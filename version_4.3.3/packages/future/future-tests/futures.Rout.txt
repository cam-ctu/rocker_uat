
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:20:40.996] plan(): Setting new future strategy stack:
[16:20:40.996] List of future strategies:
[16:20:40.996] 1. sequential:
[16:20:40.996]    - args: function (..., envir = parent.frame())
[16:20:40.996]    - tweaked: FALSE
[16:20:40.996]    - call: future::plan("sequential")
[16:20:41.010] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[16:20:41.062] plan(): Setting new future strategy stack:
[16:20:41.062] List of future strategies:
[16:20:41.062] 1. sequential:
[16:20:41.062]    - args: function (..., envir = parent.frame())
[16:20:41.062]    - tweaked: FALSE
[16:20:41.062]    - call: plan(strategy)
[16:20:41.074] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[16:20:41.075] getGlobalsAndPackages() ...
[16:20:41.075] Searching for globals...
[16:20:41.077] 
[16:20:41.077] Searching for globals ... DONE
[16:20:41.077] - globals: [0] <none>
[16:20:41.077] getGlobalsAndPackages() ... DONE
[16:20:41.078] run() for ‘Future’ ...
[16:20:41.078] - state: ‘created’
[16:20:41.078] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.079] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.079]   - Field: ‘label’
[16:20:41.079]   - Field: ‘local’
[16:20:41.079]   - Field: ‘owner’
[16:20:41.079]   - Field: ‘envir’
[16:20:41.079]   - Field: ‘packages’
[16:20:41.079]   - Field: ‘gc’
[16:20:41.079]   - Field: ‘conditions’
[16:20:41.079]   - Field: ‘expr’
[16:20:41.080]   - Field: ‘uuid’
[16:20:41.080]   - Field: ‘seed’
[16:20:41.080]   - Field: ‘version’
[16:20:41.080]   - Field: ‘result’
[16:20:41.080]   - Field: ‘asynchronous’
[16:20:41.080]   - Field: ‘calls’
[16:20:41.080]   - Field: ‘globals’
[16:20:41.080]   - Field: ‘stdout’
[16:20:41.080]   - Field: ‘earlySignal’
[16:20:41.080]   - Field: ‘lazy’
[16:20:41.080]   - Field: ‘state’
[16:20:41.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.081] - Launch lazy future ...
[16:20:41.082] Packages needed by the future expression (n = 0): <none>
[16:20:41.082] Packages needed by future strategies (n = 0): <none>
[16:20:41.082] {
[16:20:41.082]     {
[16:20:41.082]         {
[16:20:41.082]             ...future.startTime <- base::Sys.time()
[16:20:41.082]             {
[16:20:41.082]                 {
[16:20:41.082]                   {
[16:20:41.082]                     base::local({
[16:20:41.082]                       has_future <- base::requireNamespace("future", 
[16:20:41.082]                         quietly = TRUE)
[16:20:41.082]                       if (has_future) {
[16:20:41.082]                         ns <- base::getNamespace("future")
[16:20:41.082]                         version <- ns[[".package"]][["version"]]
[16:20:41.082]                         if (is.null(version)) 
[16:20:41.082]                           version <- utils::packageVersion("future")
[16:20:41.082]                       }
[16:20:41.082]                       else {
[16:20:41.082]                         version <- NULL
[16:20:41.082]                       }
[16:20:41.082]                       if (!has_future || version < "1.8.0") {
[16:20:41.082]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.082]                           "", base::R.version$version.string), 
[16:20:41.082]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.082]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.082]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.082]                             "release", "version")], collapse = " "), 
[16:20:41.082]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.082]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.082]                           info)
[16:20:41.082]                         info <- base::paste(info, collapse = "; ")
[16:20:41.082]                         if (!has_future) {
[16:20:41.082]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.082]                             info)
[16:20:41.082]                         }
[16:20:41.082]                         else {
[16:20:41.082]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.082]                             info, version)
[16:20:41.082]                         }
[16:20:41.082]                         base::stop(msg)
[16:20:41.082]                       }
[16:20:41.082]                     })
[16:20:41.082]                   }
[16:20:41.082]                   ...future.strategy.old <- future::plan("list")
[16:20:41.082]                   options(future.plan = NULL)
[16:20:41.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.082]                 }
[16:20:41.082]                 ...future.workdir <- getwd()
[16:20:41.082]             }
[16:20:41.082]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.082]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.082]         }
[16:20:41.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.082]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.082]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.082]             base::names(...future.oldOptions))
[16:20:41.082]     }
[16:20:41.082]     if (FALSE) {
[16:20:41.082]     }
[16:20:41.082]     else {
[16:20:41.082]         if (TRUE) {
[16:20:41.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.082]                 open = "w")
[16:20:41.082]         }
[16:20:41.082]         else {
[16:20:41.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.082]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.082]         }
[16:20:41.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.082]             base::sink(type = "output", split = FALSE)
[16:20:41.082]             base::close(...future.stdout)
[16:20:41.082]         }, add = TRUE)
[16:20:41.082]     }
[16:20:41.082]     ...future.frame <- base::sys.nframe()
[16:20:41.082]     ...future.conditions <- base::list()
[16:20:41.082]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.082]     if (FALSE) {
[16:20:41.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.082]     }
[16:20:41.082]     ...future.result <- base::tryCatch({
[16:20:41.082]         base::withCallingHandlers({
[16:20:41.082]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.082]             future::FutureResult(value = ...future.value$value, 
[16:20:41.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.082]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.082]                     ...future.globalenv.names))
[16:20:41.082]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.082]         }, condition = base::local({
[16:20:41.082]             c <- base::c
[16:20:41.082]             inherits <- base::inherits
[16:20:41.082]             invokeRestart <- base::invokeRestart
[16:20:41.082]             length <- base::length
[16:20:41.082]             list <- base::list
[16:20:41.082]             seq.int <- base::seq.int
[16:20:41.082]             signalCondition <- base::signalCondition
[16:20:41.082]             sys.calls <- base::sys.calls
[16:20:41.082]             `[[` <- base::`[[`
[16:20:41.082]             `+` <- base::`+`
[16:20:41.082]             `<<-` <- base::`<<-`
[16:20:41.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.082]                   3L)]
[16:20:41.082]             }
[16:20:41.082]             function(cond) {
[16:20:41.082]                 is_error <- inherits(cond, "error")
[16:20:41.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.082]                   NULL)
[16:20:41.082]                 if (is_error) {
[16:20:41.082]                   sessionInformation <- function() {
[16:20:41.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.082]                       search = base::search(), system = base::Sys.info())
[16:20:41.082]                   }
[16:20:41.082]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.082]                     cond$call), session = sessionInformation(), 
[16:20:41.082]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.082]                   signalCondition(cond)
[16:20:41.082]                 }
[16:20:41.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.082]                 "immediateCondition"))) {
[16:20:41.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.082]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.082]                   if (TRUE && !signal) {
[16:20:41.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.082]                     {
[16:20:41.082]                       inherits <- base::inherits
[16:20:41.082]                       invokeRestart <- base::invokeRestart
[16:20:41.082]                       is.null <- base::is.null
[16:20:41.082]                       muffled <- FALSE
[16:20:41.082]                       if (inherits(cond, "message")) {
[16:20:41.082]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.082]                         if (muffled) 
[16:20:41.082]                           invokeRestart("muffleMessage")
[16:20:41.082]                       }
[16:20:41.082]                       else if (inherits(cond, "warning")) {
[16:20:41.082]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.082]                         if (muffled) 
[16:20:41.082]                           invokeRestart("muffleWarning")
[16:20:41.082]                       }
[16:20:41.082]                       else if (inherits(cond, "condition")) {
[16:20:41.082]                         if (!is.null(pattern)) {
[16:20:41.082]                           computeRestarts <- base::computeRestarts
[16:20:41.082]                           grepl <- base::grepl
[16:20:41.082]                           restarts <- computeRestarts(cond)
[16:20:41.082]                           for (restart in restarts) {
[16:20:41.082]                             name <- restart$name
[16:20:41.082]                             if (is.null(name)) 
[16:20:41.082]                               next
[16:20:41.082]                             if (!grepl(pattern, name)) 
[16:20:41.082]                               next
[16:20:41.082]                             invokeRestart(restart)
[16:20:41.082]                             muffled <- TRUE
[16:20:41.082]                             break
[16:20:41.082]                           }
[16:20:41.082]                         }
[16:20:41.082]                       }
[16:20:41.082]                       invisible(muffled)
[16:20:41.082]                     }
[16:20:41.082]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.082]                   }
[16:20:41.082]                 }
[16:20:41.082]                 else {
[16:20:41.082]                   if (TRUE) {
[16:20:41.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.082]                     {
[16:20:41.082]                       inherits <- base::inherits
[16:20:41.082]                       invokeRestart <- base::invokeRestart
[16:20:41.082]                       is.null <- base::is.null
[16:20:41.082]                       muffled <- FALSE
[16:20:41.082]                       if (inherits(cond, "message")) {
[16:20:41.082]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.082]                         if (muffled) 
[16:20:41.082]                           invokeRestart("muffleMessage")
[16:20:41.082]                       }
[16:20:41.082]                       else if (inherits(cond, "warning")) {
[16:20:41.082]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.082]                         if (muffled) 
[16:20:41.082]                           invokeRestart("muffleWarning")
[16:20:41.082]                       }
[16:20:41.082]                       else if (inherits(cond, "condition")) {
[16:20:41.082]                         if (!is.null(pattern)) {
[16:20:41.082]                           computeRestarts <- base::computeRestarts
[16:20:41.082]                           grepl <- base::grepl
[16:20:41.082]                           restarts <- computeRestarts(cond)
[16:20:41.082]                           for (restart in restarts) {
[16:20:41.082]                             name <- restart$name
[16:20:41.082]                             if (is.null(name)) 
[16:20:41.082]                               next
[16:20:41.082]                             if (!grepl(pattern, name)) 
[16:20:41.082]                               next
[16:20:41.082]                             invokeRestart(restart)
[16:20:41.082]                             muffled <- TRUE
[16:20:41.082]                             break
[16:20:41.082]                           }
[16:20:41.082]                         }
[16:20:41.082]                       }
[16:20:41.082]                       invisible(muffled)
[16:20:41.082]                     }
[16:20:41.082]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.082]                   }
[16:20:41.082]                 }
[16:20:41.082]             }
[16:20:41.082]         }))
[16:20:41.082]     }, error = function(ex) {
[16:20:41.082]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.082]                 ...future.rng), started = ...future.startTime, 
[16:20:41.082]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.082]             version = "1.8"), class = "FutureResult")
[16:20:41.082]     }, finally = {
[16:20:41.082]         if (!identical(...future.workdir, getwd())) 
[16:20:41.082]             setwd(...future.workdir)
[16:20:41.082]         {
[16:20:41.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.082]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.082]             }
[16:20:41.082]             base::options(...future.oldOptions)
[16:20:41.082]             if (.Platform$OS.type == "windows") {
[16:20:41.082]                 old_names <- names(...future.oldEnvVars)
[16:20:41.082]                 envs <- base::Sys.getenv()
[16:20:41.082]                 names <- names(envs)
[16:20:41.082]                 common <- intersect(names, old_names)
[16:20:41.082]                 added <- setdiff(names, old_names)
[16:20:41.082]                 removed <- setdiff(old_names, names)
[16:20:41.082]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.082]                   envs[common]]
[16:20:41.082]                 NAMES <- toupper(changed)
[16:20:41.082]                 args <- list()
[16:20:41.082]                 for (kk in seq_along(NAMES)) {
[16:20:41.082]                   name <- changed[[kk]]
[16:20:41.082]                   NAME <- NAMES[[kk]]
[16:20:41.082]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.082]                     next
[16:20:41.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.082]                 }
[16:20:41.082]                 NAMES <- toupper(added)
[16:20:41.082]                 for (kk in seq_along(NAMES)) {
[16:20:41.082]                   name <- added[[kk]]
[16:20:41.082]                   NAME <- NAMES[[kk]]
[16:20:41.082]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.082]                     next
[16:20:41.082]                   args[[name]] <- ""
[16:20:41.082]                 }
[16:20:41.082]                 NAMES <- toupper(removed)
[16:20:41.082]                 for (kk in seq_along(NAMES)) {
[16:20:41.082]                   name <- removed[[kk]]
[16:20:41.082]                   NAME <- NAMES[[kk]]
[16:20:41.082]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.082]                     next
[16:20:41.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.082]                 }
[16:20:41.082]                 if (length(args) > 0) 
[16:20:41.082]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.082]             }
[16:20:41.082]             else {
[16:20:41.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.082]             }
[16:20:41.082]             {
[16:20:41.082]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.082]                   0L) {
[16:20:41.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.082]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.082]                   base::options(opts)
[16:20:41.082]                 }
[16:20:41.082]                 {
[16:20:41.082]                   {
[16:20:41.082]                     NULL
[16:20:41.082]                     RNGkind("Mersenne-Twister")
[16:20:41.082]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.082]                       inherits = FALSE)
[16:20:41.082]                   }
[16:20:41.082]                   options(future.plan = NULL)
[16:20:41.082]                   if (is.na(NA_character_)) 
[16:20:41.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.082]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.082]                     .init = FALSE)
[16:20:41.082]                 }
[16:20:41.082]             }
[16:20:41.082]         }
[16:20:41.082]     })
[16:20:41.082]     if (TRUE) {
[16:20:41.082]         base::sink(type = "output", split = FALSE)
[16:20:41.082]         if (TRUE) {
[16:20:41.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.082]         }
[16:20:41.082]         else {
[16:20:41.082]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.082]         }
[16:20:41.082]         base::close(...future.stdout)
[16:20:41.082]         ...future.stdout <- NULL
[16:20:41.082]     }
[16:20:41.082]     ...future.result$conditions <- ...future.conditions
[16:20:41.082]     ...future.result$finished <- base::Sys.time()
[16:20:41.082]     ...future.result
[16:20:41.082] }
[16:20:41.084] plan(): Setting new future strategy stack:
[16:20:41.084] List of future strategies:
[16:20:41.084] 1. sequential:
[16:20:41.084]    - args: function (..., envir = parent.frame())
[16:20:41.084]    - tweaked: FALSE
[16:20:41.084]    - call: NULL
[16:20:41.085] plan(): nbrOfWorkers() = 1
[16:20:41.086] plan(): Setting new future strategy stack:
[16:20:41.086] List of future strategies:
[16:20:41.086] 1. sequential:
[16:20:41.086]    - args: function (..., envir = parent.frame())
[16:20:41.086]    - tweaked: FALSE
[16:20:41.086]    - call: plan(strategy)
[16:20:41.086] plan(): nbrOfWorkers() = 1
[16:20:41.087] SequentialFuture started (and completed)
[16:20:41.087] - Launch lazy future ... done
[16:20:41.087] run() for ‘SequentialFuture’ ... done
[16:20:41.087] getGlobalsAndPackages() ...
[16:20:41.087] Searching for globals...
[16:20:41.088] 
[16:20:41.088] Searching for globals ... DONE
[16:20:41.088] - globals: [0] <none>
[16:20:41.088] getGlobalsAndPackages() ... DONE
[16:20:41.088] run() for ‘Future’ ...
[16:20:41.088] - state: ‘created’
[16:20:41.088] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.089] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.089] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.089]   - Field: ‘label’
[16:20:41.089]   - Field: ‘local’
[16:20:41.089]   - Field: ‘owner’
[16:20:41.089]   - Field: ‘envir’
[16:20:41.089]   - Field: ‘packages’
[16:20:41.089]   - Field: ‘gc’
[16:20:41.089]   - Field: ‘conditions’
[16:20:41.089]   - Field: ‘expr’
[16:20:41.090]   - Field: ‘uuid’
[16:20:41.090]   - Field: ‘seed’
[16:20:41.090]   - Field: ‘version’
[16:20:41.090]   - Field: ‘result’
[16:20:41.090]   - Field: ‘asynchronous’
[16:20:41.090]   - Field: ‘calls’
[16:20:41.090]   - Field: ‘globals’
[16:20:41.090]   - Field: ‘stdout’
[16:20:41.090]   - Field: ‘earlySignal’
[16:20:41.090]   - Field: ‘lazy’
[16:20:41.090]   - Field: ‘state’
[16:20:41.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.091] - Launch lazy future ...
[16:20:41.091] Packages needed by the future expression (n = 0): <none>
[16:20:41.091] Packages needed by future strategies (n = 0): <none>
[16:20:41.091] {
[16:20:41.091]     {
[16:20:41.091]         {
[16:20:41.091]             ...future.startTime <- base::Sys.time()
[16:20:41.091]             {
[16:20:41.091]                 {
[16:20:41.091]                   {
[16:20:41.091]                     base::local({
[16:20:41.091]                       has_future <- base::requireNamespace("future", 
[16:20:41.091]                         quietly = TRUE)
[16:20:41.091]                       if (has_future) {
[16:20:41.091]                         ns <- base::getNamespace("future")
[16:20:41.091]                         version <- ns[[".package"]][["version"]]
[16:20:41.091]                         if (is.null(version)) 
[16:20:41.091]                           version <- utils::packageVersion("future")
[16:20:41.091]                       }
[16:20:41.091]                       else {
[16:20:41.091]                         version <- NULL
[16:20:41.091]                       }
[16:20:41.091]                       if (!has_future || version < "1.8.0") {
[16:20:41.091]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.091]                           "", base::R.version$version.string), 
[16:20:41.091]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.091]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.091]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.091]                             "release", "version")], collapse = " "), 
[16:20:41.091]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.091]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.091]                           info)
[16:20:41.091]                         info <- base::paste(info, collapse = "; ")
[16:20:41.091]                         if (!has_future) {
[16:20:41.091]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.091]                             info)
[16:20:41.091]                         }
[16:20:41.091]                         else {
[16:20:41.091]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.091]                             info, version)
[16:20:41.091]                         }
[16:20:41.091]                         base::stop(msg)
[16:20:41.091]                       }
[16:20:41.091]                     })
[16:20:41.091]                   }
[16:20:41.091]                   ...future.strategy.old <- future::plan("list")
[16:20:41.091]                   options(future.plan = NULL)
[16:20:41.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.091]                 }
[16:20:41.091]                 ...future.workdir <- getwd()
[16:20:41.091]             }
[16:20:41.091]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.091]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.091]         }
[16:20:41.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.091]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.091]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.091]             base::names(...future.oldOptions))
[16:20:41.091]     }
[16:20:41.091]     if (FALSE) {
[16:20:41.091]     }
[16:20:41.091]     else {
[16:20:41.091]         if (TRUE) {
[16:20:41.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.091]                 open = "w")
[16:20:41.091]         }
[16:20:41.091]         else {
[16:20:41.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.091]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.091]         }
[16:20:41.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.091]             base::sink(type = "output", split = FALSE)
[16:20:41.091]             base::close(...future.stdout)
[16:20:41.091]         }, add = TRUE)
[16:20:41.091]     }
[16:20:41.091]     ...future.frame <- base::sys.nframe()
[16:20:41.091]     ...future.conditions <- base::list()
[16:20:41.091]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.091]     if (FALSE) {
[16:20:41.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.091]     }
[16:20:41.091]     ...future.result <- base::tryCatch({
[16:20:41.091]         base::withCallingHandlers({
[16:20:41.091]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.091]             future::FutureResult(value = ...future.value$value, 
[16:20:41.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.091]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.091]                     ...future.globalenv.names))
[16:20:41.091]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.091]         }, condition = base::local({
[16:20:41.091]             c <- base::c
[16:20:41.091]             inherits <- base::inherits
[16:20:41.091]             invokeRestart <- base::invokeRestart
[16:20:41.091]             length <- base::length
[16:20:41.091]             list <- base::list
[16:20:41.091]             seq.int <- base::seq.int
[16:20:41.091]             signalCondition <- base::signalCondition
[16:20:41.091]             sys.calls <- base::sys.calls
[16:20:41.091]             `[[` <- base::`[[`
[16:20:41.091]             `+` <- base::`+`
[16:20:41.091]             `<<-` <- base::`<<-`
[16:20:41.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.091]                   3L)]
[16:20:41.091]             }
[16:20:41.091]             function(cond) {
[16:20:41.091]                 is_error <- inherits(cond, "error")
[16:20:41.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.091]                   NULL)
[16:20:41.091]                 if (is_error) {
[16:20:41.091]                   sessionInformation <- function() {
[16:20:41.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.091]                       search = base::search(), system = base::Sys.info())
[16:20:41.091]                   }
[16:20:41.091]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.091]                     cond$call), session = sessionInformation(), 
[16:20:41.091]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.091]                   signalCondition(cond)
[16:20:41.091]                 }
[16:20:41.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.091]                 "immediateCondition"))) {
[16:20:41.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.091]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.091]                   if (TRUE && !signal) {
[16:20:41.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.091]                     {
[16:20:41.091]                       inherits <- base::inherits
[16:20:41.091]                       invokeRestart <- base::invokeRestart
[16:20:41.091]                       is.null <- base::is.null
[16:20:41.091]                       muffled <- FALSE
[16:20:41.091]                       if (inherits(cond, "message")) {
[16:20:41.091]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.091]                         if (muffled) 
[16:20:41.091]                           invokeRestart("muffleMessage")
[16:20:41.091]                       }
[16:20:41.091]                       else if (inherits(cond, "warning")) {
[16:20:41.091]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.091]                         if (muffled) 
[16:20:41.091]                           invokeRestart("muffleWarning")
[16:20:41.091]                       }
[16:20:41.091]                       else if (inherits(cond, "condition")) {
[16:20:41.091]                         if (!is.null(pattern)) {
[16:20:41.091]                           computeRestarts <- base::computeRestarts
[16:20:41.091]                           grepl <- base::grepl
[16:20:41.091]                           restarts <- computeRestarts(cond)
[16:20:41.091]                           for (restart in restarts) {
[16:20:41.091]                             name <- restart$name
[16:20:41.091]                             if (is.null(name)) 
[16:20:41.091]                               next
[16:20:41.091]                             if (!grepl(pattern, name)) 
[16:20:41.091]                               next
[16:20:41.091]                             invokeRestart(restart)
[16:20:41.091]                             muffled <- TRUE
[16:20:41.091]                             break
[16:20:41.091]                           }
[16:20:41.091]                         }
[16:20:41.091]                       }
[16:20:41.091]                       invisible(muffled)
[16:20:41.091]                     }
[16:20:41.091]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.091]                   }
[16:20:41.091]                 }
[16:20:41.091]                 else {
[16:20:41.091]                   if (TRUE) {
[16:20:41.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.091]                     {
[16:20:41.091]                       inherits <- base::inherits
[16:20:41.091]                       invokeRestart <- base::invokeRestart
[16:20:41.091]                       is.null <- base::is.null
[16:20:41.091]                       muffled <- FALSE
[16:20:41.091]                       if (inherits(cond, "message")) {
[16:20:41.091]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.091]                         if (muffled) 
[16:20:41.091]                           invokeRestart("muffleMessage")
[16:20:41.091]                       }
[16:20:41.091]                       else if (inherits(cond, "warning")) {
[16:20:41.091]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.091]                         if (muffled) 
[16:20:41.091]                           invokeRestart("muffleWarning")
[16:20:41.091]                       }
[16:20:41.091]                       else if (inherits(cond, "condition")) {
[16:20:41.091]                         if (!is.null(pattern)) {
[16:20:41.091]                           computeRestarts <- base::computeRestarts
[16:20:41.091]                           grepl <- base::grepl
[16:20:41.091]                           restarts <- computeRestarts(cond)
[16:20:41.091]                           for (restart in restarts) {
[16:20:41.091]                             name <- restart$name
[16:20:41.091]                             if (is.null(name)) 
[16:20:41.091]                               next
[16:20:41.091]                             if (!grepl(pattern, name)) 
[16:20:41.091]                               next
[16:20:41.091]                             invokeRestart(restart)
[16:20:41.091]                             muffled <- TRUE
[16:20:41.091]                             break
[16:20:41.091]                           }
[16:20:41.091]                         }
[16:20:41.091]                       }
[16:20:41.091]                       invisible(muffled)
[16:20:41.091]                     }
[16:20:41.091]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.091]                   }
[16:20:41.091]                 }
[16:20:41.091]             }
[16:20:41.091]         }))
[16:20:41.091]     }, error = function(ex) {
[16:20:41.091]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.091]                 ...future.rng), started = ...future.startTime, 
[16:20:41.091]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.091]             version = "1.8"), class = "FutureResult")
[16:20:41.091]     }, finally = {
[16:20:41.091]         if (!identical(...future.workdir, getwd())) 
[16:20:41.091]             setwd(...future.workdir)
[16:20:41.091]         {
[16:20:41.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.091]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.091]             }
[16:20:41.091]             base::options(...future.oldOptions)
[16:20:41.091]             if (.Platform$OS.type == "windows") {
[16:20:41.091]                 old_names <- names(...future.oldEnvVars)
[16:20:41.091]                 envs <- base::Sys.getenv()
[16:20:41.091]                 names <- names(envs)
[16:20:41.091]                 common <- intersect(names, old_names)
[16:20:41.091]                 added <- setdiff(names, old_names)
[16:20:41.091]                 removed <- setdiff(old_names, names)
[16:20:41.091]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.091]                   envs[common]]
[16:20:41.091]                 NAMES <- toupper(changed)
[16:20:41.091]                 args <- list()
[16:20:41.091]                 for (kk in seq_along(NAMES)) {
[16:20:41.091]                   name <- changed[[kk]]
[16:20:41.091]                   NAME <- NAMES[[kk]]
[16:20:41.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.091]                     next
[16:20:41.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.091]                 }
[16:20:41.091]                 NAMES <- toupper(added)
[16:20:41.091]                 for (kk in seq_along(NAMES)) {
[16:20:41.091]                   name <- added[[kk]]
[16:20:41.091]                   NAME <- NAMES[[kk]]
[16:20:41.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.091]                     next
[16:20:41.091]                   args[[name]] <- ""
[16:20:41.091]                 }
[16:20:41.091]                 NAMES <- toupper(removed)
[16:20:41.091]                 for (kk in seq_along(NAMES)) {
[16:20:41.091]                   name <- removed[[kk]]
[16:20:41.091]                   NAME <- NAMES[[kk]]
[16:20:41.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.091]                     next
[16:20:41.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.091]                 }
[16:20:41.091]                 if (length(args) > 0) 
[16:20:41.091]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.091]             }
[16:20:41.091]             else {
[16:20:41.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.091]             }
[16:20:41.091]             {
[16:20:41.091]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.091]                   0L) {
[16:20:41.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.091]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.091]                   base::options(opts)
[16:20:41.091]                 }
[16:20:41.091]                 {
[16:20:41.091]                   {
[16:20:41.091]                     NULL
[16:20:41.091]                     RNGkind("Mersenne-Twister")
[16:20:41.091]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.091]                       inherits = FALSE)
[16:20:41.091]                   }
[16:20:41.091]                   options(future.plan = NULL)
[16:20:41.091]                   if (is.na(NA_character_)) 
[16:20:41.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.091]                     .init = FALSE)
[16:20:41.091]                 }
[16:20:41.091]             }
[16:20:41.091]         }
[16:20:41.091]     })
[16:20:41.091]     if (TRUE) {
[16:20:41.091]         base::sink(type = "output", split = FALSE)
[16:20:41.091]         if (TRUE) {
[16:20:41.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.091]         }
[16:20:41.091]         else {
[16:20:41.091]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.091]         }
[16:20:41.091]         base::close(...future.stdout)
[16:20:41.091]         ...future.stdout <- NULL
[16:20:41.091]     }
[16:20:41.091]     ...future.result$conditions <- ...future.conditions
[16:20:41.091]     ...future.result$finished <- base::Sys.time()
[16:20:41.091]     ...future.result
[16:20:41.091] }
[16:20:41.093] plan(): Setting new future strategy stack:
[16:20:41.093] List of future strategies:
[16:20:41.093] 1. sequential:
[16:20:41.093]    - args: function (..., envir = parent.frame())
[16:20:41.093]    - tweaked: FALSE
[16:20:41.093]    - call: NULL
[16:20:41.093] plan(): nbrOfWorkers() = 1
[16:20:41.094] plan(): Setting new future strategy stack:
[16:20:41.094] List of future strategies:
[16:20:41.094] 1. sequential:
[16:20:41.094]    - args: function (..., envir = parent.frame())
[16:20:41.094]    - tweaked: FALSE
[16:20:41.094]    - call: plan(strategy)
[16:20:41.095] plan(): nbrOfWorkers() = 1
[16:20:41.095] SequentialFuture started (and completed)
[16:20:41.095] - Launch lazy future ... done
[16:20:41.095] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0b727500> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0be9f258> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0b727500> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0be9f258> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:20:41.101] resolved() for ‘SequentialFuture’ ...
[16:20:41.101] - state: ‘finished’
[16:20:41.101] - run: TRUE
[16:20:41.101] - result: ‘FutureResult’
[16:20:41.101] resolved() for ‘SequentialFuture’ ... done
[16:20:41.101] resolved() for ‘SequentialFuture’ ...
[16:20:41.102] - state: ‘finished’
[16:20:41.102] - run: TRUE
[16:20:41.102] - result: ‘FutureResult’
[16:20:41.102] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:41.103] resolve() on list ...
[16:20:41.103]  recursive: 0
[16:20:41.103]  length: 6
[16:20:41.103]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:41.103] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.104] - nx: 6
[16:20:41.104] - relay: TRUE
[16:20:41.104] - stdout: TRUE
[16:20:41.104] - signal: TRUE
[16:20:41.104] - resignal: FALSE
[16:20:41.104] - force: TRUE
[16:20:41.104] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.104] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.104]  - until=2
[16:20:41.104]  - relaying element #2
[16:20:41.104] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.104] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.105] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.105]  length: 5 (resolved future 1)
[16:20:41.105] resolved() for ‘SequentialFuture’ ...
[16:20:41.105] - state: ‘finished’
[16:20:41.105] - run: TRUE
[16:20:41.105] - result: ‘FutureResult’
[16:20:41.105] resolved() for ‘SequentialFuture’ ... done
[16:20:41.105] Future #2
[16:20:41.106] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.106] - nx: 6
[16:20:41.106] - relay: TRUE
[16:20:41.106] - stdout: TRUE
[16:20:41.106] - signal: TRUE
[16:20:41.106] - resignal: FALSE
[16:20:41.106] - force: TRUE
[16:20:41.106] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.106] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.106]  - until=2
[16:20:41.106]  - relaying element #2
[16:20:41.107] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.107] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.107] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.109]  length: 4 (resolved future 2)
[16:20:41.109] resolved() for ‘SequentialFuture’ ...
[16:20:41.109] - state: ‘finished’
[16:20:41.109] - run: TRUE
[16:20:41.109] - result: ‘FutureResult’
[16:20:41.109] resolved() for ‘SequentialFuture’ ... done
[16:20:41.109] Future #3
[16:20:41.110] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.110] - nx: 6
[16:20:41.110] - relay: TRUE
[16:20:41.110] - stdout: TRUE
[16:20:41.110] - signal: TRUE
[16:20:41.110] - resignal: FALSE
[16:20:41.110] - force: TRUE
[16:20:41.110] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.110] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.110]  - until=3
[16:20:41.110]  - relaying element #3
[16:20:41.111] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.111] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.111] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.111]  length: 3 (resolved future 3)
[16:20:41.111] signalConditionsASAP(NULL, pos=4) ...
[16:20:41.111] - nx: 6
[16:20:41.111] - relay: TRUE
[16:20:41.111] - stdout: TRUE
[16:20:41.111] - signal: TRUE
[16:20:41.111] - resignal: FALSE
[16:20:41.111] - force: TRUE
[16:20:41.112] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.112] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.112]  - until=5
[16:20:41.112]  - relaying element #5
[16:20:41.112] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.112] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.112] signalConditionsASAP(NULL, pos=4) ... done
[16:20:41.112]  length: 2 (resolved future 4)
[16:20:41.112] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.112] - nx: 6
[16:20:41.112] - relay: TRUE
[16:20:41.113] - stdout: TRUE
[16:20:41.113] - signal: TRUE
[16:20:41.113] - resignal: FALSE
[16:20:41.113] - force: TRUE
[16:20:41.113] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.113] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.113]  - until=6
[16:20:41.113]  - relaying element #6
[16:20:41.113] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.113] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.113] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.113]  length: 1 (resolved future 5)
[16:20:41.114] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.114] - nx: 6
[16:20:41.114] - relay: TRUE
[16:20:41.114] - stdout: TRUE
[16:20:41.114] - signal: TRUE
[16:20:41.114] - resignal: FALSE
[16:20:41.114] - force: TRUE
[16:20:41.114] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.114] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.114]  - until=6
[16:20:41.114] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.114] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.114] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.115]  length: 0 (resolved future 6)
[16:20:41.115] Relaying remaining futures
[16:20:41.115] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.115] - nx: 6
[16:20:41.115] - relay: TRUE
[16:20:41.115] - stdout: TRUE
[16:20:41.115] - signal: TRUE
[16:20:41.115] - resignal: FALSE
[16:20:41.115] - force: TRUE
[16:20:41.115] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.115] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:41.115] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.116] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.116] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.116] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[16:20:41.118] getGlobalsAndPackages() ...
[16:20:41.118] Searching for globals...
[16:20:41.118] 
[16:20:41.118] Searching for globals ... DONE
[16:20:41.118] - globals: [0] <none>
[16:20:41.118] getGlobalsAndPackages() ... DONE
[16:20:41.119] run() for ‘Future’ ...
[16:20:41.119] - state: ‘created’
[16:20:41.119] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.119] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.119] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.119]   - Field: ‘label’
[16:20:41.119]   - Field: ‘local’
[16:20:41.119]   - Field: ‘owner’
[16:20:41.120]   - Field: ‘envir’
[16:20:41.120]   - Field: ‘packages’
[16:20:41.120]   - Field: ‘gc’
[16:20:41.120]   - Field: ‘conditions’
[16:20:41.120]   - Field: ‘expr’
[16:20:41.120]   - Field: ‘uuid’
[16:20:41.120]   - Field: ‘seed’
[16:20:41.120]   - Field: ‘version’
[16:20:41.120]   - Field: ‘result’
[16:20:41.120]   - Field: ‘asynchronous’
[16:20:41.120]   - Field: ‘calls’
[16:20:41.121]   - Field: ‘globals’
[16:20:41.121]   - Field: ‘stdout’
[16:20:41.121]   - Field: ‘earlySignal’
[16:20:41.121]   - Field: ‘lazy’
[16:20:41.121]   - Field: ‘state’
[16:20:41.121] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.121] - Launch lazy future ...
[16:20:41.121] Packages needed by the future expression (n = 0): <none>
[16:20:41.121] Packages needed by future strategies (n = 0): <none>
[16:20:41.122] {
[16:20:41.122]     {
[16:20:41.122]         {
[16:20:41.122]             ...future.startTime <- base::Sys.time()
[16:20:41.122]             {
[16:20:41.122]                 {
[16:20:41.122]                   {
[16:20:41.122]                     base::local({
[16:20:41.122]                       has_future <- base::requireNamespace("future", 
[16:20:41.122]                         quietly = TRUE)
[16:20:41.122]                       if (has_future) {
[16:20:41.122]                         ns <- base::getNamespace("future")
[16:20:41.122]                         version <- ns[[".package"]][["version"]]
[16:20:41.122]                         if (is.null(version)) 
[16:20:41.122]                           version <- utils::packageVersion("future")
[16:20:41.122]                       }
[16:20:41.122]                       else {
[16:20:41.122]                         version <- NULL
[16:20:41.122]                       }
[16:20:41.122]                       if (!has_future || version < "1.8.0") {
[16:20:41.122]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.122]                           "", base::R.version$version.string), 
[16:20:41.122]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.122]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.122]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.122]                             "release", "version")], collapse = " "), 
[16:20:41.122]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.122]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.122]                           info)
[16:20:41.122]                         info <- base::paste(info, collapse = "; ")
[16:20:41.122]                         if (!has_future) {
[16:20:41.122]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.122]                             info)
[16:20:41.122]                         }
[16:20:41.122]                         else {
[16:20:41.122]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.122]                             info, version)
[16:20:41.122]                         }
[16:20:41.122]                         base::stop(msg)
[16:20:41.122]                       }
[16:20:41.122]                     })
[16:20:41.122]                   }
[16:20:41.122]                   ...future.strategy.old <- future::plan("list")
[16:20:41.122]                   options(future.plan = NULL)
[16:20:41.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.122]                 }
[16:20:41.122]                 ...future.workdir <- getwd()
[16:20:41.122]             }
[16:20:41.122]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.122]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.122]         }
[16:20:41.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.122]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.122]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.122]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.122]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.122]             base::names(...future.oldOptions))
[16:20:41.122]     }
[16:20:41.122]     if (FALSE) {
[16:20:41.122]     }
[16:20:41.122]     else {
[16:20:41.122]         if (TRUE) {
[16:20:41.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.122]                 open = "w")
[16:20:41.122]         }
[16:20:41.122]         else {
[16:20:41.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.122]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.122]         }
[16:20:41.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.122]             base::sink(type = "output", split = FALSE)
[16:20:41.122]             base::close(...future.stdout)
[16:20:41.122]         }, add = TRUE)
[16:20:41.122]     }
[16:20:41.122]     ...future.frame <- base::sys.nframe()
[16:20:41.122]     ...future.conditions <- base::list()
[16:20:41.122]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.122]     if (FALSE) {
[16:20:41.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.122]     }
[16:20:41.122]     ...future.result <- base::tryCatch({
[16:20:41.122]         base::withCallingHandlers({
[16:20:41.122]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.122]             future::FutureResult(value = ...future.value$value, 
[16:20:41.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.122]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.122]                     ...future.globalenv.names))
[16:20:41.122]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.122]         }, condition = base::local({
[16:20:41.122]             c <- base::c
[16:20:41.122]             inherits <- base::inherits
[16:20:41.122]             invokeRestart <- base::invokeRestart
[16:20:41.122]             length <- base::length
[16:20:41.122]             list <- base::list
[16:20:41.122]             seq.int <- base::seq.int
[16:20:41.122]             signalCondition <- base::signalCondition
[16:20:41.122]             sys.calls <- base::sys.calls
[16:20:41.122]             `[[` <- base::`[[`
[16:20:41.122]             `+` <- base::`+`
[16:20:41.122]             `<<-` <- base::`<<-`
[16:20:41.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.122]                   3L)]
[16:20:41.122]             }
[16:20:41.122]             function(cond) {
[16:20:41.122]                 is_error <- inherits(cond, "error")
[16:20:41.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.122]                   NULL)
[16:20:41.122]                 if (is_error) {
[16:20:41.122]                   sessionInformation <- function() {
[16:20:41.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.122]                       search = base::search(), system = base::Sys.info())
[16:20:41.122]                   }
[16:20:41.122]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.122]                     cond$call), session = sessionInformation(), 
[16:20:41.122]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.122]                   signalCondition(cond)
[16:20:41.122]                 }
[16:20:41.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.122]                 "immediateCondition"))) {
[16:20:41.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.122]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.122]                   if (TRUE && !signal) {
[16:20:41.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.122]                     {
[16:20:41.122]                       inherits <- base::inherits
[16:20:41.122]                       invokeRestart <- base::invokeRestart
[16:20:41.122]                       is.null <- base::is.null
[16:20:41.122]                       muffled <- FALSE
[16:20:41.122]                       if (inherits(cond, "message")) {
[16:20:41.122]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.122]                         if (muffled) 
[16:20:41.122]                           invokeRestart("muffleMessage")
[16:20:41.122]                       }
[16:20:41.122]                       else if (inherits(cond, "warning")) {
[16:20:41.122]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.122]                         if (muffled) 
[16:20:41.122]                           invokeRestart("muffleWarning")
[16:20:41.122]                       }
[16:20:41.122]                       else if (inherits(cond, "condition")) {
[16:20:41.122]                         if (!is.null(pattern)) {
[16:20:41.122]                           computeRestarts <- base::computeRestarts
[16:20:41.122]                           grepl <- base::grepl
[16:20:41.122]                           restarts <- computeRestarts(cond)
[16:20:41.122]                           for (restart in restarts) {
[16:20:41.122]                             name <- restart$name
[16:20:41.122]                             if (is.null(name)) 
[16:20:41.122]                               next
[16:20:41.122]                             if (!grepl(pattern, name)) 
[16:20:41.122]                               next
[16:20:41.122]                             invokeRestart(restart)
[16:20:41.122]                             muffled <- TRUE
[16:20:41.122]                             break
[16:20:41.122]                           }
[16:20:41.122]                         }
[16:20:41.122]                       }
[16:20:41.122]                       invisible(muffled)
[16:20:41.122]                     }
[16:20:41.122]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.122]                   }
[16:20:41.122]                 }
[16:20:41.122]                 else {
[16:20:41.122]                   if (TRUE) {
[16:20:41.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.122]                     {
[16:20:41.122]                       inherits <- base::inherits
[16:20:41.122]                       invokeRestart <- base::invokeRestart
[16:20:41.122]                       is.null <- base::is.null
[16:20:41.122]                       muffled <- FALSE
[16:20:41.122]                       if (inherits(cond, "message")) {
[16:20:41.122]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.122]                         if (muffled) 
[16:20:41.122]                           invokeRestart("muffleMessage")
[16:20:41.122]                       }
[16:20:41.122]                       else if (inherits(cond, "warning")) {
[16:20:41.122]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.122]                         if (muffled) 
[16:20:41.122]                           invokeRestart("muffleWarning")
[16:20:41.122]                       }
[16:20:41.122]                       else if (inherits(cond, "condition")) {
[16:20:41.122]                         if (!is.null(pattern)) {
[16:20:41.122]                           computeRestarts <- base::computeRestarts
[16:20:41.122]                           grepl <- base::grepl
[16:20:41.122]                           restarts <- computeRestarts(cond)
[16:20:41.122]                           for (restart in restarts) {
[16:20:41.122]                             name <- restart$name
[16:20:41.122]                             if (is.null(name)) 
[16:20:41.122]                               next
[16:20:41.122]                             if (!grepl(pattern, name)) 
[16:20:41.122]                               next
[16:20:41.122]                             invokeRestart(restart)
[16:20:41.122]                             muffled <- TRUE
[16:20:41.122]                             break
[16:20:41.122]                           }
[16:20:41.122]                         }
[16:20:41.122]                       }
[16:20:41.122]                       invisible(muffled)
[16:20:41.122]                     }
[16:20:41.122]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.122]                   }
[16:20:41.122]                 }
[16:20:41.122]             }
[16:20:41.122]         }))
[16:20:41.122]     }, error = function(ex) {
[16:20:41.122]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.122]                 ...future.rng), started = ...future.startTime, 
[16:20:41.122]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.122]             version = "1.8"), class = "FutureResult")
[16:20:41.122]     }, finally = {
[16:20:41.122]         if (!identical(...future.workdir, getwd())) 
[16:20:41.122]             setwd(...future.workdir)
[16:20:41.122]         {
[16:20:41.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.122]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.122]             }
[16:20:41.122]             base::options(...future.oldOptions)
[16:20:41.122]             if (.Platform$OS.type == "windows") {
[16:20:41.122]                 old_names <- names(...future.oldEnvVars)
[16:20:41.122]                 envs <- base::Sys.getenv()
[16:20:41.122]                 names <- names(envs)
[16:20:41.122]                 common <- intersect(names, old_names)
[16:20:41.122]                 added <- setdiff(names, old_names)
[16:20:41.122]                 removed <- setdiff(old_names, names)
[16:20:41.122]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.122]                   envs[common]]
[16:20:41.122]                 NAMES <- toupper(changed)
[16:20:41.122]                 args <- list()
[16:20:41.122]                 for (kk in seq_along(NAMES)) {
[16:20:41.122]                   name <- changed[[kk]]
[16:20:41.122]                   NAME <- NAMES[[kk]]
[16:20:41.122]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.122]                     next
[16:20:41.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.122]                 }
[16:20:41.122]                 NAMES <- toupper(added)
[16:20:41.122]                 for (kk in seq_along(NAMES)) {
[16:20:41.122]                   name <- added[[kk]]
[16:20:41.122]                   NAME <- NAMES[[kk]]
[16:20:41.122]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.122]                     next
[16:20:41.122]                   args[[name]] <- ""
[16:20:41.122]                 }
[16:20:41.122]                 NAMES <- toupper(removed)
[16:20:41.122]                 for (kk in seq_along(NAMES)) {
[16:20:41.122]                   name <- removed[[kk]]
[16:20:41.122]                   NAME <- NAMES[[kk]]
[16:20:41.122]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.122]                     next
[16:20:41.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.122]                 }
[16:20:41.122]                 if (length(args) > 0) 
[16:20:41.122]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.122]             }
[16:20:41.122]             else {
[16:20:41.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.122]             }
[16:20:41.122]             {
[16:20:41.122]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.122]                   0L) {
[16:20:41.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.122]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.122]                   base::options(opts)
[16:20:41.122]                 }
[16:20:41.122]                 {
[16:20:41.122]                   {
[16:20:41.122]                     NULL
[16:20:41.122]                     RNGkind("Mersenne-Twister")
[16:20:41.122]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.122]                       inherits = FALSE)
[16:20:41.122]                   }
[16:20:41.122]                   options(future.plan = NULL)
[16:20:41.122]                   if (is.na(NA_character_)) 
[16:20:41.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.122]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.122]                     .init = FALSE)
[16:20:41.122]                 }
[16:20:41.122]             }
[16:20:41.122]         }
[16:20:41.122]     })
[16:20:41.122]     if (TRUE) {
[16:20:41.122]         base::sink(type = "output", split = FALSE)
[16:20:41.122]         if (TRUE) {
[16:20:41.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.122]         }
[16:20:41.122]         else {
[16:20:41.122]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.122]         }
[16:20:41.122]         base::close(...future.stdout)
[16:20:41.122]         ...future.stdout <- NULL
[16:20:41.122]     }
[16:20:41.122]     ...future.result$conditions <- ...future.conditions
[16:20:41.122]     ...future.result$finished <- base::Sys.time()
[16:20:41.122]     ...future.result
[16:20:41.122] }
[16:20:41.123] plan(): Setting new future strategy stack:
[16:20:41.123] List of future strategies:
[16:20:41.123] 1. sequential:
[16:20:41.123]    - args: function (..., envir = parent.frame())
[16:20:41.123]    - tweaked: FALSE
[16:20:41.123]    - call: NULL
[16:20:41.124] plan(): nbrOfWorkers() = 1
[16:20:41.124] plan(): Setting new future strategy stack:
[16:20:41.125] List of future strategies:
[16:20:41.125] 1. sequential:
[16:20:41.125]    - args: function (..., envir = parent.frame())
[16:20:41.125]    - tweaked: FALSE
[16:20:41.125]    - call: plan(strategy)
[16:20:41.125] plan(): nbrOfWorkers() = 1
[16:20:41.125] SequentialFuture started (and completed)
[16:20:41.125] - Launch lazy future ... done
[16:20:41.125] run() for ‘SequentialFuture’ ... done
[16:20:41.125] getGlobalsAndPackages() ...
[16:20:41.125] Searching for globals...
[16:20:41.126] 
[16:20:41.126] Searching for globals ... DONE
[16:20:41.126] - globals: [0] <none>
[16:20:41.126] getGlobalsAndPackages() ... DONE
[16:20:41.126] run() for ‘Future’ ...
[16:20:41.126] - state: ‘created’
[16:20:41.126] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.127] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.127]   - Field: ‘label’
[16:20:41.127]   - Field: ‘local’
[16:20:41.127]   - Field: ‘owner’
[16:20:41.127]   - Field: ‘envir’
[16:20:41.127]   - Field: ‘packages’
[16:20:41.127]   - Field: ‘gc’
[16:20:41.127]   - Field: ‘conditions’
[16:20:41.127]   - Field: ‘expr’
[16:20:41.128]   - Field: ‘uuid’
[16:20:41.128]   - Field: ‘seed’
[16:20:41.128]   - Field: ‘version’
[16:20:41.128]   - Field: ‘result’
[16:20:41.128]   - Field: ‘asynchronous’
[16:20:41.128]   - Field: ‘calls’
[16:20:41.128]   - Field: ‘globals’
[16:20:41.128]   - Field: ‘stdout’
[16:20:41.128]   - Field: ‘earlySignal’
[16:20:41.128]   - Field: ‘lazy’
[16:20:41.128]   - Field: ‘state’
[16:20:41.129] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.129] - Launch lazy future ...
[16:20:41.129] Packages needed by the future expression (n = 0): <none>
[16:20:41.129] Packages needed by future strategies (n = 0): <none>
[16:20:41.129] {
[16:20:41.129]     {
[16:20:41.129]         {
[16:20:41.129]             ...future.startTime <- base::Sys.time()
[16:20:41.129]             {
[16:20:41.129]                 {
[16:20:41.129]                   {
[16:20:41.129]                     base::local({
[16:20:41.129]                       has_future <- base::requireNamespace("future", 
[16:20:41.129]                         quietly = TRUE)
[16:20:41.129]                       if (has_future) {
[16:20:41.129]                         ns <- base::getNamespace("future")
[16:20:41.129]                         version <- ns[[".package"]][["version"]]
[16:20:41.129]                         if (is.null(version)) 
[16:20:41.129]                           version <- utils::packageVersion("future")
[16:20:41.129]                       }
[16:20:41.129]                       else {
[16:20:41.129]                         version <- NULL
[16:20:41.129]                       }
[16:20:41.129]                       if (!has_future || version < "1.8.0") {
[16:20:41.129]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.129]                           "", base::R.version$version.string), 
[16:20:41.129]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.129]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.129]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.129]                             "release", "version")], collapse = " "), 
[16:20:41.129]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.129]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.129]                           info)
[16:20:41.129]                         info <- base::paste(info, collapse = "; ")
[16:20:41.129]                         if (!has_future) {
[16:20:41.129]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.129]                             info)
[16:20:41.129]                         }
[16:20:41.129]                         else {
[16:20:41.129]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.129]                             info, version)
[16:20:41.129]                         }
[16:20:41.129]                         base::stop(msg)
[16:20:41.129]                       }
[16:20:41.129]                     })
[16:20:41.129]                   }
[16:20:41.129]                   ...future.strategy.old <- future::plan("list")
[16:20:41.129]                   options(future.plan = NULL)
[16:20:41.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.129]                 }
[16:20:41.129]                 ...future.workdir <- getwd()
[16:20:41.129]             }
[16:20:41.129]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.129]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.129]         }
[16:20:41.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.129]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.129]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.129]             base::names(...future.oldOptions))
[16:20:41.129]     }
[16:20:41.129]     if (FALSE) {
[16:20:41.129]     }
[16:20:41.129]     else {
[16:20:41.129]         if (TRUE) {
[16:20:41.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.129]                 open = "w")
[16:20:41.129]         }
[16:20:41.129]         else {
[16:20:41.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.129]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.129]         }
[16:20:41.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.129]             base::sink(type = "output", split = FALSE)
[16:20:41.129]             base::close(...future.stdout)
[16:20:41.129]         }, add = TRUE)
[16:20:41.129]     }
[16:20:41.129]     ...future.frame <- base::sys.nframe()
[16:20:41.129]     ...future.conditions <- base::list()
[16:20:41.129]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.129]     if (FALSE) {
[16:20:41.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.129]     }
[16:20:41.129]     ...future.result <- base::tryCatch({
[16:20:41.129]         base::withCallingHandlers({
[16:20:41.129]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.129]             future::FutureResult(value = ...future.value$value, 
[16:20:41.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.129]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.129]                     ...future.globalenv.names))
[16:20:41.129]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.129]         }, condition = base::local({
[16:20:41.129]             c <- base::c
[16:20:41.129]             inherits <- base::inherits
[16:20:41.129]             invokeRestart <- base::invokeRestart
[16:20:41.129]             length <- base::length
[16:20:41.129]             list <- base::list
[16:20:41.129]             seq.int <- base::seq.int
[16:20:41.129]             signalCondition <- base::signalCondition
[16:20:41.129]             sys.calls <- base::sys.calls
[16:20:41.129]             `[[` <- base::`[[`
[16:20:41.129]             `+` <- base::`+`
[16:20:41.129]             `<<-` <- base::`<<-`
[16:20:41.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.129]                   3L)]
[16:20:41.129]             }
[16:20:41.129]             function(cond) {
[16:20:41.129]                 is_error <- inherits(cond, "error")
[16:20:41.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.129]                   NULL)
[16:20:41.129]                 if (is_error) {
[16:20:41.129]                   sessionInformation <- function() {
[16:20:41.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.129]                       search = base::search(), system = base::Sys.info())
[16:20:41.129]                   }
[16:20:41.129]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.129]                     cond$call), session = sessionInformation(), 
[16:20:41.129]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.129]                   signalCondition(cond)
[16:20:41.129]                 }
[16:20:41.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.129]                 "immediateCondition"))) {
[16:20:41.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.129]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.129]                   if (TRUE && !signal) {
[16:20:41.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.129]                     {
[16:20:41.129]                       inherits <- base::inherits
[16:20:41.129]                       invokeRestart <- base::invokeRestart
[16:20:41.129]                       is.null <- base::is.null
[16:20:41.129]                       muffled <- FALSE
[16:20:41.129]                       if (inherits(cond, "message")) {
[16:20:41.129]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.129]                         if (muffled) 
[16:20:41.129]                           invokeRestart("muffleMessage")
[16:20:41.129]                       }
[16:20:41.129]                       else if (inherits(cond, "warning")) {
[16:20:41.129]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.129]                         if (muffled) 
[16:20:41.129]                           invokeRestart("muffleWarning")
[16:20:41.129]                       }
[16:20:41.129]                       else if (inherits(cond, "condition")) {
[16:20:41.129]                         if (!is.null(pattern)) {
[16:20:41.129]                           computeRestarts <- base::computeRestarts
[16:20:41.129]                           grepl <- base::grepl
[16:20:41.129]                           restarts <- computeRestarts(cond)
[16:20:41.129]                           for (restart in restarts) {
[16:20:41.129]                             name <- restart$name
[16:20:41.129]                             if (is.null(name)) 
[16:20:41.129]                               next
[16:20:41.129]                             if (!grepl(pattern, name)) 
[16:20:41.129]                               next
[16:20:41.129]                             invokeRestart(restart)
[16:20:41.129]                             muffled <- TRUE
[16:20:41.129]                             break
[16:20:41.129]                           }
[16:20:41.129]                         }
[16:20:41.129]                       }
[16:20:41.129]                       invisible(muffled)
[16:20:41.129]                     }
[16:20:41.129]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.129]                   }
[16:20:41.129]                 }
[16:20:41.129]                 else {
[16:20:41.129]                   if (TRUE) {
[16:20:41.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.129]                     {
[16:20:41.129]                       inherits <- base::inherits
[16:20:41.129]                       invokeRestart <- base::invokeRestart
[16:20:41.129]                       is.null <- base::is.null
[16:20:41.129]                       muffled <- FALSE
[16:20:41.129]                       if (inherits(cond, "message")) {
[16:20:41.129]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.129]                         if (muffled) 
[16:20:41.129]                           invokeRestart("muffleMessage")
[16:20:41.129]                       }
[16:20:41.129]                       else if (inherits(cond, "warning")) {
[16:20:41.129]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.129]                         if (muffled) 
[16:20:41.129]                           invokeRestart("muffleWarning")
[16:20:41.129]                       }
[16:20:41.129]                       else if (inherits(cond, "condition")) {
[16:20:41.129]                         if (!is.null(pattern)) {
[16:20:41.129]                           computeRestarts <- base::computeRestarts
[16:20:41.129]                           grepl <- base::grepl
[16:20:41.129]                           restarts <- computeRestarts(cond)
[16:20:41.129]                           for (restart in restarts) {
[16:20:41.129]                             name <- restart$name
[16:20:41.129]                             if (is.null(name)) 
[16:20:41.129]                               next
[16:20:41.129]                             if (!grepl(pattern, name)) 
[16:20:41.129]                               next
[16:20:41.129]                             invokeRestart(restart)
[16:20:41.129]                             muffled <- TRUE
[16:20:41.129]                             break
[16:20:41.129]                           }
[16:20:41.129]                         }
[16:20:41.129]                       }
[16:20:41.129]                       invisible(muffled)
[16:20:41.129]                     }
[16:20:41.129]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.129]                   }
[16:20:41.129]                 }
[16:20:41.129]             }
[16:20:41.129]         }))
[16:20:41.129]     }, error = function(ex) {
[16:20:41.129]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.129]                 ...future.rng), started = ...future.startTime, 
[16:20:41.129]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.129]             version = "1.8"), class = "FutureResult")
[16:20:41.129]     }, finally = {
[16:20:41.129]         if (!identical(...future.workdir, getwd())) 
[16:20:41.129]             setwd(...future.workdir)
[16:20:41.129]         {
[16:20:41.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.129]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.129]             }
[16:20:41.129]             base::options(...future.oldOptions)
[16:20:41.129]             if (.Platform$OS.type == "windows") {
[16:20:41.129]                 old_names <- names(...future.oldEnvVars)
[16:20:41.129]                 envs <- base::Sys.getenv()
[16:20:41.129]                 names <- names(envs)
[16:20:41.129]                 common <- intersect(names, old_names)
[16:20:41.129]                 added <- setdiff(names, old_names)
[16:20:41.129]                 removed <- setdiff(old_names, names)
[16:20:41.129]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.129]                   envs[common]]
[16:20:41.129]                 NAMES <- toupper(changed)
[16:20:41.129]                 args <- list()
[16:20:41.129]                 for (kk in seq_along(NAMES)) {
[16:20:41.129]                   name <- changed[[kk]]
[16:20:41.129]                   NAME <- NAMES[[kk]]
[16:20:41.129]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.129]                     next
[16:20:41.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.129]                 }
[16:20:41.129]                 NAMES <- toupper(added)
[16:20:41.129]                 for (kk in seq_along(NAMES)) {
[16:20:41.129]                   name <- added[[kk]]
[16:20:41.129]                   NAME <- NAMES[[kk]]
[16:20:41.129]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.129]                     next
[16:20:41.129]                   args[[name]] <- ""
[16:20:41.129]                 }
[16:20:41.129]                 NAMES <- toupper(removed)
[16:20:41.129]                 for (kk in seq_along(NAMES)) {
[16:20:41.129]                   name <- removed[[kk]]
[16:20:41.129]                   NAME <- NAMES[[kk]]
[16:20:41.129]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.129]                     next
[16:20:41.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.129]                 }
[16:20:41.129]                 if (length(args) > 0) 
[16:20:41.129]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.129]             }
[16:20:41.129]             else {
[16:20:41.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.129]             }
[16:20:41.129]             {
[16:20:41.129]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.129]                   0L) {
[16:20:41.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.129]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.129]                   base::options(opts)
[16:20:41.129]                 }
[16:20:41.129]                 {
[16:20:41.129]                   {
[16:20:41.129]                     NULL
[16:20:41.129]                     RNGkind("Mersenne-Twister")
[16:20:41.129]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.129]                       inherits = FALSE)
[16:20:41.129]                   }
[16:20:41.129]                   options(future.plan = NULL)
[16:20:41.129]                   if (is.na(NA_character_)) 
[16:20:41.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.129]                     .init = FALSE)
[16:20:41.129]                 }
[16:20:41.129]             }
[16:20:41.129]         }
[16:20:41.129]     })
[16:20:41.129]     if (TRUE) {
[16:20:41.129]         base::sink(type = "output", split = FALSE)
[16:20:41.129]         if (TRUE) {
[16:20:41.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.129]         }
[16:20:41.129]         else {
[16:20:41.129]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.129]         }
[16:20:41.129]         base::close(...future.stdout)
[16:20:41.129]         ...future.stdout <- NULL
[16:20:41.129]     }
[16:20:41.129]     ...future.result$conditions <- ...future.conditions
[16:20:41.129]     ...future.result$finished <- base::Sys.time()
[16:20:41.129]     ...future.result
[16:20:41.129] }
[16:20:41.131] plan(): Setting new future strategy stack:
[16:20:41.131] List of future strategies:
[16:20:41.131] 1. sequential:
[16:20:41.131]    - args: function (..., envir = parent.frame())
[16:20:41.131]    - tweaked: FALSE
[16:20:41.131]    - call: NULL
[16:20:41.131] plan(): nbrOfWorkers() = 1
[16:20:41.132] plan(): Setting new future strategy stack:
[16:20:41.132] List of future strategies:
[16:20:41.132] 1. sequential:
[16:20:41.132]    - args: function (..., envir = parent.frame())
[16:20:41.132]    - tweaked: FALSE
[16:20:41.132]    - call: plan(strategy)
[16:20:41.132] plan(): nbrOfWorkers() = 1
[16:20:41.133] SequentialFuture started (and completed)
[16:20:41.133] - Launch lazy future ... done
[16:20:41.133] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0be6f390> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0c25ff40> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0be6f390> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0c25ff40> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:20:41.138] resolved() for ‘SequentialFuture’ ...
[16:20:41.139] - state: ‘finished’
[16:20:41.139] - run: TRUE
[16:20:41.139] - result: ‘FutureResult’
[16:20:41.139] resolved() for ‘SequentialFuture’ ... done
[16:20:41.139] resolved() for ‘SequentialFuture’ ...
[16:20:41.139] - state: ‘finished’
[16:20:41.139] - run: TRUE
[16:20:41.139] - result: ‘FutureResult’
[16:20:41.139] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:41.141] resolve() on list ...
[16:20:41.141]  recursive: 0
[16:20:41.141]  length: 6
[16:20:41.141]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:41.142] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.142] - nx: 6
[16:20:41.142] - relay: TRUE
[16:20:41.142] - stdout: TRUE
[16:20:41.142] - signal: TRUE
[16:20:41.142] - resignal: FALSE
[16:20:41.142] - force: TRUE
[16:20:41.142] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.142] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.142]  - until=2
[16:20:41.142]  - relaying element #2
[16:20:41.142] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.142] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.143] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.143]  length: 5 (resolved future 1)
[16:20:41.143] resolved() for ‘SequentialFuture’ ...
[16:20:41.143] - state: ‘finished’
[16:20:41.143] - run: TRUE
[16:20:41.143] - result: ‘FutureResult’
[16:20:41.143] resolved() for ‘SequentialFuture’ ... done
[16:20:41.143] Future #2
[16:20:41.143] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.143] - nx: 6
[16:20:41.144] - relay: TRUE
[16:20:41.144] - stdout: TRUE
[16:20:41.144] - signal: TRUE
[16:20:41.144] - resignal: FALSE
[16:20:41.144] - force: TRUE
[16:20:41.144] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.144] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.144]  - until=2
[16:20:41.144]  - relaying element #2
[16:20:41.144] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.144] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.145] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.145]  length: 4 (resolved future 2)
[16:20:41.145] resolved() for ‘SequentialFuture’ ...
[16:20:41.145] - state: ‘finished’
[16:20:41.145] - run: TRUE
[16:20:41.145] - result: ‘FutureResult’
[16:20:41.145] resolved() for ‘SequentialFuture’ ... done
[16:20:41.145] Future #3
[16:20:41.145] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.145] - nx: 6
[16:20:41.146] - relay: TRUE
[16:20:41.146] - stdout: TRUE
[16:20:41.146] - signal: TRUE
[16:20:41.146] - resignal: FALSE
[16:20:41.146] - force: TRUE
[16:20:41.146] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.146] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.146]  - until=3
[16:20:41.146]  - relaying element #3
[16:20:41.146] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.147] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.147] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.147]  length: 3 (resolved future 3)
[16:20:41.147] signalConditionsASAP(NULL, pos=4) ...
[16:20:41.147] - nx: 6
[16:20:41.147] - relay: TRUE
[16:20:41.147] - stdout: TRUE
[16:20:41.147] - signal: TRUE
[16:20:41.147] - resignal: FALSE
[16:20:41.147] - force: TRUE
[16:20:41.147] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.147] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.147]  - until=5
[16:20:41.148]  - relaying element #5
[16:20:41.148] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.148] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.148] signalConditionsASAP(NULL, pos=4) ... done
[16:20:41.148]  length: 2 (resolved future 4)
[16:20:41.148] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.148] - nx: 6
[16:20:41.148] - relay: TRUE
[16:20:41.148] - stdout: TRUE
[16:20:41.148] - signal: TRUE
[16:20:41.148] - resignal: FALSE
[16:20:41.148] - force: TRUE
[16:20:41.149] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.149] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.149]  - until=6
[16:20:41.149]  - relaying element #6
[16:20:41.149] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.149] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.149] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.149]  length: 1 (resolved future 5)
[16:20:41.149] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.149] - nx: 6
[16:20:41.149] - relay: TRUE
[16:20:41.149] - stdout: TRUE
[16:20:41.150] - signal: TRUE
[16:20:41.150] - resignal: FALSE
[16:20:41.150] - force: TRUE
[16:20:41.150] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.150] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.150]  - until=6
[16:20:41.150] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.150] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.150] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.150]  length: 0 (resolved future 6)
[16:20:41.150] Relaying remaining futures
[16:20:41.150] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.150] - nx: 6
[16:20:41.151] - relay: TRUE
[16:20:41.151] - stdout: TRUE
[16:20:41.151] - signal: TRUE
[16:20:41.151] - resignal: FALSE
[16:20:41.151] - force: TRUE
[16:20:41.151] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.151] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:41.151] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.151] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.151] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.151] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:20:41.154] getGlobalsAndPackages() ...
[16:20:41.154] Searching for globals...
[16:20:41.155] 
[16:20:41.155] Searching for globals ... DONE
[16:20:41.155] - globals: [0] <none>
[16:20:41.155] getGlobalsAndPackages() ... DONE
[16:20:41.155] run() for ‘Future’ ...
[16:20:41.155] - state: ‘created’
[16:20:41.155] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.156] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.156]   - Field: ‘label’
[16:20:41.156]   - Field: ‘local’
[16:20:41.156]   - Field: ‘owner’
[16:20:41.156]   - Field: ‘envir’
[16:20:41.156]   - Field: ‘packages’
[16:20:41.156]   - Field: ‘gc’
[16:20:41.156]   - Field: ‘conditions’
[16:20:41.157]   - Field: ‘expr’
[16:20:41.157]   - Field: ‘uuid’
[16:20:41.157]   - Field: ‘seed’
[16:20:41.157]   - Field: ‘version’
[16:20:41.157]   - Field: ‘result’
[16:20:41.157]   - Field: ‘asynchronous’
[16:20:41.157]   - Field: ‘calls’
[16:20:41.157]   - Field: ‘globals’
[16:20:41.157]   - Field: ‘stdout’
[16:20:41.157]   - Field: ‘earlySignal’
[16:20:41.157]   - Field: ‘lazy’
[16:20:41.157]   - Field: ‘state’
[16:20:41.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.158] - Launch lazy future ...
[16:20:41.158] Packages needed by the future expression (n = 0): <none>
[16:20:41.158] Packages needed by future strategies (n = 0): <none>
[16:20:41.158] {
[16:20:41.158]     {
[16:20:41.158]         {
[16:20:41.158]             ...future.startTime <- base::Sys.time()
[16:20:41.158]             {
[16:20:41.158]                 {
[16:20:41.158]                   {
[16:20:41.158]                     base::local({
[16:20:41.158]                       has_future <- base::requireNamespace("future", 
[16:20:41.158]                         quietly = TRUE)
[16:20:41.158]                       if (has_future) {
[16:20:41.158]                         ns <- base::getNamespace("future")
[16:20:41.158]                         version <- ns[[".package"]][["version"]]
[16:20:41.158]                         if (is.null(version)) 
[16:20:41.158]                           version <- utils::packageVersion("future")
[16:20:41.158]                       }
[16:20:41.158]                       else {
[16:20:41.158]                         version <- NULL
[16:20:41.158]                       }
[16:20:41.158]                       if (!has_future || version < "1.8.0") {
[16:20:41.158]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.158]                           "", base::R.version$version.string), 
[16:20:41.158]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.158]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.158]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.158]                             "release", "version")], collapse = " "), 
[16:20:41.158]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.158]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.158]                           info)
[16:20:41.158]                         info <- base::paste(info, collapse = "; ")
[16:20:41.158]                         if (!has_future) {
[16:20:41.158]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.158]                             info)
[16:20:41.158]                         }
[16:20:41.158]                         else {
[16:20:41.158]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.158]                             info, version)
[16:20:41.158]                         }
[16:20:41.158]                         base::stop(msg)
[16:20:41.158]                       }
[16:20:41.158]                     })
[16:20:41.158]                   }
[16:20:41.158]                   ...future.strategy.old <- future::plan("list")
[16:20:41.158]                   options(future.plan = NULL)
[16:20:41.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.158]                 }
[16:20:41.158]                 ...future.workdir <- getwd()
[16:20:41.158]             }
[16:20:41.158]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.158]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.158]         }
[16:20:41.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.158]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.158]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.158]             base::names(...future.oldOptions))
[16:20:41.158]     }
[16:20:41.158]     if (FALSE) {
[16:20:41.158]     }
[16:20:41.158]     else {
[16:20:41.158]         if (TRUE) {
[16:20:41.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.158]                 open = "w")
[16:20:41.158]         }
[16:20:41.158]         else {
[16:20:41.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.158]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.158]         }
[16:20:41.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.158]             base::sink(type = "output", split = FALSE)
[16:20:41.158]             base::close(...future.stdout)
[16:20:41.158]         }, add = TRUE)
[16:20:41.158]     }
[16:20:41.158]     ...future.frame <- base::sys.nframe()
[16:20:41.158]     ...future.conditions <- base::list()
[16:20:41.158]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.158]     if (FALSE) {
[16:20:41.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.158]     }
[16:20:41.158]     ...future.result <- base::tryCatch({
[16:20:41.158]         base::withCallingHandlers({
[16:20:41.158]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.158]             future::FutureResult(value = ...future.value$value, 
[16:20:41.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.158]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.158]                     ...future.globalenv.names))
[16:20:41.158]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.158]         }, condition = base::local({
[16:20:41.158]             c <- base::c
[16:20:41.158]             inherits <- base::inherits
[16:20:41.158]             invokeRestart <- base::invokeRestart
[16:20:41.158]             length <- base::length
[16:20:41.158]             list <- base::list
[16:20:41.158]             seq.int <- base::seq.int
[16:20:41.158]             signalCondition <- base::signalCondition
[16:20:41.158]             sys.calls <- base::sys.calls
[16:20:41.158]             `[[` <- base::`[[`
[16:20:41.158]             `+` <- base::`+`
[16:20:41.158]             `<<-` <- base::`<<-`
[16:20:41.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.158]                   3L)]
[16:20:41.158]             }
[16:20:41.158]             function(cond) {
[16:20:41.158]                 is_error <- inherits(cond, "error")
[16:20:41.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.158]                   NULL)
[16:20:41.158]                 if (is_error) {
[16:20:41.158]                   sessionInformation <- function() {
[16:20:41.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.158]                       search = base::search(), system = base::Sys.info())
[16:20:41.158]                   }
[16:20:41.158]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.158]                     cond$call), session = sessionInformation(), 
[16:20:41.158]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.158]                   signalCondition(cond)
[16:20:41.158]                 }
[16:20:41.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.158]                 "immediateCondition"))) {
[16:20:41.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.158]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.158]                   if (TRUE && !signal) {
[16:20:41.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.158]                     {
[16:20:41.158]                       inherits <- base::inherits
[16:20:41.158]                       invokeRestart <- base::invokeRestart
[16:20:41.158]                       is.null <- base::is.null
[16:20:41.158]                       muffled <- FALSE
[16:20:41.158]                       if (inherits(cond, "message")) {
[16:20:41.158]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.158]                         if (muffled) 
[16:20:41.158]                           invokeRestart("muffleMessage")
[16:20:41.158]                       }
[16:20:41.158]                       else if (inherits(cond, "warning")) {
[16:20:41.158]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.158]                         if (muffled) 
[16:20:41.158]                           invokeRestart("muffleWarning")
[16:20:41.158]                       }
[16:20:41.158]                       else if (inherits(cond, "condition")) {
[16:20:41.158]                         if (!is.null(pattern)) {
[16:20:41.158]                           computeRestarts <- base::computeRestarts
[16:20:41.158]                           grepl <- base::grepl
[16:20:41.158]                           restarts <- computeRestarts(cond)
[16:20:41.158]                           for (restart in restarts) {
[16:20:41.158]                             name <- restart$name
[16:20:41.158]                             if (is.null(name)) 
[16:20:41.158]                               next
[16:20:41.158]                             if (!grepl(pattern, name)) 
[16:20:41.158]                               next
[16:20:41.158]                             invokeRestart(restart)
[16:20:41.158]                             muffled <- TRUE
[16:20:41.158]                             break
[16:20:41.158]                           }
[16:20:41.158]                         }
[16:20:41.158]                       }
[16:20:41.158]                       invisible(muffled)
[16:20:41.158]                     }
[16:20:41.158]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.158]                   }
[16:20:41.158]                 }
[16:20:41.158]                 else {
[16:20:41.158]                   if (TRUE) {
[16:20:41.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.158]                     {
[16:20:41.158]                       inherits <- base::inherits
[16:20:41.158]                       invokeRestart <- base::invokeRestart
[16:20:41.158]                       is.null <- base::is.null
[16:20:41.158]                       muffled <- FALSE
[16:20:41.158]                       if (inherits(cond, "message")) {
[16:20:41.158]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.158]                         if (muffled) 
[16:20:41.158]                           invokeRestart("muffleMessage")
[16:20:41.158]                       }
[16:20:41.158]                       else if (inherits(cond, "warning")) {
[16:20:41.158]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.158]                         if (muffled) 
[16:20:41.158]                           invokeRestart("muffleWarning")
[16:20:41.158]                       }
[16:20:41.158]                       else if (inherits(cond, "condition")) {
[16:20:41.158]                         if (!is.null(pattern)) {
[16:20:41.158]                           computeRestarts <- base::computeRestarts
[16:20:41.158]                           grepl <- base::grepl
[16:20:41.158]                           restarts <- computeRestarts(cond)
[16:20:41.158]                           for (restart in restarts) {
[16:20:41.158]                             name <- restart$name
[16:20:41.158]                             if (is.null(name)) 
[16:20:41.158]                               next
[16:20:41.158]                             if (!grepl(pattern, name)) 
[16:20:41.158]                               next
[16:20:41.158]                             invokeRestart(restart)
[16:20:41.158]                             muffled <- TRUE
[16:20:41.158]                             break
[16:20:41.158]                           }
[16:20:41.158]                         }
[16:20:41.158]                       }
[16:20:41.158]                       invisible(muffled)
[16:20:41.158]                     }
[16:20:41.158]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.158]                   }
[16:20:41.158]                 }
[16:20:41.158]             }
[16:20:41.158]         }))
[16:20:41.158]     }, error = function(ex) {
[16:20:41.158]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.158]                 ...future.rng), started = ...future.startTime, 
[16:20:41.158]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.158]             version = "1.8"), class = "FutureResult")
[16:20:41.158]     }, finally = {
[16:20:41.158]         if (!identical(...future.workdir, getwd())) 
[16:20:41.158]             setwd(...future.workdir)
[16:20:41.158]         {
[16:20:41.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.158]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.158]             }
[16:20:41.158]             base::options(...future.oldOptions)
[16:20:41.158]             if (.Platform$OS.type == "windows") {
[16:20:41.158]                 old_names <- names(...future.oldEnvVars)
[16:20:41.158]                 envs <- base::Sys.getenv()
[16:20:41.158]                 names <- names(envs)
[16:20:41.158]                 common <- intersect(names, old_names)
[16:20:41.158]                 added <- setdiff(names, old_names)
[16:20:41.158]                 removed <- setdiff(old_names, names)
[16:20:41.158]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.158]                   envs[common]]
[16:20:41.158]                 NAMES <- toupper(changed)
[16:20:41.158]                 args <- list()
[16:20:41.158]                 for (kk in seq_along(NAMES)) {
[16:20:41.158]                   name <- changed[[kk]]
[16:20:41.158]                   NAME <- NAMES[[kk]]
[16:20:41.158]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.158]                     next
[16:20:41.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.158]                 }
[16:20:41.158]                 NAMES <- toupper(added)
[16:20:41.158]                 for (kk in seq_along(NAMES)) {
[16:20:41.158]                   name <- added[[kk]]
[16:20:41.158]                   NAME <- NAMES[[kk]]
[16:20:41.158]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.158]                     next
[16:20:41.158]                   args[[name]] <- ""
[16:20:41.158]                 }
[16:20:41.158]                 NAMES <- toupper(removed)
[16:20:41.158]                 for (kk in seq_along(NAMES)) {
[16:20:41.158]                   name <- removed[[kk]]
[16:20:41.158]                   NAME <- NAMES[[kk]]
[16:20:41.158]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.158]                     next
[16:20:41.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.158]                 }
[16:20:41.158]                 if (length(args) > 0) 
[16:20:41.158]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.158]             }
[16:20:41.158]             else {
[16:20:41.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.158]             }
[16:20:41.158]             {
[16:20:41.158]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.158]                   0L) {
[16:20:41.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.158]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.158]                   base::options(opts)
[16:20:41.158]                 }
[16:20:41.158]                 {
[16:20:41.158]                   {
[16:20:41.158]                     NULL
[16:20:41.158]                     RNGkind("Mersenne-Twister")
[16:20:41.158]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.158]                       inherits = FALSE)
[16:20:41.158]                   }
[16:20:41.158]                   options(future.plan = NULL)
[16:20:41.158]                   if (is.na(NA_character_)) 
[16:20:41.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.158]                     .init = FALSE)
[16:20:41.158]                 }
[16:20:41.158]             }
[16:20:41.158]         }
[16:20:41.158]     })
[16:20:41.158]     if (TRUE) {
[16:20:41.158]         base::sink(type = "output", split = FALSE)
[16:20:41.158]         if (TRUE) {
[16:20:41.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.158]         }
[16:20:41.158]         else {
[16:20:41.158]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.158]         }
[16:20:41.158]         base::close(...future.stdout)
[16:20:41.158]         ...future.stdout <- NULL
[16:20:41.158]     }
[16:20:41.158]     ...future.result$conditions <- ...future.conditions
[16:20:41.158]     ...future.result$finished <- base::Sys.time()
[16:20:41.158]     ...future.result
[16:20:41.158] }
[16:20:41.160] plan(): Setting new future strategy stack:
[16:20:41.160] List of future strategies:
[16:20:41.160] 1. sequential:
[16:20:41.160]    - args: function (..., envir = parent.frame())
[16:20:41.160]    - tweaked: FALSE
[16:20:41.160]    - call: NULL
[16:20:41.160] plan(): nbrOfWorkers() = 1
[16:20:41.161] plan(): Setting new future strategy stack:
[16:20:41.161] List of future strategies:
[16:20:41.161] 1. sequential:
[16:20:41.161]    - args: function (..., envir = parent.frame())
[16:20:41.161]    - tweaked: FALSE
[16:20:41.161]    - call: plan(strategy)
[16:20:41.161] plan(): nbrOfWorkers() = 1
[16:20:41.162] SequentialFuture started (and completed)
[16:20:41.162] - Launch lazy future ... done
[16:20:41.162] run() for ‘SequentialFuture’ ... done
[16:20:41.162] getGlobalsAndPackages() ...
[16:20:41.162] Searching for globals...
[16:20:41.163] 
[16:20:41.163] Searching for globals ... DONE
[16:20:41.163] - globals: [0] <none>
[16:20:41.163] getGlobalsAndPackages() ... DONE
[16:20:41.164] run() for ‘Future’ ...
[16:20:41.164] - state: ‘created’
[16:20:41.164] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.164] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.164] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.164]   - Field: ‘label’
[16:20:41.164]   - Field: ‘local’
[16:20:41.165]   - Field: ‘owner’
[16:20:41.165]   - Field: ‘envir’
[16:20:41.165]   - Field: ‘packages’
[16:20:41.165]   - Field: ‘gc’
[16:20:41.165]   - Field: ‘conditions’
[16:20:41.165]   - Field: ‘expr’
[16:20:41.165]   - Field: ‘uuid’
[16:20:41.165]   - Field: ‘seed’
[16:20:41.165]   - Field: ‘version’
[16:20:41.165]   - Field: ‘result’
[16:20:41.165]   - Field: ‘asynchronous’
[16:20:41.165]   - Field: ‘calls’
[16:20:41.166]   - Field: ‘globals’
[16:20:41.166]   - Field: ‘stdout’
[16:20:41.166]   - Field: ‘earlySignal’
[16:20:41.166]   - Field: ‘lazy’
[16:20:41.166]   - Field: ‘state’
[16:20:41.166] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.166] - Launch lazy future ...
[16:20:41.166] Packages needed by the future expression (n = 0): <none>
[16:20:41.166] Packages needed by future strategies (n = 0): <none>
[16:20:41.167] {
[16:20:41.167]     {
[16:20:41.167]         {
[16:20:41.167]             ...future.startTime <- base::Sys.time()
[16:20:41.167]             {
[16:20:41.167]                 {
[16:20:41.167]                   {
[16:20:41.167]                     base::local({
[16:20:41.167]                       has_future <- base::requireNamespace("future", 
[16:20:41.167]                         quietly = TRUE)
[16:20:41.167]                       if (has_future) {
[16:20:41.167]                         ns <- base::getNamespace("future")
[16:20:41.167]                         version <- ns[[".package"]][["version"]]
[16:20:41.167]                         if (is.null(version)) 
[16:20:41.167]                           version <- utils::packageVersion("future")
[16:20:41.167]                       }
[16:20:41.167]                       else {
[16:20:41.167]                         version <- NULL
[16:20:41.167]                       }
[16:20:41.167]                       if (!has_future || version < "1.8.0") {
[16:20:41.167]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.167]                           "", base::R.version$version.string), 
[16:20:41.167]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.167]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.167]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.167]                             "release", "version")], collapse = " "), 
[16:20:41.167]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.167]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.167]                           info)
[16:20:41.167]                         info <- base::paste(info, collapse = "; ")
[16:20:41.167]                         if (!has_future) {
[16:20:41.167]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.167]                             info)
[16:20:41.167]                         }
[16:20:41.167]                         else {
[16:20:41.167]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.167]                             info, version)
[16:20:41.167]                         }
[16:20:41.167]                         base::stop(msg)
[16:20:41.167]                       }
[16:20:41.167]                     })
[16:20:41.167]                   }
[16:20:41.167]                   ...future.strategy.old <- future::plan("list")
[16:20:41.167]                   options(future.plan = NULL)
[16:20:41.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.167]                 }
[16:20:41.167]                 ...future.workdir <- getwd()
[16:20:41.167]             }
[16:20:41.167]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.167]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.167]         }
[16:20:41.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.167]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.167]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.167]             base::names(...future.oldOptions))
[16:20:41.167]     }
[16:20:41.167]     if (FALSE) {
[16:20:41.167]     }
[16:20:41.167]     else {
[16:20:41.167]         if (TRUE) {
[16:20:41.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.167]                 open = "w")
[16:20:41.167]         }
[16:20:41.167]         else {
[16:20:41.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.167]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.167]         }
[16:20:41.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.167]             base::sink(type = "output", split = FALSE)
[16:20:41.167]             base::close(...future.stdout)
[16:20:41.167]         }, add = TRUE)
[16:20:41.167]     }
[16:20:41.167]     ...future.frame <- base::sys.nframe()
[16:20:41.167]     ...future.conditions <- base::list()
[16:20:41.167]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.167]     if (FALSE) {
[16:20:41.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.167]     }
[16:20:41.167]     ...future.result <- base::tryCatch({
[16:20:41.167]         base::withCallingHandlers({
[16:20:41.167]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.167]             future::FutureResult(value = ...future.value$value, 
[16:20:41.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.167]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.167]                     ...future.globalenv.names))
[16:20:41.167]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.167]         }, condition = base::local({
[16:20:41.167]             c <- base::c
[16:20:41.167]             inherits <- base::inherits
[16:20:41.167]             invokeRestart <- base::invokeRestart
[16:20:41.167]             length <- base::length
[16:20:41.167]             list <- base::list
[16:20:41.167]             seq.int <- base::seq.int
[16:20:41.167]             signalCondition <- base::signalCondition
[16:20:41.167]             sys.calls <- base::sys.calls
[16:20:41.167]             `[[` <- base::`[[`
[16:20:41.167]             `+` <- base::`+`
[16:20:41.167]             `<<-` <- base::`<<-`
[16:20:41.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.167]                   3L)]
[16:20:41.167]             }
[16:20:41.167]             function(cond) {
[16:20:41.167]                 is_error <- inherits(cond, "error")
[16:20:41.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.167]                   NULL)
[16:20:41.167]                 if (is_error) {
[16:20:41.167]                   sessionInformation <- function() {
[16:20:41.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.167]                       search = base::search(), system = base::Sys.info())
[16:20:41.167]                   }
[16:20:41.167]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.167]                     cond$call), session = sessionInformation(), 
[16:20:41.167]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.167]                   signalCondition(cond)
[16:20:41.167]                 }
[16:20:41.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.167]                 "immediateCondition"))) {
[16:20:41.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.167]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.167]                   if (TRUE && !signal) {
[16:20:41.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.167]                     {
[16:20:41.167]                       inherits <- base::inherits
[16:20:41.167]                       invokeRestart <- base::invokeRestart
[16:20:41.167]                       is.null <- base::is.null
[16:20:41.167]                       muffled <- FALSE
[16:20:41.167]                       if (inherits(cond, "message")) {
[16:20:41.167]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.167]                         if (muffled) 
[16:20:41.167]                           invokeRestart("muffleMessage")
[16:20:41.167]                       }
[16:20:41.167]                       else if (inherits(cond, "warning")) {
[16:20:41.167]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.167]                         if (muffled) 
[16:20:41.167]                           invokeRestart("muffleWarning")
[16:20:41.167]                       }
[16:20:41.167]                       else if (inherits(cond, "condition")) {
[16:20:41.167]                         if (!is.null(pattern)) {
[16:20:41.167]                           computeRestarts <- base::computeRestarts
[16:20:41.167]                           grepl <- base::grepl
[16:20:41.167]                           restarts <- computeRestarts(cond)
[16:20:41.167]                           for (restart in restarts) {
[16:20:41.167]                             name <- restart$name
[16:20:41.167]                             if (is.null(name)) 
[16:20:41.167]                               next
[16:20:41.167]                             if (!grepl(pattern, name)) 
[16:20:41.167]                               next
[16:20:41.167]                             invokeRestart(restart)
[16:20:41.167]                             muffled <- TRUE
[16:20:41.167]                             break
[16:20:41.167]                           }
[16:20:41.167]                         }
[16:20:41.167]                       }
[16:20:41.167]                       invisible(muffled)
[16:20:41.167]                     }
[16:20:41.167]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.167]                   }
[16:20:41.167]                 }
[16:20:41.167]                 else {
[16:20:41.167]                   if (TRUE) {
[16:20:41.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.167]                     {
[16:20:41.167]                       inherits <- base::inherits
[16:20:41.167]                       invokeRestart <- base::invokeRestart
[16:20:41.167]                       is.null <- base::is.null
[16:20:41.167]                       muffled <- FALSE
[16:20:41.167]                       if (inherits(cond, "message")) {
[16:20:41.167]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.167]                         if (muffled) 
[16:20:41.167]                           invokeRestart("muffleMessage")
[16:20:41.167]                       }
[16:20:41.167]                       else if (inherits(cond, "warning")) {
[16:20:41.167]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.167]                         if (muffled) 
[16:20:41.167]                           invokeRestart("muffleWarning")
[16:20:41.167]                       }
[16:20:41.167]                       else if (inherits(cond, "condition")) {
[16:20:41.167]                         if (!is.null(pattern)) {
[16:20:41.167]                           computeRestarts <- base::computeRestarts
[16:20:41.167]                           grepl <- base::grepl
[16:20:41.167]                           restarts <- computeRestarts(cond)
[16:20:41.167]                           for (restart in restarts) {
[16:20:41.167]                             name <- restart$name
[16:20:41.167]                             if (is.null(name)) 
[16:20:41.167]                               next
[16:20:41.167]                             if (!grepl(pattern, name)) 
[16:20:41.167]                               next
[16:20:41.167]                             invokeRestart(restart)
[16:20:41.167]                             muffled <- TRUE
[16:20:41.167]                             break
[16:20:41.167]                           }
[16:20:41.167]                         }
[16:20:41.167]                       }
[16:20:41.167]                       invisible(muffled)
[16:20:41.167]                     }
[16:20:41.167]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.167]                   }
[16:20:41.167]                 }
[16:20:41.167]             }
[16:20:41.167]         }))
[16:20:41.167]     }, error = function(ex) {
[16:20:41.167]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.167]                 ...future.rng), started = ...future.startTime, 
[16:20:41.167]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.167]             version = "1.8"), class = "FutureResult")
[16:20:41.167]     }, finally = {
[16:20:41.167]         if (!identical(...future.workdir, getwd())) 
[16:20:41.167]             setwd(...future.workdir)
[16:20:41.167]         {
[16:20:41.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.167]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.167]             }
[16:20:41.167]             base::options(...future.oldOptions)
[16:20:41.167]             if (.Platform$OS.type == "windows") {
[16:20:41.167]                 old_names <- names(...future.oldEnvVars)
[16:20:41.167]                 envs <- base::Sys.getenv()
[16:20:41.167]                 names <- names(envs)
[16:20:41.167]                 common <- intersect(names, old_names)
[16:20:41.167]                 added <- setdiff(names, old_names)
[16:20:41.167]                 removed <- setdiff(old_names, names)
[16:20:41.167]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.167]                   envs[common]]
[16:20:41.167]                 NAMES <- toupper(changed)
[16:20:41.167]                 args <- list()
[16:20:41.167]                 for (kk in seq_along(NAMES)) {
[16:20:41.167]                   name <- changed[[kk]]
[16:20:41.167]                   NAME <- NAMES[[kk]]
[16:20:41.167]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.167]                     next
[16:20:41.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.167]                 }
[16:20:41.167]                 NAMES <- toupper(added)
[16:20:41.167]                 for (kk in seq_along(NAMES)) {
[16:20:41.167]                   name <- added[[kk]]
[16:20:41.167]                   NAME <- NAMES[[kk]]
[16:20:41.167]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.167]                     next
[16:20:41.167]                   args[[name]] <- ""
[16:20:41.167]                 }
[16:20:41.167]                 NAMES <- toupper(removed)
[16:20:41.167]                 for (kk in seq_along(NAMES)) {
[16:20:41.167]                   name <- removed[[kk]]
[16:20:41.167]                   NAME <- NAMES[[kk]]
[16:20:41.167]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.167]                     next
[16:20:41.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.167]                 }
[16:20:41.167]                 if (length(args) > 0) 
[16:20:41.167]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.167]             }
[16:20:41.167]             else {
[16:20:41.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.167]             }
[16:20:41.167]             {
[16:20:41.167]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.167]                   0L) {
[16:20:41.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.167]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.167]                   base::options(opts)
[16:20:41.167]                 }
[16:20:41.167]                 {
[16:20:41.167]                   {
[16:20:41.167]                     NULL
[16:20:41.167]                     RNGkind("Mersenne-Twister")
[16:20:41.167]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.167]                       inherits = FALSE)
[16:20:41.167]                   }
[16:20:41.167]                   options(future.plan = NULL)
[16:20:41.167]                   if (is.na(NA_character_)) 
[16:20:41.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.167]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.167]                     .init = FALSE)
[16:20:41.167]                 }
[16:20:41.167]             }
[16:20:41.167]         }
[16:20:41.167]     })
[16:20:41.167]     if (TRUE) {
[16:20:41.167]         base::sink(type = "output", split = FALSE)
[16:20:41.167]         if (TRUE) {
[16:20:41.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.167]         }
[16:20:41.167]         else {
[16:20:41.167]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.167]         }
[16:20:41.167]         base::close(...future.stdout)
[16:20:41.167]         ...future.stdout <- NULL
[16:20:41.167]     }
[16:20:41.167]     ...future.result$conditions <- ...future.conditions
[16:20:41.167]     ...future.result$finished <- base::Sys.time()
[16:20:41.167]     ...future.result
[16:20:41.167] }
[16:20:41.168] plan(): Setting new future strategy stack:
[16:20:41.169] List of future strategies:
[16:20:41.169] 1. sequential:
[16:20:41.169]    - args: function (..., envir = parent.frame())
[16:20:41.169]    - tweaked: FALSE
[16:20:41.169]    - call: NULL
[16:20:41.169] plan(): nbrOfWorkers() = 1
[16:20:41.170] plan(): Setting new future strategy stack:
[16:20:41.170] List of future strategies:
[16:20:41.170] 1. sequential:
[16:20:41.170]    - args: function (..., envir = parent.frame())
[16:20:41.170]    - tweaked: FALSE
[16:20:41.170]    - call: plan(strategy)
[16:20:41.170] plan(): nbrOfWorkers() = 1
[16:20:41.170] SequentialFuture started (and completed)
[16:20:41.170] - Launch lazy future ... done
[16:20:41.170] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0c4301d0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0b6477b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0c4301d0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0b6477b0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:20:41.175] resolved() for ‘SequentialFuture’ ...
[16:20:41.175] - state: ‘finished’
[16:20:41.175] - run: TRUE
[16:20:41.175] - result: ‘FutureResult’
[16:20:41.175] resolved() for ‘SequentialFuture’ ... done
[16:20:41.175] resolved() for ‘SequentialFuture’ ...
[16:20:41.175] - state: ‘finished’
[16:20:41.176] - run: TRUE
[16:20:41.176] - result: ‘FutureResult’
[16:20:41.176] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:41.177] resolve() on list ...
[16:20:41.177]  recursive: 0
[16:20:41.177]  length: 6
[16:20:41.177]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:41.177] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.178] - nx: 6
[16:20:41.178] - relay: TRUE
[16:20:41.178] - stdout: TRUE
[16:20:41.178] - signal: TRUE
[16:20:41.178] - resignal: FALSE
[16:20:41.178] - force: TRUE
[16:20:41.178] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.178] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.178]  - until=2
[16:20:41.178]  - relaying element #2
[16:20:41.178] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.178] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.179] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.179]  length: 5 (resolved future 1)
[16:20:41.179] resolved() for ‘SequentialFuture’ ...
[16:20:41.179] - state: ‘finished’
[16:20:41.179] - run: TRUE
[16:20:41.179] - result: ‘FutureResult’
[16:20:41.179] resolved() for ‘SequentialFuture’ ... done
[16:20:41.179] Future #2
[16:20:41.179] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.179] - nx: 6
[16:20:41.179] - relay: TRUE
[16:20:41.180] - stdout: TRUE
[16:20:41.180] - signal: TRUE
[16:20:41.180] - resignal: FALSE
[16:20:41.180] - force: TRUE
[16:20:41.180] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.180] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.180]  - until=2
[16:20:41.180]  - relaying element #2
[16:20:41.180] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.180] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.180] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.181]  length: 4 (resolved future 2)
[16:20:41.181] resolved() for ‘SequentialFuture’ ...
[16:20:41.181] - state: ‘finished’
[16:20:41.181] - run: TRUE
[16:20:41.181] - result: ‘FutureResult’
[16:20:41.181] resolved() for ‘SequentialFuture’ ... done
[16:20:41.181] Future #3
[16:20:41.181] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.181] - nx: 6
[16:20:41.181] - relay: TRUE
[16:20:41.181] - stdout: TRUE
[16:20:41.182] - signal: TRUE
[16:20:41.182] - resignal: FALSE
[16:20:41.182] - force: TRUE
[16:20:41.182] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.182] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.182]  - until=3
[16:20:41.182]  - relaying element #3
[16:20:41.182] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.182] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.182] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.182]  length: 3 (resolved future 3)
[16:20:41.183] signalConditionsASAP(NULL, pos=4) ...
[16:20:41.183] - nx: 6
[16:20:41.183] - relay: TRUE
[16:20:41.183] - stdout: TRUE
[16:20:41.183] - signal: TRUE
[16:20:41.183] - resignal: FALSE
[16:20:41.183] - force: TRUE
[16:20:41.183] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.183] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.183]  - until=5
[16:20:41.183]  - relaying element #5
[16:20:41.183] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.183] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.184] signalConditionsASAP(NULL, pos=4) ... done
[16:20:41.184]  length: 2 (resolved future 4)
[16:20:41.184] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.184] - nx: 6
[16:20:41.184] - relay: TRUE
[16:20:41.184] - stdout: TRUE
[16:20:41.184] - signal: TRUE
[16:20:41.184] - resignal: FALSE
[16:20:41.184] - force: TRUE
[16:20:41.184] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.184] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.184]  - until=6
[16:20:41.185]  - relaying element #6
[16:20:41.185] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.185] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.185] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.185]  length: 1 (resolved future 5)
[16:20:41.185] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.185] - nx: 6
[16:20:41.185] - relay: TRUE
[16:20:41.185] - stdout: TRUE
[16:20:41.185] - signal: TRUE
[16:20:41.185] - resignal: FALSE
[16:20:41.185] - force: TRUE
[16:20:41.185] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.186] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.186]  - until=6
[16:20:41.186] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.186] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.186] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.186]  length: 0 (resolved future 6)
[16:20:41.186] Relaying remaining futures
[16:20:41.186] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.186] - nx: 6
[16:20:41.186] - relay: TRUE
[16:20:41.186] - stdout: TRUE
[16:20:41.186] - signal: TRUE
[16:20:41.187] - resignal: FALSE
[16:20:41.187] - force: TRUE
[16:20:41.187] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.187] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:41.187] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.187] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.187] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.187] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:20:41.191] getGlobalsAndPackages() ...
[16:20:41.191] Searching for globals...
[16:20:41.192] 
[16:20:41.192] Searching for globals ... DONE
[16:20:41.192] - globals: [0] <none>
[16:20:41.192] getGlobalsAndPackages() ... DONE
[16:20:41.192] run() for ‘Future’ ...
[16:20:41.192] - state: ‘created’
[16:20:41.192] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.192] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.193]   - Field: ‘label’
[16:20:41.193]   - Field: ‘local’
[16:20:41.193]   - Field: ‘owner’
[16:20:41.193]   - Field: ‘envir’
[16:20:41.193]   - Field: ‘packages’
[16:20:41.193]   - Field: ‘gc’
[16:20:41.193]   - Field: ‘conditions’
[16:20:41.193]   - Field: ‘expr’
[16:20:41.193]   - Field: ‘uuid’
[16:20:41.194]   - Field: ‘seed’
[16:20:41.194]   - Field: ‘version’
[16:20:41.194]   - Field: ‘result’
[16:20:41.194]   - Field: ‘asynchronous’
[16:20:41.194]   - Field: ‘calls’
[16:20:41.194]   - Field: ‘globals’
[16:20:41.194]   - Field: ‘stdout’
[16:20:41.194]   - Field: ‘earlySignal’
[16:20:41.194]   - Field: ‘lazy’
[16:20:41.194]   - Field: ‘state’
[16:20:41.194] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.194] - Launch lazy future ...
[16:20:41.195] Packages needed by the future expression (n = 0): <none>
[16:20:41.195] Packages needed by future strategies (n = 0): <none>
[16:20:41.195] {
[16:20:41.195]     {
[16:20:41.195]         {
[16:20:41.195]             ...future.startTime <- base::Sys.time()
[16:20:41.195]             {
[16:20:41.195]                 {
[16:20:41.195]                   {
[16:20:41.195]                     base::local({
[16:20:41.195]                       has_future <- base::requireNamespace("future", 
[16:20:41.195]                         quietly = TRUE)
[16:20:41.195]                       if (has_future) {
[16:20:41.195]                         ns <- base::getNamespace("future")
[16:20:41.195]                         version <- ns[[".package"]][["version"]]
[16:20:41.195]                         if (is.null(version)) 
[16:20:41.195]                           version <- utils::packageVersion("future")
[16:20:41.195]                       }
[16:20:41.195]                       else {
[16:20:41.195]                         version <- NULL
[16:20:41.195]                       }
[16:20:41.195]                       if (!has_future || version < "1.8.0") {
[16:20:41.195]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.195]                           "", base::R.version$version.string), 
[16:20:41.195]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.195]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.195]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.195]                             "release", "version")], collapse = " "), 
[16:20:41.195]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.195]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.195]                           info)
[16:20:41.195]                         info <- base::paste(info, collapse = "; ")
[16:20:41.195]                         if (!has_future) {
[16:20:41.195]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.195]                             info)
[16:20:41.195]                         }
[16:20:41.195]                         else {
[16:20:41.195]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.195]                             info, version)
[16:20:41.195]                         }
[16:20:41.195]                         base::stop(msg)
[16:20:41.195]                       }
[16:20:41.195]                     })
[16:20:41.195]                   }
[16:20:41.195]                   ...future.strategy.old <- future::plan("list")
[16:20:41.195]                   options(future.plan = NULL)
[16:20:41.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.195]                 }
[16:20:41.195]                 ...future.workdir <- getwd()
[16:20:41.195]             }
[16:20:41.195]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.195]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.195]         }
[16:20:41.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.195]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.195]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.195]             base::names(...future.oldOptions))
[16:20:41.195]     }
[16:20:41.195]     if (FALSE) {
[16:20:41.195]     }
[16:20:41.195]     else {
[16:20:41.195]         if (TRUE) {
[16:20:41.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.195]                 open = "w")
[16:20:41.195]         }
[16:20:41.195]         else {
[16:20:41.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.195]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.195]         }
[16:20:41.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.195]             base::sink(type = "output", split = FALSE)
[16:20:41.195]             base::close(...future.stdout)
[16:20:41.195]         }, add = TRUE)
[16:20:41.195]     }
[16:20:41.195]     ...future.frame <- base::sys.nframe()
[16:20:41.195]     ...future.conditions <- base::list()
[16:20:41.195]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.195]     if (FALSE) {
[16:20:41.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.195]     }
[16:20:41.195]     ...future.result <- base::tryCatch({
[16:20:41.195]         base::withCallingHandlers({
[16:20:41.195]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.195]             future::FutureResult(value = ...future.value$value, 
[16:20:41.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.195]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.195]                     ...future.globalenv.names))
[16:20:41.195]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.195]         }, condition = base::local({
[16:20:41.195]             c <- base::c
[16:20:41.195]             inherits <- base::inherits
[16:20:41.195]             invokeRestart <- base::invokeRestart
[16:20:41.195]             length <- base::length
[16:20:41.195]             list <- base::list
[16:20:41.195]             seq.int <- base::seq.int
[16:20:41.195]             signalCondition <- base::signalCondition
[16:20:41.195]             sys.calls <- base::sys.calls
[16:20:41.195]             `[[` <- base::`[[`
[16:20:41.195]             `+` <- base::`+`
[16:20:41.195]             `<<-` <- base::`<<-`
[16:20:41.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.195]                   3L)]
[16:20:41.195]             }
[16:20:41.195]             function(cond) {
[16:20:41.195]                 is_error <- inherits(cond, "error")
[16:20:41.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.195]                   NULL)
[16:20:41.195]                 if (is_error) {
[16:20:41.195]                   sessionInformation <- function() {
[16:20:41.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.195]                       search = base::search(), system = base::Sys.info())
[16:20:41.195]                   }
[16:20:41.195]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.195]                     cond$call), session = sessionInformation(), 
[16:20:41.195]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.195]                   signalCondition(cond)
[16:20:41.195]                 }
[16:20:41.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.195]                 "immediateCondition"))) {
[16:20:41.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.195]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.195]                   if (TRUE && !signal) {
[16:20:41.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.195]                     {
[16:20:41.195]                       inherits <- base::inherits
[16:20:41.195]                       invokeRestart <- base::invokeRestart
[16:20:41.195]                       is.null <- base::is.null
[16:20:41.195]                       muffled <- FALSE
[16:20:41.195]                       if (inherits(cond, "message")) {
[16:20:41.195]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.195]                         if (muffled) 
[16:20:41.195]                           invokeRestart("muffleMessage")
[16:20:41.195]                       }
[16:20:41.195]                       else if (inherits(cond, "warning")) {
[16:20:41.195]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.195]                         if (muffled) 
[16:20:41.195]                           invokeRestart("muffleWarning")
[16:20:41.195]                       }
[16:20:41.195]                       else if (inherits(cond, "condition")) {
[16:20:41.195]                         if (!is.null(pattern)) {
[16:20:41.195]                           computeRestarts <- base::computeRestarts
[16:20:41.195]                           grepl <- base::grepl
[16:20:41.195]                           restarts <- computeRestarts(cond)
[16:20:41.195]                           for (restart in restarts) {
[16:20:41.195]                             name <- restart$name
[16:20:41.195]                             if (is.null(name)) 
[16:20:41.195]                               next
[16:20:41.195]                             if (!grepl(pattern, name)) 
[16:20:41.195]                               next
[16:20:41.195]                             invokeRestart(restart)
[16:20:41.195]                             muffled <- TRUE
[16:20:41.195]                             break
[16:20:41.195]                           }
[16:20:41.195]                         }
[16:20:41.195]                       }
[16:20:41.195]                       invisible(muffled)
[16:20:41.195]                     }
[16:20:41.195]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.195]                   }
[16:20:41.195]                 }
[16:20:41.195]                 else {
[16:20:41.195]                   if (TRUE) {
[16:20:41.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.195]                     {
[16:20:41.195]                       inherits <- base::inherits
[16:20:41.195]                       invokeRestart <- base::invokeRestart
[16:20:41.195]                       is.null <- base::is.null
[16:20:41.195]                       muffled <- FALSE
[16:20:41.195]                       if (inherits(cond, "message")) {
[16:20:41.195]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.195]                         if (muffled) 
[16:20:41.195]                           invokeRestart("muffleMessage")
[16:20:41.195]                       }
[16:20:41.195]                       else if (inherits(cond, "warning")) {
[16:20:41.195]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.195]                         if (muffled) 
[16:20:41.195]                           invokeRestart("muffleWarning")
[16:20:41.195]                       }
[16:20:41.195]                       else if (inherits(cond, "condition")) {
[16:20:41.195]                         if (!is.null(pattern)) {
[16:20:41.195]                           computeRestarts <- base::computeRestarts
[16:20:41.195]                           grepl <- base::grepl
[16:20:41.195]                           restarts <- computeRestarts(cond)
[16:20:41.195]                           for (restart in restarts) {
[16:20:41.195]                             name <- restart$name
[16:20:41.195]                             if (is.null(name)) 
[16:20:41.195]                               next
[16:20:41.195]                             if (!grepl(pattern, name)) 
[16:20:41.195]                               next
[16:20:41.195]                             invokeRestart(restart)
[16:20:41.195]                             muffled <- TRUE
[16:20:41.195]                             break
[16:20:41.195]                           }
[16:20:41.195]                         }
[16:20:41.195]                       }
[16:20:41.195]                       invisible(muffled)
[16:20:41.195]                     }
[16:20:41.195]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.195]                   }
[16:20:41.195]                 }
[16:20:41.195]             }
[16:20:41.195]         }))
[16:20:41.195]     }, error = function(ex) {
[16:20:41.195]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.195]                 ...future.rng), started = ...future.startTime, 
[16:20:41.195]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.195]             version = "1.8"), class = "FutureResult")
[16:20:41.195]     }, finally = {
[16:20:41.195]         if (!identical(...future.workdir, getwd())) 
[16:20:41.195]             setwd(...future.workdir)
[16:20:41.195]         {
[16:20:41.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.195]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.195]             }
[16:20:41.195]             base::options(...future.oldOptions)
[16:20:41.195]             if (.Platform$OS.type == "windows") {
[16:20:41.195]                 old_names <- names(...future.oldEnvVars)
[16:20:41.195]                 envs <- base::Sys.getenv()
[16:20:41.195]                 names <- names(envs)
[16:20:41.195]                 common <- intersect(names, old_names)
[16:20:41.195]                 added <- setdiff(names, old_names)
[16:20:41.195]                 removed <- setdiff(old_names, names)
[16:20:41.195]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.195]                   envs[common]]
[16:20:41.195]                 NAMES <- toupper(changed)
[16:20:41.195]                 args <- list()
[16:20:41.195]                 for (kk in seq_along(NAMES)) {
[16:20:41.195]                   name <- changed[[kk]]
[16:20:41.195]                   NAME <- NAMES[[kk]]
[16:20:41.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.195]                     next
[16:20:41.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.195]                 }
[16:20:41.195]                 NAMES <- toupper(added)
[16:20:41.195]                 for (kk in seq_along(NAMES)) {
[16:20:41.195]                   name <- added[[kk]]
[16:20:41.195]                   NAME <- NAMES[[kk]]
[16:20:41.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.195]                     next
[16:20:41.195]                   args[[name]] <- ""
[16:20:41.195]                 }
[16:20:41.195]                 NAMES <- toupper(removed)
[16:20:41.195]                 for (kk in seq_along(NAMES)) {
[16:20:41.195]                   name <- removed[[kk]]
[16:20:41.195]                   NAME <- NAMES[[kk]]
[16:20:41.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.195]                     next
[16:20:41.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.195]                 }
[16:20:41.195]                 if (length(args) > 0) 
[16:20:41.195]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.195]             }
[16:20:41.195]             else {
[16:20:41.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.195]             }
[16:20:41.195]             {
[16:20:41.195]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.195]                   0L) {
[16:20:41.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.195]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.195]                   base::options(opts)
[16:20:41.195]                 }
[16:20:41.195]                 {
[16:20:41.195]                   {
[16:20:41.195]                     NULL
[16:20:41.195]                     RNGkind("Mersenne-Twister")
[16:20:41.195]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.195]                       inherits = FALSE)
[16:20:41.195]                   }
[16:20:41.195]                   options(future.plan = NULL)
[16:20:41.195]                   if (is.na(NA_character_)) 
[16:20:41.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.195]                     .init = FALSE)
[16:20:41.195]                 }
[16:20:41.195]             }
[16:20:41.195]         }
[16:20:41.195]     })
[16:20:41.195]     if (TRUE) {
[16:20:41.195]         base::sink(type = "output", split = FALSE)
[16:20:41.195]         if (TRUE) {
[16:20:41.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.195]         }
[16:20:41.195]         else {
[16:20:41.195]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.195]         }
[16:20:41.195]         base::close(...future.stdout)
[16:20:41.195]         ...future.stdout <- NULL
[16:20:41.195]     }
[16:20:41.195]     ...future.result$conditions <- ...future.conditions
[16:20:41.195]     ...future.result$finished <- base::Sys.time()
[16:20:41.195]     ...future.result
[16:20:41.195] }
[16:20:41.197] plan(): Setting new future strategy stack:
[16:20:41.197] List of future strategies:
[16:20:41.197] 1. sequential:
[16:20:41.197]    - args: function (..., envir = parent.frame())
[16:20:41.197]    - tweaked: FALSE
[16:20:41.197]    - call: NULL
[16:20:41.197] plan(): nbrOfWorkers() = 1
[16:20:41.198] plan(): Setting new future strategy stack:
[16:20:41.198] List of future strategies:
[16:20:41.198] 1. sequential:
[16:20:41.198]    - args: function (..., envir = parent.frame())
[16:20:41.198]    - tweaked: FALSE
[16:20:41.198]    - call: plan(strategy)
[16:20:41.198] plan(): nbrOfWorkers() = 1
[16:20:41.198] SequentialFuture started (and completed)
[16:20:41.199] - Launch lazy future ... done
[16:20:41.199] run() for ‘SequentialFuture’ ... done
[16:20:41.199] getGlobalsAndPackages() ...
[16:20:41.199] Searching for globals...
[16:20:41.199] 
[16:20:41.199] Searching for globals ... DONE
[16:20:41.199] - globals: [0] <none>
[16:20:41.199] getGlobalsAndPackages() ... DONE
[16:20:41.200] run() for ‘Future’ ...
[16:20:41.200] - state: ‘created’
[16:20:41.200] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.200] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.200] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.200]   - Field: ‘label’
[16:20:41.200]   - Field: ‘local’
[16:20:41.200]   - Field: ‘owner’
[16:20:41.201]   - Field: ‘envir’
[16:20:41.201]   - Field: ‘packages’
[16:20:41.201]   - Field: ‘gc’
[16:20:41.201]   - Field: ‘conditions’
[16:20:41.201]   - Field: ‘expr’
[16:20:41.201]   - Field: ‘uuid’
[16:20:41.201]   - Field: ‘seed’
[16:20:41.201]   - Field: ‘version’
[16:20:41.201]   - Field: ‘result’
[16:20:41.201]   - Field: ‘asynchronous’
[16:20:41.201]   - Field: ‘calls’
[16:20:41.201]   - Field: ‘globals’
[16:20:41.202]   - Field: ‘stdout’
[16:20:41.202]   - Field: ‘earlySignal’
[16:20:41.202]   - Field: ‘lazy’
[16:20:41.202]   - Field: ‘state’
[16:20:41.202] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.202] - Launch lazy future ...
[16:20:41.202] Packages needed by the future expression (n = 0): <none>
[16:20:41.202] Packages needed by future strategies (n = 0): <none>
[16:20:41.203] {
[16:20:41.203]     {
[16:20:41.203]         {
[16:20:41.203]             ...future.startTime <- base::Sys.time()
[16:20:41.203]             {
[16:20:41.203]                 {
[16:20:41.203]                   {
[16:20:41.203]                     base::local({
[16:20:41.203]                       has_future <- base::requireNamespace("future", 
[16:20:41.203]                         quietly = TRUE)
[16:20:41.203]                       if (has_future) {
[16:20:41.203]                         ns <- base::getNamespace("future")
[16:20:41.203]                         version <- ns[[".package"]][["version"]]
[16:20:41.203]                         if (is.null(version)) 
[16:20:41.203]                           version <- utils::packageVersion("future")
[16:20:41.203]                       }
[16:20:41.203]                       else {
[16:20:41.203]                         version <- NULL
[16:20:41.203]                       }
[16:20:41.203]                       if (!has_future || version < "1.8.0") {
[16:20:41.203]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.203]                           "", base::R.version$version.string), 
[16:20:41.203]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.203]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.203]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.203]                             "release", "version")], collapse = " "), 
[16:20:41.203]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.203]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.203]                           info)
[16:20:41.203]                         info <- base::paste(info, collapse = "; ")
[16:20:41.203]                         if (!has_future) {
[16:20:41.203]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.203]                             info)
[16:20:41.203]                         }
[16:20:41.203]                         else {
[16:20:41.203]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.203]                             info, version)
[16:20:41.203]                         }
[16:20:41.203]                         base::stop(msg)
[16:20:41.203]                       }
[16:20:41.203]                     })
[16:20:41.203]                   }
[16:20:41.203]                   ...future.strategy.old <- future::plan("list")
[16:20:41.203]                   options(future.plan = NULL)
[16:20:41.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.203]                 }
[16:20:41.203]                 ...future.workdir <- getwd()
[16:20:41.203]             }
[16:20:41.203]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.203]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.203]         }
[16:20:41.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.203]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.203]             base::names(...future.oldOptions))
[16:20:41.203]     }
[16:20:41.203]     if (FALSE) {
[16:20:41.203]     }
[16:20:41.203]     else {
[16:20:41.203]         if (TRUE) {
[16:20:41.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.203]                 open = "w")
[16:20:41.203]         }
[16:20:41.203]         else {
[16:20:41.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.203]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.203]         }
[16:20:41.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.203]             base::sink(type = "output", split = FALSE)
[16:20:41.203]             base::close(...future.stdout)
[16:20:41.203]         }, add = TRUE)
[16:20:41.203]     }
[16:20:41.203]     ...future.frame <- base::sys.nframe()
[16:20:41.203]     ...future.conditions <- base::list()
[16:20:41.203]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.203]     if (FALSE) {
[16:20:41.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.203]     }
[16:20:41.203]     ...future.result <- base::tryCatch({
[16:20:41.203]         base::withCallingHandlers({
[16:20:41.203]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.203]             future::FutureResult(value = ...future.value$value, 
[16:20:41.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.203]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.203]                     ...future.globalenv.names))
[16:20:41.203]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.203]         }, condition = base::local({
[16:20:41.203]             c <- base::c
[16:20:41.203]             inherits <- base::inherits
[16:20:41.203]             invokeRestart <- base::invokeRestart
[16:20:41.203]             length <- base::length
[16:20:41.203]             list <- base::list
[16:20:41.203]             seq.int <- base::seq.int
[16:20:41.203]             signalCondition <- base::signalCondition
[16:20:41.203]             sys.calls <- base::sys.calls
[16:20:41.203]             `[[` <- base::`[[`
[16:20:41.203]             `+` <- base::`+`
[16:20:41.203]             `<<-` <- base::`<<-`
[16:20:41.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.203]                   3L)]
[16:20:41.203]             }
[16:20:41.203]             function(cond) {
[16:20:41.203]                 is_error <- inherits(cond, "error")
[16:20:41.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.203]                   NULL)
[16:20:41.203]                 if (is_error) {
[16:20:41.203]                   sessionInformation <- function() {
[16:20:41.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.203]                       search = base::search(), system = base::Sys.info())
[16:20:41.203]                   }
[16:20:41.203]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.203]                     cond$call), session = sessionInformation(), 
[16:20:41.203]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.203]                   signalCondition(cond)
[16:20:41.203]                 }
[16:20:41.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.203]                 "immediateCondition"))) {
[16:20:41.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.203]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.203]                   if (TRUE && !signal) {
[16:20:41.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.203]                     {
[16:20:41.203]                       inherits <- base::inherits
[16:20:41.203]                       invokeRestart <- base::invokeRestart
[16:20:41.203]                       is.null <- base::is.null
[16:20:41.203]                       muffled <- FALSE
[16:20:41.203]                       if (inherits(cond, "message")) {
[16:20:41.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.203]                         if (muffled) 
[16:20:41.203]                           invokeRestart("muffleMessage")
[16:20:41.203]                       }
[16:20:41.203]                       else if (inherits(cond, "warning")) {
[16:20:41.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.203]                         if (muffled) 
[16:20:41.203]                           invokeRestart("muffleWarning")
[16:20:41.203]                       }
[16:20:41.203]                       else if (inherits(cond, "condition")) {
[16:20:41.203]                         if (!is.null(pattern)) {
[16:20:41.203]                           computeRestarts <- base::computeRestarts
[16:20:41.203]                           grepl <- base::grepl
[16:20:41.203]                           restarts <- computeRestarts(cond)
[16:20:41.203]                           for (restart in restarts) {
[16:20:41.203]                             name <- restart$name
[16:20:41.203]                             if (is.null(name)) 
[16:20:41.203]                               next
[16:20:41.203]                             if (!grepl(pattern, name)) 
[16:20:41.203]                               next
[16:20:41.203]                             invokeRestart(restart)
[16:20:41.203]                             muffled <- TRUE
[16:20:41.203]                             break
[16:20:41.203]                           }
[16:20:41.203]                         }
[16:20:41.203]                       }
[16:20:41.203]                       invisible(muffled)
[16:20:41.203]                     }
[16:20:41.203]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.203]                   }
[16:20:41.203]                 }
[16:20:41.203]                 else {
[16:20:41.203]                   if (TRUE) {
[16:20:41.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.203]                     {
[16:20:41.203]                       inherits <- base::inherits
[16:20:41.203]                       invokeRestart <- base::invokeRestart
[16:20:41.203]                       is.null <- base::is.null
[16:20:41.203]                       muffled <- FALSE
[16:20:41.203]                       if (inherits(cond, "message")) {
[16:20:41.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.203]                         if (muffled) 
[16:20:41.203]                           invokeRestart("muffleMessage")
[16:20:41.203]                       }
[16:20:41.203]                       else if (inherits(cond, "warning")) {
[16:20:41.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.203]                         if (muffled) 
[16:20:41.203]                           invokeRestart("muffleWarning")
[16:20:41.203]                       }
[16:20:41.203]                       else if (inherits(cond, "condition")) {
[16:20:41.203]                         if (!is.null(pattern)) {
[16:20:41.203]                           computeRestarts <- base::computeRestarts
[16:20:41.203]                           grepl <- base::grepl
[16:20:41.203]                           restarts <- computeRestarts(cond)
[16:20:41.203]                           for (restart in restarts) {
[16:20:41.203]                             name <- restart$name
[16:20:41.203]                             if (is.null(name)) 
[16:20:41.203]                               next
[16:20:41.203]                             if (!grepl(pattern, name)) 
[16:20:41.203]                               next
[16:20:41.203]                             invokeRestart(restart)
[16:20:41.203]                             muffled <- TRUE
[16:20:41.203]                             break
[16:20:41.203]                           }
[16:20:41.203]                         }
[16:20:41.203]                       }
[16:20:41.203]                       invisible(muffled)
[16:20:41.203]                     }
[16:20:41.203]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.203]                   }
[16:20:41.203]                 }
[16:20:41.203]             }
[16:20:41.203]         }))
[16:20:41.203]     }, error = function(ex) {
[16:20:41.203]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.203]                 ...future.rng), started = ...future.startTime, 
[16:20:41.203]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.203]             version = "1.8"), class = "FutureResult")
[16:20:41.203]     }, finally = {
[16:20:41.203]         if (!identical(...future.workdir, getwd())) 
[16:20:41.203]             setwd(...future.workdir)
[16:20:41.203]         {
[16:20:41.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.203]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.203]             }
[16:20:41.203]             base::options(...future.oldOptions)
[16:20:41.203]             if (.Platform$OS.type == "windows") {
[16:20:41.203]                 old_names <- names(...future.oldEnvVars)
[16:20:41.203]                 envs <- base::Sys.getenv()
[16:20:41.203]                 names <- names(envs)
[16:20:41.203]                 common <- intersect(names, old_names)
[16:20:41.203]                 added <- setdiff(names, old_names)
[16:20:41.203]                 removed <- setdiff(old_names, names)
[16:20:41.203]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.203]                   envs[common]]
[16:20:41.203]                 NAMES <- toupper(changed)
[16:20:41.203]                 args <- list()
[16:20:41.203]                 for (kk in seq_along(NAMES)) {
[16:20:41.203]                   name <- changed[[kk]]
[16:20:41.203]                   NAME <- NAMES[[kk]]
[16:20:41.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.203]                     next
[16:20:41.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.203]                 }
[16:20:41.203]                 NAMES <- toupper(added)
[16:20:41.203]                 for (kk in seq_along(NAMES)) {
[16:20:41.203]                   name <- added[[kk]]
[16:20:41.203]                   NAME <- NAMES[[kk]]
[16:20:41.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.203]                     next
[16:20:41.203]                   args[[name]] <- ""
[16:20:41.203]                 }
[16:20:41.203]                 NAMES <- toupper(removed)
[16:20:41.203]                 for (kk in seq_along(NAMES)) {
[16:20:41.203]                   name <- removed[[kk]]
[16:20:41.203]                   NAME <- NAMES[[kk]]
[16:20:41.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.203]                     next
[16:20:41.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.203]                 }
[16:20:41.203]                 if (length(args) > 0) 
[16:20:41.203]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.203]             }
[16:20:41.203]             else {
[16:20:41.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.203]             }
[16:20:41.203]             {
[16:20:41.203]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.203]                   0L) {
[16:20:41.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.203]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.203]                   base::options(opts)
[16:20:41.203]                 }
[16:20:41.203]                 {
[16:20:41.203]                   {
[16:20:41.203]                     NULL
[16:20:41.203]                     RNGkind("Mersenne-Twister")
[16:20:41.203]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.203]                       inherits = FALSE)
[16:20:41.203]                   }
[16:20:41.203]                   options(future.plan = NULL)
[16:20:41.203]                   if (is.na(NA_character_)) 
[16:20:41.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.203]                     .init = FALSE)
[16:20:41.203]                 }
[16:20:41.203]             }
[16:20:41.203]         }
[16:20:41.203]     })
[16:20:41.203]     if (TRUE) {
[16:20:41.203]         base::sink(type = "output", split = FALSE)
[16:20:41.203]         if (TRUE) {
[16:20:41.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.203]         }
[16:20:41.203]         else {
[16:20:41.203]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.203]         }
[16:20:41.203]         base::close(...future.stdout)
[16:20:41.203]         ...future.stdout <- NULL
[16:20:41.203]     }
[16:20:41.203]     ...future.result$conditions <- ...future.conditions
[16:20:41.203]     ...future.result$finished <- base::Sys.time()
[16:20:41.203]     ...future.result
[16:20:41.203] }
[16:20:41.204] plan(): Setting new future strategy stack:
[16:20:41.204] List of future strategies:
[16:20:41.204] 1. sequential:
[16:20:41.204]    - args: function (..., envir = parent.frame())
[16:20:41.204]    - tweaked: FALSE
[16:20:41.204]    - call: NULL
[16:20:41.205] plan(): nbrOfWorkers() = 1
[16:20:41.205] plan(): Setting new future strategy stack:
[16:20:41.206] List of future strategies:
[16:20:41.206] 1. sequential:
[16:20:41.206]    - args: function (..., envir = parent.frame())
[16:20:41.206]    - tweaked: FALSE
[16:20:41.206]    - call: plan(strategy)
[16:20:41.206] plan(): nbrOfWorkers() = 1
[16:20:41.206] SequentialFuture started (and completed)
[16:20:41.206] - Launch lazy future ... done
[16:20:41.206] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0a2c3ac8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0bd88848> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0a2c3ac8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0bd88848> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:41.211] resolved() for ‘SequentialFuture’ ...
[16:20:41.211] - state: ‘finished’
[16:20:41.211] - run: TRUE
[16:20:41.211] - result: ‘FutureResult’
[16:20:41.211] resolved() for ‘SequentialFuture’ ... done
[16:20:41.211] resolved() for ‘SequentialFuture’ ...
[16:20:41.212] - state: ‘finished’
[16:20:41.212] - run: TRUE
[16:20:41.212] - result: ‘FutureResult’
[16:20:41.212] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:41.214] resolve() on list ...
[16:20:41.214]  recursive: 0
[16:20:41.214]  length: 6
[16:20:41.214]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:41.214] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.214] - nx: 6
[16:20:41.214] - relay: TRUE
[16:20:41.214] - stdout: TRUE
[16:20:41.214] - signal: TRUE
[16:20:41.214] - resignal: FALSE
[16:20:41.214] - force: TRUE
[16:20:41.214] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.215] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.215]  - until=2
[16:20:41.215]  - relaying element #2
[16:20:41.215] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.215] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.215] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.215]  length: 5 (resolved future 1)
[16:20:41.216] resolved() for ‘SequentialFuture’ ...
[16:20:41.216] - state: ‘finished’
[16:20:41.216] - run: TRUE
[16:20:41.216] - result: ‘FutureResult’
[16:20:41.217] resolved() for ‘SequentialFuture’ ... done
[16:20:41.217] Future #2
[16:20:41.217] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.217] - nx: 6
[16:20:41.217] - relay: TRUE
[16:20:41.217] - stdout: TRUE
[16:20:41.217] - signal: TRUE
[16:20:41.217] - resignal: FALSE
[16:20:41.217] - force: TRUE
[16:20:41.217] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.217] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.218]  - until=2
[16:20:41.218]  - relaying element #2
[16:20:41.218] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.218] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.218] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.218]  length: 4 (resolved future 2)
[16:20:41.218] resolved() for ‘SequentialFuture’ ...
[16:20:41.218] - state: ‘finished’
[16:20:41.218] - run: TRUE
[16:20:41.218] - result: ‘FutureResult’
[16:20:41.219] resolved() for ‘SequentialFuture’ ... done
[16:20:41.219] Future #3
[16:20:41.219] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.219] - nx: 6
[16:20:41.219] - relay: TRUE
[16:20:41.219] - stdout: TRUE
[16:20:41.219] - signal: TRUE
[16:20:41.219] - resignal: FALSE
[16:20:41.219] - force: TRUE
[16:20:41.219] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.219] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.219]  - until=3
[16:20:41.220]  - relaying element #3
[16:20:41.220] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.220] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.220] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.220]  length: 3 (resolved future 3)
[16:20:41.220] signalConditionsASAP(NULL, pos=4) ...
[16:20:41.220] - nx: 6
[16:20:41.220] - relay: TRUE
[16:20:41.220] - stdout: TRUE
[16:20:41.220] - signal: TRUE
[16:20:41.221] - resignal: FALSE
[16:20:41.221] - force: TRUE
[16:20:41.221] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.221] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.221]  - until=5
[16:20:41.221]  - relaying element #5
[16:20:41.221] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.221] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.221] signalConditionsASAP(NULL, pos=4) ... done
[16:20:41.221]  length: 2 (resolved future 4)
[16:20:41.221] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.221] - nx: 6
[16:20:41.222] - relay: TRUE
[16:20:41.222] - stdout: TRUE
[16:20:41.222] - signal: TRUE
[16:20:41.222] - resignal: FALSE
[16:20:41.222] - force: TRUE
[16:20:41.222] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.222] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.222]  - until=6
[16:20:41.222]  - relaying element #6
[16:20:41.222] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.222] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.222] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.222]  length: 1 (resolved future 5)
[16:20:41.223] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.223] - nx: 6
[16:20:41.223] - relay: TRUE
[16:20:41.223] - stdout: TRUE
[16:20:41.223] - signal: TRUE
[16:20:41.223] - resignal: FALSE
[16:20:41.223] - force: TRUE
[16:20:41.223] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.223] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.223]  - until=6
[16:20:41.223] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.223] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.224] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.224]  length: 0 (resolved future 6)
[16:20:41.224] Relaying remaining futures
[16:20:41.224] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.224] - nx: 6
[16:20:41.224] - relay: TRUE
[16:20:41.224] - stdout: TRUE
[16:20:41.224] - signal: TRUE
[16:20:41.224] - resignal: FALSE
[16:20:41.224] - force: TRUE
[16:20:41.224] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.224] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:41.225] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.225] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.225] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.225] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:20:41.228] getGlobalsAndPackages() ...
[16:20:41.228] Searching for globals...
[16:20:41.228] 
[16:20:41.229] Searching for globals ... DONE
[16:20:41.229] - globals: [0] <none>
[16:20:41.229] getGlobalsAndPackages() ... DONE
[16:20:41.229] run() for ‘Future’ ...
[16:20:41.229] - state: ‘created’
[16:20:41.229] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.229] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.230]   - Field: ‘label’
[16:20:41.230]   - Field: ‘local’
[16:20:41.230]   - Field: ‘owner’
[16:20:41.230]   - Field: ‘envir’
[16:20:41.230]   - Field: ‘packages’
[16:20:41.230]   - Field: ‘gc’
[16:20:41.230]   - Field: ‘conditions’
[16:20:41.230]   - Field: ‘expr’
[16:20:41.230]   - Field: ‘uuid’
[16:20:41.230]   - Field: ‘seed’
[16:20:41.230]   - Field: ‘version’
[16:20:41.231]   - Field: ‘result’
[16:20:41.231]   - Field: ‘asynchronous’
[16:20:41.231]   - Field: ‘calls’
[16:20:41.231]   - Field: ‘globals’
[16:20:41.231]   - Field: ‘stdout’
[16:20:41.231]   - Field: ‘earlySignal’
[16:20:41.231]   - Field: ‘lazy’
[16:20:41.231]   - Field: ‘state’
[16:20:41.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.231] - Launch lazy future ...
[16:20:41.231] Packages needed by the future expression (n = 0): <none>
[16:20:41.232] Packages needed by future strategies (n = 0): <none>
[16:20:41.232] {
[16:20:41.232]     {
[16:20:41.232]         {
[16:20:41.232]             ...future.startTime <- base::Sys.time()
[16:20:41.232]             {
[16:20:41.232]                 {
[16:20:41.232]                   {
[16:20:41.232]                     base::local({
[16:20:41.232]                       has_future <- base::requireNamespace("future", 
[16:20:41.232]                         quietly = TRUE)
[16:20:41.232]                       if (has_future) {
[16:20:41.232]                         ns <- base::getNamespace("future")
[16:20:41.232]                         version <- ns[[".package"]][["version"]]
[16:20:41.232]                         if (is.null(version)) 
[16:20:41.232]                           version <- utils::packageVersion("future")
[16:20:41.232]                       }
[16:20:41.232]                       else {
[16:20:41.232]                         version <- NULL
[16:20:41.232]                       }
[16:20:41.232]                       if (!has_future || version < "1.8.0") {
[16:20:41.232]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.232]                           "", base::R.version$version.string), 
[16:20:41.232]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.232]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.232]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.232]                             "release", "version")], collapse = " "), 
[16:20:41.232]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.232]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.232]                           info)
[16:20:41.232]                         info <- base::paste(info, collapse = "; ")
[16:20:41.232]                         if (!has_future) {
[16:20:41.232]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.232]                             info)
[16:20:41.232]                         }
[16:20:41.232]                         else {
[16:20:41.232]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.232]                             info, version)
[16:20:41.232]                         }
[16:20:41.232]                         base::stop(msg)
[16:20:41.232]                       }
[16:20:41.232]                     })
[16:20:41.232]                   }
[16:20:41.232]                   ...future.strategy.old <- future::plan("list")
[16:20:41.232]                   options(future.plan = NULL)
[16:20:41.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.232]                 }
[16:20:41.232]                 ...future.workdir <- getwd()
[16:20:41.232]             }
[16:20:41.232]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.232]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.232]         }
[16:20:41.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.232]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.232]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.232]             base::names(...future.oldOptions))
[16:20:41.232]     }
[16:20:41.232]     if (FALSE) {
[16:20:41.232]     }
[16:20:41.232]     else {
[16:20:41.232]         if (TRUE) {
[16:20:41.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.232]                 open = "w")
[16:20:41.232]         }
[16:20:41.232]         else {
[16:20:41.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.232]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.232]         }
[16:20:41.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.232]             base::sink(type = "output", split = FALSE)
[16:20:41.232]             base::close(...future.stdout)
[16:20:41.232]         }, add = TRUE)
[16:20:41.232]     }
[16:20:41.232]     ...future.frame <- base::sys.nframe()
[16:20:41.232]     ...future.conditions <- base::list()
[16:20:41.232]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.232]     if (FALSE) {
[16:20:41.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.232]     }
[16:20:41.232]     ...future.result <- base::tryCatch({
[16:20:41.232]         base::withCallingHandlers({
[16:20:41.232]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.232]             future::FutureResult(value = ...future.value$value, 
[16:20:41.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.232]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.232]                     ...future.globalenv.names))
[16:20:41.232]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.232]         }, condition = base::local({
[16:20:41.232]             c <- base::c
[16:20:41.232]             inherits <- base::inherits
[16:20:41.232]             invokeRestart <- base::invokeRestart
[16:20:41.232]             length <- base::length
[16:20:41.232]             list <- base::list
[16:20:41.232]             seq.int <- base::seq.int
[16:20:41.232]             signalCondition <- base::signalCondition
[16:20:41.232]             sys.calls <- base::sys.calls
[16:20:41.232]             `[[` <- base::`[[`
[16:20:41.232]             `+` <- base::`+`
[16:20:41.232]             `<<-` <- base::`<<-`
[16:20:41.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.232]                   3L)]
[16:20:41.232]             }
[16:20:41.232]             function(cond) {
[16:20:41.232]                 is_error <- inherits(cond, "error")
[16:20:41.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.232]                   NULL)
[16:20:41.232]                 if (is_error) {
[16:20:41.232]                   sessionInformation <- function() {
[16:20:41.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.232]                       search = base::search(), system = base::Sys.info())
[16:20:41.232]                   }
[16:20:41.232]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.232]                     cond$call), session = sessionInformation(), 
[16:20:41.232]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.232]                   signalCondition(cond)
[16:20:41.232]                 }
[16:20:41.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.232]                 "immediateCondition"))) {
[16:20:41.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.232]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.232]                   if (TRUE && !signal) {
[16:20:41.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.232]                     {
[16:20:41.232]                       inherits <- base::inherits
[16:20:41.232]                       invokeRestart <- base::invokeRestart
[16:20:41.232]                       is.null <- base::is.null
[16:20:41.232]                       muffled <- FALSE
[16:20:41.232]                       if (inherits(cond, "message")) {
[16:20:41.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.232]                         if (muffled) 
[16:20:41.232]                           invokeRestart("muffleMessage")
[16:20:41.232]                       }
[16:20:41.232]                       else if (inherits(cond, "warning")) {
[16:20:41.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.232]                         if (muffled) 
[16:20:41.232]                           invokeRestart("muffleWarning")
[16:20:41.232]                       }
[16:20:41.232]                       else if (inherits(cond, "condition")) {
[16:20:41.232]                         if (!is.null(pattern)) {
[16:20:41.232]                           computeRestarts <- base::computeRestarts
[16:20:41.232]                           grepl <- base::grepl
[16:20:41.232]                           restarts <- computeRestarts(cond)
[16:20:41.232]                           for (restart in restarts) {
[16:20:41.232]                             name <- restart$name
[16:20:41.232]                             if (is.null(name)) 
[16:20:41.232]                               next
[16:20:41.232]                             if (!grepl(pattern, name)) 
[16:20:41.232]                               next
[16:20:41.232]                             invokeRestart(restart)
[16:20:41.232]                             muffled <- TRUE
[16:20:41.232]                             break
[16:20:41.232]                           }
[16:20:41.232]                         }
[16:20:41.232]                       }
[16:20:41.232]                       invisible(muffled)
[16:20:41.232]                     }
[16:20:41.232]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.232]                   }
[16:20:41.232]                 }
[16:20:41.232]                 else {
[16:20:41.232]                   if (TRUE) {
[16:20:41.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.232]                     {
[16:20:41.232]                       inherits <- base::inherits
[16:20:41.232]                       invokeRestart <- base::invokeRestart
[16:20:41.232]                       is.null <- base::is.null
[16:20:41.232]                       muffled <- FALSE
[16:20:41.232]                       if (inherits(cond, "message")) {
[16:20:41.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.232]                         if (muffled) 
[16:20:41.232]                           invokeRestart("muffleMessage")
[16:20:41.232]                       }
[16:20:41.232]                       else if (inherits(cond, "warning")) {
[16:20:41.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.232]                         if (muffled) 
[16:20:41.232]                           invokeRestart("muffleWarning")
[16:20:41.232]                       }
[16:20:41.232]                       else if (inherits(cond, "condition")) {
[16:20:41.232]                         if (!is.null(pattern)) {
[16:20:41.232]                           computeRestarts <- base::computeRestarts
[16:20:41.232]                           grepl <- base::grepl
[16:20:41.232]                           restarts <- computeRestarts(cond)
[16:20:41.232]                           for (restart in restarts) {
[16:20:41.232]                             name <- restart$name
[16:20:41.232]                             if (is.null(name)) 
[16:20:41.232]                               next
[16:20:41.232]                             if (!grepl(pattern, name)) 
[16:20:41.232]                               next
[16:20:41.232]                             invokeRestart(restart)
[16:20:41.232]                             muffled <- TRUE
[16:20:41.232]                             break
[16:20:41.232]                           }
[16:20:41.232]                         }
[16:20:41.232]                       }
[16:20:41.232]                       invisible(muffled)
[16:20:41.232]                     }
[16:20:41.232]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.232]                   }
[16:20:41.232]                 }
[16:20:41.232]             }
[16:20:41.232]         }))
[16:20:41.232]     }, error = function(ex) {
[16:20:41.232]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.232]                 ...future.rng), started = ...future.startTime, 
[16:20:41.232]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.232]             version = "1.8"), class = "FutureResult")
[16:20:41.232]     }, finally = {
[16:20:41.232]         if (!identical(...future.workdir, getwd())) 
[16:20:41.232]             setwd(...future.workdir)
[16:20:41.232]         {
[16:20:41.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.232]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.232]             }
[16:20:41.232]             base::options(...future.oldOptions)
[16:20:41.232]             if (.Platform$OS.type == "windows") {
[16:20:41.232]                 old_names <- names(...future.oldEnvVars)
[16:20:41.232]                 envs <- base::Sys.getenv()
[16:20:41.232]                 names <- names(envs)
[16:20:41.232]                 common <- intersect(names, old_names)
[16:20:41.232]                 added <- setdiff(names, old_names)
[16:20:41.232]                 removed <- setdiff(old_names, names)
[16:20:41.232]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.232]                   envs[common]]
[16:20:41.232]                 NAMES <- toupper(changed)
[16:20:41.232]                 args <- list()
[16:20:41.232]                 for (kk in seq_along(NAMES)) {
[16:20:41.232]                   name <- changed[[kk]]
[16:20:41.232]                   NAME <- NAMES[[kk]]
[16:20:41.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.232]                     next
[16:20:41.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.232]                 }
[16:20:41.232]                 NAMES <- toupper(added)
[16:20:41.232]                 for (kk in seq_along(NAMES)) {
[16:20:41.232]                   name <- added[[kk]]
[16:20:41.232]                   NAME <- NAMES[[kk]]
[16:20:41.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.232]                     next
[16:20:41.232]                   args[[name]] <- ""
[16:20:41.232]                 }
[16:20:41.232]                 NAMES <- toupper(removed)
[16:20:41.232]                 for (kk in seq_along(NAMES)) {
[16:20:41.232]                   name <- removed[[kk]]
[16:20:41.232]                   NAME <- NAMES[[kk]]
[16:20:41.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.232]                     next
[16:20:41.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.232]                 }
[16:20:41.232]                 if (length(args) > 0) 
[16:20:41.232]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.232]             }
[16:20:41.232]             else {
[16:20:41.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.232]             }
[16:20:41.232]             {
[16:20:41.232]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.232]                   0L) {
[16:20:41.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.232]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.232]                   base::options(opts)
[16:20:41.232]                 }
[16:20:41.232]                 {
[16:20:41.232]                   {
[16:20:41.232]                     NULL
[16:20:41.232]                     RNGkind("Mersenne-Twister")
[16:20:41.232]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.232]                       inherits = FALSE)
[16:20:41.232]                   }
[16:20:41.232]                   options(future.plan = NULL)
[16:20:41.232]                   if (is.na(NA_character_)) 
[16:20:41.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.232]                     .init = FALSE)
[16:20:41.232]                 }
[16:20:41.232]             }
[16:20:41.232]         }
[16:20:41.232]     })
[16:20:41.232]     if (TRUE) {
[16:20:41.232]         base::sink(type = "output", split = FALSE)
[16:20:41.232]         if (TRUE) {
[16:20:41.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.232]         }
[16:20:41.232]         else {
[16:20:41.232]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.232]         }
[16:20:41.232]         base::close(...future.stdout)
[16:20:41.232]         ...future.stdout <- NULL
[16:20:41.232]     }
[16:20:41.232]     ...future.result$conditions <- ...future.conditions
[16:20:41.232]     ...future.result$finished <- base::Sys.time()
[16:20:41.232]     ...future.result
[16:20:41.232] }
[16:20:41.234] plan(): Setting new future strategy stack:
[16:20:41.234] List of future strategies:
[16:20:41.234] 1. sequential:
[16:20:41.234]    - args: function (..., envir = parent.frame())
[16:20:41.234]    - tweaked: FALSE
[16:20:41.234]    - call: NULL
[16:20:41.234] plan(): nbrOfWorkers() = 1
[16:20:41.235] plan(): Setting new future strategy stack:
[16:20:41.235] List of future strategies:
[16:20:41.235] 1. sequential:
[16:20:41.235]    - args: function (..., envir = parent.frame())
[16:20:41.235]    - tweaked: FALSE
[16:20:41.235]    - call: plan(strategy)
[16:20:41.235] plan(): nbrOfWorkers() = 1
[16:20:41.235] SequentialFuture started (and completed)
[16:20:41.236] - Launch lazy future ... done
[16:20:41.236] run() for ‘SequentialFuture’ ... done
[16:20:41.236] getGlobalsAndPackages() ...
[16:20:41.236] Searching for globals...
[16:20:41.236] 
[16:20:41.236] Searching for globals ... DONE
[16:20:41.236] - globals: [0] <none>
[16:20:41.236] getGlobalsAndPackages() ... DONE
[16:20:41.237] run() for ‘Future’ ...
[16:20:41.237] - state: ‘created’
[16:20:41.237] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.237] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.237] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.237]   - Field: ‘label’
[16:20:41.237]   - Field: ‘local’
[16:20:41.237]   - Field: ‘owner’
[16:20:41.238]   - Field: ‘envir’
[16:20:41.238]   - Field: ‘packages’
[16:20:41.238]   - Field: ‘gc’
[16:20:41.238]   - Field: ‘conditions’
[16:20:41.238]   - Field: ‘expr’
[16:20:41.238]   - Field: ‘uuid’
[16:20:41.238]   - Field: ‘seed’
[16:20:41.238]   - Field: ‘version’
[16:20:41.238]   - Field: ‘result’
[16:20:41.238]   - Field: ‘asynchronous’
[16:20:41.238]   - Field: ‘calls’
[16:20:41.238]   - Field: ‘globals’
[16:20:41.239]   - Field: ‘stdout’
[16:20:41.239]   - Field: ‘earlySignal’
[16:20:41.239]   - Field: ‘lazy’
[16:20:41.239]   - Field: ‘state’
[16:20:41.239] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.239] - Launch lazy future ...
[16:20:41.239] Packages needed by the future expression (n = 0): <none>
[16:20:41.239] Packages needed by future strategies (n = 0): <none>
[16:20:41.240] {
[16:20:41.240]     {
[16:20:41.240]         {
[16:20:41.240]             ...future.startTime <- base::Sys.time()
[16:20:41.240]             {
[16:20:41.240]                 {
[16:20:41.240]                   {
[16:20:41.240]                     base::local({
[16:20:41.240]                       has_future <- base::requireNamespace("future", 
[16:20:41.240]                         quietly = TRUE)
[16:20:41.240]                       if (has_future) {
[16:20:41.240]                         ns <- base::getNamespace("future")
[16:20:41.240]                         version <- ns[[".package"]][["version"]]
[16:20:41.240]                         if (is.null(version)) 
[16:20:41.240]                           version <- utils::packageVersion("future")
[16:20:41.240]                       }
[16:20:41.240]                       else {
[16:20:41.240]                         version <- NULL
[16:20:41.240]                       }
[16:20:41.240]                       if (!has_future || version < "1.8.0") {
[16:20:41.240]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.240]                           "", base::R.version$version.string), 
[16:20:41.240]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.240]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.240]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.240]                             "release", "version")], collapse = " "), 
[16:20:41.240]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.240]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.240]                           info)
[16:20:41.240]                         info <- base::paste(info, collapse = "; ")
[16:20:41.240]                         if (!has_future) {
[16:20:41.240]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.240]                             info)
[16:20:41.240]                         }
[16:20:41.240]                         else {
[16:20:41.240]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.240]                             info, version)
[16:20:41.240]                         }
[16:20:41.240]                         base::stop(msg)
[16:20:41.240]                       }
[16:20:41.240]                     })
[16:20:41.240]                   }
[16:20:41.240]                   ...future.strategy.old <- future::plan("list")
[16:20:41.240]                   options(future.plan = NULL)
[16:20:41.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.240]                 }
[16:20:41.240]                 ...future.workdir <- getwd()
[16:20:41.240]             }
[16:20:41.240]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.240]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.240]         }
[16:20:41.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.240]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.240]             base::names(...future.oldOptions))
[16:20:41.240]     }
[16:20:41.240]     if (FALSE) {
[16:20:41.240]     }
[16:20:41.240]     else {
[16:20:41.240]         if (TRUE) {
[16:20:41.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.240]                 open = "w")
[16:20:41.240]         }
[16:20:41.240]         else {
[16:20:41.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.240]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.240]         }
[16:20:41.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.240]             base::sink(type = "output", split = FALSE)
[16:20:41.240]             base::close(...future.stdout)
[16:20:41.240]         }, add = TRUE)
[16:20:41.240]     }
[16:20:41.240]     ...future.frame <- base::sys.nframe()
[16:20:41.240]     ...future.conditions <- base::list()
[16:20:41.240]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.240]     if (FALSE) {
[16:20:41.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.240]     }
[16:20:41.240]     ...future.result <- base::tryCatch({
[16:20:41.240]         base::withCallingHandlers({
[16:20:41.240]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.240]             future::FutureResult(value = ...future.value$value, 
[16:20:41.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.240]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.240]                     ...future.globalenv.names))
[16:20:41.240]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.240]         }, condition = base::local({
[16:20:41.240]             c <- base::c
[16:20:41.240]             inherits <- base::inherits
[16:20:41.240]             invokeRestart <- base::invokeRestart
[16:20:41.240]             length <- base::length
[16:20:41.240]             list <- base::list
[16:20:41.240]             seq.int <- base::seq.int
[16:20:41.240]             signalCondition <- base::signalCondition
[16:20:41.240]             sys.calls <- base::sys.calls
[16:20:41.240]             `[[` <- base::`[[`
[16:20:41.240]             `+` <- base::`+`
[16:20:41.240]             `<<-` <- base::`<<-`
[16:20:41.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.240]                   3L)]
[16:20:41.240]             }
[16:20:41.240]             function(cond) {
[16:20:41.240]                 is_error <- inherits(cond, "error")
[16:20:41.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.240]                   NULL)
[16:20:41.240]                 if (is_error) {
[16:20:41.240]                   sessionInformation <- function() {
[16:20:41.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.240]                       search = base::search(), system = base::Sys.info())
[16:20:41.240]                   }
[16:20:41.240]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.240]                     cond$call), session = sessionInformation(), 
[16:20:41.240]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.240]                   signalCondition(cond)
[16:20:41.240]                 }
[16:20:41.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.240]                 "immediateCondition"))) {
[16:20:41.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.240]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.240]                   if (TRUE && !signal) {
[16:20:41.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.240]                     {
[16:20:41.240]                       inherits <- base::inherits
[16:20:41.240]                       invokeRestart <- base::invokeRestart
[16:20:41.240]                       is.null <- base::is.null
[16:20:41.240]                       muffled <- FALSE
[16:20:41.240]                       if (inherits(cond, "message")) {
[16:20:41.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.240]                         if (muffled) 
[16:20:41.240]                           invokeRestart("muffleMessage")
[16:20:41.240]                       }
[16:20:41.240]                       else if (inherits(cond, "warning")) {
[16:20:41.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.240]                         if (muffled) 
[16:20:41.240]                           invokeRestart("muffleWarning")
[16:20:41.240]                       }
[16:20:41.240]                       else if (inherits(cond, "condition")) {
[16:20:41.240]                         if (!is.null(pattern)) {
[16:20:41.240]                           computeRestarts <- base::computeRestarts
[16:20:41.240]                           grepl <- base::grepl
[16:20:41.240]                           restarts <- computeRestarts(cond)
[16:20:41.240]                           for (restart in restarts) {
[16:20:41.240]                             name <- restart$name
[16:20:41.240]                             if (is.null(name)) 
[16:20:41.240]                               next
[16:20:41.240]                             if (!grepl(pattern, name)) 
[16:20:41.240]                               next
[16:20:41.240]                             invokeRestart(restart)
[16:20:41.240]                             muffled <- TRUE
[16:20:41.240]                             break
[16:20:41.240]                           }
[16:20:41.240]                         }
[16:20:41.240]                       }
[16:20:41.240]                       invisible(muffled)
[16:20:41.240]                     }
[16:20:41.240]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.240]                   }
[16:20:41.240]                 }
[16:20:41.240]                 else {
[16:20:41.240]                   if (TRUE) {
[16:20:41.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.240]                     {
[16:20:41.240]                       inherits <- base::inherits
[16:20:41.240]                       invokeRestart <- base::invokeRestart
[16:20:41.240]                       is.null <- base::is.null
[16:20:41.240]                       muffled <- FALSE
[16:20:41.240]                       if (inherits(cond, "message")) {
[16:20:41.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.240]                         if (muffled) 
[16:20:41.240]                           invokeRestart("muffleMessage")
[16:20:41.240]                       }
[16:20:41.240]                       else if (inherits(cond, "warning")) {
[16:20:41.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.240]                         if (muffled) 
[16:20:41.240]                           invokeRestart("muffleWarning")
[16:20:41.240]                       }
[16:20:41.240]                       else if (inherits(cond, "condition")) {
[16:20:41.240]                         if (!is.null(pattern)) {
[16:20:41.240]                           computeRestarts <- base::computeRestarts
[16:20:41.240]                           grepl <- base::grepl
[16:20:41.240]                           restarts <- computeRestarts(cond)
[16:20:41.240]                           for (restart in restarts) {
[16:20:41.240]                             name <- restart$name
[16:20:41.240]                             if (is.null(name)) 
[16:20:41.240]                               next
[16:20:41.240]                             if (!grepl(pattern, name)) 
[16:20:41.240]                               next
[16:20:41.240]                             invokeRestart(restart)
[16:20:41.240]                             muffled <- TRUE
[16:20:41.240]                             break
[16:20:41.240]                           }
[16:20:41.240]                         }
[16:20:41.240]                       }
[16:20:41.240]                       invisible(muffled)
[16:20:41.240]                     }
[16:20:41.240]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.240]                   }
[16:20:41.240]                 }
[16:20:41.240]             }
[16:20:41.240]         }))
[16:20:41.240]     }, error = function(ex) {
[16:20:41.240]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.240]                 ...future.rng), started = ...future.startTime, 
[16:20:41.240]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.240]             version = "1.8"), class = "FutureResult")
[16:20:41.240]     }, finally = {
[16:20:41.240]         if (!identical(...future.workdir, getwd())) 
[16:20:41.240]             setwd(...future.workdir)
[16:20:41.240]         {
[16:20:41.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.240]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.240]             }
[16:20:41.240]             base::options(...future.oldOptions)
[16:20:41.240]             if (.Platform$OS.type == "windows") {
[16:20:41.240]                 old_names <- names(...future.oldEnvVars)
[16:20:41.240]                 envs <- base::Sys.getenv()
[16:20:41.240]                 names <- names(envs)
[16:20:41.240]                 common <- intersect(names, old_names)
[16:20:41.240]                 added <- setdiff(names, old_names)
[16:20:41.240]                 removed <- setdiff(old_names, names)
[16:20:41.240]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.240]                   envs[common]]
[16:20:41.240]                 NAMES <- toupper(changed)
[16:20:41.240]                 args <- list()
[16:20:41.240]                 for (kk in seq_along(NAMES)) {
[16:20:41.240]                   name <- changed[[kk]]
[16:20:41.240]                   NAME <- NAMES[[kk]]
[16:20:41.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.240]                     next
[16:20:41.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.240]                 }
[16:20:41.240]                 NAMES <- toupper(added)
[16:20:41.240]                 for (kk in seq_along(NAMES)) {
[16:20:41.240]                   name <- added[[kk]]
[16:20:41.240]                   NAME <- NAMES[[kk]]
[16:20:41.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.240]                     next
[16:20:41.240]                   args[[name]] <- ""
[16:20:41.240]                 }
[16:20:41.240]                 NAMES <- toupper(removed)
[16:20:41.240]                 for (kk in seq_along(NAMES)) {
[16:20:41.240]                   name <- removed[[kk]]
[16:20:41.240]                   NAME <- NAMES[[kk]]
[16:20:41.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.240]                     next
[16:20:41.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.240]                 }
[16:20:41.240]                 if (length(args) > 0) 
[16:20:41.240]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.240]             }
[16:20:41.240]             else {
[16:20:41.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.240]             }
[16:20:41.240]             {
[16:20:41.240]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.240]                   0L) {
[16:20:41.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.240]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.240]                   base::options(opts)
[16:20:41.240]                 }
[16:20:41.240]                 {
[16:20:41.240]                   {
[16:20:41.240]                     NULL
[16:20:41.240]                     RNGkind("Mersenne-Twister")
[16:20:41.240]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.240]                       inherits = FALSE)
[16:20:41.240]                   }
[16:20:41.240]                   options(future.plan = NULL)
[16:20:41.240]                   if (is.na(NA_character_)) 
[16:20:41.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.240]                     .init = FALSE)
[16:20:41.240]                 }
[16:20:41.240]             }
[16:20:41.240]         }
[16:20:41.240]     })
[16:20:41.240]     if (TRUE) {
[16:20:41.240]         base::sink(type = "output", split = FALSE)
[16:20:41.240]         if (TRUE) {
[16:20:41.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.240]         }
[16:20:41.240]         else {
[16:20:41.240]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.240]         }
[16:20:41.240]         base::close(...future.stdout)
[16:20:41.240]         ...future.stdout <- NULL
[16:20:41.240]     }
[16:20:41.240]     ...future.result$conditions <- ...future.conditions
[16:20:41.240]     ...future.result$finished <- base::Sys.time()
[16:20:41.240]     ...future.result
[16:20:41.240] }
[16:20:41.241] plan(): Setting new future strategy stack:
[16:20:41.241] List of future strategies:
[16:20:41.241] 1. sequential:
[16:20:41.241]    - args: function (..., envir = parent.frame())
[16:20:41.241]    - tweaked: FALSE
[16:20:41.241]    - call: NULL
[16:20:41.242] plan(): nbrOfWorkers() = 1
[16:20:41.244] plan(): Setting new future strategy stack:
[16:20:41.244] List of future strategies:
[16:20:41.244] 1. sequential:
[16:20:41.244]    - args: function (..., envir = parent.frame())
[16:20:41.244]    - tweaked: FALSE
[16:20:41.244]    - call: plan(strategy)
[16:20:41.244] plan(): nbrOfWorkers() = 1
[16:20:41.244] SequentialFuture started (and completed)
[16:20:41.245] - Launch lazy future ... done
[16:20:41.245] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0c067c88> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0c4c2230> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0c067c88> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55ed0c4c2230> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:41.250] resolved() for ‘SequentialFuture’ ...
[16:20:41.250] - state: ‘finished’
[16:20:41.250] - run: TRUE
[16:20:41.250] - result: ‘FutureResult’
[16:20:41.250] resolved() for ‘SequentialFuture’ ... done
[16:20:41.250] resolved() for ‘SequentialFuture’ ...
[16:20:41.250] - state: ‘finished’
[16:20:41.250] - run: TRUE
[16:20:41.251] - result: ‘FutureResult’
[16:20:41.251] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:41.253] resolve() on list ...
[16:20:41.253]  recursive: 0
[16:20:41.253]  length: 6
[16:20:41.253]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:41.253] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.253] - nx: 6
[16:20:41.253] - relay: TRUE
[16:20:41.253] - stdout: TRUE
[16:20:41.253] - signal: TRUE
[16:20:41.253] - resignal: FALSE
[16:20:41.253] - force: TRUE
[16:20:41.254] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.254] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.254]  - until=2
[16:20:41.254]  - relaying element #2
[16:20:41.254] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.254] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.254] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.254]  length: 5 (resolved future 1)
[16:20:41.254] resolved() for ‘SequentialFuture’ ...
[16:20:41.254] - state: ‘finished’
[16:20:41.254] - run: TRUE
[16:20:41.255] - result: ‘FutureResult’
[16:20:41.255] resolved() for ‘SequentialFuture’ ... done
[16:20:41.255] Future #2
[16:20:41.255] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.255] - nx: 6
[16:20:41.255] - relay: TRUE
[16:20:41.255] - stdout: TRUE
[16:20:41.255] - signal: TRUE
[16:20:41.255] - resignal: FALSE
[16:20:41.255] - force: TRUE
[16:20:41.255] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.256] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.256]  - until=2
[16:20:41.256]  - relaying element #2
[16:20:41.256] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.256] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.256] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.256]  length: 4 (resolved future 2)
[16:20:41.256] resolved() for ‘SequentialFuture’ ...
[16:20:41.256] - state: ‘finished’
[16:20:41.257] - run: TRUE
[16:20:41.257] - result: ‘FutureResult’
[16:20:41.257] resolved() for ‘SequentialFuture’ ... done
[16:20:41.257] Future #3
[16:20:41.257] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.257] - nx: 6
[16:20:41.257] - relay: TRUE
[16:20:41.257] - stdout: TRUE
[16:20:41.257] - signal: TRUE
[16:20:41.257] - resignal: FALSE
[16:20:41.257] - force: TRUE
[16:20:41.257] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.258] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.258]  - until=3
[16:20:41.258]  - relaying element #3
[16:20:41.258] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.258] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.258] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.258]  length: 3 (resolved future 3)
[16:20:41.258] signalConditionsASAP(NULL, pos=4) ...
[16:20:41.258] - nx: 6
[16:20:41.258] - relay: TRUE
[16:20:41.259] - stdout: TRUE
[16:20:41.259] - signal: TRUE
[16:20:41.259] - resignal: FALSE
[16:20:41.259] - force: TRUE
[16:20:41.259] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.259] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.259]  - until=5
[16:20:41.259]  - relaying element #5
[16:20:41.259] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.259] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.259] signalConditionsASAP(NULL, pos=4) ... done
[16:20:41.259]  length: 2 (resolved future 4)
[16:20:41.260] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.260] - nx: 6
[16:20:41.260] - relay: TRUE
[16:20:41.260] - stdout: TRUE
[16:20:41.260] - signal: TRUE
[16:20:41.260] - resignal: FALSE
[16:20:41.260] - force: TRUE
[16:20:41.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.260] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.260]  - until=6
[16:20:41.260]  - relaying element #6
[16:20:41.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.260] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.261] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.261]  length: 1 (resolved future 5)
[16:20:41.261] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.261] - nx: 6
[16:20:41.261] - relay: TRUE
[16:20:41.261] - stdout: TRUE
[16:20:41.261] - signal: TRUE
[16:20:41.261] - resignal: FALSE
[16:20:41.261] - force: TRUE
[16:20:41.261] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.261] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.261]  - until=6
[16:20:41.262] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.262] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.262] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.262]  length: 0 (resolved future 6)
[16:20:41.262] Relaying remaining futures
[16:20:41.262] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.262] - nx: 6
[16:20:41.262] - relay: TRUE
[16:20:41.262] - stdout: TRUE
[16:20:41.262] - signal: TRUE
[16:20:41.262] - resignal: FALSE
[16:20:41.262] - force: TRUE
[16:20:41.263] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.263] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:41.263] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.263] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.263] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.263] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[16:20:41.272] plan(): Setting new future strategy stack:
[16:20:41.272] List of future strategies:
[16:20:41.272] 1. sequential:
[16:20:41.272]    - args: function (..., envir = parent.frame())
[16:20:41.272]    - tweaked: FALSE
[16:20:41.272]    - call: plan(strategy)
[16:20:41.273] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[16:20:41.273] getGlobalsAndPackages() ...
[16:20:41.273] Searching for globals...
[16:20:41.273] 
[16:20:41.273] Searching for globals ... DONE
[16:20:41.273] - globals: [0] <none>
[16:20:41.274] getGlobalsAndPackages() ... DONE
[16:20:41.274] run() for ‘Future’ ...
[16:20:41.274] - state: ‘created’
[16:20:41.274] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.274] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.274]   - Field: ‘label’
[16:20:41.274]   - Field: ‘local’
[16:20:41.275]   - Field: ‘owner’
[16:20:41.275]   - Field: ‘envir’
[16:20:41.275]   - Field: ‘packages’
[16:20:41.275]   - Field: ‘gc’
[16:20:41.275]   - Field: ‘conditions’
[16:20:41.275]   - Field: ‘expr’
[16:20:41.275]   - Field: ‘uuid’
[16:20:41.275]   - Field: ‘seed’
[16:20:41.275]   - Field: ‘version’
[16:20:41.275]   - Field: ‘result’
[16:20:41.275]   - Field: ‘asynchronous’
[16:20:41.276]   - Field: ‘calls’
[16:20:41.276]   - Field: ‘globals’
[16:20:41.276]   - Field: ‘stdout’
[16:20:41.276]   - Field: ‘earlySignal’
[16:20:41.276]   - Field: ‘lazy’
[16:20:41.276]   - Field: ‘state’
[16:20:41.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.276] - Launch lazy future ...
[16:20:41.276] Packages needed by the future expression (n = 0): <none>
[16:20:41.276] Packages needed by future strategies (n = 0): <none>
[16:20:41.277] {
[16:20:41.277]     {
[16:20:41.277]         {
[16:20:41.277]             ...future.startTime <- base::Sys.time()
[16:20:41.277]             {
[16:20:41.277]                 {
[16:20:41.277]                   {
[16:20:41.277]                     base::local({
[16:20:41.277]                       has_future <- base::requireNamespace("future", 
[16:20:41.277]                         quietly = TRUE)
[16:20:41.277]                       if (has_future) {
[16:20:41.277]                         ns <- base::getNamespace("future")
[16:20:41.277]                         version <- ns[[".package"]][["version"]]
[16:20:41.277]                         if (is.null(version)) 
[16:20:41.277]                           version <- utils::packageVersion("future")
[16:20:41.277]                       }
[16:20:41.277]                       else {
[16:20:41.277]                         version <- NULL
[16:20:41.277]                       }
[16:20:41.277]                       if (!has_future || version < "1.8.0") {
[16:20:41.277]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.277]                           "", base::R.version$version.string), 
[16:20:41.277]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.277]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.277]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.277]                             "release", "version")], collapse = " "), 
[16:20:41.277]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.277]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.277]                           info)
[16:20:41.277]                         info <- base::paste(info, collapse = "; ")
[16:20:41.277]                         if (!has_future) {
[16:20:41.277]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.277]                             info)
[16:20:41.277]                         }
[16:20:41.277]                         else {
[16:20:41.277]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.277]                             info, version)
[16:20:41.277]                         }
[16:20:41.277]                         base::stop(msg)
[16:20:41.277]                       }
[16:20:41.277]                     })
[16:20:41.277]                   }
[16:20:41.277]                   ...future.strategy.old <- future::plan("list")
[16:20:41.277]                   options(future.plan = NULL)
[16:20:41.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.277]                 }
[16:20:41.277]                 ...future.workdir <- getwd()
[16:20:41.277]             }
[16:20:41.277]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.277]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.277]         }
[16:20:41.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.277]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.277]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.277]             base::names(...future.oldOptions))
[16:20:41.277]     }
[16:20:41.277]     if (FALSE) {
[16:20:41.277]     }
[16:20:41.277]     else {
[16:20:41.277]         if (TRUE) {
[16:20:41.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.277]                 open = "w")
[16:20:41.277]         }
[16:20:41.277]         else {
[16:20:41.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.277]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.277]         }
[16:20:41.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.277]             base::sink(type = "output", split = FALSE)
[16:20:41.277]             base::close(...future.stdout)
[16:20:41.277]         }, add = TRUE)
[16:20:41.277]     }
[16:20:41.277]     ...future.frame <- base::sys.nframe()
[16:20:41.277]     ...future.conditions <- base::list()
[16:20:41.277]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.277]     if (FALSE) {
[16:20:41.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.277]     }
[16:20:41.277]     ...future.result <- base::tryCatch({
[16:20:41.277]         base::withCallingHandlers({
[16:20:41.277]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.277]             future::FutureResult(value = ...future.value$value, 
[16:20:41.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.277]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.277]                     ...future.globalenv.names))
[16:20:41.277]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.277]         }, condition = base::local({
[16:20:41.277]             c <- base::c
[16:20:41.277]             inherits <- base::inherits
[16:20:41.277]             invokeRestart <- base::invokeRestart
[16:20:41.277]             length <- base::length
[16:20:41.277]             list <- base::list
[16:20:41.277]             seq.int <- base::seq.int
[16:20:41.277]             signalCondition <- base::signalCondition
[16:20:41.277]             sys.calls <- base::sys.calls
[16:20:41.277]             `[[` <- base::`[[`
[16:20:41.277]             `+` <- base::`+`
[16:20:41.277]             `<<-` <- base::`<<-`
[16:20:41.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.277]                   3L)]
[16:20:41.277]             }
[16:20:41.277]             function(cond) {
[16:20:41.277]                 is_error <- inherits(cond, "error")
[16:20:41.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.277]                   NULL)
[16:20:41.277]                 if (is_error) {
[16:20:41.277]                   sessionInformation <- function() {
[16:20:41.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.277]                       search = base::search(), system = base::Sys.info())
[16:20:41.277]                   }
[16:20:41.277]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.277]                     cond$call), session = sessionInformation(), 
[16:20:41.277]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.277]                   signalCondition(cond)
[16:20:41.277]                 }
[16:20:41.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.277]                 "immediateCondition"))) {
[16:20:41.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.277]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.277]                   if (TRUE && !signal) {
[16:20:41.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.277]                     {
[16:20:41.277]                       inherits <- base::inherits
[16:20:41.277]                       invokeRestart <- base::invokeRestart
[16:20:41.277]                       is.null <- base::is.null
[16:20:41.277]                       muffled <- FALSE
[16:20:41.277]                       if (inherits(cond, "message")) {
[16:20:41.277]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.277]                         if (muffled) 
[16:20:41.277]                           invokeRestart("muffleMessage")
[16:20:41.277]                       }
[16:20:41.277]                       else if (inherits(cond, "warning")) {
[16:20:41.277]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.277]                         if (muffled) 
[16:20:41.277]                           invokeRestart("muffleWarning")
[16:20:41.277]                       }
[16:20:41.277]                       else if (inherits(cond, "condition")) {
[16:20:41.277]                         if (!is.null(pattern)) {
[16:20:41.277]                           computeRestarts <- base::computeRestarts
[16:20:41.277]                           grepl <- base::grepl
[16:20:41.277]                           restarts <- computeRestarts(cond)
[16:20:41.277]                           for (restart in restarts) {
[16:20:41.277]                             name <- restart$name
[16:20:41.277]                             if (is.null(name)) 
[16:20:41.277]                               next
[16:20:41.277]                             if (!grepl(pattern, name)) 
[16:20:41.277]                               next
[16:20:41.277]                             invokeRestart(restart)
[16:20:41.277]                             muffled <- TRUE
[16:20:41.277]                             break
[16:20:41.277]                           }
[16:20:41.277]                         }
[16:20:41.277]                       }
[16:20:41.277]                       invisible(muffled)
[16:20:41.277]                     }
[16:20:41.277]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.277]                   }
[16:20:41.277]                 }
[16:20:41.277]                 else {
[16:20:41.277]                   if (TRUE) {
[16:20:41.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.277]                     {
[16:20:41.277]                       inherits <- base::inherits
[16:20:41.277]                       invokeRestart <- base::invokeRestart
[16:20:41.277]                       is.null <- base::is.null
[16:20:41.277]                       muffled <- FALSE
[16:20:41.277]                       if (inherits(cond, "message")) {
[16:20:41.277]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.277]                         if (muffled) 
[16:20:41.277]                           invokeRestart("muffleMessage")
[16:20:41.277]                       }
[16:20:41.277]                       else if (inherits(cond, "warning")) {
[16:20:41.277]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.277]                         if (muffled) 
[16:20:41.277]                           invokeRestart("muffleWarning")
[16:20:41.277]                       }
[16:20:41.277]                       else if (inherits(cond, "condition")) {
[16:20:41.277]                         if (!is.null(pattern)) {
[16:20:41.277]                           computeRestarts <- base::computeRestarts
[16:20:41.277]                           grepl <- base::grepl
[16:20:41.277]                           restarts <- computeRestarts(cond)
[16:20:41.277]                           for (restart in restarts) {
[16:20:41.277]                             name <- restart$name
[16:20:41.277]                             if (is.null(name)) 
[16:20:41.277]                               next
[16:20:41.277]                             if (!grepl(pattern, name)) 
[16:20:41.277]                               next
[16:20:41.277]                             invokeRestart(restart)
[16:20:41.277]                             muffled <- TRUE
[16:20:41.277]                             break
[16:20:41.277]                           }
[16:20:41.277]                         }
[16:20:41.277]                       }
[16:20:41.277]                       invisible(muffled)
[16:20:41.277]                     }
[16:20:41.277]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.277]                   }
[16:20:41.277]                 }
[16:20:41.277]             }
[16:20:41.277]         }))
[16:20:41.277]     }, error = function(ex) {
[16:20:41.277]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.277]                 ...future.rng), started = ...future.startTime, 
[16:20:41.277]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.277]             version = "1.8"), class = "FutureResult")
[16:20:41.277]     }, finally = {
[16:20:41.277]         if (!identical(...future.workdir, getwd())) 
[16:20:41.277]             setwd(...future.workdir)
[16:20:41.277]         {
[16:20:41.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.277]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.277]             }
[16:20:41.277]             base::options(...future.oldOptions)
[16:20:41.277]             if (.Platform$OS.type == "windows") {
[16:20:41.277]                 old_names <- names(...future.oldEnvVars)
[16:20:41.277]                 envs <- base::Sys.getenv()
[16:20:41.277]                 names <- names(envs)
[16:20:41.277]                 common <- intersect(names, old_names)
[16:20:41.277]                 added <- setdiff(names, old_names)
[16:20:41.277]                 removed <- setdiff(old_names, names)
[16:20:41.277]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.277]                   envs[common]]
[16:20:41.277]                 NAMES <- toupper(changed)
[16:20:41.277]                 args <- list()
[16:20:41.277]                 for (kk in seq_along(NAMES)) {
[16:20:41.277]                   name <- changed[[kk]]
[16:20:41.277]                   NAME <- NAMES[[kk]]
[16:20:41.277]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.277]                     next
[16:20:41.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.277]                 }
[16:20:41.277]                 NAMES <- toupper(added)
[16:20:41.277]                 for (kk in seq_along(NAMES)) {
[16:20:41.277]                   name <- added[[kk]]
[16:20:41.277]                   NAME <- NAMES[[kk]]
[16:20:41.277]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.277]                     next
[16:20:41.277]                   args[[name]] <- ""
[16:20:41.277]                 }
[16:20:41.277]                 NAMES <- toupper(removed)
[16:20:41.277]                 for (kk in seq_along(NAMES)) {
[16:20:41.277]                   name <- removed[[kk]]
[16:20:41.277]                   NAME <- NAMES[[kk]]
[16:20:41.277]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.277]                     next
[16:20:41.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.277]                 }
[16:20:41.277]                 if (length(args) > 0) 
[16:20:41.277]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.277]             }
[16:20:41.277]             else {
[16:20:41.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.277]             }
[16:20:41.277]             {
[16:20:41.277]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.277]                   0L) {
[16:20:41.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.277]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.277]                   base::options(opts)
[16:20:41.277]                 }
[16:20:41.277]                 {
[16:20:41.277]                   {
[16:20:41.277]                     NULL
[16:20:41.277]                     RNGkind("Mersenne-Twister")
[16:20:41.277]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.277]                       inherits = FALSE)
[16:20:41.277]                   }
[16:20:41.277]                   options(future.plan = NULL)
[16:20:41.277]                   if (is.na(NA_character_)) 
[16:20:41.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.277]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.277]                     .init = FALSE)
[16:20:41.277]                 }
[16:20:41.277]             }
[16:20:41.277]         }
[16:20:41.277]     })
[16:20:41.277]     if (TRUE) {
[16:20:41.277]         base::sink(type = "output", split = FALSE)
[16:20:41.277]         if (TRUE) {
[16:20:41.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.277]         }
[16:20:41.277]         else {
[16:20:41.277]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.277]         }
[16:20:41.277]         base::close(...future.stdout)
[16:20:41.277]         ...future.stdout <- NULL
[16:20:41.277]     }
[16:20:41.277]     ...future.result$conditions <- ...future.conditions
[16:20:41.277]     ...future.result$finished <- base::Sys.time()
[16:20:41.277]     ...future.result
[16:20:41.277] }
[16:20:41.279] plan(): Setting new future strategy stack:
[16:20:41.279] List of future strategies:
[16:20:41.279] 1. sequential:
[16:20:41.279]    - args: function (..., envir = parent.frame())
[16:20:41.279]    - tweaked: FALSE
[16:20:41.279]    - call: NULL
[16:20:41.279] plan(): nbrOfWorkers() = 1
[16:20:41.280] plan(): Setting new future strategy stack:
[16:20:41.280] List of future strategies:
[16:20:41.280] 1. sequential:
[16:20:41.280]    - args: function (..., envir = parent.frame())
[16:20:41.280]    - tweaked: FALSE
[16:20:41.280]    - call: plan(strategy)
[16:20:41.280] plan(): nbrOfWorkers() = 1
[16:20:41.280] SequentialFuture started (and completed)
[16:20:41.280] - Launch lazy future ... done
[16:20:41.280] run() for ‘SequentialFuture’ ... done
[16:20:41.281] getGlobalsAndPackages() ...
[16:20:41.281] Searching for globals...
[16:20:41.281] 
[16:20:41.281] Searching for globals ... DONE
[16:20:41.281] - globals: [0] <none>
[16:20:41.281] getGlobalsAndPackages() ... DONE
[16:20:41.281] run() for ‘Future’ ...
[16:20:41.281] - state: ‘created’
[16:20:41.282] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.282] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.282] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.282]   - Field: ‘label’
[16:20:41.282]   - Field: ‘local’
[16:20:41.282]   - Field: ‘owner’
[16:20:41.282]   - Field: ‘envir’
[16:20:41.282]   - Field: ‘packages’
[16:20:41.282]   - Field: ‘gc’
[16:20:41.283]   - Field: ‘conditions’
[16:20:41.283]   - Field: ‘expr’
[16:20:41.283]   - Field: ‘uuid’
[16:20:41.283]   - Field: ‘seed’
[16:20:41.283]   - Field: ‘version’
[16:20:41.283]   - Field: ‘result’
[16:20:41.283]   - Field: ‘asynchronous’
[16:20:41.283]   - Field: ‘calls’
[16:20:41.283]   - Field: ‘globals’
[16:20:41.283]   - Field: ‘stdout’
[16:20:41.283]   - Field: ‘earlySignal’
[16:20:41.283]   - Field: ‘lazy’
[16:20:41.284]   - Field: ‘state’
[16:20:41.284] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.284] - Launch lazy future ...
[16:20:41.284] Packages needed by the future expression (n = 0): <none>
[16:20:41.284] Packages needed by future strategies (n = 0): <none>
[16:20:41.284] {
[16:20:41.284]     {
[16:20:41.284]         {
[16:20:41.284]             ...future.startTime <- base::Sys.time()
[16:20:41.284]             {
[16:20:41.284]                 {
[16:20:41.284]                   {
[16:20:41.284]                     base::local({
[16:20:41.284]                       has_future <- base::requireNamespace("future", 
[16:20:41.284]                         quietly = TRUE)
[16:20:41.284]                       if (has_future) {
[16:20:41.284]                         ns <- base::getNamespace("future")
[16:20:41.284]                         version <- ns[[".package"]][["version"]]
[16:20:41.284]                         if (is.null(version)) 
[16:20:41.284]                           version <- utils::packageVersion("future")
[16:20:41.284]                       }
[16:20:41.284]                       else {
[16:20:41.284]                         version <- NULL
[16:20:41.284]                       }
[16:20:41.284]                       if (!has_future || version < "1.8.0") {
[16:20:41.284]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.284]                           "", base::R.version$version.string), 
[16:20:41.284]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.284]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.284]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.284]                             "release", "version")], collapse = " "), 
[16:20:41.284]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.284]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.284]                           info)
[16:20:41.284]                         info <- base::paste(info, collapse = "; ")
[16:20:41.284]                         if (!has_future) {
[16:20:41.284]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.284]                             info)
[16:20:41.284]                         }
[16:20:41.284]                         else {
[16:20:41.284]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.284]                             info, version)
[16:20:41.284]                         }
[16:20:41.284]                         base::stop(msg)
[16:20:41.284]                       }
[16:20:41.284]                     })
[16:20:41.284]                   }
[16:20:41.284]                   ...future.strategy.old <- future::plan("list")
[16:20:41.284]                   options(future.plan = NULL)
[16:20:41.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.284]                 }
[16:20:41.284]                 ...future.workdir <- getwd()
[16:20:41.284]             }
[16:20:41.284]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.284]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.284]         }
[16:20:41.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.284]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.284]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.284]             base::names(...future.oldOptions))
[16:20:41.284]     }
[16:20:41.284]     if (FALSE) {
[16:20:41.284]     }
[16:20:41.284]     else {
[16:20:41.284]         if (TRUE) {
[16:20:41.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.284]                 open = "w")
[16:20:41.284]         }
[16:20:41.284]         else {
[16:20:41.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.284]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.284]         }
[16:20:41.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.284]             base::sink(type = "output", split = FALSE)
[16:20:41.284]             base::close(...future.stdout)
[16:20:41.284]         }, add = TRUE)
[16:20:41.284]     }
[16:20:41.284]     ...future.frame <- base::sys.nframe()
[16:20:41.284]     ...future.conditions <- base::list()
[16:20:41.284]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.284]     if (FALSE) {
[16:20:41.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.284]     }
[16:20:41.284]     ...future.result <- base::tryCatch({
[16:20:41.284]         base::withCallingHandlers({
[16:20:41.284]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.284]             future::FutureResult(value = ...future.value$value, 
[16:20:41.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.284]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.284]                     ...future.globalenv.names))
[16:20:41.284]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.284]         }, condition = base::local({
[16:20:41.284]             c <- base::c
[16:20:41.284]             inherits <- base::inherits
[16:20:41.284]             invokeRestart <- base::invokeRestart
[16:20:41.284]             length <- base::length
[16:20:41.284]             list <- base::list
[16:20:41.284]             seq.int <- base::seq.int
[16:20:41.284]             signalCondition <- base::signalCondition
[16:20:41.284]             sys.calls <- base::sys.calls
[16:20:41.284]             `[[` <- base::`[[`
[16:20:41.284]             `+` <- base::`+`
[16:20:41.284]             `<<-` <- base::`<<-`
[16:20:41.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.284]                   3L)]
[16:20:41.284]             }
[16:20:41.284]             function(cond) {
[16:20:41.284]                 is_error <- inherits(cond, "error")
[16:20:41.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.284]                   NULL)
[16:20:41.284]                 if (is_error) {
[16:20:41.284]                   sessionInformation <- function() {
[16:20:41.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.284]                       search = base::search(), system = base::Sys.info())
[16:20:41.284]                   }
[16:20:41.284]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.284]                     cond$call), session = sessionInformation(), 
[16:20:41.284]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.284]                   signalCondition(cond)
[16:20:41.284]                 }
[16:20:41.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.284]                 "immediateCondition"))) {
[16:20:41.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.284]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.284]                   if (TRUE && !signal) {
[16:20:41.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.284]                     {
[16:20:41.284]                       inherits <- base::inherits
[16:20:41.284]                       invokeRestart <- base::invokeRestart
[16:20:41.284]                       is.null <- base::is.null
[16:20:41.284]                       muffled <- FALSE
[16:20:41.284]                       if (inherits(cond, "message")) {
[16:20:41.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.284]                         if (muffled) 
[16:20:41.284]                           invokeRestart("muffleMessage")
[16:20:41.284]                       }
[16:20:41.284]                       else if (inherits(cond, "warning")) {
[16:20:41.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.284]                         if (muffled) 
[16:20:41.284]                           invokeRestart("muffleWarning")
[16:20:41.284]                       }
[16:20:41.284]                       else if (inherits(cond, "condition")) {
[16:20:41.284]                         if (!is.null(pattern)) {
[16:20:41.284]                           computeRestarts <- base::computeRestarts
[16:20:41.284]                           grepl <- base::grepl
[16:20:41.284]                           restarts <- computeRestarts(cond)
[16:20:41.284]                           for (restart in restarts) {
[16:20:41.284]                             name <- restart$name
[16:20:41.284]                             if (is.null(name)) 
[16:20:41.284]                               next
[16:20:41.284]                             if (!grepl(pattern, name)) 
[16:20:41.284]                               next
[16:20:41.284]                             invokeRestart(restart)
[16:20:41.284]                             muffled <- TRUE
[16:20:41.284]                             break
[16:20:41.284]                           }
[16:20:41.284]                         }
[16:20:41.284]                       }
[16:20:41.284]                       invisible(muffled)
[16:20:41.284]                     }
[16:20:41.284]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.284]                   }
[16:20:41.284]                 }
[16:20:41.284]                 else {
[16:20:41.284]                   if (TRUE) {
[16:20:41.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.284]                     {
[16:20:41.284]                       inherits <- base::inherits
[16:20:41.284]                       invokeRestart <- base::invokeRestart
[16:20:41.284]                       is.null <- base::is.null
[16:20:41.284]                       muffled <- FALSE
[16:20:41.284]                       if (inherits(cond, "message")) {
[16:20:41.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.284]                         if (muffled) 
[16:20:41.284]                           invokeRestart("muffleMessage")
[16:20:41.284]                       }
[16:20:41.284]                       else if (inherits(cond, "warning")) {
[16:20:41.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.284]                         if (muffled) 
[16:20:41.284]                           invokeRestart("muffleWarning")
[16:20:41.284]                       }
[16:20:41.284]                       else if (inherits(cond, "condition")) {
[16:20:41.284]                         if (!is.null(pattern)) {
[16:20:41.284]                           computeRestarts <- base::computeRestarts
[16:20:41.284]                           grepl <- base::grepl
[16:20:41.284]                           restarts <- computeRestarts(cond)
[16:20:41.284]                           for (restart in restarts) {
[16:20:41.284]                             name <- restart$name
[16:20:41.284]                             if (is.null(name)) 
[16:20:41.284]                               next
[16:20:41.284]                             if (!grepl(pattern, name)) 
[16:20:41.284]                               next
[16:20:41.284]                             invokeRestart(restart)
[16:20:41.284]                             muffled <- TRUE
[16:20:41.284]                             break
[16:20:41.284]                           }
[16:20:41.284]                         }
[16:20:41.284]                       }
[16:20:41.284]                       invisible(muffled)
[16:20:41.284]                     }
[16:20:41.284]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.284]                   }
[16:20:41.284]                 }
[16:20:41.284]             }
[16:20:41.284]         }))
[16:20:41.284]     }, error = function(ex) {
[16:20:41.284]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.284]                 ...future.rng), started = ...future.startTime, 
[16:20:41.284]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.284]             version = "1.8"), class = "FutureResult")
[16:20:41.284]     }, finally = {
[16:20:41.284]         if (!identical(...future.workdir, getwd())) 
[16:20:41.284]             setwd(...future.workdir)
[16:20:41.284]         {
[16:20:41.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.284]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.284]             }
[16:20:41.284]             base::options(...future.oldOptions)
[16:20:41.284]             if (.Platform$OS.type == "windows") {
[16:20:41.284]                 old_names <- names(...future.oldEnvVars)
[16:20:41.284]                 envs <- base::Sys.getenv()
[16:20:41.284]                 names <- names(envs)
[16:20:41.284]                 common <- intersect(names, old_names)
[16:20:41.284]                 added <- setdiff(names, old_names)
[16:20:41.284]                 removed <- setdiff(old_names, names)
[16:20:41.284]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.284]                   envs[common]]
[16:20:41.284]                 NAMES <- toupper(changed)
[16:20:41.284]                 args <- list()
[16:20:41.284]                 for (kk in seq_along(NAMES)) {
[16:20:41.284]                   name <- changed[[kk]]
[16:20:41.284]                   NAME <- NAMES[[kk]]
[16:20:41.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.284]                     next
[16:20:41.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.284]                 }
[16:20:41.284]                 NAMES <- toupper(added)
[16:20:41.284]                 for (kk in seq_along(NAMES)) {
[16:20:41.284]                   name <- added[[kk]]
[16:20:41.284]                   NAME <- NAMES[[kk]]
[16:20:41.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.284]                     next
[16:20:41.284]                   args[[name]] <- ""
[16:20:41.284]                 }
[16:20:41.284]                 NAMES <- toupper(removed)
[16:20:41.284]                 for (kk in seq_along(NAMES)) {
[16:20:41.284]                   name <- removed[[kk]]
[16:20:41.284]                   NAME <- NAMES[[kk]]
[16:20:41.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.284]                     next
[16:20:41.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.284]                 }
[16:20:41.284]                 if (length(args) > 0) 
[16:20:41.284]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.284]             }
[16:20:41.284]             else {
[16:20:41.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.284]             }
[16:20:41.284]             {
[16:20:41.284]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.284]                   0L) {
[16:20:41.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.284]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.284]                   base::options(opts)
[16:20:41.284]                 }
[16:20:41.284]                 {
[16:20:41.284]                   {
[16:20:41.284]                     NULL
[16:20:41.284]                     RNGkind("Mersenne-Twister")
[16:20:41.284]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.284]                       inherits = FALSE)
[16:20:41.284]                   }
[16:20:41.284]                   options(future.plan = NULL)
[16:20:41.284]                   if (is.na(NA_character_)) 
[16:20:41.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.284]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.284]                     .init = FALSE)
[16:20:41.284]                 }
[16:20:41.284]             }
[16:20:41.284]         }
[16:20:41.284]     })
[16:20:41.284]     if (TRUE) {
[16:20:41.284]         base::sink(type = "output", split = FALSE)
[16:20:41.284]         if (TRUE) {
[16:20:41.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.284]         }
[16:20:41.284]         else {
[16:20:41.284]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.284]         }
[16:20:41.284]         base::close(...future.stdout)
[16:20:41.284]         ...future.stdout <- NULL
[16:20:41.284]     }
[16:20:41.284]     ...future.result$conditions <- ...future.conditions
[16:20:41.284]     ...future.result$finished <- base::Sys.time()
[16:20:41.284]     ...future.result
[16:20:41.284] }
[16:20:41.286] plan(): Setting new future strategy stack:
[16:20:41.286] List of future strategies:
[16:20:41.286] 1. sequential:
[16:20:41.286]    - args: function (..., envir = parent.frame())
[16:20:41.286]    - tweaked: FALSE
[16:20:41.286]    - call: NULL
[16:20:41.287] plan(): nbrOfWorkers() = 1
[16:20:41.287] plan(): Setting new future strategy stack:
[16:20:41.287] List of future strategies:
[16:20:41.287] 1. sequential:
[16:20:41.287]    - args: function (..., envir = parent.frame())
[16:20:41.287]    - tweaked: FALSE
[16:20:41.287]    - call: plan(strategy)
[16:20:41.288] plan(): nbrOfWorkers() = 1
[16:20:41.288] SequentialFuture started (and completed)
[16:20:41.288] - Launch lazy future ... done
[16:20:41.288] run() for ‘SequentialFuture’ ... done
[16:20:41.289] getGlobalsAndPackages() ...
[16:20:41.289] Searching for globals...
[16:20:41.291] - globals found: [1] ‘{’
[16:20:41.291] Searching for globals ... DONE
[16:20:41.291] Resolving globals: FALSE
[16:20:41.291] 
[16:20:41.291] 
[16:20:41.292] getGlobalsAndPackages() ... DONE
[16:20:41.292] run() for ‘Future’ ...
[16:20:41.292] - state: ‘created’
[16:20:41.292] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.292] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.292]   - Field: ‘label’
[16:20:41.293]   - Field: ‘local’
[16:20:41.293]   - Field: ‘owner’
[16:20:41.293]   - Field: ‘envir’
[16:20:41.293]   - Field: ‘packages’
[16:20:41.293]   - Field: ‘gc’
[16:20:41.293]   - Field: ‘conditions’
[16:20:41.293]   - Field: ‘expr’
[16:20:41.293]   - Field: ‘uuid’
[16:20:41.293]   - Field: ‘seed’
[16:20:41.293]   - Field: ‘version’
[16:20:41.294]   - Field: ‘result’
[16:20:41.294]   - Field: ‘asynchronous’
[16:20:41.294]   - Field: ‘calls’
[16:20:41.294]   - Field: ‘globals’
[16:20:41.294]   - Field: ‘stdout’
[16:20:41.294]   - Field: ‘earlySignal’
[16:20:41.296]   - Field: ‘lazy’
[16:20:41.296]   - Field: ‘state’
[16:20:41.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.296] - Launch lazy future ...
[16:20:41.296] Packages needed by the future expression (n = 0): <none>
[16:20:41.296] Packages needed by future strategies (n = 0): <none>
[16:20:41.297] {
[16:20:41.297]     {
[16:20:41.297]         {
[16:20:41.297]             ...future.startTime <- base::Sys.time()
[16:20:41.297]             {
[16:20:41.297]                 {
[16:20:41.297]                   {
[16:20:41.297]                     base::local({
[16:20:41.297]                       has_future <- base::requireNamespace("future", 
[16:20:41.297]                         quietly = TRUE)
[16:20:41.297]                       if (has_future) {
[16:20:41.297]                         ns <- base::getNamespace("future")
[16:20:41.297]                         version <- ns[[".package"]][["version"]]
[16:20:41.297]                         if (is.null(version)) 
[16:20:41.297]                           version <- utils::packageVersion("future")
[16:20:41.297]                       }
[16:20:41.297]                       else {
[16:20:41.297]                         version <- NULL
[16:20:41.297]                       }
[16:20:41.297]                       if (!has_future || version < "1.8.0") {
[16:20:41.297]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.297]                           "", base::R.version$version.string), 
[16:20:41.297]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.297]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.297]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.297]                             "release", "version")], collapse = " "), 
[16:20:41.297]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.297]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.297]                           info)
[16:20:41.297]                         info <- base::paste(info, collapse = "; ")
[16:20:41.297]                         if (!has_future) {
[16:20:41.297]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.297]                             info)
[16:20:41.297]                         }
[16:20:41.297]                         else {
[16:20:41.297]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.297]                             info, version)
[16:20:41.297]                         }
[16:20:41.297]                         base::stop(msg)
[16:20:41.297]                       }
[16:20:41.297]                     })
[16:20:41.297]                   }
[16:20:41.297]                   ...future.strategy.old <- future::plan("list")
[16:20:41.297]                   options(future.plan = NULL)
[16:20:41.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.297]                 }
[16:20:41.297]                 ...future.workdir <- getwd()
[16:20:41.297]             }
[16:20:41.297]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.297]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.297]         }
[16:20:41.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.297]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.297]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.297]             base::names(...future.oldOptions))
[16:20:41.297]     }
[16:20:41.297]     if (FALSE) {
[16:20:41.297]     }
[16:20:41.297]     else {
[16:20:41.297]         if (TRUE) {
[16:20:41.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.297]                 open = "w")
[16:20:41.297]         }
[16:20:41.297]         else {
[16:20:41.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.297]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.297]         }
[16:20:41.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.297]             base::sink(type = "output", split = FALSE)
[16:20:41.297]             base::close(...future.stdout)
[16:20:41.297]         }, add = TRUE)
[16:20:41.297]     }
[16:20:41.297]     ...future.frame <- base::sys.nframe()
[16:20:41.297]     ...future.conditions <- base::list()
[16:20:41.297]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.297]     if (FALSE) {
[16:20:41.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.297]     }
[16:20:41.297]     ...future.result <- base::tryCatch({
[16:20:41.297]         base::withCallingHandlers({
[16:20:41.297]             ...future.value <- base::withVisible(base::local({
[16:20:41.297]                 4
[16:20:41.297]             }))
[16:20:41.297]             future::FutureResult(value = ...future.value$value, 
[16:20:41.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.297]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.297]                     ...future.globalenv.names))
[16:20:41.297]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.297]         }, condition = base::local({
[16:20:41.297]             c <- base::c
[16:20:41.297]             inherits <- base::inherits
[16:20:41.297]             invokeRestart <- base::invokeRestart
[16:20:41.297]             length <- base::length
[16:20:41.297]             list <- base::list
[16:20:41.297]             seq.int <- base::seq.int
[16:20:41.297]             signalCondition <- base::signalCondition
[16:20:41.297]             sys.calls <- base::sys.calls
[16:20:41.297]             `[[` <- base::`[[`
[16:20:41.297]             `+` <- base::`+`
[16:20:41.297]             `<<-` <- base::`<<-`
[16:20:41.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.297]                   3L)]
[16:20:41.297]             }
[16:20:41.297]             function(cond) {
[16:20:41.297]                 is_error <- inherits(cond, "error")
[16:20:41.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.297]                   NULL)
[16:20:41.297]                 if (is_error) {
[16:20:41.297]                   sessionInformation <- function() {
[16:20:41.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.297]                       search = base::search(), system = base::Sys.info())
[16:20:41.297]                   }
[16:20:41.297]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.297]                     cond$call), session = sessionInformation(), 
[16:20:41.297]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.297]                   signalCondition(cond)
[16:20:41.297]                 }
[16:20:41.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.297]                 "immediateCondition"))) {
[16:20:41.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.297]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.297]                   if (TRUE && !signal) {
[16:20:41.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.297]                     {
[16:20:41.297]                       inherits <- base::inherits
[16:20:41.297]                       invokeRestart <- base::invokeRestart
[16:20:41.297]                       is.null <- base::is.null
[16:20:41.297]                       muffled <- FALSE
[16:20:41.297]                       if (inherits(cond, "message")) {
[16:20:41.297]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.297]                         if (muffled) 
[16:20:41.297]                           invokeRestart("muffleMessage")
[16:20:41.297]                       }
[16:20:41.297]                       else if (inherits(cond, "warning")) {
[16:20:41.297]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.297]                         if (muffled) 
[16:20:41.297]                           invokeRestart("muffleWarning")
[16:20:41.297]                       }
[16:20:41.297]                       else if (inherits(cond, "condition")) {
[16:20:41.297]                         if (!is.null(pattern)) {
[16:20:41.297]                           computeRestarts <- base::computeRestarts
[16:20:41.297]                           grepl <- base::grepl
[16:20:41.297]                           restarts <- computeRestarts(cond)
[16:20:41.297]                           for (restart in restarts) {
[16:20:41.297]                             name <- restart$name
[16:20:41.297]                             if (is.null(name)) 
[16:20:41.297]                               next
[16:20:41.297]                             if (!grepl(pattern, name)) 
[16:20:41.297]                               next
[16:20:41.297]                             invokeRestart(restart)
[16:20:41.297]                             muffled <- TRUE
[16:20:41.297]                             break
[16:20:41.297]                           }
[16:20:41.297]                         }
[16:20:41.297]                       }
[16:20:41.297]                       invisible(muffled)
[16:20:41.297]                     }
[16:20:41.297]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.297]                   }
[16:20:41.297]                 }
[16:20:41.297]                 else {
[16:20:41.297]                   if (TRUE) {
[16:20:41.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.297]                     {
[16:20:41.297]                       inherits <- base::inherits
[16:20:41.297]                       invokeRestart <- base::invokeRestart
[16:20:41.297]                       is.null <- base::is.null
[16:20:41.297]                       muffled <- FALSE
[16:20:41.297]                       if (inherits(cond, "message")) {
[16:20:41.297]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.297]                         if (muffled) 
[16:20:41.297]                           invokeRestart("muffleMessage")
[16:20:41.297]                       }
[16:20:41.297]                       else if (inherits(cond, "warning")) {
[16:20:41.297]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.297]                         if (muffled) 
[16:20:41.297]                           invokeRestart("muffleWarning")
[16:20:41.297]                       }
[16:20:41.297]                       else if (inherits(cond, "condition")) {
[16:20:41.297]                         if (!is.null(pattern)) {
[16:20:41.297]                           computeRestarts <- base::computeRestarts
[16:20:41.297]                           grepl <- base::grepl
[16:20:41.297]                           restarts <- computeRestarts(cond)
[16:20:41.297]                           for (restart in restarts) {
[16:20:41.297]                             name <- restart$name
[16:20:41.297]                             if (is.null(name)) 
[16:20:41.297]                               next
[16:20:41.297]                             if (!grepl(pattern, name)) 
[16:20:41.297]                               next
[16:20:41.297]                             invokeRestart(restart)
[16:20:41.297]                             muffled <- TRUE
[16:20:41.297]                             break
[16:20:41.297]                           }
[16:20:41.297]                         }
[16:20:41.297]                       }
[16:20:41.297]                       invisible(muffled)
[16:20:41.297]                     }
[16:20:41.297]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.297]                   }
[16:20:41.297]                 }
[16:20:41.297]             }
[16:20:41.297]         }))
[16:20:41.297]     }, error = function(ex) {
[16:20:41.297]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.297]                 ...future.rng), started = ...future.startTime, 
[16:20:41.297]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.297]             version = "1.8"), class = "FutureResult")
[16:20:41.297]     }, finally = {
[16:20:41.297]         if (!identical(...future.workdir, getwd())) 
[16:20:41.297]             setwd(...future.workdir)
[16:20:41.297]         {
[16:20:41.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.297]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.297]             }
[16:20:41.297]             base::options(...future.oldOptions)
[16:20:41.297]             if (.Platform$OS.type == "windows") {
[16:20:41.297]                 old_names <- names(...future.oldEnvVars)
[16:20:41.297]                 envs <- base::Sys.getenv()
[16:20:41.297]                 names <- names(envs)
[16:20:41.297]                 common <- intersect(names, old_names)
[16:20:41.297]                 added <- setdiff(names, old_names)
[16:20:41.297]                 removed <- setdiff(old_names, names)
[16:20:41.297]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.297]                   envs[common]]
[16:20:41.297]                 NAMES <- toupper(changed)
[16:20:41.297]                 args <- list()
[16:20:41.297]                 for (kk in seq_along(NAMES)) {
[16:20:41.297]                   name <- changed[[kk]]
[16:20:41.297]                   NAME <- NAMES[[kk]]
[16:20:41.297]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.297]                     next
[16:20:41.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.297]                 }
[16:20:41.297]                 NAMES <- toupper(added)
[16:20:41.297]                 for (kk in seq_along(NAMES)) {
[16:20:41.297]                   name <- added[[kk]]
[16:20:41.297]                   NAME <- NAMES[[kk]]
[16:20:41.297]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.297]                     next
[16:20:41.297]                   args[[name]] <- ""
[16:20:41.297]                 }
[16:20:41.297]                 NAMES <- toupper(removed)
[16:20:41.297]                 for (kk in seq_along(NAMES)) {
[16:20:41.297]                   name <- removed[[kk]]
[16:20:41.297]                   NAME <- NAMES[[kk]]
[16:20:41.297]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.297]                     next
[16:20:41.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.297]                 }
[16:20:41.297]                 if (length(args) > 0) 
[16:20:41.297]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.297]             }
[16:20:41.297]             else {
[16:20:41.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.297]             }
[16:20:41.297]             {
[16:20:41.297]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.297]                   0L) {
[16:20:41.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.297]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.297]                   base::options(opts)
[16:20:41.297]                 }
[16:20:41.297]                 {
[16:20:41.297]                   {
[16:20:41.297]                     NULL
[16:20:41.297]                     RNGkind("Mersenne-Twister")
[16:20:41.297]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.297]                       inherits = FALSE)
[16:20:41.297]                   }
[16:20:41.297]                   options(future.plan = NULL)
[16:20:41.297]                   if (is.na(NA_character_)) 
[16:20:41.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.297]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.297]                     .init = FALSE)
[16:20:41.297]                 }
[16:20:41.297]             }
[16:20:41.297]         }
[16:20:41.297]     })
[16:20:41.297]     if (TRUE) {
[16:20:41.297]         base::sink(type = "output", split = FALSE)
[16:20:41.297]         if (TRUE) {
[16:20:41.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.297]         }
[16:20:41.297]         else {
[16:20:41.297]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.297]         }
[16:20:41.297]         base::close(...future.stdout)
[16:20:41.297]         ...future.stdout <- NULL
[16:20:41.297]     }
[16:20:41.297]     ...future.result$conditions <- ...future.conditions
[16:20:41.297]     ...future.result$finished <- base::Sys.time()
[16:20:41.297]     ...future.result
[16:20:41.297] }
[16:20:41.298] plan(): Setting new future strategy stack:
[16:20:41.299] List of future strategies:
[16:20:41.299] 1. sequential:
[16:20:41.299]    - args: function (..., envir = parent.frame())
[16:20:41.299]    - tweaked: FALSE
[16:20:41.299]    - call: NULL
[16:20:41.299] plan(): nbrOfWorkers() = 1
[16:20:41.300] plan(): Setting new future strategy stack:
[16:20:41.300] List of future strategies:
[16:20:41.300] 1. sequential:
[16:20:41.300]    - args: function (..., envir = parent.frame())
[16:20:41.300]    - tweaked: FALSE
[16:20:41.300]    - call: plan(strategy)
[16:20:41.300] plan(): nbrOfWorkers() = 1
[16:20:41.300] SequentialFuture started (and completed)
[16:20:41.300] - Launch lazy future ... done
[16:20:41.300] run() for ‘SequentialFuture’ ... done
<environment: 0x55ed0a979880> 
<environment: 0x55ed0a306ac8> 
[16:20:41.302] resolved() for ‘SequentialFuture’ ...
[16:20:41.302] - state: ‘finished’
[16:20:41.302] - run: TRUE
[16:20:41.302] - result: ‘FutureResult’
[16:20:41.302] resolved() for ‘SequentialFuture’ ... done
[16:20:41.302] resolved() for ‘SequentialFuture’ ...
[16:20:41.303] - state: ‘finished’
[16:20:41.303] - run: TRUE
[16:20:41.303] - result: ‘FutureResult’
[16:20:41.303] resolved() for ‘SequentialFuture’ ... done
[16:20:41.303] resolved() for ‘SequentialFuture’ ...
[16:20:41.303] - state: ‘finished’
[16:20:41.303] - run: TRUE
[16:20:41.303] - result: ‘FutureResult’
[16:20:41.303] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:41.305] resolve() on environment ...
[16:20:41.305]  recursive: 0
[16:20:41.305]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:41.305] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.305] - nx: 4
[16:20:41.306] - relay: TRUE
[16:20:41.306] - stdout: TRUE
[16:20:41.306] - signal: TRUE
[16:20:41.306] - resignal: FALSE
[16:20:41.306] - force: TRUE
[16:20:41.306] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.306] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.306]  - until=2
[16:20:41.306]  - relaying element #2
[16:20:41.306] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.306] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.306] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.307]  length: 3 (resolved future 1)
[16:20:41.307] resolved() for ‘SequentialFuture’ ...
[16:20:41.307] - state: ‘finished’
[16:20:41.307] - run: TRUE
[16:20:41.307] - result: ‘FutureResult’
[16:20:41.307] resolved() for ‘SequentialFuture’ ... done
[16:20:41.307] Future #2
[16:20:41.307] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.307] - nx: 4
[16:20:41.307] - relay: TRUE
[16:20:41.308] - stdout: TRUE
[16:20:41.308] - signal: TRUE
[16:20:41.308] - resignal: FALSE
[16:20:41.308] - force: TRUE
[16:20:41.308] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.308] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.308]  - until=2
[16:20:41.308]  - relaying element #2
[16:20:41.308] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.308] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.309] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.309]  length: 2 (resolved future 2)
[16:20:41.309] resolved() for ‘SequentialFuture’ ...
[16:20:41.309] - state: ‘finished’
[16:20:41.309] - run: TRUE
[16:20:41.309] - result: ‘FutureResult’
[16:20:41.309] resolved() for ‘SequentialFuture’ ... done
[16:20:41.309] Future #3
[16:20:41.309] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.309] - nx: 4
[16:20:41.309] - relay: TRUE
[16:20:41.310] - stdout: TRUE
[16:20:41.310] - signal: TRUE
[16:20:41.310] - resignal: FALSE
[16:20:41.310] - force: TRUE
[16:20:41.310] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.310] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.310]  - until=3
[16:20:41.310]  - relaying element #3
[16:20:41.310] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.311] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.311] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.311]  length: 1 (resolved future 3)
[16:20:41.311] resolved() for ‘SequentialFuture’ ...
[16:20:41.311] - state: ‘finished’
[16:20:41.311] - run: TRUE
[16:20:41.311] - result: ‘FutureResult’
[16:20:41.311] resolved() for ‘SequentialFuture’ ... done
[16:20:41.311] Future #4
[16:20:41.311] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.311] - nx: 4
[16:20:41.312] - relay: TRUE
[16:20:41.312] - stdout: TRUE
[16:20:41.312] - signal: TRUE
[16:20:41.312] - resignal: FALSE
[16:20:41.312] - force: TRUE
[16:20:41.312] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.312] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.312]  - until=4
[16:20:41.312]  - relaying element #4
[16:20:41.312] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.312] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.313] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.313]  length: 0 (resolved future 4)
[16:20:41.313] Relaying remaining futures
[16:20:41.313] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.313] - nx: 4
[16:20:41.313] - relay: TRUE
[16:20:41.313] - stdout: TRUE
[16:20:41.313] - signal: TRUE
[16:20:41.313] - resignal: FALSE
[16:20:41.313] - force: TRUE
[16:20:41.313] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.313] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:41.314] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.314] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.314] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.314] resolve() on environment ... DONE
<environment: 0x55ed0abb3e10> 
Dimensions: c(1, 6)
[16:20:41.314] getGlobalsAndPackages() ...
[16:20:41.314] Searching for globals...
[16:20:41.315] 
[16:20:41.315] Searching for globals ... DONE
[16:20:41.315] - globals: [0] <none>
[16:20:41.315] getGlobalsAndPackages() ... DONE
[16:20:41.315] run() for ‘Future’ ...
[16:20:41.315] - state: ‘created’
[16:20:41.315] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.316] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.316]   - Field: ‘label’
[16:20:41.316]   - Field: ‘local’
[16:20:41.316]   - Field: ‘owner’
[16:20:41.316]   - Field: ‘envir’
[16:20:41.316]   - Field: ‘packages’
[16:20:41.316]   - Field: ‘gc’
[16:20:41.316]   - Field: ‘conditions’
[16:20:41.317]   - Field: ‘expr’
[16:20:41.317]   - Field: ‘uuid’
[16:20:41.317]   - Field: ‘seed’
[16:20:41.317]   - Field: ‘version’
[16:20:41.317]   - Field: ‘result’
[16:20:41.317]   - Field: ‘asynchronous’
[16:20:41.317]   - Field: ‘calls’
[16:20:41.317]   - Field: ‘globals’
[16:20:41.317]   - Field: ‘stdout’
[16:20:41.317]   - Field: ‘earlySignal’
[16:20:41.317]   - Field: ‘lazy’
[16:20:41.318]   - Field: ‘state’
[16:20:41.318] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.318] - Launch lazy future ...
[16:20:41.318] Packages needed by the future expression (n = 0): <none>
[16:20:41.318] Packages needed by future strategies (n = 0): <none>
[16:20:41.318] {
[16:20:41.318]     {
[16:20:41.318]         {
[16:20:41.318]             ...future.startTime <- base::Sys.time()
[16:20:41.318]             {
[16:20:41.318]                 {
[16:20:41.318]                   {
[16:20:41.318]                     base::local({
[16:20:41.318]                       has_future <- base::requireNamespace("future", 
[16:20:41.318]                         quietly = TRUE)
[16:20:41.318]                       if (has_future) {
[16:20:41.318]                         ns <- base::getNamespace("future")
[16:20:41.318]                         version <- ns[[".package"]][["version"]]
[16:20:41.318]                         if (is.null(version)) 
[16:20:41.318]                           version <- utils::packageVersion("future")
[16:20:41.318]                       }
[16:20:41.318]                       else {
[16:20:41.318]                         version <- NULL
[16:20:41.318]                       }
[16:20:41.318]                       if (!has_future || version < "1.8.0") {
[16:20:41.318]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.318]                           "", base::R.version$version.string), 
[16:20:41.318]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.318]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.318]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.318]                             "release", "version")], collapse = " "), 
[16:20:41.318]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.318]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.318]                           info)
[16:20:41.318]                         info <- base::paste(info, collapse = "; ")
[16:20:41.318]                         if (!has_future) {
[16:20:41.318]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.318]                             info)
[16:20:41.318]                         }
[16:20:41.318]                         else {
[16:20:41.318]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.318]                             info, version)
[16:20:41.318]                         }
[16:20:41.318]                         base::stop(msg)
[16:20:41.318]                       }
[16:20:41.318]                     })
[16:20:41.318]                   }
[16:20:41.318]                   ...future.strategy.old <- future::plan("list")
[16:20:41.318]                   options(future.plan = NULL)
[16:20:41.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.318]                 }
[16:20:41.318]                 ...future.workdir <- getwd()
[16:20:41.318]             }
[16:20:41.318]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.318]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.318]         }
[16:20:41.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.318]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.318]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.318]             base::names(...future.oldOptions))
[16:20:41.318]     }
[16:20:41.318]     if (FALSE) {
[16:20:41.318]     }
[16:20:41.318]     else {
[16:20:41.318]         if (TRUE) {
[16:20:41.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.318]                 open = "w")
[16:20:41.318]         }
[16:20:41.318]         else {
[16:20:41.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.318]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.318]         }
[16:20:41.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.318]             base::sink(type = "output", split = FALSE)
[16:20:41.318]             base::close(...future.stdout)
[16:20:41.318]         }, add = TRUE)
[16:20:41.318]     }
[16:20:41.318]     ...future.frame <- base::sys.nframe()
[16:20:41.318]     ...future.conditions <- base::list()
[16:20:41.318]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.318]     if (FALSE) {
[16:20:41.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.318]     }
[16:20:41.318]     ...future.result <- base::tryCatch({
[16:20:41.318]         base::withCallingHandlers({
[16:20:41.318]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.318]             future::FutureResult(value = ...future.value$value, 
[16:20:41.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.318]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.318]                     ...future.globalenv.names))
[16:20:41.318]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.318]         }, condition = base::local({
[16:20:41.318]             c <- base::c
[16:20:41.318]             inherits <- base::inherits
[16:20:41.318]             invokeRestart <- base::invokeRestart
[16:20:41.318]             length <- base::length
[16:20:41.318]             list <- base::list
[16:20:41.318]             seq.int <- base::seq.int
[16:20:41.318]             signalCondition <- base::signalCondition
[16:20:41.318]             sys.calls <- base::sys.calls
[16:20:41.318]             `[[` <- base::`[[`
[16:20:41.318]             `+` <- base::`+`
[16:20:41.318]             `<<-` <- base::`<<-`
[16:20:41.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.318]                   3L)]
[16:20:41.318]             }
[16:20:41.318]             function(cond) {
[16:20:41.318]                 is_error <- inherits(cond, "error")
[16:20:41.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.318]                   NULL)
[16:20:41.318]                 if (is_error) {
[16:20:41.318]                   sessionInformation <- function() {
[16:20:41.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.318]                       search = base::search(), system = base::Sys.info())
[16:20:41.318]                   }
[16:20:41.318]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.318]                     cond$call), session = sessionInformation(), 
[16:20:41.318]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.318]                   signalCondition(cond)
[16:20:41.318]                 }
[16:20:41.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.318]                 "immediateCondition"))) {
[16:20:41.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.318]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.318]                   if (TRUE && !signal) {
[16:20:41.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.318]                     {
[16:20:41.318]                       inherits <- base::inherits
[16:20:41.318]                       invokeRestart <- base::invokeRestart
[16:20:41.318]                       is.null <- base::is.null
[16:20:41.318]                       muffled <- FALSE
[16:20:41.318]                       if (inherits(cond, "message")) {
[16:20:41.318]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.318]                         if (muffled) 
[16:20:41.318]                           invokeRestart("muffleMessage")
[16:20:41.318]                       }
[16:20:41.318]                       else if (inherits(cond, "warning")) {
[16:20:41.318]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.318]                         if (muffled) 
[16:20:41.318]                           invokeRestart("muffleWarning")
[16:20:41.318]                       }
[16:20:41.318]                       else if (inherits(cond, "condition")) {
[16:20:41.318]                         if (!is.null(pattern)) {
[16:20:41.318]                           computeRestarts <- base::computeRestarts
[16:20:41.318]                           grepl <- base::grepl
[16:20:41.318]                           restarts <- computeRestarts(cond)
[16:20:41.318]                           for (restart in restarts) {
[16:20:41.318]                             name <- restart$name
[16:20:41.318]                             if (is.null(name)) 
[16:20:41.318]                               next
[16:20:41.318]                             if (!grepl(pattern, name)) 
[16:20:41.318]                               next
[16:20:41.318]                             invokeRestart(restart)
[16:20:41.318]                             muffled <- TRUE
[16:20:41.318]                             break
[16:20:41.318]                           }
[16:20:41.318]                         }
[16:20:41.318]                       }
[16:20:41.318]                       invisible(muffled)
[16:20:41.318]                     }
[16:20:41.318]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.318]                   }
[16:20:41.318]                 }
[16:20:41.318]                 else {
[16:20:41.318]                   if (TRUE) {
[16:20:41.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.318]                     {
[16:20:41.318]                       inherits <- base::inherits
[16:20:41.318]                       invokeRestart <- base::invokeRestart
[16:20:41.318]                       is.null <- base::is.null
[16:20:41.318]                       muffled <- FALSE
[16:20:41.318]                       if (inherits(cond, "message")) {
[16:20:41.318]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.318]                         if (muffled) 
[16:20:41.318]                           invokeRestart("muffleMessage")
[16:20:41.318]                       }
[16:20:41.318]                       else if (inherits(cond, "warning")) {
[16:20:41.318]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.318]                         if (muffled) 
[16:20:41.318]                           invokeRestart("muffleWarning")
[16:20:41.318]                       }
[16:20:41.318]                       else if (inherits(cond, "condition")) {
[16:20:41.318]                         if (!is.null(pattern)) {
[16:20:41.318]                           computeRestarts <- base::computeRestarts
[16:20:41.318]                           grepl <- base::grepl
[16:20:41.318]                           restarts <- computeRestarts(cond)
[16:20:41.318]                           for (restart in restarts) {
[16:20:41.318]                             name <- restart$name
[16:20:41.318]                             if (is.null(name)) 
[16:20:41.318]                               next
[16:20:41.318]                             if (!grepl(pattern, name)) 
[16:20:41.318]                               next
[16:20:41.318]                             invokeRestart(restart)
[16:20:41.318]                             muffled <- TRUE
[16:20:41.318]                             break
[16:20:41.318]                           }
[16:20:41.318]                         }
[16:20:41.318]                       }
[16:20:41.318]                       invisible(muffled)
[16:20:41.318]                     }
[16:20:41.318]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.318]                   }
[16:20:41.318]                 }
[16:20:41.318]             }
[16:20:41.318]         }))
[16:20:41.318]     }, error = function(ex) {
[16:20:41.318]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.318]                 ...future.rng), started = ...future.startTime, 
[16:20:41.318]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.318]             version = "1.8"), class = "FutureResult")
[16:20:41.318]     }, finally = {
[16:20:41.318]         if (!identical(...future.workdir, getwd())) 
[16:20:41.318]             setwd(...future.workdir)
[16:20:41.318]         {
[16:20:41.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.318]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.318]             }
[16:20:41.318]             base::options(...future.oldOptions)
[16:20:41.318]             if (.Platform$OS.type == "windows") {
[16:20:41.318]                 old_names <- names(...future.oldEnvVars)
[16:20:41.318]                 envs <- base::Sys.getenv()
[16:20:41.318]                 names <- names(envs)
[16:20:41.318]                 common <- intersect(names, old_names)
[16:20:41.318]                 added <- setdiff(names, old_names)
[16:20:41.318]                 removed <- setdiff(old_names, names)
[16:20:41.318]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.318]                   envs[common]]
[16:20:41.318]                 NAMES <- toupper(changed)
[16:20:41.318]                 args <- list()
[16:20:41.318]                 for (kk in seq_along(NAMES)) {
[16:20:41.318]                   name <- changed[[kk]]
[16:20:41.318]                   NAME <- NAMES[[kk]]
[16:20:41.318]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.318]                     next
[16:20:41.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.318]                 }
[16:20:41.318]                 NAMES <- toupper(added)
[16:20:41.318]                 for (kk in seq_along(NAMES)) {
[16:20:41.318]                   name <- added[[kk]]
[16:20:41.318]                   NAME <- NAMES[[kk]]
[16:20:41.318]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.318]                     next
[16:20:41.318]                   args[[name]] <- ""
[16:20:41.318]                 }
[16:20:41.318]                 NAMES <- toupper(removed)
[16:20:41.318]                 for (kk in seq_along(NAMES)) {
[16:20:41.318]                   name <- removed[[kk]]
[16:20:41.318]                   NAME <- NAMES[[kk]]
[16:20:41.318]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.318]                     next
[16:20:41.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.318]                 }
[16:20:41.318]                 if (length(args) > 0) 
[16:20:41.318]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.318]             }
[16:20:41.318]             else {
[16:20:41.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.318]             }
[16:20:41.318]             {
[16:20:41.318]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.318]                   0L) {
[16:20:41.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.318]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.318]                   base::options(opts)
[16:20:41.318]                 }
[16:20:41.318]                 {
[16:20:41.318]                   {
[16:20:41.318]                     NULL
[16:20:41.318]                     RNGkind("Mersenne-Twister")
[16:20:41.318]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.318]                       inherits = FALSE)
[16:20:41.318]                   }
[16:20:41.318]                   options(future.plan = NULL)
[16:20:41.318]                   if (is.na(NA_character_)) 
[16:20:41.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.318]                     .init = FALSE)
[16:20:41.318]                 }
[16:20:41.318]             }
[16:20:41.318]         }
[16:20:41.318]     })
[16:20:41.318]     if (TRUE) {
[16:20:41.318]         base::sink(type = "output", split = FALSE)
[16:20:41.318]         if (TRUE) {
[16:20:41.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.318]         }
[16:20:41.318]         else {
[16:20:41.318]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.318]         }
[16:20:41.318]         base::close(...future.stdout)
[16:20:41.318]         ...future.stdout <- NULL
[16:20:41.318]     }
[16:20:41.318]     ...future.result$conditions <- ...future.conditions
[16:20:41.318]     ...future.result$finished <- base::Sys.time()
[16:20:41.318]     ...future.result
[16:20:41.318] }
[16:20:41.320] plan(): Setting new future strategy stack:
[16:20:41.320] List of future strategies:
[16:20:41.320] 1. sequential:
[16:20:41.320]    - args: function (..., envir = parent.frame())
[16:20:41.320]    - tweaked: FALSE
[16:20:41.320]    - call: NULL
[16:20:41.321] plan(): nbrOfWorkers() = 1
[16:20:41.321] plan(): Setting new future strategy stack:
[16:20:41.321] List of future strategies:
[16:20:41.321] 1. sequential:
[16:20:41.321]    - args: function (..., envir = parent.frame())
[16:20:41.321]    - tweaked: FALSE
[16:20:41.321]    - call: plan(strategy)
[16:20:41.322] plan(): nbrOfWorkers() = 1
[16:20:41.322] SequentialFuture started (and completed)
[16:20:41.322] - Launch lazy future ... done
[16:20:41.322] run() for ‘SequentialFuture’ ... done
[16:20:41.323] getGlobalsAndPackages() ...
[16:20:41.324] Searching for globals...
[16:20:41.324] 
[16:20:41.324] Searching for globals ... DONE
[16:20:41.324] - globals: [0] <none>
[16:20:41.324] getGlobalsAndPackages() ... DONE
[16:20:41.324] run() for ‘Future’ ...
[16:20:41.324] - state: ‘created’
[16:20:41.325] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.325] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.325] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.325]   - Field: ‘label’
[16:20:41.325]   - Field: ‘local’
[16:20:41.325]   - Field: ‘owner’
[16:20:41.325]   - Field: ‘envir’
[16:20:41.325]   - Field: ‘packages’
[16:20:41.326]   - Field: ‘gc’
[16:20:41.326]   - Field: ‘conditions’
[16:20:41.326]   - Field: ‘expr’
[16:20:41.326]   - Field: ‘uuid’
[16:20:41.326]   - Field: ‘seed’
[16:20:41.326]   - Field: ‘version’
[16:20:41.326]   - Field: ‘result’
[16:20:41.326]   - Field: ‘asynchronous’
[16:20:41.326]   - Field: ‘calls’
[16:20:41.326]   - Field: ‘globals’
[16:20:41.326]   - Field: ‘stdout’
[16:20:41.327]   - Field: ‘earlySignal’
[16:20:41.327]   - Field: ‘lazy’
[16:20:41.327]   - Field: ‘state’
[16:20:41.327] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.327] - Launch lazy future ...
[16:20:41.327] Packages needed by the future expression (n = 0): <none>
[16:20:41.327] Packages needed by future strategies (n = 0): <none>
[16:20:41.328] {
[16:20:41.328]     {
[16:20:41.328]         {
[16:20:41.328]             ...future.startTime <- base::Sys.time()
[16:20:41.328]             {
[16:20:41.328]                 {
[16:20:41.328]                   {
[16:20:41.328]                     base::local({
[16:20:41.328]                       has_future <- base::requireNamespace("future", 
[16:20:41.328]                         quietly = TRUE)
[16:20:41.328]                       if (has_future) {
[16:20:41.328]                         ns <- base::getNamespace("future")
[16:20:41.328]                         version <- ns[[".package"]][["version"]]
[16:20:41.328]                         if (is.null(version)) 
[16:20:41.328]                           version <- utils::packageVersion("future")
[16:20:41.328]                       }
[16:20:41.328]                       else {
[16:20:41.328]                         version <- NULL
[16:20:41.328]                       }
[16:20:41.328]                       if (!has_future || version < "1.8.0") {
[16:20:41.328]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.328]                           "", base::R.version$version.string), 
[16:20:41.328]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.328]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.328]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.328]                             "release", "version")], collapse = " "), 
[16:20:41.328]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.328]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.328]                           info)
[16:20:41.328]                         info <- base::paste(info, collapse = "; ")
[16:20:41.328]                         if (!has_future) {
[16:20:41.328]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.328]                             info)
[16:20:41.328]                         }
[16:20:41.328]                         else {
[16:20:41.328]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.328]                             info, version)
[16:20:41.328]                         }
[16:20:41.328]                         base::stop(msg)
[16:20:41.328]                       }
[16:20:41.328]                     })
[16:20:41.328]                   }
[16:20:41.328]                   ...future.strategy.old <- future::plan("list")
[16:20:41.328]                   options(future.plan = NULL)
[16:20:41.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.328]                 }
[16:20:41.328]                 ...future.workdir <- getwd()
[16:20:41.328]             }
[16:20:41.328]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.328]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.328]         }
[16:20:41.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.328]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.328]             base::names(...future.oldOptions))
[16:20:41.328]     }
[16:20:41.328]     if (FALSE) {
[16:20:41.328]     }
[16:20:41.328]     else {
[16:20:41.328]         if (TRUE) {
[16:20:41.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.328]                 open = "w")
[16:20:41.328]         }
[16:20:41.328]         else {
[16:20:41.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.328]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.328]         }
[16:20:41.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.328]             base::sink(type = "output", split = FALSE)
[16:20:41.328]             base::close(...future.stdout)
[16:20:41.328]         }, add = TRUE)
[16:20:41.328]     }
[16:20:41.328]     ...future.frame <- base::sys.nframe()
[16:20:41.328]     ...future.conditions <- base::list()
[16:20:41.328]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.328]     if (FALSE) {
[16:20:41.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.328]     }
[16:20:41.328]     ...future.result <- base::tryCatch({
[16:20:41.328]         base::withCallingHandlers({
[16:20:41.328]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.328]             future::FutureResult(value = ...future.value$value, 
[16:20:41.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.328]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.328]                     ...future.globalenv.names))
[16:20:41.328]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.328]         }, condition = base::local({
[16:20:41.328]             c <- base::c
[16:20:41.328]             inherits <- base::inherits
[16:20:41.328]             invokeRestart <- base::invokeRestart
[16:20:41.328]             length <- base::length
[16:20:41.328]             list <- base::list
[16:20:41.328]             seq.int <- base::seq.int
[16:20:41.328]             signalCondition <- base::signalCondition
[16:20:41.328]             sys.calls <- base::sys.calls
[16:20:41.328]             `[[` <- base::`[[`
[16:20:41.328]             `+` <- base::`+`
[16:20:41.328]             `<<-` <- base::`<<-`
[16:20:41.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.328]                   3L)]
[16:20:41.328]             }
[16:20:41.328]             function(cond) {
[16:20:41.328]                 is_error <- inherits(cond, "error")
[16:20:41.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.328]                   NULL)
[16:20:41.328]                 if (is_error) {
[16:20:41.328]                   sessionInformation <- function() {
[16:20:41.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.328]                       search = base::search(), system = base::Sys.info())
[16:20:41.328]                   }
[16:20:41.328]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.328]                     cond$call), session = sessionInformation(), 
[16:20:41.328]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.328]                   signalCondition(cond)
[16:20:41.328]                 }
[16:20:41.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.328]                 "immediateCondition"))) {
[16:20:41.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.328]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.328]                   if (TRUE && !signal) {
[16:20:41.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.328]                     {
[16:20:41.328]                       inherits <- base::inherits
[16:20:41.328]                       invokeRestart <- base::invokeRestart
[16:20:41.328]                       is.null <- base::is.null
[16:20:41.328]                       muffled <- FALSE
[16:20:41.328]                       if (inherits(cond, "message")) {
[16:20:41.328]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.328]                         if (muffled) 
[16:20:41.328]                           invokeRestart("muffleMessage")
[16:20:41.328]                       }
[16:20:41.328]                       else if (inherits(cond, "warning")) {
[16:20:41.328]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.328]                         if (muffled) 
[16:20:41.328]                           invokeRestart("muffleWarning")
[16:20:41.328]                       }
[16:20:41.328]                       else if (inherits(cond, "condition")) {
[16:20:41.328]                         if (!is.null(pattern)) {
[16:20:41.328]                           computeRestarts <- base::computeRestarts
[16:20:41.328]                           grepl <- base::grepl
[16:20:41.328]                           restarts <- computeRestarts(cond)
[16:20:41.328]                           for (restart in restarts) {
[16:20:41.328]                             name <- restart$name
[16:20:41.328]                             if (is.null(name)) 
[16:20:41.328]                               next
[16:20:41.328]                             if (!grepl(pattern, name)) 
[16:20:41.328]                               next
[16:20:41.328]                             invokeRestart(restart)
[16:20:41.328]                             muffled <- TRUE
[16:20:41.328]                             break
[16:20:41.328]                           }
[16:20:41.328]                         }
[16:20:41.328]                       }
[16:20:41.328]                       invisible(muffled)
[16:20:41.328]                     }
[16:20:41.328]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.328]                   }
[16:20:41.328]                 }
[16:20:41.328]                 else {
[16:20:41.328]                   if (TRUE) {
[16:20:41.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.328]                     {
[16:20:41.328]                       inherits <- base::inherits
[16:20:41.328]                       invokeRestart <- base::invokeRestart
[16:20:41.328]                       is.null <- base::is.null
[16:20:41.328]                       muffled <- FALSE
[16:20:41.328]                       if (inherits(cond, "message")) {
[16:20:41.328]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.328]                         if (muffled) 
[16:20:41.328]                           invokeRestart("muffleMessage")
[16:20:41.328]                       }
[16:20:41.328]                       else if (inherits(cond, "warning")) {
[16:20:41.328]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.328]                         if (muffled) 
[16:20:41.328]                           invokeRestart("muffleWarning")
[16:20:41.328]                       }
[16:20:41.328]                       else if (inherits(cond, "condition")) {
[16:20:41.328]                         if (!is.null(pattern)) {
[16:20:41.328]                           computeRestarts <- base::computeRestarts
[16:20:41.328]                           grepl <- base::grepl
[16:20:41.328]                           restarts <- computeRestarts(cond)
[16:20:41.328]                           for (restart in restarts) {
[16:20:41.328]                             name <- restart$name
[16:20:41.328]                             if (is.null(name)) 
[16:20:41.328]                               next
[16:20:41.328]                             if (!grepl(pattern, name)) 
[16:20:41.328]                               next
[16:20:41.328]                             invokeRestart(restart)
[16:20:41.328]                             muffled <- TRUE
[16:20:41.328]                             break
[16:20:41.328]                           }
[16:20:41.328]                         }
[16:20:41.328]                       }
[16:20:41.328]                       invisible(muffled)
[16:20:41.328]                     }
[16:20:41.328]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.328]                   }
[16:20:41.328]                 }
[16:20:41.328]             }
[16:20:41.328]         }))
[16:20:41.328]     }, error = function(ex) {
[16:20:41.328]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.328]                 ...future.rng), started = ...future.startTime, 
[16:20:41.328]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.328]             version = "1.8"), class = "FutureResult")
[16:20:41.328]     }, finally = {
[16:20:41.328]         if (!identical(...future.workdir, getwd())) 
[16:20:41.328]             setwd(...future.workdir)
[16:20:41.328]         {
[16:20:41.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.328]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.328]             }
[16:20:41.328]             base::options(...future.oldOptions)
[16:20:41.328]             if (.Platform$OS.type == "windows") {
[16:20:41.328]                 old_names <- names(...future.oldEnvVars)
[16:20:41.328]                 envs <- base::Sys.getenv()
[16:20:41.328]                 names <- names(envs)
[16:20:41.328]                 common <- intersect(names, old_names)
[16:20:41.328]                 added <- setdiff(names, old_names)
[16:20:41.328]                 removed <- setdiff(old_names, names)
[16:20:41.328]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.328]                   envs[common]]
[16:20:41.328]                 NAMES <- toupper(changed)
[16:20:41.328]                 args <- list()
[16:20:41.328]                 for (kk in seq_along(NAMES)) {
[16:20:41.328]                   name <- changed[[kk]]
[16:20:41.328]                   NAME <- NAMES[[kk]]
[16:20:41.328]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.328]                     next
[16:20:41.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.328]                 }
[16:20:41.328]                 NAMES <- toupper(added)
[16:20:41.328]                 for (kk in seq_along(NAMES)) {
[16:20:41.328]                   name <- added[[kk]]
[16:20:41.328]                   NAME <- NAMES[[kk]]
[16:20:41.328]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.328]                     next
[16:20:41.328]                   args[[name]] <- ""
[16:20:41.328]                 }
[16:20:41.328]                 NAMES <- toupper(removed)
[16:20:41.328]                 for (kk in seq_along(NAMES)) {
[16:20:41.328]                   name <- removed[[kk]]
[16:20:41.328]                   NAME <- NAMES[[kk]]
[16:20:41.328]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.328]                     next
[16:20:41.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.328]                 }
[16:20:41.328]                 if (length(args) > 0) 
[16:20:41.328]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.328]             }
[16:20:41.328]             else {
[16:20:41.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.328]             }
[16:20:41.328]             {
[16:20:41.328]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.328]                   0L) {
[16:20:41.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.328]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.328]                   base::options(opts)
[16:20:41.328]                 }
[16:20:41.328]                 {
[16:20:41.328]                   {
[16:20:41.328]                     NULL
[16:20:41.328]                     RNGkind("Mersenne-Twister")
[16:20:41.328]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.328]                       inherits = FALSE)
[16:20:41.328]                   }
[16:20:41.328]                   options(future.plan = NULL)
[16:20:41.328]                   if (is.na(NA_character_)) 
[16:20:41.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.328]                     .init = FALSE)
[16:20:41.328]                 }
[16:20:41.328]             }
[16:20:41.328]         }
[16:20:41.328]     })
[16:20:41.328]     if (TRUE) {
[16:20:41.328]         base::sink(type = "output", split = FALSE)
[16:20:41.328]         if (TRUE) {
[16:20:41.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.328]         }
[16:20:41.328]         else {
[16:20:41.328]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.328]         }
[16:20:41.328]         base::close(...future.stdout)
[16:20:41.328]         ...future.stdout <- NULL
[16:20:41.328]     }
[16:20:41.328]     ...future.result$conditions <- ...future.conditions
[16:20:41.328]     ...future.result$finished <- base::Sys.time()
[16:20:41.328]     ...future.result
[16:20:41.328] }
[16:20:41.329] plan(): Setting new future strategy stack:
[16:20:41.329] List of future strategies:
[16:20:41.329] 1. sequential:
[16:20:41.329]    - args: function (..., envir = parent.frame())
[16:20:41.329]    - tweaked: FALSE
[16:20:41.329]    - call: NULL
[16:20:41.330] plan(): nbrOfWorkers() = 1
[16:20:41.330] plan(): Setting new future strategy stack:
[16:20:41.330] List of future strategies:
[16:20:41.330] 1. sequential:
[16:20:41.330]    - args: function (..., envir = parent.frame())
[16:20:41.330]    - tweaked: FALSE
[16:20:41.330]    - call: plan(strategy)
[16:20:41.331] plan(): nbrOfWorkers() = 1
[16:20:41.331] SequentialFuture started (and completed)
[16:20:41.331] - Launch lazy future ... done
[16:20:41.331] run() for ‘SequentialFuture’ ... done
[16:20:41.331] getGlobalsAndPackages() ...
[16:20:41.332] Searching for globals...
[16:20:41.332] - globals found: [1] ‘{’
[16:20:41.332] Searching for globals ... DONE
[16:20:41.332] Resolving globals: FALSE
[16:20:41.333] 
[16:20:41.333] 
[16:20:41.333] getGlobalsAndPackages() ... DONE
[16:20:41.333] run() for ‘Future’ ...
[16:20:41.333] - state: ‘created’
[16:20:41.333] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.333] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.334] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.334]   - Field: ‘label’
[16:20:41.334]   - Field: ‘local’
[16:20:41.334]   - Field: ‘owner’
[16:20:41.334]   - Field: ‘envir’
[16:20:41.334]   - Field: ‘packages’
[16:20:41.334]   - Field: ‘gc’
[16:20:41.334]   - Field: ‘conditions’
[16:20:41.334]   - Field: ‘expr’
[16:20:41.334]   - Field: ‘uuid’
[16:20:41.334]   - Field: ‘seed’
[16:20:41.335]   - Field: ‘version’
[16:20:41.335]   - Field: ‘result’
[16:20:41.335]   - Field: ‘asynchronous’
[16:20:41.335]   - Field: ‘calls’
[16:20:41.335]   - Field: ‘globals’
[16:20:41.335]   - Field: ‘stdout’
[16:20:41.335]   - Field: ‘earlySignal’
[16:20:41.335]   - Field: ‘lazy’
[16:20:41.335]   - Field: ‘state’
[16:20:41.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.335] - Launch lazy future ...
[16:20:41.336] Packages needed by the future expression (n = 0): <none>
[16:20:41.336] Packages needed by future strategies (n = 0): <none>
[16:20:41.336] {
[16:20:41.336]     {
[16:20:41.336]         {
[16:20:41.336]             ...future.startTime <- base::Sys.time()
[16:20:41.336]             {
[16:20:41.336]                 {
[16:20:41.336]                   {
[16:20:41.336]                     base::local({
[16:20:41.336]                       has_future <- base::requireNamespace("future", 
[16:20:41.336]                         quietly = TRUE)
[16:20:41.336]                       if (has_future) {
[16:20:41.336]                         ns <- base::getNamespace("future")
[16:20:41.336]                         version <- ns[[".package"]][["version"]]
[16:20:41.336]                         if (is.null(version)) 
[16:20:41.336]                           version <- utils::packageVersion("future")
[16:20:41.336]                       }
[16:20:41.336]                       else {
[16:20:41.336]                         version <- NULL
[16:20:41.336]                       }
[16:20:41.336]                       if (!has_future || version < "1.8.0") {
[16:20:41.336]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.336]                           "", base::R.version$version.string), 
[16:20:41.336]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.336]                             "release", "version")], collapse = " "), 
[16:20:41.336]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.336]                           info)
[16:20:41.336]                         info <- base::paste(info, collapse = "; ")
[16:20:41.336]                         if (!has_future) {
[16:20:41.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.336]                             info)
[16:20:41.336]                         }
[16:20:41.336]                         else {
[16:20:41.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.336]                             info, version)
[16:20:41.336]                         }
[16:20:41.336]                         base::stop(msg)
[16:20:41.336]                       }
[16:20:41.336]                     })
[16:20:41.336]                   }
[16:20:41.336]                   ...future.strategy.old <- future::plan("list")
[16:20:41.336]                   options(future.plan = NULL)
[16:20:41.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.336]                 }
[16:20:41.336]                 ...future.workdir <- getwd()
[16:20:41.336]             }
[16:20:41.336]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.336]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.336]         }
[16:20:41.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.336]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.336]             base::names(...future.oldOptions))
[16:20:41.336]     }
[16:20:41.336]     if (FALSE) {
[16:20:41.336]     }
[16:20:41.336]     else {
[16:20:41.336]         if (TRUE) {
[16:20:41.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.336]                 open = "w")
[16:20:41.336]         }
[16:20:41.336]         else {
[16:20:41.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.336]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.336]         }
[16:20:41.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.336]             base::sink(type = "output", split = FALSE)
[16:20:41.336]             base::close(...future.stdout)
[16:20:41.336]         }, add = TRUE)
[16:20:41.336]     }
[16:20:41.336]     ...future.frame <- base::sys.nframe()
[16:20:41.336]     ...future.conditions <- base::list()
[16:20:41.336]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.336]     if (FALSE) {
[16:20:41.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.336]     }
[16:20:41.336]     ...future.result <- base::tryCatch({
[16:20:41.336]         base::withCallingHandlers({
[16:20:41.336]             ...future.value <- base::withVisible(base::local({
[16:20:41.336]                 4
[16:20:41.336]             }))
[16:20:41.336]             future::FutureResult(value = ...future.value$value, 
[16:20:41.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.336]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.336]                     ...future.globalenv.names))
[16:20:41.336]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.336]         }, condition = base::local({
[16:20:41.336]             c <- base::c
[16:20:41.336]             inherits <- base::inherits
[16:20:41.336]             invokeRestart <- base::invokeRestart
[16:20:41.336]             length <- base::length
[16:20:41.336]             list <- base::list
[16:20:41.336]             seq.int <- base::seq.int
[16:20:41.336]             signalCondition <- base::signalCondition
[16:20:41.336]             sys.calls <- base::sys.calls
[16:20:41.336]             `[[` <- base::`[[`
[16:20:41.336]             `+` <- base::`+`
[16:20:41.336]             `<<-` <- base::`<<-`
[16:20:41.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.336]                   3L)]
[16:20:41.336]             }
[16:20:41.336]             function(cond) {
[16:20:41.336]                 is_error <- inherits(cond, "error")
[16:20:41.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.336]                   NULL)
[16:20:41.336]                 if (is_error) {
[16:20:41.336]                   sessionInformation <- function() {
[16:20:41.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.336]                       search = base::search(), system = base::Sys.info())
[16:20:41.336]                   }
[16:20:41.336]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.336]                     cond$call), session = sessionInformation(), 
[16:20:41.336]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.336]                   signalCondition(cond)
[16:20:41.336]                 }
[16:20:41.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.336]                 "immediateCondition"))) {
[16:20:41.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.336]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.336]                   if (TRUE && !signal) {
[16:20:41.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.336]                     {
[16:20:41.336]                       inherits <- base::inherits
[16:20:41.336]                       invokeRestart <- base::invokeRestart
[16:20:41.336]                       is.null <- base::is.null
[16:20:41.336]                       muffled <- FALSE
[16:20:41.336]                       if (inherits(cond, "message")) {
[16:20:41.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.336]                         if (muffled) 
[16:20:41.336]                           invokeRestart("muffleMessage")
[16:20:41.336]                       }
[16:20:41.336]                       else if (inherits(cond, "warning")) {
[16:20:41.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.336]                         if (muffled) 
[16:20:41.336]                           invokeRestart("muffleWarning")
[16:20:41.336]                       }
[16:20:41.336]                       else if (inherits(cond, "condition")) {
[16:20:41.336]                         if (!is.null(pattern)) {
[16:20:41.336]                           computeRestarts <- base::computeRestarts
[16:20:41.336]                           grepl <- base::grepl
[16:20:41.336]                           restarts <- computeRestarts(cond)
[16:20:41.336]                           for (restart in restarts) {
[16:20:41.336]                             name <- restart$name
[16:20:41.336]                             if (is.null(name)) 
[16:20:41.336]                               next
[16:20:41.336]                             if (!grepl(pattern, name)) 
[16:20:41.336]                               next
[16:20:41.336]                             invokeRestart(restart)
[16:20:41.336]                             muffled <- TRUE
[16:20:41.336]                             break
[16:20:41.336]                           }
[16:20:41.336]                         }
[16:20:41.336]                       }
[16:20:41.336]                       invisible(muffled)
[16:20:41.336]                     }
[16:20:41.336]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.336]                   }
[16:20:41.336]                 }
[16:20:41.336]                 else {
[16:20:41.336]                   if (TRUE) {
[16:20:41.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.336]                     {
[16:20:41.336]                       inherits <- base::inherits
[16:20:41.336]                       invokeRestart <- base::invokeRestart
[16:20:41.336]                       is.null <- base::is.null
[16:20:41.336]                       muffled <- FALSE
[16:20:41.336]                       if (inherits(cond, "message")) {
[16:20:41.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.336]                         if (muffled) 
[16:20:41.336]                           invokeRestart("muffleMessage")
[16:20:41.336]                       }
[16:20:41.336]                       else if (inherits(cond, "warning")) {
[16:20:41.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.336]                         if (muffled) 
[16:20:41.336]                           invokeRestart("muffleWarning")
[16:20:41.336]                       }
[16:20:41.336]                       else if (inherits(cond, "condition")) {
[16:20:41.336]                         if (!is.null(pattern)) {
[16:20:41.336]                           computeRestarts <- base::computeRestarts
[16:20:41.336]                           grepl <- base::grepl
[16:20:41.336]                           restarts <- computeRestarts(cond)
[16:20:41.336]                           for (restart in restarts) {
[16:20:41.336]                             name <- restart$name
[16:20:41.336]                             if (is.null(name)) 
[16:20:41.336]                               next
[16:20:41.336]                             if (!grepl(pattern, name)) 
[16:20:41.336]                               next
[16:20:41.336]                             invokeRestart(restart)
[16:20:41.336]                             muffled <- TRUE
[16:20:41.336]                             break
[16:20:41.336]                           }
[16:20:41.336]                         }
[16:20:41.336]                       }
[16:20:41.336]                       invisible(muffled)
[16:20:41.336]                     }
[16:20:41.336]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.336]                   }
[16:20:41.336]                 }
[16:20:41.336]             }
[16:20:41.336]         }))
[16:20:41.336]     }, error = function(ex) {
[16:20:41.336]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.336]                 ...future.rng), started = ...future.startTime, 
[16:20:41.336]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.336]             version = "1.8"), class = "FutureResult")
[16:20:41.336]     }, finally = {
[16:20:41.336]         if (!identical(...future.workdir, getwd())) 
[16:20:41.336]             setwd(...future.workdir)
[16:20:41.336]         {
[16:20:41.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.336]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.336]             }
[16:20:41.336]             base::options(...future.oldOptions)
[16:20:41.336]             if (.Platform$OS.type == "windows") {
[16:20:41.336]                 old_names <- names(...future.oldEnvVars)
[16:20:41.336]                 envs <- base::Sys.getenv()
[16:20:41.336]                 names <- names(envs)
[16:20:41.336]                 common <- intersect(names, old_names)
[16:20:41.336]                 added <- setdiff(names, old_names)
[16:20:41.336]                 removed <- setdiff(old_names, names)
[16:20:41.336]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.336]                   envs[common]]
[16:20:41.336]                 NAMES <- toupper(changed)
[16:20:41.336]                 args <- list()
[16:20:41.336]                 for (kk in seq_along(NAMES)) {
[16:20:41.336]                   name <- changed[[kk]]
[16:20:41.336]                   NAME <- NAMES[[kk]]
[16:20:41.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.336]                     next
[16:20:41.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.336]                 }
[16:20:41.336]                 NAMES <- toupper(added)
[16:20:41.336]                 for (kk in seq_along(NAMES)) {
[16:20:41.336]                   name <- added[[kk]]
[16:20:41.336]                   NAME <- NAMES[[kk]]
[16:20:41.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.336]                     next
[16:20:41.336]                   args[[name]] <- ""
[16:20:41.336]                 }
[16:20:41.336]                 NAMES <- toupper(removed)
[16:20:41.336]                 for (kk in seq_along(NAMES)) {
[16:20:41.336]                   name <- removed[[kk]]
[16:20:41.336]                   NAME <- NAMES[[kk]]
[16:20:41.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.336]                     next
[16:20:41.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.336]                 }
[16:20:41.336]                 if (length(args) > 0) 
[16:20:41.336]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.336]             }
[16:20:41.336]             else {
[16:20:41.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.336]             }
[16:20:41.336]             {
[16:20:41.336]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.336]                   0L) {
[16:20:41.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.336]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.336]                   base::options(opts)
[16:20:41.336]                 }
[16:20:41.336]                 {
[16:20:41.336]                   {
[16:20:41.336]                     NULL
[16:20:41.336]                     RNGkind("Mersenne-Twister")
[16:20:41.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.336]                       inherits = FALSE)
[16:20:41.336]                   }
[16:20:41.336]                   options(future.plan = NULL)
[16:20:41.336]                   if (is.na(NA_character_)) 
[16:20:41.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.336]                     .init = FALSE)
[16:20:41.336]                 }
[16:20:41.336]             }
[16:20:41.336]         }
[16:20:41.336]     })
[16:20:41.336]     if (TRUE) {
[16:20:41.336]         base::sink(type = "output", split = FALSE)
[16:20:41.336]         if (TRUE) {
[16:20:41.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.336]         }
[16:20:41.336]         else {
[16:20:41.336]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.336]         }
[16:20:41.336]         base::close(...future.stdout)
[16:20:41.336]         ...future.stdout <- NULL
[16:20:41.336]     }
[16:20:41.336]     ...future.result$conditions <- ...future.conditions
[16:20:41.336]     ...future.result$finished <- base::Sys.time()
[16:20:41.336]     ...future.result
[16:20:41.336] }
[16:20:41.338] plan(): Setting new future strategy stack:
[16:20:41.338] List of future strategies:
[16:20:41.338] 1. sequential:
[16:20:41.338]    - args: function (..., envir = parent.frame())
[16:20:41.338]    - tweaked: FALSE
[16:20:41.338]    - call: NULL
[16:20:41.338] plan(): nbrOfWorkers() = 1
[16:20:41.339] plan(): Setting new future strategy stack:
[16:20:41.339] List of future strategies:
[16:20:41.339] 1. sequential:
[16:20:41.339]    - args: function (..., envir = parent.frame())
[16:20:41.339]    - tweaked: FALSE
[16:20:41.339]    - call: plan(strategy)
[16:20:41.339] plan(): nbrOfWorkers() = 1
[16:20:41.339] SequentialFuture started (and completed)
[16:20:41.340] - Launch lazy future ... done
[16:20:41.340] run() for ‘SequentialFuture’ ... done
<environment: 0x55ed0c2b09e8> 
<environment: 0x55ed0c078120> 
[16:20:41.341] resolved() for ‘SequentialFuture’ ...
[16:20:41.341] - state: ‘finished’
[16:20:41.341] - run: TRUE
[16:20:41.341] - result: ‘FutureResult’
[16:20:41.341] resolved() for ‘SequentialFuture’ ... done
[16:20:41.341] resolved() for ‘SequentialFuture’ ...
[16:20:41.341] - state: ‘finished’
[16:20:41.342] - run: TRUE
[16:20:41.342] - result: ‘FutureResult’
[16:20:41.342] resolved() for ‘SequentialFuture’ ... done
[16:20:41.342] resolved() for ‘SequentialFuture’ ...
[16:20:41.342] - state: ‘finished’
[16:20:41.342] - run: TRUE
[16:20:41.342] - result: ‘FutureResult’
[16:20:41.342] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:41.343] resolve() on environment ...
[16:20:41.343]  recursive: 0
[16:20:41.344]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:41.344] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.344] - nx: 4
[16:20:41.344] - relay: TRUE
[16:20:41.344] - stdout: TRUE
[16:20:41.344] - signal: TRUE
[16:20:41.344] - resignal: FALSE
[16:20:41.344] - force: TRUE
[16:20:41.344] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.345] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.345]  - until=2
[16:20:41.345]  - relaying element #2
[16:20:41.345] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.345] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.345] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.345]  length: 3 (resolved future 1)
[16:20:41.345] resolved() for ‘SequentialFuture’ ...
[16:20:41.345] - state: ‘finished’
[16:20:41.345] - run: TRUE
[16:20:41.345] - result: ‘FutureResult’
[16:20:41.346] resolved() for ‘SequentialFuture’ ... done
[16:20:41.346] Future #2
[16:20:41.346] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.346] - nx: 4
[16:20:41.346] - relay: TRUE
[16:20:41.346] - stdout: TRUE
[16:20:41.346] - signal: TRUE
[16:20:41.346] - resignal: FALSE
[16:20:41.346] - force: TRUE
[16:20:41.346] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.346] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.346]  - until=2
[16:20:41.347]  - relaying element #2
[16:20:41.347] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.347] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.347] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.347]  length: 2 (resolved future 2)
[16:20:41.347] resolved() for ‘SequentialFuture’ ...
[16:20:41.347] - state: ‘finished’
[16:20:41.347] - run: TRUE
[16:20:41.347] - result: ‘FutureResult’
[16:20:41.347] resolved() for ‘SequentialFuture’ ... done
[16:20:41.348] Future #3
[16:20:41.348] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.348] - nx: 4
[16:20:41.348] - relay: TRUE
[16:20:41.348] - stdout: TRUE
[16:20:41.348] - signal: TRUE
[16:20:41.348] - resignal: FALSE
[16:20:41.348] - force: TRUE
[16:20:41.348] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.348] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.348]  - until=3
[16:20:41.349]  - relaying element #3
[16:20:41.350] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.350] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.350] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.350]  length: 1 (resolved future 3)
[16:20:41.350] resolved() for ‘SequentialFuture’ ...
[16:20:41.350] - state: ‘finished’
[16:20:41.350] - run: TRUE
[16:20:41.350] - result: ‘FutureResult’
[16:20:41.351] resolved() for ‘SequentialFuture’ ... done
[16:20:41.351] Future #4
[16:20:41.351] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.351] - nx: 4
[16:20:41.351] - relay: TRUE
[16:20:41.351] - stdout: TRUE
[16:20:41.351] - signal: TRUE
[16:20:41.351] - resignal: FALSE
[16:20:41.351] - force: TRUE
[16:20:41.351] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.351] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.352]  - until=4
[16:20:41.352]  - relaying element #4
[16:20:41.352] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.352] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.352] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.352]  length: 0 (resolved future 4)
[16:20:41.352] Relaying remaining futures
[16:20:41.352] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.352] - nx: 4
[16:20:41.352] - relay: TRUE
[16:20:41.352] - stdout: TRUE
[16:20:41.353] - signal: TRUE
[16:20:41.353] - resignal: FALSE
[16:20:41.353] - force: TRUE
[16:20:41.353] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.353] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:41.353] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.353] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.353] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.353] resolve() on environment ... DONE
<environment: 0x55ed0c2bd0d0> 
Dimensions: c(2, 3)
[16:20:41.354] getGlobalsAndPackages() ...
[16:20:41.354] Searching for globals...
[16:20:41.354] 
[16:20:41.354] Searching for globals ... DONE
[16:20:41.354] - globals: [0] <none>
[16:20:41.354] getGlobalsAndPackages() ... DONE
[16:20:41.355] run() for ‘Future’ ...
[16:20:41.355] - state: ‘created’
[16:20:41.355] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.355] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.355]   - Field: ‘label’
[16:20:41.355]   - Field: ‘local’
[16:20:41.355]   - Field: ‘owner’
[16:20:41.356]   - Field: ‘envir’
[16:20:41.356]   - Field: ‘packages’
[16:20:41.356]   - Field: ‘gc’
[16:20:41.356]   - Field: ‘conditions’
[16:20:41.356]   - Field: ‘expr’
[16:20:41.356]   - Field: ‘uuid’
[16:20:41.356]   - Field: ‘seed’
[16:20:41.356]   - Field: ‘version’
[16:20:41.356]   - Field: ‘result’
[16:20:41.356]   - Field: ‘asynchronous’
[16:20:41.356]   - Field: ‘calls’
[16:20:41.357]   - Field: ‘globals’
[16:20:41.357]   - Field: ‘stdout’
[16:20:41.357]   - Field: ‘earlySignal’
[16:20:41.357]   - Field: ‘lazy’
[16:20:41.357]   - Field: ‘state’
[16:20:41.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.357] - Launch lazy future ...
[16:20:41.357] Packages needed by the future expression (n = 0): <none>
[16:20:41.357] Packages needed by future strategies (n = 0): <none>
[16:20:41.358] {
[16:20:41.358]     {
[16:20:41.358]         {
[16:20:41.358]             ...future.startTime <- base::Sys.time()
[16:20:41.358]             {
[16:20:41.358]                 {
[16:20:41.358]                   {
[16:20:41.358]                     base::local({
[16:20:41.358]                       has_future <- base::requireNamespace("future", 
[16:20:41.358]                         quietly = TRUE)
[16:20:41.358]                       if (has_future) {
[16:20:41.358]                         ns <- base::getNamespace("future")
[16:20:41.358]                         version <- ns[[".package"]][["version"]]
[16:20:41.358]                         if (is.null(version)) 
[16:20:41.358]                           version <- utils::packageVersion("future")
[16:20:41.358]                       }
[16:20:41.358]                       else {
[16:20:41.358]                         version <- NULL
[16:20:41.358]                       }
[16:20:41.358]                       if (!has_future || version < "1.8.0") {
[16:20:41.358]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.358]                           "", base::R.version$version.string), 
[16:20:41.358]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.358]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.358]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.358]                             "release", "version")], collapse = " "), 
[16:20:41.358]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.358]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.358]                           info)
[16:20:41.358]                         info <- base::paste(info, collapse = "; ")
[16:20:41.358]                         if (!has_future) {
[16:20:41.358]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.358]                             info)
[16:20:41.358]                         }
[16:20:41.358]                         else {
[16:20:41.358]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.358]                             info, version)
[16:20:41.358]                         }
[16:20:41.358]                         base::stop(msg)
[16:20:41.358]                       }
[16:20:41.358]                     })
[16:20:41.358]                   }
[16:20:41.358]                   ...future.strategy.old <- future::plan("list")
[16:20:41.358]                   options(future.plan = NULL)
[16:20:41.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.358]                 }
[16:20:41.358]                 ...future.workdir <- getwd()
[16:20:41.358]             }
[16:20:41.358]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.358]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.358]         }
[16:20:41.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.358]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.358]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.358]             base::names(...future.oldOptions))
[16:20:41.358]     }
[16:20:41.358]     if (FALSE) {
[16:20:41.358]     }
[16:20:41.358]     else {
[16:20:41.358]         if (TRUE) {
[16:20:41.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.358]                 open = "w")
[16:20:41.358]         }
[16:20:41.358]         else {
[16:20:41.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.358]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.358]         }
[16:20:41.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.358]             base::sink(type = "output", split = FALSE)
[16:20:41.358]             base::close(...future.stdout)
[16:20:41.358]         }, add = TRUE)
[16:20:41.358]     }
[16:20:41.358]     ...future.frame <- base::sys.nframe()
[16:20:41.358]     ...future.conditions <- base::list()
[16:20:41.358]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.358]     if (FALSE) {
[16:20:41.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.358]     }
[16:20:41.358]     ...future.result <- base::tryCatch({
[16:20:41.358]         base::withCallingHandlers({
[16:20:41.358]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.358]             future::FutureResult(value = ...future.value$value, 
[16:20:41.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.358]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.358]                     ...future.globalenv.names))
[16:20:41.358]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.358]         }, condition = base::local({
[16:20:41.358]             c <- base::c
[16:20:41.358]             inherits <- base::inherits
[16:20:41.358]             invokeRestart <- base::invokeRestart
[16:20:41.358]             length <- base::length
[16:20:41.358]             list <- base::list
[16:20:41.358]             seq.int <- base::seq.int
[16:20:41.358]             signalCondition <- base::signalCondition
[16:20:41.358]             sys.calls <- base::sys.calls
[16:20:41.358]             `[[` <- base::`[[`
[16:20:41.358]             `+` <- base::`+`
[16:20:41.358]             `<<-` <- base::`<<-`
[16:20:41.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.358]                   3L)]
[16:20:41.358]             }
[16:20:41.358]             function(cond) {
[16:20:41.358]                 is_error <- inherits(cond, "error")
[16:20:41.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.358]                   NULL)
[16:20:41.358]                 if (is_error) {
[16:20:41.358]                   sessionInformation <- function() {
[16:20:41.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.358]                       search = base::search(), system = base::Sys.info())
[16:20:41.358]                   }
[16:20:41.358]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.358]                     cond$call), session = sessionInformation(), 
[16:20:41.358]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.358]                   signalCondition(cond)
[16:20:41.358]                 }
[16:20:41.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.358]                 "immediateCondition"))) {
[16:20:41.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.358]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.358]                   if (TRUE && !signal) {
[16:20:41.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.358]                     {
[16:20:41.358]                       inherits <- base::inherits
[16:20:41.358]                       invokeRestart <- base::invokeRestart
[16:20:41.358]                       is.null <- base::is.null
[16:20:41.358]                       muffled <- FALSE
[16:20:41.358]                       if (inherits(cond, "message")) {
[16:20:41.358]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.358]                         if (muffled) 
[16:20:41.358]                           invokeRestart("muffleMessage")
[16:20:41.358]                       }
[16:20:41.358]                       else if (inherits(cond, "warning")) {
[16:20:41.358]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.358]                         if (muffled) 
[16:20:41.358]                           invokeRestart("muffleWarning")
[16:20:41.358]                       }
[16:20:41.358]                       else if (inherits(cond, "condition")) {
[16:20:41.358]                         if (!is.null(pattern)) {
[16:20:41.358]                           computeRestarts <- base::computeRestarts
[16:20:41.358]                           grepl <- base::grepl
[16:20:41.358]                           restarts <- computeRestarts(cond)
[16:20:41.358]                           for (restart in restarts) {
[16:20:41.358]                             name <- restart$name
[16:20:41.358]                             if (is.null(name)) 
[16:20:41.358]                               next
[16:20:41.358]                             if (!grepl(pattern, name)) 
[16:20:41.358]                               next
[16:20:41.358]                             invokeRestart(restart)
[16:20:41.358]                             muffled <- TRUE
[16:20:41.358]                             break
[16:20:41.358]                           }
[16:20:41.358]                         }
[16:20:41.358]                       }
[16:20:41.358]                       invisible(muffled)
[16:20:41.358]                     }
[16:20:41.358]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.358]                   }
[16:20:41.358]                 }
[16:20:41.358]                 else {
[16:20:41.358]                   if (TRUE) {
[16:20:41.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.358]                     {
[16:20:41.358]                       inherits <- base::inherits
[16:20:41.358]                       invokeRestart <- base::invokeRestart
[16:20:41.358]                       is.null <- base::is.null
[16:20:41.358]                       muffled <- FALSE
[16:20:41.358]                       if (inherits(cond, "message")) {
[16:20:41.358]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.358]                         if (muffled) 
[16:20:41.358]                           invokeRestart("muffleMessage")
[16:20:41.358]                       }
[16:20:41.358]                       else if (inherits(cond, "warning")) {
[16:20:41.358]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.358]                         if (muffled) 
[16:20:41.358]                           invokeRestart("muffleWarning")
[16:20:41.358]                       }
[16:20:41.358]                       else if (inherits(cond, "condition")) {
[16:20:41.358]                         if (!is.null(pattern)) {
[16:20:41.358]                           computeRestarts <- base::computeRestarts
[16:20:41.358]                           grepl <- base::grepl
[16:20:41.358]                           restarts <- computeRestarts(cond)
[16:20:41.358]                           for (restart in restarts) {
[16:20:41.358]                             name <- restart$name
[16:20:41.358]                             if (is.null(name)) 
[16:20:41.358]                               next
[16:20:41.358]                             if (!grepl(pattern, name)) 
[16:20:41.358]                               next
[16:20:41.358]                             invokeRestart(restart)
[16:20:41.358]                             muffled <- TRUE
[16:20:41.358]                             break
[16:20:41.358]                           }
[16:20:41.358]                         }
[16:20:41.358]                       }
[16:20:41.358]                       invisible(muffled)
[16:20:41.358]                     }
[16:20:41.358]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.358]                   }
[16:20:41.358]                 }
[16:20:41.358]             }
[16:20:41.358]         }))
[16:20:41.358]     }, error = function(ex) {
[16:20:41.358]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.358]                 ...future.rng), started = ...future.startTime, 
[16:20:41.358]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.358]             version = "1.8"), class = "FutureResult")
[16:20:41.358]     }, finally = {
[16:20:41.358]         if (!identical(...future.workdir, getwd())) 
[16:20:41.358]             setwd(...future.workdir)
[16:20:41.358]         {
[16:20:41.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.358]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.358]             }
[16:20:41.358]             base::options(...future.oldOptions)
[16:20:41.358]             if (.Platform$OS.type == "windows") {
[16:20:41.358]                 old_names <- names(...future.oldEnvVars)
[16:20:41.358]                 envs <- base::Sys.getenv()
[16:20:41.358]                 names <- names(envs)
[16:20:41.358]                 common <- intersect(names, old_names)
[16:20:41.358]                 added <- setdiff(names, old_names)
[16:20:41.358]                 removed <- setdiff(old_names, names)
[16:20:41.358]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.358]                   envs[common]]
[16:20:41.358]                 NAMES <- toupper(changed)
[16:20:41.358]                 args <- list()
[16:20:41.358]                 for (kk in seq_along(NAMES)) {
[16:20:41.358]                   name <- changed[[kk]]
[16:20:41.358]                   NAME <- NAMES[[kk]]
[16:20:41.358]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.358]                     next
[16:20:41.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.358]                 }
[16:20:41.358]                 NAMES <- toupper(added)
[16:20:41.358]                 for (kk in seq_along(NAMES)) {
[16:20:41.358]                   name <- added[[kk]]
[16:20:41.358]                   NAME <- NAMES[[kk]]
[16:20:41.358]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.358]                     next
[16:20:41.358]                   args[[name]] <- ""
[16:20:41.358]                 }
[16:20:41.358]                 NAMES <- toupper(removed)
[16:20:41.358]                 for (kk in seq_along(NAMES)) {
[16:20:41.358]                   name <- removed[[kk]]
[16:20:41.358]                   NAME <- NAMES[[kk]]
[16:20:41.358]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.358]                     next
[16:20:41.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.358]                 }
[16:20:41.358]                 if (length(args) > 0) 
[16:20:41.358]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.358]             }
[16:20:41.358]             else {
[16:20:41.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.358]             }
[16:20:41.358]             {
[16:20:41.358]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.358]                   0L) {
[16:20:41.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.358]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.358]                   base::options(opts)
[16:20:41.358]                 }
[16:20:41.358]                 {
[16:20:41.358]                   {
[16:20:41.358]                     NULL
[16:20:41.358]                     RNGkind("Mersenne-Twister")
[16:20:41.358]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.358]                       inherits = FALSE)
[16:20:41.358]                   }
[16:20:41.358]                   options(future.plan = NULL)
[16:20:41.358]                   if (is.na(NA_character_)) 
[16:20:41.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.358]                     .init = FALSE)
[16:20:41.358]                 }
[16:20:41.358]             }
[16:20:41.358]         }
[16:20:41.358]     })
[16:20:41.358]     if (TRUE) {
[16:20:41.358]         base::sink(type = "output", split = FALSE)
[16:20:41.358]         if (TRUE) {
[16:20:41.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.358]         }
[16:20:41.358]         else {
[16:20:41.358]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.358]         }
[16:20:41.358]         base::close(...future.stdout)
[16:20:41.358]         ...future.stdout <- NULL
[16:20:41.358]     }
[16:20:41.358]     ...future.result$conditions <- ...future.conditions
[16:20:41.358]     ...future.result$finished <- base::Sys.time()
[16:20:41.358]     ...future.result
[16:20:41.358] }
[16:20:41.359] plan(): Setting new future strategy stack:
[16:20:41.359] List of future strategies:
[16:20:41.359] 1. sequential:
[16:20:41.359]    - args: function (..., envir = parent.frame())
[16:20:41.359]    - tweaked: FALSE
[16:20:41.359]    - call: NULL
[16:20:41.360] plan(): nbrOfWorkers() = 1
[16:20:41.360] plan(): Setting new future strategy stack:
[16:20:41.361] List of future strategies:
[16:20:41.361] 1. sequential:
[16:20:41.361]    - args: function (..., envir = parent.frame())
[16:20:41.361]    - tweaked: FALSE
[16:20:41.361]    - call: plan(strategy)
[16:20:41.361] plan(): nbrOfWorkers() = 1
[16:20:41.361] SequentialFuture started (and completed)
[16:20:41.361] - Launch lazy future ... done
[16:20:41.361] run() for ‘SequentialFuture’ ... done
[16:20:41.361] getGlobalsAndPackages() ...
[16:20:41.361] Searching for globals...
[16:20:41.362] 
[16:20:41.362] Searching for globals ... DONE
[16:20:41.362] - globals: [0] <none>
[16:20:41.362] getGlobalsAndPackages() ... DONE
[16:20:41.362] run() for ‘Future’ ...
[16:20:41.362] - state: ‘created’
[16:20:41.362] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.363] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.363] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.363]   - Field: ‘label’
[16:20:41.363]   - Field: ‘local’
[16:20:41.363]   - Field: ‘owner’
[16:20:41.363]   - Field: ‘envir’
[16:20:41.363]   - Field: ‘packages’
[16:20:41.363]   - Field: ‘gc’
[16:20:41.363]   - Field: ‘conditions’
[16:20:41.363]   - Field: ‘expr’
[16:20:41.364]   - Field: ‘uuid’
[16:20:41.364]   - Field: ‘seed’
[16:20:41.364]   - Field: ‘version’
[16:20:41.364]   - Field: ‘result’
[16:20:41.364]   - Field: ‘asynchronous’
[16:20:41.364]   - Field: ‘calls’
[16:20:41.364]   - Field: ‘globals’
[16:20:41.364]   - Field: ‘stdout’
[16:20:41.364]   - Field: ‘earlySignal’
[16:20:41.364]   - Field: ‘lazy’
[16:20:41.364]   - Field: ‘state’
[16:20:41.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.365] - Launch lazy future ...
[16:20:41.365] Packages needed by the future expression (n = 0): <none>
[16:20:41.365] Packages needed by future strategies (n = 0): <none>
[16:20:41.365] {
[16:20:41.365]     {
[16:20:41.365]         {
[16:20:41.365]             ...future.startTime <- base::Sys.time()
[16:20:41.365]             {
[16:20:41.365]                 {
[16:20:41.365]                   {
[16:20:41.365]                     base::local({
[16:20:41.365]                       has_future <- base::requireNamespace("future", 
[16:20:41.365]                         quietly = TRUE)
[16:20:41.365]                       if (has_future) {
[16:20:41.365]                         ns <- base::getNamespace("future")
[16:20:41.365]                         version <- ns[[".package"]][["version"]]
[16:20:41.365]                         if (is.null(version)) 
[16:20:41.365]                           version <- utils::packageVersion("future")
[16:20:41.365]                       }
[16:20:41.365]                       else {
[16:20:41.365]                         version <- NULL
[16:20:41.365]                       }
[16:20:41.365]                       if (!has_future || version < "1.8.0") {
[16:20:41.365]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.365]                           "", base::R.version$version.string), 
[16:20:41.365]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.365]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.365]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.365]                             "release", "version")], collapse = " "), 
[16:20:41.365]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.365]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.365]                           info)
[16:20:41.365]                         info <- base::paste(info, collapse = "; ")
[16:20:41.365]                         if (!has_future) {
[16:20:41.365]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.365]                             info)
[16:20:41.365]                         }
[16:20:41.365]                         else {
[16:20:41.365]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.365]                             info, version)
[16:20:41.365]                         }
[16:20:41.365]                         base::stop(msg)
[16:20:41.365]                       }
[16:20:41.365]                     })
[16:20:41.365]                   }
[16:20:41.365]                   ...future.strategy.old <- future::plan("list")
[16:20:41.365]                   options(future.plan = NULL)
[16:20:41.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.365]                 }
[16:20:41.365]                 ...future.workdir <- getwd()
[16:20:41.365]             }
[16:20:41.365]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.365]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.365]         }
[16:20:41.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.365]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.365]             base::names(...future.oldOptions))
[16:20:41.365]     }
[16:20:41.365]     if (FALSE) {
[16:20:41.365]     }
[16:20:41.365]     else {
[16:20:41.365]         if (TRUE) {
[16:20:41.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.365]                 open = "w")
[16:20:41.365]         }
[16:20:41.365]         else {
[16:20:41.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.365]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.365]         }
[16:20:41.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.365]             base::sink(type = "output", split = FALSE)
[16:20:41.365]             base::close(...future.stdout)
[16:20:41.365]         }, add = TRUE)
[16:20:41.365]     }
[16:20:41.365]     ...future.frame <- base::sys.nframe()
[16:20:41.365]     ...future.conditions <- base::list()
[16:20:41.365]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.365]     if (FALSE) {
[16:20:41.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.365]     }
[16:20:41.365]     ...future.result <- base::tryCatch({
[16:20:41.365]         base::withCallingHandlers({
[16:20:41.365]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.365]             future::FutureResult(value = ...future.value$value, 
[16:20:41.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.365]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.365]                     ...future.globalenv.names))
[16:20:41.365]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.365]         }, condition = base::local({
[16:20:41.365]             c <- base::c
[16:20:41.365]             inherits <- base::inherits
[16:20:41.365]             invokeRestart <- base::invokeRestart
[16:20:41.365]             length <- base::length
[16:20:41.365]             list <- base::list
[16:20:41.365]             seq.int <- base::seq.int
[16:20:41.365]             signalCondition <- base::signalCondition
[16:20:41.365]             sys.calls <- base::sys.calls
[16:20:41.365]             `[[` <- base::`[[`
[16:20:41.365]             `+` <- base::`+`
[16:20:41.365]             `<<-` <- base::`<<-`
[16:20:41.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.365]                   3L)]
[16:20:41.365]             }
[16:20:41.365]             function(cond) {
[16:20:41.365]                 is_error <- inherits(cond, "error")
[16:20:41.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.365]                   NULL)
[16:20:41.365]                 if (is_error) {
[16:20:41.365]                   sessionInformation <- function() {
[16:20:41.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.365]                       search = base::search(), system = base::Sys.info())
[16:20:41.365]                   }
[16:20:41.365]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.365]                     cond$call), session = sessionInformation(), 
[16:20:41.365]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.365]                   signalCondition(cond)
[16:20:41.365]                 }
[16:20:41.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.365]                 "immediateCondition"))) {
[16:20:41.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.365]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.365]                   if (TRUE && !signal) {
[16:20:41.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.365]                     {
[16:20:41.365]                       inherits <- base::inherits
[16:20:41.365]                       invokeRestart <- base::invokeRestart
[16:20:41.365]                       is.null <- base::is.null
[16:20:41.365]                       muffled <- FALSE
[16:20:41.365]                       if (inherits(cond, "message")) {
[16:20:41.365]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.365]                         if (muffled) 
[16:20:41.365]                           invokeRestart("muffleMessage")
[16:20:41.365]                       }
[16:20:41.365]                       else if (inherits(cond, "warning")) {
[16:20:41.365]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.365]                         if (muffled) 
[16:20:41.365]                           invokeRestart("muffleWarning")
[16:20:41.365]                       }
[16:20:41.365]                       else if (inherits(cond, "condition")) {
[16:20:41.365]                         if (!is.null(pattern)) {
[16:20:41.365]                           computeRestarts <- base::computeRestarts
[16:20:41.365]                           grepl <- base::grepl
[16:20:41.365]                           restarts <- computeRestarts(cond)
[16:20:41.365]                           for (restart in restarts) {
[16:20:41.365]                             name <- restart$name
[16:20:41.365]                             if (is.null(name)) 
[16:20:41.365]                               next
[16:20:41.365]                             if (!grepl(pattern, name)) 
[16:20:41.365]                               next
[16:20:41.365]                             invokeRestart(restart)
[16:20:41.365]                             muffled <- TRUE
[16:20:41.365]                             break
[16:20:41.365]                           }
[16:20:41.365]                         }
[16:20:41.365]                       }
[16:20:41.365]                       invisible(muffled)
[16:20:41.365]                     }
[16:20:41.365]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.365]                   }
[16:20:41.365]                 }
[16:20:41.365]                 else {
[16:20:41.365]                   if (TRUE) {
[16:20:41.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.365]                     {
[16:20:41.365]                       inherits <- base::inherits
[16:20:41.365]                       invokeRestart <- base::invokeRestart
[16:20:41.365]                       is.null <- base::is.null
[16:20:41.365]                       muffled <- FALSE
[16:20:41.365]                       if (inherits(cond, "message")) {
[16:20:41.365]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.365]                         if (muffled) 
[16:20:41.365]                           invokeRestart("muffleMessage")
[16:20:41.365]                       }
[16:20:41.365]                       else if (inherits(cond, "warning")) {
[16:20:41.365]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.365]                         if (muffled) 
[16:20:41.365]                           invokeRestart("muffleWarning")
[16:20:41.365]                       }
[16:20:41.365]                       else if (inherits(cond, "condition")) {
[16:20:41.365]                         if (!is.null(pattern)) {
[16:20:41.365]                           computeRestarts <- base::computeRestarts
[16:20:41.365]                           grepl <- base::grepl
[16:20:41.365]                           restarts <- computeRestarts(cond)
[16:20:41.365]                           for (restart in restarts) {
[16:20:41.365]                             name <- restart$name
[16:20:41.365]                             if (is.null(name)) 
[16:20:41.365]                               next
[16:20:41.365]                             if (!grepl(pattern, name)) 
[16:20:41.365]                               next
[16:20:41.365]                             invokeRestart(restart)
[16:20:41.365]                             muffled <- TRUE
[16:20:41.365]                             break
[16:20:41.365]                           }
[16:20:41.365]                         }
[16:20:41.365]                       }
[16:20:41.365]                       invisible(muffled)
[16:20:41.365]                     }
[16:20:41.365]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.365]                   }
[16:20:41.365]                 }
[16:20:41.365]             }
[16:20:41.365]         }))
[16:20:41.365]     }, error = function(ex) {
[16:20:41.365]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.365]                 ...future.rng), started = ...future.startTime, 
[16:20:41.365]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.365]             version = "1.8"), class = "FutureResult")
[16:20:41.365]     }, finally = {
[16:20:41.365]         if (!identical(...future.workdir, getwd())) 
[16:20:41.365]             setwd(...future.workdir)
[16:20:41.365]         {
[16:20:41.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.365]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.365]             }
[16:20:41.365]             base::options(...future.oldOptions)
[16:20:41.365]             if (.Platform$OS.type == "windows") {
[16:20:41.365]                 old_names <- names(...future.oldEnvVars)
[16:20:41.365]                 envs <- base::Sys.getenv()
[16:20:41.365]                 names <- names(envs)
[16:20:41.365]                 common <- intersect(names, old_names)
[16:20:41.365]                 added <- setdiff(names, old_names)
[16:20:41.365]                 removed <- setdiff(old_names, names)
[16:20:41.365]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.365]                   envs[common]]
[16:20:41.365]                 NAMES <- toupper(changed)
[16:20:41.365]                 args <- list()
[16:20:41.365]                 for (kk in seq_along(NAMES)) {
[16:20:41.365]                   name <- changed[[kk]]
[16:20:41.365]                   NAME <- NAMES[[kk]]
[16:20:41.365]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.365]                     next
[16:20:41.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.365]                 }
[16:20:41.365]                 NAMES <- toupper(added)
[16:20:41.365]                 for (kk in seq_along(NAMES)) {
[16:20:41.365]                   name <- added[[kk]]
[16:20:41.365]                   NAME <- NAMES[[kk]]
[16:20:41.365]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.365]                     next
[16:20:41.365]                   args[[name]] <- ""
[16:20:41.365]                 }
[16:20:41.365]                 NAMES <- toupper(removed)
[16:20:41.365]                 for (kk in seq_along(NAMES)) {
[16:20:41.365]                   name <- removed[[kk]]
[16:20:41.365]                   NAME <- NAMES[[kk]]
[16:20:41.365]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.365]                     next
[16:20:41.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.365]                 }
[16:20:41.365]                 if (length(args) > 0) 
[16:20:41.365]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.365]             }
[16:20:41.365]             else {
[16:20:41.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.365]             }
[16:20:41.365]             {
[16:20:41.365]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.365]                   0L) {
[16:20:41.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.365]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.365]                   base::options(opts)
[16:20:41.365]                 }
[16:20:41.365]                 {
[16:20:41.365]                   {
[16:20:41.365]                     NULL
[16:20:41.365]                     RNGkind("Mersenne-Twister")
[16:20:41.365]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.365]                       inherits = FALSE)
[16:20:41.365]                   }
[16:20:41.365]                   options(future.plan = NULL)
[16:20:41.365]                   if (is.na(NA_character_)) 
[16:20:41.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.365]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.365]                     .init = FALSE)
[16:20:41.365]                 }
[16:20:41.365]             }
[16:20:41.365]         }
[16:20:41.365]     })
[16:20:41.365]     if (TRUE) {
[16:20:41.365]         base::sink(type = "output", split = FALSE)
[16:20:41.365]         if (TRUE) {
[16:20:41.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.365]         }
[16:20:41.365]         else {
[16:20:41.365]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.365]         }
[16:20:41.365]         base::close(...future.stdout)
[16:20:41.365]         ...future.stdout <- NULL
[16:20:41.365]     }
[16:20:41.365]     ...future.result$conditions <- ...future.conditions
[16:20:41.365]     ...future.result$finished <- base::Sys.time()
[16:20:41.365]     ...future.result
[16:20:41.365] }
[16:20:41.367] plan(): Setting new future strategy stack:
[16:20:41.367] List of future strategies:
[16:20:41.367] 1. sequential:
[16:20:41.367]    - args: function (..., envir = parent.frame())
[16:20:41.367]    - tweaked: FALSE
[16:20:41.367]    - call: NULL
[16:20:41.367] plan(): nbrOfWorkers() = 1
[16:20:41.368] plan(): Setting new future strategy stack:
[16:20:41.368] List of future strategies:
[16:20:41.368] 1. sequential:
[16:20:41.368]    - args: function (..., envir = parent.frame())
[16:20:41.368]    - tweaked: FALSE
[16:20:41.368]    - call: plan(strategy)
[16:20:41.368] plan(): nbrOfWorkers() = 1
[16:20:41.369] SequentialFuture started (and completed)
[16:20:41.369] - Launch lazy future ... done
[16:20:41.369] run() for ‘SequentialFuture’ ... done
[16:20:41.369] getGlobalsAndPackages() ...
[16:20:41.369] Searching for globals...
[16:20:41.370] - globals found: [1] ‘{’
[16:20:41.370] Searching for globals ... DONE
[16:20:41.370] Resolving globals: FALSE
[16:20:41.370] 
[16:20:41.370] 
[16:20:41.370] getGlobalsAndPackages() ... DONE
[16:20:41.370] run() for ‘Future’ ...
[16:20:41.371] - state: ‘created’
[16:20:41.371] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.371] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.371]   - Field: ‘label’
[16:20:41.371]   - Field: ‘local’
[16:20:41.371]   - Field: ‘owner’
[16:20:41.371]   - Field: ‘envir’
[16:20:41.371]   - Field: ‘packages’
[16:20:41.372]   - Field: ‘gc’
[16:20:41.372]   - Field: ‘conditions’
[16:20:41.372]   - Field: ‘expr’
[16:20:41.372]   - Field: ‘uuid’
[16:20:41.372]   - Field: ‘seed’
[16:20:41.372]   - Field: ‘version’
[16:20:41.372]   - Field: ‘result’
[16:20:41.372]   - Field: ‘asynchronous’
[16:20:41.372]   - Field: ‘calls’
[16:20:41.372]   - Field: ‘globals’
[16:20:41.372]   - Field: ‘stdout’
[16:20:41.373]   - Field: ‘earlySignal’
[16:20:41.373]   - Field: ‘lazy’
[16:20:41.373]   - Field: ‘state’
[16:20:41.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.373] - Launch lazy future ...
[16:20:41.373] Packages needed by the future expression (n = 0): <none>
[16:20:41.373] Packages needed by future strategies (n = 0): <none>
[16:20:41.374] {
[16:20:41.374]     {
[16:20:41.374]         {
[16:20:41.374]             ...future.startTime <- base::Sys.time()
[16:20:41.374]             {
[16:20:41.374]                 {
[16:20:41.374]                   {
[16:20:41.374]                     base::local({
[16:20:41.374]                       has_future <- base::requireNamespace("future", 
[16:20:41.374]                         quietly = TRUE)
[16:20:41.374]                       if (has_future) {
[16:20:41.374]                         ns <- base::getNamespace("future")
[16:20:41.374]                         version <- ns[[".package"]][["version"]]
[16:20:41.374]                         if (is.null(version)) 
[16:20:41.374]                           version <- utils::packageVersion("future")
[16:20:41.374]                       }
[16:20:41.374]                       else {
[16:20:41.374]                         version <- NULL
[16:20:41.374]                       }
[16:20:41.374]                       if (!has_future || version < "1.8.0") {
[16:20:41.374]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.374]                           "", base::R.version$version.string), 
[16:20:41.374]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.374]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.374]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.374]                             "release", "version")], collapse = " "), 
[16:20:41.374]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.374]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.374]                           info)
[16:20:41.374]                         info <- base::paste(info, collapse = "; ")
[16:20:41.374]                         if (!has_future) {
[16:20:41.374]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.374]                             info)
[16:20:41.374]                         }
[16:20:41.374]                         else {
[16:20:41.374]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.374]                             info, version)
[16:20:41.374]                         }
[16:20:41.374]                         base::stop(msg)
[16:20:41.374]                       }
[16:20:41.374]                     })
[16:20:41.374]                   }
[16:20:41.374]                   ...future.strategy.old <- future::plan("list")
[16:20:41.374]                   options(future.plan = NULL)
[16:20:41.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.374]                 }
[16:20:41.374]                 ...future.workdir <- getwd()
[16:20:41.374]             }
[16:20:41.374]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.374]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.374]         }
[16:20:41.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.374]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.374]             base::names(...future.oldOptions))
[16:20:41.374]     }
[16:20:41.374]     if (FALSE) {
[16:20:41.374]     }
[16:20:41.374]     else {
[16:20:41.374]         if (TRUE) {
[16:20:41.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.374]                 open = "w")
[16:20:41.374]         }
[16:20:41.374]         else {
[16:20:41.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.374]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.374]         }
[16:20:41.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.374]             base::sink(type = "output", split = FALSE)
[16:20:41.374]             base::close(...future.stdout)
[16:20:41.374]         }, add = TRUE)
[16:20:41.374]     }
[16:20:41.374]     ...future.frame <- base::sys.nframe()
[16:20:41.374]     ...future.conditions <- base::list()
[16:20:41.374]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.374]     if (FALSE) {
[16:20:41.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.374]     }
[16:20:41.374]     ...future.result <- base::tryCatch({
[16:20:41.374]         base::withCallingHandlers({
[16:20:41.374]             ...future.value <- base::withVisible(base::local({
[16:20:41.374]                 4
[16:20:41.374]             }))
[16:20:41.374]             future::FutureResult(value = ...future.value$value, 
[16:20:41.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.374]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.374]                     ...future.globalenv.names))
[16:20:41.374]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.374]         }, condition = base::local({
[16:20:41.374]             c <- base::c
[16:20:41.374]             inherits <- base::inherits
[16:20:41.374]             invokeRestart <- base::invokeRestart
[16:20:41.374]             length <- base::length
[16:20:41.374]             list <- base::list
[16:20:41.374]             seq.int <- base::seq.int
[16:20:41.374]             signalCondition <- base::signalCondition
[16:20:41.374]             sys.calls <- base::sys.calls
[16:20:41.374]             `[[` <- base::`[[`
[16:20:41.374]             `+` <- base::`+`
[16:20:41.374]             `<<-` <- base::`<<-`
[16:20:41.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.374]                   3L)]
[16:20:41.374]             }
[16:20:41.374]             function(cond) {
[16:20:41.374]                 is_error <- inherits(cond, "error")
[16:20:41.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.374]                   NULL)
[16:20:41.374]                 if (is_error) {
[16:20:41.374]                   sessionInformation <- function() {
[16:20:41.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.374]                       search = base::search(), system = base::Sys.info())
[16:20:41.374]                   }
[16:20:41.374]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.374]                     cond$call), session = sessionInformation(), 
[16:20:41.374]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.374]                   signalCondition(cond)
[16:20:41.374]                 }
[16:20:41.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.374]                 "immediateCondition"))) {
[16:20:41.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.374]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.374]                   if (TRUE && !signal) {
[16:20:41.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.374]                     {
[16:20:41.374]                       inherits <- base::inherits
[16:20:41.374]                       invokeRestart <- base::invokeRestart
[16:20:41.374]                       is.null <- base::is.null
[16:20:41.374]                       muffled <- FALSE
[16:20:41.374]                       if (inherits(cond, "message")) {
[16:20:41.374]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.374]                         if (muffled) 
[16:20:41.374]                           invokeRestart("muffleMessage")
[16:20:41.374]                       }
[16:20:41.374]                       else if (inherits(cond, "warning")) {
[16:20:41.374]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.374]                         if (muffled) 
[16:20:41.374]                           invokeRestart("muffleWarning")
[16:20:41.374]                       }
[16:20:41.374]                       else if (inherits(cond, "condition")) {
[16:20:41.374]                         if (!is.null(pattern)) {
[16:20:41.374]                           computeRestarts <- base::computeRestarts
[16:20:41.374]                           grepl <- base::grepl
[16:20:41.374]                           restarts <- computeRestarts(cond)
[16:20:41.374]                           for (restart in restarts) {
[16:20:41.374]                             name <- restart$name
[16:20:41.374]                             if (is.null(name)) 
[16:20:41.374]                               next
[16:20:41.374]                             if (!grepl(pattern, name)) 
[16:20:41.374]                               next
[16:20:41.374]                             invokeRestart(restart)
[16:20:41.374]                             muffled <- TRUE
[16:20:41.374]                             break
[16:20:41.374]                           }
[16:20:41.374]                         }
[16:20:41.374]                       }
[16:20:41.374]                       invisible(muffled)
[16:20:41.374]                     }
[16:20:41.374]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.374]                   }
[16:20:41.374]                 }
[16:20:41.374]                 else {
[16:20:41.374]                   if (TRUE) {
[16:20:41.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.374]                     {
[16:20:41.374]                       inherits <- base::inherits
[16:20:41.374]                       invokeRestart <- base::invokeRestart
[16:20:41.374]                       is.null <- base::is.null
[16:20:41.374]                       muffled <- FALSE
[16:20:41.374]                       if (inherits(cond, "message")) {
[16:20:41.374]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.374]                         if (muffled) 
[16:20:41.374]                           invokeRestart("muffleMessage")
[16:20:41.374]                       }
[16:20:41.374]                       else if (inherits(cond, "warning")) {
[16:20:41.374]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.374]                         if (muffled) 
[16:20:41.374]                           invokeRestart("muffleWarning")
[16:20:41.374]                       }
[16:20:41.374]                       else if (inherits(cond, "condition")) {
[16:20:41.374]                         if (!is.null(pattern)) {
[16:20:41.374]                           computeRestarts <- base::computeRestarts
[16:20:41.374]                           grepl <- base::grepl
[16:20:41.374]                           restarts <- computeRestarts(cond)
[16:20:41.374]                           for (restart in restarts) {
[16:20:41.374]                             name <- restart$name
[16:20:41.374]                             if (is.null(name)) 
[16:20:41.374]                               next
[16:20:41.374]                             if (!grepl(pattern, name)) 
[16:20:41.374]                               next
[16:20:41.374]                             invokeRestart(restart)
[16:20:41.374]                             muffled <- TRUE
[16:20:41.374]                             break
[16:20:41.374]                           }
[16:20:41.374]                         }
[16:20:41.374]                       }
[16:20:41.374]                       invisible(muffled)
[16:20:41.374]                     }
[16:20:41.374]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.374]                   }
[16:20:41.374]                 }
[16:20:41.374]             }
[16:20:41.374]         }))
[16:20:41.374]     }, error = function(ex) {
[16:20:41.374]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.374]                 ...future.rng), started = ...future.startTime, 
[16:20:41.374]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.374]             version = "1.8"), class = "FutureResult")
[16:20:41.374]     }, finally = {
[16:20:41.374]         if (!identical(...future.workdir, getwd())) 
[16:20:41.374]             setwd(...future.workdir)
[16:20:41.374]         {
[16:20:41.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.374]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.374]             }
[16:20:41.374]             base::options(...future.oldOptions)
[16:20:41.374]             if (.Platform$OS.type == "windows") {
[16:20:41.374]                 old_names <- names(...future.oldEnvVars)
[16:20:41.374]                 envs <- base::Sys.getenv()
[16:20:41.374]                 names <- names(envs)
[16:20:41.374]                 common <- intersect(names, old_names)
[16:20:41.374]                 added <- setdiff(names, old_names)
[16:20:41.374]                 removed <- setdiff(old_names, names)
[16:20:41.374]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.374]                   envs[common]]
[16:20:41.374]                 NAMES <- toupper(changed)
[16:20:41.374]                 args <- list()
[16:20:41.374]                 for (kk in seq_along(NAMES)) {
[16:20:41.374]                   name <- changed[[kk]]
[16:20:41.374]                   NAME <- NAMES[[kk]]
[16:20:41.374]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.374]                     next
[16:20:41.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.374]                 }
[16:20:41.374]                 NAMES <- toupper(added)
[16:20:41.374]                 for (kk in seq_along(NAMES)) {
[16:20:41.374]                   name <- added[[kk]]
[16:20:41.374]                   NAME <- NAMES[[kk]]
[16:20:41.374]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.374]                     next
[16:20:41.374]                   args[[name]] <- ""
[16:20:41.374]                 }
[16:20:41.374]                 NAMES <- toupper(removed)
[16:20:41.374]                 for (kk in seq_along(NAMES)) {
[16:20:41.374]                   name <- removed[[kk]]
[16:20:41.374]                   NAME <- NAMES[[kk]]
[16:20:41.374]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.374]                     next
[16:20:41.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.374]                 }
[16:20:41.374]                 if (length(args) > 0) 
[16:20:41.374]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.374]             }
[16:20:41.374]             else {
[16:20:41.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.374]             }
[16:20:41.374]             {
[16:20:41.374]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.374]                   0L) {
[16:20:41.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.374]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.374]                   base::options(opts)
[16:20:41.374]                 }
[16:20:41.374]                 {
[16:20:41.374]                   {
[16:20:41.374]                     NULL
[16:20:41.374]                     RNGkind("Mersenne-Twister")
[16:20:41.374]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.374]                       inherits = FALSE)
[16:20:41.374]                   }
[16:20:41.374]                   options(future.plan = NULL)
[16:20:41.374]                   if (is.na(NA_character_)) 
[16:20:41.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.374]                     .init = FALSE)
[16:20:41.374]                 }
[16:20:41.374]             }
[16:20:41.374]         }
[16:20:41.374]     })
[16:20:41.374]     if (TRUE) {
[16:20:41.374]         base::sink(type = "output", split = FALSE)
[16:20:41.374]         if (TRUE) {
[16:20:41.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.374]         }
[16:20:41.374]         else {
[16:20:41.374]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.374]         }
[16:20:41.374]         base::close(...future.stdout)
[16:20:41.374]         ...future.stdout <- NULL
[16:20:41.374]     }
[16:20:41.374]     ...future.result$conditions <- ...future.conditions
[16:20:41.374]     ...future.result$finished <- base::Sys.time()
[16:20:41.374]     ...future.result
[16:20:41.374] }
[16:20:41.375] plan(): Setting new future strategy stack:
[16:20:41.375] List of future strategies:
[16:20:41.375] 1. sequential:
[16:20:41.375]    - args: function (..., envir = parent.frame())
[16:20:41.375]    - tweaked: FALSE
[16:20:41.375]    - call: NULL
[16:20:41.376] plan(): nbrOfWorkers() = 1
[16:20:41.377] plan(): Setting new future strategy stack:
[16:20:41.378] List of future strategies:
[16:20:41.378] 1. sequential:
[16:20:41.378]    - args: function (..., envir = parent.frame())
[16:20:41.378]    - tweaked: FALSE
[16:20:41.378]    - call: plan(strategy)
[16:20:41.378] plan(): nbrOfWorkers() = 1
[16:20:41.378] SequentialFuture started (and completed)
[16:20:41.378] - Launch lazy future ... done
[16:20:41.378] run() for ‘SequentialFuture’ ... done
<environment: 0x55ed09d86a08> 
<environment: 0x55ed0ab2cab8> 
[16:20:41.379] resolved() for ‘SequentialFuture’ ...
[16:20:41.380] - state: ‘finished’
[16:20:41.380] - run: TRUE
[16:20:41.380] - result: ‘FutureResult’
[16:20:41.380] resolved() for ‘SequentialFuture’ ... done
[16:20:41.380] resolved() for ‘SequentialFuture’ ...
[16:20:41.380] - state: ‘finished’
[16:20:41.380] - run: TRUE
[16:20:41.380] - result: ‘FutureResult’
[16:20:41.380] resolved() for ‘SequentialFuture’ ... done
[16:20:41.380] resolved() for ‘SequentialFuture’ ...
[16:20:41.381] - state: ‘finished’
[16:20:41.381] - run: TRUE
[16:20:41.381] - result: ‘FutureResult’
[16:20:41.381] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:41.382] resolve() on environment ...
[16:20:41.382]  recursive: 0
[16:20:41.382]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:41.383] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.383] - nx: 4
[16:20:41.383] - relay: TRUE
[16:20:41.383] - stdout: TRUE
[16:20:41.383] - signal: TRUE
[16:20:41.383] - resignal: FALSE
[16:20:41.383] - force: TRUE
[16:20:41.383] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.383] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.383]  - until=2
[16:20:41.383]  - relaying element #2
[16:20:41.383] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.384] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.384] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.384]  length: 3 (resolved future 1)
[16:20:41.384] resolved() for ‘SequentialFuture’ ...
[16:20:41.384] - state: ‘finished’
[16:20:41.384] - run: TRUE
[16:20:41.384] - result: ‘FutureResult’
[16:20:41.384] resolved() for ‘SequentialFuture’ ... done
[16:20:41.384] Future #2
[16:20:41.384] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.384] - nx: 4
[16:20:41.385] - relay: TRUE
[16:20:41.385] - stdout: TRUE
[16:20:41.385] - signal: TRUE
[16:20:41.385] - resignal: FALSE
[16:20:41.385] - force: TRUE
[16:20:41.385] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.385] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.385]  - until=2
[16:20:41.385]  - relaying element #2
[16:20:41.385] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.385] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.386] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.386]  length: 2 (resolved future 2)
[16:20:41.386] resolved() for ‘SequentialFuture’ ...
[16:20:41.386] - state: ‘finished’
[16:20:41.386] - run: TRUE
[16:20:41.386] - result: ‘FutureResult’
[16:20:41.386] resolved() for ‘SequentialFuture’ ... done
[16:20:41.386] Future #3
[16:20:41.386] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.386] - nx: 4
[16:20:41.386] - relay: TRUE
[16:20:41.387] - stdout: TRUE
[16:20:41.387] - signal: TRUE
[16:20:41.387] - resignal: FALSE
[16:20:41.387] - force: TRUE
[16:20:41.387] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.387] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.387]  - until=3
[16:20:41.387]  - relaying element #3
[16:20:41.387] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.387] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.387] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.388]  length: 1 (resolved future 3)
[16:20:41.388] resolved() for ‘SequentialFuture’ ...
[16:20:41.388] - state: ‘finished’
[16:20:41.388] - run: TRUE
[16:20:41.388] - result: ‘FutureResult’
[16:20:41.388] resolved() for ‘SequentialFuture’ ... done
[16:20:41.388] Future #4
[16:20:41.388] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.388] - nx: 4
[16:20:41.388] - relay: TRUE
[16:20:41.388] - stdout: TRUE
[16:20:41.389] - signal: TRUE
[16:20:41.389] - resignal: FALSE
[16:20:41.389] - force: TRUE
[16:20:41.389] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.389] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.389]  - until=4
[16:20:41.389]  - relaying element #4
[16:20:41.389] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.389] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.389] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.389]  length: 0 (resolved future 4)
[16:20:41.390] Relaying remaining futures
[16:20:41.390] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.390] - nx: 4
[16:20:41.390] - relay: TRUE
[16:20:41.390] - stdout: TRUE
[16:20:41.390] - signal: TRUE
[16:20:41.390] - resignal: FALSE
[16:20:41.390] - force: TRUE
[16:20:41.390] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.390] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:41.390] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.390] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.391] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.391] resolve() on environment ... DONE
<environment: 0x55ed0ad0f108> 
Dimensions: c(2, 3, 1)
[16:20:41.391] getGlobalsAndPackages() ...
[16:20:41.391] Searching for globals...
[16:20:41.392] 
[16:20:41.392] Searching for globals ... DONE
[16:20:41.392] - globals: [0] <none>
[16:20:41.392] getGlobalsAndPackages() ... DONE
[16:20:41.392] run() for ‘Future’ ...
[16:20:41.392] - state: ‘created’
[16:20:41.392] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.392] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.393]   - Field: ‘label’
[16:20:41.393]   - Field: ‘local’
[16:20:41.393]   - Field: ‘owner’
[16:20:41.393]   - Field: ‘envir’
[16:20:41.393]   - Field: ‘packages’
[16:20:41.393]   - Field: ‘gc’
[16:20:41.393]   - Field: ‘conditions’
[16:20:41.393]   - Field: ‘expr’
[16:20:41.393]   - Field: ‘uuid’
[16:20:41.394]   - Field: ‘seed’
[16:20:41.394]   - Field: ‘version’
[16:20:41.394]   - Field: ‘result’
[16:20:41.394]   - Field: ‘asynchronous’
[16:20:41.394]   - Field: ‘calls’
[16:20:41.394]   - Field: ‘globals’
[16:20:41.394]   - Field: ‘stdout’
[16:20:41.394]   - Field: ‘earlySignal’
[16:20:41.394]   - Field: ‘lazy’
[16:20:41.394]   - Field: ‘state’
[16:20:41.394] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.394] - Launch lazy future ...
[16:20:41.395] Packages needed by the future expression (n = 0): <none>
[16:20:41.395] Packages needed by future strategies (n = 0): <none>
[16:20:41.395] {
[16:20:41.395]     {
[16:20:41.395]         {
[16:20:41.395]             ...future.startTime <- base::Sys.time()
[16:20:41.395]             {
[16:20:41.395]                 {
[16:20:41.395]                   {
[16:20:41.395]                     base::local({
[16:20:41.395]                       has_future <- base::requireNamespace("future", 
[16:20:41.395]                         quietly = TRUE)
[16:20:41.395]                       if (has_future) {
[16:20:41.395]                         ns <- base::getNamespace("future")
[16:20:41.395]                         version <- ns[[".package"]][["version"]]
[16:20:41.395]                         if (is.null(version)) 
[16:20:41.395]                           version <- utils::packageVersion("future")
[16:20:41.395]                       }
[16:20:41.395]                       else {
[16:20:41.395]                         version <- NULL
[16:20:41.395]                       }
[16:20:41.395]                       if (!has_future || version < "1.8.0") {
[16:20:41.395]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.395]                           "", base::R.version$version.string), 
[16:20:41.395]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.395]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.395]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.395]                             "release", "version")], collapse = " "), 
[16:20:41.395]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.395]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.395]                           info)
[16:20:41.395]                         info <- base::paste(info, collapse = "; ")
[16:20:41.395]                         if (!has_future) {
[16:20:41.395]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.395]                             info)
[16:20:41.395]                         }
[16:20:41.395]                         else {
[16:20:41.395]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.395]                             info, version)
[16:20:41.395]                         }
[16:20:41.395]                         base::stop(msg)
[16:20:41.395]                       }
[16:20:41.395]                     })
[16:20:41.395]                   }
[16:20:41.395]                   ...future.strategy.old <- future::plan("list")
[16:20:41.395]                   options(future.plan = NULL)
[16:20:41.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.395]                 }
[16:20:41.395]                 ...future.workdir <- getwd()
[16:20:41.395]             }
[16:20:41.395]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.395]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.395]         }
[16:20:41.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.395]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.395]             base::names(...future.oldOptions))
[16:20:41.395]     }
[16:20:41.395]     if (FALSE) {
[16:20:41.395]     }
[16:20:41.395]     else {
[16:20:41.395]         if (TRUE) {
[16:20:41.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.395]                 open = "w")
[16:20:41.395]         }
[16:20:41.395]         else {
[16:20:41.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.395]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.395]         }
[16:20:41.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.395]             base::sink(type = "output", split = FALSE)
[16:20:41.395]             base::close(...future.stdout)
[16:20:41.395]         }, add = TRUE)
[16:20:41.395]     }
[16:20:41.395]     ...future.frame <- base::sys.nframe()
[16:20:41.395]     ...future.conditions <- base::list()
[16:20:41.395]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.395]     if (FALSE) {
[16:20:41.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.395]     }
[16:20:41.395]     ...future.result <- base::tryCatch({
[16:20:41.395]         base::withCallingHandlers({
[16:20:41.395]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.395]             future::FutureResult(value = ...future.value$value, 
[16:20:41.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.395]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.395]                     ...future.globalenv.names))
[16:20:41.395]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.395]         }, condition = base::local({
[16:20:41.395]             c <- base::c
[16:20:41.395]             inherits <- base::inherits
[16:20:41.395]             invokeRestart <- base::invokeRestart
[16:20:41.395]             length <- base::length
[16:20:41.395]             list <- base::list
[16:20:41.395]             seq.int <- base::seq.int
[16:20:41.395]             signalCondition <- base::signalCondition
[16:20:41.395]             sys.calls <- base::sys.calls
[16:20:41.395]             `[[` <- base::`[[`
[16:20:41.395]             `+` <- base::`+`
[16:20:41.395]             `<<-` <- base::`<<-`
[16:20:41.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.395]                   3L)]
[16:20:41.395]             }
[16:20:41.395]             function(cond) {
[16:20:41.395]                 is_error <- inherits(cond, "error")
[16:20:41.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.395]                   NULL)
[16:20:41.395]                 if (is_error) {
[16:20:41.395]                   sessionInformation <- function() {
[16:20:41.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.395]                       search = base::search(), system = base::Sys.info())
[16:20:41.395]                   }
[16:20:41.395]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.395]                     cond$call), session = sessionInformation(), 
[16:20:41.395]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.395]                   signalCondition(cond)
[16:20:41.395]                 }
[16:20:41.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.395]                 "immediateCondition"))) {
[16:20:41.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.395]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.395]                   if (TRUE && !signal) {
[16:20:41.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.395]                     {
[16:20:41.395]                       inherits <- base::inherits
[16:20:41.395]                       invokeRestart <- base::invokeRestart
[16:20:41.395]                       is.null <- base::is.null
[16:20:41.395]                       muffled <- FALSE
[16:20:41.395]                       if (inherits(cond, "message")) {
[16:20:41.395]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.395]                         if (muffled) 
[16:20:41.395]                           invokeRestart("muffleMessage")
[16:20:41.395]                       }
[16:20:41.395]                       else if (inherits(cond, "warning")) {
[16:20:41.395]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.395]                         if (muffled) 
[16:20:41.395]                           invokeRestart("muffleWarning")
[16:20:41.395]                       }
[16:20:41.395]                       else if (inherits(cond, "condition")) {
[16:20:41.395]                         if (!is.null(pattern)) {
[16:20:41.395]                           computeRestarts <- base::computeRestarts
[16:20:41.395]                           grepl <- base::grepl
[16:20:41.395]                           restarts <- computeRestarts(cond)
[16:20:41.395]                           for (restart in restarts) {
[16:20:41.395]                             name <- restart$name
[16:20:41.395]                             if (is.null(name)) 
[16:20:41.395]                               next
[16:20:41.395]                             if (!grepl(pattern, name)) 
[16:20:41.395]                               next
[16:20:41.395]                             invokeRestart(restart)
[16:20:41.395]                             muffled <- TRUE
[16:20:41.395]                             break
[16:20:41.395]                           }
[16:20:41.395]                         }
[16:20:41.395]                       }
[16:20:41.395]                       invisible(muffled)
[16:20:41.395]                     }
[16:20:41.395]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.395]                   }
[16:20:41.395]                 }
[16:20:41.395]                 else {
[16:20:41.395]                   if (TRUE) {
[16:20:41.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.395]                     {
[16:20:41.395]                       inherits <- base::inherits
[16:20:41.395]                       invokeRestart <- base::invokeRestart
[16:20:41.395]                       is.null <- base::is.null
[16:20:41.395]                       muffled <- FALSE
[16:20:41.395]                       if (inherits(cond, "message")) {
[16:20:41.395]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.395]                         if (muffled) 
[16:20:41.395]                           invokeRestart("muffleMessage")
[16:20:41.395]                       }
[16:20:41.395]                       else if (inherits(cond, "warning")) {
[16:20:41.395]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.395]                         if (muffled) 
[16:20:41.395]                           invokeRestart("muffleWarning")
[16:20:41.395]                       }
[16:20:41.395]                       else if (inherits(cond, "condition")) {
[16:20:41.395]                         if (!is.null(pattern)) {
[16:20:41.395]                           computeRestarts <- base::computeRestarts
[16:20:41.395]                           grepl <- base::grepl
[16:20:41.395]                           restarts <- computeRestarts(cond)
[16:20:41.395]                           for (restart in restarts) {
[16:20:41.395]                             name <- restart$name
[16:20:41.395]                             if (is.null(name)) 
[16:20:41.395]                               next
[16:20:41.395]                             if (!grepl(pattern, name)) 
[16:20:41.395]                               next
[16:20:41.395]                             invokeRestart(restart)
[16:20:41.395]                             muffled <- TRUE
[16:20:41.395]                             break
[16:20:41.395]                           }
[16:20:41.395]                         }
[16:20:41.395]                       }
[16:20:41.395]                       invisible(muffled)
[16:20:41.395]                     }
[16:20:41.395]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.395]                   }
[16:20:41.395]                 }
[16:20:41.395]             }
[16:20:41.395]         }))
[16:20:41.395]     }, error = function(ex) {
[16:20:41.395]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.395]                 ...future.rng), started = ...future.startTime, 
[16:20:41.395]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.395]             version = "1.8"), class = "FutureResult")
[16:20:41.395]     }, finally = {
[16:20:41.395]         if (!identical(...future.workdir, getwd())) 
[16:20:41.395]             setwd(...future.workdir)
[16:20:41.395]         {
[16:20:41.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.395]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.395]             }
[16:20:41.395]             base::options(...future.oldOptions)
[16:20:41.395]             if (.Platform$OS.type == "windows") {
[16:20:41.395]                 old_names <- names(...future.oldEnvVars)
[16:20:41.395]                 envs <- base::Sys.getenv()
[16:20:41.395]                 names <- names(envs)
[16:20:41.395]                 common <- intersect(names, old_names)
[16:20:41.395]                 added <- setdiff(names, old_names)
[16:20:41.395]                 removed <- setdiff(old_names, names)
[16:20:41.395]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.395]                   envs[common]]
[16:20:41.395]                 NAMES <- toupper(changed)
[16:20:41.395]                 args <- list()
[16:20:41.395]                 for (kk in seq_along(NAMES)) {
[16:20:41.395]                   name <- changed[[kk]]
[16:20:41.395]                   NAME <- NAMES[[kk]]
[16:20:41.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.395]                     next
[16:20:41.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.395]                 }
[16:20:41.395]                 NAMES <- toupper(added)
[16:20:41.395]                 for (kk in seq_along(NAMES)) {
[16:20:41.395]                   name <- added[[kk]]
[16:20:41.395]                   NAME <- NAMES[[kk]]
[16:20:41.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.395]                     next
[16:20:41.395]                   args[[name]] <- ""
[16:20:41.395]                 }
[16:20:41.395]                 NAMES <- toupper(removed)
[16:20:41.395]                 for (kk in seq_along(NAMES)) {
[16:20:41.395]                   name <- removed[[kk]]
[16:20:41.395]                   NAME <- NAMES[[kk]]
[16:20:41.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.395]                     next
[16:20:41.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.395]                 }
[16:20:41.395]                 if (length(args) > 0) 
[16:20:41.395]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.395]             }
[16:20:41.395]             else {
[16:20:41.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.395]             }
[16:20:41.395]             {
[16:20:41.395]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.395]                   0L) {
[16:20:41.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.395]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.395]                   base::options(opts)
[16:20:41.395]                 }
[16:20:41.395]                 {
[16:20:41.395]                   {
[16:20:41.395]                     NULL
[16:20:41.395]                     RNGkind("Mersenne-Twister")
[16:20:41.395]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.395]                       inherits = FALSE)
[16:20:41.395]                   }
[16:20:41.395]                   options(future.plan = NULL)
[16:20:41.395]                   if (is.na(NA_character_)) 
[16:20:41.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.395]                     .init = FALSE)
[16:20:41.395]                 }
[16:20:41.395]             }
[16:20:41.395]         }
[16:20:41.395]     })
[16:20:41.395]     if (TRUE) {
[16:20:41.395]         base::sink(type = "output", split = FALSE)
[16:20:41.395]         if (TRUE) {
[16:20:41.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.395]         }
[16:20:41.395]         else {
[16:20:41.395]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.395]         }
[16:20:41.395]         base::close(...future.stdout)
[16:20:41.395]         ...future.stdout <- NULL
[16:20:41.395]     }
[16:20:41.395]     ...future.result$conditions <- ...future.conditions
[16:20:41.395]     ...future.result$finished <- base::Sys.time()
[16:20:41.395]     ...future.result
[16:20:41.395] }
[16:20:41.397] plan(): Setting new future strategy stack:
[16:20:41.397] List of future strategies:
[16:20:41.397] 1. sequential:
[16:20:41.397]    - args: function (..., envir = parent.frame())
[16:20:41.397]    - tweaked: FALSE
[16:20:41.397]    - call: NULL
[16:20:41.397] plan(): nbrOfWorkers() = 1
[16:20:41.398] plan(): Setting new future strategy stack:
[16:20:41.398] List of future strategies:
[16:20:41.398] 1. sequential:
[16:20:41.398]    - args: function (..., envir = parent.frame())
[16:20:41.398]    - tweaked: FALSE
[16:20:41.398]    - call: plan(strategy)
[16:20:41.398] plan(): nbrOfWorkers() = 1
[16:20:41.398] SequentialFuture started (and completed)
[16:20:41.399] - Launch lazy future ... done
[16:20:41.399] run() for ‘SequentialFuture’ ... done
[16:20:41.399] getGlobalsAndPackages() ...
[16:20:41.399] Searching for globals...
[16:20:41.399] 
[16:20:41.399] Searching for globals ... DONE
[16:20:41.399] - globals: [0] <none>
[16:20:41.399] getGlobalsAndPackages() ... DONE
[16:20:41.400] run() for ‘Future’ ...
[16:20:41.400] - state: ‘created’
[16:20:41.400] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.400] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.401] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.402]   - Field: ‘label’
[16:20:41.402]   - Field: ‘local’
[16:20:41.402]   - Field: ‘owner’
[16:20:41.402]   - Field: ‘envir’
[16:20:41.402]   - Field: ‘packages’
[16:20:41.402]   - Field: ‘gc’
[16:20:41.402]   - Field: ‘conditions’
[16:20:41.402]   - Field: ‘expr’
[16:20:41.402]   - Field: ‘uuid’
[16:20:41.402]   - Field: ‘seed’
[16:20:41.402]   - Field: ‘version’
[16:20:41.403]   - Field: ‘result’
[16:20:41.403]   - Field: ‘asynchronous’
[16:20:41.403]   - Field: ‘calls’
[16:20:41.403]   - Field: ‘globals’
[16:20:41.403]   - Field: ‘stdout’
[16:20:41.403]   - Field: ‘earlySignal’
[16:20:41.403]   - Field: ‘lazy’
[16:20:41.403]   - Field: ‘state’
[16:20:41.403] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.403] - Launch lazy future ...
[16:20:41.403] Packages needed by the future expression (n = 0): <none>
[16:20:41.404] Packages needed by future strategies (n = 0): <none>
[16:20:41.404] {
[16:20:41.404]     {
[16:20:41.404]         {
[16:20:41.404]             ...future.startTime <- base::Sys.time()
[16:20:41.404]             {
[16:20:41.404]                 {
[16:20:41.404]                   {
[16:20:41.404]                     base::local({
[16:20:41.404]                       has_future <- base::requireNamespace("future", 
[16:20:41.404]                         quietly = TRUE)
[16:20:41.404]                       if (has_future) {
[16:20:41.404]                         ns <- base::getNamespace("future")
[16:20:41.404]                         version <- ns[[".package"]][["version"]]
[16:20:41.404]                         if (is.null(version)) 
[16:20:41.404]                           version <- utils::packageVersion("future")
[16:20:41.404]                       }
[16:20:41.404]                       else {
[16:20:41.404]                         version <- NULL
[16:20:41.404]                       }
[16:20:41.404]                       if (!has_future || version < "1.8.0") {
[16:20:41.404]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.404]                           "", base::R.version$version.string), 
[16:20:41.404]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.404]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.404]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.404]                             "release", "version")], collapse = " "), 
[16:20:41.404]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.404]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.404]                           info)
[16:20:41.404]                         info <- base::paste(info, collapse = "; ")
[16:20:41.404]                         if (!has_future) {
[16:20:41.404]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.404]                             info)
[16:20:41.404]                         }
[16:20:41.404]                         else {
[16:20:41.404]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.404]                             info, version)
[16:20:41.404]                         }
[16:20:41.404]                         base::stop(msg)
[16:20:41.404]                       }
[16:20:41.404]                     })
[16:20:41.404]                   }
[16:20:41.404]                   ...future.strategy.old <- future::plan("list")
[16:20:41.404]                   options(future.plan = NULL)
[16:20:41.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.404]                 }
[16:20:41.404]                 ...future.workdir <- getwd()
[16:20:41.404]             }
[16:20:41.404]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.404]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.404]         }
[16:20:41.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.404]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.404]             base::names(...future.oldOptions))
[16:20:41.404]     }
[16:20:41.404]     if (FALSE) {
[16:20:41.404]     }
[16:20:41.404]     else {
[16:20:41.404]         if (TRUE) {
[16:20:41.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.404]                 open = "w")
[16:20:41.404]         }
[16:20:41.404]         else {
[16:20:41.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.404]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.404]         }
[16:20:41.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.404]             base::sink(type = "output", split = FALSE)
[16:20:41.404]             base::close(...future.stdout)
[16:20:41.404]         }, add = TRUE)
[16:20:41.404]     }
[16:20:41.404]     ...future.frame <- base::sys.nframe()
[16:20:41.404]     ...future.conditions <- base::list()
[16:20:41.404]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.404]     if (FALSE) {
[16:20:41.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.404]     }
[16:20:41.404]     ...future.result <- base::tryCatch({
[16:20:41.404]         base::withCallingHandlers({
[16:20:41.404]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.404]             future::FutureResult(value = ...future.value$value, 
[16:20:41.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.404]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.404]                     ...future.globalenv.names))
[16:20:41.404]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.404]         }, condition = base::local({
[16:20:41.404]             c <- base::c
[16:20:41.404]             inherits <- base::inherits
[16:20:41.404]             invokeRestart <- base::invokeRestart
[16:20:41.404]             length <- base::length
[16:20:41.404]             list <- base::list
[16:20:41.404]             seq.int <- base::seq.int
[16:20:41.404]             signalCondition <- base::signalCondition
[16:20:41.404]             sys.calls <- base::sys.calls
[16:20:41.404]             `[[` <- base::`[[`
[16:20:41.404]             `+` <- base::`+`
[16:20:41.404]             `<<-` <- base::`<<-`
[16:20:41.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.404]                   3L)]
[16:20:41.404]             }
[16:20:41.404]             function(cond) {
[16:20:41.404]                 is_error <- inherits(cond, "error")
[16:20:41.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.404]                   NULL)
[16:20:41.404]                 if (is_error) {
[16:20:41.404]                   sessionInformation <- function() {
[16:20:41.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.404]                       search = base::search(), system = base::Sys.info())
[16:20:41.404]                   }
[16:20:41.404]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.404]                     cond$call), session = sessionInformation(), 
[16:20:41.404]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.404]                   signalCondition(cond)
[16:20:41.404]                 }
[16:20:41.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.404]                 "immediateCondition"))) {
[16:20:41.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.404]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.404]                   if (TRUE && !signal) {
[16:20:41.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.404]                     {
[16:20:41.404]                       inherits <- base::inherits
[16:20:41.404]                       invokeRestart <- base::invokeRestart
[16:20:41.404]                       is.null <- base::is.null
[16:20:41.404]                       muffled <- FALSE
[16:20:41.404]                       if (inherits(cond, "message")) {
[16:20:41.404]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.404]                         if (muffled) 
[16:20:41.404]                           invokeRestart("muffleMessage")
[16:20:41.404]                       }
[16:20:41.404]                       else if (inherits(cond, "warning")) {
[16:20:41.404]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.404]                         if (muffled) 
[16:20:41.404]                           invokeRestart("muffleWarning")
[16:20:41.404]                       }
[16:20:41.404]                       else if (inherits(cond, "condition")) {
[16:20:41.404]                         if (!is.null(pattern)) {
[16:20:41.404]                           computeRestarts <- base::computeRestarts
[16:20:41.404]                           grepl <- base::grepl
[16:20:41.404]                           restarts <- computeRestarts(cond)
[16:20:41.404]                           for (restart in restarts) {
[16:20:41.404]                             name <- restart$name
[16:20:41.404]                             if (is.null(name)) 
[16:20:41.404]                               next
[16:20:41.404]                             if (!grepl(pattern, name)) 
[16:20:41.404]                               next
[16:20:41.404]                             invokeRestart(restart)
[16:20:41.404]                             muffled <- TRUE
[16:20:41.404]                             break
[16:20:41.404]                           }
[16:20:41.404]                         }
[16:20:41.404]                       }
[16:20:41.404]                       invisible(muffled)
[16:20:41.404]                     }
[16:20:41.404]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.404]                   }
[16:20:41.404]                 }
[16:20:41.404]                 else {
[16:20:41.404]                   if (TRUE) {
[16:20:41.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.404]                     {
[16:20:41.404]                       inherits <- base::inherits
[16:20:41.404]                       invokeRestart <- base::invokeRestart
[16:20:41.404]                       is.null <- base::is.null
[16:20:41.404]                       muffled <- FALSE
[16:20:41.404]                       if (inherits(cond, "message")) {
[16:20:41.404]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.404]                         if (muffled) 
[16:20:41.404]                           invokeRestart("muffleMessage")
[16:20:41.404]                       }
[16:20:41.404]                       else if (inherits(cond, "warning")) {
[16:20:41.404]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.404]                         if (muffled) 
[16:20:41.404]                           invokeRestart("muffleWarning")
[16:20:41.404]                       }
[16:20:41.404]                       else if (inherits(cond, "condition")) {
[16:20:41.404]                         if (!is.null(pattern)) {
[16:20:41.404]                           computeRestarts <- base::computeRestarts
[16:20:41.404]                           grepl <- base::grepl
[16:20:41.404]                           restarts <- computeRestarts(cond)
[16:20:41.404]                           for (restart in restarts) {
[16:20:41.404]                             name <- restart$name
[16:20:41.404]                             if (is.null(name)) 
[16:20:41.404]                               next
[16:20:41.404]                             if (!grepl(pattern, name)) 
[16:20:41.404]                               next
[16:20:41.404]                             invokeRestart(restart)
[16:20:41.404]                             muffled <- TRUE
[16:20:41.404]                             break
[16:20:41.404]                           }
[16:20:41.404]                         }
[16:20:41.404]                       }
[16:20:41.404]                       invisible(muffled)
[16:20:41.404]                     }
[16:20:41.404]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.404]                   }
[16:20:41.404]                 }
[16:20:41.404]             }
[16:20:41.404]         }))
[16:20:41.404]     }, error = function(ex) {
[16:20:41.404]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.404]                 ...future.rng), started = ...future.startTime, 
[16:20:41.404]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.404]             version = "1.8"), class = "FutureResult")
[16:20:41.404]     }, finally = {
[16:20:41.404]         if (!identical(...future.workdir, getwd())) 
[16:20:41.404]             setwd(...future.workdir)
[16:20:41.404]         {
[16:20:41.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.404]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.404]             }
[16:20:41.404]             base::options(...future.oldOptions)
[16:20:41.404]             if (.Platform$OS.type == "windows") {
[16:20:41.404]                 old_names <- names(...future.oldEnvVars)
[16:20:41.404]                 envs <- base::Sys.getenv()
[16:20:41.404]                 names <- names(envs)
[16:20:41.404]                 common <- intersect(names, old_names)
[16:20:41.404]                 added <- setdiff(names, old_names)
[16:20:41.404]                 removed <- setdiff(old_names, names)
[16:20:41.404]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.404]                   envs[common]]
[16:20:41.404]                 NAMES <- toupper(changed)
[16:20:41.404]                 args <- list()
[16:20:41.404]                 for (kk in seq_along(NAMES)) {
[16:20:41.404]                   name <- changed[[kk]]
[16:20:41.404]                   NAME <- NAMES[[kk]]
[16:20:41.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.404]                     next
[16:20:41.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.404]                 }
[16:20:41.404]                 NAMES <- toupper(added)
[16:20:41.404]                 for (kk in seq_along(NAMES)) {
[16:20:41.404]                   name <- added[[kk]]
[16:20:41.404]                   NAME <- NAMES[[kk]]
[16:20:41.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.404]                     next
[16:20:41.404]                   args[[name]] <- ""
[16:20:41.404]                 }
[16:20:41.404]                 NAMES <- toupper(removed)
[16:20:41.404]                 for (kk in seq_along(NAMES)) {
[16:20:41.404]                   name <- removed[[kk]]
[16:20:41.404]                   NAME <- NAMES[[kk]]
[16:20:41.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.404]                     next
[16:20:41.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.404]                 }
[16:20:41.404]                 if (length(args) > 0) 
[16:20:41.404]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.404]             }
[16:20:41.404]             else {
[16:20:41.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.404]             }
[16:20:41.404]             {
[16:20:41.404]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.404]                   0L) {
[16:20:41.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.404]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.404]                   base::options(opts)
[16:20:41.404]                 }
[16:20:41.404]                 {
[16:20:41.404]                   {
[16:20:41.404]                     NULL
[16:20:41.404]                     RNGkind("Mersenne-Twister")
[16:20:41.404]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.404]                       inherits = FALSE)
[16:20:41.404]                   }
[16:20:41.404]                   options(future.plan = NULL)
[16:20:41.404]                   if (is.na(NA_character_)) 
[16:20:41.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.404]                     .init = FALSE)
[16:20:41.404]                 }
[16:20:41.404]             }
[16:20:41.404]         }
[16:20:41.404]     })
[16:20:41.404]     if (TRUE) {
[16:20:41.404]         base::sink(type = "output", split = FALSE)
[16:20:41.404]         if (TRUE) {
[16:20:41.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.404]         }
[16:20:41.404]         else {
[16:20:41.404]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.404]         }
[16:20:41.404]         base::close(...future.stdout)
[16:20:41.404]         ...future.stdout <- NULL
[16:20:41.404]     }
[16:20:41.404]     ...future.result$conditions <- ...future.conditions
[16:20:41.404]     ...future.result$finished <- base::Sys.time()
[16:20:41.404]     ...future.result
[16:20:41.404] }
[16:20:41.406] plan(): Setting new future strategy stack:
[16:20:41.406] List of future strategies:
[16:20:41.406] 1. sequential:
[16:20:41.406]    - args: function (..., envir = parent.frame())
[16:20:41.406]    - tweaked: FALSE
[16:20:41.406]    - call: NULL
[16:20:41.406] plan(): nbrOfWorkers() = 1
[16:20:41.407] plan(): Setting new future strategy stack:
[16:20:41.407] List of future strategies:
[16:20:41.407] 1. sequential:
[16:20:41.407]    - args: function (..., envir = parent.frame())
[16:20:41.407]    - tweaked: FALSE
[16:20:41.407]    - call: plan(strategy)
[16:20:41.407] plan(): nbrOfWorkers() = 1
[16:20:41.407] SequentialFuture started (and completed)
[16:20:41.407] - Launch lazy future ... done
[16:20:41.408] run() for ‘SequentialFuture’ ... done
[16:20:41.408] getGlobalsAndPackages() ...
[16:20:41.408] Searching for globals...
[16:20:41.408] - globals found: [1] ‘{’
[16:20:41.409] Searching for globals ... DONE
[16:20:41.409] Resolving globals: FALSE
[16:20:41.409] 
[16:20:41.409] 
[16:20:41.409] getGlobalsAndPackages() ... DONE
[16:20:41.409] run() for ‘Future’ ...
[16:20:41.409] - state: ‘created’
[16:20:41.410] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.410] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.410]   - Field: ‘label’
[16:20:41.410]   - Field: ‘local’
[16:20:41.410]   - Field: ‘owner’
[16:20:41.410]   - Field: ‘envir’
[16:20:41.410]   - Field: ‘packages’
[16:20:41.410]   - Field: ‘gc’
[16:20:41.410]   - Field: ‘conditions’
[16:20:41.411]   - Field: ‘expr’
[16:20:41.411]   - Field: ‘uuid’
[16:20:41.411]   - Field: ‘seed’
[16:20:41.411]   - Field: ‘version’
[16:20:41.411]   - Field: ‘result’
[16:20:41.411]   - Field: ‘asynchronous’
[16:20:41.411]   - Field: ‘calls’
[16:20:41.411]   - Field: ‘globals’
[16:20:41.411]   - Field: ‘stdout’
[16:20:41.411]   - Field: ‘earlySignal’
[16:20:41.411]   - Field: ‘lazy’
[16:20:41.412]   - Field: ‘state’
[16:20:41.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.412] - Launch lazy future ...
[16:20:41.412] Packages needed by the future expression (n = 0): <none>
[16:20:41.412] Packages needed by future strategies (n = 0): <none>
[16:20:41.412] {
[16:20:41.412]     {
[16:20:41.412]         {
[16:20:41.412]             ...future.startTime <- base::Sys.time()
[16:20:41.412]             {
[16:20:41.412]                 {
[16:20:41.412]                   {
[16:20:41.412]                     base::local({
[16:20:41.412]                       has_future <- base::requireNamespace("future", 
[16:20:41.412]                         quietly = TRUE)
[16:20:41.412]                       if (has_future) {
[16:20:41.412]                         ns <- base::getNamespace("future")
[16:20:41.412]                         version <- ns[[".package"]][["version"]]
[16:20:41.412]                         if (is.null(version)) 
[16:20:41.412]                           version <- utils::packageVersion("future")
[16:20:41.412]                       }
[16:20:41.412]                       else {
[16:20:41.412]                         version <- NULL
[16:20:41.412]                       }
[16:20:41.412]                       if (!has_future || version < "1.8.0") {
[16:20:41.412]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.412]                           "", base::R.version$version.string), 
[16:20:41.412]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.412]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.412]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.412]                             "release", "version")], collapse = " "), 
[16:20:41.412]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.412]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.412]                           info)
[16:20:41.412]                         info <- base::paste(info, collapse = "; ")
[16:20:41.412]                         if (!has_future) {
[16:20:41.412]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.412]                             info)
[16:20:41.412]                         }
[16:20:41.412]                         else {
[16:20:41.412]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.412]                             info, version)
[16:20:41.412]                         }
[16:20:41.412]                         base::stop(msg)
[16:20:41.412]                       }
[16:20:41.412]                     })
[16:20:41.412]                   }
[16:20:41.412]                   ...future.strategy.old <- future::plan("list")
[16:20:41.412]                   options(future.plan = NULL)
[16:20:41.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.412]                 }
[16:20:41.412]                 ...future.workdir <- getwd()
[16:20:41.412]             }
[16:20:41.412]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.412]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.412]         }
[16:20:41.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.412]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.412]             base::names(...future.oldOptions))
[16:20:41.412]     }
[16:20:41.412]     if (FALSE) {
[16:20:41.412]     }
[16:20:41.412]     else {
[16:20:41.412]         if (TRUE) {
[16:20:41.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.412]                 open = "w")
[16:20:41.412]         }
[16:20:41.412]         else {
[16:20:41.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.412]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.412]         }
[16:20:41.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.412]             base::sink(type = "output", split = FALSE)
[16:20:41.412]             base::close(...future.stdout)
[16:20:41.412]         }, add = TRUE)
[16:20:41.412]     }
[16:20:41.412]     ...future.frame <- base::sys.nframe()
[16:20:41.412]     ...future.conditions <- base::list()
[16:20:41.412]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.412]     if (FALSE) {
[16:20:41.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.412]     }
[16:20:41.412]     ...future.result <- base::tryCatch({
[16:20:41.412]         base::withCallingHandlers({
[16:20:41.412]             ...future.value <- base::withVisible(base::local({
[16:20:41.412]                 4
[16:20:41.412]             }))
[16:20:41.412]             future::FutureResult(value = ...future.value$value, 
[16:20:41.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.412]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.412]                     ...future.globalenv.names))
[16:20:41.412]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.412]         }, condition = base::local({
[16:20:41.412]             c <- base::c
[16:20:41.412]             inherits <- base::inherits
[16:20:41.412]             invokeRestart <- base::invokeRestart
[16:20:41.412]             length <- base::length
[16:20:41.412]             list <- base::list
[16:20:41.412]             seq.int <- base::seq.int
[16:20:41.412]             signalCondition <- base::signalCondition
[16:20:41.412]             sys.calls <- base::sys.calls
[16:20:41.412]             `[[` <- base::`[[`
[16:20:41.412]             `+` <- base::`+`
[16:20:41.412]             `<<-` <- base::`<<-`
[16:20:41.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.412]                   3L)]
[16:20:41.412]             }
[16:20:41.412]             function(cond) {
[16:20:41.412]                 is_error <- inherits(cond, "error")
[16:20:41.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.412]                   NULL)
[16:20:41.412]                 if (is_error) {
[16:20:41.412]                   sessionInformation <- function() {
[16:20:41.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.412]                       search = base::search(), system = base::Sys.info())
[16:20:41.412]                   }
[16:20:41.412]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.412]                     cond$call), session = sessionInformation(), 
[16:20:41.412]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.412]                   signalCondition(cond)
[16:20:41.412]                 }
[16:20:41.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.412]                 "immediateCondition"))) {
[16:20:41.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.412]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.412]                   if (TRUE && !signal) {
[16:20:41.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.412]                     {
[16:20:41.412]                       inherits <- base::inherits
[16:20:41.412]                       invokeRestart <- base::invokeRestart
[16:20:41.412]                       is.null <- base::is.null
[16:20:41.412]                       muffled <- FALSE
[16:20:41.412]                       if (inherits(cond, "message")) {
[16:20:41.412]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.412]                         if (muffled) 
[16:20:41.412]                           invokeRestart("muffleMessage")
[16:20:41.412]                       }
[16:20:41.412]                       else if (inherits(cond, "warning")) {
[16:20:41.412]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.412]                         if (muffled) 
[16:20:41.412]                           invokeRestart("muffleWarning")
[16:20:41.412]                       }
[16:20:41.412]                       else if (inherits(cond, "condition")) {
[16:20:41.412]                         if (!is.null(pattern)) {
[16:20:41.412]                           computeRestarts <- base::computeRestarts
[16:20:41.412]                           grepl <- base::grepl
[16:20:41.412]                           restarts <- computeRestarts(cond)
[16:20:41.412]                           for (restart in restarts) {
[16:20:41.412]                             name <- restart$name
[16:20:41.412]                             if (is.null(name)) 
[16:20:41.412]                               next
[16:20:41.412]                             if (!grepl(pattern, name)) 
[16:20:41.412]                               next
[16:20:41.412]                             invokeRestart(restart)
[16:20:41.412]                             muffled <- TRUE
[16:20:41.412]                             break
[16:20:41.412]                           }
[16:20:41.412]                         }
[16:20:41.412]                       }
[16:20:41.412]                       invisible(muffled)
[16:20:41.412]                     }
[16:20:41.412]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.412]                   }
[16:20:41.412]                 }
[16:20:41.412]                 else {
[16:20:41.412]                   if (TRUE) {
[16:20:41.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.412]                     {
[16:20:41.412]                       inherits <- base::inherits
[16:20:41.412]                       invokeRestart <- base::invokeRestart
[16:20:41.412]                       is.null <- base::is.null
[16:20:41.412]                       muffled <- FALSE
[16:20:41.412]                       if (inherits(cond, "message")) {
[16:20:41.412]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.412]                         if (muffled) 
[16:20:41.412]                           invokeRestart("muffleMessage")
[16:20:41.412]                       }
[16:20:41.412]                       else if (inherits(cond, "warning")) {
[16:20:41.412]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.412]                         if (muffled) 
[16:20:41.412]                           invokeRestart("muffleWarning")
[16:20:41.412]                       }
[16:20:41.412]                       else if (inherits(cond, "condition")) {
[16:20:41.412]                         if (!is.null(pattern)) {
[16:20:41.412]                           computeRestarts <- base::computeRestarts
[16:20:41.412]                           grepl <- base::grepl
[16:20:41.412]                           restarts <- computeRestarts(cond)
[16:20:41.412]                           for (restart in restarts) {
[16:20:41.412]                             name <- restart$name
[16:20:41.412]                             if (is.null(name)) 
[16:20:41.412]                               next
[16:20:41.412]                             if (!grepl(pattern, name)) 
[16:20:41.412]                               next
[16:20:41.412]                             invokeRestart(restart)
[16:20:41.412]                             muffled <- TRUE
[16:20:41.412]                             break
[16:20:41.412]                           }
[16:20:41.412]                         }
[16:20:41.412]                       }
[16:20:41.412]                       invisible(muffled)
[16:20:41.412]                     }
[16:20:41.412]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.412]                   }
[16:20:41.412]                 }
[16:20:41.412]             }
[16:20:41.412]         }))
[16:20:41.412]     }, error = function(ex) {
[16:20:41.412]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.412]                 ...future.rng), started = ...future.startTime, 
[16:20:41.412]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.412]             version = "1.8"), class = "FutureResult")
[16:20:41.412]     }, finally = {
[16:20:41.412]         if (!identical(...future.workdir, getwd())) 
[16:20:41.412]             setwd(...future.workdir)
[16:20:41.412]         {
[16:20:41.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.412]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.412]             }
[16:20:41.412]             base::options(...future.oldOptions)
[16:20:41.412]             if (.Platform$OS.type == "windows") {
[16:20:41.412]                 old_names <- names(...future.oldEnvVars)
[16:20:41.412]                 envs <- base::Sys.getenv()
[16:20:41.412]                 names <- names(envs)
[16:20:41.412]                 common <- intersect(names, old_names)
[16:20:41.412]                 added <- setdiff(names, old_names)
[16:20:41.412]                 removed <- setdiff(old_names, names)
[16:20:41.412]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.412]                   envs[common]]
[16:20:41.412]                 NAMES <- toupper(changed)
[16:20:41.412]                 args <- list()
[16:20:41.412]                 for (kk in seq_along(NAMES)) {
[16:20:41.412]                   name <- changed[[kk]]
[16:20:41.412]                   NAME <- NAMES[[kk]]
[16:20:41.412]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.412]                     next
[16:20:41.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.412]                 }
[16:20:41.412]                 NAMES <- toupper(added)
[16:20:41.412]                 for (kk in seq_along(NAMES)) {
[16:20:41.412]                   name <- added[[kk]]
[16:20:41.412]                   NAME <- NAMES[[kk]]
[16:20:41.412]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.412]                     next
[16:20:41.412]                   args[[name]] <- ""
[16:20:41.412]                 }
[16:20:41.412]                 NAMES <- toupper(removed)
[16:20:41.412]                 for (kk in seq_along(NAMES)) {
[16:20:41.412]                   name <- removed[[kk]]
[16:20:41.412]                   NAME <- NAMES[[kk]]
[16:20:41.412]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.412]                     next
[16:20:41.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.412]                 }
[16:20:41.412]                 if (length(args) > 0) 
[16:20:41.412]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.412]             }
[16:20:41.412]             else {
[16:20:41.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.412]             }
[16:20:41.412]             {
[16:20:41.412]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.412]                   0L) {
[16:20:41.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.412]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.412]                   base::options(opts)
[16:20:41.412]                 }
[16:20:41.412]                 {
[16:20:41.412]                   {
[16:20:41.412]                     NULL
[16:20:41.412]                     RNGkind("Mersenne-Twister")
[16:20:41.412]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.412]                       inherits = FALSE)
[16:20:41.412]                   }
[16:20:41.412]                   options(future.plan = NULL)
[16:20:41.412]                   if (is.na(NA_character_)) 
[16:20:41.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.412]                     .init = FALSE)
[16:20:41.412]                 }
[16:20:41.412]             }
[16:20:41.412]         }
[16:20:41.412]     })
[16:20:41.412]     if (TRUE) {
[16:20:41.412]         base::sink(type = "output", split = FALSE)
[16:20:41.412]         if (TRUE) {
[16:20:41.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.412]         }
[16:20:41.412]         else {
[16:20:41.412]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.412]         }
[16:20:41.412]         base::close(...future.stdout)
[16:20:41.412]         ...future.stdout <- NULL
[16:20:41.412]     }
[16:20:41.412]     ...future.result$conditions <- ...future.conditions
[16:20:41.412]     ...future.result$finished <- base::Sys.time()
[16:20:41.412]     ...future.result
[16:20:41.412] }
[16:20:41.414] plan(): Setting new future strategy stack:
[16:20:41.414] List of future strategies:
[16:20:41.414] 1. sequential:
[16:20:41.414]    - args: function (..., envir = parent.frame())
[16:20:41.414]    - tweaked: FALSE
[16:20:41.414]    - call: NULL
[16:20:41.414] plan(): nbrOfWorkers() = 1
[16:20:41.415] plan(): Setting new future strategy stack:
[16:20:41.415] List of future strategies:
[16:20:41.415] 1. sequential:
[16:20:41.415]    - args: function (..., envir = parent.frame())
[16:20:41.415]    - tweaked: FALSE
[16:20:41.415]    - call: plan(strategy)
[16:20:41.416] plan(): nbrOfWorkers() = 1
[16:20:41.416] SequentialFuture started (and completed)
[16:20:41.416] - Launch lazy future ... done
[16:20:41.416] run() for ‘SequentialFuture’ ... done
<environment: 0x55ed0c10e560> 
<environment: 0x55ed0bfc9b78> 
[16:20:41.417] resolved() for ‘SequentialFuture’ ...
[16:20:41.417] - state: ‘finished’
[16:20:41.417] - run: TRUE
[16:20:41.417] - result: ‘FutureResult’
[16:20:41.417] resolved() for ‘SequentialFuture’ ... done
[16:20:41.418] resolved() for ‘SequentialFuture’ ...
[16:20:41.418] - state: ‘finished’
[16:20:41.418] - run: TRUE
[16:20:41.418] - result: ‘FutureResult’
[16:20:41.418] resolved() for ‘SequentialFuture’ ... done
[16:20:41.418] resolved() for ‘SequentialFuture’ ...
[16:20:41.418] - state: ‘finished’
[16:20:41.418] - run: TRUE
[16:20:41.418] - result: ‘FutureResult’
[16:20:41.418] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:41.419] resolve() on environment ...
[16:20:41.419]  recursive: 0
[16:20:41.420]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:41.420] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.420] - nx: 4
[16:20:41.420] - relay: TRUE
[16:20:41.420] - stdout: TRUE
[16:20:41.420] - signal: TRUE
[16:20:41.420] - resignal: FALSE
[16:20:41.421] - force: TRUE
[16:20:41.421] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.421] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.421]  - until=2
[16:20:41.421]  - relaying element #2
[16:20:41.421] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.421] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.421] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.421]  length: 3 (resolved future 1)
[16:20:41.421] resolved() for ‘SequentialFuture’ ...
[16:20:41.421] - state: ‘finished’
[16:20:41.421] - run: TRUE
[16:20:41.422] - result: ‘FutureResult’
[16:20:41.422] resolved() for ‘SequentialFuture’ ... done
[16:20:41.422] Future #2
[16:20:41.422] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.422] - nx: 4
[16:20:41.422] - relay: TRUE
[16:20:41.422] - stdout: TRUE
[16:20:41.422] - signal: TRUE
[16:20:41.422] - resignal: FALSE
[16:20:41.422] - force: TRUE
[16:20:41.422] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.423] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.423]  - until=2
[16:20:41.423]  - relaying element #2
[16:20:41.423] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.423] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.423] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.423]  length: 2 (resolved future 2)
[16:20:41.423] resolved() for ‘SequentialFuture’ ...
[16:20:41.423] - state: ‘finished’
[16:20:41.423] - run: TRUE
[16:20:41.423] - result: ‘FutureResult’
[16:20:41.424] resolved() for ‘SequentialFuture’ ... done
[16:20:41.424] Future #3
[16:20:41.424] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.424] - nx: 4
[16:20:41.424] - relay: TRUE
[16:20:41.424] - stdout: TRUE
[16:20:41.424] - signal: TRUE
[16:20:41.424] - resignal: FALSE
[16:20:41.424] - force: TRUE
[16:20:41.424] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.424] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.425]  - until=3
[16:20:41.425]  - relaying element #3
[16:20:41.425] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.425] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.425] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.425]  length: 1 (resolved future 3)
[16:20:41.425] resolved() for ‘SequentialFuture’ ...
[16:20:41.425] - state: ‘finished’
[16:20:41.425] - run: TRUE
[16:20:41.425] - result: ‘FutureResult’
[16:20:41.426] resolved() for ‘SequentialFuture’ ... done
[16:20:41.427] Future #4
[16:20:41.427] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.427] - nx: 4
[16:20:41.427] - relay: TRUE
[16:20:41.427] - stdout: TRUE
[16:20:41.427] - signal: TRUE
[16:20:41.427] - resignal: FALSE
[16:20:41.427] - force: TRUE
[16:20:41.427] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.427] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.428]  - until=4
[16:20:41.428]  - relaying element #4
[16:20:41.428] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.428] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.428] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.428]  length: 0 (resolved future 4)
[16:20:41.428] Relaying remaining futures
[16:20:41.428] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.428] - nx: 4
[16:20:41.428] - relay: TRUE
[16:20:41.429] - stdout: TRUE
[16:20:41.429] - signal: TRUE
[16:20:41.429] - resignal: FALSE
[16:20:41.429] - force: TRUE
[16:20:41.429] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.429] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:41.429] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.429] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.429] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.429] resolve() on environment ... DONE
<environment: 0x55ed0c17c378> 
Dimensions: c(2, 1, 3, 1)
[16:20:41.430] getGlobalsAndPackages() ...
[16:20:41.430] Searching for globals...
[16:20:41.430] 
[16:20:41.430] Searching for globals ... DONE
[16:20:41.430] - globals: [0] <none>
[16:20:41.430] getGlobalsAndPackages() ... DONE
[16:20:41.431] run() for ‘Future’ ...
[16:20:41.431] - state: ‘created’
[16:20:41.431] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.431] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.431]   - Field: ‘label’
[16:20:41.431]   - Field: ‘local’
[16:20:41.431]   - Field: ‘owner’
[16:20:41.432]   - Field: ‘envir’
[16:20:41.432]   - Field: ‘packages’
[16:20:41.432]   - Field: ‘gc’
[16:20:41.432]   - Field: ‘conditions’
[16:20:41.432]   - Field: ‘expr’
[16:20:41.432]   - Field: ‘uuid’
[16:20:41.432]   - Field: ‘seed’
[16:20:41.432]   - Field: ‘version’
[16:20:41.432]   - Field: ‘result’
[16:20:41.432]   - Field: ‘asynchronous’
[16:20:41.432]   - Field: ‘calls’
[16:20:41.433]   - Field: ‘globals’
[16:20:41.433]   - Field: ‘stdout’
[16:20:41.433]   - Field: ‘earlySignal’
[16:20:41.433]   - Field: ‘lazy’
[16:20:41.433]   - Field: ‘state’
[16:20:41.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.433] - Launch lazy future ...
[16:20:41.433] Packages needed by the future expression (n = 0): <none>
[16:20:41.433] Packages needed by future strategies (n = 0): <none>
[16:20:41.434] {
[16:20:41.434]     {
[16:20:41.434]         {
[16:20:41.434]             ...future.startTime <- base::Sys.time()
[16:20:41.434]             {
[16:20:41.434]                 {
[16:20:41.434]                   {
[16:20:41.434]                     base::local({
[16:20:41.434]                       has_future <- base::requireNamespace("future", 
[16:20:41.434]                         quietly = TRUE)
[16:20:41.434]                       if (has_future) {
[16:20:41.434]                         ns <- base::getNamespace("future")
[16:20:41.434]                         version <- ns[[".package"]][["version"]]
[16:20:41.434]                         if (is.null(version)) 
[16:20:41.434]                           version <- utils::packageVersion("future")
[16:20:41.434]                       }
[16:20:41.434]                       else {
[16:20:41.434]                         version <- NULL
[16:20:41.434]                       }
[16:20:41.434]                       if (!has_future || version < "1.8.0") {
[16:20:41.434]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.434]                           "", base::R.version$version.string), 
[16:20:41.434]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.434]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.434]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.434]                             "release", "version")], collapse = " "), 
[16:20:41.434]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.434]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.434]                           info)
[16:20:41.434]                         info <- base::paste(info, collapse = "; ")
[16:20:41.434]                         if (!has_future) {
[16:20:41.434]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.434]                             info)
[16:20:41.434]                         }
[16:20:41.434]                         else {
[16:20:41.434]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.434]                             info, version)
[16:20:41.434]                         }
[16:20:41.434]                         base::stop(msg)
[16:20:41.434]                       }
[16:20:41.434]                     })
[16:20:41.434]                   }
[16:20:41.434]                   ...future.strategy.old <- future::plan("list")
[16:20:41.434]                   options(future.plan = NULL)
[16:20:41.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.434]                 }
[16:20:41.434]                 ...future.workdir <- getwd()
[16:20:41.434]             }
[16:20:41.434]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.434]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.434]         }
[16:20:41.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.434]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.434]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.434]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.434]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.434]             base::names(...future.oldOptions))
[16:20:41.434]     }
[16:20:41.434]     if (FALSE) {
[16:20:41.434]     }
[16:20:41.434]     else {
[16:20:41.434]         if (TRUE) {
[16:20:41.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.434]                 open = "w")
[16:20:41.434]         }
[16:20:41.434]         else {
[16:20:41.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.434]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.434]         }
[16:20:41.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.434]             base::sink(type = "output", split = FALSE)
[16:20:41.434]             base::close(...future.stdout)
[16:20:41.434]         }, add = TRUE)
[16:20:41.434]     }
[16:20:41.434]     ...future.frame <- base::sys.nframe()
[16:20:41.434]     ...future.conditions <- base::list()
[16:20:41.434]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.434]     if (FALSE) {
[16:20:41.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.434]     }
[16:20:41.434]     ...future.result <- base::tryCatch({
[16:20:41.434]         base::withCallingHandlers({
[16:20:41.434]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.434]             future::FutureResult(value = ...future.value$value, 
[16:20:41.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.434]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.434]                     ...future.globalenv.names))
[16:20:41.434]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.434]         }, condition = base::local({
[16:20:41.434]             c <- base::c
[16:20:41.434]             inherits <- base::inherits
[16:20:41.434]             invokeRestart <- base::invokeRestart
[16:20:41.434]             length <- base::length
[16:20:41.434]             list <- base::list
[16:20:41.434]             seq.int <- base::seq.int
[16:20:41.434]             signalCondition <- base::signalCondition
[16:20:41.434]             sys.calls <- base::sys.calls
[16:20:41.434]             `[[` <- base::`[[`
[16:20:41.434]             `+` <- base::`+`
[16:20:41.434]             `<<-` <- base::`<<-`
[16:20:41.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.434]                   3L)]
[16:20:41.434]             }
[16:20:41.434]             function(cond) {
[16:20:41.434]                 is_error <- inherits(cond, "error")
[16:20:41.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.434]                   NULL)
[16:20:41.434]                 if (is_error) {
[16:20:41.434]                   sessionInformation <- function() {
[16:20:41.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.434]                       search = base::search(), system = base::Sys.info())
[16:20:41.434]                   }
[16:20:41.434]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.434]                     cond$call), session = sessionInformation(), 
[16:20:41.434]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.434]                   signalCondition(cond)
[16:20:41.434]                 }
[16:20:41.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.434]                 "immediateCondition"))) {
[16:20:41.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.434]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.434]                   if (TRUE && !signal) {
[16:20:41.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.434]                     {
[16:20:41.434]                       inherits <- base::inherits
[16:20:41.434]                       invokeRestart <- base::invokeRestart
[16:20:41.434]                       is.null <- base::is.null
[16:20:41.434]                       muffled <- FALSE
[16:20:41.434]                       if (inherits(cond, "message")) {
[16:20:41.434]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.434]                         if (muffled) 
[16:20:41.434]                           invokeRestart("muffleMessage")
[16:20:41.434]                       }
[16:20:41.434]                       else if (inherits(cond, "warning")) {
[16:20:41.434]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.434]                         if (muffled) 
[16:20:41.434]                           invokeRestart("muffleWarning")
[16:20:41.434]                       }
[16:20:41.434]                       else if (inherits(cond, "condition")) {
[16:20:41.434]                         if (!is.null(pattern)) {
[16:20:41.434]                           computeRestarts <- base::computeRestarts
[16:20:41.434]                           grepl <- base::grepl
[16:20:41.434]                           restarts <- computeRestarts(cond)
[16:20:41.434]                           for (restart in restarts) {
[16:20:41.434]                             name <- restart$name
[16:20:41.434]                             if (is.null(name)) 
[16:20:41.434]                               next
[16:20:41.434]                             if (!grepl(pattern, name)) 
[16:20:41.434]                               next
[16:20:41.434]                             invokeRestart(restart)
[16:20:41.434]                             muffled <- TRUE
[16:20:41.434]                             break
[16:20:41.434]                           }
[16:20:41.434]                         }
[16:20:41.434]                       }
[16:20:41.434]                       invisible(muffled)
[16:20:41.434]                     }
[16:20:41.434]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.434]                   }
[16:20:41.434]                 }
[16:20:41.434]                 else {
[16:20:41.434]                   if (TRUE) {
[16:20:41.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.434]                     {
[16:20:41.434]                       inherits <- base::inherits
[16:20:41.434]                       invokeRestart <- base::invokeRestart
[16:20:41.434]                       is.null <- base::is.null
[16:20:41.434]                       muffled <- FALSE
[16:20:41.434]                       if (inherits(cond, "message")) {
[16:20:41.434]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.434]                         if (muffled) 
[16:20:41.434]                           invokeRestart("muffleMessage")
[16:20:41.434]                       }
[16:20:41.434]                       else if (inherits(cond, "warning")) {
[16:20:41.434]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.434]                         if (muffled) 
[16:20:41.434]                           invokeRestart("muffleWarning")
[16:20:41.434]                       }
[16:20:41.434]                       else if (inherits(cond, "condition")) {
[16:20:41.434]                         if (!is.null(pattern)) {
[16:20:41.434]                           computeRestarts <- base::computeRestarts
[16:20:41.434]                           grepl <- base::grepl
[16:20:41.434]                           restarts <- computeRestarts(cond)
[16:20:41.434]                           for (restart in restarts) {
[16:20:41.434]                             name <- restart$name
[16:20:41.434]                             if (is.null(name)) 
[16:20:41.434]                               next
[16:20:41.434]                             if (!grepl(pattern, name)) 
[16:20:41.434]                               next
[16:20:41.434]                             invokeRestart(restart)
[16:20:41.434]                             muffled <- TRUE
[16:20:41.434]                             break
[16:20:41.434]                           }
[16:20:41.434]                         }
[16:20:41.434]                       }
[16:20:41.434]                       invisible(muffled)
[16:20:41.434]                     }
[16:20:41.434]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.434]                   }
[16:20:41.434]                 }
[16:20:41.434]             }
[16:20:41.434]         }))
[16:20:41.434]     }, error = function(ex) {
[16:20:41.434]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.434]                 ...future.rng), started = ...future.startTime, 
[16:20:41.434]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.434]             version = "1.8"), class = "FutureResult")
[16:20:41.434]     }, finally = {
[16:20:41.434]         if (!identical(...future.workdir, getwd())) 
[16:20:41.434]             setwd(...future.workdir)
[16:20:41.434]         {
[16:20:41.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.434]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.434]             }
[16:20:41.434]             base::options(...future.oldOptions)
[16:20:41.434]             if (.Platform$OS.type == "windows") {
[16:20:41.434]                 old_names <- names(...future.oldEnvVars)
[16:20:41.434]                 envs <- base::Sys.getenv()
[16:20:41.434]                 names <- names(envs)
[16:20:41.434]                 common <- intersect(names, old_names)
[16:20:41.434]                 added <- setdiff(names, old_names)
[16:20:41.434]                 removed <- setdiff(old_names, names)
[16:20:41.434]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.434]                   envs[common]]
[16:20:41.434]                 NAMES <- toupper(changed)
[16:20:41.434]                 args <- list()
[16:20:41.434]                 for (kk in seq_along(NAMES)) {
[16:20:41.434]                   name <- changed[[kk]]
[16:20:41.434]                   NAME <- NAMES[[kk]]
[16:20:41.434]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.434]                     next
[16:20:41.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.434]                 }
[16:20:41.434]                 NAMES <- toupper(added)
[16:20:41.434]                 for (kk in seq_along(NAMES)) {
[16:20:41.434]                   name <- added[[kk]]
[16:20:41.434]                   NAME <- NAMES[[kk]]
[16:20:41.434]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.434]                     next
[16:20:41.434]                   args[[name]] <- ""
[16:20:41.434]                 }
[16:20:41.434]                 NAMES <- toupper(removed)
[16:20:41.434]                 for (kk in seq_along(NAMES)) {
[16:20:41.434]                   name <- removed[[kk]]
[16:20:41.434]                   NAME <- NAMES[[kk]]
[16:20:41.434]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.434]                     next
[16:20:41.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.434]                 }
[16:20:41.434]                 if (length(args) > 0) 
[16:20:41.434]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.434]             }
[16:20:41.434]             else {
[16:20:41.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.434]             }
[16:20:41.434]             {
[16:20:41.434]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.434]                   0L) {
[16:20:41.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.434]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.434]                   base::options(opts)
[16:20:41.434]                 }
[16:20:41.434]                 {
[16:20:41.434]                   {
[16:20:41.434]                     NULL
[16:20:41.434]                     RNGkind("Mersenne-Twister")
[16:20:41.434]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.434]                       inherits = FALSE)
[16:20:41.434]                   }
[16:20:41.434]                   options(future.plan = NULL)
[16:20:41.434]                   if (is.na(NA_character_)) 
[16:20:41.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.434]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.434]                     .init = FALSE)
[16:20:41.434]                 }
[16:20:41.434]             }
[16:20:41.434]         }
[16:20:41.434]     })
[16:20:41.434]     if (TRUE) {
[16:20:41.434]         base::sink(type = "output", split = FALSE)
[16:20:41.434]         if (TRUE) {
[16:20:41.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.434]         }
[16:20:41.434]         else {
[16:20:41.434]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.434]         }
[16:20:41.434]         base::close(...future.stdout)
[16:20:41.434]         ...future.stdout <- NULL
[16:20:41.434]     }
[16:20:41.434]     ...future.result$conditions <- ...future.conditions
[16:20:41.434]     ...future.result$finished <- base::Sys.time()
[16:20:41.434]     ...future.result
[16:20:41.434] }
[16:20:41.435] plan(): Setting new future strategy stack:
[16:20:41.435] List of future strategies:
[16:20:41.435] 1. sequential:
[16:20:41.435]    - args: function (..., envir = parent.frame())
[16:20:41.435]    - tweaked: FALSE
[16:20:41.435]    - call: NULL
[16:20:41.436] plan(): nbrOfWorkers() = 1
[16:20:41.436] plan(): Setting new future strategy stack:
[16:20:41.437] List of future strategies:
[16:20:41.437] 1. sequential:
[16:20:41.437]    - args: function (..., envir = parent.frame())
[16:20:41.437]    - tweaked: FALSE
[16:20:41.437]    - call: plan(strategy)
[16:20:41.437] plan(): nbrOfWorkers() = 1
[16:20:41.437] SequentialFuture started (and completed)
[16:20:41.437] - Launch lazy future ... done
[16:20:41.437] run() for ‘SequentialFuture’ ... done
[16:20:41.437] getGlobalsAndPackages() ...
[16:20:41.437] Searching for globals...
[16:20:41.438] 
[16:20:41.438] Searching for globals ... DONE
[16:20:41.438] - globals: [0] <none>
[16:20:41.438] getGlobalsAndPackages() ... DONE
[16:20:41.438] run() for ‘Future’ ...
[16:20:41.438] - state: ‘created’
[16:20:41.438] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.439] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.439]   - Field: ‘label’
[16:20:41.439]   - Field: ‘local’
[16:20:41.439]   - Field: ‘owner’
[16:20:41.439]   - Field: ‘envir’
[16:20:41.439]   - Field: ‘packages’
[16:20:41.439]   - Field: ‘gc’
[16:20:41.439]   - Field: ‘conditions’
[16:20:41.439]   - Field: ‘expr’
[16:20:41.439]   - Field: ‘uuid’
[16:20:41.440]   - Field: ‘seed’
[16:20:41.440]   - Field: ‘version’
[16:20:41.440]   - Field: ‘result’
[16:20:41.440]   - Field: ‘asynchronous’
[16:20:41.440]   - Field: ‘calls’
[16:20:41.440]   - Field: ‘globals’
[16:20:41.440]   - Field: ‘stdout’
[16:20:41.440]   - Field: ‘earlySignal’
[16:20:41.440]   - Field: ‘lazy’
[16:20:41.440]   - Field: ‘state’
[16:20:41.440] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.441] - Launch lazy future ...
[16:20:41.441] Packages needed by the future expression (n = 0): <none>
[16:20:41.441] Packages needed by future strategies (n = 0): <none>
[16:20:41.441] {
[16:20:41.441]     {
[16:20:41.441]         {
[16:20:41.441]             ...future.startTime <- base::Sys.time()
[16:20:41.441]             {
[16:20:41.441]                 {
[16:20:41.441]                   {
[16:20:41.441]                     base::local({
[16:20:41.441]                       has_future <- base::requireNamespace("future", 
[16:20:41.441]                         quietly = TRUE)
[16:20:41.441]                       if (has_future) {
[16:20:41.441]                         ns <- base::getNamespace("future")
[16:20:41.441]                         version <- ns[[".package"]][["version"]]
[16:20:41.441]                         if (is.null(version)) 
[16:20:41.441]                           version <- utils::packageVersion("future")
[16:20:41.441]                       }
[16:20:41.441]                       else {
[16:20:41.441]                         version <- NULL
[16:20:41.441]                       }
[16:20:41.441]                       if (!has_future || version < "1.8.0") {
[16:20:41.441]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.441]                           "", base::R.version$version.string), 
[16:20:41.441]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.441]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.441]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.441]                             "release", "version")], collapse = " "), 
[16:20:41.441]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.441]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.441]                           info)
[16:20:41.441]                         info <- base::paste(info, collapse = "; ")
[16:20:41.441]                         if (!has_future) {
[16:20:41.441]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.441]                             info)
[16:20:41.441]                         }
[16:20:41.441]                         else {
[16:20:41.441]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.441]                             info, version)
[16:20:41.441]                         }
[16:20:41.441]                         base::stop(msg)
[16:20:41.441]                       }
[16:20:41.441]                     })
[16:20:41.441]                   }
[16:20:41.441]                   ...future.strategy.old <- future::plan("list")
[16:20:41.441]                   options(future.plan = NULL)
[16:20:41.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.441]                 }
[16:20:41.441]                 ...future.workdir <- getwd()
[16:20:41.441]             }
[16:20:41.441]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.441]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.441]         }
[16:20:41.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.441]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.441]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.441]             base::names(...future.oldOptions))
[16:20:41.441]     }
[16:20:41.441]     if (FALSE) {
[16:20:41.441]     }
[16:20:41.441]     else {
[16:20:41.441]         if (TRUE) {
[16:20:41.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.441]                 open = "w")
[16:20:41.441]         }
[16:20:41.441]         else {
[16:20:41.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.441]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.441]         }
[16:20:41.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.441]             base::sink(type = "output", split = FALSE)
[16:20:41.441]             base::close(...future.stdout)
[16:20:41.441]         }, add = TRUE)
[16:20:41.441]     }
[16:20:41.441]     ...future.frame <- base::sys.nframe()
[16:20:41.441]     ...future.conditions <- base::list()
[16:20:41.441]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.441]     if (FALSE) {
[16:20:41.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.441]     }
[16:20:41.441]     ...future.result <- base::tryCatch({
[16:20:41.441]         base::withCallingHandlers({
[16:20:41.441]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.441]             future::FutureResult(value = ...future.value$value, 
[16:20:41.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.441]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.441]                     ...future.globalenv.names))
[16:20:41.441]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.441]         }, condition = base::local({
[16:20:41.441]             c <- base::c
[16:20:41.441]             inherits <- base::inherits
[16:20:41.441]             invokeRestart <- base::invokeRestart
[16:20:41.441]             length <- base::length
[16:20:41.441]             list <- base::list
[16:20:41.441]             seq.int <- base::seq.int
[16:20:41.441]             signalCondition <- base::signalCondition
[16:20:41.441]             sys.calls <- base::sys.calls
[16:20:41.441]             `[[` <- base::`[[`
[16:20:41.441]             `+` <- base::`+`
[16:20:41.441]             `<<-` <- base::`<<-`
[16:20:41.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.441]                   3L)]
[16:20:41.441]             }
[16:20:41.441]             function(cond) {
[16:20:41.441]                 is_error <- inherits(cond, "error")
[16:20:41.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.441]                   NULL)
[16:20:41.441]                 if (is_error) {
[16:20:41.441]                   sessionInformation <- function() {
[16:20:41.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.441]                       search = base::search(), system = base::Sys.info())
[16:20:41.441]                   }
[16:20:41.441]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.441]                     cond$call), session = sessionInformation(), 
[16:20:41.441]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.441]                   signalCondition(cond)
[16:20:41.441]                 }
[16:20:41.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.441]                 "immediateCondition"))) {
[16:20:41.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.441]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.441]                   if (TRUE && !signal) {
[16:20:41.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.441]                     {
[16:20:41.441]                       inherits <- base::inherits
[16:20:41.441]                       invokeRestart <- base::invokeRestart
[16:20:41.441]                       is.null <- base::is.null
[16:20:41.441]                       muffled <- FALSE
[16:20:41.441]                       if (inherits(cond, "message")) {
[16:20:41.441]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.441]                         if (muffled) 
[16:20:41.441]                           invokeRestart("muffleMessage")
[16:20:41.441]                       }
[16:20:41.441]                       else if (inherits(cond, "warning")) {
[16:20:41.441]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.441]                         if (muffled) 
[16:20:41.441]                           invokeRestart("muffleWarning")
[16:20:41.441]                       }
[16:20:41.441]                       else if (inherits(cond, "condition")) {
[16:20:41.441]                         if (!is.null(pattern)) {
[16:20:41.441]                           computeRestarts <- base::computeRestarts
[16:20:41.441]                           grepl <- base::grepl
[16:20:41.441]                           restarts <- computeRestarts(cond)
[16:20:41.441]                           for (restart in restarts) {
[16:20:41.441]                             name <- restart$name
[16:20:41.441]                             if (is.null(name)) 
[16:20:41.441]                               next
[16:20:41.441]                             if (!grepl(pattern, name)) 
[16:20:41.441]                               next
[16:20:41.441]                             invokeRestart(restart)
[16:20:41.441]                             muffled <- TRUE
[16:20:41.441]                             break
[16:20:41.441]                           }
[16:20:41.441]                         }
[16:20:41.441]                       }
[16:20:41.441]                       invisible(muffled)
[16:20:41.441]                     }
[16:20:41.441]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.441]                   }
[16:20:41.441]                 }
[16:20:41.441]                 else {
[16:20:41.441]                   if (TRUE) {
[16:20:41.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.441]                     {
[16:20:41.441]                       inherits <- base::inherits
[16:20:41.441]                       invokeRestart <- base::invokeRestart
[16:20:41.441]                       is.null <- base::is.null
[16:20:41.441]                       muffled <- FALSE
[16:20:41.441]                       if (inherits(cond, "message")) {
[16:20:41.441]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.441]                         if (muffled) 
[16:20:41.441]                           invokeRestart("muffleMessage")
[16:20:41.441]                       }
[16:20:41.441]                       else if (inherits(cond, "warning")) {
[16:20:41.441]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.441]                         if (muffled) 
[16:20:41.441]                           invokeRestart("muffleWarning")
[16:20:41.441]                       }
[16:20:41.441]                       else if (inherits(cond, "condition")) {
[16:20:41.441]                         if (!is.null(pattern)) {
[16:20:41.441]                           computeRestarts <- base::computeRestarts
[16:20:41.441]                           grepl <- base::grepl
[16:20:41.441]                           restarts <- computeRestarts(cond)
[16:20:41.441]                           for (restart in restarts) {
[16:20:41.441]                             name <- restart$name
[16:20:41.441]                             if (is.null(name)) 
[16:20:41.441]                               next
[16:20:41.441]                             if (!grepl(pattern, name)) 
[16:20:41.441]                               next
[16:20:41.441]                             invokeRestart(restart)
[16:20:41.441]                             muffled <- TRUE
[16:20:41.441]                             break
[16:20:41.441]                           }
[16:20:41.441]                         }
[16:20:41.441]                       }
[16:20:41.441]                       invisible(muffled)
[16:20:41.441]                     }
[16:20:41.441]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.441]                   }
[16:20:41.441]                 }
[16:20:41.441]             }
[16:20:41.441]         }))
[16:20:41.441]     }, error = function(ex) {
[16:20:41.441]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.441]                 ...future.rng), started = ...future.startTime, 
[16:20:41.441]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.441]             version = "1.8"), class = "FutureResult")
[16:20:41.441]     }, finally = {
[16:20:41.441]         if (!identical(...future.workdir, getwd())) 
[16:20:41.441]             setwd(...future.workdir)
[16:20:41.441]         {
[16:20:41.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.441]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.441]             }
[16:20:41.441]             base::options(...future.oldOptions)
[16:20:41.441]             if (.Platform$OS.type == "windows") {
[16:20:41.441]                 old_names <- names(...future.oldEnvVars)
[16:20:41.441]                 envs <- base::Sys.getenv()
[16:20:41.441]                 names <- names(envs)
[16:20:41.441]                 common <- intersect(names, old_names)
[16:20:41.441]                 added <- setdiff(names, old_names)
[16:20:41.441]                 removed <- setdiff(old_names, names)
[16:20:41.441]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.441]                   envs[common]]
[16:20:41.441]                 NAMES <- toupper(changed)
[16:20:41.441]                 args <- list()
[16:20:41.441]                 for (kk in seq_along(NAMES)) {
[16:20:41.441]                   name <- changed[[kk]]
[16:20:41.441]                   NAME <- NAMES[[kk]]
[16:20:41.441]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.441]                     next
[16:20:41.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.441]                 }
[16:20:41.441]                 NAMES <- toupper(added)
[16:20:41.441]                 for (kk in seq_along(NAMES)) {
[16:20:41.441]                   name <- added[[kk]]
[16:20:41.441]                   NAME <- NAMES[[kk]]
[16:20:41.441]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.441]                     next
[16:20:41.441]                   args[[name]] <- ""
[16:20:41.441]                 }
[16:20:41.441]                 NAMES <- toupper(removed)
[16:20:41.441]                 for (kk in seq_along(NAMES)) {
[16:20:41.441]                   name <- removed[[kk]]
[16:20:41.441]                   NAME <- NAMES[[kk]]
[16:20:41.441]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.441]                     next
[16:20:41.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.441]                 }
[16:20:41.441]                 if (length(args) > 0) 
[16:20:41.441]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.441]             }
[16:20:41.441]             else {
[16:20:41.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.441]             }
[16:20:41.441]             {
[16:20:41.441]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.441]                   0L) {
[16:20:41.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.441]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.441]                   base::options(opts)
[16:20:41.441]                 }
[16:20:41.441]                 {
[16:20:41.441]                   {
[16:20:41.441]                     NULL
[16:20:41.441]                     RNGkind("Mersenne-Twister")
[16:20:41.441]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.441]                       inherits = FALSE)
[16:20:41.441]                   }
[16:20:41.441]                   options(future.plan = NULL)
[16:20:41.441]                   if (is.na(NA_character_)) 
[16:20:41.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.441]                     .init = FALSE)
[16:20:41.441]                 }
[16:20:41.441]             }
[16:20:41.441]         }
[16:20:41.441]     })
[16:20:41.441]     if (TRUE) {
[16:20:41.441]         base::sink(type = "output", split = FALSE)
[16:20:41.441]         if (TRUE) {
[16:20:41.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.441]         }
[16:20:41.441]         else {
[16:20:41.441]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.441]         }
[16:20:41.441]         base::close(...future.stdout)
[16:20:41.441]         ...future.stdout <- NULL
[16:20:41.441]     }
[16:20:41.441]     ...future.result$conditions <- ...future.conditions
[16:20:41.441]     ...future.result$finished <- base::Sys.time()
[16:20:41.441]     ...future.result
[16:20:41.441] }
[16:20:41.443] plan(): Setting new future strategy stack:
[16:20:41.443] List of future strategies:
[16:20:41.443] 1. sequential:
[16:20:41.443]    - args: function (..., envir = parent.frame())
[16:20:41.443]    - tweaked: FALSE
[16:20:41.443]    - call: NULL
[16:20:41.443] plan(): nbrOfWorkers() = 1
[16:20:41.444] plan(): Setting new future strategy stack:
[16:20:41.444] List of future strategies:
[16:20:41.444] 1. sequential:
[16:20:41.444]    - args: function (..., envir = parent.frame())
[16:20:41.444]    - tweaked: FALSE
[16:20:41.444]    - call: plan(strategy)
[16:20:41.444] plan(): nbrOfWorkers() = 1
[16:20:41.444] SequentialFuture started (and completed)
[16:20:41.445] - Launch lazy future ... done
[16:20:41.445] run() for ‘SequentialFuture’ ... done
[16:20:41.445] getGlobalsAndPackages() ...
[16:20:41.445] Searching for globals...
[16:20:41.446] - globals found: [1] ‘{’
[16:20:41.446] Searching for globals ... DONE
[16:20:41.446] Resolving globals: FALSE
[16:20:41.446] 
[16:20:41.446] 
[16:20:41.446] getGlobalsAndPackages() ... DONE
[16:20:41.446] run() for ‘Future’ ...
[16:20:41.446] - state: ‘created’
[16:20:41.447] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.447] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.447]   - Field: ‘label’
[16:20:41.447]   - Field: ‘local’
[16:20:41.447]   - Field: ‘owner’
[16:20:41.447]   - Field: ‘envir’
[16:20:41.447]   - Field: ‘packages’
[16:20:41.447]   - Field: ‘gc’
[16:20:41.448]   - Field: ‘conditions’
[16:20:41.448]   - Field: ‘expr’
[16:20:41.448]   - Field: ‘uuid’
[16:20:41.448]   - Field: ‘seed’
[16:20:41.448]   - Field: ‘version’
[16:20:41.448]   - Field: ‘result’
[16:20:41.448]   - Field: ‘asynchronous’
[16:20:41.448]   - Field: ‘calls’
[16:20:41.448]   - Field: ‘globals’
[16:20:41.448]   - Field: ‘stdout’
[16:20:41.448]   - Field: ‘earlySignal’
[16:20:41.449]   - Field: ‘lazy’
[16:20:41.449]   - Field: ‘state’
[16:20:41.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.449] - Launch lazy future ...
[16:20:41.449] Packages needed by the future expression (n = 0): <none>
[16:20:41.449] Packages needed by future strategies (n = 0): <none>
[16:20:41.449] {
[16:20:41.449]     {
[16:20:41.449]         {
[16:20:41.449]             ...future.startTime <- base::Sys.time()
[16:20:41.449]             {
[16:20:41.449]                 {
[16:20:41.449]                   {
[16:20:41.449]                     base::local({
[16:20:41.449]                       has_future <- base::requireNamespace("future", 
[16:20:41.449]                         quietly = TRUE)
[16:20:41.449]                       if (has_future) {
[16:20:41.449]                         ns <- base::getNamespace("future")
[16:20:41.449]                         version <- ns[[".package"]][["version"]]
[16:20:41.449]                         if (is.null(version)) 
[16:20:41.449]                           version <- utils::packageVersion("future")
[16:20:41.449]                       }
[16:20:41.449]                       else {
[16:20:41.449]                         version <- NULL
[16:20:41.449]                       }
[16:20:41.449]                       if (!has_future || version < "1.8.0") {
[16:20:41.449]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.449]                           "", base::R.version$version.string), 
[16:20:41.449]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.449]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.449]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.449]                             "release", "version")], collapse = " "), 
[16:20:41.449]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.449]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.449]                           info)
[16:20:41.449]                         info <- base::paste(info, collapse = "; ")
[16:20:41.449]                         if (!has_future) {
[16:20:41.449]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.449]                             info)
[16:20:41.449]                         }
[16:20:41.449]                         else {
[16:20:41.449]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.449]                             info, version)
[16:20:41.449]                         }
[16:20:41.449]                         base::stop(msg)
[16:20:41.449]                       }
[16:20:41.449]                     })
[16:20:41.449]                   }
[16:20:41.449]                   ...future.strategy.old <- future::plan("list")
[16:20:41.449]                   options(future.plan = NULL)
[16:20:41.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.449]                 }
[16:20:41.449]                 ...future.workdir <- getwd()
[16:20:41.449]             }
[16:20:41.449]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.449]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.449]         }
[16:20:41.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.449]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.449]             base::names(...future.oldOptions))
[16:20:41.449]     }
[16:20:41.449]     if (FALSE) {
[16:20:41.449]     }
[16:20:41.449]     else {
[16:20:41.449]         if (TRUE) {
[16:20:41.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.449]                 open = "w")
[16:20:41.449]         }
[16:20:41.449]         else {
[16:20:41.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.449]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.449]         }
[16:20:41.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.449]             base::sink(type = "output", split = FALSE)
[16:20:41.449]             base::close(...future.stdout)
[16:20:41.449]         }, add = TRUE)
[16:20:41.449]     }
[16:20:41.449]     ...future.frame <- base::sys.nframe()
[16:20:41.449]     ...future.conditions <- base::list()
[16:20:41.449]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.449]     if (FALSE) {
[16:20:41.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.449]     }
[16:20:41.449]     ...future.result <- base::tryCatch({
[16:20:41.449]         base::withCallingHandlers({
[16:20:41.449]             ...future.value <- base::withVisible(base::local({
[16:20:41.449]                 4
[16:20:41.449]             }))
[16:20:41.449]             future::FutureResult(value = ...future.value$value, 
[16:20:41.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.449]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.449]                     ...future.globalenv.names))
[16:20:41.449]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.449]         }, condition = base::local({
[16:20:41.449]             c <- base::c
[16:20:41.449]             inherits <- base::inherits
[16:20:41.449]             invokeRestart <- base::invokeRestart
[16:20:41.449]             length <- base::length
[16:20:41.449]             list <- base::list
[16:20:41.449]             seq.int <- base::seq.int
[16:20:41.449]             signalCondition <- base::signalCondition
[16:20:41.449]             sys.calls <- base::sys.calls
[16:20:41.449]             `[[` <- base::`[[`
[16:20:41.449]             `+` <- base::`+`
[16:20:41.449]             `<<-` <- base::`<<-`
[16:20:41.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.449]                   3L)]
[16:20:41.449]             }
[16:20:41.449]             function(cond) {
[16:20:41.449]                 is_error <- inherits(cond, "error")
[16:20:41.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.449]                   NULL)
[16:20:41.449]                 if (is_error) {
[16:20:41.449]                   sessionInformation <- function() {
[16:20:41.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.449]                       search = base::search(), system = base::Sys.info())
[16:20:41.449]                   }
[16:20:41.449]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.449]                     cond$call), session = sessionInformation(), 
[16:20:41.449]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.449]                   signalCondition(cond)
[16:20:41.449]                 }
[16:20:41.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.449]                 "immediateCondition"))) {
[16:20:41.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.449]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.449]                   if (TRUE && !signal) {
[16:20:41.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.449]                     {
[16:20:41.449]                       inherits <- base::inherits
[16:20:41.449]                       invokeRestart <- base::invokeRestart
[16:20:41.449]                       is.null <- base::is.null
[16:20:41.449]                       muffled <- FALSE
[16:20:41.449]                       if (inherits(cond, "message")) {
[16:20:41.449]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.449]                         if (muffled) 
[16:20:41.449]                           invokeRestart("muffleMessage")
[16:20:41.449]                       }
[16:20:41.449]                       else if (inherits(cond, "warning")) {
[16:20:41.449]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.449]                         if (muffled) 
[16:20:41.449]                           invokeRestart("muffleWarning")
[16:20:41.449]                       }
[16:20:41.449]                       else if (inherits(cond, "condition")) {
[16:20:41.449]                         if (!is.null(pattern)) {
[16:20:41.449]                           computeRestarts <- base::computeRestarts
[16:20:41.449]                           grepl <- base::grepl
[16:20:41.449]                           restarts <- computeRestarts(cond)
[16:20:41.449]                           for (restart in restarts) {
[16:20:41.449]                             name <- restart$name
[16:20:41.449]                             if (is.null(name)) 
[16:20:41.449]                               next
[16:20:41.449]                             if (!grepl(pattern, name)) 
[16:20:41.449]                               next
[16:20:41.449]                             invokeRestart(restart)
[16:20:41.449]                             muffled <- TRUE
[16:20:41.449]                             break
[16:20:41.449]                           }
[16:20:41.449]                         }
[16:20:41.449]                       }
[16:20:41.449]                       invisible(muffled)
[16:20:41.449]                     }
[16:20:41.449]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.449]                   }
[16:20:41.449]                 }
[16:20:41.449]                 else {
[16:20:41.449]                   if (TRUE) {
[16:20:41.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.449]                     {
[16:20:41.449]                       inherits <- base::inherits
[16:20:41.449]                       invokeRestart <- base::invokeRestart
[16:20:41.449]                       is.null <- base::is.null
[16:20:41.449]                       muffled <- FALSE
[16:20:41.449]                       if (inherits(cond, "message")) {
[16:20:41.449]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.449]                         if (muffled) 
[16:20:41.449]                           invokeRestart("muffleMessage")
[16:20:41.449]                       }
[16:20:41.449]                       else if (inherits(cond, "warning")) {
[16:20:41.449]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.449]                         if (muffled) 
[16:20:41.449]                           invokeRestart("muffleWarning")
[16:20:41.449]                       }
[16:20:41.449]                       else if (inherits(cond, "condition")) {
[16:20:41.449]                         if (!is.null(pattern)) {
[16:20:41.449]                           computeRestarts <- base::computeRestarts
[16:20:41.449]                           grepl <- base::grepl
[16:20:41.449]                           restarts <- computeRestarts(cond)
[16:20:41.449]                           for (restart in restarts) {
[16:20:41.449]                             name <- restart$name
[16:20:41.449]                             if (is.null(name)) 
[16:20:41.449]                               next
[16:20:41.449]                             if (!grepl(pattern, name)) 
[16:20:41.449]                               next
[16:20:41.449]                             invokeRestart(restart)
[16:20:41.449]                             muffled <- TRUE
[16:20:41.449]                             break
[16:20:41.449]                           }
[16:20:41.449]                         }
[16:20:41.449]                       }
[16:20:41.449]                       invisible(muffled)
[16:20:41.449]                     }
[16:20:41.449]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.449]                   }
[16:20:41.449]                 }
[16:20:41.449]             }
[16:20:41.449]         }))
[16:20:41.449]     }, error = function(ex) {
[16:20:41.449]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.449]                 ...future.rng), started = ...future.startTime, 
[16:20:41.449]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.449]             version = "1.8"), class = "FutureResult")
[16:20:41.449]     }, finally = {
[16:20:41.449]         if (!identical(...future.workdir, getwd())) 
[16:20:41.449]             setwd(...future.workdir)
[16:20:41.449]         {
[16:20:41.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.449]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.449]             }
[16:20:41.449]             base::options(...future.oldOptions)
[16:20:41.449]             if (.Platform$OS.type == "windows") {
[16:20:41.449]                 old_names <- names(...future.oldEnvVars)
[16:20:41.449]                 envs <- base::Sys.getenv()
[16:20:41.449]                 names <- names(envs)
[16:20:41.449]                 common <- intersect(names, old_names)
[16:20:41.449]                 added <- setdiff(names, old_names)
[16:20:41.449]                 removed <- setdiff(old_names, names)
[16:20:41.449]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.449]                   envs[common]]
[16:20:41.449]                 NAMES <- toupper(changed)
[16:20:41.449]                 args <- list()
[16:20:41.449]                 for (kk in seq_along(NAMES)) {
[16:20:41.449]                   name <- changed[[kk]]
[16:20:41.449]                   NAME <- NAMES[[kk]]
[16:20:41.449]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.449]                     next
[16:20:41.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.449]                 }
[16:20:41.449]                 NAMES <- toupper(added)
[16:20:41.449]                 for (kk in seq_along(NAMES)) {
[16:20:41.449]                   name <- added[[kk]]
[16:20:41.449]                   NAME <- NAMES[[kk]]
[16:20:41.449]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.449]                     next
[16:20:41.449]                   args[[name]] <- ""
[16:20:41.449]                 }
[16:20:41.449]                 NAMES <- toupper(removed)
[16:20:41.449]                 for (kk in seq_along(NAMES)) {
[16:20:41.449]                   name <- removed[[kk]]
[16:20:41.449]                   NAME <- NAMES[[kk]]
[16:20:41.449]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.449]                     next
[16:20:41.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.449]                 }
[16:20:41.449]                 if (length(args) > 0) 
[16:20:41.449]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.449]             }
[16:20:41.449]             else {
[16:20:41.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.449]             }
[16:20:41.449]             {
[16:20:41.449]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.449]                   0L) {
[16:20:41.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.449]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.449]                   base::options(opts)
[16:20:41.449]                 }
[16:20:41.449]                 {
[16:20:41.449]                   {
[16:20:41.449]                     NULL
[16:20:41.449]                     RNGkind("Mersenne-Twister")
[16:20:41.449]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.449]                       inherits = FALSE)
[16:20:41.449]                   }
[16:20:41.449]                   options(future.plan = NULL)
[16:20:41.449]                   if (is.na(NA_character_)) 
[16:20:41.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.449]                     .init = FALSE)
[16:20:41.449]                 }
[16:20:41.449]             }
[16:20:41.449]         }
[16:20:41.449]     })
[16:20:41.449]     if (TRUE) {
[16:20:41.449]         base::sink(type = "output", split = FALSE)
[16:20:41.449]         if (TRUE) {
[16:20:41.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.449]         }
[16:20:41.449]         else {
[16:20:41.449]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.449]         }
[16:20:41.449]         base::close(...future.stdout)
[16:20:41.449]         ...future.stdout <- NULL
[16:20:41.449]     }
[16:20:41.449]     ...future.result$conditions <- ...future.conditions
[16:20:41.449]     ...future.result$finished <- base::Sys.time()
[16:20:41.449]     ...future.result
[16:20:41.449] }
[16:20:41.451] plan(): Setting new future strategy stack:
[16:20:41.451] List of future strategies:
[16:20:41.451] 1. sequential:
[16:20:41.451]    - args: function (..., envir = parent.frame())
[16:20:41.451]    - tweaked: FALSE
[16:20:41.451]    - call: NULL
[16:20:41.452] plan(): nbrOfWorkers() = 1
[16:20:41.453] plan(): Setting new future strategy stack:
[16:20:41.453] List of future strategies:
[16:20:41.453] 1. sequential:
[16:20:41.453]    - args: function (..., envir = parent.frame())
[16:20:41.453]    - tweaked: FALSE
[16:20:41.453]    - call: plan(strategy)
[16:20:41.454] plan(): nbrOfWorkers() = 1
[16:20:41.454] SequentialFuture started (and completed)
[16:20:41.454] - Launch lazy future ... done
[16:20:41.454] run() for ‘SequentialFuture’ ... done
<environment: 0x55ed0a4eeca0> 
<environment: 0x55ed0ac44ed0> 
[16:20:41.455] resolved() for ‘SequentialFuture’ ...
[16:20:41.455] - state: ‘finished’
[16:20:41.456] - run: TRUE
[16:20:41.456] - result: ‘FutureResult’
[16:20:41.456] resolved() for ‘SequentialFuture’ ... done
[16:20:41.456] resolved() for ‘SequentialFuture’ ...
[16:20:41.456] - state: ‘finished’
[16:20:41.456] - run: TRUE
[16:20:41.456] - result: ‘FutureResult’
[16:20:41.456] resolved() for ‘SequentialFuture’ ... done
[16:20:41.456] resolved() for ‘SequentialFuture’ ...
[16:20:41.457] - state: ‘finished’
[16:20:41.457] - run: TRUE
[16:20:41.457] - result: ‘FutureResult’
[16:20:41.457] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:41.458] resolve() on environment ...
[16:20:41.458]  recursive: 0
[16:20:41.458]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:41.458] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.459] - nx: 4
[16:20:41.459] - relay: TRUE
[16:20:41.459] - stdout: TRUE
[16:20:41.459] - signal: TRUE
[16:20:41.459] - resignal: FALSE
[16:20:41.459] - force: TRUE
[16:20:41.459] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.459] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.459]  - until=2
[16:20:41.459]  - relaying element #2
[16:20:41.459] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.459] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.460] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.460]  length: 3 (resolved future 1)
[16:20:41.460] resolved() for ‘SequentialFuture’ ...
[16:20:41.460] - state: ‘finished’
[16:20:41.460] - run: TRUE
[16:20:41.460] - result: ‘FutureResult’
[16:20:41.460] resolved() for ‘SequentialFuture’ ... done
[16:20:41.460] Future #2
[16:20:41.460] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.460] - nx: 4
[16:20:41.461] - relay: TRUE
[16:20:41.461] - stdout: TRUE
[16:20:41.461] - signal: TRUE
[16:20:41.461] - resignal: FALSE
[16:20:41.461] - force: TRUE
[16:20:41.461] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:41.461] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:41.461]  - until=2
[16:20:41.461]  - relaying element #2
[16:20:41.461] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.461] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.462] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.462]  length: 2 (resolved future 2)
[16:20:41.462] resolved() for ‘SequentialFuture’ ...
[16:20:41.462] - state: ‘finished’
[16:20:41.462] - run: TRUE
[16:20:41.462] - result: ‘FutureResult’
[16:20:41.462] resolved() for ‘SequentialFuture’ ... done
[16:20:41.462] Future #3
[16:20:41.462] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.462] - nx: 4
[16:20:41.462] - relay: TRUE
[16:20:41.463] - stdout: TRUE
[16:20:41.463] - signal: TRUE
[16:20:41.463] - resignal: FALSE
[16:20:41.463] - force: TRUE
[16:20:41.463] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:41.463] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:41.463]  - until=3
[16:20:41.463]  - relaying element #3
[16:20:41.463] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.463] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.463] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.464]  length: 1 (resolved future 3)
[16:20:41.464] resolved() for ‘SequentialFuture’ ...
[16:20:41.464] - state: ‘finished’
[16:20:41.464] - run: TRUE
[16:20:41.464] - result: ‘FutureResult’
[16:20:41.464] resolved() for ‘SequentialFuture’ ... done
[16:20:41.464] Future #4
[16:20:41.464] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.464] - nx: 4
[16:20:41.464] - relay: TRUE
[16:20:41.465] - stdout: TRUE
[16:20:41.465] - signal: TRUE
[16:20:41.465] - resignal: FALSE
[16:20:41.465] - force: TRUE
[16:20:41.465] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:41.465] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:41.465]  - until=4
[16:20:41.465]  - relaying element #4
[16:20:41.465] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.465] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.465] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.465]  length: 0 (resolved future 4)
[16:20:41.466] Relaying remaining futures
[16:20:41.466] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.466] - nx: 4
[16:20:41.466] - relay: TRUE
[16:20:41.466] - stdout: TRUE
[16:20:41.466] - signal: TRUE
[16:20:41.466] - resignal: FALSE
[16:20:41.466] - force: TRUE
[16:20:41.466] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.466] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:41.466] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:41.466] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:41.467] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.467] resolve() on environment ... DONE
<environment: 0x55ed0ae16d70> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[16:20:41.467] plan(): Setting new future strategy stack:
[16:20:41.467] List of future strategies:
[16:20:41.467] 1. sequential:
[16:20:41.467]    - args: function (..., envir = parent.frame())
[16:20:41.467]    - tweaked: FALSE
[16:20:41.467]    - call: plan(strategy)
[16:20:41.468] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[16:20:41.468] getGlobalsAndPackages() ...
[16:20:41.468] Searching for globals...
[16:20:41.469] 
[16:20:41.469] Searching for globals ... DONE
[16:20:41.469] - globals: [0] <none>
[16:20:41.469] getGlobalsAndPackages() ... DONE
[16:20:41.469] run() for ‘Future’ ...
[16:20:41.469] - state: ‘created’
[16:20:41.469] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.470] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.470] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.470]   - Field: ‘label’
[16:20:41.470]   - Field: ‘local’
[16:20:41.470]   - Field: ‘owner’
[16:20:41.470]   - Field: ‘envir’
[16:20:41.470]   - Field: ‘packages’
[16:20:41.470]   - Field: ‘gc’
[16:20:41.470]   - Field: ‘conditions’
[16:20:41.470]   - Field: ‘expr’
[16:20:41.471]   - Field: ‘uuid’
[16:20:41.471]   - Field: ‘seed’
[16:20:41.471]   - Field: ‘version’
[16:20:41.471]   - Field: ‘result’
[16:20:41.471]   - Field: ‘asynchronous’
[16:20:41.471]   - Field: ‘calls’
[16:20:41.471]   - Field: ‘globals’
[16:20:41.471]   - Field: ‘stdout’
[16:20:41.471]   - Field: ‘earlySignal’
[16:20:41.471]   - Field: ‘lazy’
[16:20:41.471]   - Field: ‘state’
[16:20:41.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.472] - Launch lazy future ...
[16:20:41.472] Packages needed by the future expression (n = 0): <none>
[16:20:41.472] Packages needed by future strategies (n = 0): <none>
[16:20:41.472] {
[16:20:41.472]     {
[16:20:41.472]         {
[16:20:41.472]             ...future.startTime <- base::Sys.time()
[16:20:41.472]             {
[16:20:41.472]                 {
[16:20:41.472]                   {
[16:20:41.472]                     base::local({
[16:20:41.472]                       has_future <- base::requireNamespace("future", 
[16:20:41.472]                         quietly = TRUE)
[16:20:41.472]                       if (has_future) {
[16:20:41.472]                         ns <- base::getNamespace("future")
[16:20:41.472]                         version <- ns[[".package"]][["version"]]
[16:20:41.472]                         if (is.null(version)) 
[16:20:41.472]                           version <- utils::packageVersion("future")
[16:20:41.472]                       }
[16:20:41.472]                       else {
[16:20:41.472]                         version <- NULL
[16:20:41.472]                       }
[16:20:41.472]                       if (!has_future || version < "1.8.0") {
[16:20:41.472]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.472]                           "", base::R.version$version.string), 
[16:20:41.472]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.472]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.472]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.472]                             "release", "version")], collapse = " "), 
[16:20:41.472]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.472]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.472]                           info)
[16:20:41.472]                         info <- base::paste(info, collapse = "; ")
[16:20:41.472]                         if (!has_future) {
[16:20:41.472]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.472]                             info)
[16:20:41.472]                         }
[16:20:41.472]                         else {
[16:20:41.472]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.472]                             info, version)
[16:20:41.472]                         }
[16:20:41.472]                         base::stop(msg)
[16:20:41.472]                       }
[16:20:41.472]                     })
[16:20:41.472]                   }
[16:20:41.472]                   ...future.strategy.old <- future::plan("list")
[16:20:41.472]                   options(future.plan = NULL)
[16:20:41.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.472]                 }
[16:20:41.472]                 ...future.workdir <- getwd()
[16:20:41.472]             }
[16:20:41.472]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.472]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.472]         }
[16:20:41.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.472]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.472]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.472]             base::names(...future.oldOptions))
[16:20:41.472]     }
[16:20:41.472]     if (FALSE) {
[16:20:41.472]     }
[16:20:41.472]     else {
[16:20:41.472]         if (TRUE) {
[16:20:41.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.472]                 open = "w")
[16:20:41.472]         }
[16:20:41.472]         else {
[16:20:41.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.472]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.472]         }
[16:20:41.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.472]             base::sink(type = "output", split = FALSE)
[16:20:41.472]             base::close(...future.stdout)
[16:20:41.472]         }, add = TRUE)
[16:20:41.472]     }
[16:20:41.472]     ...future.frame <- base::sys.nframe()
[16:20:41.472]     ...future.conditions <- base::list()
[16:20:41.472]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.472]     if (FALSE) {
[16:20:41.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.472]     }
[16:20:41.472]     ...future.result <- base::tryCatch({
[16:20:41.472]         base::withCallingHandlers({
[16:20:41.472]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.472]             future::FutureResult(value = ...future.value$value, 
[16:20:41.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.472]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.472]                     ...future.globalenv.names))
[16:20:41.472]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.472]         }, condition = base::local({
[16:20:41.472]             c <- base::c
[16:20:41.472]             inherits <- base::inherits
[16:20:41.472]             invokeRestart <- base::invokeRestart
[16:20:41.472]             length <- base::length
[16:20:41.472]             list <- base::list
[16:20:41.472]             seq.int <- base::seq.int
[16:20:41.472]             signalCondition <- base::signalCondition
[16:20:41.472]             sys.calls <- base::sys.calls
[16:20:41.472]             `[[` <- base::`[[`
[16:20:41.472]             `+` <- base::`+`
[16:20:41.472]             `<<-` <- base::`<<-`
[16:20:41.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.472]                   3L)]
[16:20:41.472]             }
[16:20:41.472]             function(cond) {
[16:20:41.472]                 is_error <- inherits(cond, "error")
[16:20:41.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.472]                   NULL)
[16:20:41.472]                 if (is_error) {
[16:20:41.472]                   sessionInformation <- function() {
[16:20:41.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.472]                       search = base::search(), system = base::Sys.info())
[16:20:41.472]                   }
[16:20:41.472]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.472]                     cond$call), session = sessionInformation(), 
[16:20:41.472]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.472]                   signalCondition(cond)
[16:20:41.472]                 }
[16:20:41.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.472]                 "immediateCondition"))) {
[16:20:41.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.472]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.472]                   if (TRUE && !signal) {
[16:20:41.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.472]                     {
[16:20:41.472]                       inherits <- base::inherits
[16:20:41.472]                       invokeRestart <- base::invokeRestart
[16:20:41.472]                       is.null <- base::is.null
[16:20:41.472]                       muffled <- FALSE
[16:20:41.472]                       if (inherits(cond, "message")) {
[16:20:41.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.472]                         if (muffled) 
[16:20:41.472]                           invokeRestart("muffleMessage")
[16:20:41.472]                       }
[16:20:41.472]                       else if (inherits(cond, "warning")) {
[16:20:41.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.472]                         if (muffled) 
[16:20:41.472]                           invokeRestart("muffleWarning")
[16:20:41.472]                       }
[16:20:41.472]                       else if (inherits(cond, "condition")) {
[16:20:41.472]                         if (!is.null(pattern)) {
[16:20:41.472]                           computeRestarts <- base::computeRestarts
[16:20:41.472]                           grepl <- base::grepl
[16:20:41.472]                           restarts <- computeRestarts(cond)
[16:20:41.472]                           for (restart in restarts) {
[16:20:41.472]                             name <- restart$name
[16:20:41.472]                             if (is.null(name)) 
[16:20:41.472]                               next
[16:20:41.472]                             if (!grepl(pattern, name)) 
[16:20:41.472]                               next
[16:20:41.472]                             invokeRestart(restart)
[16:20:41.472]                             muffled <- TRUE
[16:20:41.472]                             break
[16:20:41.472]                           }
[16:20:41.472]                         }
[16:20:41.472]                       }
[16:20:41.472]                       invisible(muffled)
[16:20:41.472]                     }
[16:20:41.472]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.472]                   }
[16:20:41.472]                 }
[16:20:41.472]                 else {
[16:20:41.472]                   if (TRUE) {
[16:20:41.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.472]                     {
[16:20:41.472]                       inherits <- base::inherits
[16:20:41.472]                       invokeRestart <- base::invokeRestart
[16:20:41.472]                       is.null <- base::is.null
[16:20:41.472]                       muffled <- FALSE
[16:20:41.472]                       if (inherits(cond, "message")) {
[16:20:41.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.472]                         if (muffled) 
[16:20:41.472]                           invokeRestart("muffleMessage")
[16:20:41.472]                       }
[16:20:41.472]                       else if (inherits(cond, "warning")) {
[16:20:41.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.472]                         if (muffled) 
[16:20:41.472]                           invokeRestart("muffleWarning")
[16:20:41.472]                       }
[16:20:41.472]                       else if (inherits(cond, "condition")) {
[16:20:41.472]                         if (!is.null(pattern)) {
[16:20:41.472]                           computeRestarts <- base::computeRestarts
[16:20:41.472]                           grepl <- base::grepl
[16:20:41.472]                           restarts <- computeRestarts(cond)
[16:20:41.472]                           for (restart in restarts) {
[16:20:41.472]                             name <- restart$name
[16:20:41.472]                             if (is.null(name)) 
[16:20:41.472]                               next
[16:20:41.472]                             if (!grepl(pattern, name)) 
[16:20:41.472]                               next
[16:20:41.472]                             invokeRestart(restart)
[16:20:41.472]                             muffled <- TRUE
[16:20:41.472]                             break
[16:20:41.472]                           }
[16:20:41.472]                         }
[16:20:41.472]                       }
[16:20:41.472]                       invisible(muffled)
[16:20:41.472]                     }
[16:20:41.472]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.472]                   }
[16:20:41.472]                 }
[16:20:41.472]             }
[16:20:41.472]         }))
[16:20:41.472]     }, error = function(ex) {
[16:20:41.472]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.472]                 ...future.rng), started = ...future.startTime, 
[16:20:41.472]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.472]             version = "1.8"), class = "FutureResult")
[16:20:41.472]     }, finally = {
[16:20:41.472]         if (!identical(...future.workdir, getwd())) 
[16:20:41.472]             setwd(...future.workdir)
[16:20:41.472]         {
[16:20:41.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.472]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.472]             }
[16:20:41.472]             base::options(...future.oldOptions)
[16:20:41.472]             if (.Platform$OS.type == "windows") {
[16:20:41.472]                 old_names <- names(...future.oldEnvVars)
[16:20:41.472]                 envs <- base::Sys.getenv()
[16:20:41.472]                 names <- names(envs)
[16:20:41.472]                 common <- intersect(names, old_names)
[16:20:41.472]                 added <- setdiff(names, old_names)
[16:20:41.472]                 removed <- setdiff(old_names, names)
[16:20:41.472]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.472]                   envs[common]]
[16:20:41.472]                 NAMES <- toupper(changed)
[16:20:41.472]                 args <- list()
[16:20:41.472]                 for (kk in seq_along(NAMES)) {
[16:20:41.472]                   name <- changed[[kk]]
[16:20:41.472]                   NAME <- NAMES[[kk]]
[16:20:41.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.472]                     next
[16:20:41.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.472]                 }
[16:20:41.472]                 NAMES <- toupper(added)
[16:20:41.472]                 for (kk in seq_along(NAMES)) {
[16:20:41.472]                   name <- added[[kk]]
[16:20:41.472]                   NAME <- NAMES[[kk]]
[16:20:41.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.472]                     next
[16:20:41.472]                   args[[name]] <- ""
[16:20:41.472]                 }
[16:20:41.472]                 NAMES <- toupper(removed)
[16:20:41.472]                 for (kk in seq_along(NAMES)) {
[16:20:41.472]                   name <- removed[[kk]]
[16:20:41.472]                   NAME <- NAMES[[kk]]
[16:20:41.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.472]                     next
[16:20:41.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.472]                 }
[16:20:41.472]                 if (length(args) > 0) 
[16:20:41.472]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.472]             }
[16:20:41.472]             else {
[16:20:41.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.472]             }
[16:20:41.472]             {
[16:20:41.472]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.472]                   0L) {
[16:20:41.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.472]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.472]                   base::options(opts)
[16:20:41.472]                 }
[16:20:41.472]                 {
[16:20:41.472]                   {
[16:20:41.472]                     NULL
[16:20:41.472]                     RNGkind("Mersenne-Twister")
[16:20:41.472]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.472]                       inherits = FALSE)
[16:20:41.472]                   }
[16:20:41.472]                   options(future.plan = NULL)
[16:20:41.472]                   if (is.na(NA_character_)) 
[16:20:41.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.472]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.472]                     .init = FALSE)
[16:20:41.472]                 }
[16:20:41.472]             }
[16:20:41.472]         }
[16:20:41.472]     })
[16:20:41.472]     if (TRUE) {
[16:20:41.472]         base::sink(type = "output", split = FALSE)
[16:20:41.472]         if (TRUE) {
[16:20:41.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.472]         }
[16:20:41.472]         else {
[16:20:41.472]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.472]         }
[16:20:41.472]         base::close(...future.stdout)
[16:20:41.472]         ...future.stdout <- NULL
[16:20:41.472]     }
[16:20:41.472]     ...future.result$conditions <- ...future.conditions
[16:20:41.472]     ...future.result$finished <- base::Sys.time()
[16:20:41.472]     ...future.result
[16:20:41.472] }
[16:20:41.474] plan(): Setting new future strategy stack:
[16:20:41.474] List of future strategies:
[16:20:41.474] 1. sequential:
[16:20:41.474]    - args: function (..., envir = parent.frame())
[16:20:41.474]    - tweaked: FALSE
[16:20:41.474]    - call: NULL
[16:20:41.475] plan(): nbrOfWorkers() = 1
[16:20:41.475] plan(): Setting new future strategy stack:
[16:20:41.475] List of future strategies:
[16:20:41.475] 1. sequential:
[16:20:41.475]    - args: function (..., envir = parent.frame())
[16:20:41.475]    - tweaked: FALSE
[16:20:41.475]    - call: plan(strategy)
[16:20:41.476] plan(): nbrOfWorkers() = 1
[16:20:41.476] SequentialFuture started (and completed)
[16:20:41.476] - Launch lazy future ... done
[16:20:41.476] run() for ‘SequentialFuture’ ... done
[16:20:41.476] getGlobalsAndPackages() ...
[16:20:41.476] Searching for globals...
[16:20:41.478] 
[16:20:41.478] Searching for globals ... DONE
[16:20:41.479] - globals: [0] <none>
[16:20:41.479] getGlobalsAndPackages() ... DONE
[16:20:41.479] run() for ‘Future’ ...
[16:20:41.479] - state: ‘created’
[16:20:41.479] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.479] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.479] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.480]   - Field: ‘label’
[16:20:41.480]   - Field: ‘local’
[16:20:41.480]   - Field: ‘owner’
[16:20:41.480]   - Field: ‘envir’
[16:20:41.480]   - Field: ‘packages’
[16:20:41.480]   - Field: ‘gc’
[16:20:41.480]   - Field: ‘conditions’
[16:20:41.480]   - Field: ‘expr’
[16:20:41.480]   - Field: ‘uuid’
[16:20:41.480]   - Field: ‘seed’
[16:20:41.480]   - Field: ‘version’
[16:20:41.481]   - Field: ‘result’
[16:20:41.481]   - Field: ‘asynchronous’
[16:20:41.481]   - Field: ‘calls’
[16:20:41.481]   - Field: ‘globals’
[16:20:41.481]   - Field: ‘stdout’
[16:20:41.481]   - Field: ‘earlySignal’
[16:20:41.481]   - Field: ‘lazy’
[16:20:41.481]   - Field: ‘state’
[16:20:41.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.481] - Launch lazy future ...
[16:20:41.482] Packages needed by the future expression (n = 0): <none>
[16:20:41.482] Packages needed by future strategies (n = 0): <none>
[16:20:41.482] {
[16:20:41.482]     {
[16:20:41.482]         {
[16:20:41.482]             ...future.startTime <- base::Sys.time()
[16:20:41.482]             {
[16:20:41.482]                 {
[16:20:41.482]                   {
[16:20:41.482]                     base::local({
[16:20:41.482]                       has_future <- base::requireNamespace("future", 
[16:20:41.482]                         quietly = TRUE)
[16:20:41.482]                       if (has_future) {
[16:20:41.482]                         ns <- base::getNamespace("future")
[16:20:41.482]                         version <- ns[[".package"]][["version"]]
[16:20:41.482]                         if (is.null(version)) 
[16:20:41.482]                           version <- utils::packageVersion("future")
[16:20:41.482]                       }
[16:20:41.482]                       else {
[16:20:41.482]                         version <- NULL
[16:20:41.482]                       }
[16:20:41.482]                       if (!has_future || version < "1.8.0") {
[16:20:41.482]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.482]                           "", base::R.version$version.string), 
[16:20:41.482]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.482]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.482]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.482]                             "release", "version")], collapse = " "), 
[16:20:41.482]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.482]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.482]                           info)
[16:20:41.482]                         info <- base::paste(info, collapse = "; ")
[16:20:41.482]                         if (!has_future) {
[16:20:41.482]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.482]                             info)
[16:20:41.482]                         }
[16:20:41.482]                         else {
[16:20:41.482]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.482]                             info, version)
[16:20:41.482]                         }
[16:20:41.482]                         base::stop(msg)
[16:20:41.482]                       }
[16:20:41.482]                     })
[16:20:41.482]                   }
[16:20:41.482]                   ...future.strategy.old <- future::plan("list")
[16:20:41.482]                   options(future.plan = NULL)
[16:20:41.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.482]                 }
[16:20:41.482]                 ...future.workdir <- getwd()
[16:20:41.482]             }
[16:20:41.482]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.482]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.482]         }
[16:20:41.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.482]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.482]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.482]             base::names(...future.oldOptions))
[16:20:41.482]     }
[16:20:41.482]     if (FALSE) {
[16:20:41.482]     }
[16:20:41.482]     else {
[16:20:41.482]         if (TRUE) {
[16:20:41.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.482]                 open = "w")
[16:20:41.482]         }
[16:20:41.482]         else {
[16:20:41.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.482]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.482]         }
[16:20:41.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.482]             base::sink(type = "output", split = FALSE)
[16:20:41.482]             base::close(...future.stdout)
[16:20:41.482]         }, add = TRUE)
[16:20:41.482]     }
[16:20:41.482]     ...future.frame <- base::sys.nframe()
[16:20:41.482]     ...future.conditions <- base::list()
[16:20:41.482]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.482]     if (FALSE) {
[16:20:41.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.482]     }
[16:20:41.482]     ...future.result <- base::tryCatch({
[16:20:41.482]         base::withCallingHandlers({
[16:20:41.482]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.482]             future::FutureResult(value = ...future.value$value, 
[16:20:41.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.482]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.482]                     ...future.globalenv.names))
[16:20:41.482]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.482]         }, condition = base::local({
[16:20:41.482]             c <- base::c
[16:20:41.482]             inherits <- base::inherits
[16:20:41.482]             invokeRestart <- base::invokeRestart
[16:20:41.482]             length <- base::length
[16:20:41.482]             list <- base::list
[16:20:41.482]             seq.int <- base::seq.int
[16:20:41.482]             signalCondition <- base::signalCondition
[16:20:41.482]             sys.calls <- base::sys.calls
[16:20:41.482]             `[[` <- base::`[[`
[16:20:41.482]             `+` <- base::`+`
[16:20:41.482]             `<<-` <- base::`<<-`
[16:20:41.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.482]                   3L)]
[16:20:41.482]             }
[16:20:41.482]             function(cond) {
[16:20:41.482]                 is_error <- inherits(cond, "error")
[16:20:41.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.482]                   NULL)
[16:20:41.482]                 if (is_error) {
[16:20:41.482]                   sessionInformation <- function() {
[16:20:41.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.482]                       search = base::search(), system = base::Sys.info())
[16:20:41.482]                   }
[16:20:41.482]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.482]                     cond$call), session = sessionInformation(), 
[16:20:41.482]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.482]                   signalCondition(cond)
[16:20:41.482]                 }
[16:20:41.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.482]                 "immediateCondition"))) {
[16:20:41.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.482]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.482]                   if (TRUE && !signal) {
[16:20:41.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.482]                     {
[16:20:41.482]                       inherits <- base::inherits
[16:20:41.482]                       invokeRestart <- base::invokeRestart
[16:20:41.482]                       is.null <- base::is.null
[16:20:41.482]                       muffled <- FALSE
[16:20:41.482]                       if (inherits(cond, "message")) {
[16:20:41.482]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.482]                         if (muffled) 
[16:20:41.482]                           invokeRestart("muffleMessage")
[16:20:41.482]                       }
[16:20:41.482]                       else if (inherits(cond, "warning")) {
[16:20:41.482]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.482]                         if (muffled) 
[16:20:41.482]                           invokeRestart("muffleWarning")
[16:20:41.482]                       }
[16:20:41.482]                       else if (inherits(cond, "condition")) {
[16:20:41.482]                         if (!is.null(pattern)) {
[16:20:41.482]                           computeRestarts <- base::computeRestarts
[16:20:41.482]                           grepl <- base::grepl
[16:20:41.482]                           restarts <- computeRestarts(cond)
[16:20:41.482]                           for (restart in restarts) {
[16:20:41.482]                             name <- restart$name
[16:20:41.482]                             if (is.null(name)) 
[16:20:41.482]                               next
[16:20:41.482]                             if (!grepl(pattern, name)) 
[16:20:41.482]                               next
[16:20:41.482]                             invokeRestart(restart)
[16:20:41.482]                             muffled <- TRUE
[16:20:41.482]                             break
[16:20:41.482]                           }
[16:20:41.482]                         }
[16:20:41.482]                       }
[16:20:41.482]                       invisible(muffled)
[16:20:41.482]                     }
[16:20:41.482]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.482]                   }
[16:20:41.482]                 }
[16:20:41.482]                 else {
[16:20:41.482]                   if (TRUE) {
[16:20:41.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.482]                     {
[16:20:41.482]                       inherits <- base::inherits
[16:20:41.482]                       invokeRestart <- base::invokeRestart
[16:20:41.482]                       is.null <- base::is.null
[16:20:41.482]                       muffled <- FALSE
[16:20:41.482]                       if (inherits(cond, "message")) {
[16:20:41.482]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.482]                         if (muffled) 
[16:20:41.482]                           invokeRestart("muffleMessage")
[16:20:41.482]                       }
[16:20:41.482]                       else if (inherits(cond, "warning")) {
[16:20:41.482]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.482]                         if (muffled) 
[16:20:41.482]                           invokeRestart("muffleWarning")
[16:20:41.482]                       }
[16:20:41.482]                       else if (inherits(cond, "condition")) {
[16:20:41.482]                         if (!is.null(pattern)) {
[16:20:41.482]                           computeRestarts <- base::computeRestarts
[16:20:41.482]                           grepl <- base::grepl
[16:20:41.482]                           restarts <- computeRestarts(cond)
[16:20:41.482]                           for (restart in restarts) {
[16:20:41.482]                             name <- restart$name
[16:20:41.482]                             if (is.null(name)) 
[16:20:41.482]                               next
[16:20:41.482]                             if (!grepl(pattern, name)) 
[16:20:41.482]                               next
[16:20:41.482]                             invokeRestart(restart)
[16:20:41.482]                             muffled <- TRUE
[16:20:41.482]                             break
[16:20:41.482]                           }
[16:20:41.482]                         }
[16:20:41.482]                       }
[16:20:41.482]                       invisible(muffled)
[16:20:41.482]                     }
[16:20:41.482]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.482]                   }
[16:20:41.482]                 }
[16:20:41.482]             }
[16:20:41.482]         }))
[16:20:41.482]     }, error = function(ex) {
[16:20:41.482]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.482]                 ...future.rng), started = ...future.startTime, 
[16:20:41.482]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.482]             version = "1.8"), class = "FutureResult")
[16:20:41.482]     }, finally = {
[16:20:41.482]         if (!identical(...future.workdir, getwd())) 
[16:20:41.482]             setwd(...future.workdir)
[16:20:41.482]         {
[16:20:41.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.482]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.482]             }
[16:20:41.482]             base::options(...future.oldOptions)
[16:20:41.482]             if (.Platform$OS.type == "windows") {
[16:20:41.482]                 old_names <- names(...future.oldEnvVars)
[16:20:41.482]                 envs <- base::Sys.getenv()
[16:20:41.482]                 names <- names(envs)
[16:20:41.482]                 common <- intersect(names, old_names)
[16:20:41.482]                 added <- setdiff(names, old_names)
[16:20:41.482]                 removed <- setdiff(old_names, names)
[16:20:41.482]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.482]                   envs[common]]
[16:20:41.482]                 NAMES <- toupper(changed)
[16:20:41.482]                 args <- list()
[16:20:41.482]                 for (kk in seq_along(NAMES)) {
[16:20:41.482]                   name <- changed[[kk]]
[16:20:41.482]                   NAME <- NAMES[[kk]]
[16:20:41.482]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.482]                     next
[16:20:41.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.482]                 }
[16:20:41.482]                 NAMES <- toupper(added)
[16:20:41.482]                 for (kk in seq_along(NAMES)) {
[16:20:41.482]                   name <- added[[kk]]
[16:20:41.482]                   NAME <- NAMES[[kk]]
[16:20:41.482]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.482]                     next
[16:20:41.482]                   args[[name]] <- ""
[16:20:41.482]                 }
[16:20:41.482]                 NAMES <- toupper(removed)
[16:20:41.482]                 for (kk in seq_along(NAMES)) {
[16:20:41.482]                   name <- removed[[kk]]
[16:20:41.482]                   NAME <- NAMES[[kk]]
[16:20:41.482]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.482]                     next
[16:20:41.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.482]                 }
[16:20:41.482]                 if (length(args) > 0) 
[16:20:41.482]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.482]             }
[16:20:41.482]             else {
[16:20:41.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.482]             }
[16:20:41.482]             {
[16:20:41.482]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.482]                   0L) {
[16:20:41.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.482]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.482]                   base::options(opts)
[16:20:41.482]                 }
[16:20:41.482]                 {
[16:20:41.482]                   {
[16:20:41.482]                     NULL
[16:20:41.482]                     RNGkind("Mersenne-Twister")
[16:20:41.482]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.482]                       inherits = FALSE)
[16:20:41.482]                   }
[16:20:41.482]                   options(future.plan = NULL)
[16:20:41.482]                   if (is.na(NA_character_)) 
[16:20:41.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.482]                     .init = FALSE)
[16:20:41.482]                 }
[16:20:41.482]             }
[16:20:41.482]         }
[16:20:41.482]     })
[16:20:41.482]     if (TRUE) {
[16:20:41.482]         base::sink(type = "output", split = FALSE)
[16:20:41.482]         if (TRUE) {
[16:20:41.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.482]         }
[16:20:41.482]         else {
[16:20:41.482]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.482]         }
[16:20:41.482]         base::close(...future.stdout)
[16:20:41.482]         ...future.stdout <- NULL
[16:20:41.482]     }
[16:20:41.482]     ...future.result$conditions <- ...future.conditions
[16:20:41.482]     ...future.result$finished <- base::Sys.time()
[16:20:41.482]     ...future.result
[16:20:41.482] }
[16:20:41.484] plan(): Setting new future strategy stack:
[16:20:41.484] List of future strategies:
[16:20:41.484] 1. sequential:
[16:20:41.484]    - args: function (..., envir = parent.frame())
[16:20:41.484]    - tweaked: FALSE
[16:20:41.484]    - call: NULL
[16:20:41.484] plan(): nbrOfWorkers() = 1
[16:20:41.485] plan(): Setting new future strategy stack:
[16:20:41.485] List of future strategies:
[16:20:41.485] 1. sequential:
[16:20:41.485]    - args: function (..., envir = parent.frame())
[16:20:41.485]    - tweaked: FALSE
[16:20:41.485]    - call: plan(strategy)
[16:20:41.485] plan(): nbrOfWorkers() = 1
[16:20:41.486] SequentialFuture started (and completed)
[16:20:41.486] - Launch lazy future ... done
[16:20:41.486] run() for ‘SequentialFuture’ ... done
[16:20:41.486] getGlobalsAndPackages() ...
[16:20:41.486] Searching for globals...
[16:20:41.487] - globals found: [1] ‘{’
[16:20:41.487] Searching for globals ... DONE
[16:20:41.487] Resolving globals: FALSE
[16:20:41.487] 
[16:20:41.488] 
[16:20:41.488] getGlobalsAndPackages() ... DONE
[16:20:41.488] run() for ‘Future’ ...
[16:20:41.488] - state: ‘created’
[16:20:41.488] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.488] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.488] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.489]   - Field: ‘label’
[16:20:41.489]   - Field: ‘local’
[16:20:41.489]   - Field: ‘owner’
[16:20:41.489]   - Field: ‘envir’
[16:20:41.489]   - Field: ‘packages’
[16:20:41.489]   - Field: ‘gc’
[16:20:41.489]   - Field: ‘conditions’
[16:20:41.489]   - Field: ‘expr’
[16:20:41.489]   - Field: ‘uuid’
[16:20:41.489]   - Field: ‘seed’
[16:20:41.489]   - Field: ‘version’
[16:20:41.490]   - Field: ‘result’
[16:20:41.490]   - Field: ‘asynchronous’
[16:20:41.490]   - Field: ‘calls’
[16:20:41.490]   - Field: ‘globals’
[16:20:41.490]   - Field: ‘stdout’
[16:20:41.490]   - Field: ‘earlySignal’
[16:20:41.490]   - Field: ‘lazy’
[16:20:41.490]   - Field: ‘state’
[16:20:41.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.490] - Launch lazy future ...
[16:20:41.490] Packages needed by the future expression (n = 0): <none>
[16:20:41.491] Packages needed by future strategies (n = 0): <none>
[16:20:41.491] {
[16:20:41.491]     {
[16:20:41.491]         {
[16:20:41.491]             ...future.startTime <- base::Sys.time()
[16:20:41.491]             {
[16:20:41.491]                 {
[16:20:41.491]                   {
[16:20:41.491]                     base::local({
[16:20:41.491]                       has_future <- base::requireNamespace("future", 
[16:20:41.491]                         quietly = TRUE)
[16:20:41.491]                       if (has_future) {
[16:20:41.491]                         ns <- base::getNamespace("future")
[16:20:41.491]                         version <- ns[[".package"]][["version"]]
[16:20:41.491]                         if (is.null(version)) 
[16:20:41.491]                           version <- utils::packageVersion("future")
[16:20:41.491]                       }
[16:20:41.491]                       else {
[16:20:41.491]                         version <- NULL
[16:20:41.491]                       }
[16:20:41.491]                       if (!has_future || version < "1.8.0") {
[16:20:41.491]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.491]                           "", base::R.version$version.string), 
[16:20:41.491]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.491]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.491]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.491]                             "release", "version")], collapse = " "), 
[16:20:41.491]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.491]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.491]                           info)
[16:20:41.491]                         info <- base::paste(info, collapse = "; ")
[16:20:41.491]                         if (!has_future) {
[16:20:41.491]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.491]                             info)
[16:20:41.491]                         }
[16:20:41.491]                         else {
[16:20:41.491]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.491]                             info, version)
[16:20:41.491]                         }
[16:20:41.491]                         base::stop(msg)
[16:20:41.491]                       }
[16:20:41.491]                     })
[16:20:41.491]                   }
[16:20:41.491]                   ...future.strategy.old <- future::plan("list")
[16:20:41.491]                   options(future.plan = NULL)
[16:20:41.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.491]                 }
[16:20:41.491]                 ...future.workdir <- getwd()
[16:20:41.491]             }
[16:20:41.491]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.491]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.491]         }
[16:20:41.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.491]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.491]             base::names(...future.oldOptions))
[16:20:41.491]     }
[16:20:41.491]     if (FALSE) {
[16:20:41.491]     }
[16:20:41.491]     else {
[16:20:41.491]         if (TRUE) {
[16:20:41.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.491]                 open = "w")
[16:20:41.491]         }
[16:20:41.491]         else {
[16:20:41.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.491]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.491]         }
[16:20:41.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.491]             base::sink(type = "output", split = FALSE)
[16:20:41.491]             base::close(...future.stdout)
[16:20:41.491]         }, add = TRUE)
[16:20:41.491]     }
[16:20:41.491]     ...future.frame <- base::sys.nframe()
[16:20:41.491]     ...future.conditions <- base::list()
[16:20:41.491]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.491]     if (FALSE) {
[16:20:41.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.491]     }
[16:20:41.491]     ...future.result <- base::tryCatch({
[16:20:41.491]         base::withCallingHandlers({
[16:20:41.491]             ...future.value <- base::withVisible(base::local({
[16:20:41.491]                 4
[16:20:41.491]             }))
[16:20:41.491]             future::FutureResult(value = ...future.value$value, 
[16:20:41.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.491]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.491]                     ...future.globalenv.names))
[16:20:41.491]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.491]         }, condition = base::local({
[16:20:41.491]             c <- base::c
[16:20:41.491]             inherits <- base::inherits
[16:20:41.491]             invokeRestart <- base::invokeRestart
[16:20:41.491]             length <- base::length
[16:20:41.491]             list <- base::list
[16:20:41.491]             seq.int <- base::seq.int
[16:20:41.491]             signalCondition <- base::signalCondition
[16:20:41.491]             sys.calls <- base::sys.calls
[16:20:41.491]             `[[` <- base::`[[`
[16:20:41.491]             `+` <- base::`+`
[16:20:41.491]             `<<-` <- base::`<<-`
[16:20:41.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.491]                   3L)]
[16:20:41.491]             }
[16:20:41.491]             function(cond) {
[16:20:41.491]                 is_error <- inherits(cond, "error")
[16:20:41.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.491]                   NULL)
[16:20:41.491]                 if (is_error) {
[16:20:41.491]                   sessionInformation <- function() {
[16:20:41.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.491]                       search = base::search(), system = base::Sys.info())
[16:20:41.491]                   }
[16:20:41.491]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.491]                     cond$call), session = sessionInformation(), 
[16:20:41.491]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.491]                   signalCondition(cond)
[16:20:41.491]                 }
[16:20:41.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.491]                 "immediateCondition"))) {
[16:20:41.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.491]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.491]                   if (TRUE && !signal) {
[16:20:41.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.491]                     {
[16:20:41.491]                       inherits <- base::inherits
[16:20:41.491]                       invokeRestart <- base::invokeRestart
[16:20:41.491]                       is.null <- base::is.null
[16:20:41.491]                       muffled <- FALSE
[16:20:41.491]                       if (inherits(cond, "message")) {
[16:20:41.491]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.491]                         if (muffled) 
[16:20:41.491]                           invokeRestart("muffleMessage")
[16:20:41.491]                       }
[16:20:41.491]                       else if (inherits(cond, "warning")) {
[16:20:41.491]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.491]                         if (muffled) 
[16:20:41.491]                           invokeRestart("muffleWarning")
[16:20:41.491]                       }
[16:20:41.491]                       else if (inherits(cond, "condition")) {
[16:20:41.491]                         if (!is.null(pattern)) {
[16:20:41.491]                           computeRestarts <- base::computeRestarts
[16:20:41.491]                           grepl <- base::grepl
[16:20:41.491]                           restarts <- computeRestarts(cond)
[16:20:41.491]                           for (restart in restarts) {
[16:20:41.491]                             name <- restart$name
[16:20:41.491]                             if (is.null(name)) 
[16:20:41.491]                               next
[16:20:41.491]                             if (!grepl(pattern, name)) 
[16:20:41.491]                               next
[16:20:41.491]                             invokeRestart(restart)
[16:20:41.491]                             muffled <- TRUE
[16:20:41.491]                             break
[16:20:41.491]                           }
[16:20:41.491]                         }
[16:20:41.491]                       }
[16:20:41.491]                       invisible(muffled)
[16:20:41.491]                     }
[16:20:41.491]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.491]                   }
[16:20:41.491]                 }
[16:20:41.491]                 else {
[16:20:41.491]                   if (TRUE) {
[16:20:41.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.491]                     {
[16:20:41.491]                       inherits <- base::inherits
[16:20:41.491]                       invokeRestart <- base::invokeRestart
[16:20:41.491]                       is.null <- base::is.null
[16:20:41.491]                       muffled <- FALSE
[16:20:41.491]                       if (inherits(cond, "message")) {
[16:20:41.491]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.491]                         if (muffled) 
[16:20:41.491]                           invokeRestart("muffleMessage")
[16:20:41.491]                       }
[16:20:41.491]                       else if (inherits(cond, "warning")) {
[16:20:41.491]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.491]                         if (muffled) 
[16:20:41.491]                           invokeRestart("muffleWarning")
[16:20:41.491]                       }
[16:20:41.491]                       else if (inherits(cond, "condition")) {
[16:20:41.491]                         if (!is.null(pattern)) {
[16:20:41.491]                           computeRestarts <- base::computeRestarts
[16:20:41.491]                           grepl <- base::grepl
[16:20:41.491]                           restarts <- computeRestarts(cond)
[16:20:41.491]                           for (restart in restarts) {
[16:20:41.491]                             name <- restart$name
[16:20:41.491]                             if (is.null(name)) 
[16:20:41.491]                               next
[16:20:41.491]                             if (!grepl(pattern, name)) 
[16:20:41.491]                               next
[16:20:41.491]                             invokeRestart(restart)
[16:20:41.491]                             muffled <- TRUE
[16:20:41.491]                             break
[16:20:41.491]                           }
[16:20:41.491]                         }
[16:20:41.491]                       }
[16:20:41.491]                       invisible(muffled)
[16:20:41.491]                     }
[16:20:41.491]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.491]                   }
[16:20:41.491]                 }
[16:20:41.491]             }
[16:20:41.491]         }))
[16:20:41.491]     }, error = function(ex) {
[16:20:41.491]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.491]                 ...future.rng), started = ...future.startTime, 
[16:20:41.491]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.491]             version = "1.8"), class = "FutureResult")
[16:20:41.491]     }, finally = {
[16:20:41.491]         if (!identical(...future.workdir, getwd())) 
[16:20:41.491]             setwd(...future.workdir)
[16:20:41.491]         {
[16:20:41.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.491]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.491]             }
[16:20:41.491]             base::options(...future.oldOptions)
[16:20:41.491]             if (.Platform$OS.type == "windows") {
[16:20:41.491]                 old_names <- names(...future.oldEnvVars)
[16:20:41.491]                 envs <- base::Sys.getenv()
[16:20:41.491]                 names <- names(envs)
[16:20:41.491]                 common <- intersect(names, old_names)
[16:20:41.491]                 added <- setdiff(names, old_names)
[16:20:41.491]                 removed <- setdiff(old_names, names)
[16:20:41.491]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.491]                   envs[common]]
[16:20:41.491]                 NAMES <- toupper(changed)
[16:20:41.491]                 args <- list()
[16:20:41.491]                 for (kk in seq_along(NAMES)) {
[16:20:41.491]                   name <- changed[[kk]]
[16:20:41.491]                   NAME <- NAMES[[kk]]
[16:20:41.491]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.491]                     next
[16:20:41.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.491]                 }
[16:20:41.491]                 NAMES <- toupper(added)
[16:20:41.491]                 for (kk in seq_along(NAMES)) {
[16:20:41.491]                   name <- added[[kk]]
[16:20:41.491]                   NAME <- NAMES[[kk]]
[16:20:41.491]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.491]                     next
[16:20:41.491]                   args[[name]] <- ""
[16:20:41.491]                 }
[16:20:41.491]                 NAMES <- toupper(removed)
[16:20:41.491]                 for (kk in seq_along(NAMES)) {
[16:20:41.491]                   name <- removed[[kk]]
[16:20:41.491]                   NAME <- NAMES[[kk]]
[16:20:41.491]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.491]                     next
[16:20:41.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.491]                 }
[16:20:41.491]                 if (length(args) > 0) 
[16:20:41.491]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.491]             }
[16:20:41.491]             else {
[16:20:41.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.491]             }
[16:20:41.491]             {
[16:20:41.491]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.491]                   0L) {
[16:20:41.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.491]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.491]                   base::options(opts)
[16:20:41.491]                 }
[16:20:41.491]                 {
[16:20:41.491]                   {
[16:20:41.491]                     NULL
[16:20:41.491]                     RNGkind("Mersenne-Twister")
[16:20:41.491]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.491]                       inherits = FALSE)
[16:20:41.491]                   }
[16:20:41.491]                   options(future.plan = NULL)
[16:20:41.491]                   if (is.na(NA_character_)) 
[16:20:41.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.491]                     .init = FALSE)
[16:20:41.491]                 }
[16:20:41.491]             }
[16:20:41.491]         }
[16:20:41.491]     })
[16:20:41.491]     if (TRUE) {
[16:20:41.491]         base::sink(type = "output", split = FALSE)
[16:20:41.491]         if (TRUE) {
[16:20:41.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.491]         }
[16:20:41.491]         else {
[16:20:41.491]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.491]         }
[16:20:41.491]         base::close(...future.stdout)
[16:20:41.491]         ...future.stdout <- NULL
[16:20:41.491]     }
[16:20:41.491]     ...future.result$conditions <- ...future.conditions
[16:20:41.491]     ...future.result$finished <- base::Sys.time()
[16:20:41.491]     ...future.result
[16:20:41.491] }
[16:20:41.493] plan(): Setting new future strategy stack:
[16:20:41.493] List of future strategies:
[16:20:41.493] 1. sequential:
[16:20:41.493]    - args: function (..., envir = parent.frame())
[16:20:41.493]    - tweaked: FALSE
[16:20:41.493]    - call: NULL
[16:20:41.493] plan(): nbrOfWorkers() = 1
[16:20:41.494] plan(): Setting new future strategy stack:
[16:20:41.494] List of future strategies:
[16:20:41.494] 1. sequential:
[16:20:41.494]    - args: function (..., envir = parent.frame())
[16:20:41.494]    - tweaked: FALSE
[16:20:41.494]    - call: plan(strategy)
[16:20:41.494] plan(): nbrOfWorkers() = 1
[16:20:41.494] SequentialFuture started (and completed)
[16:20:41.495] - Launch lazy future ... done
[16:20:41.495] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0c180d30> 
Classes 'listenv', 'environment' <environment: 0x55ed0c0aad60> 
[16:20:41.498] resolved() for ‘SequentialFuture’ ...
[16:20:41.498] - state: ‘finished’
[16:20:41.498] - run: TRUE
[16:20:41.498] - result: ‘FutureResult’
[16:20:41.498] resolved() for ‘SequentialFuture’ ... done
[16:20:41.498] resolved() for ‘SequentialFuture’ ...
[16:20:41.498] - state: ‘finished’
[16:20:41.498] - run: TRUE
[16:20:41.498] - result: ‘FutureResult’
[16:20:41.499] resolved() for ‘SequentialFuture’ ... done
[16:20:41.499] resolved() for ‘SequentialFuture’ ...
[16:20:41.499] - state: ‘finished’
[16:20:41.499] - run: TRUE
[16:20:41.499] - result: ‘FutureResult’
[16:20:41.499] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:41.501] resolve() on list environment ...
[16:20:41.501]  recursive: 0
[16:20:41.502]  length: 6
[16:20:41.502]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:41.502] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.502] - nx: 6
[16:20:41.502] - relay: TRUE
[16:20:41.502] - stdout: TRUE
[16:20:41.502] - signal: TRUE
[16:20:41.502] - resignal: FALSE
[16:20:41.503] - force: TRUE
[16:20:41.503] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.503] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.503]  - until=2
[16:20:41.503]  - relaying element #2
[16:20:41.505] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.505] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.505] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.505]  length: 5 (resolved future 1)
[16:20:41.505] resolved() for ‘SequentialFuture’ ...
[16:20:41.505] - state: ‘finished’
[16:20:41.505] - run: TRUE
[16:20:41.505] - result: ‘FutureResult’
[16:20:41.505] resolved() for ‘SequentialFuture’ ... done
[16:20:41.505] Future #2
[16:20:41.506] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.506] - nx: 6
[16:20:41.506] - relay: TRUE
[16:20:41.506] - stdout: TRUE
[16:20:41.506] - signal: TRUE
[16:20:41.506] - resignal: FALSE
[16:20:41.506] - force: TRUE
[16:20:41.506] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.506] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.506]  - until=2
[16:20:41.506]  - relaying element #2
[16:20:41.507] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.507] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.507] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.507]  length: 4 (resolved future 2)
[16:20:41.507] resolved() for ‘SequentialFuture’ ...
[16:20:41.507] - state: ‘finished’
[16:20:41.507] - run: TRUE
[16:20:41.507] - result: ‘FutureResult’
[16:20:41.507] resolved() for ‘SequentialFuture’ ... done
[16:20:41.508] Future #3
[16:20:41.508] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.508] - nx: 6
[16:20:41.508] - relay: TRUE
[16:20:41.508] - stdout: TRUE
[16:20:41.508] - signal: TRUE
[16:20:41.508] - resignal: FALSE
[16:20:41.508] - force: TRUE
[16:20:41.508] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.508] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.508]  - until=3
[16:20:41.509]  - relaying element #3
[16:20:41.509] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.509] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.509] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.509]  length: 3 (resolved future 3)
[16:20:41.509] resolved() for ‘SequentialFuture’ ...
[16:20:41.509] - state: ‘finished’
[16:20:41.509] - run: TRUE
[16:20:41.509] - result: ‘FutureResult’
[16:20:41.509] resolved() for ‘SequentialFuture’ ... done
[16:20:41.510] Future #4
[16:20:41.510] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.510] - nx: 6
[16:20:41.510] - relay: TRUE
[16:20:41.510] - stdout: TRUE
[16:20:41.510] - signal: TRUE
[16:20:41.510] - resignal: FALSE
[16:20:41.510] - force: TRUE
[16:20:41.510] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.510] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.510]  - until=4
[16:20:41.511]  - relaying element #4
[16:20:41.511] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.511] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.511] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.511]  length: 2 (resolved future 4)
[16:20:41.511] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.511] - nx: 6
[16:20:41.511] - relay: TRUE
[16:20:41.511] - stdout: TRUE
[16:20:41.511] - signal: TRUE
[16:20:41.512] - resignal: FALSE
[16:20:41.512] - force: TRUE
[16:20:41.512] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.512] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.512]  - until=6
[16:20:41.512]  - relaying element #6
[16:20:41.512] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.512] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.512] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.512]  length: 1 (resolved future 5)
[16:20:41.512] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.512] - nx: 6
[16:20:41.513] - relay: TRUE
[16:20:41.513] - stdout: TRUE
[16:20:41.513] - signal: TRUE
[16:20:41.513] - resignal: FALSE
[16:20:41.513] - force: TRUE
[16:20:41.513] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.513] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.513]  - until=6
[16:20:41.513] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.513] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.513] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.513]  length: 0 (resolved future 6)
[16:20:41.514] Relaying remaining futures
[16:20:41.514] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.514] - nx: 6
[16:20:41.514] - relay: TRUE
[16:20:41.514] - stdout: TRUE
[16:20:41.514] - signal: TRUE
[16:20:41.514] - resignal: FALSE
[16:20:41.514] - force: TRUE
[16:20:41.514] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.514] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:41.514] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.514] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.515] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.515] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55ed0c3ed710> 
Dimensions: c(1, 6)
[16:20:41.515] getGlobalsAndPackages() ...
[16:20:41.515] Searching for globals...
[16:20:41.516] 
[16:20:41.516] Searching for globals ... DONE
[16:20:41.516] - globals: [0] <none>
[16:20:41.516] getGlobalsAndPackages() ... DONE
[16:20:41.516] run() for ‘Future’ ...
[16:20:41.516] - state: ‘created’
[16:20:41.516] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.517] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.517] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.517]   - Field: ‘label’
[16:20:41.517]   - Field: ‘local’
[16:20:41.517]   - Field: ‘owner’
[16:20:41.517]   - Field: ‘envir’
[16:20:41.517]   - Field: ‘packages’
[16:20:41.517]   - Field: ‘gc’
[16:20:41.518]   - Field: ‘conditions’
[16:20:41.518]   - Field: ‘expr’
[16:20:41.518]   - Field: ‘uuid’
[16:20:41.518]   - Field: ‘seed’
[16:20:41.518]   - Field: ‘version’
[16:20:41.518]   - Field: ‘result’
[16:20:41.518]   - Field: ‘asynchronous’
[16:20:41.518]   - Field: ‘calls’
[16:20:41.518]   - Field: ‘globals’
[16:20:41.518]   - Field: ‘stdout’
[16:20:41.518]   - Field: ‘earlySignal’
[16:20:41.518]   - Field: ‘lazy’
[16:20:41.519]   - Field: ‘state’
[16:20:41.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.519] - Launch lazy future ...
[16:20:41.519] Packages needed by the future expression (n = 0): <none>
[16:20:41.519] Packages needed by future strategies (n = 0): <none>
[16:20:41.519] {
[16:20:41.519]     {
[16:20:41.519]         {
[16:20:41.519]             ...future.startTime <- base::Sys.time()
[16:20:41.519]             {
[16:20:41.519]                 {
[16:20:41.519]                   {
[16:20:41.519]                     base::local({
[16:20:41.519]                       has_future <- base::requireNamespace("future", 
[16:20:41.519]                         quietly = TRUE)
[16:20:41.519]                       if (has_future) {
[16:20:41.519]                         ns <- base::getNamespace("future")
[16:20:41.519]                         version <- ns[[".package"]][["version"]]
[16:20:41.519]                         if (is.null(version)) 
[16:20:41.519]                           version <- utils::packageVersion("future")
[16:20:41.519]                       }
[16:20:41.519]                       else {
[16:20:41.519]                         version <- NULL
[16:20:41.519]                       }
[16:20:41.519]                       if (!has_future || version < "1.8.0") {
[16:20:41.519]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.519]                           "", base::R.version$version.string), 
[16:20:41.519]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.519]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.519]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.519]                             "release", "version")], collapse = " "), 
[16:20:41.519]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.519]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.519]                           info)
[16:20:41.519]                         info <- base::paste(info, collapse = "; ")
[16:20:41.519]                         if (!has_future) {
[16:20:41.519]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.519]                             info)
[16:20:41.519]                         }
[16:20:41.519]                         else {
[16:20:41.519]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.519]                             info, version)
[16:20:41.519]                         }
[16:20:41.519]                         base::stop(msg)
[16:20:41.519]                       }
[16:20:41.519]                     })
[16:20:41.519]                   }
[16:20:41.519]                   ...future.strategy.old <- future::plan("list")
[16:20:41.519]                   options(future.plan = NULL)
[16:20:41.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.519]                 }
[16:20:41.519]                 ...future.workdir <- getwd()
[16:20:41.519]             }
[16:20:41.519]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.519]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.519]         }
[16:20:41.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.519]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.519]             base::names(...future.oldOptions))
[16:20:41.519]     }
[16:20:41.519]     if (FALSE) {
[16:20:41.519]     }
[16:20:41.519]     else {
[16:20:41.519]         if (TRUE) {
[16:20:41.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.519]                 open = "w")
[16:20:41.519]         }
[16:20:41.519]         else {
[16:20:41.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.519]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.519]         }
[16:20:41.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.519]             base::sink(type = "output", split = FALSE)
[16:20:41.519]             base::close(...future.stdout)
[16:20:41.519]         }, add = TRUE)
[16:20:41.519]     }
[16:20:41.519]     ...future.frame <- base::sys.nframe()
[16:20:41.519]     ...future.conditions <- base::list()
[16:20:41.519]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.519]     if (FALSE) {
[16:20:41.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.519]     }
[16:20:41.519]     ...future.result <- base::tryCatch({
[16:20:41.519]         base::withCallingHandlers({
[16:20:41.519]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.519]             future::FutureResult(value = ...future.value$value, 
[16:20:41.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.519]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.519]                     ...future.globalenv.names))
[16:20:41.519]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.519]         }, condition = base::local({
[16:20:41.519]             c <- base::c
[16:20:41.519]             inherits <- base::inherits
[16:20:41.519]             invokeRestart <- base::invokeRestart
[16:20:41.519]             length <- base::length
[16:20:41.519]             list <- base::list
[16:20:41.519]             seq.int <- base::seq.int
[16:20:41.519]             signalCondition <- base::signalCondition
[16:20:41.519]             sys.calls <- base::sys.calls
[16:20:41.519]             `[[` <- base::`[[`
[16:20:41.519]             `+` <- base::`+`
[16:20:41.519]             `<<-` <- base::`<<-`
[16:20:41.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.519]                   3L)]
[16:20:41.519]             }
[16:20:41.519]             function(cond) {
[16:20:41.519]                 is_error <- inherits(cond, "error")
[16:20:41.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.519]                   NULL)
[16:20:41.519]                 if (is_error) {
[16:20:41.519]                   sessionInformation <- function() {
[16:20:41.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.519]                       search = base::search(), system = base::Sys.info())
[16:20:41.519]                   }
[16:20:41.519]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.519]                     cond$call), session = sessionInformation(), 
[16:20:41.519]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.519]                   signalCondition(cond)
[16:20:41.519]                 }
[16:20:41.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.519]                 "immediateCondition"))) {
[16:20:41.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.519]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.519]                   if (TRUE && !signal) {
[16:20:41.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.519]                     {
[16:20:41.519]                       inherits <- base::inherits
[16:20:41.519]                       invokeRestart <- base::invokeRestart
[16:20:41.519]                       is.null <- base::is.null
[16:20:41.519]                       muffled <- FALSE
[16:20:41.519]                       if (inherits(cond, "message")) {
[16:20:41.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.519]                         if (muffled) 
[16:20:41.519]                           invokeRestart("muffleMessage")
[16:20:41.519]                       }
[16:20:41.519]                       else if (inherits(cond, "warning")) {
[16:20:41.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.519]                         if (muffled) 
[16:20:41.519]                           invokeRestart("muffleWarning")
[16:20:41.519]                       }
[16:20:41.519]                       else if (inherits(cond, "condition")) {
[16:20:41.519]                         if (!is.null(pattern)) {
[16:20:41.519]                           computeRestarts <- base::computeRestarts
[16:20:41.519]                           grepl <- base::grepl
[16:20:41.519]                           restarts <- computeRestarts(cond)
[16:20:41.519]                           for (restart in restarts) {
[16:20:41.519]                             name <- restart$name
[16:20:41.519]                             if (is.null(name)) 
[16:20:41.519]                               next
[16:20:41.519]                             if (!grepl(pattern, name)) 
[16:20:41.519]                               next
[16:20:41.519]                             invokeRestart(restart)
[16:20:41.519]                             muffled <- TRUE
[16:20:41.519]                             break
[16:20:41.519]                           }
[16:20:41.519]                         }
[16:20:41.519]                       }
[16:20:41.519]                       invisible(muffled)
[16:20:41.519]                     }
[16:20:41.519]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.519]                   }
[16:20:41.519]                 }
[16:20:41.519]                 else {
[16:20:41.519]                   if (TRUE) {
[16:20:41.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.519]                     {
[16:20:41.519]                       inherits <- base::inherits
[16:20:41.519]                       invokeRestart <- base::invokeRestart
[16:20:41.519]                       is.null <- base::is.null
[16:20:41.519]                       muffled <- FALSE
[16:20:41.519]                       if (inherits(cond, "message")) {
[16:20:41.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.519]                         if (muffled) 
[16:20:41.519]                           invokeRestart("muffleMessage")
[16:20:41.519]                       }
[16:20:41.519]                       else if (inherits(cond, "warning")) {
[16:20:41.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.519]                         if (muffled) 
[16:20:41.519]                           invokeRestart("muffleWarning")
[16:20:41.519]                       }
[16:20:41.519]                       else if (inherits(cond, "condition")) {
[16:20:41.519]                         if (!is.null(pattern)) {
[16:20:41.519]                           computeRestarts <- base::computeRestarts
[16:20:41.519]                           grepl <- base::grepl
[16:20:41.519]                           restarts <- computeRestarts(cond)
[16:20:41.519]                           for (restart in restarts) {
[16:20:41.519]                             name <- restart$name
[16:20:41.519]                             if (is.null(name)) 
[16:20:41.519]                               next
[16:20:41.519]                             if (!grepl(pattern, name)) 
[16:20:41.519]                               next
[16:20:41.519]                             invokeRestart(restart)
[16:20:41.519]                             muffled <- TRUE
[16:20:41.519]                             break
[16:20:41.519]                           }
[16:20:41.519]                         }
[16:20:41.519]                       }
[16:20:41.519]                       invisible(muffled)
[16:20:41.519]                     }
[16:20:41.519]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.519]                   }
[16:20:41.519]                 }
[16:20:41.519]             }
[16:20:41.519]         }))
[16:20:41.519]     }, error = function(ex) {
[16:20:41.519]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.519]                 ...future.rng), started = ...future.startTime, 
[16:20:41.519]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.519]             version = "1.8"), class = "FutureResult")
[16:20:41.519]     }, finally = {
[16:20:41.519]         if (!identical(...future.workdir, getwd())) 
[16:20:41.519]             setwd(...future.workdir)
[16:20:41.519]         {
[16:20:41.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.519]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.519]             }
[16:20:41.519]             base::options(...future.oldOptions)
[16:20:41.519]             if (.Platform$OS.type == "windows") {
[16:20:41.519]                 old_names <- names(...future.oldEnvVars)
[16:20:41.519]                 envs <- base::Sys.getenv()
[16:20:41.519]                 names <- names(envs)
[16:20:41.519]                 common <- intersect(names, old_names)
[16:20:41.519]                 added <- setdiff(names, old_names)
[16:20:41.519]                 removed <- setdiff(old_names, names)
[16:20:41.519]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.519]                   envs[common]]
[16:20:41.519]                 NAMES <- toupper(changed)
[16:20:41.519]                 args <- list()
[16:20:41.519]                 for (kk in seq_along(NAMES)) {
[16:20:41.519]                   name <- changed[[kk]]
[16:20:41.519]                   NAME <- NAMES[[kk]]
[16:20:41.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.519]                     next
[16:20:41.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.519]                 }
[16:20:41.519]                 NAMES <- toupper(added)
[16:20:41.519]                 for (kk in seq_along(NAMES)) {
[16:20:41.519]                   name <- added[[kk]]
[16:20:41.519]                   NAME <- NAMES[[kk]]
[16:20:41.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.519]                     next
[16:20:41.519]                   args[[name]] <- ""
[16:20:41.519]                 }
[16:20:41.519]                 NAMES <- toupper(removed)
[16:20:41.519]                 for (kk in seq_along(NAMES)) {
[16:20:41.519]                   name <- removed[[kk]]
[16:20:41.519]                   NAME <- NAMES[[kk]]
[16:20:41.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.519]                     next
[16:20:41.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.519]                 }
[16:20:41.519]                 if (length(args) > 0) 
[16:20:41.519]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.519]             }
[16:20:41.519]             else {
[16:20:41.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.519]             }
[16:20:41.519]             {
[16:20:41.519]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.519]                   0L) {
[16:20:41.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.519]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.519]                   base::options(opts)
[16:20:41.519]                 }
[16:20:41.519]                 {
[16:20:41.519]                   {
[16:20:41.519]                     NULL
[16:20:41.519]                     RNGkind("Mersenne-Twister")
[16:20:41.519]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.519]                       inherits = FALSE)
[16:20:41.519]                   }
[16:20:41.519]                   options(future.plan = NULL)
[16:20:41.519]                   if (is.na(NA_character_)) 
[16:20:41.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.519]                     .init = FALSE)
[16:20:41.519]                 }
[16:20:41.519]             }
[16:20:41.519]         }
[16:20:41.519]     })
[16:20:41.519]     if (TRUE) {
[16:20:41.519]         base::sink(type = "output", split = FALSE)
[16:20:41.519]         if (TRUE) {
[16:20:41.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.519]         }
[16:20:41.519]         else {
[16:20:41.519]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.519]         }
[16:20:41.519]         base::close(...future.stdout)
[16:20:41.519]         ...future.stdout <- NULL
[16:20:41.519]     }
[16:20:41.519]     ...future.result$conditions <- ...future.conditions
[16:20:41.519]     ...future.result$finished <- base::Sys.time()
[16:20:41.519]     ...future.result
[16:20:41.519] }
[16:20:41.521] plan(): Setting new future strategy stack:
[16:20:41.521] List of future strategies:
[16:20:41.521] 1. sequential:
[16:20:41.521]    - args: function (..., envir = parent.frame())
[16:20:41.521]    - tweaked: FALSE
[16:20:41.521]    - call: NULL
[16:20:41.521] plan(): nbrOfWorkers() = 1
[16:20:41.522] plan(): Setting new future strategy stack:
[16:20:41.522] List of future strategies:
[16:20:41.522] 1. sequential:
[16:20:41.522]    - args: function (..., envir = parent.frame())
[16:20:41.522]    - tweaked: FALSE
[16:20:41.522]    - call: plan(strategy)
[16:20:41.523] plan(): nbrOfWorkers() = 1
[16:20:41.523] SequentialFuture started (and completed)
[16:20:41.523] - Launch lazy future ... done
[16:20:41.523] run() for ‘SequentialFuture’ ... done
[16:20:41.523] getGlobalsAndPackages() ...
[16:20:41.523] Searching for globals...
[16:20:41.523] 
[16:20:41.524] Searching for globals ... DONE
[16:20:41.524] - globals: [0] <none>
[16:20:41.524] getGlobalsAndPackages() ... DONE
[16:20:41.524] run() for ‘Future’ ...
[16:20:41.524] - state: ‘created’
[16:20:41.524] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.524] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.525]   - Field: ‘label’
[16:20:41.525]   - Field: ‘local’
[16:20:41.525]   - Field: ‘owner’
[16:20:41.525]   - Field: ‘envir’
[16:20:41.525]   - Field: ‘packages’
[16:20:41.525]   - Field: ‘gc’
[16:20:41.525]   - Field: ‘conditions’
[16:20:41.525]   - Field: ‘expr’
[16:20:41.525]   - Field: ‘uuid’
[16:20:41.525]   - Field: ‘seed’
[16:20:41.526]   - Field: ‘version’
[16:20:41.526]   - Field: ‘result’
[16:20:41.526]   - Field: ‘asynchronous’
[16:20:41.526]   - Field: ‘calls’
[16:20:41.526]   - Field: ‘globals’
[16:20:41.526]   - Field: ‘stdout’
[16:20:41.526]   - Field: ‘earlySignal’
[16:20:41.526]   - Field: ‘lazy’
[16:20:41.526]   - Field: ‘state’
[16:20:41.550] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.550] - Launch lazy future ...
[16:20:41.551] Packages needed by the future expression (n = 0): <none>
[16:20:41.551] Packages needed by future strategies (n = 0): <none>
[16:20:41.551] {
[16:20:41.551]     {
[16:20:41.551]         {
[16:20:41.551]             ...future.startTime <- base::Sys.time()
[16:20:41.551]             {
[16:20:41.551]                 {
[16:20:41.551]                   {
[16:20:41.551]                     base::local({
[16:20:41.551]                       has_future <- base::requireNamespace("future", 
[16:20:41.551]                         quietly = TRUE)
[16:20:41.551]                       if (has_future) {
[16:20:41.551]                         ns <- base::getNamespace("future")
[16:20:41.551]                         version <- ns[[".package"]][["version"]]
[16:20:41.551]                         if (is.null(version)) 
[16:20:41.551]                           version <- utils::packageVersion("future")
[16:20:41.551]                       }
[16:20:41.551]                       else {
[16:20:41.551]                         version <- NULL
[16:20:41.551]                       }
[16:20:41.551]                       if (!has_future || version < "1.8.0") {
[16:20:41.551]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.551]                           "", base::R.version$version.string), 
[16:20:41.551]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.551]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.551]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.551]                             "release", "version")], collapse = " "), 
[16:20:41.551]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.551]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.551]                           info)
[16:20:41.551]                         info <- base::paste(info, collapse = "; ")
[16:20:41.551]                         if (!has_future) {
[16:20:41.551]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.551]                             info)
[16:20:41.551]                         }
[16:20:41.551]                         else {
[16:20:41.551]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.551]                             info, version)
[16:20:41.551]                         }
[16:20:41.551]                         base::stop(msg)
[16:20:41.551]                       }
[16:20:41.551]                     })
[16:20:41.551]                   }
[16:20:41.551]                   ...future.strategy.old <- future::plan("list")
[16:20:41.551]                   options(future.plan = NULL)
[16:20:41.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.551]                 }
[16:20:41.551]                 ...future.workdir <- getwd()
[16:20:41.551]             }
[16:20:41.551]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.551]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.551]         }
[16:20:41.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.551]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.551]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.551]             base::names(...future.oldOptions))
[16:20:41.551]     }
[16:20:41.551]     if (FALSE) {
[16:20:41.551]     }
[16:20:41.551]     else {
[16:20:41.551]         if (TRUE) {
[16:20:41.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.551]                 open = "w")
[16:20:41.551]         }
[16:20:41.551]         else {
[16:20:41.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.551]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.551]         }
[16:20:41.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.551]             base::sink(type = "output", split = FALSE)
[16:20:41.551]             base::close(...future.stdout)
[16:20:41.551]         }, add = TRUE)
[16:20:41.551]     }
[16:20:41.551]     ...future.frame <- base::sys.nframe()
[16:20:41.551]     ...future.conditions <- base::list()
[16:20:41.551]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.551]     if (FALSE) {
[16:20:41.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.551]     }
[16:20:41.551]     ...future.result <- base::tryCatch({
[16:20:41.551]         base::withCallingHandlers({
[16:20:41.551]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.551]             future::FutureResult(value = ...future.value$value, 
[16:20:41.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.551]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.551]                     ...future.globalenv.names))
[16:20:41.551]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.551]         }, condition = base::local({
[16:20:41.551]             c <- base::c
[16:20:41.551]             inherits <- base::inherits
[16:20:41.551]             invokeRestart <- base::invokeRestart
[16:20:41.551]             length <- base::length
[16:20:41.551]             list <- base::list
[16:20:41.551]             seq.int <- base::seq.int
[16:20:41.551]             signalCondition <- base::signalCondition
[16:20:41.551]             sys.calls <- base::sys.calls
[16:20:41.551]             `[[` <- base::`[[`
[16:20:41.551]             `+` <- base::`+`
[16:20:41.551]             `<<-` <- base::`<<-`
[16:20:41.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.551]                   3L)]
[16:20:41.551]             }
[16:20:41.551]             function(cond) {
[16:20:41.551]                 is_error <- inherits(cond, "error")
[16:20:41.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.551]                   NULL)
[16:20:41.551]                 if (is_error) {
[16:20:41.551]                   sessionInformation <- function() {
[16:20:41.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.551]                       search = base::search(), system = base::Sys.info())
[16:20:41.551]                   }
[16:20:41.551]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.551]                     cond$call), session = sessionInformation(), 
[16:20:41.551]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.551]                   signalCondition(cond)
[16:20:41.551]                 }
[16:20:41.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.551]                 "immediateCondition"))) {
[16:20:41.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.551]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.551]                   if (TRUE && !signal) {
[16:20:41.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.551]                     {
[16:20:41.551]                       inherits <- base::inherits
[16:20:41.551]                       invokeRestart <- base::invokeRestart
[16:20:41.551]                       is.null <- base::is.null
[16:20:41.551]                       muffled <- FALSE
[16:20:41.551]                       if (inherits(cond, "message")) {
[16:20:41.551]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.551]                         if (muffled) 
[16:20:41.551]                           invokeRestart("muffleMessage")
[16:20:41.551]                       }
[16:20:41.551]                       else if (inherits(cond, "warning")) {
[16:20:41.551]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.551]                         if (muffled) 
[16:20:41.551]                           invokeRestart("muffleWarning")
[16:20:41.551]                       }
[16:20:41.551]                       else if (inherits(cond, "condition")) {
[16:20:41.551]                         if (!is.null(pattern)) {
[16:20:41.551]                           computeRestarts <- base::computeRestarts
[16:20:41.551]                           grepl <- base::grepl
[16:20:41.551]                           restarts <- computeRestarts(cond)
[16:20:41.551]                           for (restart in restarts) {
[16:20:41.551]                             name <- restart$name
[16:20:41.551]                             if (is.null(name)) 
[16:20:41.551]                               next
[16:20:41.551]                             if (!grepl(pattern, name)) 
[16:20:41.551]                               next
[16:20:41.551]                             invokeRestart(restart)
[16:20:41.551]                             muffled <- TRUE
[16:20:41.551]                             break
[16:20:41.551]                           }
[16:20:41.551]                         }
[16:20:41.551]                       }
[16:20:41.551]                       invisible(muffled)
[16:20:41.551]                     }
[16:20:41.551]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.551]                   }
[16:20:41.551]                 }
[16:20:41.551]                 else {
[16:20:41.551]                   if (TRUE) {
[16:20:41.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.551]                     {
[16:20:41.551]                       inherits <- base::inherits
[16:20:41.551]                       invokeRestart <- base::invokeRestart
[16:20:41.551]                       is.null <- base::is.null
[16:20:41.551]                       muffled <- FALSE
[16:20:41.551]                       if (inherits(cond, "message")) {
[16:20:41.551]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.551]                         if (muffled) 
[16:20:41.551]                           invokeRestart("muffleMessage")
[16:20:41.551]                       }
[16:20:41.551]                       else if (inherits(cond, "warning")) {
[16:20:41.551]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.551]                         if (muffled) 
[16:20:41.551]                           invokeRestart("muffleWarning")
[16:20:41.551]                       }
[16:20:41.551]                       else if (inherits(cond, "condition")) {
[16:20:41.551]                         if (!is.null(pattern)) {
[16:20:41.551]                           computeRestarts <- base::computeRestarts
[16:20:41.551]                           grepl <- base::grepl
[16:20:41.551]                           restarts <- computeRestarts(cond)
[16:20:41.551]                           for (restart in restarts) {
[16:20:41.551]                             name <- restart$name
[16:20:41.551]                             if (is.null(name)) 
[16:20:41.551]                               next
[16:20:41.551]                             if (!grepl(pattern, name)) 
[16:20:41.551]                               next
[16:20:41.551]                             invokeRestart(restart)
[16:20:41.551]                             muffled <- TRUE
[16:20:41.551]                             break
[16:20:41.551]                           }
[16:20:41.551]                         }
[16:20:41.551]                       }
[16:20:41.551]                       invisible(muffled)
[16:20:41.551]                     }
[16:20:41.551]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.551]                   }
[16:20:41.551]                 }
[16:20:41.551]             }
[16:20:41.551]         }))
[16:20:41.551]     }, error = function(ex) {
[16:20:41.551]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.551]                 ...future.rng), started = ...future.startTime, 
[16:20:41.551]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.551]             version = "1.8"), class = "FutureResult")
[16:20:41.551]     }, finally = {
[16:20:41.551]         if (!identical(...future.workdir, getwd())) 
[16:20:41.551]             setwd(...future.workdir)
[16:20:41.551]         {
[16:20:41.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.551]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.551]             }
[16:20:41.551]             base::options(...future.oldOptions)
[16:20:41.551]             if (.Platform$OS.type == "windows") {
[16:20:41.551]                 old_names <- names(...future.oldEnvVars)
[16:20:41.551]                 envs <- base::Sys.getenv()
[16:20:41.551]                 names <- names(envs)
[16:20:41.551]                 common <- intersect(names, old_names)
[16:20:41.551]                 added <- setdiff(names, old_names)
[16:20:41.551]                 removed <- setdiff(old_names, names)
[16:20:41.551]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.551]                   envs[common]]
[16:20:41.551]                 NAMES <- toupper(changed)
[16:20:41.551]                 args <- list()
[16:20:41.551]                 for (kk in seq_along(NAMES)) {
[16:20:41.551]                   name <- changed[[kk]]
[16:20:41.551]                   NAME <- NAMES[[kk]]
[16:20:41.551]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.551]                     next
[16:20:41.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.551]                 }
[16:20:41.551]                 NAMES <- toupper(added)
[16:20:41.551]                 for (kk in seq_along(NAMES)) {
[16:20:41.551]                   name <- added[[kk]]
[16:20:41.551]                   NAME <- NAMES[[kk]]
[16:20:41.551]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.551]                     next
[16:20:41.551]                   args[[name]] <- ""
[16:20:41.551]                 }
[16:20:41.551]                 NAMES <- toupper(removed)
[16:20:41.551]                 for (kk in seq_along(NAMES)) {
[16:20:41.551]                   name <- removed[[kk]]
[16:20:41.551]                   NAME <- NAMES[[kk]]
[16:20:41.551]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.551]                     next
[16:20:41.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.551]                 }
[16:20:41.551]                 if (length(args) > 0) 
[16:20:41.551]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.551]             }
[16:20:41.551]             else {
[16:20:41.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.551]             }
[16:20:41.551]             {
[16:20:41.551]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.551]                   0L) {
[16:20:41.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.551]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.551]                   base::options(opts)
[16:20:41.551]                 }
[16:20:41.551]                 {
[16:20:41.551]                   {
[16:20:41.551]                     NULL
[16:20:41.551]                     RNGkind("Mersenne-Twister")
[16:20:41.551]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.551]                       inherits = FALSE)
[16:20:41.551]                   }
[16:20:41.551]                   options(future.plan = NULL)
[16:20:41.551]                   if (is.na(NA_character_)) 
[16:20:41.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.551]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.551]                     .init = FALSE)
[16:20:41.551]                 }
[16:20:41.551]             }
[16:20:41.551]         }
[16:20:41.551]     })
[16:20:41.551]     if (TRUE) {
[16:20:41.551]         base::sink(type = "output", split = FALSE)
[16:20:41.551]         if (TRUE) {
[16:20:41.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.551]         }
[16:20:41.551]         else {
[16:20:41.551]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.551]         }
[16:20:41.551]         base::close(...future.stdout)
[16:20:41.551]         ...future.stdout <- NULL
[16:20:41.551]     }
[16:20:41.551]     ...future.result$conditions <- ...future.conditions
[16:20:41.551]     ...future.result$finished <- base::Sys.time()
[16:20:41.551]     ...future.result
[16:20:41.551] }
[16:20:41.553] plan(): Setting new future strategy stack:
[16:20:41.553] List of future strategies:
[16:20:41.553] 1. sequential:
[16:20:41.553]    - args: function (..., envir = parent.frame())
[16:20:41.553]    - tweaked: FALSE
[16:20:41.553]    - call: NULL
[16:20:41.554] plan(): nbrOfWorkers() = 1
[16:20:41.554] plan(): Setting new future strategy stack:
[16:20:41.554] List of future strategies:
[16:20:41.554] 1. sequential:
[16:20:41.554]    - args: function (..., envir = parent.frame())
[16:20:41.554]    - tweaked: FALSE
[16:20:41.554]    - call: plan(strategy)
[16:20:41.555] plan(): nbrOfWorkers() = 1
[16:20:41.555] SequentialFuture started (and completed)
[16:20:41.555] - Launch lazy future ... done
[16:20:41.555] run() for ‘SequentialFuture’ ... done
[16:20:41.555] getGlobalsAndPackages() ...
[16:20:41.556] Searching for globals...
[16:20:41.556] - globals found: [1] ‘{’
[16:20:41.556] Searching for globals ... DONE
[16:20:41.556] Resolving globals: FALSE
[16:20:41.557] 
[16:20:41.557] 
[16:20:41.557] getGlobalsAndPackages() ... DONE
[16:20:41.557] run() for ‘Future’ ...
[16:20:41.557] - state: ‘created’
[16:20:41.557] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.558] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.558]   - Field: ‘label’
[16:20:41.558]   - Field: ‘local’
[16:20:41.558]   - Field: ‘owner’
[16:20:41.558]   - Field: ‘envir’
[16:20:41.558]   - Field: ‘packages’
[16:20:41.558]   - Field: ‘gc’
[16:20:41.558]   - Field: ‘conditions’
[16:20:41.558]   - Field: ‘expr’
[16:20:41.558]   - Field: ‘uuid’
[16:20:41.559]   - Field: ‘seed’
[16:20:41.559]   - Field: ‘version’
[16:20:41.559]   - Field: ‘result’
[16:20:41.559]   - Field: ‘asynchronous’
[16:20:41.559]   - Field: ‘calls’
[16:20:41.559]   - Field: ‘globals’
[16:20:41.559]   - Field: ‘stdout’
[16:20:41.559]   - Field: ‘earlySignal’
[16:20:41.559]   - Field: ‘lazy’
[16:20:41.559]   - Field: ‘state’
[16:20:41.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.560] - Launch lazy future ...
[16:20:41.560] Packages needed by the future expression (n = 0): <none>
[16:20:41.560] Packages needed by future strategies (n = 0): <none>
[16:20:41.560] {
[16:20:41.560]     {
[16:20:41.560]         {
[16:20:41.560]             ...future.startTime <- base::Sys.time()
[16:20:41.560]             {
[16:20:41.560]                 {
[16:20:41.560]                   {
[16:20:41.560]                     base::local({
[16:20:41.560]                       has_future <- base::requireNamespace("future", 
[16:20:41.560]                         quietly = TRUE)
[16:20:41.560]                       if (has_future) {
[16:20:41.560]                         ns <- base::getNamespace("future")
[16:20:41.560]                         version <- ns[[".package"]][["version"]]
[16:20:41.560]                         if (is.null(version)) 
[16:20:41.560]                           version <- utils::packageVersion("future")
[16:20:41.560]                       }
[16:20:41.560]                       else {
[16:20:41.560]                         version <- NULL
[16:20:41.560]                       }
[16:20:41.560]                       if (!has_future || version < "1.8.0") {
[16:20:41.560]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.560]                           "", base::R.version$version.string), 
[16:20:41.560]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.560]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.560]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.560]                             "release", "version")], collapse = " "), 
[16:20:41.560]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.560]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.560]                           info)
[16:20:41.560]                         info <- base::paste(info, collapse = "; ")
[16:20:41.560]                         if (!has_future) {
[16:20:41.560]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.560]                             info)
[16:20:41.560]                         }
[16:20:41.560]                         else {
[16:20:41.560]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.560]                             info, version)
[16:20:41.560]                         }
[16:20:41.560]                         base::stop(msg)
[16:20:41.560]                       }
[16:20:41.560]                     })
[16:20:41.560]                   }
[16:20:41.560]                   ...future.strategy.old <- future::plan("list")
[16:20:41.560]                   options(future.plan = NULL)
[16:20:41.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.560]                 }
[16:20:41.560]                 ...future.workdir <- getwd()
[16:20:41.560]             }
[16:20:41.560]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.560]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.560]         }
[16:20:41.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.560]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.560]             base::names(...future.oldOptions))
[16:20:41.560]     }
[16:20:41.560]     if (FALSE) {
[16:20:41.560]     }
[16:20:41.560]     else {
[16:20:41.560]         if (TRUE) {
[16:20:41.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.560]                 open = "w")
[16:20:41.560]         }
[16:20:41.560]         else {
[16:20:41.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.560]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.560]         }
[16:20:41.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.560]             base::sink(type = "output", split = FALSE)
[16:20:41.560]             base::close(...future.stdout)
[16:20:41.560]         }, add = TRUE)
[16:20:41.560]     }
[16:20:41.560]     ...future.frame <- base::sys.nframe()
[16:20:41.560]     ...future.conditions <- base::list()
[16:20:41.560]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.560]     if (FALSE) {
[16:20:41.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.560]     }
[16:20:41.560]     ...future.result <- base::tryCatch({
[16:20:41.560]         base::withCallingHandlers({
[16:20:41.560]             ...future.value <- base::withVisible(base::local({
[16:20:41.560]                 4
[16:20:41.560]             }))
[16:20:41.560]             future::FutureResult(value = ...future.value$value, 
[16:20:41.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.560]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.560]                     ...future.globalenv.names))
[16:20:41.560]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.560]         }, condition = base::local({
[16:20:41.560]             c <- base::c
[16:20:41.560]             inherits <- base::inherits
[16:20:41.560]             invokeRestart <- base::invokeRestart
[16:20:41.560]             length <- base::length
[16:20:41.560]             list <- base::list
[16:20:41.560]             seq.int <- base::seq.int
[16:20:41.560]             signalCondition <- base::signalCondition
[16:20:41.560]             sys.calls <- base::sys.calls
[16:20:41.560]             `[[` <- base::`[[`
[16:20:41.560]             `+` <- base::`+`
[16:20:41.560]             `<<-` <- base::`<<-`
[16:20:41.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.560]                   3L)]
[16:20:41.560]             }
[16:20:41.560]             function(cond) {
[16:20:41.560]                 is_error <- inherits(cond, "error")
[16:20:41.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.560]                   NULL)
[16:20:41.560]                 if (is_error) {
[16:20:41.560]                   sessionInformation <- function() {
[16:20:41.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.560]                       search = base::search(), system = base::Sys.info())
[16:20:41.560]                   }
[16:20:41.560]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.560]                     cond$call), session = sessionInformation(), 
[16:20:41.560]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.560]                   signalCondition(cond)
[16:20:41.560]                 }
[16:20:41.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.560]                 "immediateCondition"))) {
[16:20:41.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.560]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.560]                   if (TRUE && !signal) {
[16:20:41.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.560]                     {
[16:20:41.560]                       inherits <- base::inherits
[16:20:41.560]                       invokeRestart <- base::invokeRestart
[16:20:41.560]                       is.null <- base::is.null
[16:20:41.560]                       muffled <- FALSE
[16:20:41.560]                       if (inherits(cond, "message")) {
[16:20:41.560]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.560]                         if (muffled) 
[16:20:41.560]                           invokeRestart("muffleMessage")
[16:20:41.560]                       }
[16:20:41.560]                       else if (inherits(cond, "warning")) {
[16:20:41.560]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.560]                         if (muffled) 
[16:20:41.560]                           invokeRestart("muffleWarning")
[16:20:41.560]                       }
[16:20:41.560]                       else if (inherits(cond, "condition")) {
[16:20:41.560]                         if (!is.null(pattern)) {
[16:20:41.560]                           computeRestarts <- base::computeRestarts
[16:20:41.560]                           grepl <- base::grepl
[16:20:41.560]                           restarts <- computeRestarts(cond)
[16:20:41.560]                           for (restart in restarts) {
[16:20:41.560]                             name <- restart$name
[16:20:41.560]                             if (is.null(name)) 
[16:20:41.560]                               next
[16:20:41.560]                             if (!grepl(pattern, name)) 
[16:20:41.560]                               next
[16:20:41.560]                             invokeRestart(restart)
[16:20:41.560]                             muffled <- TRUE
[16:20:41.560]                             break
[16:20:41.560]                           }
[16:20:41.560]                         }
[16:20:41.560]                       }
[16:20:41.560]                       invisible(muffled)
[16:20:41.560]                     }
[16:20:41.560]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.560]                   }
[16:20:41.560]                 }
[16:20:41.560]                 else {
[16:20:41.560]                   if (TRUE) {
[16:20:41.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.560]                     {
[16:20:41.560]                       inherits <- base::inherits
[16:20:41.560]                       invokeRestart <- base::invokeRestart
[16:20:41.560]                       is.null <- base::is.null
[16:20:41.560]                       muffled <- FALSE
[16:20:41.560]                       if (inherits(cond, "message")) {
[16:20:41.560]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.560]                         if (muffled) 
[16:20:41.560]                           invokeRestart("muffleMessage")
[16:20:41.560]                       }
[16:20:41.560]                       else if (inherits(cond, "warning")) {
[16:20:41.560]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.560]                         if (muffled) 
[16:20:41.560]                           invokeRestart("muffleWarning")
[16:20:41.560]                       }
[16:20:41.560]                       else if (inherits(cond, "condition")) {
[16:20:41.560]                         if (!is.null(pattern)) {
[16:20:41.560]                           computeRestarts <- base::computeRestarts
[16:20:41.560]                           grepl <- base::grepl
[16:20:41.560]                           restarts <- computeRestarts(cond)
[16:20:41.560]                           for (restart in restarts) {
[16:20:41.560]                             name <- restart$name
[16:20:41.560]                             if (is.null(name)) 
[16:20:41.560]                               next
[16:20:41.560]                             if (!grepl(pattern, name)) 
[16:20:41.560]                               next
[16:20:41.560]                             invokeRestart(restart)
[16:20:41.560]                             muffled <- TRUE
[16:20:41.560]                             break
[16:20:41.560]                           }
[16:20:41.560]                         }
[16:20:41.560]                       }
[16:20:41.560]                       invisible(muffled)
[16:20:41.560]                     }
[16:20:41.560]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.560]                   }
[16:20:41.560]                 }
[16:20:41.560]             }
[16:20:41.560]         }))
[16:20:41.560]     }, error = function(ex) {
[16:20:41.560]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.560]                 ...future.rng), started = ...future.startTime, 
[16:20:41.560]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.560]             version = "1.8"), class = "FutureResult")
[16:20:41.560]     }, finally = {
[16:20:41.560]         if (!identical(...future.workdir, getwd())) 
[16:20:41.560]             setwd(...future.workdir)
[16:20:41.560]         {
[16:20:41.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.560]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.560]             }
[16:20:41.560]             base::options(...future.oldOptions)
[16:20:41.560]             if (.Platform$OS.type == "windows") {
[16:20:41.560]                 old_names <- names(...future.oldEnvVars)
[16:20:41.560]                 envs <- base::Sys.getenv()
[16:20:41.560]                 names <- names(envs)
[16:20:41.560]                 common <- intersect(names, old_names)
[16:20:41.560]                 added <- setdiff(names, old_names)
[16:20:41.560]                 removed <- setdiff(old_names, names)
[16:20:41.560]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.560]                   envs[common]]
[16:20:41.560]                 NAMES <- toupper(changed)
[16:20:41.560]                 args <- list()
[16:20:41.560]                 for (kk in seq_along(NAMES)) {
[16:20:41.560]                   name <- changed[[kk]]
[16:20:41.560]                   NAME <- NAMES[[kk]]
[16:20:41.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.560]                     next
[16:20:41.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.560]                 }
[16:20:41.560]                 NAMES <- toupper(added)
[16:20:41.560]                 for (kk in seq_along(NAMES)) {
[16:20:41.560]                   name <- added[[kk]]
[16:20:41.560]                   NAME <- NAMES[[kk]]
[16:20:41.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.560]                     next
[16:20:41.560]                   args[[name]] <- ""
[16:20:41.560]                 }
[16:20:41.560]                 NAMES <- toupper(removed)
[16:20:41.560]                 for (kk in seq_along(NAMES)) {
[16:20:41.560]                   name <- removed[[kk]]
[16:20:41.560]                   NAME <- NAMES[[kk]]
[16:20:41.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.560]                     next
[16:20:41.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.560]                 }
[16:20:41.560]                 if (length(args) > 0) 
[16:20:41.560]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.560]             }
[16:20:41.560]             else {
[16:20:41.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.560]             }
[16:20:41.560]             {
[16:20:41.560]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.560]                   0L) {
[16:20:41.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.560]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.560]                   base::options(opts)
[16:20:41.560]                 }
[16:20:41.560]                 {
[16:20:41.560]                   {
[16:20:41.560]                     NULL
[16:20:41.560]                     RNGkind("Mersenne-Twister")
[16:20:41.560]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.560]                       inherits = FALSE)
[16:20:41.560]                   }
[16:20:41.560]                   options(future.plan = NULL)
[16:20:41.560]                   if (is.na(NA_character_)) 
[16:20:41.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.560]                     .init = FALSE)
[16:20:41.560]                 }
[16:20:41.560]             }
[16:20:41.560]         }
[16:20:41.560]     })
[16:20:41.560]     if (TRUE) {
[16:20:41.560]         base::sink(type = "output", split = FALSE)
[16:20:41.560]         if (TRUE) {
[16:20:41.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.560]         }
[16:20:41.560]         else {
[16:20:41.560]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.560]         }
[16:20:41.560]         base::close(...future.stdout)
[16:20:41.560]         ...future.stdout <- NULL
[16:20:41.560]     }
[16:20:41.560]     ...future.result$conditions <- ...future.conditions
[16:20:41.560]     ...future.result$finished <- base::Sys.time()
[16:20:41.560]     ...future.result
[16:20:41.560] }
[16:20:41.562] plan(): Setting new future strategy stack:
[16:20:41.562] List of future strategies:
[16:20:41.562] 1. sequential:
[16:20:41.562]    - args: function (..., envir = parent.frame())
[16:20:41.562]    - tweaked: FALSE
[16:20:41.562]    - call: NULL
[16:20:41.562] plan(): nbrOfWorkers() = 1
[16:20:41.563] plan(): Setting new future strategy stack:
[16:20:41.563] List of future strategies:
[16:20:41.563] 1. sequential:
[16:20:41.563]    - args: function (..., envir = parent.frame())
[16:20:41.563]    - tweaked: FALSE
[16:20:41.563]    - call: plan(strategy)
[16:20:41.564] plan(): nbrOfWorkers() = 1
[16:20:41.564] SequentialFuture started (and completed)
[16:20:41.564] - Launch lazy future ... done
[16:20:41.564] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0bf33118> 
Classes 'listenv', 'environment' <environment: 0x55ed0bd06a10> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:20:41.567] resolved() for ‘SequentialFuture’ ...
[16:20:41.568] - state: ‘finished’
[16:20:41.568] - run: TRUE
[16:20:41.568] - result: ‘FutureResult’
[16:20:41.568] resolved() for ‘SequentialFuture’ ... done
[16:20:41.568] resolved() for ‘SequentialFuture’ ...
[16:20:41.568] - state: ‘finished’
[16:20:41.568] - run: TRUE
[16:20:41.568] - result: ‘FutureResult’
[16:20:41.568] resolved() for ‘SequentialFuture’ ... done
[16:20:41.569] resolved() for ‘SequentialFuture’ ...
[16:20:41.569] - state: ‘finished’
[16:20:41.569] - run: TRUE
[16:20:41.569] - result: ‘FutureResult’
[16:20:41.569] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:41.571] resolve() on list environment ...
[16:20:41.571]  recursive: 0
[16:20:41.572]  length: 6
[16:20:41.572]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:41.572] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.572] - nx: 6
[16:20:41.573] - relay: TRUE
[16:20:41.573] - stdout: TRUE
[16:20:41.573] - signal: TRUE
[16:20:41.573] - resignal: FALSE
[16:20:41.573] - force: TRUE
[16:20:41.573] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.573] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.573]  - until=2
[16:20:41.573]  - relaying element #2
[16:20:41.573] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.573] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.574] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.574]  length: 5 (resolved future 1)
[16:20:41.574] resolved() for ‘SequentialFuture’ ...
[16:20:41.574] - state: ‘finished’
[16:20:41.574] - run: TRUE
[16:20:41.574] - result: ‘FutureResult’
[16:20:41.574] resolved() for ‘SequentialFuture’ ... done
[16:20:41.574] Future #2
[16:20:41.574] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.574] - nx: 6
[16:20:41.575] - relay: TRUE
[16:20:41.575] - stdout: TRUE
[16:20:41.575] - signal: TRUE
[16:20:41.575] - resignal: FALSE
[16:20:41.575] - force: TRUE
[16:20:41.575] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.575] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.575]  - until=2
[16:20:41.575]  - relaying element #2
[16:20:41.575] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.575] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.576] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.576]  length: 4 (resolved future 2)
[16:20:41.576] resolved() for ‘SequentialFuture’ ...
[16:20:41.576] - state: ‘finished’
[16:20:41.576] - run: TRUE
[16:20:41.576] - result: ‘FutureResult’
[16:20:41.576] resolved() for ‘SequentialFuture’ ... done
[16:20:41.576] Future #3
[16:20:41.576] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.577] - nx: 6
[16:20:41.577] - relay: TRUE
[16:20:41.577] - stdout: TRUE
[16:20:41.577] - signal: TRUE
[16:20:41.577] - resignal: FALSE
[16:20:41.577] - force: TRUE
[16:20:41.577] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.577] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.577]  - until=3
[16:20:41.577]  - relaying element #3
[16:20:41.578] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.579] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.579] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.579]  length: 3 (resolved future 3)
[16:20:41.579] resolved() for ‘SequentialFuture’ ...
[16:20:41.579] - state: ‘finished’
[16:20:41.579] - run: TRUE
[16:20:41.579] - result: ‘FutureResult’
[16:20:41.579] resolved() for ‘SequentialFuture’ ... done
[16:20:41.579] Future #4
[16:20:41.580] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.580] - nx: 6
[16:20:41.580] - relay: TRUE
[16:20:41.580] - stdout: TRUE
[16:20:41.580] - signal: TRUE
[16:20:41.580] - resignal: FALSE
[16:20:41.580] - force: TRUE
[16:20:41.580] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.580] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.580]  - until=4
[16:20:41.580]  - relaying element #4
[16:20:41.581] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.581] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.581] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.581]  length: 2 (resolved future 4)
[16:20:41.581] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.581] - nx: 6
[16:20:41.581] - relay: TRUE
[16:20:41.581] - stdout: TRUE
[16:20:41.581] - signal: TRUE
[16:20:41.581] - resignal: FALSE
[16:20:41.581] - force: TRUE
[16:20:41.581] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.582] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.582]  - until=6
[16:20:41.582]  - relaying element #6
[16:20:41.582] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.582] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.582] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.582]  length: 1 (resolved future 5)
[16:20:41.582] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.582] - nx: 6
[16:20:41.582] - relay: TRUE
[16:20:41.583] - stdout: TRUE
[16:20:41.583] - signal: TRUE
[16:20:41.583] - resignal: FALSE
[16:20:41.583] - force: TRUE
[16:20:41.583] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.583] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.583]  - until=6
[16:20:41.583] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.583] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.583] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.583]  length: 0 (resolved future 6)
[16:20:41.583] Relaying remaining futures
[16:20:41.584] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.584] - nx: 6
[16:20:41.584] - relay: TRUE
[16:20:41.584] - stdout: TRUE
[16:20:41.584] - signal: TRUE
[16:20:41.584] - resignal: FALSE
[16:20:41.584] - force: TRUE
[16:20:41.584] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.584] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:41.584] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.584] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.585] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.585] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55ed0c2894c0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:20:41.586] getGlobalsAndPackages() ...
[16:20:41.587] Searching for globals...
[16:20:41.587] 
[16:20:41.587] Searching for globals ... DONE
[16:20:41.587] - globals: [0] <none>
[16:20:41.587] getGlobalsAndPackages() ... DONE
[16:20:41.587] run() for ‘Future’ ...
[16:20:41.587] - state: ‘created’
[16:20:41.588] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.588] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.588]   - Field: ‘label’
[16:20:41.588]   - Field: ‘local’
[16:20:41.588]   - Field: ‘owner’
[16:20:41.588]   - Field: ‘envir’
[16:20:41.588]   - Field: ‘packages’
[16:20:41.589]   - Field: ‘gc’
[16:20:41.589]   - Field: ‘conditions’
[16:20:41.589]   - Field: ‘expr’
[16:20:41.589]   - Field: ‘uuid’
[16:20:41.589]   - Field: ‘seed’
[16:20:41.589]   - Field: ‘version’
[16:20:41.589]   - Field: ‘result’
[16:20:41.589]   - Field: ‘asynchronous’
[16:20:41.589]   - Field: ‘calls’
[16:20:41.589]   - Field: ‘globals’
[16:20:41.589]   - Field: ‘stdout’
[16:20:41.590]   - Field: ‘earlySignal’
[16:20:41.590]   - Field: ‘lazy’
[16:20:41.590]   - Field: ‘state’
[16:20:41.590] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.590] - Launch lazy future ...
[16:20:41.590] Packages needed by the future expression (n = 0): <none>
[16:20:41.590] Packages needed by future strategies (n = 0): <none>
[16:20:41.591] {
[16:20:41.591]     {
[16:20:41.591]         {
[16:20:41.591]             ...future.startTime <- base::Sys.time()
[16:20:41.591]             {
[16:20:41.591]                 {
[16:20:41.591]                   {
[16:20:41.591]                     base::local({
[16:20:41.591]                       has_future <- base::requireNamespace("future", 
[16:20:41.591]                         quietly = TRUE)
[16:20:41.591]                       if (has_future) {
[16:20:41.591]                         ns <- base::getNamespace("future")
[16:20:41.591]                         version <- ns[[".package"]][["version"]]
[16:20:41.591]                         if (is.null(version)) 
[16:20:41.591]                           version <- utils::packageVersion("future")
[16:20:41.591]                       }
[16:20:41.591]                       else {
[16:20:41.591]                         version <- NULL
[16:20:41.591]                       }
[16:20:41.591]                       if (!has_future || version < "1.8.0") {
[16:20:41.591]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.591]                           "", base::R.version$version.string), 
[16:20:41.591]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.591]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.591]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.591]                             "release", "version")], collapse = " "), 
[16:20:41.591]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.591]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.591]                           info)
[16:20:41.591]                         info <- base::paste(info, collapse = "; ")
[16:20:41.591]                         if (!has_future) {
[16:20:41.591]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.591]                             info)
[16:20:41.591]                         }
[16:20:41.591]                         else {
[16:20:41.591]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.591]                             info, version)
[16:20:41.591]                         }
[16:20:41.591]                         base::stop(msg)
[16:20:41.591]                       }
[16:20:41.591]                     })
[16:20:41.591]                   }
[16:20:41.591]                   ...future.strategy.old <- future::plan("list")
[16:20:41.591]                   options(future.plan = NULL)
[16:20:41.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.591]                 }
[16:20:41.591]                 ...future.workdir <- getwd()
[16:20:41.591]             }
[16:20:41.591]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.591]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.591]         }
[16:20:41.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.591]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.591]             base::names(...future.oldOptions))
[16:20:41.591]     }
[16:20:41.591]     if (FALSE) {
[16:20:41.591]     }
[16:20:41.591]     else {
[16:20:41.591]         if (TRUE) {
[16:20:41.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.591]                 open = "w")
[16:20:41.591]         }
[16:20:41.591]         else {
[16:20:41.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.591]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.591]         }
[16:20:41.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.591]             base::sink(type = "output", split = FALSE)
[16:20:41.591]             base::close(...future.stdout)
[16:20:41.591]         }, add = TRUE)
[16:20:41.591]     }
[16:20:41.591]     ...future.frame <- base::sys.nframe()
[16:20:41.591]     ...future.conditions <- base::list()
[16:20:41.591]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.591]     if (FALSE) {
[16:20:41.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.591]     }
[16:20:41.591]     ...future.result <- base::tryCatch({
[16:20:41.591]         base::withCallingHandlers({
[16:20:41.591]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.591]             future::FutureResult(value = ...future.value$value, 
[16:20:41.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.591]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.591]                     ...future.globalenv.names))
[16:20:41.591]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.591]         }, condition = base::local({
[16:20:41.591]             c <- base::c
[16:20:41.591]             inherits <- base::inherits
[16:20:41.591]             invokeRestart <- base::invokeRestart
[16:20:41.591]             length <- base::length
[16:20:41.591]             list <- base::list
[16:20:41.591]             seq.int <- base::seq.int
[16:20:41.591]             signalCondition <- base::signalCondition
[16:20:41.591]             sys.calls <- base::sys.calls
[16:20:41.591]             `[[` <- base::`[[`
[16:20:41.591]             `+` <- base::`+`
[16:20:41.591]             `<<-` <- base::`<<-`
[16:20:41.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.591]                   3L)]
[16:20:41.591]             }
[16:20:41.591]             function(cond) {
[16:20:41.591]                 is_error <- inherits(cond, "error")
[16:20:41.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.591]                   NULL)
[16:20:41.591]                 if (is_error) {
[16:20:41.591]                   sessionInformation <- function() {
[16:20:41.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.591]                       search = base::search(), system = base::Sys.info())
[16:20:41.591]                   }
[16:20:41.591]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.591]                     cond$call), session = sessionInformation(), 
[16:20:41.591]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.591]                   signalCondition(cond)
[16:20:41.591]                 }
[16:20:41.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.591]                 "immediateCondition"))) {
[16:20:41.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.591]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.591]                   if (TRUE && !signal) {
[16:20:41.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.591]                     {
[16:20:41.591]                       inherits <- base::inherits
[16:20:41.591]                       invokeRestart <- base::invokeRestart
[16:20:41.591]                       is.null <- base::is.null
[16:20:41.591]                       muffled <- FALSE
[16:20:41.591]                       if (inherits(cond, "message")) {
[16:20:41.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.591]                         if (muffled) 
[16:20:41.591]                           invokeRestart("muffleMessage")
[16:20:41.591]                       }
[16:20:41.591]                       else if (inherits(cond, "warning")) {
[16:20:41.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.591]                         if (muffled) 
[16:20:41.591]                           invokeRestart("muffleWarning")
[16:20:41.591]                       }
[16:20:41.591]                       else if (inherits(cond, "condition")) {
[16:20:41.591]                         if (!is.null(pattern)) {
[16:20:41.591]                           computeRestarts <- base::computeRestarts
[16:20:41.591]                           grepl <- base::grepl
[16:20:41.591]                           restarts <- computeRestarts(cond)
[16:20:41.591]                           for (restart in restarts) {
[16:20:41.591]                             name <- restart$name
[16:20:41.591]                             if (is.null(name)) 
[16:20:41.591]                               next
[16:20:41.591]                             if (!grepl(pattern, name)) 
[16:20:41.591]                               next
[16:20:41.591]                             invokeRestart(restart)
[16:20:41.591]                             muffled <- TRUE
[16:20:41.591]                             break
[16:20:41.591]                           }
[16:20:41.591]                         }
[16:20:41.591]                       }
[16:20:41.591]                       invisible(muffled)
[16:20:41.591]                     }
[16:20:41.591]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.591]                   }
[16:20:41.591]                 }
[16:20:41.591]                 else {
[16:20:41.591]                   if (TRUE) {
[16:20:41.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.591]                     {
[16:20:41.591]                       inherits <- base::inherits
[16:20:41.591]                       invokeRestart <- base::invokeRestart
[16:20:41.591]                       is.null <- base::is.null
[16:20:41.591]                       muffled <- FALSE
[16:20:41.591]                       if (inherits(cond, "message")) {
[16:20:41.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.591]                         if (muffled) 
[16:20:41.591]                           invokeRestart("muffleMessage")
[16:20:41.591]                       }
[16:20:41.591]                       else if (inherits(cond, "warning")) {
[16:20:41.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.591]                         if (muffled) 
[16:20:41.591]                           invokeRestart("muffleWarning")
[16:20:41.591]                       }
[16:20:41.591]                       else if (inherits(cond, "condition")) {
[16:20:41.591]                         if (!is.null(pattern)) {
[16:20:41.591]                           computeRestarts <- base::computeRestarts
[16:20:41.591]                           grepl <- base::grepl
[16:20:41.591]                           restarts <- computeRestarts(cond)
[16:20:41.591]                           for (restart in restarts) {
[16:20:41.591]                             name <- restart$name
[16:20:41.591]                             if (is.null(name)) 
[16:20:41.591]                               next
[16:20:41.591]                             if (!grepl(pattern, name)) 
[16:20:41.591]                               next
[16:20:41.591]                             invokeRestart(restart)
[16:20:41.591]                             muffled <- TRUE
[16:20:41.591]                             break
[16:20:41.591]                           }
[16:20:41.591]                         }
[16:20:41.591]                       }
[16:20:41.591]                       invisible(muffled)
[16:20:41.591]                     }
[16:20:41.591]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.591]                   }
[16:20:41.591]                 }
[16:20:41.591]             }
[16:20:41.591]         }))
[16:20:41.591]     }, error = function(ex) {
[16:20:41.591]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.591]                 ...future.rng), started = ...future.startTime, 
[16:20:41.591]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.591]             version = "1.8"), class = "FutureResult")
[16:20:41.591]     }, finally = {
[16:20:41.591]         if (!identical(...future.workdir, getwd())) 
[16:20:41.591]             setwd(...future.workdir)
[16:20:41.591]         {
[16:20:41.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.591]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.591]             }
[16:20:41.591]             base::options(...future.oldOptions)
[16:20:41.591]             if (.Platform$OS.type == "windows") {
[16:20:41.591]                 old_names <- names(...future.oldEnvVars)
[16:20:41.591]                 envs <- base::Sys.getenv()
[16:20:41.591]                 names <- names(envs)
[16:20:41.591]                 common <- intersect(names, old_names)
[16:20:41.591]                 added <- setdiff(names, old_names)
[16:20:41.591]                 removed <- setdiff(old_names, names)
[16:20:41.591]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.591]                   envs[common]]
[16:20:41.591]                 NAMES <- toupper(changed)
[16:20:41.591]                 args <- list()
[16:20:41.591]                 for (kk in seq_along(NAMES)) {
[16:20:41.591]                   name <- changed[[kk]]
[16:20:41.591]                   NAME <- NAMES[[kk]]
[16:20:41.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.591]                     next
[16:20:41.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.591]                 }
[16:20:41.591]                 NAMES <- toupper(added)
[16:20:41.591]                 for (kk in seq_along(NAMES)) {
[16:20:41.591]                   name <- added[[kk]]
[16:20:41.591]                   NAME <- NAMES[[kk]]
[16:20:41.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.591]                     next
[16:20:41.591]                   args[[name]] <- ""
[16:20:41.591]                 }
[16:20:41.591]                 NAMES <- toupper(removed)
[16:20:41.591]                 for (kk in seq_along(NAMES)) {
[16:20:41.591]                   name <- removed[[kk]]
[16:20:41.591]                   NAME <- NAMES[[kk]]
[16:20:41.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.591]                     next
[16:20:41.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.591]                 }
[16:20:41.591]                 if (length(args) > 0) 
[16:20:41.591]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.591]             }
[16:20:41.591]             else {
[16:20:41.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.591]             }
[16:20:41.591]             {
[16:20:41.591]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.591]                   0L) {
[16:20:41.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.591]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.591]                   base::options(opts)
[16:20:41.591]                 }
[16:20:41.591]                 {
[16:20:41.591]                   {
[16:20:41.591]                     NULL
[16:20:41.591]                     RNGkind("Mersenne-Twister")
[16:20:41.591]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.591]                       inherits = FALSE)
[16:20:41.591]                   }
[16:20:41.591]                   options(future.plan = NULL)
[16:20:41.591]                   if (is.na(NA_character_)) 
[16:20:41.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.591]                     .init = FALSE)
[16:20:41.591]                 }
[16:20:41.591]             }
[16:20:41.591]         }
[16:20:41.591]     })
[16:20:41.591]     if (TRUE) {
[16:20:41.591]         base::sink(type = "output", split = FALSE)
[16:20:41.591]         if (TRUE) {
[16:20:41.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.591]         }
[16:20:41.591]         else {
[16:20:41.591]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.591]         }
[16:20:41.591]         base::close(...future.stdout)
[16:20:41.591]         ...future.stdout <- NULL
[16:20:41.591]     }
[16:20:41.591]     ...future.result$conditions <- ...future.conditions
[16:20:41.591]     ...future.result$finished <- base::Sys.time()
[16:20:41.591]     ...future.result
[16:20:41.591] }
[16:20:41.592] plan(): Setting new future strategy stack:
[16:20:41.592] List of future strategies:
[16:20:41.592] 1. sequential:
[16:20:41.592]    - args: function (..., envir = parent.frame())
[16:20:41.592]    - tweaked: FALSE
[16:20:41.592]    - call: NULL
[16:20:41.593] plan(): nbrOfWorkers() = 1
[16:20:41.593] plan(): Setting new future strategy stack:
[16:20:41.593] List of future strategies:
[16:20:41.593] 1. sequential:
[16:20:41.593]    - args: function (..., envir = parent.frame())
[16:20:41.593]    - tweaked: FALSE
[16:20:41.593]    - call: plan(strategy)
[16:20:41.594] plan(): nbrOfWorkers() = 1
[16:20:41.594] SequentialFuture started (and completed)
[16:20:41.594] - Launch lazy future ... done
[16:20:41.594] run() for ‘SequentialFuture’ ... done
[16:20:41.594] getGlobalsAndPackages() ...
[16:20:41.594] Searching for globals...
[16:20:41.595] 
[16:20:41.595] Searching for globals ... DONE
[16:20:41.595] - globals: [0] <none>
[16:20:41.595] getGlobalsAndPackages() ... DONE
[16:20:41.595] run() for ‘Future’ ...
[16:20:41.595] - state: ‘created’
[16:20:41.595] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.596] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.596] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.596]   - Field: ‘label’
[16:20:41.596]   - Field: ‘local’
[16:20:41.596]   - Field: ‘owner’
[16:20:41.596]   - Field: ‘envir’
[16:20:41.596]   - Field: ‘packages’
[16:20:41.596]   - Field: ‘gc’
[16:20:41.596]   - Field: ‘conditions’
[16:20:41.596]   - Field: ‘expr’
[16:20:41.597]   - Field: ‘uuid’
[16:20:41.597]   - Field: ‘seed’
[16:20:41.597]   - Field: ‘version’
[16:20:41.597]   - Field: ‘result’
[16:20:41.597]   - Field: ‘asynchronous’
[16:20:41.597]   - Field: ‘calls’
[16:20:41.597]   - Field: ‘globals’
[16:20:41.597]   - Field: ‘stdout’
[16:20:41.597]   - Field: ‘earlySignal’
[16:20:41.597]   - Field: ‘lazy’
[16:20:41.597]   - Field: ‘state’
[16:20:41.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.598] - Launch lazy future ...
[16:20:41.598] Packages needed by the future expression (n = 0): <none>
[16:20:41.598] Packages needed by future strategies (n = 0): <none>
[16:20:41.598] {
[16:20:41.598]     {
[16:20:41.598]         {
[16:20:41.598]             ...future.startTime <- base::Sys.time()
[16:20:41.598]             {
[16:20:41.598]                 {
[16:20:41.598]                   {
[16:20:41.598]                     base::local({
[16:20:41.598]                       has_future <- base::requireNamespace("future", 
[16:20:41.598]                         quietly = TRUE)
[16:20:41.598]                       if (has_future) {
[16:20:41.598]                         ns <- base::getNamespace("future")
[16:20:41.598]                         version <- ns[[".package"]][["version"]]
[16:20:41.598]                         if (is.null(version)) 
[16:20:41.598]                           version <- utils::packageVersion("future")
[16:20:41.598]                       }
[16:20:41.598]                       else {
[16:20:41.598]                         version <- NULL
[16:20:41.598]                       }
[16:20:41.598]                       if (!has_future || version < "1.8.0") {
[16:20:41.598]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.598]                           "", base::R.version$version.string), 
[16:20:41.598]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.598]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.598]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.598]                             "release", "version")], collapse = " "), 
[16:20:41.598]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.598]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.598]                           info)
[16:20:41.598]                         info <- base::paste(info, collapse = "; ")
[16:20:41.598]                         if (!has_future) {
[16:20:41.598]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.598]                             info)
[16:20:41.598]                         }
[16:20:41.598]                         else {
[16:20:41.598]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.598]                             info, version)
[16:20:41.598]                         }
[16:20:41.598]                         base::stop(msg)
[16:20:41.598]                       }
[16:20:41.598]                     })
[16:20:41.598]                   }
[16:20:41.598]                   ...future.strategy.old <- future::plan("list")
[16:20:41.598]                   options(future.plan = NULL)
[16:20:41.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.598]                 }
[16:20:41.598]                 ...future.workdir <- getwd()
[16:20:41.598]             }
[16:20:41.598]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.598]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.598]         }
[16:20:41.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.598]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.598]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.598]             base::names(...future.oldOptions))
[16:20:41.598]     }
[16:20:41.598]     if (FALSE) {
[16:20:41.598]     }
[16:20:41.598]     else {
[16:20:41.598]         if (TRUE) {
[16:20:41.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.598]                 open = "w")
[16:20:41.598]         }
[16:20:41.598]         else {
[16:20:41.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.598]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.598]         }
[16:20:41.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.598]             base::sink(type = "output", split = FALSE)
[16:20:41.598]             base::close(...future.stdout)
[16:20:41.598]         }, add = TRUE)
[16:20:41.598]     }
[16:20:41.598]     ...future.frame <- base::sys.nframe()
[16:20:41.598]     ...future.conditions <- base::list()
[16:20:41.598]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.598]     if (FALSE) {
[16:20:41.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.598]     }
[16:20:41.598]     ...future.result <- base::tryCatch({
[16:20:41.598]         base::withCallingHandlers({
[16:20:41.598]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.598]             future::FutureResult(value = ...future.value$value, 
[16:20:41.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.598]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.598]                     ...future.globalenv.names))
[16:20:41.598]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.598]         }, condition = base::local({
[16:20:41.598]             c <- base::c
[16:20:41.598]             inherits <- base::inherits
[16:20:41.598]             invokeRestart <- base::invokeRestart
[16:20:41.598]             length <- base::length
[16:20:41.598]             list <- base::list
[16:20:41.598]             seq.int <- base::seq.int
[16:20:41.598]             signalCondition <- base::signalCondition
[16:20:41.598]             sys.calls <- base::sys.calls
[16:20:41.598]             `[[` <- base::`[[`
[16:20:41.598]             `+` <- base::`+`
[16:20:41.598]             `<<-` <- base::`<<-`
[16:20:41.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.598]                   3L)]
[16:20:41.598]             }
[16:20:41.598]             function(cond) {
[16:20:41.598]                 is_error <- inherits(cond, "error")
[16:20:41.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.598]                   NULL)
[16:20:41.598]                 if (is_error) {
[16:20:41.598]                   sessionInformation <- function() {
[16:20:41.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.598]                       search = base::search(), system = base::Sys.info())
[16:20:41.598]                   }
[16:20:41.598]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.598]                     cond$call), session = sessionInformation(), 
[16:20:41.598]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.598]                   signalCondition(cond)
[16:20:41.598]                 }
[16:20:41.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.598]                 "immediateCondition"))) {
[16:20:41.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.598]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.598]                   if (TRUE && !signal) {
[16:20:41.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.598]                     {
[16:20:41.598]                       inherits <- base::inherits
[16:20:41.598]                       invokeRestart <- base::invokeRestart
[16:20:41.598]                       is.null <- base::is.null
[16:20:41.598]                       muffled <- FALSE
[16:20:41.598]                       if (inherits(cond, "message")) {
[16:20:41.598]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.598]                         if (muffled) 
[16:20:41.598]                           invokeRestart("muffleMessage")
[16:20:41.598]                       }
[16:20:41.598]                       else if (inherits(cond, "warning")) {
[16:20:41.598]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.598]                         if (muffled) 
[16:20:41.598]                           invokeRestart("muffleWarning")
[16:20:41.598]                       }
[16:20:41.598]                       else if (inherits(cond, "condition")) {
[16:20:41.598]                         if (!is.null(pattern)) {
[16:20:41.598]                           computeRestarts <- base::computeRestarts
[16:20:41.598]                           grepl <- base::grepl
[16:20:41.598]                           restarts <- computeRestarts(cond)
[16:20:41.598]                           for (restart in restarts) {
[16:20:41.598]                             name <- restart$name
[16:20:41.598]                             if (is.null(name)) 
[16:20:41.598]                               next
[16:20:41.598]                             if (!grepl(pattern, name)) 
[16:20:41.598]                               next
[16:20:41.598]                             invokeRestart(restart)
[16:20:41.598]                             muffled <- TRUE
[16:20:41.598]                             break
[16:20:41.598]                           }
[16:20:41.598]                         }
[16:20:41.598]                       }
[16:20:41.598]                       invisible(muffled)
[16:20:41.598]                     }
[16:20:41.598]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.598]                   }
[16:20:41.598]                 }
[16:20:41.598]                 else {
[16:20:41.598]                   if (TRUE) {
[16:20:41.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.598]                     {
[16:20:41.598]                       inherits <- base::inherits
[16:20:41.598]                       invokeRestart <- base::invokeRestart
[16:20:41.598]                       is.null <- base::is.null
[16:20:41.598]                       muffled <- FALSE
[16:20:41.598]                       if (inherits(cond, "message")) {
[16:20:41.598]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.598]                         if (muffled) 
[16:20:41.598]                           invokeRestart("muffleMessage")
[16:20:41.598]                       }
[16:20:41.598]                       else if (inherits(cond, "warning")) {
[16:20:41.598]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.598]                         if (muffled) 
[16:20:41.598]                           invokeRestart("muffleWarning")
[16:20:41.598]                       }
[16:20:41.598]                       else if (inherits(cond, "condition")) {
[16:20:41.598]                         if (!is.null(pattern)) {
[16:20:41.598]                           computeRestarts <- base::computeRestarts
[16:20:41.598]                           grepl <- base::grepl
[16:20:41.598]                           restarts <- computeRestarts(cond)
[16:20:41.598]                           for (restart in restarts) {
[16:20:41.598]                             name <- restart$name
[16:20:41.598]                             if (is.null(name)) 
[16:20:41.598]                               next
[16:20:41.598]                             if (!grepl(pattern, name)) 
[16:20:41.598]                               next
[16:20:41.598]                             invokeRestart(restart)
[16:20:41.598]                             muffled <- TRUE
[16:20:41.598]                             break
[16:20:41.598]                           }
[16:20:41.598]                         }
[16:20:41.598]                       }
[16:20:41.598]                       invisible(muffled)
[16:20:41.598]                     }
[16:20:41.598]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.598]                   }
[16:20:41.598]                 }
[16:20:41.598]             }
[16:20:41.598]         }))
[16:20:41.598]     }, error = function(ex) {
[16:20:41.598]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.598]                 ...future.rng), started = ...future.startTime, 
[16:20:41.598]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.598]             version = "1.8"), class = "FutureResult")
[16:20:41.598]     }, finally = {
[16:20:41.598]         if (!identical(...future.workdir, getwd())) 
[16:20:41.598]             setwd(...future.workdir)
[16:20:41.598]         {
[16:20:41.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.598]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.598]             }
[16:20:41.598]             base::options(...future.oldOptions)
[16:20:41.598]             if (.Platform$OS.type == "windows") {
[16:20:41.598]                 old_names <- names(...future.oldEnvVars)
[16:20:41.598]                 envs <- base::Sys.getenv()
[16:20:41.598]                 names <- names(envs)
[16:20:41.598]                 common <- intersect(names, old_names)
[16:20:41.598]                 added <- setdiff(names, old_names)
[16:20:41.598]                 removed <- setdiff(old_names, names)
[16:20:41.598]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.598]                   envs[common]]
[16:20:41.598]                 NAMES <- toupper(changed)
[16:20:41.598]                 args <- list()
[16:20:41.598]                 for (kk in seq_along(NAMES)) {
[16:20:41.598]                   name <- changed[[kk]]
[16:20:41.598]                   NAME <- NAMES[[kk]]
[16:20:41.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.598]                     next
[16:20:41.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.598]                 }
[16:20:41.598]                 NAMES <- toupper(added)
[16:20:41.598]                 for (kk in seq_along(NAMES)) {
[16:20:41.598]                   name <- added[[kk]]
[16:20:41.598]                   NAME <- NAMES[[kk]]
[16:20:41.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.598]                     next
[16:20:41.598]                   args[[name]] <- ""
[16:20:41.598]                 }
[16:20:41.598]                 NAMES <- toupper(removed)
[16:20:41.598]                 for (kk in seq_along(NAMES)) {
[16:20:41.598]                   name <- removed[[kk]]
[16:20:41.598]                   NAME <- NAMES[[kk]]
[16:20:41.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.598]                     next
[16:20:41.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.598]                 }
[16:20:41.598]                 if (length(args) > 0) 
[16:20:41.598]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.598]             }
[16:20:41.598]             else {
[16:20:41.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.598]             }
[16:20:41.598]             {
[16:20:41.598]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.598]                   0L) {
[16:20:41.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.598]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.598]                   base::options(opts)
[16:20:41.598]                 }
[16:20:41.598]                 {
[16:20:41.598]                   {
[16:20:41.598]                     NULL
[16:20:41.598]                     RNGkind("Mersenne-Twister")
[16:20:41.598]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.598]                       inherits = FALSE)
[16:20:41.598]                   }
[16:20:41.598]                   options(future.plan = NULL)
[16:20:41.598]                   if (is.na(NA_character_)) 
[16:20:41.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.598]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.598]                     .init = FALSE)
[16:20:41.598]                 }
[16:20:41.598]             }
[16:20:41.598]         }
[16:20:41.598]     })
[16:20:41.598]     if (TRUE) {
[16:20:41.598]         base::sink(type = "output", split = FALSE)
[16:20:41.598]         if (TRUE) {
[16:20:41.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.598]         }
[16:20:41.598]         else {
[16:20:41.598]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.598]         }
[16:20:41.598]         base::close(...future.stdout)
[16:20:41.598]         ...future.stdout <- NULL
[16:20:41.598]     }
[16:20:41.598]     ...future.result$conditions <- ...future.conditions
[16:20:41.598]     ...future.result$finished <- base::Sys.time()
[16:20:41.598]     ...future.result
[16:20:41.598] }
[16:20:41.600] plan(): Setting new future strategy stack:
[16:20:41.600] List of future strategies:
[16:20:41.600] 1. sequential:
[16:20:41.600]    - args: function (..., envir = parent.frame())
[16:20:41.600]    - tweaked: FALSE
[16:20:41.600]    - call: NULL
[16:20:41.600] plan(): nbrOfWorkers() = 1
[16:20:41.601] plan(): Setting new future strategy stack:
[16:20:41.601] List of future strategies:
[16:20:41.601] 1. sequential:
[16:20:41.601]    - args: function (..., envir = parent.frame())
[16:20:41.601]    - tweaked: FALSE
[16:20:41.601]    - call: plan(strategy)
[16:20:41.602] plan(): nbrOfWorkers() = 1
[16:20:41.602] SequentialFuture started (and completed)
[16:20:41.602] - Launch lazy future ... done
[16:20:41.602] run() for ‘SequentialFuture’ ... done
[16:20:41.602] getGlobalsAndPackages() ...
[16:20:41.602] Searching for globals...
[16:20:41.603] - globals found: [1] ‘{’
[16:20:41.603] Searching for globals ... DONE
[16:20:41.603] Resolving globals: FALSE
[16:20:41.603] 
[16:20:41.603] 
[16:20:41.604] getGlobalsAndPackages() ... DONE
[16:20:41.604] run() for ‘Future’ ...
[16:20:41.604] - state: ‘created’
[16:20:41.604] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.604] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.604] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.605]   - Field: ‘label’
[16:20:41.605]   - Field: ‘local’
[16:20:41.605]   - Field: ‘owner’
[16:20:41.605]   - Field: ‘envir’
[16:20:41.605]   - Field: ‘packages’
[16:20:41.605]   - Field: ‘gc’
[16:20:41.605]   - Field: ‘conditions’
[16:20:41.605]   - Field: ‘expr’
[16:20:41.606]   - Field: ‘uuid’
[16:20:41.606]   - Field: ‘seed’
[16:20:41.606]   - Field: ‘version’
[16:20:41.607]   - Field: ‘result’
[16:20:41.607]   - Field: ‘asynchronous’
[16:20:41.607]   - Field: ‘calls’
[16:20:41.607]   - Field: ‘globals’
[16:20:41.607]   - Field: ‘stdout’
[16:20:41.607]   - Field: ‘earlySignal’
[16:20:41.607]   - Field: ‘lazy’
[16:20:41.607]   - Field: ‘state’
[16:20:41.607] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.607] - Launch lazy future ...
[16:20:41.608] Packages needed by the future expression (n = 0): <none>
[16:20:41.608] Packages needed by future strategies (n = 0): <none>
[16:20:41.608] {
[16:20:41.608]     {
[16:20:41.608]         {
[16:20:41.608]             ...future.startTime <- base::Sys.time()
[16:20:41.608]             {
[16:20:41.608]                 {
[16:20:41.608]                   {
[16:20:41.608]                     base::local({
[16:20:41.608]                       has_future <- base::requireNamespace("future", 
[16:20:41.608]                         quietly = TRUE)
[16:20:41.608]                       if (has_future) {
[16:20:41.608]                         ns <- base::getNamespace("future")
[16:20:41.608]                         version <- ns[[".package"]][["version"]]
[16:20:41.608]                         if (is.null(version)) 
[16:20:41.608]                           version <- utils::packageVersion("future")
[16:20:41.608]                       }
[16:20:41.608]                       else {
[16:20:41.608]                         version <- NULL
[16:20:41.608]                       }
[16:20:41.608]                       if (!has_future || version < "1.8.0") {
[16:20:41.608]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.608]                           "", base::R.version$version.string), 
[16:20:41.608]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.608]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.608]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.608]                             "release", "version")], collapse = " "), 
[16:20:41.608]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.608]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.608]                           info)
[16:20:41.608]                         info <- base::paste(info, collapse = "; ")
[16:20:41.608]                         if (!has_future) {
[16:20:41.608]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.608]                             info)
[16:20:41.608]                         }
[16:20:41.608]                         else {
[16:20:41.608]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.608]                             info, version)
[16:20:41.608]                         }
[16:20:41.608]                         base::stop(msg)
[16:20:41.608]                       }
[16:20:41.608]                     })
[16:20:41.608]                   }
[16:20:41.608]                   ...future.strategy.old <- future::plan("list")
[16:20:41.608]                   options(future.plan = NULL)
[16:20:41.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.608]                 }
[16:20:41.608]                 ...future.workdir <- getwd()
[16:20:41.608]             }
[16:20:41.608]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.608]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.608]         }
[16:20:41.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.608]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.608]             base::names(...future.oldOptions))
[16:20:41.608]     }
[16:20:41.608]     if (FALSE) {
[16:20:41.608]     }
[16:20:41.608]     else {
[16:20:41.608]         if (TRUE) {
[16:20:41.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.608]                 open = "w")
[16:20:41.608]         }
[16:20:41.608]         else {
[16:20:41.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.608]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.608]         }
[16:20:41.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.608]             base::sink(type = "output", split = FALSE)
[16:20:41.608]             base::close(...future.stdout)
[16:20:41.608]         }, add = TRUE)
[16:20:41.608]     }
[16:20:41.608]     ...future.frame <- base::sys.nframe()
[16:20:41.608]     ...future.conditions <- base::list()
[16:20:41.608]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.608]     if (FALSE) {
[16:20:41.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.608]     }
[16:20:41.608]     ...future.result <- base::tryCatch({
[16:20:41.608]         base::withCallingHandlers({
[16:20:41.608]             ...future.value <- base::withVisible(base::local({
[16:20:41.608]                 4
[16:20:41.608]             }))
[16:20:41.608]             future::FutureResult(value = ...future.value$value, 
[16:20:41.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.608]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.608]                     ...future.globalenv.names))
[16:20:41.608]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.608]         }, condition = base::local({
[16:20:41.608]             c <- base::c
[16:20:41.608]             inherits <- base::inherits
[16:20:41.608]             invokeRestart <- base::invokeRestart
[16:20:41.608]             length <- base::length
[16:20:41.608]             list <- base::list
[16:20:41.608]             seq.int <- base::seq.int
[16:20:41.608]             signalCondition <- base::signalCondition
[16:20:41.608]             sys.calls <- base::sys.calls
[16:20:41.608]             `[[` <- base::`[[`
[16:20:41.608]             `+` <- base::`+`
[16:20:41.608]             `<<-` <- base::`<<-`
[16:20:41.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.608]                   3L)]
[16:20:41.608]             }
[16:20:41.608]             function(cond) {
[16:20:41.608]                 is_error <- inherits(cond, "error")
[16:20:41.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.608]                   NULL)
[16:20:41.608]                 if (is_error) {
[16:20:41.608]                   sessionInformation <- function() {
[16:20:41.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.608]                       search = base::search(), system = base::Sys.info())
[16:20:41.608]                   }
[16:20:41.608]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.608]                     cond$call), session = sessionInformation(), 
[16:20:41.608]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.608]                   signalCondition(cond)
[16:20:41.608]                 }
[16:20:41.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.608]                 "immediateCondition"))) {
[16:20:41.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.608]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.608]                   if (TRUE && !signal) {
[16:20:41.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.608]                     {
[16:20:41.608]                       inherits <- base::inherits
[16:20:41.608]                       invokeRestart <- base::invokeRestart
[16:20:41.608]                       is.null <- base::is.null
[16:20:41.608]                       muffled <- FALSE
[16:20:41.608]                       if (inherits(cond, "message")) {
[16:20:41.608]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.608]                         if (muffled) 
[16:20:41.608]                           invokeRestart("muffleMessage")
[16:20:41.608]                       }
[16:20:41.608]                       else if (inherits(cond, "warning")) {
[16:20:41.608]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.608]                         if (muffled) 
[16:20:41.608]                           invokeRestart("muffleWarning")
[16:20:41.608]                       }
[16:20:41.608]                       else if (inherits(cond, "condition")) {
[16:20:41.608]                         if (!is.null(pattern)) {
[16:20:41.608]                           computeRestarts <- base::computeRestarts
[16:20:41.608]                           grepl <- base::grepl
[16:20:41.608]                           restarts <- computeRestarts(cond)
[16:20:41.608]                           for (restart in restarts) {
[16:20:41.608]                             name <- restart$name
[16:20:41.608]                             if (is.null(name)) 
[16:20:41.608]                               next
[16:20:41.608]                             if (!grepl(pattern, name)) 
[16:20:41.608]                               next
[16:20:41.608]                             invokeRestart(restart)
[16:20:41.608]                             muffled <- TRUE
[16:20:41.608]                             break
[16:20:41.608]                           }
[16:20:41.608]                         }
[16:20:41.608]                       }
[16:20:41.608]                       invisible(muffled)
[16:20:41.608]                     }
[16:20:41.608]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.608]                   }
[16:20:41.608]                 }
[16:20:41.608]                 else {
[16:20:41.608]                   if (TRUE) {
[16:20:41.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.608]                     {
[16:20:41.608]                       inherits <- base::inherits
[16:20:41.608]                       invokeRestart <- base::invokeRestart
[16:20:41.608]                       is.null <- base::is.null
[16:20:41.608]                       muffled <- FALSE
[16:20:41.608]                       if (inherits(cond, "message")) {
[16:20:41.608]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.608]                         if (muffled) 
[16:20:41.608]                           invokeRestart("muffleMessage")
[16:20:41.608]                       }
[16:20:41.608]                       else if (inherits(cond, "warning")) {
[16:20:41.608]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.608]                         if (muffled) 
[16:20:41.608]                           invokeRestart("muffleWarning")
[16:20:41.608]                       }
[16:20:41.608]                       else if (inherits(cond, "condition")) {
[16:20:41.608]                         if (!is.null(pattern)) {
[16:20:41.608]                           computeRestarts <- base::computeRestarts
[16:20:41.608]                           grepl <- base::grepl
[16:20:41.608]                           restarts <- computeRestarts(cond)
[16:20:41.608]                           for (restart in restarts) {
[16:20:41.608]                             name <- restart$name
[16:20:41.608]                             if (is.null(name)) 
[16:20:41.608]                               next
[16:20:41.608]                             if (!grepl(pattern, name)) 
[16:20:41.608]                               next
[16:20:41.608]                             invokeRestart(restart)
[16:20:41.608]                             muffled <- TRUE
[16:20:41.608]                             break
[16:20:41.608]                           }
[16:20:41.608]                         }
[16:20:41.608]                       }
[16:20:41.608]                       invisible(muffled)
[16:20:41.608]                     }
[16:20:41.608]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.608]                   }
[16:20:41.608]                 }
[16:20:41.608]             }
[16:20:41.608]         }))
[16:20:41.608]     }, error = function(ex) {
[16:20:41.608]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.608]                 ...future.rng), started = ...future.startTime, 
[16:20:41.608]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.608]             version = "1.8"), class = "FutureResult")
[16:20:41.608]     }, finally = {
[16:20:41.608]         if (!identical(...future.workdir, getwd())) 
[16:20:41.608]             setwd(...future.workdir)
[16:20:41.608]         {
[16:20:41.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.608]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.608]             }
[16:20:41.608]             base::options(...future.oldOptions)
[16:20:41.608]             if (.Platform$OS.type == "windows") {
[16:20:41.608]                 old_names <- names(...future.oldEnvVars)
[16:20:41.608]                 envs <- base::Sys.getenv()
[16:20:41.608]                 names <- names(envs)
[16:20:41.608]                 common <- intersect(names, old_names)
[16:20:41.608]                 added <- setdiff(names, old_names)
[16:20:41.608]                 removed <- setdiff(old_names, names)
[16:20:41.608]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.608]                   envs[common]]
[16:20:41.608]                 NAMES <- toupper(changed)
[16:20:41.608]                 args <- list()
[16:20:41.608]                 for (kk in seq_along(NAMES)) {
[16:20:41.608]                   name <- changed[[kk]]
[16:20:41.608]                   NAME <- NAMES[[kk]]
[16:20:41.608]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.608]                     next
[16:20:41.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.608]                 }
[16:20:41.608]                 NAMES <- toupper(added)
[16:20:41.608]                 for (kk in seq_along(NAMES)) {
[16:20:41.608]                   name <- added[[kk]]
[16:20:41.608]                   NAME <- NAMES[[kk]]
[16:20:41.608]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.608]                     next
[16:20:41.608]                   args[[name]] <- ""
[16:20:41.608]                 }
[16:20:41.608]                 NAMES <- toupper(removed)
[16:20:41.608]                 for (kk in seq_along(NAMES)) {
[16:20:41.608]                   name <- removed[[kk]]
[16:20:41.608]                   NAME <- NAMES[[kk]]
[16:20:41.608]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.608]                     next
[16:20:41.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.608]                 }
[16:20:41.608]                 if (length(args) > 0) 
[16:20:41.608]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.608]             }
[16:20:41.608]             else {
[16:20:41.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.608]             }
[16:20:41.608]             {
[16:20:41.608]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.608]                   0L) {
[16:20:41.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.608]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.608]                   base::options(opts)
[16:20:41.608]                 }
[16:20:41.608]                 {
[16:20:41.608]                   {
[16:20:41.608]                     NULL
[16:20:41.608]                     RNGkind("Mersenne-Twister")
[16:20:41.608]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.608]                       inherits = FALSE)
[16:20:41.608]                   }
[16:20:41.608]                   options(future.plan = NULL)
[16:20:41.608]                   if (is.na(NA_character_)) 
[16:20:41.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.608]                     .init = FALSE)
[16:20:41.608]                 }
[16:20:41.608]             }
[16:20:41.608]         }
[16:20:41.608]     })
[16:20:41.608]     if (TRUE) {
[16:20:41.608]         base::sink(type = "output", split = FALSE)
[16:20:41.608]         if (TRUE) {
[16:20:41.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.608]         }
[16:20:41.608]         else {
[16:20:41.608]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.608]         }
[16:20:41.608]         base::close(...future.stdout)
[16:20:41.608]         ...future.stdout <- NULL
[16:20:41.608]     }
[16:20:41.608]     ...future.result$conditions <- ...future.conditions
[16:20:41.608]     ...future.result$finished <- base::Sys.time()
[16:20:41.608]     ...future.result
[16:20:41.608] }
[16:20:41.610] plan(): Setting new future strategy stack:
[16:20:41.610] List of future strategies:
[16:20:41.610] 1. sequential:
[16:20:41.610]    - args: function (..., envir = parent.frame())
[16:20:41.610]    - tweaked: FALSE
[16:20:41.610]    - call: NULL
[16:20:41.610] plan(): nbrOfWorkers() = 1
[16:20:41.611] plan(): Setting new future strategy stack:
[16:20:41.611] List of future strategies:
[16:20:41.611] 1. sequential:
[16:20:41.611]    - args: function (..., envir = parent.frame())
[16:20:41.611]    - tweaked: FALSE
[16:20:41.611]    - call: plan(strategy)
[16:20:41.611] plan(): nbrOfWorkers() = 1
[16:20:41.612] SequentialFuture started (and completed)
[16:20:41.612] - Launch lazy future ... done
[16:20:41.612] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0a317668> 
Classes 'listenv', 'environment' <environment: 0x55ed0a68aca0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:20:41.615] resolved() for ‘SequentialFuture’ ...
[16:20:41.615] - state: ‘finished’
[16:20:41.615] - run: TRUE
[16:20:41.615] - result: ‘FutureResult’
[16:20:41.616] resolved() for ‘SequentialFuture’ ... done
[16:20:41.616] resolved() for ‘SequentialFuture’ ...
[16:20:41.616] - state: ‘finished’
[16:20:41.616] - run: TRUE
[16:20:41.616] - result: ‘FutureResult’
[16:20:41.616] resolved() for ‘SequentialFuture’ ... done
[16:20:41.616] resolved() for ‘SequentialFuture’ ...
[16:20:41.616] - state: ‘finished’
[16:20:41.616] - run: TRUE
[16:20:41.616] - result: ‘FutureResult’
[16:20:41.616] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:41.619] resolve() on list environment ...
[16:20:41.619]  recursive: 0
[16:20:41.620]  length: 6
[16:20:41.620]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:41.620] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.620] - nx: 6
[16:20:41.620] - relay: TRUE
[16:20:41.620] - stdout: TRUE
[16:20:41.620] - signal: TRUE
[16:20:41.620] - resignal: FALSE
[16:20:41.620] - force: TRUE
[16:20:41.620] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.621] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.621]  - until=2
[16:20:41.621]  - relaying element #2
[16:20:41.621] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.621] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.621] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.621]  length: 5 (resolved future 1)
[16:20:41.621] resolved() for ‘SequentialFuture’ ...
[16:20:41.621] - state: ‘finished’
[16:20:41.621] - run: TRUE
[16:20:41.621] - result: ‘FutureResult’
[16:20:41.622] resolved() for ‘SequentialFuture’ ... done
[16:20:41.622] Future #2
[16:20:41.622] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.622] - nx: 6
[16:20:41.622] - relay: TRUE
[16:20:41.622] - stdout: TRUE
[16:20:41.622] - signal: TRUE
[16:20:41.622] - resignal: FALSE
[16:20:41.622] - force: TRUE
[16:20:41.622] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.622] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.622]  - until=2
[16:20:41.623]  - relaying element #2
[16:20:41.623] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.623] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.623] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.623]  length: 4 (resolved future 2)
[16:20:41.623] resolved() for ‘SequentialFuture’ ...
[16:20:41.623] - state: ‘finished’
[16:20:41.623] - run: TRUE
[16:20:41.623] - result: ‘FutureResult’
[16:20:41.624] resolved() for ‘SequentialFuture’ ... done
[16:20:41.624] Future #3
[16:20:41.624] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.624] - nx: 6
[16:20:41.624] - relay: TRUE
[16:20:41.624] - stdout: TRUE
[16:20:41.624] - signal: TRUE
[16:20:41.624] - resignal: FALSE
[16:20:41.624] - force: TRUE
[16:20:41.624] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.624] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.625]  - until=3
[16:20:41.625]  - relaying element #3
[16:20:41.625] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.625] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.625] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.625]  length: 3 (resolved future 3)
[16:20:41.625] resolved() for ‘SequentialFuture’ ...
[16:20:41.625] - state: ‘finished’
[16:20:41.625] - run: TRUE
[16:20:41.625] - result: ‘FutureResult’
[16:20:41.626] resolved() for ‘SequentialFuture’ ... done
[16:20:41.626] Future #4
[16:20:41.626] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.626] - nx: 6
[16:20:41.626] - relay: TRUE
[16:20:41.626] - stdout: TRUE
[16:20:41.626] - signal: TRUE
[16:20:41.626] - resignal: FALSE
[16:20:41.626] - force: TRUE
[16:20:41.626] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.626] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.626]  - until=4
[16:20:41.627]  - relaying element #4
[16:20:41.627] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.627] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.627] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.627]  length: 2 (resolved future 4)
[16:20:41.627] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.627] - nx: 6
[16:20:41.627] - relay: TRUE
[16:20:41.627] - stdout: TRUE
[16:20:41.627] - signal: TRUE
[16:20:41.627] - resignal: FALSE
[16:20:41.628] - force: TRUE
[16:20:41.628] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.628] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.628]  - until=6
[16:20:41.628]  - relaying element #6
[16:20:41.628] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.628] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.628] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.628]  length: 1 (resolved future 5)
[16:20:41.628] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.628] - nx: 6
[16:20:41.629] - relay: TRUE
[16:20:41.629] - stdout: TRUE
[16:20:41.629] - signal: TRUE
[16:20:41.629] - resignal: FALSE
[16:20:41.629] - force: TRUE
[16:20:41.629] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.629] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.629]  - until=6
[16:20:41.629] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.629] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.629] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.629]  length: 0 (resolved future 6)
[16:20:41.630] Relaying remaining futures
[16:20:41.630] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.630] - nx: 6
[16:20:41.630] - relay: TRUE
[16:20:41.630] - stdout: TRUE
[16:20:41.630] - signal: TRUE
[16:20:41.630] - resignal: FALSE
[16:20:41.630] - force: TRUE
[16:20:41.631] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.631] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:41.631] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.631] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.631] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.631] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55ed0bd98ba8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:20:41.633] getGlobalsAndPackages() ...
[16:20:41.633] Searching for globals...
[16:20:41.634] 
[16:20:41.634] Searching for globals ... DONE
[16:20:41.634] - globals: [0] <none>
[16:20:41.634] getGlobalsAndPackages() ... DONE
[16:20:41.634] run() for ‘Future’ ...
[16:20:41.634] - state: ‘created’
[16:20:41.634] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.635] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.635] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.635]   - Field: ‘label’
[16:20:41.635]   - Field: ‘local’
[16:20:41.635]   - Field: ‘owner’
[16:20:41.635]   - Field: ‘envir’
[16:20:41.635]   - Field: ‘packages’
[16:20:41.635]   - Field: ‘gc’
[16:20:41.635]   - Field: ‘conditions’
[16:20:41.636]   - Field: ‘expr’
[16:20:41.636]   - Field: ‘uuid’
[16:20:41.636]   - Field: ‘seed’
[16:20:41.636]   - Field: ‘version’
[16:20:41.636]   - Field: ‘result’
[16:20:41.636]   - Field: ‘asynchronous’
[16:20:41.636]   - Field: ‘calls’
[16:20:41.636]   - Field: ‘globals’
[16:20:41.636]   - Field: ‘stdout’
[16:20:41.636]   - Field: ‘earlySignal’
[16:20:41.636]   - Field: ‘lazy’
[16:20:41.637]   - Field: ‘state’
[16:20:41.637] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.637] - Launch lazy future ...
[16:20:41.637] Packages needed by the future expression (n = 0): <none>
[16:20:41.637] Packages needed by future strategies (n = 0): <none>
[16:20:41.637] {
[16:20:41.637]     {
[16:20:41.637]         {
[16:20:41.637]             ...future.startTime <- base::Sys.time()
[16:20:41.637]             {
[16:20:41.637]                 {
[16:20:41.637]                   {
[16:20:41.637]                     base::local({
[16:20:41.637]                       has_future <- base::requireNamespace("future", 
[16:20:41.637]                         quietly = TRUE)
[16:20:41.637]                       if (has_future) {
[16:20:41.637]                         ns <- base::getNamespace("future")
[16:20:41.637]                         version <- ns[[".package"]][["version"]]
[16:20:41.637]                         if (is.null(version)) 
[16:20:41.637]                           version <- utils::packageVersion("future")
[16:20:41.637]                       }
[16:20:41.637]                       else {
[16:20:41.637]                         version <- NULL
[16:20:41.637]                       }
[16:20:41.637]                       if (!has_future || version < "1.8.0") {
[16:20:41.637]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.637]                           "", base::R.version$version.string), 
[16:20:41.637]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.637]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.637]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.637]                             "release", "version")], collapse = " "), 
[16:20:41.637]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.637]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.637]                           info)
[16:20:41.637]                         info <- base::paste(info, collapse = "; ")
[16:20:41.637]                         if (!has_future) {
[16:20:41.637]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.637]                             info)
[16:20:41.637]                         }
[16:20:41.637]                         else {
[16:20:41.637]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.637]                             info, version)
[16:20:41.637]                         }
[16:20:41.637]                         base::stop(msg)
[16:20:41.637]                       }
[16:20:41.637]                     })
[16:20:41.637]                   }
[16:20:41.637]                   ...future.strategy.old <- future::plan("list")
[16:20:41.637]                   options(future.plan = NULL)
[16:20:41.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.637]                 }
[16:20:41.637]                 ...future.workdir <- getwd()
[16:20:41.637]             }
[16:20:41.637]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.637]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.637]         }
[16:20:41.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.637]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.637]             base::names(...future.oldOptions))
[16:20:41.637]     }
[16:20:41.637]     if (FALSE) {
[16:20:41.637]     }
[16:20:41.637]     else {
[16:20:41.637]         if (TRUE) {
[16:20:41.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.637]                 open = "w")
[16:20:41.637]         }
[16:20:41.637]         else {
[16:20:41.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.637]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.637]         }
[16:20:41.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.637]             base::sink(type = "output", split = FALSE)
[16:20:41.637]             base::close(...future.stdout)
[16:20:41.637]         }, add = TRUE)
[16:20:41.637]     }
[16:20:41.637]     ...future.frame <- base::sys.nframe()
[16:20:41.637]     ...future.conditions <- base::list()
[16:20:41.637]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.637]     if (FALSE) {
[16:20:41.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.637]     }
[16:20:41.637]     ...future.result <- base::tryCatch({
[16:20:41.637]         base::withCallingHandlers({
[16:20:41.637]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.637]             future::FutureResult(value = ...future.value$value, 
[16:20:41.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.637]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.637]                     ...future.globalenv.names))
[16:20:41.637]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.637]         }, condition = base::local({
[16:20:41.637]             c <- base::c
[16:20:41.637]             inherits <- base::inherits
[16:20:41.637]             invokeRestart <- base::invokeRestart
[16:20:41.637]             length <- base::length
[16:20:41.637]             list <- base::list
[16:20:41.637]             seq.int <- base::seq.int
[16:20:41.637]             signalCondition <- base::signalCondition
[16:20:41.637]             sys.calls <- base::sys.calls
[16:20:41.637]             `[[` <- base::`[[`
[16:20:41.637]             `+` <- base::`+`
[16:20:41.637]             `<<-` <- base::`<<-`
[16:20:41.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.637]                   3L)]
[16:20:41.637]             }
[16:20:41.637]             function(cond) {
[16:20:41.637]                 is_error <- inherits(cond, "error")
[16:20:41.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.637]                   NULL)
[16:20:41.637]                 if (is_error) {
[16:20:41.637]                   sessionInformation <- function() {
[16:20:41.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.637]                       search = base::search(), system = base::Sys.info())
[16:20:41.637]                   }
[16:20:41.637]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.637]                     cond$call), session = sessionInformation(), 
[16:20:41.637]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.637]                   signalCondition(cond)
[16:20:41.637]                 }
[16:20:41.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.637]                 "immediateCondition"))) {
[16:20:41.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.637]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.637]                   if (TRUE && !signal) {
[16:20:41.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.637]                     {
[16:20:41.637]                       inherits <- base::inherits
[16:20:41.637]                       invokeRestart <- base::invokeRestart
[16:20:41.637]                       is.null <- base::is.null
[16:20:41.637]                       muffled <- FALSE
[16:20:41.637]                       if (inherits(cond, "message")) {
[16:20:41.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.637]                         if (muffled) 
[16:20:41.637]                           invokeRestart("muffleMessage")
[16:20:41.637]                       }
[16:20:41.637]                       else if (inherits(cond, "warning")) {
[16:20:41.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.637]                         if (muffled) 
[16:20:41.637]                           invokeRestart("muffleWarning")
[16:20:41.637]                       }
[16:20:41.637]                       else if (inherits(cond, "condition")) {
[16:20:41.637]                         if (!is.null(pattern)) {
[16:20:41.637]                           computeRestarts <- base::computeRestarts
[16:20:41.637]                           grepl <- base::grepl
[16:20:41.637]                           restarts <- computeRestarts(cond)
[16:20:41.637]                           for (restart in restarts) {
[16:20:41.637]                             name <- restart$name
[16:20:41.637]                             if (is.null(name)) 
[16:20:41.637]                               next
[16:20:41.637]                             if (!grepl(pattern, name)) 
[16:20:41.637]                               next
[16:20:41.637]                             invokeRestart(restart)
[16:20:41.637]                             muffled <- TRUE
[16:20:41.637]                             break
[16:20:41.637]                           }
[16:20:41.637]                         }
[16:20:41.637]                       }
[16:20:41.637]                       invisible(muffled)
[16:20:41.637]                     }
[16:20:41.637]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.637]                   }
[16:20:41.637]                 }
[16:20:41.637]                 else {
[16:20:41.637]                   if (TRUE) {
[16:20:41.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.637]                     {
[16:20:41.637]                       inherits <- base::inherits
[16:20:41.637]                       invokeRestart <- base::invokeRestart
[16:20:41.637]                       is.null <- base::is.null
[16:20:41.637]                       muffled <- FALSE
[16:20:41.637]                       if (inherits(cond, "message")) {
[16:20:41.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.637]                         if (muffled) 
[16:20:41.637]                           invokeRestart("muffleMessage")
[16:20:41.637]                       }
[16:20:41.637]                       else if (inherits(cond, "warning")) {
[16:20:41.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.637]                         if (muffled) 
[16:20:41.637]                           invokeRestart("muffleWarning")
[16:20:41.637]                       }
[16:20:41.637]                       else if (inherits(cond, "condition")) {
[16:20:41.637]                         if (!is.null(pattern)) {
[16:20:41.637]                           computeRestarts <- base::computeRestarts
[16:20:41.637]                           grepl <- base::grepl
[16:20:41.637]                           restarts <- computeRestarts(cond)
[16:20:41.637]                           for (restart in restarts) {
[16:20:41.637]                             name <- restart$name
[16:20:41.637]                             if (is.null(name)) 
[16:20:41.637]                               next
[16:20:41.637]                             if (!grepl(pattern, name)) 
[16:20:41.637]                               next
[16:20:41.637]                             invokeRestart(restart)
[16:20:41.637]                             muffled <- TRUE
[16:20:41.637]                             break
[16:20:41.637]                           }
[16:20:41.637]                         }
[16:20:41.637]                       }
[16:20:41.637]                       invisible(muffled)
[16:20:41.637]                     }
[16:20:41.637]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.637]                   }
[16:20:41.637]                 }
[16:20:41.637]             }
[16:20:41.637]         }))
[16:20:41.637]     }, error = function(ex) {
[16:20:41.637]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.637]                 ...future.rng), started = ...future.startTime, 
[16:20:41.637]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.637]             version = "1.8"), class = "FutureResult")
[16:20:41.637]     }, finally = {
[16:20:41.637]         if (!identical(...future.workdir, getwd())) 
[16:20:41.637]             setwd(...future.workdir)
[16:20:41.637]         {
[16:20:41.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.637]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.637]             }
[16:20:41.637]             base::options(...future.oldOptions)
[16:20:41.637]             if (.Platform$OS.type == "windows") {
[16:20:41.637]                 old_names <- names(...future.oldEnvVars)
[16:20:41.637]                 envs <- base::Sys.getenv()
[16:20:41.637]                 names <- names(envs)
[16:20:41.637]                 common <- intersect(names, old_names)
[16:20:41.637]                 added <- setdiff(names, old_names)
[16:20:41.637]                 removed <- setdiff(old_names, names)
[16:20:41.637]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.637]                   envs[common]]
[16:20:41.637]                 NAMES <- toupper(changed)
[16:20:41.637]                 args <- list()
[16:20:41.637]                 for (kk in seq_along(NAMES)) {
[16:20:41.637]                   name <- changed[[kk]]
[16:20:41.637]                   NAME <- NAMES[[kk]]
[16:20:41.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.637]                     next
[16:20:41.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.637]                 }
[16:20:41.637]                 NAMES <- toupper(added)
[16:20:41.637]                 for (kk in seq_along(NAMES)) {
[16:20:41.637]                   name <- added[[kk]]
[16:20:41.637]                   NAME <- NAMES[[kk]]
[16:20:41.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.637]                     next
[16:20:41.637]                   args[[name]] <- ""
[16:20:41.637]                 }
[16:20:41.637]                 NAMES <- toupper(removed)
[16:20:41.637]                 for (kk in seq_along(NAMES)) {
[16:20:41.637]                   name <- removed[[kk]]
[16:20:41.637]                   NAME <- NAMES[[kk]]
[16:20:41.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.637]                     next
[16:20:41.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.637]                 }
[16:20:41.637]                 if (length(args) > 0) 
[16:20:41.637]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.637]             }
[16:20:41.637]             else {
[16:20:41.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.637]             }
[16:20:41.637]             {
[16:20:41.637]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.637]                   0L) {
[16:20:41.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.637]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.637]                   base::options(opts)
[16:20:41.637]                 }
[16:20:41.637]                 {
[16:20:41.637]                   {
[16:20:41.637]                     NULL
[16:20:41.637]                     RNGkind("Mersenne-Twister")
[16:20:41.637]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.637]                       inherits = FALSE)
[16:20:41.637]                   }
[16:20:41.637]                   options(future.plan = NULL)
[16:20:41.637]                   if (is.na(NA_character_)) 
[16:20:41.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.637]                     .init = FALSE)
[16:20:41.637]                 }
[16:20:41.637]             }
[16:20:41.637]         }
[16:20:41.637]     })
[16:20:41.637]     if (TRUE) {
[16:20:41.637]         base::sink(type = "output", split = FALSE)
[16:20:41.637]         if (TRUE) {
[16:20:41.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.637]         }
[16:20:41.637]         else {
[16:20:41.637]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.637]         }
[16:20:41.637]         base::close(...future.stdout)
[16:20:41.637]         ...future.stdout <- NULL
[16:20:41.637]     }
[16:20:41.637]     ...future.result$conditions <- ...future.conditions
[16:20:41.637]     ...future.result$finished <- base::Sys.time()
[16:20:41.637]     ...future.result
[16:20:41.637] }
[16:20:41.639] plan(): Setting new future strategy stack:
[16:20:41.639] List of future strategies:
[16:20:41.639] 1. sequential:
[16:20:41.639]    - args: function (..., envir = parent.frame())
[16:20:41.639]    - tweaked: FALSE
[16:20:41.639]    - call: NULL
[16:20:41.639] plan(): nbrOfWorkers() = 1
[16:20:41.640] plan(): Setting new future strategy stack:
[16:20:41.640] List of future strategies:
[16:20:41.640] 1. sequential:
[16:20:41.640]    - args: function (..., envir = parent.frame())
[16:20:41.640]    - tweaked: FALSE
[16:20:41.640]    - call: plan(strategy)
[16:20:41.641] plan(): nbrOfWorkers() = 1
[16:20:41.641] SequentialFuture started (and completed)
[16:20:41.641] - Launch lazy future ... done
[16:20:41.641] run() for ‘SequentialFuture’ ... done
[16:20:41.641] getGlobalsAndPackages() ...
[16:20:41.641] Searching for globals...
[16:20:41.641] 
[16:20:41.642] Searching for globals ... DONE
[16:20:41.642] - globals: [0] <none>
[16:20:41.642] getGlobalsAndPackages() ... DONE
[16:20:41.642] run() for ‘Future’ ...
[16:20:41.642] - state: ‘created’
[16:20:41.642] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.642] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.642] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.643]   - Field: ‘label’
[16:20:41.643]   - Field: ‘local’
[16:20:41.643]   - Field: ‘owner’
[16:20:41.643]   - Field: ‘envir’
[16:20:41.643]   - Field: ‘packages’
[16:20:41.643]   - Field: ‘gc’
[16:20:41.643]   - Field: ‘conditions’
[16:20:41.643]   - Field: ‘expr’
[16:20:41.643]   - Field: ‘uuid’
[16:20:41.643]   - Field: ‘seed’
[16:20:41.643]   - Field: ‘version’
[16:20:41.644]   - Field: ‘result’
[16:20:41.644]   - Field: ‘asynchronous’
[16:20:41.644]   - Field: ‘calls’
[16:20:41.644]   - Field: ‘globals’
[16:20:41.644]   - Field: ‘stdout’
[16:20:41.644]   - Field: ‘earlySignal’
[16:20:41.644]   - Field: ‘lazy’
[16:20:41.644]   - Field: ‘state’
[16:20:41.644] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.644] - Launch lazy future ...
[16:20:41.645] Packages needed by the future expression (n = 0): <none>
[16:20:41.645] Packages needed by future strategies (n = 0): <none>
[16:20:41.645] {
[16:20:41.645]     {
[16:20:41.645]         {
[16:20:41.645]             ...future.startTime <- base::Sys.time()
[16:20:41.645]             {
[16:20:41.645]                 {
[16:20:41.645]                   {
[16:20:41.645]                     base::local({
[16:20:41.645]                       has_future <- base::requireNamespace("future", 
[16:20:41.645]                         quietly = TRUE)
[16:20:41.645]                       if (has_future) {
[16:20:41.645]                         ns <- base::getNamespace("future")
[16:20:41.645]                         version <- ns[[".package"]][["version"]]
[16:20:41.645]                         if (is.null(version)) 
[16:20:41.645]                           version <- utils::packageVersion("future")
[16:20:41.645]                       }
[16:20:41.645]                       else {
[16:20:41.645]                         version <- NULL
[16:20:41.645]                       }
[16:20:41.645]                       if (!has_future || version < "1.8.0") {
[16:20:41.645]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.645]                           "", base::R.version$version.string), 
[16:20:41.645]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.645]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.645]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.645]                             "release", "version")], collapse = " "), 
[16:20:41.645]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.645]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.645]                           info)
[16:20:41.645]                         info <- base::paste(info, collapse = "; ")
[16:20:41.645]                         if (!has_future) {
[16:20:41.645]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.645]                             info)
[16:20:41.645]                         }
[16:20:41.645]                         else {
[16:20:41.645]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.645]                             info, version)
[16:20:41.645]                         }
[16:20:41.645]                         base::stop(msg)
[16:20:41.645]                       }
[16:20:41.645]                     })
[16:20:41.645]                   }
[16:20:41.645]                   ...future.strategy.old <- future::plan("list")
[16:20:41.645]                   options(future.plan = NULL)
[16:20:41.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.645]                 }
[16:20:41.645]                 ...future.workdir <- getwd()
[16:20:41.645]             }
[16:20:41.645]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.645]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.645]         }
[16:20:41.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.645]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.645]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.645]             base::names(...future.oldOptions))
[16:20:41.645]     }
[16:20:41.645]     if (FALSE) {
[16:20:41.645]     }
[16:20:41.645]     else {
[16:20:41.645]         if (TRUE) {
[16:20:41.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.645]                 open = "w")
[16:20:41.645]         }
[16:20:41.645]         else {
[16:20:41.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.645]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.645]         }
[16:20:41.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.645]             base::sink(type = "output", split = FALSE)
[16:20:41.645]             base::close(...future.stdout)
[16:20:41.645]         }, add = TRUE)
[16:20:41.645]     }
[16:20:41.645]     ...future.frame <- base::sys.nframe()
[16:20:41.645]     ...future.conditions <- base::list()
[16:20:41.645]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.645]     if (FALSE) {
[16:20:41.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.645]     }
[16:20:41.645]     ...future.result <- base::tryCatch({
[16:20:41.645]         base::withCallingHandlers({
[16:20:41.645]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.645]             future::FutureResult(value = ...future.value$value, 
[16:20:41.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.645]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.645]                     ...future.globalenv.names))
[16:20:41.645]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.645]         }, condition = base::local({
[16:20:41.645]             c <- base::c
[16:20:41.645]             inherits <- base::inherits
[16:20:41.645]             invokeRestart <- base::invokeRestart
[16:20:41.645]             length <- base::length
[16:20:41.645]             list <- base::list
[16:20:41.645]             seq.int <- base::seq.int
[16:20:41.645]             signalCondition <- base::signalCondition
[16:20:41.645]             sys.calls <- base::sys.calls
[16:20:41.645]             `[[` <- base::`[[`
[16:20:41.645]             `+` <- base::`+`
[16:20:41.645]             `<<-` <- base::`<<-`
[16:20:41.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.645]                   3L)]
[16:20:41.645]             }
[16:20:41.645]             function(cond) {
[16:20:41.645]                 is_error <- inherits(cond, "error")
[16:20:41.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.645]                   NULL)
[16:20:41.645]                 if (is_error) {
[16:20:41.645]                   sessionInformation <- function() {
[16:20:41.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.645]                       search = base::search(), system = base::Sys.info())
[16:20:41.645]                   }
[16:20:41.645]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.645]                     cond$call), session = sessionInformation(), 
[16:20:41.645]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.645]                   signalCondition(cond)
[16:20:41.645]                 }
[16:20:41.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.645]                 "immediateCondition"))) {
[16:20:41.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.645]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.645]                   if (TRUE && !signal) {
[16:20:41.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.645]                     {
[16:20:41.645]                       inherits <- base::inherits
[16:20:41.645]                       invokeRestart <- base::invokeRestart
[16:20:41.645]                       is.null <- base::is.null
[16:20:41.645]                       muffled <- FALSE
[16:20:41.645]                       if (inherits(cond, "message")) {
[16:20:41.645]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.645]                         if (muffled) 
[16:20:41.645]                           invokeRestart("muffleMessage")
[16:20:41.645]                       }
[16:20:41.645]                       else if (inherits(cond, "warning")) {
[16:20:41.645]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.645]                         if (muffled) 
[16:20:41.645]                           invokeRestart("muffleWarning")
[16:20:41.645]                       }
[16:20:41.645]                       else if (inherits(cond, "condition")) {
[16:20:41.645]                         if (!is.null(pattern)) {
[16:20:41.645]                           computeRestarts <- base::computeRestarts
[16:20:41.645]                           grepl <- base::grepl
[16:20:41.645]                           restarts <- computeRestarts(cond)
[16:20:41.645]                           for (restart in restarts) {
[16:20:41.645]                             name <- restart$name
[16:20:41.645]                             if (is.null(name)) 
[16:20:41.645]                               next
[16:20:41.645]                             if (!grepl(pattern, name)) 
[16:20:41.645]                               next
[16:20:41.645]                             invokeRestart(restart)
[16:20:41.645]                             muffled <- TRUE
[16:20:41.645]                             break
[16:20:41.645]                           }
[16:20:41.645]                         }
[16:20:41.645]                       }
[16:20:41.645]                       invisible(muffled)
[16:20:41.645]                     }
[16:20:41.645]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.645]                   }
[16:20:41.645]                 }
[16:20:41.645]                 else {
[16:20:41.645]                   if (TRUE) {
[16:20:41.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.645]                     {
[16:20:41.645]                       inherits <- base::inherits
[16:20:41.645]                       invokeRestart <- base::invokeRestart
[16:20:41.645]                       is.null <- base::is.null
[16:20:41.645]                       muffled <- FALSE
[16:20:41.645]                       if (inherits(cond, "message")) {
[16:20:41.645]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.645]                         if (muffled) 
[16:20:41.645]                           invokeRestart("muffleMessage")
[16:20:41.645]                       }
[16:20:41.645]                       else if (inherits(cond, "warning")) {
[16:20:41.645]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.645]                         if (muffled) 
[16:20:41.645]                           invokeRestart("muffleWarning")
[16:20:41.645]                       }
[16:20:41.645]                       else if (inherits(cond, "condition")) {
[16:20:41.645]                         if (!is.null(pattern)) {
[16:20:41.645]                           computeRestarts <- base::computeRestarts
[16:20:41.645]                           grepl <- base::grepl
[16:20:41.645]                           restarts <- computeRestarts(cond)
[16:20:41.645]                           for (restart in restarts) {
[16:20:41.645]                             name <- restart$name
[16:20:41.645]                             if (is.null(name)) 
[16:20:41.645]                               next
[16:20:41.645]                             if (!grepl(pattern, name)) 
[16:20:41.645]                               next
[16:20:41.645]                             invokeRestart(restart)
[16:20:41.645]                             muffled <- TRUE
[16:20:41.645]                             break
[16:20:41.645]                           }
[16:20:41.645]                         }
[16:20:41.645]                       }
[16:20:41.645]                       invisible(muffled)
[16:20:41.645]                     }
[16:20:41.645]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.645]                   }
[16:20:41.645]                 }
[16:20:41.645]             }
[16:20:41.645]         }))
[16:20:41.645]     }, error = function(ex) {
[16:20:41.645]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.645]                 ...future.rng), started = ...future.startTime, 
[16:20:41.645]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.645]             version = "1.8"), class = "FutureResult")
[16:20:41.645]     }, finally = {
[16:20:41.645]         if (!identical(...future.workdir, getwd())) 
[16:20:41.645]             setwd(...future.workdir)
[16:20:41.645]         {
[16:20:41.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.645]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.645]             }
[16:20:41.645]             base::options(...future.oldOptions)
[16:20:41.645]             if (.Platform$OS.type == "windows") {
[16:20:41.645]                 old_names <- names(...future.oldEnvVars)
[16:20:41.645]                 envs <- base::Sys.getenv()
[16:20:41.645]                 names <- names(envs)
[16:20:41.645]                 common <- intersect(names, old_names)
[16:20:41.645]                 added <- setdiff(names, old_names)
[16:20:41.645]                 removed <- setdiff(old_names, names)
[16:20:41.645]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.645]                   envs[common]]
[16:20:41.645]                 NAMES <- toupper(changed)
[16:20:41.645]                 args <- list()
[16:20:41.645]                 for (kk in seq_along(NAMES)) {
[16:20:41.645]                   name <- changed[[kk]]
[16:20:41.645]                   NAME <- NAMES[[kk]]
[16:20:41.645]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.645]                     next
[16:20:41.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.645]                 }
[16:20:41.645]                 NAMES <- toupper(added)
[16:20:41.645]                 for (kk in seq_along(NAMES)) {
[16:20:41.645]                   name <- added[[kk]]
[16:20:41.645]                   NAME <- NAMES[[kk]]
[16:20:41.645]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.645]                     next
[16:20:41.645]                   args[[name]] <- ""
[16:20:41.645]                 }
[16:20:41.645]                 NAMES <- toupper(removed)
[16:20:41.645]                 for (kk in seq_along(NAMES)) {
[16:20:41.645]                   name <- removed[[kk]]
[16:20:41.645]                   NAME <- NAMES[[kk]]
[16:20:41.645]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.645]                     next
[16:20:41.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.645]                 }
[16:20:41.645]                 if (length(args) > 0) 
[16:20:41.645]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.645]             }
[16:20:41.645]             else {
[16:20:41.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.645]             }
[16:20:41.645]             {
[16:20:41.645]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.645]                   0L) {
[16:20:41.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.645]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.645]                   base::options(opts)
[16:20:41.645]                 }
[16:20:41.645]                 {
[16:20:41.645]                   {
[16:20:41.645]                     NULL
[16:20:41.645]                     RNGkind("Mersenne-Twister")
[16:20:41.645]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.645]                       inherits = FALSE)
[16:20:41.645]                   }
[16:20:41.645]                   options(future.plan = NULL)
[16:20:41.645]                   if (is.na(NA_character_)) 
[16:20:41.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.645]                     .init = FALSE)
[16:20:41.645]                 }
[16:20:41.645]             }
[16:20:41.645]         }
[16:20:41.645]     })
[16:20:41.645]     if (TRUE) {
[16:20:41.645]         base::sink(type = "output", split = FALSE)
[16:20:41.645]         if (TRUE) {
[16:20:41.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.645]         }
[16:20:41.645]         else {
[16:20:41.645]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.645]         }
[16:20:41.645]         base::close(...future.stdout)
[16:20:41.645]         ...future.stdout <- NULL
[16:20:41.645]     }
[16:20:41.645]     ...future.result$conditions <- ...future.conditions
[16:20:41.645]     ...future.result$finished <- base::Sys.time()
[16:20:41.645]     ...future.result
[16:20:41.645] }
[16:20:41.647] plan(): Setting new future strategy stack:
[16:20:41.647] List of future strategies:
[16:20:41.647] 1. sequential:
[16:20:41.647]    - args: function (..., envir = parent.frame())
[16:20:41.647]    - tweaked: FALSE
[16:20:41.647]    - call: NULL
[16:20:41.647] plan(): nbrOfWorkers() = 1
[16:20:41.648] plan(): Setting new future strategy stack:
[16:20:41.648] List of future strategies:
[16:20:41.648] 1. sequential:
[16:20:41.648]    - args: function (..., envir = parent.frame())
[16:20:41.648]    - tweaked: FALSE
[16:20:41.648]    - call: plan(strategy)
[16:20:41.648] plan(): nbrOfWorkers() = 1
[16:20:41.648] SequentialFuture started (and completed)
[16:20:41.649] - Launch lazy future ... done
[16:20:41.649] run() for ‘SequentialFuture’ ... done
[16:20:41.649] getGlobalsAndPackages() ...
[16:20:41.649] Searching for globals...
[16:20:41.650] - globals found: [1] ‘{’
[16:20:41.650] Searching for globals ... DONE
[16:20:41.650] Resolving globals: FALSE
[16:20:41.650] 
[16:20:41.650] 
[16:20:41.650] getGlobalsAndPackages() ... DONE
[16:20:41.650] run() for ‘Future’ ...
[16:20:41.650] - state: ‘created’
[16:20:41.651] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.651] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.651] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.651]   - Field: ‘label’
[16:20:41.651]   - Field: ‘local’
[16:20:41.651]   - Field: ‘owner’
[16:20:41.651]   - Field: ‘envir’
[16:20:41.651]   - Field: ‘packages’
[16:20:41.651]   - Field: ‘gc’
[16:20:41.652]   - Field: ‘conditions’
[16:20:41.652]   - Field: ‘expr’
[16:20:41.652]   - Field: ‘uuid’
[16:20:41.652]   - Field: ‘seed’
[16:20:41.652]   - Field: ‘version’
[16:20:41.652]   - Field: ‘result’
[16:20:41.652]   - Field: ‘asynchronous’
[16:20:41.652]   - Field: ‘calls’
[16:20:41.652]   - Field: ‘globals’
[16:20:41.652]   - Field: ‘stdout’
[16:20:41.652]   - Field: ‘earlySignal’
[16:20:41.653]   - Field: ‘lazy’
[16:20:41.653]   - Field: ‘state’
[16:20:41.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.653] - Launch lazy future ...
[16:20:41.653] Packages needed by the future expression (n = 0): <none>
[16:20:41.653] Packages needed by future strategies (n = 0): <none>
[16:20:41.653] {
[16:20:41.653]     {
[16:20:41.653]         {
[16:20:41.653]             ...future.startTime <- base::Sys.time()
[16:20:41.653]             {
[16:20:41.653]                 {
[16:20:41.653]                   {
[16:20:41.653]                     base::local({
[16:20:41.653]                       has_future <- base::requireNamespace("future", 
[16:20:41.653]                         quietly = TRUE)
[16:20:41.653]                       if (has_future) {
[16:20:41.653]                         ns <- base::getNamespace("future")
[16:20:41.653]                         version <- ns[[".package"]][["version"]]
[16:20:41.653]                         if (is.null(version)) 
[16:20:41.653]                           version <- utils::packageVersion("future")
[16:20:41.653]                       }
[16:20:41.653]                       else {
[16:20:41.653]                         version <- NULL
[16:20:41.653]                       }
[16:20:41.653]                       if (!has_future || version < "1.8.0") {
[16:20:41.653]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.653]                           "", base::R.version$version.string), 
[16:20:41.653]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.653]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.653]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.653]                             "release", "version")], collapse = " "), 
[16:20:41.653]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.653]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.653]                           info)
[16:20:41.653]                         info <- base::paste(info, collapse = "; ")
[16:20:41.653]                         if (!has_future) {
[16:20:41.653]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.653]                             info)
[16:20:41.653]                         }
[16:20:41.653]                         else {
[16:20:41.653]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.653]                             info, version)
[16:20:41.653]                         }
[16:20:41.653]                         base::stop(msg)
[16:20:41.653]                       }
[16:20:41.653]                     })
[16:20:41.653]                   }
[16:20:41.653]                   ...future.strategy.old <- future::plan("list")
[16:20:41.653]                   options(future.plan = NULL)
[16:20:41.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.653]                 }
[16:20:41.653]                 ...future.workdir <- getwd()
[16:20:41.653]             }
[16:20:41.653]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.653]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.653]         }
[16:20:41.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.653]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.653]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.653]             base::names(...future.oldOptions))
[16:20:41.653]     }
[16:20:41.653]     if (FALSE) {
[16:20:41.653]     }
[16:20:41.653]     else {
[16:20:41.653]         if (TRUE) {
[16:20:41.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.653]                 open = "w")
[16:20:41.653]         }
[16:20:41.653]         else {
[16:20:41.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.653]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.653]         }
[16:20:41.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.653]             base::sink(type = "output", split = FALSE)
[16:20:41.653]             base::close(...future.stdout)
[16:20:41.653]         }, add = TRUE)
[16:20:41.653]     }
[16:20:41.653]     ...future.frame <- base::sys.nframe()
[16:20:41.653]     ...future.conditions <- base::list()
[16:20:41.653]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.653]     if (FALSE) {
[16:20:41.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.653]     }
[16:20:41.653]     ...future.result <- base::tryCatch({
[16:20:41.653]         base::withCallingHandlers({
[16:20:41.653]             ...future.value <- base::withVisible(base::local({
[16:20:41.653]                 4
[16:20:41.653]             }))
[16:20:41.653]             future::FutureResult(value = ...future.value$value, 
[16:20:41.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.653]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.653]                     ...future.globalenv.names))
[16:20:41.653]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.653]         }, condition = base::local({
[16:20:41.653]             c <- base::c
[16:20:41.653]             inherits <- base::inherits
[16:20:41.653]             invokeRestart <- base::invokeRestart
[16:20:41.653]             length <- base::length
[16:20:41.653]             list <- base::list
[16:20:41.653]             seq.int <- base::seq.int
[16:20:41.653]             signalCondition <- base::signalCondition
[16:20:41.653]             sys.calls <- base::sys.calls
[16:20:41.653]             `[[` <- base::`[[`
[16:20:41.653]             `+` <- base::`+`
[16:20:41.653]             `<<-` <- base::`<<-`
[16:20:41.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.653]                   3L)]
[16:20:41.653]             }
[16:20:41.653]             function(cond) {
[16:20:41.653]                 is_error <- inherits(cond, "error")
[16:20:41.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.653]                   NULL)
[16:20:41.653]                 if (is_error) {
[16:20:41.653]                   sessionInformation <- function() {
[16:20:41.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.653]                       search = base::search(), system = base::Sys.info())
[16:20:41.653]                   }
[16:20:41.653]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.653]                     cond$call), session = sessionInformation(), 
[16:20:41.653]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.653]                   signalCondition(cond)
[16:20:41.653]                 }
[16:20:41.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.653]                 "immediateCondition"))) {
[16:20:41.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.653]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.653]                   if (TRUE && !signal) {
[16:20:41.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.653]                     {
[16:20:41.653]                       inherits <- base::inherits
[16:20:41.653]                       invokeRestart <- base::invokeRestart
[16:20:41.653]                       is.null <- base::is.null
[16:20:41.653]                       muffled <- FALSE
[16:20:41.653]                       if (inherits(cond, "message")) {
[16:20:41.653]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.653]                         if (muffled) 
[16:20:41.653]                           invokeRestart("muffleMessage")
[16:20:41.653]                       }
[16:20:41.653]                       else if (inherits(cond, "warning")) {
[16:20:41.653]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.653]                         if (muffled) 
[16:20:41.653]                           invokeRestart("muffleWarning")
[16:20:41.653]                       }
[16:20:41.653]                       else if (inherits(cond, "condition")) {
[16:20:41.653]                         if (!is.null(pattern)) {
[16:20:41.653]                           computeRestarts <- base::computeRestarts
[16:20:41.653]                           grepl <- base::grepl
[16:20:41.653]                           restarts <- computeRestarts(cond)
[16:20:41.653]                           for (restart in restarts) {
[16:20:41.653]                             name <- restart$name
[16:20:41.653]                             if (is.null(name)) 
[16:20:41.653]                               next
[16:20:41.653]                             if (!grepl(pattern, name)) 
[16:20:41.653]                               next
[16:20:41.653]                             invokeRestart(restart)
[16:20:41.653]                             muffled <- TRUE
[16:20:41.653]                             break
[16:20:41.653]                           }
[16:20:41.653]                         }
[16:20:41.653]                       }
[16:20:41.653]                       invisible(muffled)
[16:20:41.653]                     }
[16:20:41.653]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.653]                   }
[16:20:41.653]                 }
[16:20:41.653]                 else {
[16:20:41.653]                   if (TRUE) {
[16:20:41.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.653]                     {
[16:20:41.653]                       inherits <- base::inherits
[16:20:41.653]                       invokeRestart <- base::invokeRestart
[16:20:41.653]                       is.null <- base::is.null
[16:20:41.653]                       muffled <- FALSE
[16:20:41.653]                       if (inherits(cond, "message")) {
[16:20:41.653]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.653]                         if (muffled) 
[16:20:41.653]                           invokeRestart("muffleMessage")
[16:20:41.653]                       }
[16:20:41.653]                       else if (inherits(cond, "warning")) {
[16:20:41.653]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.653]                         if (muffled) 
[16:20:41.653]                           invokeRestart("muffleWarning")
[16:20:41.653]                       }
[16:20:41.653]                       else if (inherits(cond, "condition")) {
[16:20:41.653]                         if (!is.null(pattern)) {
[16:20:41.653]                           computeRestarts <- base::computeRestarts
[16:20:41.653]                           grepl <- base::grepl
[16:20:41.653]                           restarts <- computeRestarts(cond)
[16:20:41.653]                           for (restart in restarts) {
[16:20:41.653]                             name <- restart$name
[16:20:41.653]                             if (is.null(name)) 
[16:20:41.653]                               next
[16:20:41.653]                             if (!grepl(pattern, name)) 
[16:20:41.653]                               next
[16:20:41.653]                             invokeRestart(restart)
[16:20:41.653]                             muffled <- TRUE
[16:20:41.653]                             break
[16:20:41.653]                           }
[16:20:41.653]                         }
[16:20:41.653]                       }
[16:20:41.653]                       invisible(muffled)
[16:20:41.653]                     }
[16:20:41.653]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.653]                   }
[16:20:41.653]                 }
[16:20:41.653]             }
[16:20:41.653]         }))
[16:20:41.653]     }, error = function(ex) {
[16:20:41.653]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.653]                 ...future.rng), started = ...future.startTime, 
[16:20:41.653]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.653]             version = "1.8"), class = "FutureResult")
[16:20:41.653]     }, finally = {
[16:20:41.653]         if (!identical(...future.workdir, getwd())) 
[16:20:41.653]             setwd(...future.workdir)
[16:20:41.653]         {
[16:20:41.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.653]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.653]             }
[16:20:41.653]             base::options(...future.oldOptions)
[16:20:41.653]             if (.Platform$OS.type == "windows") {
[16:20:41.653]                 old_names <- names(...future.oldEnvVars)
[16:20:41.653]                 envs <- base::Sys.getenv()
[16:20:41.653]                 names <- names(envs)
[16:20:41.653]                 common <- intersect(names, old_names)
[16:20:41.653]                 added <- setdiff(names, old_names)
[16:20:41.653]                 removed <- setdiff(old_names, names)
[16:20:41.653]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.653]                   envs[common]]
[16:20:41.653]                 NAMES <- toupper(changed)
[16:20:41.653]                 args <- list()
[16:20:41.653]                 for (kk in seq_along(NAMES)) {
[16:20:41.653]                   name <- changed[[kk]]
[16:20:41.653]                   NAME <- NAMES[[kk]]
[16:20:41.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.653]                     next
[16:20:41.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.653]                 }
[16:20:41.653]                 NAMES <- toupper(added)
[16:20:41.653]                 for (kk in seq_along(NAMES)) {
[16:20:41.653]                   name <- added[[kk]]
[16:20:41.653]                   NAME <- NAMES[[kk]]
[16:20:41.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.653]                     next
[16:20:41.653]                   args[[name]] <- ""
[16:20:41.653]                 }
[16:20:41.653]                 NAMES <- toupper(removed)
[16:20:41.653]                 for (kk in seq_along(NAMES)) {
[16:20:41.653]                   name <- removed[[kk]]
[16:20:41.653]                   NAME <- NAMES[[kk]]
[16:20:41.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.653]                     next
[16:20:41.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.653]                 }
[16:20:41.653]                 if (length(args) > 0) 
[16:20:41.653]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.653]             }
[16:20:41.653]             else {
[16:20:41.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.653]             }
[16:20:41.653]             {
[16:20:41.653]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.653]                   0L) {
[16:20:41.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.653]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.653]                   base::options(opts)
[16:20:41.653]                 }
[16:20:41.653]                 {
[16:20:41.653]                   {
[16:20:41.653]                     NULL
[16:20:41.653]                     RNGkind("Mersenne-Twister")
[16:20:41.653]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.653]                       inherits = FALSE)
[16:20:41.653]                   }
[16:20:41.653]                   options(future.plan = NULL)
[16:20:41.653]                   if (is.na(NA_character_)) 
[16:20:41.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.653]                     .init = FALSE)
[16:20:41.653]                 }
[16:20:41.653]             }
[16:20:41.653]         }
[16:20:41.653]     })
[16:20:41.653]     if (TRUE) {
[16:20:41.653]         base::sink(type = "output", split = FALSE)
[16:20:41.653]         if (TRUE) {
[16:20:41.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.653]         }
[16:20:41.653]         else {
[16:20:41.653]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.653]         }
[16:20:41.653]         base::close(...future.stdout)
[16:20:41.653]         ...future.stdout <- NULL
[16:20:41.653]     }
[16:20:41.653]     ...future.result$conditions <- ...future.conditions
[16:20:41.653]     ...future.result$finished <- base::Sys.time()
[16:20:41.653]     ...future.result
[16:20:41.653] }
[16:20:41.655] plan(): Setting new future strategy stack:
[16:20:41.655] List of future strategies:
[16:20:41.655] 1. sequential:
[16:20:41.655]    - args: function (..., envir = parent.frame())
[16:20:41.655]    - tweaked: FALSE
[16:20:41.655]    - call: NULL
[16:20:41.656] plan(): nbrOfWorkers() = 1
[16:20:41.656] plan(): Setting new future strategy stack:
[16:20:41.656] List of future strategies:
[16:20:41.656] 1. sequential:
[16:20:41.656]    - args: function (..., envir = parent.frame())
[16:20:41.656]    - tweaked: FALSE
[16:20:41.656]    - call: plan(strategy)
[16:20:41.657] plan(): nbrOfWorkers() = 1
[16:20:41.657] SequentialFuture started (and completed)
[16:20:41.657] - Launch lazy future ... done
[16:20:41.657] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0af44420> 
Classes 'listenv', 'environment' <environment: 0x55ed0c75ee50> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:41.662] resolved() for ‘SequentialFuture’ ...
[16:20:41.662] - state: ‘finished’
[16:20:41.662] - run: TRUE
[16:20:41.662] - result: ‘FutureResult’
[16:20:41.662] resolved() for ‘SequentialFuture’ ... done
[16:20:41.662] resolved() for ‘SequentialFuture’ ...
[16:20:41.662] - state: ‘finished’
[16:20:41.663] - run: TRUE
[16:20:41.663] - result: ‘FutureResult’
[16:20:41.663] resolved() for ‘SequentialFuture’ ... done
[16:20:41.663] resolved() for ‘SequentialFuture’ ...
[16:20:41.663] - state: ‘finished’
[16:20:41.663] - run: TRUE
[16:20:41.663] - result: ‘FutureResult’
[16:20:41.663] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:41.666] resolve() on list environment ...
[16:20:41.666]  recursive: 0
[16:20:41.667]  length: 6
[16:20:41.667]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:41.667] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.667] - nx: 6
[16:20:41.667] - relay: TRUE
[16:20:41.667] - stdout: TRUE
[16:20:41.667] - signal: TRUE
[16:20:41.667] - resignal: FALSE
[16:20:41.667] - force: TRUE
[16:20:41.667] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.667] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.668]  - until=2
[16:20:41.668]  - relaying element #2
[16:20:41.668] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.668] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.668] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.668]  length: 5 (resolved future 1)
[16:20:41.668] resolved() for ‘SequentialFuture’ ...
[16:20:41.668] - state: ‘finished’
[16:20:41.668] - run: TRUE
[16:20:41.668] - result: ‘FutureResult’
[16:20:41.668] resolved() for ‘SequentialFuture’ ... done
[16:20:41.669] Future #2
[16:20:41.669] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.669] - nx: 6
[16:20:41.669] - relay: TRUE
[16:20:41.669] - stdout: TRUE
[16:20:41.669] - signal: TRUE
[16:20:41.669] - resignal: FALSE
[16:20:41.669] - force: TRUE
[16:20:41.669] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.669] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.669]  - until=2
[16:20:41.670]  - relaying element #2
[16:20:41.670] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.670] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.670] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.670]  length: 4 (resolved future 2)
[16:20:41.670] resolved() for ‘SequentialFuture’ ...
[16:20:41.670] - state: ‘finished’
[16:20:41.670] - run: TRUE
[16:20:41.670] - result: ‘FutureResult’
[16:20:41.670] resolved() for ‘SequentialFuture’ ... done
[16:20:41.671] Future #3
[16:20:41.671] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.671] - nx: 6
[16:20:41.671] - relay: TRUE
[16:20:41.671] - stdout: TRUE
[16:20:41.671] - signal: TRUE
[16:20:41.671] - resignal: FALSE
[16:20:41.671] - force: TRUE
[16:20:41.671] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.671] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.671]  - until=3
[16:20:41.671]  - relaying element #3
[16:20:41.672] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.672] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.672] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.672]  length: 3 (resolved future 3)
[16:20:41.672] resolved() for ‘SequentialFuture’ ...
[16:20:41.672] - state: ‘finished’
[16:20:41.672] - run: TRUE
[16:20:41.672] - result: ‘FutureResult’
[16:20:41.672] resolved() for ‘SequentialFuture’ ... done
[16:20:41.672] Future #4
[16:20:41.673] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.673] - nx: 6
[16:20:41.673] - relay: TRUE
[16:20:41.673] - stdout: TRUE
[16:20:41.673] - signal: TRUE
[16:20:41.673] - resignal: FALSE
[16:20:41.673] - force: TRUE
[16:20:41.673] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.673] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.673]  - until=4
[16:20:41.673]  - relaying element #4
[16:20:41.674] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.674] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.674] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.674]  length: 2 (resolved future 4)
[16:20:41.674] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.674] - nx: 6
[16:20:41.674] - relay: TRUE
[16:20:41.674] - stdout: TRUE
[16:20:41.674] - signal: TRUE
[16:20:41.674] - resignal: FALSE
[16:20:41.674] - force: TRUE
[16:20:41.674] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.675] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.675]  - until=6
[16:20:41.675]  - relaying element #6
[16:20:41.675] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.675] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.675] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.675]  length: 1 (resolved future 5)
[16:20:41.675] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.675] - nx: 6
[16:20:41.675] - relay: TRUE
[16:20:41.675] - stdout: TRUE
[16:20:41.675] - signal: TRUE
[16:20:41.676] - resignal: FALSE
[16:20:41.676] - force: TRUE
[16:20:41.676] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.676] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.676]  - until=6
[16:20:41.676] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.676] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.676] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.676]  length: 0 (resolved future 6)
[16:20:41.676] Relaying remaining futures
[16:20:41.676] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.677] - nx: 6
[16:20:41.677] - relay: TRUE
[16:20:41.677] - stdout: TRUE
[16:20:41.677] - signal: TRUE
[16:20:41.677] - resignal: FALSE
[16:20:41.677] - force: TRUE
[16:20:41.677] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.677] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:41.677] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.677] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.677] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.677] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55ed0ae0bc88> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:20:41.679] getGlobalsAndPackages() ...
[16:20:41.680] Searching for globals...
[16:20:41.680] 
[16:20:41.680] Searching for globals ... DONE
[16:20:41.680] - globals: [0] <none>
[16:20:41.680] getGlobalsAndPackages() ... DONE
[16:20:41.680] run() for ‘Future’ ...
[16:20:41.680] - state: ‘created’
[16:20:41.681] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.681] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.681]   - Field: ‘label’
[16:20:41.681]   - Field: ‘local’
[16:20:41.681]   - Field: ‘owner’
[16:20:41.681]   - Field: ‘envir’
[16:20:41.682]   - Field: ‘packages’
[16:20:41.682]   - Field: ‘gc’
[16:20:41.682]   - Field: ‘conditions’
[16:20:41.683]   - Field: ‘expr’
[16:20:41.683]   - Field: ‘uuid’
[16:20:41.683]   - Field: ‘seed’
[16:20:41.683]   - Field: ‘version’
[16:20:41.683]   - Field: ‘result’
[16:20:41.683]   - Field: ‘asynchronous’
[16:20:41.683]   - Field: ‘calls’
[16:20:41.683]   - Field: ‘globals’
[16:20:41.683]   - Field: ‘stdout’
[16:20:41.683]   - Field: ‘earlySignal’
[16:20:41.683]   - Field: ‘lazy’
[16:20:41.684]   - Field: ‘state’
[16:20:41.684] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.684] - Launch lazy future ...
[16:20:41.684] Packages needed by the future expression (n = 0): <none>
[16:20:41.684] Packages needed by future strategies (n = 0): <none>
[16:20:41.684] {
[16:20:41.684]     {
[16:20:41.684]         {
[16:20:41.684]             ...future.startTime <- base::Sys.time()
[16:20:41.684]             {
[16:20:41.684]                 {
[16:20:41.684]                   {
[16:20:41.684]                     base::local({
[16:20:41.684]                       has_future <- base::requireNamespace("future", 
[16:20:41.684]                         quietly = TRUE)
[16:20:41.684]                       if (has_future) {
[16:20:41.684]                         ns <- base::getNamespace("future")
[16:20:41.684]                         version <- ns[[".package"]][["version"]]
[16:20:41.684]                         if (is.null(version)) 
[16:20:41.684]                           version <- utils::packageVersion("future")
[16:20:41.684]                       }
[16:20:41.684]                       else {
[16:20:41.684]                         version <- NULL
[16:20:41.684]                       }
[16:20:41.684]                       if (!has_future || version < "1.8.0") {
[16:20:41.684]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.684]                           "", base::R.version$version.string), 
[16:20:41.684]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.684]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.684]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.684]                             "release", "version")], collapse = " "), 
[16:20:41.684]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.684]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.684]                           info)
[16:20:41.684]                         info <- base::paste(info, collapse = "; ")
[16:20:41.684]                         if (!has_future) {
[16:20:41.684]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.684]                             info)
[16:20:41.684]                         }
[16:20:41.684]                         else {
[16:20:41.684]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.684]                             info, version)
[16:20:41.684]                         }
[16:20:41.684]                         base::stop(msg)
[16:20:41.684]                       }
[16:20:41.684]                     })
[16:20:41.684]                   }
[16:20:41.684]                   ...future.strategy.old <- future::plan("list")
[16:20:41.684]                   options(future.plan = NULL)
[16:20:41.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.684]                 }
[16:20:41.684]                 ...future.workdir <- getwd()
[16:20:41.684]             }
[16:20:41.684]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.684]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.684]         }
[16:20:41.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.684]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.684]             base::names(...future.oldOptions))
[16:20:41.684]     }
[16:20:41.684]     if (FALSE) {
[16:20:41.684]     }
[16:20:41.684]     else {
[16:20:41.684]         if (TRUE) {
[16:20:41.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.684]                 open = "w")
[16:20:41.684]         }
[16:20:41.684]         else {
[16:20:41.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.684]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.684]         }
[16:20:41.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.684]             base::sink(type = "output", split = FALSE)
[16:20:41.684]             base::close(...future.stdout)
[16:20:41.684]         }, add = TRUE)
[16:20:41.684]     }
[16:20:41.684]     ...future.frame <- base::sys.nframe()
[16:20:41.684]     ...future.conditions <- base::list()
[16:20:41.684]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.684]     if (FALSE) {
[16:20:41.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.684]     }
[16:20:41.684]     ...future.result <- base::tryCatch({
[16:20:41.684]         base::withCallingHandlers({
[16:20:41.684]             ...future.value <- base::withVisible(base::local(2))
[16:20:41.684]             future::FutureResult(value = ...future.value$value, 
[16:20:41.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.684]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.684]                     ...future.globalenv.names))
[16:20:41.684]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.684]         }, condition = base::local({
[16:20:41.684]             c <- base::c
[16:20:41.684]             inherits <- base::inherits
[16:20:41.684]             invokeRestart <- base::invokeRestart
[16:20:41.684]             length <- base::length
[16:20:41.684]             list <- base::list
[16:20:41.684]             seq.int <- base::seq.int
[16:20:41.684]             signalCondition <- base::signalCondition
[16:20:41.684]             sys.calls <- base::sys.calls
[16:20:41.684]             `[[` <- base::`[[`
[16:20:41.684]             `+` <- base::`+`
[16:20:41.684]             `<<-` <- base::`<<-`
[16:20:41.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.684]                   3L)]
[16:20:41.684]             }
[16:20:41.684]             function(cond) {
[16:20:41.684]                 is_error <- inherits(cond, "error")
[16:20:41.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.684]                   NULL)
[16:20:41.684]                 if (is_error) {
[16:20:41.684]                   sessionInformation <- function() {
[16:20:41.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.684]                       search = base::search(), system = base::Sys.info())
[16:20:41.684]                   }
[16:20:41.684]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.684]                     cond$call), session = sessionInformation(), 
[16:20:41.684]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.684]                   signalCondition(cond)
[16:20:41.684]                 }
[16:20:41.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.684]                 "immediateCondition"))) {
[16:20:41.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.684]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.684]                   if (TRUE && !signal) {
[16:20:41.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.684]                     {
[16:20:41.684]                       inherits <- base::inherits
[16:20:41.684]                       invokeRestart <- base::invokeRestart
[16:20:41.684]                       is.null <- base::is.null
[16:20:41.684]                       muffled <- FALSE
[16:20:41.684]                       if (inherits(cond, "message")) {
[16:20:41.684]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.684]                         if (muffled) 
[16:20:41.684]                           invokeRestart("muffleMessage")
[16:20:41.684]                       }
[16:20:41.684]                       else if (inherits(cond, "warning")) {
[16:20:41.684]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.684]                         if (muffled) 
[16:20:41.684]                           invokeRestart("muffleWarning")
[16:20:41.684]                       }
[16:20:41.684]                       else if (inherits(cond, "condition")) {
[16:20:41.684]                         if (!is.null(pattern)) {
[16:20:41.684]                           computeRestarts <- base::computeRestarts
[16:20:41.684]                           grepl <- base::grepl
[16:20:41.684]                           restarts <- computeRestarts(cond)
[16:20:41.684]                           for (restart in restarts) {
[16:20:41.684]                             name <- restart$name
[16:20:41.684]                             if (is.null(name)) 
[16:20:41.684]                               next
[16:20:41.684]                             if (!grepl(pattern, name)) 
[16:20:41.684]                               next
[16:20:41.684]                             invokeRestart(restart)
[16:20:41.684]                             muffled <- TRUE
[16:20:41.684]                             break
[16:20:41.684]                           }
[16:20:41.684]                         }
[16:20:41.684]                       }
[16:20:41.684]                       invisible(muffled)
[16:20:41.684]                     }
[16:20:41.684]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.684]                   }
[16:20:41.684]                 }
[16:20:41.684]                 else {
[16:20:41.684]                   if (TRUE) {
[16:20:41.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.684]                     {
[16:20:41.684]                       inherits <- base::inherits
[16:20:41.684]                       invokeRestart <- base::invokeRestart
[16:20:41.684]                       is.null <- base::is.null
[16:20:41.684]                       muffled <- FALSE
[16:20:41.684]                       if (inherits(cond, "message")) {
[16:20:41.684]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.684]                         if (muffled) 
[16:20:41.684]                           invokeRestart("muffleMessage")
[16:20:41.684]                       }
[16:20:41.684]                       else if (inherits(cond, "warning")) {
[16:20:41.684]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.684]                         if (muffled) 
[16:20:41.684]                           invokeRestart("muffleWarning")
[16:20:41.684]                       }
[16:20:41.684]                       else if (inherits(cond, "condition")) {
[16:20:41.684]                         if (!is.null(pattern)) {
[16:20:41.684]                           computeRestarts <- base::computeRestarts
[16:20:41.684]                           grepl <- base::grepl
[16:20:41.684]                           restarts <- computeRestarts(cond)
[16:20:41.684]                           for (restart in restarts) {
[16:20:41.684]                             name <- restart$name
[16:20:41.684]                             if (is.null(name)) 
[16:20:41.684]                               next
[16:20:41.684]                             if (!grepl(pattern, name)) 
[16:20:41.684]                               next
[16:20:41.684]                             invokeRestart(restart)
[16:20:41.684]                             muffled <- TRUE
[16:20:41.684]                             break
[16:20:41.684]                           }
[16:20:41.684]                         }
[16:20:41.684]                       }
[16:20:41.684]                       invisible(muffled)
[16:20:41.684]                     }
[16:20:41.684]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.684]                   }
[16:20:41.684]                 }
[16:20:41.684]             }
[16:20:41.684]         }))
[16:20:41.684]     }, error = function(ex) {
[16:20:41.684]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.684]                 ...future.rng), started = ...future.startTime, 
[16:20:41.684]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.684]             version = "1.8"), class = "FutureResult")
[16:20:41.684]     }, finally = {
[16:20:41.684]         if (!identical(...future.workdir, getwd())) 
[16:20:41.684]             setwd(...future.workdir)
[16:20:41.684]         {
[16:20:41.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.684]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.684]             }
[16:20:41.684]             base::options(...future.oldOptions)
[16:20:41.684]             if (.Platform$OS.type == "windows") {
[16:20:41.684]                 old_names <- names(...future.oldEnvVars)
[16:20:41.684]                 envs <- base::Sys.getenv()
[16:20:41.684]                 names <- names(envs)
[16:20:41.684]                 common <- intersect(names, old_names)
[16:20:41.684]                 added <- setdiff(names, old_names)
[16:20:41.684]                 removed <- setdiff(old_names, names)
[16:20:41.684]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.684]                   envs[common]]
[16:20:41.684]                 NAMES <- toupper(changed)
[16:20:41.684]                 args <- list()
[16:20:41.684]                 for (kk in seq_along(NAMES)) {
[16:20:41.684]                   name <- changed[[kk]]
[16:20:41.684]                   NAME <- NAMES[[kk]]
[16:20:41.684]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.684]                     next
[16:20:41.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.684]                 }
[16:20:41.684]                 NAMES <- toupper(added)
[16:20:41.684]                 for (kk in seq_along(NAMES)) {
[16:20:41.684]                   name <- added[[kk]]
[16:20:41.684]                   NAME <- NAMES[[kk]]
[16:20:41.684]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.684]                     next
[16:20:41.684]                   args[[name]] <- ""
[16:20:41.684]                 }
[16:20:41.684]                 NAMES <- toupper(removed)
[16:20:41.684]                 for (kk in seq_along(NAMES)) {
[16:20:41.684]                   name <- removed[[kk]]
[16:20:41.684]                   NAME <- NAMES[[kk]]
[16:20:41.684]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.684]                     next
[16:20:41.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.684]                 }
[16:20:41.684]                 if (length(args) > 0) 
[16:20:41.684]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.684]             }
[16:20:41.684]             else {
[16:20:41.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.684]             }
[16:20:41.684]             {
[16:20:41.684]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.684]                   0L) {
[16:20:41.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.684]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.684]                   base::options(opts)
[16:20:41.684]                 }
[16:20:41.684]                 {
[16:20:41.684]                   {
[16:20:41.684]                     NULL
[16:20:41.684]                     RNGkind("Mersenne-Twister")
[16:20:41.684]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.684]                       inherits = FALSE)
[16:20:41.684]                   }
[16:20:41.684]                   options(future.plan = NULL)
[16:20:41.684]                   if (is.na(NA_character_)) 
[16:20:41.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.684]                     .init = FALSE)
[16:20:41.684]                 }
[16:20:41.684]             }
[16:20:41.684]         }
[16:20:41.684]     })
[16:20:41.684]     if (TRUE) {
[16:20:41.684]         base::sink(type = "output", split = FALSE)
[16:20:41.684]         if (TRUE) {
[16:20:41.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.684]         }
[16:20:41.684]         else {
[16:20:41.684]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.684]         }
[16:20:41.684]         base::close(...future.stdout)
[16:20:41.684]         ...future.stdout <- NULL
[16:20:41.684]     }
[16:20:41.684]     ...future.result$conditions <- ...future.conditions
[16:20:41.684]     ...future.result$finished <- base::Sys.time()
[16:20:41.684]     ...future.result
[16:20:41.684] }
[16:20:41.686] plan(): Setting new future strategy stack:
[16:20:41.686] List of future strategies:
[16:20:41.686] 1. sequential:
[16:20:41.686]    - args: function (..., envir = parent.frame())
[16:20:41.686]    - tweaked: FALSE
[16:20:41.686]    - call: NULL
[16:20:41.686] plan(): nbrOfWorkers() = 1
[16:20:41.687] plan(): Setting new future strategy stack:
[16:20:41.687] List of future strategies:
[16:20:41.687] 1. sequential:
[16:20:41.687]    - args: function (..., envir = parent.frame())
[16:20:41.687]    - tweaked: FALSE
[16:20:41.687]    - call: plan(strategy)
[16:20:41.688] plan(): nbrOfWorkers() = 1
[16:20:41.688] SequentialFuture started (and completed)
[16:20:41.688] - Launch lazy future ... done
[16:20:41.688] run() for ‘SequentialFuture’ ... done
[16:20:41.688] getGlobalsAndPackages() ...
[16:20:41.688] Searching for globals...
[16:20:41.688] 
[16:20:41.689] Searching for globals ... DONE
[16:20:41.689] - globals: [0] <none>
[16:20:41.689] getGlobalsAndPackages() ... DONE
[16:20:41.689] run() for ‘Future’ ...
[16:20:41.689] - state: ‘created’
[16:20:41.689] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.689] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.689] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.690]   - Field: ‘label’
[16:20:41.690]   - Field: ‘local’
[16:20:41.690]   - Field: ‘owner’
[16:20:41.690]   - Field: ‘envir’
[16:20:41.690]   - Field: ‘packages’
[16:20:41.690]   - Field: ‘gc’
[16:20:41.690]   - Field: ‘conditions’
[16:20:41.690]   - Field: ‘expr’
[16:20:41.690]   - Field: ‘uuid’
[16:20:41.690]   - Field: ‘seed’
[16:20:41.690]   - Field: ‘version’
[16:20:41.691]   - Field: ‘result’
[16:20:41.691]   - Field: ‘asynchronous’
[16:20:41.691]   - Field: ‘calls’
[16:20:41.691]   - Field: ‘globals’
[16:20:41.691]   - Field: ‘stdout’
[16:20:41.691]   - Field: ‘earlySignal’
[16:20:41.691]   - Field: ‘lazy’
[16:20:41.691]   - Field: ‘state’
[16:20:41.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.691] - Launch lazy future ...
[16:20:41.692] Packages needed by the future expression (n = 0): <none>
[16:20:41.692] Packages needed by future strategies (n = 0): <none>
[16:20:41.692] {
[16:20:41.692]     {
[16:20:41.692]         {
[16:20:41.692]             ...future.startTime <- base::Sys.time()
[16:20:41.692]             {
[16:20:41.692]                 {
[16:20:41.692]                   {
[16:20:41.692]                     base::local({
[16:20:41.692]                       has_future <- base::requireNamespace("future", 
[16:20:41.692]                         quietly = TRUE)
[16:20:41.692]                       if (has_future) {
[16:20:41.692]                         ns <- base::getNamespace("future")
[16:20:41.692]                         version <- ns[[".package"]][["version"]]
[16:20:41.692]                         if (is.null(version)) 
[16:20:41.692]                           version <- utils::packageVersion("future")
[16:20:41.692]                       }
[16:20:41.692]                       else {
[16:20:41.692]                         version <- NULL
[16:20:41.692]                       }
[16:20:41.692]                       if (!has_future || version < "1.8.0") {
[16:20:41.692]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.692]                           "", base::R.version$version.string), 
[16:20:41.692]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.692]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.692]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.692]                             "release", "version")], collapse = " "), 
[16:20:41.692]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.692]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.692]                           info)
[16:20:41.692]                         info <- base::paste(info, collapse = "; ")
[16:20:41.692]                         if (!has_future) {
[16:20:41.692]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.692]                             info)
[16:20:41.692]                         }
[16:20:41.692]                         else {
[16:20:41.692]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.692]                             info, version)
[16:20:41.692]                         }
[16:20:41.692]                         base::stop(msg)
[16:20:41.692]                       }
[16:20:41.692]                     })
[16:20:41.692]                   }
[16:20:41.692]                   ...future.strategy.old <- future::plan("list")
[16:20:41.692]                   options(future.plan = NULL)
[16:20:41.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.692]                 }
[16:20:41.692]                 ...future.workdir <- getwd()
[16:20:41.692]             }
[16:20:41.692]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.692]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.692]         }
[16:20:41.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.692]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.692]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.692]             base::names(...future.oldOptions))
[16:20:41.692]     }
[16:20:41.692]     if (FALSE) {
[16:20:41.692]     }
[16:20:41.692]     else {
[16:20:41.692]         if (TRUE) {
[16:20:41.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.692]                 open = "w")
[16:20:41.692]         }
[16:20:41.692]         else {
[16:20:41.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.692]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.692]         }
[16:20:41.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.692]             base::sink(type = "output", split = FALSE)
[16:20:41.692]             base::close(...future.stdout)
[16:20:41.692]         }, add = TRUE)
[16:20:41.692]     }
[16:20:41.692]     ...future.frame <- base::sys.nframe()
[16:20:41.692]     ...future.conditions <- base::list()
[16:20:41.692]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.692]     if (FALSE) {
[16:20:41.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.692]     }
[16:20:41.692]     ...future.result <- base::tryCatch({
[16:20:41.692]         base::withCallingHandlers({
[16:20:41.692]             ...future.value <- base::withVisible(base::local(NULL))
[16:20:41.692]             future::FutureResult(value = ...future.value$value, 
[16:20:41.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.692]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.692]                     ...future.globalenv.names))
[16:20:41.692]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.692]         }, condition = base::local({
[16:20:41.692]             c <- base::c
[16:20:41.692]             inherits <- base::inherits
[16:20:41.692]             invokeRestart <- base::invokeRestart
[16:20:41.692]             length <- base::length
[16:20:41.692]             list <- base::list
[16:20:41.692]             seq.int <- base::seq.int
[16:20:41.692]             signalCondition <- base::signalCondition
[16:20:41.692]             sys.calls <- base::sys.calls
[16:20:41.692]             `[[` <- base::`[[`
[16:20:41.692]             `+` <- base::`+`
[16:20:41.692]             `<<-` <- base::`<<-`
[16:20:41.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.692]                   3L)]
[16:20:41.692]             }
[16:20:41.692]             function(cond) {
[16:20:41.692]                 is_error <- inherits(cond, "error")
[16:20:41.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.692]                   NULL)
[16:20:41.692]                 if (is_error) {
[16:20:41.692]                   sessionInformation <- function() {
[16:20:41.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.692]                       search = base::search(), system = base::Sys.info())
[16:20:41.692]                   }
[16:20:41.692]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.692]                     cond$call), session = sessionInformation(), 
[16:20:41.692]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.692]                   signalCondition(cond)
[16:20:41.692]                 }
[16:20:41.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.692]                 "immediateCondition"))) {
[16:20:41.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.692]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.692]                   if (TRUE && !signal) {
[16:20:41.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.692]                     {
[16:20:41.692]                       inherits <- base::inherits
[16:20:41.692]                       invokeRestart <- base::invokeRestart
[16:20:41.692]                       is.null <- base::is.null
[16:20:41.692]                       muffled <- FALSE
[16:20:41.692]                       if (inherits(cond, "message")) {
[16:20:41.692]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.692]                         if (muffled) 
[16:20:41.692]                           invokeRestart("muffleMessage")
[16:20:41.692]                       }
[16:20:41.692]                       else if (inherits(cond, "warning")) {
[16:20:41.692]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.692]                         if (muffled) 
[16:20:41.692]                           invokeRestart("muffleWarning")
[16:20:41.692]                       }
[16:20:41.692]                       else if (inherits(cond, "condition")) {
[16:20:41.692]                         if (!is.null(pattern)) {
[16:20:41.692]                           computeRestarts <- base::computeRestarts
[16:20:41.692]                           grepl <- base::grepl
[16:20:41.692]                           restarts <- computeRestarts(cond)
[16:20:41.692]                           for (restart in restarts) {
[16:20:41.692]                             name <- restart$name
[16:20:41.692]                             if (is.null(name)) 
[16:20:41.692]                               next
[16:20:41.692]                             if (!grepl(pattern, name)) 
[16:20:41.692]                               next
[16:20:41.692]                             invokeRestart(restart)
[16:20:41.692]                             muffled <- TRUE
[16:20:41.692]                             break
[16:20:41.692]                           }
[16:20:41.692]                         }
[16:20:41.692]                       }
[16:20:41.692]                       invisible(muffled)
[16:20:41.692]                     }
[16:20:41.692]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.692]                   }
[16:20:41.692]                 }
[16:20:41.692]                 else {
[16:20:41.692]                   if (TRUE) {
[16:20:41.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.692]                     {
[16:20:41.692]                       inherits <- base::inherits
[16:20:41.692]                       invokeRestart <- base::invokeRestart
[16:20:41.692]                       is.null <- base::is.null
[16:20:41.692]                       muffled <- FALSE
[16:20:41.692]                       if (inherits(cond, "message")) {
[16:20:41.692]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.692]                         if (muffled) 
[16:20:41.692]                           invokeRestart("muffleMessage")
[16:20:41.692]                       }
[16:20:41.692]                       else if (inherits(cond, "warning")) {
[16:20:41.692]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.692]                         if (muffled) 
[16:20:41.692]                           invokeRestart("muffleWarning")
[16:20:41.692]                       }
[16:20:41.692]                       else if (inherits(cond, "condition")) {
[16:20:41.692]                         if (!is.null(pattern)) {
[16:20:41.692]                           computeRestarts <- base::computeRestarts
[16:20:41.692]                           grepl <- base::grepl
[16:20:41.692]                           restarts <- computeRestarts(cond)
[16:20:41.692]                           for (restart in restarts) {
[16:20:41.692]                             name <- restart$name
[16:20:41.692]                             if (is.null(name)) 
[16:20:41.692]                               next
[16:20:41.692]                             if (!grepl(pattern, name)) 
[16:20:41.692]                               next
[16:20:41.692]                             invokeRestart(restart)
[16:20:41.692]                             muffled <- TRUE
[16:20:41.692]                             break
[16:20:41.692]                           }
[16:20:41.692]                         }
[16:20:41.692]                       }
[16:20:41.692]                       invisible(muffled)
[16:20:41.692]                     }
[16:20:41.692]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.692]                   }
[16:20:41.692]                 }
[16:20:41.692]             }
[16:20:41.692]         }))
[16:20:41.692]     }, error = function(ex) {
[16:20:41.692]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.692]                 ...future.rng), started = ...future.startTime, 
[16:20:41.692]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.692]             version = "1.8"), class = "FutureResult")
[16:20:41.692]     }, finally = {
[16:20:41.692]         if (!identical(...future.workdir, getwd())) 
[16:20:41.692]             setwd(...future.workdir)
[16:20:41.692]         {
[16:20:41.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.692]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.692]             }
[16:20:41.692]             base::options(...future.oldOptions)
[16:20:41.692]             if (.Platform$OS.type == "windows") {
[16:20:41.692]                 old_names <- names(...future.oldEnvVars)
[16:20:41.692]                 envs <- base::Sys.getenv()
[16:20:41.692]                 names <- names(envs)
[16:20:41.692]                 common <- intersect(names, old_names)
[16:20:41.692]                 added <- setdiff(names, old_names)
[16:20:41.692]                 removed <- setdiff(old_names, names)
[16:20:41.692]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.692]                   envs[common]]
[16:20:41.692]                 NAMES <- toupper(changed)
[16:20:41.692]                 args <- list()
[16:20:41.692]                 for (kk in seq_along(NAMES)) {
[16:20:41.692]                   name <- changed[[kk]]
[16:20:41.692]                   NAME <- NAMES[[kk]]
[16:20:41.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.692]                     next
[16:20:41.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.692]                 }
[16:20:41.692]                 NAMES <- toupper(added)
[16:20:41.692]                 for (kk in seq_along(NAMES)) {
[16:20:41.692]                   name <- added[[kk]]
[16:20:41.692]                   NAME <- NAMES[[kk]]
[16:20:41.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.692]                     next
[16:20:41.692]                   args[[name]] <- ""
[16:20:41.692]                 }
[16:20:41.692]                 NAMES <- toupper(removed)
[16:20:41.692]                 for (kk in seq_along(NAMES)) {
[16:20:41.692]                   name <- removed[[kk]]
[16:20:41.692]                   NAME <- NAMES[[kk]]
[16:20:41.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.692]                     next
[16:20:41.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.692]                 }
[16:20:41.692]                 if (length(args) > 0) 
[16:20:41.692]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.692]             }
[16:20:41.692]             else {
[16:20:41.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.692]             }
[16:20:41.692]             {
[16:20:41.692]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.692]                   0L) {
[16:20:41.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.692]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.692]                   base::options(opts)
[16:20:41.692]                 }
[16:20:41.692]                 {
[16:20:41.692]                   {
[16:20:41.692]                     NULL
[16:20:41.692]                     RNGkind("Mersenne-Twister")
[16:20:41.692]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.692]                       inherits = FALSE)
[16:20:41.692]                   }
[16:20:41.692]                   options(future.plan = NULL)
[16:20:41.692]                   if (is.na(NA_character_)) 
[16:20:41.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.692]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.692]                     .init = FALSE)
[16:20:41.692]                 }
[16:20:41.692]             }
[16:20:41.692]         }
[16:20:41.692]     })
[16:20:41.692]     if (TRUE) {
[16:20:41.692]         base::sink(type = "output", split = FALSE)
[16:20:41.692]         if (TRUE) {
[16:20:41.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.692]         }
[16:20:41.692]         else {
[16:20:41.692]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.692]         }
[16:20:41.692]         base::close(...future.stdout)
[16:20:41.692]         ...future.stdout <- NULL
[16:20:41.692]     }
[16:20:41.692]     ...future.result$conditions <- ...future.conditions
[16:20:41.692]     ...future.result$finished <- base::Sys.time()
[16:20:41.692]     ...future.result
[16:20:41.692] }
[16:20:41.694] plan(): Setting new future strategy stack:
[16:20:41.694] List of future strategies:
[16:20:41.694] 1. sequential:
[16:20:41.694]    - args: function (..., envir = parent.frame())
[16:20:41.694]    - tweaked: FALSE
[16:20:41.694]    - call: NULL
[16:20:41.694] plan(): nbrOfWorkers() = 1
[16:20:41.695] plan(): Setting new future strategy stack:
[16:20:41.695] List of future strategies:
[16:20:41.695] 1. sequential:
[16:20:41.695]    - args: function (..., envir = parent.frame())
[16:20:41.695]    - tweaked: FALSE
[16:20:41.695]    - call: plan(strategy)
[16:20:41.695] plan(): nbrOfWorkers() = 1
[16:20:41.695] SequentialFuture started (and completed)
[16:20:41.695] - Launch lazy future ... done
[16:20:41.696] run() for ‘SequentialFuture’ ... done
[16:20:41.696] getGlobalsAndPackages() ...
[16:20:41.696] Searching for globals...
[16:20:41.696] - globals found: [1] ‘{’
[16:20:41.697] Searching for globals ... DONE
[16:20:41.697] Resolving globals: FALSE
[16:20:41.697] 
[16:20:41.697] 
[16:20:41.697] getGlobalsAndPackages() ... DONE
[16:20:41.697] run() for ‘Future’ ...
[16:20:41.697] - state: ‘created’
[16:20:41.698] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:41.698] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:41.698] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:41.698]   - Field: ‘label’
[16:20:41.698]   - Field: ‘local’
[16:20:41.698]   - Field: ‘owner’
[16:20:41.698]   - Field: ‘envir’
[16:20:41.698]   - Field: ‘packages’
[16:20:41.698]   - Field: ‘gc’
[16:20:41.699]   - Field: ‘conditions’
[16:20:41.699]   - Field: ‘expr’
[16:20:41.699]   - Field: ‘uuid’
[16:20:41.699]   - Field: ‘seed’
[16:20:41.699]   - Field: ‘version’
[16:20:41.699]   - Field: ‘result’
[16:20:41.699]   - Field: ‘asynchronous’
[16:20:41.699]   - Field: ‘calls’
[16:20:41.699]   - Field: ‘globals’
[16:20:41.699]   - Field: ‘stdout’
[16:20:41.699]   - Field: ‘earlySignal’
[16:20:41.699]   - Field: ‘lazy’
[16:20:41.700]   - Field: ‘state’
[16:20:41.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:41.700] - Launch lazy future ...
[16:20:41.700] Packages needed by the future expression (n = 0): <none>
[16:20:41.700] Packages needed by future strategies (n = 0): <none>
[16:20:41.700] {
[16:20:41.700]     {
[16:20:41.700]         {
[16:20:41.700]             ...future.startTime <- base::Sys.time()
[16:20:41.700]             {
[16:20:41.700]                 {
[16:20:41.700]                   {
[16:20:41.700]                     base::local({
[16:20:41.700]                       has_future <- base::requireNamespace("future", 
[16:20:41.700]                         quietly = TRUE)
[16:20:41.700]                       if (has_future) {
[16:20:41.700]                         ns <- base::getNamespace("future")
[16:20:41.700]                         version <- ns[[".package"]][["version"]]
[16:20:41.700]                         if (is.null(version)) 
[16:20:41.700]                           version <- utils::packageVersion("future")
[16:20:41.700]                       }
[16:20:41.700]                       else {
[16:20:41.700]                         version <- NULL
[16:20:41.700]                       }
[16:20:41.700]                       if (!has_future || version < "1.8.0") {
[16:20:41.700]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.700]                           "", base::R.version$version.string), 
[16:20:41.700]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:41.700]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.700]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.700]                             "release", "version")], collapse = " "), 
[16:20:41.700]                           hostname = base::Sys.info()[["nodename"]])
[16:20:41.700]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.700]                           info)
[16:20:41.700]                         info <- base::paste(info, collapse = "; ")
[16:20:41.700]                         if (!has_future) {
[16:20:41.700]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.700]                             info)
[16:20:41.700]                         }
[16:20:41.700]                         else {
[16:20:41.700]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.700]                             info, version)
[16:20:41.700]                         }
[16:20:41.700]                         base::stop(msg)
[16:20:41.700]                       }
[16:20:41.700]                     })
[16:20:41.700]                   }
[16:20:41.700]                   ...future.strategy.old <- future::plan("list")
[16:20:41.700]                   options(future.plan = NULL)
[16:20:41.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.700]                 }
[16:20:41.700]                 ...future.workdir <- getwd()
[16:20:41.700]             }
[16:20:41.700]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.700]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.700]         }
[16:20:41.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.700]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.700]             base::names(...future.oldOptions))
[16:20:41.700]     }
[16:20:41.700]     if (FALSE) {
[16:20:41.700]     }
[16:20:41.700]     else {
[16:20:41.700]         if (TRUE) {
[16:20:41.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.700]                 open = "w")
[16:20:41.700]         }
[16:20:41.700]         else {
[16:20:41.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.700]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.700]         }
[16:20:41.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.700]             base::sink(type = "output", split = FALSE)
[16:20:41.700]             base::close(...future.stdout)
[16:20:41.700]         }, add = TRUE)
[16:20:41.700]     }
[16:20:41.700]     ...future.frame <- base::sys.nframe()
[16:20:41.700]     ...future.conditions <- base::list()
[16:20:41.700]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.700]     if (FALSE) {
[16:20:41.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.700]     }
[16:20:41.700]     ...future.result <- base::tryCatch({
[16:20:41.700]         base::withCallingHandlers({
[16:20:41.700]             ...future.value <- base::withVisible(base::local({
[16:20:41.700]                 4
[16:20:41.700]             }))
[16:20:41.700]             future::FutureResult(value = ...future.value$value, 
[16:20:41.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.700]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.700]                     ...future.globalenv.names))
[16:20:41.700]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.700]         }, condition = base::local({
[16:20:41.700]             c <- base::c
[16:20:41.700]             inherits <- base::inherits
[16:20:41.700]             invokeRestart <- base::invokeRestart
[16:20:41.700]             length <- base::length
[16:20:41.700]             list <- base::list
[16:20:41.700]             seq.int <- base::seq.int
[16:20:41.700]             signalCondition <- base::signalCondition
[16:20:41.700]             sys.calls <- base::sys.calls
[16:20:41.700]             `[[` <- base::`[[`
[16:20:41.700]             `+` <- base::`+`
[16:20:41.700]             `<<-` <- base::`<<-`
[16:20:41.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.700]                   3L)]
[16:20:41.700]             }
[16:20:41.700]             function(cond) {
[16:20:41.700]                 is_error <- inherits(cond, "error")
[16:20:41.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.700]                   NULL)
[16:20:41.700]                 if (is_error) {
[16:20:41.700]                   sessionInformation <- function() {
[16:20:41.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.700]                       search = base::search(), system = base::Sys.info())
[16:20:41.700]                   }
[16:20:41.700]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.700]                     cond$call), session = sessionInformation(), 
[16:20:41.700]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.700]                   signalCondition(cond)
[16:20:41.700]                 }
[16:20:41.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.700]                 "immediateCondition"))) {
[16:20:41.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.700]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.700]                   if (TRUE && !signal) {
[16:20:41.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.700]                     {
[16:20:41.700]                       inherits <- base::inherits
[16:20:41.700]                       invokeRestart <- base::invokeRestart
[16:20:41.700]                       is.null <- base::is.null
[16:20:41.700]                       muffled <- FALSE
[16:20:41.700]                       if (inherits(cond, "message")) {
[16:20:41.700]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.700]                         if (muffled) 
[16:20:41.700]                           invokeRestart("muffleMessage")
[16:20:41.700]                       }
[16:20:41.700]                       else if (inherits(cond, "warning")) {
[16:20:41.700]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.700]                         if (muffled) 
[16:20:41.700]                           invokeRestart("muffleWarning")
[16:20:41.700]                       }
[16:20:41.700]                       else if (inherits(cond, "condition")) {
[16:20:41.700]                         if (!is.null(pattern)) {
[16:20:41.700]                           computeRestarts <- base::computeRestarts
[16:20:41.700]                           grepl <- base::grepl
[16:20:41.700]                           restarts <- computeRestarts(cond)
[16:20:41.700]                           for (restart in restarts) {
[16:20:41.700]                             name <- restart$name
[16:20:41.700]                             if (is.null(name)) 
[16:20:41.700]                               next
[16:20:41.700]                             if (!grepl(pattern, name)) 
[16:20:41.700]                               next
[16:20:41.700]                             invokeRestart(restart)
[16:20:41.700]                             muffled <- TRUE
[16:20:41.700]                             break
[16:20:41.700]                           }
[16:20:41.700]                         }
[16:20:41.700]                       }
[16:20:41.700]                       invisible(muffled)
[16:20:41.700]                     }
[16:20:41.700]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.700]                   }
[16:20:41.700]                 }
[16:20:41.700]                 else {
[16:20:41.700]                   if (TRUE) {
[16:20:41.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.700]                     {
[16:20:41.700]                       inherits <- base::inherits
[16:20:41.700]                       invokeRestart <- base::invokeRestart
[16:20:41.700]                       is.null <- base::is.null
[16:20:41.700]                       muffled <- FALSE
[16:20:41.700]                       if (inherits(cond, "message")) {
[16:20:41.700]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.700]                         if (muffled) 
[16:20:41.700]                           invokeRestart("muffleMessage")
[16:20:41.700]                       }
[16:20:41.700]                       else if (inherits(cond, "warning")) {
[16:20:41.700]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.700]                         if (muffled) 
[16:20:41.700]                           invokeRestart("muffleWarning")
[16:20:41.700]                       }
[16:20:41.700]                       else if (inherits(cond, "condition")) {
[16:20:41.700]                         if (!is.null(pattern)) {
[16:20:41.700]                           computeRestarts <- base::computeRestarts
[16:20:41.700]                           grepl <- base::grepl
[16:20:41.700]                           restarts <- computeRestarts(cond)
[16:20:41.700]                           for (restart in restarts) {
[16:20:41.700]                             name <- restart$name
[16:20:41.700]                             if (is.null(name)) 
[16:20:41.700]                               next
[16:20:41.700]                             if (!grepl(pattern, name)) 
[16:20:41.700]                               next
[16:20:41.700]                             invokeRestart(restart)
[16:20:41.700]                             muffled <- TRUE
[16:20:41.700]                             break
[16:20:41.700]                           }
[16:20:41.700]                         }
[16:20:41.700]                       }
[16:20:41.700]                       invisible(muffled)
[16:20:41.700]                     }
[16:20:41.700]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.700]                   }
[16:20:41.700]                 }
[16:20:41.700]             }
[16:20:41.700]         }))
[16:20:41.700]     }, error = function(ex) {
[16:20:41.700]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.700]                 ...future.rng), started = ...future.startTime, 
[16:20:41.700]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.700]             version = "1.8"), class = "FutureResult")
[16:20:41.700]     }, finally = {
[16:20:41.700]         if (!identical(...future.workdir, getwd())) 
[16:20:41.700]             setwd(...future.workdir)
[16:20:41.700]         {
[16:20:41.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.700]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.700]             }
[16:20:41.700]             base::options(...future.oldOptions)
[16:20:41.700]             if (.Platform$OS.type == "windows") {
[16:20:41.700]                 old_names <- names(...future.oldEnvVars)
[16:20:41.700]                 envs <- base::Sys.getenv()
[16:20:41.700]                 names <- names(envs)
[16:20:41.700]                 common <- intersect(names, old_names)
[16:20:41.700]                 added <- setdiff(names, old_names)
[16:20:41.700]                 removed <- setdiff(old_names, names)
[16:20:41.700]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.700]                   envs[common]]
[16:20:41.700]                 NAMES <- toupper(changed)
[16:20:41.700]                 args <- list()
[16:20:41.700]                 for (kk in seq_along(NAMES)) {
[16:20:41.700]                   name <- changed[[kk]]
[16:20:41.700]                   NAME <- NAMES[[kk]]
[16:20:41.700]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.700]                     next
[16:20:41.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.700]                 }
[16:20:41.700]                 NAMES <- toupper(added)
[16:20:41.700]                 for (kk in seq_along(NAMES)) {
[16:20:41.700]                   name <- added[[kk]]
[16:20:41.700]                   NAME <- NAMES[[kk]]
[16:20:41.700]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.700]                     next
[16:20:41.700]                   args[[name]] <- ""
[16:20:41.700]                 }
[16:20:41.700]                 NAMES <- toupper(removed)
[16:20:41.700]                 for (kk in seq_along(NAMES)) {
[16:20:41.700]                   name <- removed[[kk]]
[16:20:41.700]                   NAME <- NAMES[[kk]]
[16:20:41.700]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.700]                     next
[16:20:41.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.700]                 }
[16:20:41.700]                 if (length(args) > 0) 
[16:20:41.700]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.700]             }
[16:20:41.700]             else {
[16:20:41.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.700]             }
[16:20:41.700]             {
[16:20:41.700]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.700]                   0L) {
[16:20:41.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.700]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.700]                   base::options(opts)
[16:20:41.700]                 }
[16:20:41.700]                 {
[16:20:41.700]                   {
[16:20:41.700]                     NULL
[16:20:41.700]                     RNGkind("Mersenne-Twister")
[16:20:41.700]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:41.700]                       inherits = FALSE)
[16:20:41.700]                   }
[16:20:41.700]                   options(future.plan = NULL)
[16:20:41.700]                   if (is.na(NA_character_)) 
[16:20:41.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.700]                     .init = FALSE)
[16:20:41.700]                 }
[16:20:41.700]             }
[16:20:41.700]         }
[16:20:41.700]     })
[16:20:41.700]     if (TRUE) {
[16:20:41.700]         base::sink(type = "output", split = FALSE)
[16:20:41.700]         if (TRUE) {
[16:20:41.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.700]         }
[16:20:41.700]         else {
[16:20:41.700]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.700]         }
[16:20:41.700]         base::close(...future.stdout)
[16:20:41.700]         ...future.stdout <- NULL
[16:20:41.700]     }
[16:20:41.700]     ...future.result$conditions <- ...future.conditions
[16:20:41.700]     ...future.result$finished <- base::Sys.time()
[16:20:41.700]     ...future.result
[16:20:41.700] }
[16:20:41.702] plan(): Setting new future strategy stack:
[16:20:41.702] List of future strategies:
[16:20:41.702] 1. sequential:
[16:20:41.702]    - args: function (..., envir = parent.frame())
[16:20:41.702]    - tweaked: FALSE
[16:20:41.702]    - call: NULL
[16:20:41.703] plan(): nbrOfWorkers() = 1
[16:20:41.703] plan(): Setting new future strategy stack:
[16:20:41.703] List of future strategies:
[16:20:41.703] 1. sequential:
[16:20:41.703]    - args: function (..., envir = parent.frame())
[16:20:41.703]    - tweaked: FALSE
[16:20:41.703]    - call: plan(strategy)
[16:20:41.704] plan(): nbrOfWorkers() = 1
[16:20:41.704] SequentialFuture started (and completed)
[16:20:41.704] - Launch lazy future ... done
[16:20:41.704] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0c6b7520> 
Classes 'listenv', 'environment' <environment: 0x55ed0c35ed78> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:41.708] resolved() for ‘SequentialFuture’ ...
[16:20:41.708] - state: ‘finished’
[16:20:41.708] - run: TRUE
[16:20:41.708] - result: ‘FutureResult’
[16:20:41.708] resolved() for ‘SequentialFuture’ ... done
[16:20:41.708] resolved() for ‘SequentialFuture’ ...
[16:20:41.708] - state: ‘finished’
[16:20:41.708] - run: TRUE
[16:20:41.708] - result: ‘FutureResult’
[16:20:41.709] resolved() for ‘SequentialFuture’ ... done
[16:20:41.709] resolved() for ‘SequentialFuture’ ...
[16:20:41.709] - state: ‘finished’
[16:20:41.709] - run: TRUE
[16:20:41.709] - result: ‘FutureResult’
[16:20:41.709] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:41.713] resolve() on list environment ...
[16:20:41.713]  recursive: 0
[16:20:41.714]  length: 6
[16:20:41.714]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:41.714] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.714] - nx: 6
[16:20:41.714] - relay: TRUE
[16:20:41.714] - stdout: TRUE
[16:20:41.714] - signal: TRUE
[16:20:41.714] - resignal: FALSE
[16:20:41.714] - force: TRUE
[16:20:41.714] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.715] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.715]  - until=2
[16:20:41.715]  - relaying element #2
[16:20:41.715] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.715] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.715] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.715]  length: 5 (resolved future 1)
[16:20:41.715] resolved() for ‘SequentialFuture’ ...
[16:20:41.715] - state: ‘finished’
[16:20:41.715] - run: TRUE
[16:20:41.715] - result: ‘FutureResult’
[16:20:41.716] resolved() for ‘SequentialFuture’ ... done
[16:20:41.716] Future #2
[16:20:41.716] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:20:41.716] - nx: 6
[16:20:41.716] - relay: TRUE
[16:20:41.716] - stdout: TRUE
[16:20:41.716] - signal: TRUE
[16:20:41.716] - resignal: FALSE
[16:20:41.716] - force: TRUE
[16:20:41.716] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.716] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.717]  - until=2
[16:20:41.717]  - relaying element #2
[16:20:41.717] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.717] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.717] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:20:41.717]  length: 4 (resolved future 2)
[16:20:41.717] resolved() for ‘SequentialFuture’ ...
[16:20:41.717] - state: ‘finished’
[16:20:41.717] - run: TRUE
[16:20:41.717] - result: ‘FutureResult’
[16:20:41.718] resolved() for ‘SequentialFuture’ ... done
[16:20:41.718] Future #3
[16:20:41.718] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:20:41.718] - nx: 6
[16:20:41.718] - relay: TRUE
[16:20:41.718] - stdout: TRUE
[16:20:41.718] - signal: TRUE
[16:20:41.718] - resignal: FALSE
[16:20:41.718] - force: TRUE
[16:20:41.718] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.718] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.719]  - until=3
[16:20:41.719]  - relaying element #3
[16:20:41.719] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.719] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.719] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:20:41.719]  length: 3 (resolved future 3)
[16:20:41.719] resolved() for ‘SequentialFuture’ ...
[16:20:41.719] - state: ‘finished’
[16:20:41.719] - run: TRUE
[16:20:41.719] - result: ‘FutureResult’
[16:20:41.719] resolved() for ‘SequentialFuture’ ... done
[16:20:41.720] Future #4
[16:20:41.720] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:20:41.720] - nx: 6
[16:20:41.720] - relay: TRUE
[16:20:41.720] - stdout: TRUE
[16:20:41.720] - signal: TRUE
[16:20:41.720] - resignal: FALSE
[16:20:41.720] - force: TRUE
[16:20:41.720] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.720] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.720]  - until=4
[16:20:41.721]  - relaying element #4
[16:20:41.721] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.721] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.721] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:20:41.721]  length: 2 (resolved future 4)
[16:20:41.721] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.721] - nx: 6
[16:20:41.721] - relay: TRUE
[16:20:41.721] - stdout: TRUE
[16:20:41.721] - signal: TRUE
[16:20:41.721] - resignal: FALSE
[16:20:41.722] - force: TRUE
[16:20:41.722] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.722] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.722]  - until=6
[16:20:41.722]  - relaying element #6
[16:20:41.722] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.722] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.722] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.722]  length: 1 (resolved future 5)
[16:20:41.722] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.722] - nx: 6
[16:20:41.722] - relay: TRUE
[16:20:41.723] - stdout: TRUE
[16:20:41.723] - signal: TRUE
[16:20:41.723] - resignal: FALSE
[16:20:41.723] - force: TRUE
[16:20:41.723] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.723] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.723]  - until=6
[16:20:41.723] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.723] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.723] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.723]  length: 0 (resolved future 6)
[16:20:41.723] Relaying remaining futures
[16:20:41.723] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.724] - nx: 6
[16:20:41.724] - relay: TRUE
[16:20:41.724] - stdout: TRUE
[16:20:41.724] - signal: TRUE
[16:20:41.724] - resignal: FALSE
[16:20:41.724] - force: TRUE
[16:20:41.724] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.724] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:41.724] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.724] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.724] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.724] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55ed0ae11978> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[16:20:41.727] plan(): Setting new future strategy stack:
[16:20:41.727] List of future strategies:
[16:20:41.727] 1. multicore:
[16:20:41.727]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:41.727]    - tweaked: FALSE
[16:20:41.727]    - call: plan(strategy)
[16:20:41.731] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:20:41.732] getGlobalsAndPackages() ...
[16:20:41.732] Searching for globals...
[16:20:41.732] 
[16:20:41.732] Searching for globals ... DONE
[16:20:41.732] - globals: [0] <none>
[16:20:41.732] getGlobalsAndPackages() ... DONE
[16:20:41.733] run() for ‘Future’ ...
[16:20:41.733] - state: ‘created’
[16:20:41.733] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:41.736] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:41.736] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:41.737]   - Field: ‘label’
[16:20:41.737]   - Field: ‘local’
[16:20:41.737]   - Field: ‘owner’
[16:20:41.737]   - Field: ‘envir’
[16:20:41.737]   - Field: ‘workers’
[16:20:41.738]   - Field: ‘packages’
[16:20:41.738]   - Field: ‘gc’
[16:20:41.738]   - Field: ‘job’
[16:20:41.738]   - Field: ‘conditions’
[16:20:41.738]   - Field: ‘expr’
[16:20:41.738]   - Field: ‘uuid’
[16:20:41.739]   - Field: ‘seed’
[16:20:41.739]   - Field: ‘version’
[16:20:41.739]   - Field: ‘result’
[16:20:41.739]   - Field: ‘asynchronous’
[16:20:41.739]   - Field: ‘calls’
[16:20:41.739]   - Field: ‘globals’
[16:20:41.739]   - Field: ‘stdout’
[16:20:41.739]   - Field: ‘earlySignal’
[16:20:41.739]   - Field: ‘lazy’
[16:20:41.739]   - Field: ‘state’
[16:20:41.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:41.740] - Launch lazy future ...
[16:20:41.741] Packages needed by the future expression (n = 0): <none>
[16:20:41.741] Packages needed by future strategies (n = 0): <none>
[16:20:41.741] {
[16:20:41.741]     {
[16:20:41.741]         {
[16:20:41.741]             ...future.startTime <- base::Sys.time()
[16:20:41.741]             {
[16:20:41.741]                 {
[16:20:41.741]                   {
[16:20:41.741]                     {
[16:20:41.741]                       base::local({
[16:20:41.741]                         has_future <- base::requireNamespace("future", 
[16:20:41.741]                           quietly = TRUE)
[16:20:41.741]                         if (has_future) {
[16:20:41.741]                           ns <- base::getNamespace("future")
[16:20:41.741]                           version <- ns[[".package"]][["version"]]
[16:20:41.741]                           if (is.null(version)) 
[16:20:41.741]                             version <- utils::packageVersion("future")
[16:20:41.741]                         }
[16:20:41.741]                         else {
[16:20:41.741]                           version <- NULL
[16:20:41.741]                         }
[16:20:41.741]                         if (!has_future || version < "1.8.0") {
[16:20:41.741]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.741]                             "", base::R.version$version.string), 
[16:20:41.741]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:41.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.741]                               "release", "version")], collapse = " "), 
[16:20:41.741]                             hostname = base::Sys.info()[["nodename"]])
[16:20:41.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.741]                             info)
[16:20:41.741]                           info <- base::paste(info, collapse = "; ")
[16:20:41.741]                           if (!has_future) {
[16:20:41.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.741]                               info)
[16:20:41.741]                           }
[16:20:41.741]                           else {
[16:20:41.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.741]                               info, version)
[16:20:41.741]                           }
[16:20:41.741]                           base::stop(msg)
[16:20:41.741]                         }
[16:20:41.741]                       })
[16:20:41.741]                     }
[16:20:41.741]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:41.741]                     base::options(mc.cores = 1L)
[16:20:41.741]                   }
[16:20:41.741]                   ...future.strategy.old <- future::plan("list")
[16:20:41.741]                   options(future.plan = NULL)
[16:20:41.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.741]                 }
[16:20:41.741]                 ...future.workdir <- getwd()
[16:20:41.741]             }
[16:20:41.741]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.741]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.741]         }
[16:20:41.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.741]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.741]             base::names(...future.oldOptions))
[16:20:41.741]     }
[16:20:41.741]     if (FALSE) {
[16:20:41.741]     }
[16:20:41.741]     else {
[16:20:41.741]         if (TRUE) {
[16:20:41.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.741]                 open = "w")
[16:20:41.741]         }
[16:20:41.741]         else {
[16:20:41.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.741]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.741]         }
[16:20:41.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.741]             base::sink(type = "output", split = FALSE)
[16:20:41.741]             base::close(...future.stdout)
[16:20:41.741]         }, add = TRUE)
[16:20:41.741]     }
[16:20:41.741]     ...future.frame <- base::sys.nframe()
[16:20:41.741]     ...future.conditions <- base::list()
[16:20:41.741]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.741]     if (FALSE) {
[16:20:41.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.741]     }
[16:20:41.741]     ...future.result <- base::tryCatch({
[16:20:41.741]         base::withCallingHandlers({
[16:20:41.741]             ...future.value <- base::withVisible(base::local({
[16:20:41.741]                 withCallingHandlers({
[16:20:41.741]                   2
[16:20:41.741]                 }, immediateCondition = function(cond) {
[16:20:41.741]                   save_rds <- function (object, pathname, ...) 
[16:20:41.741]                   {
[16:20:41.741]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:41.741]                     if (file_test("-f", pathname_tmp)) {
[16:20:41.741]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.741]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:41.741]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.741]                         fi_tmp[["mtime"]])
[16:20:41.741]                     }
[16:20:41.741]                     tryCatch({
[16:20:41.741]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:41.741]                     }, error = function(ex) {
[16:20:41.741]                       msg <- conditionMessage(ex)
[16:20:41.741]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.741]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:41.741]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.741]                         fi_tmp[["mtime"]], msg)
[16:20:41.741]                       ex$message <- msg
[16:20:41.741]                       stop(ex)
[16:20:41.741]                     })
[16:20:41.741]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:41.741]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:41.741]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:41.741]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.741]                       fi <- file.info(pathname)
[16:20:41.741]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:41.741]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.741]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:41.741]                         fi[["size"]], fi[["mtime"]])
[16:20:41.741]                       stop(msg)
[16:20:41.741]                     }
[16:20:41.741]                     invisible(pathname)
[16:20:41.741]                   }
[16:20:41.741]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:41.741]                     rootPath = tempdir()) 
[16:20:41.741]                   {
[16:20:41.741]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:41.741]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:41.741]                       tmpdir = path, fileext = ".rds")
[16:20:41.741]                     save_rds(obj, file)
[16:20:41.741]                   }
[16:20:41.741]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:41.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.741]                   {
[16:20:41.741]                     inherits <- base::inherits
[16:20:41.741]                     invokeRestart <- base::invokeRestart
[16:20:41.741]                     is.null <- base::is.null
[16:20:41.741]                     muffled <- FALSE
[16:20:41.741]                     if (inherits(cond, "message")) {
[16:20:41.741]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:41.741]                       if (muffled) 
[16:20:41.741]                         invokeRestart("muffleMessage")
[16:20:41.741]                     }
[16:20:41.741]                     else if (inherits(cond, "warning")) {
[16:20:41.741]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:41.741]                       if (muffled) 
[16:20:41.741]                         invokeRestart("muffleWarning")
[16:20:41.741]                     }
[16:20:41.741]                     else if (inherits(cond, "condition")) {
[16:20:41.741]                       if (!is.null(pattern)) {
[16:20:41.741]                         computeRestarts <- base::computeRestarts
[16:20:41.741]                         grepl <- base::grepl
[16:20:41.741]                         restarts <- computeRestarts(cond)
[16:20:41.741]                         for (restart in restarts) {
[16:20:41.741]                           name <- restart$name
[16:20:41.741]                           if (is.null(name)) 
[16:20:41.741]                             next
[16:20:41.741]                           if (!grepl(pattern, name)) 
[16:20:41.741]                             next
[16:20:41.741]                           invokeRestart(restart)
[16:20:41.741]                           muffled <- TRUE
[16:20:41.741]                           break
[16:20:41.741]                         }
[16:20:41.741]                       }
[16:20:41.741]                     }
[16:20:41.741]                     invisible(muffled)
[16:20:41.741]                   }
[16:20:41.741]                   muffleCondition(cond)
[16:20:41.741]                 })
[16:20:41.741]             }))
[16:20:41.741]             future::FutureResult(value = ...future.value$value, 
[16:20:41.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.741]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.741]                     ...future.globalenv.names))
[16:20:41.741]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.741]         }, condition = base::local({
[16:20:41.741]             c <- base::c
[16:20:41.741]             inherits <- base::inherits
[16:20:41.741]             invokeRestart <- base::invokeRestart
[16:20:41.741]             length <- base::length
[16:20:41.741]             list <- base::list
[16:20:41.741]             seq.int <- base::seq.int
[16:20:41.741]             signalCondition <- base::signalCondition
[16:20:41.741]             sys.calls <- base::sys.calls
[16:20:41.741]             `[[` <- base::`[[`
[16:20:41.741]             `+` <- base::`+`
[16:20:41.741]             `<<-` <- base::`<<-`
[16:20:41.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.741]                   3L)]
[16:20:41.741]             }
[16:20:41.741]             function(cond) {
[16:20:41.741]                 is_error <- inherits(cond, "error")
[16:20:41.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.741]                   NULL)
[16:20:41.741]                 if (is_error) {
[16:20:41.741]                   sessionInformation <- function() {
[16:20:41.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.741]                       search = base::search(), system = base::Sys.info())
[16:20:41.741]                   }
[16:20:41.741]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.741]                     cond$call), session = sessionInformation(), 
[16:20:41.741]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.741]                   signalCondition(cond)
[16:20:41.741]                 }
[16:20:41.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.741]                 "immediateCondition"))) {
[16:20:41.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.741]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.741]                   if (TRUE && !signal) {
[16:20:41.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.741]                     {
[16:20:41.741]                       inherits <- base::inherits
[16:20:41.741]                       invokeRestart <- base::invokeRestart
[16:20:41.741]                       is.null <- base::is.null
[16:20:41.741]                       muffled <- FALSE
[16:20:41.741]                       if (inherits(cond, "message")) {
[16:20:41.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.741]                         if (muffled) 
[16:20:41.741]                           invokeRestart("muffleMessage")
[16:20:41.741]                       }
[16:20:41.741]                       else if (inherits(cond, "warning")) {
[16:20:41.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.741]                         if (muffled) 
[16:20:41.741]                           invokeRestart("muffleWarning")
[16:20:41.741]                       }
[16:20:41.741]                       else if (inherits(cond, "condition")) {
[16:20:41.741]                         if (!is.null(pattern)) {
[16:20:41.741]                           computeRestarts <- base::computeRestarts
[16:20:41.741]                           grepl <- base::grepl
[16:20:41.741]                           restarts <- computeRestarts(cond)
[16:20:41.741]                           for (restart in restarts) {
[16:20:41.741]                             name <- restart$name
[16:20:41.741]                             if (is.null(name)) 
[16:20:41.741]                               next
[16:20:41.741]                             if (!grepl(pattern, name)) 
[16:20:41.741]                               next
[16:20:41.741]                             invokeRestart(restart)
[16:20:41.741]                             muffled <- TRUE
[16:20:41.741]                             break
[16:20:41.741]                           }
[16:20:41.741]                         }
[16:20:41.741]                       }
[16:20:41.741]                       invisible(muffled)
[16:20:41.741]                     }
[16:20:41.741]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.741]                   }
[16:20:41.741]                 }
[16:20:41.741]                 else {
[16:20:41.741]                   if (TRUE) {
[16:20:41.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.741]                     {
[16:20:41.741]                       inherits <- base::inherits
[16:20:41.741]                       invokeRestart <- base::invokeRestart
[16:20:41.741]                       is.null <- base::is.null
[16:20:41.741]                       muffled <- FALSE
[16:20:41.741]                       if (inherits(cond, "message")) {
[16:20:41.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.741]                         if (muffled) 
[16:20:41.741]                           invokeRestart("muffleMessage")
[16:20:41.741]                       }
[16:20:41.741]                       else if (inherits(cond, "warning")) {
[16:20:41.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.741]                         if (muffled) 
[16:20:41.741]                           invokeRestart("muffleWarning")
[16:20:41.741]                       }
[16:20:41.741]                       else if (inherits(cond, "condition")) {
[16:20:41.741]                         if (!is.null(pattern)) {
[16:20:41.741]                           computeRestarts <- base::computeRestarts
[16:20:41.741]                           grepl <- base::grepl
[16:20:41.741]                           restarts <- computeRestarts(cond)
[16:20:41.741]                           for (restart in restarts) {
[16:20:41.741]                             name <- restart$name
[16:20:41.741]                             if (is.null(name)) 
[16:20:41.741]                               next
[16:20:41.741]                             if (!grepl(pattern, name)) 
[16:20:41.741]                               next
[16:20:41.741]                             invokeRestart(restart)
[16:20:41.741]                             muffled <- TRUE
[16:20:41.741]                             break
[16:20:41.741]                           }
[16:20:41.741]                         }
[16:20:41.741]                       }
[16:20:41.741]                       invisible(muffled)
[16:20:41.741]                     }
[16:20:41.741]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.741]                   }
[16:20:41.741]                 }
[16:20:41.741]             }
[16:20:41.741]         }))
[16:20:41.741]     }, error = function(ex) {
[16:20:41.741]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.741]                 ...future.rng), started = ...future.startTime, 
[16:20:41.741]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.741]             version = "1.8"), class = "FutureResult")
[16:20:41.741]     }, finally = {
[16:20:41.741]         if (!identical(...future.workdir, getwd())) 
[16:20:41.741]             setwd(...future.workdir)
[16:20:41.741]         {
[16:20:41.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.741]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.741]             }
[16:20:41.741]             base::options(...future.oldOptions)
[16:20:41.741]             if (.Platform$OS.type == "windows") {
[16:20:41.741]                 old_names <- names(...future.oldEnvVars)
[16:20:41.741]                 envs <- base::Sys.getenv()
[16:20:41.741]                 names <- names(envs)
[16:20:41.741]                 common <- intersect(names, old_names)
[16:20:41.741]                 added <- setdiff(names, old_names)
[16:20:41.741]                 removed <- setdiff(old_names, names)
[16:20:41.741]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.741]                   envs[common]]
[16:20:41.741]                 NAMES <- toupper(changed)
[16:20:41.741]                 args <- list()
[16:20:41.741]                 for (kk in seq_along(NAMES)) {
[16:20:41.741]                   name <- changed[[kk]]
[16:20:41.741]                   NAME <- NAMES[[kk]]
[16:20:41.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.741]                     next
[16:20:41.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.741]                 }
[16:20:41.741]                 NAMES <- toupper(added)
[16:20:41.741]                 for (kk in seq_along(NAMES)) {
[16:20:41.741]                   name <- added[[kk]]
[16:20:41.741]                   NAME <- NAMES[[kk]]
[16:20:41.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.741]                     next
[16:20:41.741]                   args[[name]] <- ""
[16:20:41.741]                 }
[16:20:41.741]                 NAMES <- toupper(removed)
[16:20:41.741]                 for (kk in seq_along(NAMES)) {
[16:20:41.741]                   name <- removed[[kk]]
[16:20:41.741]                   NAME <- NAMES[[kk]]
[16:20:41.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.741]                     next
[16:20:41.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.741]                 }
[16:20:41.741]                 if (length(args) > 0) 
[16:20:41.741]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.741]             }
[16:20:41.741]             else {
[16:20:41.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.741]             }
[16:20:41.741]             {
[16:20:41.741]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.741]                   0L) {
[16:20:41.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.741]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.741]                   base::options(opts)
[16:20:41.741]                 }
[16:20:41.741]                 {
[16:20:41.741]                   {
[16:20:41.741]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:41.741]                     NULL
[16:20:41.741]                   }
[16:20:41.741]                   options(future.plan = NULL)
[16:20:41.741]                   if (is.na(NA_character_)) 
[16:20:41.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.741]                     .init = FALSE)
[16:20:41.741]                 }
[16:20:41.741]             }
[16:20:41.741]         }
[16:20:41.741]     })
[16:20:41.741]     if (TRUE) {
[16:20:41.741]         base::sink(type = "output", split = FALSE)
[16:20:41.741]         if (TRUE) {
[16:20:41.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.741]         }
[16:20:41.741]         else {
[16:20:41.741]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.741]         }
[16:20:41.741]         base::close(...future.stdout)
[16:20:41.741]         ...future.stdout <- NULL
[16:20:41.741]     }
[16:20:41.741]     ...future.result$conditions <- ...future.conditions
[16:20:41.741]     ...future.result$finished <- base::Sys.time()
[16:20:41.741]     ...future.result
[16:20:41.741] }
[16:20:41.743] requestCore(): workers = 2
[16:20:41.746] MulticoreFuture started
[16:20:41.746] - Launch lazy future ... done
[16:20:41.747] run() for ‘MulticoreFuture’ ... done
[16:20:41.747] getGlobalsAndPackages() ...
[16:20:41.747] plan(): Setting new future strategy stack:
[16:20:41.747] Searching for globals...
[16:20:41.747] List of future strategies:
[16:20:41.747] 1. sequential:
[16:20:41.747]    - args: function (..., envir = parent.frame())
[16:20:41.747]    - tweaked: FALSE
[16:20:41.747]    - call: NULL
[16:20:41.748] plan(): nbrOfWorkers() = 1
[16:20:41.748] 
[16:20:41.749] Searching for globals ... DONE
[16:20:41.749] - globals: [0] <none>
[16:20:41.749] getGlobalsAndPackages() ... DONE
[16:20:41.750] run() for ‘Future’ ...
[16:20:41.750] - state: ‘created’
[16:20:41.750] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:41.750] plan(): Setting new future strategy stack:
[16:20:41.750] List of future strategies:
[16:20:41.750] 1. multicore:
[16:20:41.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:41.750]    - tweaked: FALSE
[16:20:41.750]    - call: plan(strategy)
[16:20:41.755] plan(): nbrOfWorkers() = 2
[16:20:41.755] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:41.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:41.756]   - Field: ‘label’
[16:20:41.756]   - Field: ‘local’
[16:20:41.756]   - Field: ‘owner’
[16:20:41.756]   - Field: ‘envir’
[16:20:41.756]   - Field: ‘workers’
[16:20:41.756]   - Field: ‘packages’
[16:20:41.757]   - Field: ‘gc’
[16:20:41.757]   - Field: ‘job’
[16:20:41.757]   - Field: ‘conditions’
[16:20:41.757]   - Field: ‘expr’
[16:20:41.757]   - Field: ‘uuid’
[16:20:41.757]   - Field: ‘seed’
[16:20:41.758]   - Field: ‘version’
[16:20:41.758]   - Field: ‘result’
[16:20:41.758]   - Field: ‘asynchronous’
[16:20:41.758]   - Field: ‘calls’
[16:20:41.758]   - Field: ‘globals’
[16:20:41.758]   - Field: ‘stdout’
[16:20:41.758]   - Field: ‘earlySignal’
[16:20:41.759]   - Field: ‘lazy’
[16:20:41.759]   - Field: ‘state’
[16:20:41.759] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:41.759] - Launch lazy future ...
[16:20:41.760] Packages needed by the future expression (n = 0): <none>
[16:20:41.760] Packages needed by future strategies (n = 0): <none>
[16:20:41.761] {
[16:20:41.761]     {
[16:20:41.761]         {
[16:20:41.761]             ...future.startTime <- base::Sys.time()
[16:20:41.761]             {
[16:20:41.761]                 {
[16:20:41.761]                   {
[16:20:41.761]                     {
[16:20:41.761]                       base::local({
[16:20:41.761]                         has_future <- base::requireNamespace("future", 
[16:20:41.761]                           quietly = TRUE)
[16:20:41.761]                         if (has_future) {
[16:20:41.761]                           ns <- base::getNamespace("future")
[16:20:41.761]                           version <- ns[[".package"]][["version"]]
[16:20:41.761]                           if (is.null(version)) 
[16:20:41.761]                             version <- utils::packageVersion("future")
[16:20:41.761]                         }
[16:20:41.761]                         else {
[16:20:41.761]                           version <- NULL
[16:20:41.761]                         }
[16:20:41.761]                         if (!has_future || version < "1.8.0") {
[16:20:41.761]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.761]                             "", base::R.version$version.string), 
[16:20:41.761]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:41.761]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.761]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.761]                               "release", "version")], collapse = " "), 
[16:20:41.761]                             hostname = base::Sys.info()[["nodename"]])
[16:20:41.761]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.761]                             info)
[16:20:41.761]                           info <- base::paste(info, collapse = "; ")
[16:20:41.761]                           if (!has_future) {
[16:20:41.761]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.761]                               info)
[16:20:41.761]                           }
[16:20:41.761]                           else {
[16:20:41.761]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.761]                               info, version)
[16:20:41.761]                           }
[16:20:41.761]                           base::stop(msg)
[16:20:41.761]                         }
[16:20:41.761]                       })
[16:20:41.761]                     }
[16:20:41.761]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:41.761]                     base::options(mc.cores = 1L)
[16:20:41.761]                   }
[16:20:41.761]                   ...future.strategy.old <- future::plan("list")
[16:20:41.761]                   options(future.plan = NULL)
[16:20:41.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.761]                 }
[16:20:41.761]                 ...future.workdir <- getwd()
[16:20:41.761]             }
[16:20:41.761]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.761]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.761]         }
[16:20:41.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.761]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.761]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.761]             base::names(...future.oldOptions))
[16:20:41.761]     }
[16:20:41.761]     if (FALSE) {
[16:20:41.761]     }
[16:20:41.761]     else {
[16:20:41.761]         if (TRUE) {
[16:20:41.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.761]                 open = "w")
[16:20:41.761]         }
[16:20:41.761]         else {
[16:20:41.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.761]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.761]         }
[16:20:41.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.761]             base::sink(type = "output", split = FALSE)
[16:20:41.761]             base::close(...future.stdout)
[16:20:41.761]         }, add = TRUE)
[16:20:41.761]     }
[16:20:41.761]     ...future.frame <- base::sys.nframe()
[16:20:41.761]     ...future.conditions <- base::list()
[16:20:41.761]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.761]     if (FALSE) {
[16:20:41.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.761]     }
[16:20:41.761]     ...future.result <- base::tryCatch({
[16:20:41.761]         base::withCallingHandlers({
[16:20:41.761]             ...future.value <- base::withVisible(base::local({
[16:20:41.761]                 withCallingHandlers({
[16:20:41.761]                   NULL
[16:20:41.761]                 }, immediateCondition = function(cond) {
[16:20:41.761]                   save_rds <- function (object, pathname, ...) 
[16:20:41.761]                   {
[16:20:41.761]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:41.761]                     if (file_test("-f", pathname_tmp)) {
[16:20:41.761]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.761]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:41.761]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.761]                         fi_tmp[["mtime"]])
[16:20:41.761]                     }
[16:20:41.761]                     tryCatch({
[16:20:41.761]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:41.761]                     }, error = function(ex) {
[16:20:41.761]                       msg <- conditionMessage(ex)
[16:20:41.761]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.761]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:41.761]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.761]                         fi_tmp[["mtime"]], msg)
[16:20:41.761]                       ex$message <- msg
[16:20:41.761]                       stop(ex)
[16:20:41.761]                     })
[16:20:41.761]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:41.761]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:41.761]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:41.761]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.761]                       fi <- file.info(pathname)
[16:20:41.761]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:41.761]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.761]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:41.761]                         fi[["size"]], fi[["mtime"]])
[16:20:41.761]                       stop(msg)
[16:20:41.761]                     }
[16:20:41.761]                     invisible(pathname)
[16:20:41.761]                   }
[16:20:41.761]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:41.761]                     rootPath = tempdir()) 
[16:20:41.761]                   {
[16:20:41.761]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:41.761]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:41.761]                       tmpdir = path, fileext = ".rds")
[16:20:41.761]                     save_rds(obj, file)
[16:20:41.761]                   }
[16:20:41.761]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:41.761]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.761]                   {
[16:20:41.761]                     inherits <- base::inherits
[16:20:41.761]                     invokeRestart <- base::invokeRestart
[16:20:41.761]                     is.null <- base::is.null
[16:20:41.761]                     muffled <- FALSE
[16:20:41.761]                     if (inherits(cond, "message")) {
[16:20:41.761]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:41.761]                       if (muffled) 
[16:20:41.761]                         invokeRestart("muffleMessage")
[16:20:41.761]                     }
[16:20:41.761]                     else if (inherits(cond, "warning")) {
[16:20:41.761]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:41.761]                       if (muffled) 
[16:20:41.761]                         invokeRestart("muffleWarning")
[16:20:41.761]                     }
[16:20:41.761]                     else if (inherits(cond, "condition")) {
[16:20:41.761]                       if (!is.null(pattern)) {
[16:20:41.761]                         computeRestarts <- base::computeRestarts
[16:20:41.761]                         grepl <- base::grepl
[16:20:41.761]                         restarts <- computeRestarts(cond)
[16:20:41.761]                         for (restart in restarts) {
[16:20:41.761]                           name <- restart$name
[16:20:41.761]                           if (is.null(name)) 
[16:20:41.761]                             next
[16:20:41.761]                           if (!grepl(pattern, name)) 
[16:20:41.761]                             next
[16:20:41.761]                           invokeRestart(restart)
[16:20:41.761]                           muffled <- TRUE
[16:20:41.761]                           break
[16:20:41.761]                         }
[16:20:41.761]                       }
[16:20:41.761]                     }
[16:20:41.761]                     invisible(muffled)
[16:20:41.761]                   }
[16:20:41.761]                   muffleCondition(cond)
[16:20:41.761]                 })
[16:20:41.761]             }))
[16:20:41.761]             future::FutureResult(value = ...future.value$value, 
[16:20:41.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.761]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.761]                     ...future.globalenv.names))
[16:20:41.761]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.761]         }, condition = base::local({
[16:20:41.761]             c <- base::c
[16:20:41.761]             inherits <- base::inherits
[16:20:41.761]             invokeRestart <- base::invokeRestart
[16:20:41.761]             length <- base::length
[16:20:41.761]             list <- base::list
[16:20:41.761]             seq.int <- base::seq.int
[16:20:41.761]             signalCondition <- base::signalCondition
[16:20:41.761]             sys.calls <- base::sys.calls
[16:20:41.761]             `[[` <- base::`[[`
[16:20:41.761]             `+` <- base::`+`
[16:20:41.761]             `<<-` <- base::`<<-`
[16:20:41.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.761]                   3L)]
[16:20:41.761]             }
[16:20:41.761]             function(cond) {
[16:20:41.761]                 is_error <- inherits(cond, "error")
[16:20:41.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.761]                   NULL)
[16:20:41.761]                 if (is_error) {
[16:20:41.761]                   sessionInformation <- function() {
[16:20:41.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.761]                       search = base::search(), system = base::Sys.info())
[16:20:41.761]                   }
[16:20:41.761]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.761]                     cond$call), session = sessionInformation(), 
[16:20:41.761]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.761]                   signalCondition(cond)
[16:20:41.761]                 }
[16:20:41.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.761]                 "immediateCondition"))) {
[16:20:41.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.761]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.761]                   if (TRUE && !signal) {
[16:20:41.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.761]                     {
[16:20:41.761]                       inherits <- base::inherits
[16:20:41.761]                       invokeRestart <- base::invokeRestart
[16:20:41.761]                       is.null <- base::is.null
[16:20:41.761]                       muffled <- FALSE
[16:20:41.761]                       if (inherits(cond, "message")) {
[16:20:41.761]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.761]                         if (muffled) 
[16:20:41.761]                           invokeRestart("muffleMessage")
[16:20:41.761]                       }
[16:20:41.761]                       else if (inherits(cond, "warning")) {
[16:20:41.761]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.761]                         if (muffled) 
[16:20:41.761]                           invokeRestart("muffleWarning")
[16:20:41.761]                       }
[16:20:41.761]                       else if (inherits(cond, "condition")) {
[16:20:41.761]                         if (!is.null(pattern)) {
[16:20:41.761]                           computeRestarts <- base::computeRestarts
[16:20:41.761]                           grepl <- base::grepl
[16:20:41.761]                           restarts <- computeRestarts(cond)
[16:20:41.761]                           for (restart in restarts) {
[16:20:41.761]                             name <- restart$name
[16:20:41.761]                             if (is.null(name)) 
[16:20:41.761]                               next
[16:20:41.761]                             if (!grepl(pattern, name)) 
[16:20:41.761]                               next
[16:20:41.761]                             invokeRestart(restart)
[16:20:41.761]                             muffled <- TRUE
[16:20:41.761]                             break
[16:20:41.761]                           }
[16:20:41.761]                         }
[16:20:41.761]                       }
[16:20:41.761]                       invisible(muffled)
[16:20:41.761]                     }
[16:20:41.761]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.761]                   }
[16:20:41.761]                 }
[16:20:41.761]                 else {
[16:20:41.761]                   if (TRUE) {
[16:20:41.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.761]                     {
[16:20:41.761]                       inherits <- base::inherits
[16:20:41.761]                       invokeRestart <- base::invokeRestart
[16:20:41.761]                       is.null <- base::is.null
[16:20:41.761]                       muffled <- FALSE
[16:20:41.761]                       if (inherits(cond, "message")) {
[16:20:41.761]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.761]                         if (muffled) 
[16:20:41.761]                           invokeRestart("muffleMessage")
[16:20:41.761]                       }
[16:20:41.761]                       else if (inherits(cond, "warning")) {
[16:20:41.761]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.761]                         if (muffled) 
[16:20:41.761]                           invokeRestart("muffleWarning")
[16:20:41.761]                       }
[16:20:41.761]                       else if (inherits(cond, "condition")) {
[16:20:41.761]                         if (!is.null(pattern)) {
[16:20:41.761]                           computeRestarts <- base::computeRestarts
[16:20:41.761]                           grepl <- base::grepl
[16:20:41.761]                           restarts <- computeRestarts(cond)
[16:20:41.761]                           for (restart in restarts) {
[16:20:41.761]                             name <- restart$name
[16:20:41.761]                             if (is.null(name)) 
[16:20:41.761]                               next
[16:20:41.761]                             if (!grepl(pattern, name)) 
[16:20:41.761]                               next
[16:20:41.761]                             invokeRestart(restart)
[16:20:41.761]                             muffled <- TRUE
[16:20:41.761]                             break
[16:20:41.761]                           }
[16:20:41.761]                         }
[16:20:41.761]                       }
[16:20:41.761]                       invisible(muffled)
[16:20:41.761]                     }
[16:20:41.761]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.761]                   }
[16:20:41.761]                 }
[16:20:41.761]             }
[16:20:41.761]         }))
[16:20:41.761]     }, error = function(ex) {
[16:20:41.761]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.761]                 ...future.rng), started = ...future.startTime, 
[16:20:41.761]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.761]             version = "1.8"), class = "FutureResult")
[16:20:41.761]     }, finally = {
[16:20:41.761]         if (!identical(...future.workdir, getwd())) 
[16:20:41.761]             setwd(...future.workdir)
[16:20:41.761]         {
[16:20:41.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.761]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.761]             }
[16:20:41.761]             base::options(...future.oldOptions)
[16:20:41.761]             if (.Platform$OS.type == "windows") {
[16:20:41.761]                 old_names <- names(...future.oldEnvVars)
[16:20:41.761]                 envs <- base::Sys.getenv()
[16:20:41.761]                 names <- names(envs)
[16:20:41.761]                 common <- intersect(names, old_names)
[16:20:41.761]                 added <- setdiff(names, old_names)
[16:20:41.761]                 removed <- setdiff(old_names, names)
[16:20:41.761]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.761]                   envs[common]]
[16:20:41.761]                 NAMES <- toupper(changed)
[16:20:41.761]                 args <- list()
[16:20:41.761]                 for (kk in seq_along(NAMES)) {
[16:20:41.761]                   name <- changed[[kk]]
[16:20:41.761]                   NAME <- NAMES[[kk]]
[16:20:41.761]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.761]                     next
[16:20:41.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.761]                 }
[16:20:41.761]                 NAMES <- toupper(added)
[16:20:41.761]                 for (kk in seq_along(NAMES)) {
[16:20:41.761]                   name <- added[[kk]]
[16:20:41.761]                   NAME <- NAMES[[kk]]
[16:20:41.761]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.761]                     next
[16:20:41.761]                   args[[name]] <- ""
[16:20:41.761]                 }
[16:20:41.761]                 NAMES <- toupper(removed)
[16:20:41.761]                 for (kk in seq_along(NAMES)) {
[16:20:41.761]                   name <- removed[[kk]]
[16:20:41.761]                   NAME <- NAMES[[kk]]
[16:20:41.761]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.761]                     next
[16:20:41.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.761]                 }
[16:20:41.761]                 if (length(args) > 0) 
[16:20:41.761]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.761]             }
[16:20:41.761]             else {
[16:20:41.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.761]             }
[16:20:41.761]             {
[16:20:41.761]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.761]                   0L) {
[16:20:41.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.761]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.761]                   base::options(opts)
[16:20:41.761]                 }
[16:20:41.761]                 {
[16:20:41.761]                   {
[16:20:41.761]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:41.761]                     NULL
[16:20:41.761]                   }
[16:20:41.761]                   options(future.plan = NULL)
[16:20:41.761]                   if (is.na(NA_character_)) 
[16:20:41.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.761]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.761]                     .init = FALSE)
[16:20:41.761]                 }
[16:20:41.761]             }
[16:20:41.761]         }
[16:20:41.761]     })
[16:20:41.761]     if (TRUE) {
[16:20:41.761]         base::sink(type = "output", split = FALSE)
[16:20:41.761]         if (TRUE) {
[16:20:41.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.761]         }
[16:20:41.761]         else {
[16:20:41.761]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.761]         }
[16:20:41.761]         base::close(...future.stdout)
[16:20:41.761]         ...future.stdout <- NULL
[16:20:41.761]     }
[16:20:41.761]     ...future.result$conditions <- ...future.conditions
[16:20:41.761]     ...future.result$finished <- base::Sys.time()
[16:20:41.761]     ...future.result
[16:20:41.761] }
[16:20:41.764] requestCore(): workers = 2
[16:20:41.770] MulticoreFuture started
[16:20:41.770] - Launch lazy future ... done
[16:20:41.771] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[16:20:41.771] plan(): Setting new future strategy stack:
[16:20:41.771] List of future strategies:
[16:20:41.771] 1. sequential:
[16:20:41.771]    - args: function (..., envir = parent.frame())
[16:20:41.771]    - tweaked: FALSE
[16:20:41.771]    - call: NULL
 num 1
 $ b:[16:20:41.772] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c66c828> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0a89fde8> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:20:41.774] plan(): Setting new future strategy stack:
List of 6
 $ a:[16:20:41.774] List of future strategies:
[16:20:41.774] 1. multicore:
[16:20:41.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:41.774]    - tweaked: FALSE
[16:20:41.774]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c66c828> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0a89fde8> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:20:41.780] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:41.781] resolve() on list ...
[16:20:41.781]  recursive: 0
[16:20:41.781]  length: 6
[16:20:41.782]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:41.782] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.782] - nx: 6
[16:20:41.782] - relay: TRUE
[16:20:41.782] - stdout: TRUE
[16:20:41.782] - signal: TRUE
[16:20:41.782] - resignal: FALSE
[16:20:41.783] - force: TRUE
[16:20:41.783] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.783] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.783]  - until=2
[16:20:41.783]  - relaying element #2
[16:20:41.783] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.783] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.783] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.784]  length: 5 (resolved future 1)
[16:20:41.784] Future #2
[16:20:41.785] result() for MulticoreFuture ...
[16:20:41.786] result() for MulticoreFuture ...
[16:20:41.786] result() for MulticoreFuture ... done
[16:20:41.786] result() for MulticoreFuture ... done
[16:20:41.787] result() for MulticoreFuture ...
[16:20:41.787] result() for MulticoreFuture ... done
[16:20:41.787] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:41.787] - nx: 6
[16:20:41.787] - relay: TRUE
[16:20:41.787] - stdout: TRUE
[16:20:41.787] - signal: TRUE
[16:20:41.788] - resignal: FALSE
[16:20:41.788] - force: TRUE
[16:20:41.788] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.788] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.788]  - until=2
[16:20:41.788]  - relaying element #2
[16:20:41.788] result() for MulticoreFuture ...
[16:20:41.789] result() for MulticoreFuture ... done
[16:20:41.789] result() for MulticoreFuture ...
[16:20:41.789] result() for MulticoreFuture ... done
[16:20:41.789] result() for MulticoreFuture ...
[16:20:41.789] result() for MulticoreFuture ... done
[16:20:41.789] result() for MulticoreFuture ...
[16:20:41.789] result() for MulticoreFuture ... done
[16:20:41.789] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.790] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.790] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:41.790]  length: 4 (resolved future 2)
[16:20:41.790] Future #3
[16:20:41.790] result() for MulticoreFuture ...
[16:20:41.791] result() for MulticoreFuture ...
[16:20:41.791] result() for MulticoreFuture ... done
[16:20:41.791] result() for MulticoreFuture ... done
[16:20:41.792] result() for MulticoreFuture ...
[16:20:41.792] result() for MulticoreFuture ... done
[16:20:41.795] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:41.796] - nx: 6
[16:20:41.796] - relay: TRUE
[16:20:41.796] - stdout: TRUE
[16:20:41.796] - signal: TRUE
[16:20:41.796] - resignal: FALSE
[16:20:41.797] - force: TRUE
[16:20:41.797] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.797] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.797]  - until=3
[16:20:41.797]  - relaying element #3
[16:20:41.797] result() for MulticoreFuture ...
[16:20:41.797] result() for MulticoreFuture ... done
[16:20:41.798] result() for MulticoreFuture ...
[16:20:41.798] result() for MulticoreFuture ... done
[16:20:41.798] result() for MulticoreFuture ...
[16:20:41.798] result() for MulticoreFuture ... done
[16:20:41.798] result() for MulticoreFuture ...
[16:20:41.798] result() for MulticoreFuture ... done
[16:20:41.798] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.799] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.799] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:41.799]  length: 3 (resolved future 3)
[16:20:41.799] signalConditionsASAP(NULL, pos=4) ...
[16:20:41.799] - nx: 6
[16:20:41.799] - relay: TRUE
[16:20:41.799] - stdout: TRUE
[16:20:41.799] - signal: TRUE
[16:20:41.799] - resignal: FALSE
[16:20:41.800] - force: TRUE
[16:20:41.800] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.800] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.800]  - until=5
[16:20:41.800]  - relaying element #5
[16:20:41.800] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.800] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.800] signalConditionsASAP(NULL, pos=4) ... done
[16:20:41.801]  length: 2 (resolved future 4)
[16:20:41.801] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.801] - nx: 6
[16:20:41.801] - relay: TRUE
[16:20:41.801] - stdout: TRUE
[16:20:41.801] - signal: TRUE
[16:20:41.801] - resignal: FALSE
[16:20:41.801] - force: TRUE
[16:20:41.801] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.802] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.802]  - until=6
[16:20:41.802]  - relaying element #6
[16:20:41.802] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.802] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.802] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.802]  length: 1 (resolved future 5)
[16:20:41.802] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.802] - nx: 6
[16:20:41.803] - relay: TRUE
[16:20:41.803] - stdout: TRUE
[16:20:41.803] - signal: TRUE
[16:20:41.803] - resignal: FALSE
[16:20:41.803] - force: TRUE
[16:20:41.803] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.803] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.803]  - until=6
[16:20:41.803] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.803] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.804] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.804]  length: 0 (resolved future 6)
[16:20:41.804] Relaying remaining futures
[16:20:41.804] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.804] - nx: 6
[16:20:41.804] - relay: TRUE
[16:20:41.804] - stdout: TRUE
[16:20:41.804] - signal: TRUE
[16:20:41.804] - resignal: FALSE
[16:20:41.804] - force: TRUE
[16:20:41.805] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.805] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:41.805] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.805] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.805] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.805] resolve() on list ... DONE
[16:20:41.805] result() for MulticoreFuture ...
[16:20:41.805] result() for MulticoreFuture ... done
[16:20:41.805] result() for MulticoreFuture ...
[16:20:41.806] result() for MulticoreFuture ... done
[16:20:41.806] result() for MulticoreFuture ...
[16:20:41.806] result() for MulticoreFuture ... done
[16:20:41.806] result() for MulticoreFuture ...
[16:20:41.806] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[16:20:41.808] getGlobalsAndPackages() ...
[16:20:41.808] Searching for globals...
[16:20:41.809] 
[16:20:41.809] Searching for globals ... DONE
[16:20:41.809] - globals: [0] <none>
[16:20:41.809] getGlobalsAndPackages() ... DONE
[16:20:41.809] run() for ‘Future’ ...
[16:20:41.810] - state: ‘created’
[16:20:41.810] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:41.814] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:41.814] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:41.814]   - Field: ‘label’
[16:20:41.814]   - Field: ‘local’
[16:20:41.814]   - Field: ‘owner’
[16:20:41.815]   - Field: ‘envir’
[16:20:41.815]   - Field: ‘workers’
[16:20:41.815]   - Field: ‘packages’
[16:20:41.815]   - Field: ‘gc’
[16:20:41.815]   - Field: ‘job’
[16:20:41.815]   - Field: ‘conditions’
[16:20:41.815]   - Field: ‘expr’
[16:20:41.815]   - Field: ‘uuid’
[16:20:41.815]   - Field: ‘seed’
[16:20:41.815]   - Field: ‘version’
[16:20:41.815]   - Field: ‘result’
[16:20:41.816]   - Field: ‘asynchronous’
[16:20:41.816]   - Field: ‘calls’
[16:20:41.816]   - Field: ‘globals’
[16:20:41.816]   - Field: ‘stdout’
[16:20:41.816]   - Field: ‘earlySignal’
[16:20:41.816]   - Field: ‘lazy’
[16:20:41.816]   - Field: ‘state’
[16:20:41.816] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:41.816] - Launch lazy future ...
[16:20:41.817] Packages needed by the future expression (n = 0): <none>
[16:20:41.817] Packages needed by future strategies (n = 0): <none>
[16:20:41.817] {
[16:20:41.817]     {
[16:20:41.817]         {
[16:20:41.817]             ...future.startTime <- base::Sys.time()
[16:20:41.817]             {
[16:20:41.817]                 {
[16:20:41.817]                   {
[16:20:41.817]                     {
[16:20:41.817]                       base::local({
[16:20:41.817]                         has_future <- base::requireNamespace("future", 
[16:20:41.817]                           quietly = TRUE)
[16:20:41.817]                         if (has_future) {
[16:20:41.817]                           ns <- base::getNamespace("future")
[16:20:41.817]                           version <- ns[[".package"]][["version"]]
[16:20:41.817]                           if (is.null(version)) 
[16:20:41.817]                             version <- utils::packageVersion("future")
[16:20:41.817]                         }
[16:20:41.817]                         else {
[16:20:41.817]                           version <- NULL
[16:20:41.817]                         }
[16:20:41.817]                         if (!has_future || version < "1.8.0") {
[16:20:41.817]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.817]                             "", base::R.version$version.string), 
[16:20:41.817]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:41.817]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.817]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.817]                               "release", "version")], collapse = " "), 
[16:20:41.817]                             hostname = base::Sys.info()[["nodename"]])
[16:20:41.817]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.817]                             info)
[16:20:41.817]                           info <- base::paste(info, collapse = "; ")
[16:20:41.817]                           if (!has_future) {
[16:20:41.817]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.817]                               info)
[16:20:41.817]                           }
[16:20:41.817]                           else {
[16:20:41.817]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.817]                               info, version)
[16:20:41.817]                           }
[16:20:41.817]                           base::stop(msg)
[16:20:41.817]                         }
[16:20:41.817]                       })
[16:20:41.817]                     }
[16:20:41.817]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:41.817]                     base::options(mc.cores = 1L)
[16:20:41.817]                   }
[16:20:41.817]                   ...future.strategy.old <- future::plan("list")
[16:20:41.817]                   options(future.plan = NULL)
[16:20:41.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.817]                 }
[16:20:41.817]                 ...future.workdir <- getwd()
[16:20:41.817]             }
[16:20:41.817]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.817]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.817]         }
[16:20:41.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.817]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.817]             base::names(...future.oldOptions))
[16:20:41.817]     }
[16:20:41.817]     if (FALSE) {
[16:20:41.817]     }
[16:20:41.817]     else {
[16:20:41.817]         if (TRUE) {
[16:20:41.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.817]                 open = "w")
[16:20:41.817]         }
[16:20:41.817]         else {
[16:20:41.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.817]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.817]         }
[16:20:41.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.817]             base::sink(type = "output", split = FALSE)
[16:20:41.817]             base::close(...future.stdout)
[16:20:41.817]         }, add = TRUE)
[16:20:41.817]     }
[16:20:41.817]     ...future.frame <- base::sys.nframe()
[16:20:41.817]     ...future.conditions <- base::list()
[16:20:41.817]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.817]     if (FALSE) {
[16:20:41.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.817]     }
[16:20:41.817]     ...future.result <- base::tryCatch({
[16:20:41.817]         base::withCallingHandlers({
[16:20:41.817]             ...future.value <- base::withVisible(base::local({
[16:20:41.817]                 withCallingHandlers({
[16:20:41.817]                   2
[16:20:41.817]                 }, immediateCondition = function(cond) {
[16:20:41.817]                   save_rds <- function (object, pathname, ...) 
[16:20:41.817]                   {
[16:20:41.817]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:41.817]                     if (file_test("-f", pathname_tmp)) {
[16:20:41.817]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.817]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:41.817]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.817]                         fi_tmp[["mtime"]])
[16:20:41.817]                     }
[16:20:41.817]                     tryCatch({
[16:20:41.817]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:41.817]                     }, error = function(ex) {
[16:20:41.817]                       msg <- conditionMessage(ex)
[16:20:41.817]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.817]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:41.817]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.817]                         fi_tmp[["mtime"]], msg)
[16:20:41.817]                       ex$message <- msg
[16:20:41.817]                       stop(ex)
[16:20:41.817]                     })
[16:20:41.817]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:41.817]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:41.817]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:41.817]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.817]                       fi <- file.info(pathname)
[16:20:41.817]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:41.817]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.817]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:41.817]                         fi[["size"]], fi[["mtime"]])
[16:20:41.817]                       stop(msg)
[16:20:41.817]                     }
[16:20:41.817]                     invisible(pathname)
[16:20:41.817]                   }
[16:20:41.817]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:41.817]                     rootPath = tempdir()) 
[16:20:41.817]                   {
[16:20:41.817]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:41.817]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:41.817]                       tmpdir = path, fileext = ".rds")
[16:20:41.817]                     save_rds(obj, file)
[16:20:41.817]                   }
[16:20:41.817]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:41.817]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.817]                   {
[16:20:41.817]                     inherits <- base::inherits
[16:20:41.817]                     invokeRestart <- base::invokeRestart
[16:20:41.817]                     is.null <- base::is.null
[16:20:41.817]                     muffled <- FALSE
[16:20:41.817]                     if (inherits(cond, "message")) {
[16:20:41.817]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:41.817]                       if (muffled) 
[16:20:41.817]                         invokeRestart("muffleMessage")
[16:20:41.817]                     }
[16:20:41.817]                     else if (inherits(cond, "warning")) {
[16:20:41.817]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:41.817]                       if (muffled) 
[16:20:41.817]                         invokeRestart("muffleWarning")
[16:20:41.817]                     }
[16:20:41.817]                     else if (inherits(cond, "condition")) {
[16:20:41.817]                       if (!is.null(pattern)) {
[16:20:41.817]                         computeRestarts <- base::computeRestarts
[16:20:41.817]                         grepl <- base::grepl
[16:20:41.817]                         restarts <- computeRestarts(cond)
[16:20:41.817]                         for (restart in restarts) {
[16:20:41.817]                           name <- restart$name
[16:20:41.817]                           if (is.null(name)) 
[16:20:41.817]                             next
[16:20:41.817]                           if (!grepl(pattern, name)) 
[16:20:41.817]                             next
[16:20:41.817]                           invokeRestart(restart)
[16:20:41.817]                           muffled <- TRUE
[16:20:41.817]                           break
[16:20:41.817]                         }
[16:20:41.817]                       }
[16:20:41.817]                     }
[16:20:41.817]                     invisible(muffled)
[16:20:41.817]                   }
[16:20:41.817]                   muffleCondition(cond)
[16:20:41.817]                 })
[16:20:41.817]             }))
[16:20:41.817]             future::FutureResult(value = ...future.value$value, 
[16:20:41.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.817]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.817]                     ...future.globalenv.names))
[16:20:41.817]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.817]         }, condition = base::local({
[16:20:41.817]             c <- base::c
[16:20:41.817]             inherits <- base::inherits
[16:20:41.817]             invokeRestart <- base::invokeRestart
[16:20:41.817]             length <- base::length
[16:20:41.817]             list <- base::list
[16:20:41.817]             seq.int <- base::seq.int
[16:20:41.817]             signalCondition <- base::signalCondition
[16:20:41.817]             sys.calls <- base::sys.calls
[16:20:41.817]             `[[` <- base::`[[`
[16:20:41.817]             `+` <- base::`+`
[16:20:41.817]             `<<-` <- base::`<<-`
[16:20:41.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.817]                   3L)]
[16:20:41.817]             }
[16:20:41.817]             function(cond) {
[16:20:41.817]                 is_error <- inherits(cond, "error")
[16:20:41.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.817]                   NULL)
[16:20:41.817]                 if (is_error) {
[16:20:41.817]                   sessionInformation <- function() {
[16:20:41.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.817]                       search = base::search(), system = base::Sys.info())
[16:20:41.817]                   }
[16:20:41.817]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.817]                     cond$call), session = sessionInformation(), 
[16:20:41.817]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.817]                   signalCondition(cond)
[16:20:41.817]                 }
[16:20:41.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.817]                 "immediateCondition"))) {
[16:20:41.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.817]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.817]                   if (TRUE && !signal) {
[16:20:41.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.817]                     {
[16:20:41.817]                       inherits <- base::inherits
[16:20:41.817]                       invokeRestart <- base::invokeRestart
[16:20:41.817]                       is.null <- base::is.null
[16:20:41.817]                       muffled <- FALSE
[16:20:41.817]                       if (inherits(cond, "message")) {
[16:20:41.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.817]                         if (muffled) 
[16:20:41.817]                           invokeRestart("muffleMessage")
[16:20:41.817]                       }
[16:20:41.817]                       else if (inherits(cond, "warning")) {
[16:20:41.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.817]                         if (muffled) 
[16:20:41.817]                           invokeRestart("muffleWarning")
[16:20:41.817]                       }
[16:20:41.817]                       else if (inherits(cond, "condition")) {
[16:20:41.817]                         if (!is.null(pattern)) {
[16:20:41.817]                           computeRestarts <- base::computeRestarts
[16:20:41.817]                           grepl <- base::grepl
[16:20:41.817]                           restarts <- computeRestarts(cond)
[16:20:41.817]                           for (restart in restarts) {
[16:20:41.817]                             name <- restart$name
[16:20:41.817]                             if (is.null(name)) 
[16:20:41.817]                               next
[16:20:41.817]                             if (!grepl(pattern, name)) 
[16:20:41.817]                               next
[16:20:41.817]                             invokeRestart(restart)
[16:20:41.817]                             muffled <- TRUE
[16:20:41.817]                             break
[16:20:41.817]                           }
[16:20:41.817]                         }
[16:20:41.817]                       }
[16:20:41.817]                       invisible(muffled)
[16:20:41.817]                     }
[16:20:41.817]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.817]                   }
[16:20:41.817]                 }
[16:20:41.817]                 else {
[16:20:41.817]                   if (TRUE) {
[16:20:41.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.817]                     {
[16:20:41.817]                       inherits <- base::inherits
[16:20:41.817]                       invokeRestart <- base::invokeRestart
[16:20:41.817]                       is.null <- base::is.null
[16:20:41.817]                       muffled <- FALSE
[16:20:41.817]                       if (inherits(cond, "message")) {
[16:20:41.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.817]                         if (muffled) 
[16:20:41.817]                           invokeRestart("muffleMessage")
[16:20:41.817]                       }
[16:20:41.817]                       else if (inherits(cond, "warning")) {
[16:20:41.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.817]                         if (muffled) 
[16:20:41.817]                           invokeRestart("muffleWarning")
[16:20:41.817]                       }
[16:20:41.817]                       else if (inherits(cond, "condition")) {
[16:20:41.817]                         if (!is.null(pattern)) {
[16:20:41.817]                           computeRestarts <- base::computeRestarts
[16:20:41.817]                           grepl <- base::grepl
[16:20:41.817]                           restarts <- computeRestarts(cond)
[16:20:41.817]                           for (restart in restarts) {
[16:20:41.817]                             name <- restart$name
[16:20:41.817]                             if (is.null(name)) 
[16:20:41.817]                               next
[16:20:41.817]                             if (!grepl(pattern, name)) 
[16:20:41.817]                               next
[16:20:41.817]                             invokeRestart(restart)
[16:20:41.817]                             muffled <- TRUE
[16:20:41.817]                             break
[16:20:41.817]                           }
[16:20:41.817]                         }
[16:20:41.817]                       }
[16:20:41.817]                       invisible(muffled)
[16:20:41.817]                     }
[16:20:41.817]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.817]                   }
[16:20:41.817]                 }
[16:20:41.817]             }
[16:20:41.817]         }))
[16:20:41.817]     }, error = function(ex) {
[16:20:41.817]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.817]                 ...future.rng), started = ...future.startTime, 
[16:20:41.817]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.817]             version = "1.8"), class = "FutureResult")
[16:20:41.817]     }, finally = {
[16:20:41.817]         if (!identical(...future.workdir, getwd())) 
[16:20:41.817]             setwd(...future.workdir)
[16:20:41.817]         {
[16:20:41.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.817]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.817]             }
[16:20:41.817]             base::options(...future.oldOptions)
[16:20:41.817]             if (.Platform$OS.type == "windows") {
[16:20:41.817]                 old_names <- names(...future.oldEnvVars)
[16:20:41.817]                 envs <- base::Sys.getenv()
[16:20:41.817]                 names <- names(envs)
[16:20:41.817]                 common <- intersect(names, old_names)
[16:20:41.817]                 added <- setdiff(names, old_names)
[16:20:41.817]                 removed <- setdiff(old_names, names)
[16:20:41.817]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.817]                   envs[common]]
[16:20:41.817]                 NAMES <- toupper(changed)
[16:20:41.817]                 args <- list()
[16:20:41.817]                 for (kk in seq_along(NAMES)) {
[16:20:41.817]                   name <- changed[[kk]]
[16:20:41.817]                   NAME <- NAMES[[kk]]
[16:20:41.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.817]                     next
[16:20:41.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.817]                 }
[16:20:41.817]                 NAMES <- toupper(added)
[16:20:41.817]                 for (kk in seq_along(NAMES)) {
[16:20:41.817]                   name <- added[[kk]]
[16:20:41.817]                   NAME <- NAMES[[kk]]
[16:20:41.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.817]                     next
[16:20:41.817]                   args[[name]] <- ""
[16:20:41.817]                 }
[16:20:41.817]                 NAMES <- toupper(removed)
[16:20:41.817]                 for (kk in seq_along(NAMES)) {
[16:20:41.817]                   name <- removed[[kk]]
[16:20:41.817]                   NAME <- NAMES[[kk]]
[16:20:41.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.817]                     next
[16:20:41.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.817]                 }
[16:20:41.817]                 if (length(args) > 0) 
[16:20:41.817]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.817]             }
[16:20:41.817]             else {
[16:20:41.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.817]             }
[16:20:41.817]             {
[16:20:41.817]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.817]                   0L) {
[16:20:41.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.817]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.817]                   base::options(opts)
[16:20:41.817]                 }
[16:20:41.817]                 {
[16:20:41.817]                   {
[16:20:41.817]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:41.817]                     NULL
[16:20:41.817]                   }
[16:20:41.817]                   options(future.plan = NULL)
[16:20:41.817]                   if (is.na(NA_character_)) 
[16:20:41.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.817]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.817]                     .init = FALSE)
[16:20:41.817]                 }
[16:20:41.817]             }
[16:20:41.817]         }
[16:20:41.817]     })
[16:20:41.817]     if (TRUE) {
[16:20:41.817]         base::sink(type = "output", split = FALSE)
[16:20:41.817]         if (TRUE) {
[16:20:41.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.817]         }
[16:20:41.817]         else {
[16:20:41.817]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.817]         }
[16:20:41.817]         base::close(...future.stdout)
[16:20:41.817]         ...future.stdout <- NULL
[16:20:41.817]     }
[16:20:41.817]     ...future.result$conditions <- ...future.conditions
[16:20:41.817]     ...future.result$finished <- base::Sys.time()
[16:20:41.817]     ...future.result
[16:20:41.817] }
[16:20:41.819] requestCore(): workers = 2
[16:20:41.821] MulticoreFuture started
[16:20:41.822] - Launch lazy future ... done
[16:20:41.822] run() for ‘MulticoreFuture’ ... done
[16:20:41.822] getGlobalsAndPackages() ...
[16:20:41.822] Searching for globals...
[16:20:41.822] plan(): Setting new future strategy stack:
[16:20:41.823] 
[16:20:41.823] List of future strategies:
[16:20:41.823] 1. sequential:
[16:20:41.823]    - args: function (..., envir = parent.frame())
[16:20:41.823]    - tweaked: FALSE
[16:20:41.823]    - call: NULL
[16:20:41.823] Searching for globals ... DONE
[16:20:41.823] plan(): nbrOfWorkers() = 1
[16:20:41.824] - globals: [0] <none>
[16:20:41.824] getGlobalsAndPackages() ... DONE
[16:20:41.824] run() for ‘Future’ ...
[16:20:41.824] - state: ‘created’
[16:20:41.825] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:41.825] plan(): Setting new future strategy stack:
[16:20:41.825] List of future strategies:
[16:20:41.825] 1. multicore:
[16:20:41.825]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:41.825]    - tweaked: FALSE
[16:20:41.825]    - call: plan(strategy)
[16:20:41.830] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:41.830] plan(): nbrOfWorkers() = 2
[16:20:41.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:41.830]   - Field: ‘label’
[16:20:41.830]   - Field: ‘local’
[16:20:41.830]   - Field: ‘owner’
[16:20:41.830]   - Field: ‘envir’
[16:20:41.831]   - Field: ‘workers’
[16:20:41.831]   - Field: ‘packages’
[16:20:41.831]   - Field: ‘gc’
[16:20:41.831]   - Field: ‘job’
[16:20:41.831]   - Field: ‘conditions’
[16:20:41.831]   - Field: ‘expr’
[16:20:41.831]   - Field: ‘uuid’
[16:20:41.832]   - Field: ‘seed’
[16:20:41.832]   - Field: ‘version’
[16:20:41.832]   - Field: ‘result’
[16:20:41.832]   - Field: ‘asynchronous’
[16:20:41.832]   - Field: ‘calls’
[16:20:41.832]   - Field: ‘globals’
[16:20:41.833]   - Field: ‘stdout’
[16:20:41.833]   - Field: ‘earlySignal’
[16:20:41.833]   - Field: ‘lazy’
[16:20:41.833]   - Field: ‘state’
[16:20:41.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:41.833] - Launch lazy future ...
[16:20:41.834] Packages needed by the future expression (n = 0): <none>
[16:20:41.834] Packages needed by future strategies (n = 0): <none>
[16:20:41.835] {
[16:20:41.835]     {
[16:20:41.835]         {
[16:20:41.835]             ...future.startTime <- base::Sys.time()
[16:20:41.835]             {
[16:20:41.835]                 {
[16:20:41.835]                   {
[16:20:41.835]                     {
[16:20:41.835]                       base::local({
[16:20:41.835]                         has_future <- base::requireNamespace("future", 
[16:20:41.835]                           quietly = TRUE)
[16:20:41.835]                         if (has_future) {
[16:20:41.835]                           ns <- base::getNamespace("future")
[16:20:41.835]                           version <- ns[[".package"]][["version"]]
[16:20:41.835]                           if (is.null(version)) 
[16:20:41.835]                             version <- utils::packageVersion("future")
[16:20:41.835]                         }
[16:20:41.835]                         else {
[16:20:41.835]                           version <- NULL
[16:20:41.835]                         }
[16:20:41.835]                         if (!has_future || version < "1.8.0") {
[16:20:41.835]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.835]                             "", base::R.version$version.string), 
[16:20:41.835]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:41.835]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.835]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.835]                               "release", "version")], collapse = " "), 
[16:20:41.835]                             hostname = base::Sys.info()[["nodename"]])
[16:20:41.835]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.835]                             info)
[16:20:41.835]                           info <- base::paste(info, collapse = "; ")
[16:20:41.835]                           if (!has_future) {
[16:20:41.835]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.835]                               info)
[16:20:41.835]                           }
[16:20:41.835]                           else {
[16:20:41.835]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.835]                               info, version)
[16:20:41.835]                           }
[16:20:41.835]                           base::stop(msg)
[16:20:41.835]                         }
[16:20:41.835]                       })
[16:20:41.835]                     }
[16:20:41.835]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:41.835]                     base::options(mc.cores = 1L)
[16:20:41.835]                   }
[16:20:41.835]                   ...future.strategy.old <- future::plan("list")
[16:20:41.835]                   options(future.plan = NULL)
[16:20:41.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.835]                 }
[16:20:41.835]                 ...future.workdir <- getwd()
[16:20:41.835]             }
[16:20:41.835]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.835]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.835]         }
[16:20:41.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.835]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.835]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.835]             base::names(...future.oldOptions))
[16:20:41.835]     }
[16:20:41.835]     if (FALSE) {
[16:20:41.835]     }
[16:20:41.835]     else {
[16:20:41.835]         if (TRUE) {
[16:20:41.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.835]                 open = "w")
[16:20:41.835]         }
[16:20:41.835]         else {
[16:20:41.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.835]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.835]         }
[16:20:41.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.835]             base::sink(type = "output", split = FALSE)
[16:20:41.835]             base::close(...future.stdout)
[16:20:41.835]         }, add = TRUE)
[16:20:41.835]     }
[16:20:41.835]     ...future.frame <- base::sys.nframe()
[16:20:41.835]     ...future.conditions <- base::list()
[16:20:41.835]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.835]     if (FALSE) {
[16:20:41.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.835]     }
[16:20:41.835]     ...future.result <- base::tryCatch({
[16:20:41.835]         base::withCallingHandlers({
[16:20:41.835]             ...future.value <- base::withVisible(base::local({
[16:20:41.835]                 withCallingHandlers({
[16:20:41.835]                   NULL
[16:20:41.835]                 }, immediateCondition = function(cond) {
[16:20:41.835]                   save_rds <- function (object, pathname, ...) 
[16:20:41.835]                   {
[16:20:41.835]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:41.835]                     if (file_test("-f", pathname_tmp)) {
[16:20:41.835]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.835]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:41.835]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.835]                         fi_tmp[["mtime"]])
[16:20:41.835]                     }
[16:20:41.835]                     tryCatch({
[16:20:41.835]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:41.835]                     }, error = function(ex) {
[16:20:41.835]                       msg <- conditionMessage(ex)
[16:20:41.835]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.835]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:41.835]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.835]                         fi_tmp[["mtime"]], msg)
[16:20:41.835]                       ex$message <- msg
[16:20:41.835]                       stop(ex)
[16:20:41.835]                     })
[16:20:41.835]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:41.835]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:41.835]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:41.835]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.835]                       fi <- file.info(pathname)
[16:20:41.835]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:41.835]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.835]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:41.835]                         fi[["size"]], fi[["mtime"]])
[16:20:41.835]                       stop(msg)
[16:20:41.835]                     }
[16:20:41.835]                     invisible(pathname)
[16:20:41.835]                   }
[16:20:41.835]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:41.835]                     rootPath = tempdir()) 
[16:20:41.835]                   {
[16:20:41.835]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:41.835]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:41.835]                       tmpdir = path, fileext = ".rds")
[16:20:41.835]                     save_rds(obj, file)
[16:20:41.835]                   }
[16:20:41.835]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:41.835]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.835]                   {
[16:20:41.835]                     inherits <- base::inherits
[16:20:41.835]                     invokeRestart <- base::invokeRestart
[16:20:41.835]                     is.null <- base::is.null
[16:20:41.835]                     muffled <- FALSE
[16:20:41.835]                     if (inherits(cond, "message")) {
[16:20:41.835]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:41.835]                       if (muffled) 
[16:20:41.835]                         invokeRestart("muffleMessage")
[16:20:41.835]                     }
[16:20:41.835]                     else if (inherits(cond, "warning")) {
[16:20:41.835]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:41.835]                       if (muffled) 
[16:20:41.835]                         invokeRestart("muffleWarning")
[16:20:41.835]                     }
[16:20:41.835]                     else if (inherits(cond, "condition")) {
[16:20:41.835]                       if (!is.null(pattern)) {
[16:20:41.835]                         computeRestarts <- base::computeRestarts
[16:20:41.835]                         grepl <- base::grepl
[16:20:41.835]                         restarts <- computeRestarts(cond)
[16:20:41.835]                         for (restart in restarts) {
[16:20:41.835]                           name <- restart$name
[16:20:41.835]                           if (is.null(name)) 
[16:20:41.835]                             next
[16:20:41.835]                           if (!grepl(pattern, name)) 
[16:20:41.835]                             next
[16:20:41.835]                           invokeRestart(restart)
[16:20:41.835]                           muffled <- TRUE
[16:20:41.835]                           break
[16:20:41.835]                         }
[16:20:41.835]                       }
[16:20:41.835]                     }
[16:20:41.835]                     invisible(muffled)
[16:20:41.835]                   }
[16:20:41.835]                   muffleCondition(cond)
[16:20:41.835]                 })
[16:20:41.835]             }))
[16:20:41.835]             future::FutureResult(value = ...future.value$value, 
[16:20:41.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.835]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.835]                     ...future.globalenv.names))
[16:20:41.835]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.835]         }, condition = base::local({
[16:20:41.835]             c <- base::c
[16:20:41.835]             inherits <- base::inherits
[16:20:41.835]             invokeRestart <- base::invokeRestart
[16:20:41.835]             length <- base::length
[16:20:41.835]             list <- base::list
[16:20:41.835]             seq.int <- base::seq.int
[16:20:41.835]             signalCondition <- base::signalCondition
[16:20:41.835]             sys.calls <- base::sys.calls
[16:20:41.835]             `[[` <- base::`[[`
[16:20:41.835]             `+` <- base::`+`
[16:20:41.835]             `<<-` <- base::`<<-`
[16:20:41.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.835]                   3L)]
[16:20:41.835]             }
[16:20:41.835]             function(cond) {
[16:20:41.835]                 is_error <- inherits(cond, "error")
[16:20:41.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.835]                   NULL)
[16:20:41.835]                 if (is_error) {
[16:20:41.835]                   sessionInformation <- function() {
[16:20:41.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.835]                       search = base::search(), system = base::Sys.info())
[16:20:41.835]                   }
[16:20:41.835]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.835]                     cond$call), session = sessionInformation(), 
[16:20:41.835]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.835]                   signalCondition(cond)
[16:20:41.835]                 }
[16:20:41.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.835]                 "immediateCondition"))) {
[16:20:41.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.835]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.835]                   if (TRUE && !signal) {
[16:20:41.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.835]                     {
[16:20:41.835]                       inherits <- base::inherits
[16:20:41.835]                       invokeRestart <- base::invokeRestart
[16:20:41.835]                       is.null <- base::is.null
[16:20:41.835]                       muffled <- FALSE
[16:20:41.835]                       if (inherits(cond, "message")) {
[16:20:41.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.835]                         if (muffled) 
[16:20:41.835]                           invokeRestart("muffleMessage")
[16:20:41.835]                       }
[16:20:41.835]                       else if (inherits(cond, "warning")) {
[16:20:41.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.835]                         if (muffled) 
[16:20:41.835]                           invokeRestart("muffleWarning")
[16:20:41.835]                       }
[16:20:41.835]                       else if (inherits(cond, "condition")) {
[16:20:41.835]                         if (!is.null(pattern)) {
[16:20:41.835]                           computeRestarts <- base::computeRestarts
[16:20:41.835]                           grepl <- base::grepl
[16:20:41.835]                           restarts <- computeRestarts(cond)
[16:20:41.835]                           for (restart in restarts) {
[16:20:41.835]                             name <- restart$name
[16:20:41.835]                             if (is.null(name)) 
[16:20:41.835]                               next
[16:20:41.835]                             if (!grepl(pattern, name)) 
[16:20:41.835]                               next
[16:20:41.835]                             invokeRestart(restart)
[16:20:41.835]                             muffled <- TRUE
[16:20:41.835]                             break
[16:20:41.835]                           }
[16:20:41.835]                         }
[16:20:41.835]                       }
[16:20:41.835]                       invisible(muffled)
[16:20:41.835]                     }
[16:20:41.835]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.835]                   }
[16:20:41.835]                 }
[16:20:41.835]                 else {
[16:20:41.835]                   if (TRUE) {
[16:20:41.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.835]                     {
[16:20:41.835]                       inherits <- base::inherits
[16:20:41.835]                       invokeRestart <- base::invokeRestart
[16:20:41.835]                       is.null <- base::is.null
[16:20:41.835]                       muffled <- FALSE
[16:20:41.835]                       if (inherits(cond, "message")) {
[16:20:41.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.835]                         if (muffled) 
[16:20:41.835]                           invokeRestart("muffleMessage")
[16:20:41.835]                       }
[16:20:41.835]                       else if (inherits(cond, "warning")) {
[16:20:41.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.835]                         if (muffled) 
[16:20:41.835]                           invokeRestart("muffleWarning")
[16:20:41.835]                       }
[16:20:41.835]                       else if (inherits(cond, "condition")) {
[16:20:41.835]                         if (!is.null(pattern)) {
[16:20:41.835]                           computeRestarts <- base::computeRestarts
[16:20:41.835]                           grepl <- base::grepl
[16:20:41.835]                           restarts <- computeRestarts(cond)
[16:20:41.835]                           for (restart in restarts) {
[16:20:41.835]                             name <- restart$name
[16:20:41.835]                             if (is.null(name)) 
[16:20:41.835]                               next
[16:20:41.835]                             if (!grepl(pattern, name)) 
[16:20:41.835]                               next
[16:20:41.835]                             invokeRestart(restart)
[16:20:41.835]                             muffled <- TRUE
[16:20:41.835]                             break
[16:20:41.835]                           }
[16:20:41.835]                         }
[16:20:41.835]                       }
[16:20:41.835]                       invisible(muffled)
[16:20:41.835]                     }
[16:20:41.835]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.835]                   }
[16:20:41.835]                 }
[16:20:41.835]             }
[16:20:41.835]         }))
[16:20:41.835]     }, error = function(ex) {
[16:20:41.835]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.835]                 ...future.rng), started = ...future.startTime, 
[16:20:41.835]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.835]             version = "1.8"), class = "FutureResult")
[16:20:41.835]     }, finally = {
[16:20:41.835]         if (!identical(...future.workdir, getwd())) 
[16:20:41.835]             setwd(...future.workdir)
[16:20:41.835]         {
[16:20:41.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.835]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.835]             }
[16:20:41.835]             base::options(...future.oldOptions)
[16:20:41.835]             if (.Platform$OS.type == "windows") {
[16:20:41.835]                 old_names <- names(...future.oldEnvVars)
[16:20:41.835]                 envs <- base::Sys.getenv()
[16:20:41.835]                 names <- names(envs)
[16:20:41.835]                 common <- intersect(names, old_names)
[16:20:41.835]                 added <- setdiff(names, old_names)
[16:20:41.835]                 removed <- setdiff(old_names, names)
[16:20:41.835]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.835]                   envs[common]]
[16:20:41.835]                 NAMES <- toupper(changed)
[16:20:41.835]                 args <- list()
[16:20:41.835]                 for (kk in seq_along(NAMES)) {
[16:20:41.835]                   name <- changed[[kk]]
[16:20:41.835]                   NAME <- NAMES[[kk]]
[16:20:41.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.835]                     next
[16:20:41.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.835]                 }
[16:20:41.835]                 NAMES <- toupper(added)
[16:20:41.835]                 for (kk in seq_along(NAMES)) {
[16:20:41.835]                   name <- added[[kk]]
[16:20:41.835]                   NAME <- NAMES[[kk]]
[16:20:41.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.835]                     next
[16:20:41.835]                   args[[name]] <- ""
[16:20:41.835]                 }
[16:20:41.835]                 NAMES <- toupper(removed)
[16:20:41.835]                 for (kk in seq_along(NAMES)) {
[16:20:41.835]                   name <- removed[[kk]]
[16:20:41.835]                   NAME <- NAMES[[kk]]
[16:20:41.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.835]                     next
[16:20:41.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.835]                 }
[16:20:41.835]                 if (length(args) > 0) 
[16:20:41.835]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.835]             }
[16:20:41.835]             else {
[16:20:41.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.835]             }
[16:20:41.835]             {
[16:20:41.835]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.835]                   0L) {
[16:20:41.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.835]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.835]                   base::options(opts)
[16:20:41.835]                 }
[16:20:41.835]                 {
[16:20:41.835]                   {
[16:20:41.835]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:41.835]                     NULL
[16:20:41.835]                   }
[16:20:41.835]                   options(future.plan = NULL)
[16:20:41.835]                   if (is.na(NA_character_)) 
[16:20:41.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.835]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.835]                     .init = FALSE)
[16:20:41.835]                 }
[16:20:41.835]             }
[16:20:41.835]         }
[16:20:41.835]     })
[16:20:41.835]     if (TRUE) {
[16:20:41.835]         base::sink(type = "output", split = FALSE)
[16:20:41.835]         if (TRUE) {
[16:20:41.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.835]         }
[16:20:41.835]         else {
[16:20:41.835]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.835]         }
[16:20:41.835]         base::close(...future.stdout)
[16:20:41.835]         ...future.stdout <- NULL
[16:20:41.835]     }
[16:20:41.835]     ...future.result$conditions <- ...future.conditions
[16:20:41.835]     ...future.result$finished <- base::Sys.time()
[16:20:41.835]     ...future.result
[16:20:41.835] }
[16:20:41.838] requestCore(): workers = 2
[16:20:41.840] MulticoreFuture started
[16:20:41.845] - Launch lazy future ... done
[16:20:41.846] run() for ‘MulticoreFuture’ ... done
[16:20:41.846] plan(): Setting new future strategy stack:
List of 6
 $ a:[16:20:41.846] List of future strategies:
[16:20:41.846] 1. sequential:
[16:20:41.846]    - args: function (..., envir = parent.frame())
[16:20:41.846]    - tweaked: FALSE
[16:20:41.846]    - call: NULL
[16:20:41.848] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0be6feb8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c2cc670> 
 $  :[16:20:41.850] plan(): Setting new future strategy stack:
 NULL
 $  :[16:20:41.851] List of future strategies:
[16:20:41.851] 1. multicore:
[16:20:41.851]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:41.851]    - tweaked: FALSE
[16:20:41.851]    - call: plan(strategy)
 NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0be6feb8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c2cc670> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=[16:20:41.856] plan(): nbrOfWorkers() = 2
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:41.861] resolve() on list ...
[16:20:41.861]  recursive: 0
[16:20:41.861]  length: 6
[16:20:41.861]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:41.861] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.862] - nx: 6
[16:20:41.862] - relay: TRUE
[16:20:41.862] - stdout: TRUE
[16:20:41.862] - signal: TRUE
[16:20:41.862] - resignal: FALSE
[16:20:41.862] - force: TRUE
[16:20:41.862] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.862] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.863]  - until=2
[16:20:41.863]  - relaying element #2
[16:20:41.863] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.863] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.863] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.863]  length: 5 (resolved future 1)
[16:20:41.864] Future #2
[16:20:41.864] result() for MulticoreFuture ...
[16:20:41.865] result() for MulticoreFuture ...
[16:20:41.865] result() for MulticoreFuture ... done
[16:20:41.865] result() for MulticoreFuture ... done
[16:20:41.865] result() for MulticoreFuture ...
[16:20:41.865] result() for MulticoreFuture ... done
[16:20:41.865] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:41.865] - nx: 6
[16:20:41.865] - relay: TRUE
[16:20:41.866] - stdout: TRUE
[16:20:41.866] - signal: TRUE
[16:20:41.866] - resignal: FALSE
[16:20:41.866] - force: TRUE
[16:20:41.866] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.866] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.866]  - until=2
[16:20:41.866]  - relaying element #2
[16:20:41.867] result() for MulticoreFuture ...
[16:20:41.867] result() for MulticoreFuture ... done
[16:20:41.867] result() for MulticoreFuture ...
[16:20:41.867] result() for MulticoreFuture ... done
[16:20:41.867] result() for MulticoreFuture ...
[16:20:41.867] result() for MulticoreFuture ... done
[16:20:41.867] result() for MulticoreFuture ...
[16:20:41.867] result() for MulticoreFuture ... done
[16:20:41.868] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.868] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.868] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:41.868]  length: 4 (resolved future 2)
[16:20:41.868] Future #3
[16:20:41.868] result() for MulticoreFuture ...
[16:20:41.869] result() for MulticoreFuture ...
[16:20:41.869] result() for MulticoreFuture ... done
[16:20:41.869] result() for MulticoreFuture ... done
[16:20:41.869] result() for MulticoreFuture ...
[16:20:41.869] result() for MulticoreFuture ... done
[16:20:41.870] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:41.870] - nx: 6
[16:20:41.870] - relay: TRUE
[16:20:41.870] - stdout: TRUE
[16:20:41.870] - signal: TRUE
[16:20:41.870] - resignal: FALSE
[16:20:41.870] - force: TRUE
[16:20:41.871] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.871] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.871]  - until=3
[16:20:41.871]  - relaying element #3
[16:20:41.871] result() for MulticoreFuture ...
[16:20:41.871] result() for MulticoreFuture ... done
[16:20:41.871] result() for MulticoreFuture ...
[16:20:41.871] result() for MulticoreFuture ... done
[16:20:41.871] result() for MulticoreFuture ...
[16:20:41.871] result() for MulticoreFuture ... done
[16:20:41.872] result() for MulticoreFuture ...
[16:20:41.872] result() for MulticoreFuture ... done
[16:20:41.872] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.872] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.872] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:41.872]  length: 3 (resolved future 3)
[16:20:41.872] signalConditionsASAP(NULL, pos=4) ...
[16:20:41.872] - nx: 6
[16:20:41.873] - relay: TRUE
[16:20:41.873] - stdout: TRUE
[16:20:41.873] - signal: TRUE
[16:20:41.873] - resignal: FALSE
[16:20:41.873] - force: TRUE
[16:20:41.873] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.873] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.873]  - until=5
[16:20:41.873]  - relaying element #5
[16:20:41.873] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.873] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.874] signalConditionsASAP(NULL, pos=4) ... done
[16:20:41.874]  length: 2 (resolved future 4)
[16:20:41.874] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.874] - nx: 6
[16:20:41.874] - relay: TRUE
[16:20:41.874] - stdout: TRUE
[16:20:41.874] - signal: TRUE
[16:20:41.874] - resignal: FALSE
[16:20:41.874] - force: TRUE
[16:20:41.874] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.874] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.875]  - until=6
[16:20:41.875]  - relaying element #6
[16:20:41.875] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.875] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.875] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.875]  length: 1 (resolved future 5)
[16:20:41.875] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.875] - nx: 6
[16:20:41.875] - relay: TRUE
[16:20:41.875] - stdout: TRUE
[16:20:41.876] - signal: TRUE
[16:20:41.876] - resignal: FALSE
[16:20:41.876] - force: TRUE
[16:20:41.876] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.876] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.876]  - until=6
[16:20:41.876] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.876] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.876] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.877]  length: 0 (resolved future 6)
[16:20:41.877] Relaying remaining futures
[16:20:41.877] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.877] - nx: 6
[16:20:41.877] - relay: TRUE
[16:20:41.877] - stdout: TRUE
[16:20:41.877] - signal: TRUE
[16:20:41.877] - resignal: FALSE
[16:20:41.877] - force: TRUE
[16:20:41.877] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.878] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:41.878] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.878] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.878] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.878] resolve() on list ... DONE
[16:20:41.878] result() for MulticoreFuture ...
[16:20:41.878] result() for MulticoreFuture ... done
[16:20:41.878] result() for MulticoreFuture ...
[16:20:41.878] result() for MulticoreFuture ... done
[16:20:41.879] result() for MulticoreFuture ...
[16:20:41.879] result() for MulticoreFuture ... done
[16:20:41.879] result() for MulticoreFuture ...
[16:20:41.879] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:20:41.884] getGlobalsAndPackages() ...
[16:20:41.884] Searching for globals...
[16:20:41.884] 
[16:20:41.885] Searching for globals ... DONE
[16:20:41.885] - globals: [0] <none>
[16:20:41.885] getGlobalsAndPackages() ... DONE
[16:20:41.885] run() for ‘Future’ ...
[16:20:41.885] - state: ‘created’
[16:20:41.885] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:41.889] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:41.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:41.890]   - Field: ‘label’
[16:20:41.890]   - Field: ‘local’
[16:20:41.890]   - Field: ‘owner’
[16:20:41.890]   - Field: ‘envir’
[16:20:41.890]   - Field: ‘workers’
[16:20:41.890]   - Field: ‘packages’
[16:20:41.890]   - Field: ‘gc’
[16:20:41.891]   - Field: ‘job’
[16:20:41.891]   - Field: ‘conditions’
[16:20:41.891]   - Field: ‘expr’
[16:20:41.891]   - Field: ‘uuid’
[16:20:41.891]   - Field: ‘seed’
[16:20:41.891]   - Field: ‘version’
[16:20:41.891]   - Field: ‘result’
[16:20:41.891]   - Field: ‘asynchronous’
[16:20:41.891]   - Field: ‘calls’
[16:20:41.891]   - Field: ‘globals’
[16:20:41.891]   - Field: ‘stdout’
[16:20:41.892]   - Field: ‘earlySignal’
[16:20:41.892]   - Field: ‘lazy’
[16:20:41.892]   - Field: ‘state’
[16:20:41.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:41.892] - Launch lazy future ...
[16:20:41.892] Packages needed by the future expression (n = 0): <none>
[16:20:41.892] Packages needed by future strategies (n = 0): <none>
[16:20:41.893] {
[16:20:41.893]     {
[16:20:41.893]         {
[16:20:41.893]             ...future.startTime <- base::Sys.time()
[16:20:41.893]             {
[16:20:41.893]                 {
[16:20:41.893]                   {
[16:20:41.893]                     {
[16:20:41.893]                       base::local({
[16:20:41.893]                         has_future <- base::requireNamespace("future", 
[16:20:41.893]                           quietly = TRUE)
[16:20:41.893]                         if (has_future) {
[16:20:41.893]                           ns <- base::getNamespace("future")
[16:20:41.893]                           version <- ns[[".package"]][["version"]]
[16:20:41.893]                           if (is.null(version)) 
[16:20:41.893]                             version <- utils::packageVersion("future")
[16:20:41.893]                         }
[16:20:41.893]                         else {
[16:20:41.893]                           version <- NULL
[16:20:41.893]                         }
[16:20:41.893]                         if (!has_future || version < "1.8.0") {
[16:20:41.893]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.893]                             "", base::R.version$version.string), 
[16:20:41.893]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:41.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.893]                               "release", "version")], collapse = " "), 
[16:20:41.893]                             hostname = base::Sys.info()[["nodename"]])
[16:20:41.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.893]                             info)
[16:20:41.893]                           info <- base::paste(info, collapse = "; ")
[16:20:41.893]                           if (!has_future) {
[16:20:41.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.893]                               info)
[16:20:41.893]                           }
[16:20:41.893]                           else {
[16:20:41.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.893]                               info, version)
[16:20:41.893]                           }
[16:20:41.893]                           base::stop(msg)
[16:20:41.893]                         }
[16:20:41.893]                       })
[16:20:41.893]                     }
[16:20:41.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:41.893]                     base::options(mc.cores = 1L)
[16:20:41.893]                   }
[16:20:41.893]                   ...future.strategy.old <- future::plan("list")
[16:20:41.893]                   options(future.plan = NULL)
[16:20:41.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.893]                 }
[16:20:41.893]                 ...future.workdir <- getwd()
[16:20:41.893]             }
[16:20:41.893]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.893]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.893]         }
[16:20:41.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.893]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.893]             base::names(...future.oldOptions))
[16:20:41.893]     }
[16:20:41.893]     if (FALSE) {
[16:20:41.893]     }
[16:20:41.893]     else {
[16:20:41.893]         if (TRUE) {
[16:20:41.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.893]                 open = "w")
[16:20:41.893]         }
[16:20:41.893]         else {
[16:20:41.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.893]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.893]         }
[16:20:41.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.893]             base::sink(type = "output", split = FALSE)
[16:20:41.893]             base::close(...future.stdout)
[16:20:41.893]         }, add = TRUE)
[16:20:41.893]     }
[16:20:41.893]     ...future.frame <- base::sys.nframe()
[16:20:41.893]     ...future.conditions <- base::list()
[16:20:41.893]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.893]     if (FALSE) {
[16:20:41.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.893]     }
[16:20:41.893]     ...future.result <- base::tryCatch({
[16:20:41.893]         base::withCallingHandlers({
[16:20:41.893]             ...future.value <- base::withVisible(base::local({
[16:20:41.893]                 withCallingHandlers({
[16:20:41.893]                   2
[16:20:41.893]                 }, immediateCondition = function(cond) {
[16:20:41.893]                   save_rds <- function (object, pathname, ...) 
[16:20:41.893]                   {
[16:20:41.893]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:41.893]                     if (file_test("-f", pathname_tmp)) {
[16:20:41.893]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.893]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:41.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.893]                         fi_tmp[["mtime"]])
[16:20:41.893]                     }
[16:20:41.893]                     tryCatch({
[16:20:41.893]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:41.893]                     }, error = function(ex) {
[16:20:41.893]                       msg <- conditionMessage(ex)
[16:20:41.893]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.893]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:41.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.893]                         fi_tmp[["mtime"]], msg)
[16:20:41.893]                       ex$message <- msg
[16:20:41.893]                       stop(ex)
[16:20:41.893]                     })
[16:20:41.893]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:41.893]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:41.893]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:41.893]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.893]                       fi <- file.info(pathname)
[16:20:41.893]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:41.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.893]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:41.893]                         fi[["size"]], fi[["mtime"]])
[16:20:41.893]                       stop(msg)
[16:20:41.893]                     }
[16:20:41.893]                     invisible(pathname)
[16:20:41.893]                   }
[16:20:41.893]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:41.893]                     rootPath = tempdir()) 
[16:20:41.893]                   {
[16:20:41.893]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:41.893]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:41.893]                       tmpdir = path, fileext = ".rds")
[16:20:41.893]                     save_rds(obj, file)
[16:20:41.893]                   }
[16:20:41.893]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:41.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.893]                   {
[16:20:41.893]                     inherits <- base::inherits
[16:20:41.893]                     invokeRestart <- base::invokeRestart
[16:20:41.893]                     is.null <- base::is.null
[16:20:41.893]                     muffled <- FALSE
[16:20:41.893]                     if (inherits(cond, "message")) {
[16:20:41.893]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:41.893]                       if (muffled) 
[16:20:41.893]                         invokeRestart("muffleMessage")
[16:20:41.893]                     }
[16:20:41.893]                     else if (inherits(cond, "warning")) {
[16:20:41.893]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:41.893]                       if (muffled) 
[16:20:41.893]                         invokeRestart("muffleWarning")
[16:20:41.893]                     }
[16:20:41.893]                     else if (inherits(cond, "condition")) {
[16:20:41.893]                       if (!is.null(pattern)) {
[16:20:41.893]                         computeRestarts <- base::computeRestarts
[16:20:41.893]                         grepl <- base::grepl
[16:20:41.893]                         restarts <- computeRestarts(cond)
[16:20:41.893]                         for (restart in restarts) {
[16:20:41.893]                           name <- restart$name
[16:20:41.893]                           if (is.null(name)) 
[16:20:41.893]                             next
[16:20:41.893]                           if (!grepl(pattern, name)) 
[16:20:41.893]                             next
[16:20:41.893]                           invokeRestart(restart)
[16:20:41.893]                           muffled <- TRUE
[16:20:41.893]                           break
[16:20:41.893]                         }
[16:20:41.893]                       }
[16:20:41.893]                     }
[16:20:41.893]                     invisible(muffled)
[16:20:41.893]                   }
[16:20:41.893]                   muffleCondition(cond)
[16:20:41.893]                 })
[16:20:41.893]             }))
[16:20:41.893]             future::FutureResult(value = ...future.value$value, 
[16:20:41.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.893]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.893]                     ...future.globalenv.names))
[16:20:41.893]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.893]         }, condition = base::local({
[16:20:41.893]             c <- base::c
[16:20:41.893]             inherits <- base::inherits
[16:20:41.893]             invokeRestart <- base::invokeRestart
[16:20:41.893]             length <- base::length
[16:20:41.893]             list <- base::list
[16:20:41.893]             seq.int <- base::seq.int
[16:20:41.893]             signalCondition <- base::signalCondition
[16:20:41.893]             sys.calls <- base::sys.calls
[16:20:41.893]             `[[` <- base::`[[`
[16:20:41.893]             `+` <- base::`+`
[16:20:41.893]             `<<-` <- base::`<<-`
[16:20:41.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.893]                   3L)]
[16:20:41.893]             }
[16:20:41.893]             function(cond) {
[16:20:41.893]                 is_error <- inherits(cond, "error")
[16:20:41.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.893]                   NULL)
[16:20:41.893]                 if (is_error) {
[16:20:41.893]                   sessionInformation <- function() {
[16:20:41.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.893]                       search = base::search(), system = base::Sys.info())
[16:20:41.893]                   }
[16:20:41.893]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.893]                     cond$call), session = sessionInformation(), 
[16:20:41.893]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.893]                   signalCondition(cond)
[16:20:41.893]                 }
[16:20:41.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.893]                 "immediateCondition"))) {
[16:20:41.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.893]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.893]                   if (TRUE && !signal) {
[16:20:41.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.893]                     {
[16:20:41.893]                       inherits <- base::inherits
[16:20:41.893]                       invokeRestart <- base::invokeRestart
[16:20:41.893]                       is.null <- base::is.null
[16:20:41.893]                       muffled <- FALSE
[16:20:41.893]                       if (inherits(cond, "message")) {
[16:20:41.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.893]                         if (muffled) 
[16:20:41.893]                           invokeRestart("muffleMessage")
[16:20:41.893]                       }
[16:20:41.893]                       else if (inherits(cond, "warning")) {
[16:20:41.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.893]                         if (muffled) 
[16:20:41.893]                           invokeRestart("muffleWarning")
[16:20:41.893]                       }
[16:20:41.893]                       else if (inherits(cond, "condition")) {
[16:20:41.893]                         if (!is.null(pattern)) {
[16:20:41.893]                           computeRestarts <- base::computeRestarts
[16:20:41.893]                           grepl <- base::grepl
[16:20:41.893]                           restarts <- computeRestarts(cond)
[16:20:41.893]                           for (restart in restarts) {
[16:20:41.893]                             name <- restart$name
[16:20:41.893]                             if (is.null(name)) 
[16:20:41.893]                               next
[16:20:41.893]                             if (!grepl(pattern, name)) 
[16:20:41.893]                               next
[16:20:41.893]                             invokeRestart(restart)
[16:20:41.893]                             muffled <- TRUE
[16:20:41.893]                             break
[16:20:41.893]                           }
[16:20:41.893]                         }
[16:20:41.893]                       }
[16:20:41.893]                       invisible(muffled)
[16:20:41.893]                     }
[16:20:41.893]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.893]                   }
[16:20:41.893]                 }
[16:20:41.893]                 else {
[16:20:41.893]                   if (TRUE) {
[16:20:41.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.893]                     {
[16:20:41.893]                       inherits <- base::inherits
[16:20:41.893]                       invokeRestart <- base::invokeRestart
[16:20:41.893]                       is.null <- base::is.null
[16:20:41.893]                       muffled <- FALSE
[16:20:41.893]                       if (inherits(cond, "message")) {
[16:20:41.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.893]                         if (muffled) 
[16:20:41.893]                           invokeRestart("muffleMessage")
[16:20:41.893]                       }
[16:20:41.893]                       else if (inherits(cond, "warning")) {
[16:20:41.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.893]                         if (muffled) 
[16:20:41.893]                           invokeRestart("muffleWarning")
[16:20:41.893]                       }
[16:20:41.893]                       else if (inherits(cond, "condition")) {
[16:20:41.893]                         if (!is.null(pattern)) {
[16:20:41.893]                           computeRestarts <- base::computeRestarts
[16:20:41.893]                           grepl <- base::grepl
[16:20:41.893]                           restarts <- computeRestarts(cond)
[16:20:41.893]                           for (restart in restarts) {
[16:20:41.893]                             name <- restart$name
[16:20:41.893]                             if (is.null(name)) 
[16:20:41.893]                               next
[16:20:41.893]                             if (!grepl(pattern, name)) 
[16:20:41.893]                               next
[16:20:41.893]                             invokeRestart(restart)
[16:20:41.893]                             muffled <- TRUE
[16:20:41.893]                             break
[16:20:41.893]                           }
[16:20:41.893]                         }
[16:20:41.893]                       }
[16:20:41.893]                       invisible(muffled)
[16:20:41.893]                     }
[16:20:41.893]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.893]                   }
[16:20:41.893]                 }
[16:20:41.893]             }
[16:20:41.893]         }))
[16:20:41.893]     }, error = function(ex) {
[16:20:41.893]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.893]                 ...future.rng), started = ...future.startTime, 
[16:20:41.893]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.893]             version = "1.8"), class = "FutureResult")
[16:20:41.893]     }, finally = {
[16:20:41.893]         if (!identical(...future.workdir, getwd())) 
[16:20:41.893]             setwd(...future.workdir)
[16:20:41.893]         {
[16:20:41.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.893]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.893]             }
[16:20:41.893]             base::options(...future.oldOptions)
[16:20:41.893]             if (.Platform$OS.type == "windows") {
[16:20:41.893]                 old_names <- names(...future.oldEnvVars)
[16:20:41.893]                 envs <- base::Sys.getenv()
[16:20:41.893]                 names <- names(envs)
[16:20:41.893]                 common <- intersect(names, old_names)
[16:20:41.893]                 added <- setdiff(names, old_names)
[16:20:41.893]                 removed <- setdiff(old_names, names)
[16:20:41.893]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.893]                   envs[common]]
[16:20:41.893]                 NAMES <- toupper(changed)
[16:20:41.893]                 args <- list()
[16:20:41.893]                 for (kk in seq_along(NAMES)) {
[16:20:41.893]                   name <- changed[[kk]]
[16:20:41.893]                   NAME <- NAMES[[kk]]
[16:20:41.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.893]                     next
[16:20:41.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.893]                 }
[16:20:41.893]                 NAMES <- toupper(added)
[16:20:41.893]                 for (kk in seq_along(NAMES)) {
[16:20:41.893]                   name <- added[[kk]]
[16:20:41.893]                   NAME <- NAMES[[kk]]
[16:20:41.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.893]                     next
[16:20:41.893]                   args[[name]] <- ""
[16:20:41.893]                 }
[16:20:41.893]                 NAMES <- toupper(removed)
[16:20:41.893]                 for (kk in seq_along(NAMES)) {
[16:20:41.893]                   name <- removed[[kk]]
[16:20:41.893]                   NAME <- NAMES[[kk]]
[16:20:41.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.893]                     next
[16:20:41.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.893]                 }
[16:20:41.893]                 if (length(args) > 0) 
[16:20:41.893]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.893]             }
[16:20:41.893]             else {
[16:20:41.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.893]             }
[16:20:41.893]             {
[16:20:41.893]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.893]                   0L) {
[16:20:41.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.893]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.893]                   base::options(opts)
[16:20:41.893]                 }
[16:20:41.893]                 {
[16:20:41.893]                   {
[16:20:41.893]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:41.893]                     NULL
[16:20:41.893]                   }
[16:20:41.893]                   options(future.plan = NULL)
[16:20:41.893]                   if (is.na(NA_character_)) 
[16:20:41.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.893]                     .init = FALSE)
[16:20:41.893]                 }
[16:20:41.893]             }
[16:20:41.893]         }
[16:20:41.893]     })
[16:20:41.893]     if (TRUE) {
[16:20:41.893]         base::sink(type = "output", split = FALSE)
[16:20:41.893]         if (TRUE) {
[16:20:41.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.893]         }
[16:20:41.893]         else {
[16:20:41.893]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.893]         }
[16:20:41.893]         base::close(...future.stdout)
[16:20:41.893]         ...future.stdout <- NULL
[16:20:41.893]     }
[16:20:41.893]     ...future.result$conditions <- ...future.conditions
[16:20:41.893]     ...future.result$finished <- base::Sys.time()
[16:20:41.893]     ...future.result
[16:20:41.893] }
[16:20:41.895] requestCore(): workers = 2
[16:20:41.897] MulticoreFuture started
[16:20:41.897] - Launch lazy future ... done
[16:20:41.898] run() for ‘MulticoreFuture’ ... done
[16:20:41.898] getGlobalsAndPackages() ...
[16:20:41.898] Searching for globals...
[16:20:41.898] plan(): Setting new future strategy stack:
[16:20:41.898] List of future strategies:
[16:20:41.898] 1. sequential:
[16:20:41.898]    - args: function (..., envir = parent.frame())
[16:20:41.898]    - tweaked: FALSE
[16:20:41.898]    - call: NULL
[16:20:41.899] 
[16:20:41.899] Searching for globals ... DONE
[16:20:41.899] plan(): nbrOfWorkers() = 1
[16:20:41.899] - globals: [0] <none>
[16:20:41.900] getGlobalsAndPackages() ... DONE
[16:20:41.900] run() for ‘Future’ ...
[16:20:41.900] - state: ‘created’
[16:20:41.901] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:41.901] plan(): Setting new future strategy stack:
[16:20:41.901] List of future strategies:
[16:20:41.901] 1. multicore:
[16:20:41.901]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:41.901]    - tweaked: FALSE
[16:20:41.901]    - call: plan(strategy)
[16:20:41.906] plan(): nbrOfWorkers() = 2
[16:20:41.906] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:41.907] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:41.907]   - Field: ‘label’
[16:20:41.907]   - Field: ‘local’
[16:20:41.907]   - Field: ‘owner’
[16:20:41.907]   - Field: ‘envir’
[16:20:41.908]   - Field: ‘workers’
[16:20:41.908]   - Field: ‘packages’
[16:20:41.908]   - Field: ‘gc’
[16:20:41.908]   - Field: ‘job’
[16:20:41.908]   - Field: ‘conditions’
[16:20:41.908]   - Field: ‘expr’
[16:20:41.909]   - Field: ‘uuid’
[16:20:41.909]   - Field: ‘seed’
[16:20:41.909]   - Field: ‘version’
[16:20:41.909]   - Field: ‘result’
[16:20:41.909]   - Field: ‘asynchronous’
[16:20:41.909]   - Field: ‘calls’
[16:20:41.909]   - Field: ‘globals’
[16:20:41.910]   - Field: ‘stdout’
[16:20:41.910]   - Field: ‘earlySignal’
[16:20:41.910]   - Field: ‘lazy’
[16:20:41.910]   - Field: ‘state’
[16:20:41.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:41.910] - Launch lazy future ...
[16:20:41.911] Packages needed by the future expression (n = 0): <none>
[16:20:41.911] Packages needed by future strategies (n = 0): <none>
[16:20:41.912] {
[16:20:41.912]     {
[16:20:41.912]         {
[16:20:41.912]             ...future.startTime <- base::Sys.time()
[16:20:41.912]             {
[16:20:41.912]                 {
[16:20:41.912]                   {
[16:20:41.912]                     {
[16:20:41.912]                       base::local({
[16:20:41.912]                         has_future <- base::requireNamespace("future", 
[16:20:41.912]                           quietly = TRUE)
[16:20:41.912]                         if (has_future) {
[16:20:41.912]                           ns <- base::getNamespace("future")
[16:20:41.912]                           version <- ns[[".package"]][["version"]]
[16:20:41.912]                           if (is.null(version)) 
[16:20:41.912]                             version <- utils::packageVersion("future")
[16:20:41.912]                         }
[16:20:41.912]                         else {
[16:20:41.912]                           version <- NULL
[16:20:41.912]                         }
[16:20:41.912]                         if (!has_future || version < "1.8.0") {
[16:20:41.912]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.912]                             "", base::R.version$version.string), 
[16:20:41.912]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:41.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.912]                               "release", "version")], collapse = " "), 
[16:20:41.912]                             hostname = base::Sys.info()[["nodename"]])
[16:20:41.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.912]                             info)
[16:20:41.912]                           info <- base::paste(info, collapse = "; ")
[16:20:41.912]                           if (!has_future) {
[16:20:41.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.912]                               info)
[16:20:41.912]                           }
[16:20:41.912]                           else {
[16:20:41.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.912]                               info, version)
[16:20:41.912]                           }
[16:20:41.912]                           base::stop(msg)
[16:20:41.912]                         }
[16:20:41.912]                       })
[16:20:41.912]                     }
[16:20:41.912]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:41.912]                     base::options(mc.cores = 1L)
[16:20:41.912]                   }
[16:20:41.912]                   ...future.strategy.old <- future::plan("list")
[16:20:41.912]                   options(future.plan = NULL)
[16:20:41.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.912]                 }
[16:20:41.912]                 ...future.workdir <- getwd()
[16:20:41.912]             }
[16:20:41.912]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.912]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.912]         }
[16:20:41.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.912]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.912]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.912]             base::names(...future.oldOptions))
[16:20:41.912]     }
[16:20:41.912]     if (FALSE) {
[16:20:41.912]     }
[16:20:41.912]     else {
[16:20:41.912]         if (TRUE) {
[16:20:41.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.912]                 open = "w")
[16:20:41.912]         }
[16:20:41.912]         else {
[16:20:41.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.912]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.912]         }
[16:20:41.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.912]             base::sink(type = "output", split = FALSE)
[16:20:41.912]             base::close(...future.stdout)
[16:20:41.912]         }, add = TRUE)
[16:20:41.912]     }
[16:20:41.912]     ...future.frame <- base::sys.nframe()
[16:20:41.912]     ...future.conditions <- base::list()
[16:20:41.912]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.912]     if (FALSE) {
[16:20:41.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.912]     }
[16:20:41.912]     ...future.result <- base::tryCatch({
[16:20:41.912]         base::withCallingHandlers({
[16:20:41.912]             ...future.value <- base::withVisible(base::local({
[16:20:41.912]                 withCallingHandlers({
[16:20:41.912]                   NULL
[16:20:41.912]                 }, immediateCondition = function(cond) {
[16:20:41.912]                   save_rds <- function (object, pathname, ...) 
[16:20:41.912]                   {
[16:20:41.912]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:41.912]                     if (file_test("-f", pathname_tmp)) {
[16:20:41.912]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.912]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:41.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.912]                         fi_tmp[["mtime"]])
[16:20:41.912]                     }
[16:20:41.912]                     tryCatch({
[16:20:41.912]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:41.912]                     }, error = function(ex) {
[16:20:41.912]                       msg <- conditionMessage(ex)
[16:20:41.912]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.912]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:41.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.912]                         fi_tmp[["mtime"]], msg)
[16:20:41.912]                       ex$message <- msg
[16:20:41.912]                       stop(ex)
[16:20:41.912]                     })
[16:20:41.912]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:41.912]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:41.912]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:41.912]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.912]                       fi <- file.info(pathname)
[16:20:41.912]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:41.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.912]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:41.912]                         fi[["size"]], fi[["mtime"]])
[16:20:41.912]                       stop(msg)
[16:20:41.912]                     }
[16:20:41.912]                     invisible(pathname)
[16:20:41.912]                   }
[16:20:41.912]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:41.912]                     rootPath = tempdir()) 
[16:20:41.912]                   {
[16:20:41.912]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:41.912]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:41.912]                       tmpdir = path, fileext = ".rds")
[16:20:41.912]                     save_rds(obj, file)
[16:20:41.912]                   }
[16:20:41.912]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:41.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.912]                   {
[16:20:41.912]                     inherits <- base::inherits
[16:20:41.912]                     invokeRestart <- base::invokeRestart
[16:20:41.912]                     is.null <- base::is.null
[16:20:41.912]                     muffled <- FALSE
[16:20:41.912]                     if (inherits(cond, "message")) {
[16:20:41.912]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:41.912]                       if (muffled) 
[16:20:41.912]                         invokeRestart("muffleMessage")
[16:20:41.912]                     }
[16:20:41.912]                     else if (inherits(cond, "warning")) {
[16:20:41.912]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:41.912]                       if (muffled) 
[16:20:41.912]                         invokeRestart("muffleWarning")
[16:20:41.912]                     }
[16:20:41.912]                     else if (inherits(cond, "condition")) {
[16:20:41.912]                       if (!is.null(pattern)) {
[16:20:41.912]                         computeRestarts <- base::computeRestarts
[16:20:41.912]                         grepl <- base::grepl
[16:20:41.912]                         restarts <- computeRestarts(cond)
[16:20:41.912]                         for (restart in restarts) {
[16:20:41.912]                           name <- restart$name
[16:20:41.912]                           if (is.null(name)) 
[16:20:41.912]                             next
[16:20:41.912]                           if (!grepl(pattern, name)) 
[16:20:41.912]                             next
[16:20:41.912]                           invokeRestart(restart)
[16:20:41.912]                           muffled <- TRUE
[16:20:41.912]                           break
[16:20:41.912]                         }
[16:20:41.912]                       }
[16:20:41.912]                     }
[16:20:41.912]                     invisible(muffled)
[16:20:41.912]                   }
[16:20:41.912]                   muffleCondition(cond)
[16:20:41.912]                 })
[16:20:41.912]             }))
[16:20:41.912]             future::FutureResult(value = ...future.value$value, 
[16:20:41.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.912]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.912]                     ...future.globalenv.names))
[16:20:41.912]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.912]         }, condition = base::local({
[16:20:41.912]             c <- base::c
[16:20:41.912]             inherits <- base::inherits
[16:20:41.912]             invokeRestart <- base::invokeRestart
[16:20:41.912]             length <- base::length
[16:20:41.912]             list <- base::list
[16:20:41.912]             seq.int <- base::seq.int
[16:20:41.912]             signalCondition <- base::signalCondition
[16:20:41.912]             sys.calls <- base::sys.calls
[16:20:41.912]             `[[` <- base::`[[`
[16:20:41.912]             `+` <- base::`+`
[16:20:41.912]             `<<-` <- base::`<<-`
[16:20:41.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.912]                   3L)]
[16:20:41.912]             }
[16:20:41.912]             function(cond) {
[16:20:41.912]                 is_error <- inherits(cond, "error")
[16:20:41.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.912]                   NULL)
[16:20:41.912]                 if (is_error) {
[16:20:41.912]                   sessionInformation <- function() {
[16:20:41.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.912]                       search = base::search(), system = base::Sys.info())
[16:20:41.912]                   }
[16:20:41.912]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.912]                     cond$call), session = sessionInformation(), 
[16:20:41.912]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.912]                   signalCondition(cond)
[16:20:41.912]                 }
[16:20:41.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.912]                 "immediateCondition"))) {
[16:20:41.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.912]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.912]                   if (TRUE && !signal) {
[16:20:41.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.912]                     {
[16:20:41.912]                       inherits <- base::inherits
[16:20:41.912]                       invokeRestart <- base::invokeRestart
[16:20:41.912]                       is.null <- base::is.null
[16:20:41.912]                       muffled <- FALSE
[16:20:41.912]                       if (inherits(cond, "message")) {
[16:20:41.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.912]                         if (muffled) 
[16:20:41.912]                           invokeRestart("muffleMessage")
[16:20:41.912]                       }
[16:20:41.912]                       else if (inherits(cond, "warning")) {
[16:20:41.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.912]                         if (muffled) 
[16:20:41.912]                           invokeRestart("muffleWarning")
[16:20:41.912]                       }
[16:20:41.912]                       else if (inherits(cond, "condition")) {
[16:20:41.912]                         if (!is.null(pattern)) {
[16:20:41.912]                           computeRestarts <- base::computeRestarts
[16:20:41.912]                           grepl <- base::grepl
[16:20:41.912]                           restarts <- computeRestarts(cond)
[16:20:41.912]                           for (restart in restarts) {
[16:20:41.912]                             name <- restart$name
[16:20:41.912]                             if (is.null(name)) 
[16:20:41.912]                               next
[16:20:41.912]                             if (!grepl(pattern, name)) 
[16:20:41.912]                               next
[16:20:41.912]                             invokeRestart(restart)
[16:20:41.912]                             muffled <- TRUE
[16:20:41.912]                             break
[16:20:41.912]                           }
[16:20:41.912]                         }
[16:20:41.912]                       }
[16:20:41.912]                       invisible(muffled)
[16:20:41.912]                     }
[16:20:41.912]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.912]                   }
[16:20:41.912]                 }
[16:20:41.912]                 else {
[16:20:41.912]                   if (TRUE) {
[16:20:41.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.912]                     {
[16:20:41.912]                       inherits <- base::inherits
[16:20:41.912]                       invokeRestart <- base::invokeRestart
[16:20:41.912]                       is.null <- base::is.null
[16:20:41.912]                       muffled <- FALSE
[16:20:41.912]                       if (inherits(cond, "message")) {
[16:20:41.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.912]                         if (muffled) 
[16:20:41.912]                           invokeRestart("muffleMessage")
[16:20:41.912]                       }
[16:20:41.912]                       else if (inherits(cond, "warning")) {
[16:20:41.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.912]                         if (muffled) 
[16:20:41.912]                           invokeRestart("muffleWarning")
[16:20:41.912]                       }
[16:20:41.912]                       else if (inherits(cond, "condition")) {
[16:20:41.912]                         if (!is.null(pattern)) {
[16:20:41.912]                           computeRestarts <- base::computeRestarts
[16:20:41.912]                           grepl <- base::grepl
[16:20:41.912]                           restarts <- computeRestarts(cond)
[16:20:41.912]                           for (restart in restarts) {
[16:20:41.912]                             name <- restart$name
[16:20:41.912]                             if (is.null(name)) 
[16:20:41.912]                               next
[16:20:41.912]                             if (!grepl(pattern, name)) 
[16:20:41.912]                               next
[16:20:41.912]                             invokeRestart(restart)
[16:20:41.912]                             muffled <- TRUE
[16:20:41.912]                             break
[16:20:41.912]                           }
[16:20:41.912]                         }
[16:20:41.912]                       }
[16:20:41.912]                       invisible(muffled)
[16:20:41.912]                     }
[16:20:41.912]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.912]                   }
[16:20:41.912]                 }
[16:20:41.912]             }
[16:20:41.912]         }))
[16:20:41.912]     }, error = function(ex) {
[16:20:41.912]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.912]                 ...future.rng), started = ...future.startTime, 
[16:20:41.912]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.912]             version = "1.8"), class = "FutureResult")
[16:20:41.912]     }, finally = {
[16:20:41.912]         if (!identical(...future.workdir, getwd())) 
[16:20:41.912]             setwd(...future.workdir)
[16:20:41.912]         {
[16:20:41.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.912]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.912]             }
[16:20:41.912]             base::options(...future.oldOptions)
[16:20:41.912]             if (.Platform$OS.type == "windows") {
[16:20:41.912]                 old_names <- names(...future.oldEnvVars)
[16:20:41.912]                 envs <- base::Sys.getenv()
[16:20:41.912]                 names <- names(envs)
[16:20:41.912]                 common <- intersect(names, old_names)
[16:20:41.912]                 added <- setdiff(names, old_names)
[16:20:41.912]                 removed <- setdiff(old_names, names)
[16:20:41.912]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.912]                   envs[common]]
[16:20:41.912]                 NAMES <- toupper(changed)
[16:20:41.912]                 args <- list()
[16:20:41.912]                 for (kk in seq_along(NAMES)) {
[16:20:41.912]                   name <- changed[[kk]]
[16:20:41.912]                   NAME <- NAMES[[kk]]
[16:20:41.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.912]                     next
[16:20:41.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.912]                 }
[16:20:41.912]                 NAMES <- toupper(added)
[16:20:41.912]                 for (kk in seq_along(NAMES)) {
[16:20:41.912]                   name <- added[[kk]]
[16:20:41.912]                   NAME <- NAMES[[kk]]
[16:20:41.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.912]                     next
[16:20:41.912]                   args[[name]] <- ""
[16:20:41.912]                 }
[16:20:41.912]                 NAMES <- toupper(removed)
[16:20:41.912]                 for (kk in seq_along(NAMES)) {
[16:20:41.912]                   name <- removed[[kk]]
[16:20:41.912]                   NAME <- NAMES[[kk]]
[16:20:41.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.912]                     next
[16:20:41.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.912]                 }
[16:20:41.912]                 if (length(args) > 0) 
[16:20:41.912]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.912]             }
[16:20:41.912]             else {
[16:20:41.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.912]             }
[16:20:41.912]             {
[16:20:41.912]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.912]                   0L) {
[16:20:41.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.912]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.912]                   base::options(opts)
[16:20:41.912]                 }
[16:20:41.912]                 {
[16:20:41.912]                   {
[16:20:41.912]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:41.912]                     NULL
[16:20:41.912]                   }
[16:20:41.912]                   options(future.plan = NULL)
[16:20:41.912]                   if (is.na(NA_character_)) 
[16:20:41.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.912]                     .init = FALSE)
[16:20:41.912]                 }
[16:20:41.912]             }
[16:20:41.912]         }
[16:20:41.912]     })
[16:20:41.912]     if (TRUE) {
[16:20:41.912]         base::sink(type = "output", split = FALSE)
[16:20:41.912]         if (TRUE) {
[16:20:41.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.912]         }
[16:20:41.912]         else {
[16:20:41.912]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.912]         }
[16:20:41.912]         base::close(...future.stdout)
[16:20:41.912]         ...future.stdout <- NULL
[16:20:41.912]     }
[16:20:41.912]     ...future.result$conditions <- ...future.conditions
[16:20:41.912]     ...future.result$finished <- base::Sys.time()
[16:20:41.912]     ...future.result
[16:20:41.912] }
[16:20:41.915] requestCore(): workers = 2
[16:20:41.917] MulticoreFuture started
[16:20:41.918] - Launch lazy future ... done
[16:20:41.918] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a[16:20:41.918] plan(): Setting new future strategy stack:
:[16:20:41.919] List of future strategies:
[16:20:41.919] 1. sequential:
[16:20:41.919]    - args: function (..., envir = parent.frame())
[16:20:41.919]    - tweaked: FALSE
[16:20:41.919]    - call: NULL
 num 1
 $ b:[16:20:41.920] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0ae872e8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0a4cc4c0> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:20:41.922] plan(): Setting new future strategy stack:
List of 6
 $ a:[16:20:41.922] List of future strategies:
[16:20:41.922] 1. multicore:
[16:20:41.922]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:41.922]    - tweaked: FALSE
[16:20:41.922]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0ae872e8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0a4cc4c0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:20:41.927] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:41.930] resolve() on list ...
[16:20:41.930]  recursive: 0
[16:20:41.930]  length: 6
[16:20:41.930]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:41.930] signalConditionsASAP(numeric, pos=1) ...
[16:20:41.930] - nx: 6
[16:20:41.931] - relay: TRUE
[16:20:41.931] - stdout: TRUE
[16:20:41.931] - signal: TRUE
[16:20:41.931] - resignal: FALSE
[16:20:41.931] - force: TRUE
[16:20:41.931] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.931] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.932]  - until=2
[16:20:41.932]  - relaying element #2
[16:20:41.932] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.932] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.932] signalConditionsASAP(NULL, pos=1) ... done
[16:20:41.932]  length: 5 (resolved future 1)
[16:20:41.933] Future #2
[16:20:41.936] result() for MulticoreFuture ...
[16:20:41.938] result() for MulticoreFuture ...
[16:20:41.938] result() for MulticoreFuture ... done
[16:20:41.938] result() for MulticoreFuture ... done
[16:20:41.939] result() for MulticoreFuture ...
[16:20:41.939] result() for MulticoreFuture ... done
[16:20:41.940] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:41.940] - nx: 6
[16:20:41.940] - relay: TRUE
[16:20:41.940] - stdout: TRUE
[16:20:41.941] - signal: TRUE
[16:20:41.941] - resignal: FALSE
[16:20:41.941] - force: TRUE
[16:20:41.941] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.942] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:41.942]  - until=2
[16:20:41.942]  - relaying element #2
[16:20:41.942] result() for MulticoreFuture ...
[16:20:41.942] result() for MulticoreFuture ... done
[16:20:41.942] result() for MulticoreFuture ...
[16:20:41.942] result() for MulticoreFuture ... done
[16:20:41.943] result() for MulticoreFuture ...
[16:20:41.943] result() for MulticoreFuture ... done
[16:20:41.943] result() for MulticoreFuture ...
[16:20:41.943] result() for MulticoreFuture ... done
[16:20:41.943] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.943] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.944] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:41.944]  length: 4 (resolved future 2)
[16:20:41.944] Future #3
[16:20:41.944] result() for MulticoreFuture ...
[16:20:41.945] result() for MulticoreFuture ...
[16:20:41.945] result() for MulticoreFuture ... done
[16:20:41.946] result() for MulticoreFuture ... done
[16:20:41.946] result() for MulticoreFuture ...
[16:20:41.946] result() for MulticoreFuture ... done
[16:20:41.946] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:41.946] - nx: 6
[16:20:41.946] - relay: TRUE
[16:20:41.946] - stdout: TRUE
[16:20:41.946] - signal: TRUE
[16:20:41.947] - resignal: FALSE
[16:20:41.947] - force: TRUE
[16:20:41.947] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.947] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:41.947]  - until=3
[16:20:41.947]  - relaying element #3
[16:20:41.947] result() for MulticoreFuture ...
[16:20:41.947] result() for MulticoreFuture ... done
[16:20:41.948] result() for MulticoreFuture ...
[16:20:41.948] result() for MulticoreFuture ... done
[16:20:41.948] result() for MulticoreFuture ...
[16:20:41.948] result() for MulticoreFuture ... done
[16:20:41.948] result() for MulticoreFuture ...
[16:20:41.948] result() for MulticoreFuture ... done
[16:20:41.948] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.948] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.949] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:41.949]  length: 3 (resolved future 3)
[16:20:41.949] signalConditionsASAP(NULL, pos=4) ...
[16:20:41.949] - nx: 6
[16:20:41.949] - relay: TRUE
[16:20:41.949] - stdout: TRUE
[16:20:41.949] - signal: TRUE
[16:20:41.949] - resignal: FALSE
[16:20:41.949] - force: TRUE
[16:20:41.950] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.950] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.950]  - until=5
[16:20:41.950]  - relaying element #5
[16:20:41.950] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.950] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.950] signalConditionsASAP(NULL, pos=4) ... done
[16:20:41.950]  length: 2 (resolved future 4)
[16:20:41.950] signalConditionsASAP(NULL, pos=5) ...
[16:20:41.950] - nx: 6
[16:20:41.951] - relay: TRUE
[16:20:41.951] - stdout: TRUE
[16:20:41.951] - signal: TRUE
[16:20:41.951] - resignal: FALSE
[16:20:41.951] - force: TRUE
[16:20:41.951] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:41.951] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.951]  - until=6
[16:20:41.951]  - relaying element #6
[16:20:41.951] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.952] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.952] signalConditionsASAP(NULL, pos=5) ... done
[16:20:41.952]  length: 1 (resolved future 5)
[16:20:41.952] signalConditionsASAP(numeric, pos=6) ...
[16:20:41.952] - nx: 6
[16:20:41.952] - relay: TRUE
[16:20:41.952] - stdout: TRUE
[16:20:41.952] - signal: TRUE
[16:20:41.952] - resignal: FALSE
[16:20:41.952] - force: TRUE
[16:20:41.953] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:41.953] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.953]  - until=6
[16:20:41.953] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.953] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.953] signalConditionsASAP(numeric, pos=6) ... done
[16:20:41.953]  length: 0 (resolved future 6)
[16:20:41.953] Relaying remaining futures
[16:20:41.953] signalConditionsASAP(NULL, pos=0) ...
[16:20:41.953] - nx: 6
[16:20:41.954] - relay: TRUE
[16:20:41.954] - stdout: TRUE
[16:20:41.954] - signal: TRUE
[16:20:41.954] - resignal: FALSE
[16:20:41.954] - force: TRUE
[16:20:41.954] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.954] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:41.954] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:41.954] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:41.954] signalConditionsASAP(NULL, pos=0) ... done
[16:20:41.955] resolve() on list ... DONE
[16:20:41.955] result() for MulticoreFuture ...
[16:20:41.955] result() for MulticoreFuture ... done
[16:20:41.955] result() for MulticoreFuture ...
[16:20:41.955] result() for MulticoreFuture ... done
[16:20:41.955] result() for MulticoreFuture ...
[16:20:41.955] result() for MulticoreFuture ... done
[16:20:41.955] result() for MulticoreFuture ...
[16:20:41.955] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:20:41.959] getGlobalsAndPackages() ...
[16:20:41.959] Searching for globals...
[16:20:41.959] 
[16:20:41.959] Searching for globals ... DONE
[16:20:41.959] - globals: [0] <none>
[16:20:41.959] getGlobalsAndPackages() ... DONE
[16:20:41.960] run() for ‘Future’ ...
[16:20:41.960] - state: ‘created’
[16:20:41.960] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:41.964] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:41.964] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:41.964]   - Field: ‘label’
[16:20:41.964]   - Field: ‘local’
[16:20:41.965]   - Field: ‘owner’
[16:20:41.965]   - Field: ‘envir’
[16:20:41.965]   - Field: ‘workers’
[16:20:41.965]   - Field: ‘packages’
[16:20:41.965]   - Field: ‘gc’
[16:20:41.965]   - Field: ‘job’
[16:20:41.965]   - Field: ‘conditions’
[16:20:41.965]   - Field: ‘expr’
[16:20:41.966]   - Field: ‘uuid’
[16:20:41.966]   - Field: ‘seed’
[16:20:41.966]   - Field: ‘version’
[16:20:41.966]   - Field: ‘result’
[16:20:41.966]   - Field: ‘asynchronous’
[16:20:41.966]   - Field: ‘calls’
[16:20:41.966]   - Field: ‘globals’
[16:20:41.966]   - Field: ‘stdout’
[16:20:41.966]   - Field: ‘earlySignal’
[16:20:41.966]   - Field: ‘lazy’
[16:20:41.967]   - Field: ‘state’
[16:20:41.967] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:41.967] - Launch lazy future ...
[16:20:41.967] Packages needed by the future expression (n = 0): <none>
[16:20:41.967] Packages needed by future strategies (n = 0): <none>
[16:20:41.968] {
[16:20:41.968]     {
[16:20:41.968]         {
[16:20:41.968]             ...future.startTime <- base::Sys.time()
[16:20:41.968]             {
[16:20:41.968]                 {
[16:20:41.968]                   {
[16:20:41.968]                     {
[16:20:41.968]                       base::local({
[16:20:41.968]                         has_future <- base::requireNamespace("future", 
[16:20:41.968]                           quietly = TRUE)
[16:20:41.968]                         if (has_future) {
[16:20:41.968]                           ns <- base::getNamespace("future")
[16:20:41.968]                           version <- ns[[".package"]][["version"]]
[16:20:41.968]                           if (is.null(version)) 
[16:20:41.968]                             version <- utils::packageVersion("future")
[16:20:41.968]                         }
[16:20:41.968]                         else {
[16:20:41.968]                           version <- NULL
[16:20:41.968]                         }
[16:20:41.968]                         if (!has_future || version < "1.8.0") {
[16:20:41.968]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.968]                             "", base::R.version$version.string), 
[16:20:41.968]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:41.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.968]                               "release", "version")], collapse = " "), 
[16:20:41.968]                             hostname = base::Sys.info()[["nodename"]])
[16:20:41.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.968]                             info)
[16:20:41.968]                           info <- base::paste(info, collapse = "; ")
[16:20:41.968]                           if (!has_future) {
[16:20:41.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.968]                               info)
[16:20:41.968]                           }
[16:20:41.968]                           else {
[16:20:41.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.968]                               info, version)
[16:20:41.968]                           }
[16:20:41.968]                           base::stop(msg)
[16:20:41.968]                         }
[16:20:41.968]                       })
[16:20:41.968]                     }
[16:20:41.968]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:41.968]                     base::options(mc.cores = 1L)
[16:20:41.968]                   }
[16:20:41.968]                   ...future.strategy.old <- future::plan("list")
[16:20:41.968]                   options(future.plan = NULL)
[16:20:41.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.968]                 }
[16:20:41.968]                 ...future.workdir <- getwd()
[16:20:41.968]             }
[16:20:41.968]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.968]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.968]         }
[16:20:41.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.968]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.968]             base::names(...future.oldOptions))
[16:20:41.968]     }
[16:20:41.968]     if (FALSE) {
[16:20:41.968]     }
[16:20:41.968]     else {
[16:20:41.968]         if (TRUE) {
[16:20:41.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.968]                 open = "w")
[16:20:41.968]         }
[16:20:41.968]         else {
[16:20:41.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.968]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.968]         }
[16:20:41.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.968]             base::sink(type = "output", split = FALSE)
[16:20:41.968]             base::close(...future.stdout)
[16:20:41.968]         }, add = TRUE)
[16:20:41.968]     }
[16:20:41.968]     ...future.frame <- base::sys.nframe()
[16:20:41.968]     ...future.conditions <- base::list()
[16:20:41.968]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.968]     if (FALSE) {
[16:20:41.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.968]     }
[16:20:41.968]     ...future.result <- base::tryCatch({
[16:20:41.968]         base::withCallingHandlers({
[16:20:41.968]             ...future.value <- base::withVisible(base::local({
[16:20:41.968]                 withCallingHandlers({
[16:20:41.968]                   2
[16:20:41.968]                 }, immediateCondition = function(cond) {
[16:20:41.968]                   save_rds <- function (object, pathname, ...) 
[16:20:41.968]                   {
[16:20:41.968]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:41.968]                     if (file_test("-f", pathname_tmp)) {
[16:20:41.968]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.968]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:41.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.968]                         fi_tmp[["mtime"]])
[16:20:41.968]                     }
[16:20:41.968]                     tryCatch({
[16:20:41.968]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:41.968]                     }, error = function(ex) {
[16:20:41.968]                       msg <- conditionMessage(ex)
[16:20:41.968]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.968]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:41.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.968]                         fi_tmp[["mtime"]], msg)
[16:20:41.968]                       ex$message <- msg
[16:20:41.968]                       stop(ex)
[16:20:41.968]                     })
[16:20:41.968]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:41.968]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:41.968]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:41.968]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.968]                       fi <- file.info(pathname)
[16:20:41.968]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:41.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.968]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:41.968]                         fi[["size"]], fi[["mtime"]])
[16:20:41.968]                       stop(msg)
[16:20:41.968]                     }
[16:20:41.968]                     invisible(pathname)
[16:20:41.968]                   }
[16:20:41.968]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:41.968]                     rootPath = tempdir()) 
[16:20:41.968]                   {
[16:20:41.968]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:41.968]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:41.968]                       tmpdir = path, fileext = ".rds")
[16:20:41.968]                     save_rds(obj, file)
[16:20:41.968]                   }
[16:20:41.968]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:41.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.968]                   {
[16:20:41.968]                     inherits <- base::inherits
[16:20:41.968]                     invokeRestart <- base::invokeRestart
[16:20:41.968]                     is.null <- base::is.null
[16:20:41.968]                     muffled <- FALSE
[16:20:41.968]                     if (inherits(cond, "message")) {
[16:20:41.968]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:41.968]                       if (muffled) 
[16:20:41.968]                         invokeRestart("muffleMessage")
[16:20:41.968]                     }
[16:20:41.968]                     else if (inherits(cond, "warning")) {
[16:20:41.968]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:41.968]                       if (muffled) 
[16:20:41.968]                         invokeRestart("muffleWarning")
[16:20:41.968]                     }
[16:20:41.968]                     else if (inherits(cond, "condition")) {
[16:20:41.968]                       if (!is.null(pattern)) {
[16:20:41.968]                         computeRestarts <- base::computeRestarts
[16:20:41.968]                         grepl <- base::grepl
[16:20:41.968]                         restarts <- computeRestarts(cond)
[16:20:41.968]                         for (restart in restarts) {
[16:20:41.968]                           name <- restart$name
[16:20:41.968]                           if (is.null(name)) 
[16:20:41.968]                             next
[16:20:41.968]                           if (!grepl(pattern, name)) 
[16:20:41.968]                             next
[16:20:41.968]                           invokeRestart(restart)
[16:20:41.968]                           muffled <- TRUE
[16:20:41.968]                           break
[16:20:41.968]                         }
[16:20:41.968]                       }
[16:20:41.968]                     }
[16:20:41.968]                     invisible(muffled)
[16:20:41.968]                   }
[16:20:41.968]                   muffleCondition(cond)
[16:20:41.968]                 })
[16:20:41.968]             }))
[16:20:41.968]             future::FutureResult(value = ...future.value$value, 
[16:20:41.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.968]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.968]                     ...future.globalenv.names))
[16:20:41.968]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.968]         }, condition = base::local({
[16:20:41.968]             c <- base::c
[16:20:41.968]             inherits <- base::inherits
[16:20:41.968]             invokeRestart <- base::invokeRestart
[16:20:41.968]             length <- base::length
[16:20:41.968]             list <- base::list
[16:20:41.968]             seq.int <- base::seq.int
[16:20:41.968]             signalCondition <- base::signalCondition
[16:20:41.968]             sys.calls <- base::sys.calls
[16:20:41.968]             `[[` <- base::`[[`
[16:20:41.968]             `+` <- base::`+`
[16:20:41.968]             `<<-` <- base::`<<-`
[16:20:41.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.968]                   3L)]
[16:20:41.968]             }
[16:20:41.968]             function(cond) {
[16:20:41.968]                 is_error <- inherits(cond, "error")
[16:20:41.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.968]                   NULL)
[16:20:41.968]                 if (is_error) {
[16:20:41.968]                   sessionInformation <- function() {
[16:20:41.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.968]                       search = base::search(), system = base::Sys.info())
[16:20:41.968]                   }
[16:20:41.968]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.968]                     cond$call), session = sessionInformation(), 
[16:20:41.968]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.968]                   signalCondition(cond)
[16:20:41.968]                 }
[16:20:41.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.968]                 "immediateCondition"))) {
[16:20:41.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.968]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.968]                   if (TRUE && !signal) {
[16:20:41.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.968]                     {
[16:20:41.968]                       inherits <- base::inherits
[16:20:41.968]                       invokeRestart <- base::invokeRestart
[16:20:41.968]                       is.null <- base::is.null
[16:20:41.968]                       muffled <- FALSE
[16:20:41.968]                       if (inherits(cond, "message")) {
[16:20:41.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.968]                         if (muffled) 
[16:20:41.968]                           invokeRestart("muffleMessage")
[16:20:41.968]                       }
[16:20:41.968]                       else if (inherits(cond, "warning")) {
[16:20:41.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.968]                         if (muffled) 
[16:20:41.968]                           invokeRestart("muffleWarning")
[16:20:41.968]                       }
[16:20:41.968]                       else if (inherits(cond, "condition")) {
[16:20:41.968]                         if (!is.null(pattern)) {
[16:20:41.968]                           computeRestarts <- base::computeRestarts
[16:20:41.968]                           grepl <- base::grepl
[16:20:41.968]                           restarts <- computeRestarts(cond)
[16:20:41.968]                           for (restart in restarts) {
[16:20:41.968]                             name <- restart$name
[16:20:41.968]                             if (is.null(name)) 
[16:20:41.968]                               next
[16:20:41.968]                             if (!grepl(pattern, name)) 
[16:20:41.968]                               next
[16:20:41.968]                             invokeRestart(restart)
[16:20:41.968]                             muffled <- TRUE
[16:20:41.968]                             break
[16:20:41.968]                           }
[16:20:41.968]                         }
[16:20:41.968]                       }
[16:20:41.968]                       invisible(muffled)
[16:20:41.968]                     }
[16:20:41.968]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.968]                   }
[16:20:41.968]                 }
[16:20:41.968]                 else {
[16:20:41.968]                   if (TRUE) {
[16:20:41.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.968]                     {
[16:20:41.968]                       inherits <- base::inherits
[16:20:41.968]                       invokeRestart <- base::invokeRestart
[16:20:41.968]                       is.null <- base::is.null
[16:20:41.968]                       muffled <- FALSE
[16:20:41.968]                       if (inherits(cond, "message")) {
[16:20:41.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.968]                         if (muffled) 
[16:20:41.968]                           invokeRestart("muffleMessage")
[16:20:41.968]                       }
[16:20:41.968]                       else if (inherits(cond, "warning")) {
[16:20:41.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.968]                         if (muffled) 
[16:20:41.968]                           invokeRestart("muffleWarning")
[16:20:41.968]                       }
[16:20:41.968]                       else if (inherits(cond, "condition")) {
[16:20:41.968]                         if (!is.null(pattern)) {
[16:20:41.968]                           computeRestarts <- base::computeRestarts
[16:20:41.968]                           grepl <- base::grepl
[16:20:41.968]                           restarts <- computeRestarts(cond)
[16:20:41.968]                           for (restart in restarts) {
[16:20:41.968]                             name <- restart$name
[16:20:41.968]                             if (is.null(name)) 
[16:20:41.968]                               next
[16:20:41.968]                             if (!grepl(pattern, name)) 
[16:20:41.968]                               next
[16:20:41.968]                             invokeRestart(restart)
[16:20:41.968]                             muffled <- TRUE
[16:20:41.968]                             break
[16:20:41.968]                           }
[16:20:41.968]                         }
[16:20:41.968]                       }
[16:20:41.968]                       invisible(muffled)
[16:20:41.968]                     }
[16:20:41.968]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.968]                   }
[16:20:41.968]                 }
[16:20:41.968]             }
[16:20:41.968]         }))
[16:20:41.968]     }, error = function(ex) {
[16:20:41.968]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.968]                 ...future.rng), started = ...future.startTime, 
[16:20:41.968]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.968]             version = "1.8"), class = "FutureResult")
[16:20:41.968]     }, finally = {
[16:20:41.968]         if (!identical(...future.workdir, getwd())) 
[16:20:41.968]             setwd(...future.workdir)
[16:20:41.968]         {
[16:20:41.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.968]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.968]             }
[16:20:41.968]             base::options(...future.oldOptions)
[16:20:41.968]             if (.Platform$OS.type == "windows") {
[16:20:41.968]                 old_names <- names(...future.oldEnvVars)
[16:20:41.968]                 envs <- base::Sys.getenv()
[16:20:41.968]                 names <- names(envs)
[16:20:41.968]                 common <- intersect(names, old_names)
[16:20:41.968]                 added <- setdiff(names, old_names)
[16:20:41.968]                 removed <- setdiff(old_names, names)
[16:20:41.968]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.968]                   envs[common]]
[16:20:41.968]                 NAMES <- toupper(changed)
[16:20:41.968]                 args <- list()
[16:20:41.968]                 for (kk in seq_along(NAMES)) {
[16:20:41.968]                   name <- changed[[kk]]
[16:20:41.968]                   NAME <- NAMES[[kk]]
[16:20:41.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.968]                     next
[16:20:41.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.968]                 }
[16:20:41.968]                 NAMES <- toupper(added)
[16:20:41.968]                 for (kk in seq_along(NAMES)) {
[16:20:41.968]                   name <- added[[kk]]
[16:20:41.968]                   NAME <- NAMES[[kk]]
[16:20:41.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.968]                     next
[16:20:41.968]                   args[[name]] <- ""
[16:20:41.968]                 }
[16:20:41.968]                 NAMES <- toupper(removed)
[16:20:41.968]                 for (kk in seq_along(NAMES)) {
[16:20:41.968]                   name <- removed[[kk]]
[16:20:41.968]                   NAME <- NAMES[[kk]]
[16:20:41.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.968]                     next
[16:20:41.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.968]                 }
[16:20:41.968]                 if (length(args) > 0) 
[16:20:41.968]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.968]             }
[16:20:41.968]             else {
[16:20:41.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.968]             }
[16:20:41.968]             {
[16:20:41.968]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.968]                   0L) {
[16:20:41.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.968]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.968]                   base::options(opts)
[16:20:41.968]                 }
[16:20:41.968]                 {
[16:20:41.968]                   {
[16:20:41.968]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:41.968]                     NULL
[16:20:41.968]                   }
[16:20:41.968]                   options(future.plan = NULL)
[16:20:41.968]                   if (is.na(NA_character_)) 
[16:20:41.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.968]                     .init = FALSE)
[16:20:41.968]                 }
[16:20:41.968]             }
[16:20:41.968]         }
[16:20:41.968]     })
[16:20:41.968]     if (TRUE) {
[16:20:41.968]         base::sink(type = "output", split = FALSE)
[16:20:41.968]         if (TRUE) {
[16:20:41.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.968]         }
[16:20:41.968]         else {
[16:20:41.968]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.968]         }
[16:20:41.968]         base::close(...future.stdout)
[16:20:41.968]         ...future.stdout <- NULL
[16:20:41.968]     }
[16:20:41.968]     ...future.result$conditions <- ...future.conditions
[16:20:41.968]     ...future.result$finished <- base::Sys.time()
[16:20:41.968]     ...future.result
[16:20:41.968] }
[16:20:41.970] requestCore(): workers = 2
[16:20:41.972] MulticoreFuture started
[16:20:41.972] - Launch lazy future ... done
[16:20:41.972] run() for ‘MulticoreFuture’ ... done
[16:20:41.973] getGlobalsAndPackages() ...
[16:20:41.973] Searching for globals...
[16:20:41.973] plan(): Setting new future strategy stack:
[16:20:41.973] List of future strategies:
[16:20:41.973] 1. sequential:
[16:20:41.973]    - args: function (..., envir = parent.frame())
[16:20:41.973]    - tweaked: FALSE
[16:20:41.973]    - call: NULL
[16:20:41.974] plan(): nbrOfWorkers() = 1
[16:20:41.974] 
[16:20:41.978] Searching for globals ... DONE
[16:20:41.978] - globals: [0] <none>
[16:20:41.979] getGlobalsAndPackages() ... DONE
[16:20:41.979] plan(): Setting new future strategy stack:
[16:20:41.979] run() for ‘Future’ ...
[16:20:41.979] - state: ‘created’
[16:20:41.979] List of future strategies:
[16:20:41.979] 1. multicore:
[16:20:41.979]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:41.979]    - tweaked: FALSE
[16:20:41.979]    - call: plan(strategy)
[16:20:41.980] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:41.985] plan(): nbrOfWorkers() = 2
[16:20:41.986] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:41.986] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:41.986]   - Field: ‘label’
[16:20:41.987]   - Field: ‘local’
[16:20:41.987]   - Field: ‘owner’
[16:20:41.987]   - Field: ‘envir’
[16:20:41.987]   - Field: ‘workers’
[16:20:41.988]   - Field: ‘packages’
[16:20:41.988]   - Field: ‘gc’
[16:20:41.988]   - Field: ‘job’
[16:20:41.988]   - Field: ‘conditions’
[16:20:41.988]   - Field: ‘expr’
[16:20:41.988]   - Field: ‘uuid’
[16:20:41.989]   - Field: ‘seed’
[16:20:41.989]   - Field: ‘version’
[16:20:41.989]   - Field: ‘result’
[16:20:41.989]   - Field: ‘asynchronous’
[16:20:41.989]   - Field: ‘calls’
[16:20:41.990]   - Field: ‘globals’
[16:20:41.990]   - Field: ‘stdout’
[16:20:41.990]   - Field: ‘earlySignal’
[16:20:41.990]   - Field: ‘lazy’
[16:20:41.990]   - Field: ‘state’
[16:20:41.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:41.991] - Launch lazy future ...
[16:20:41.991] Packages needed by the future expression (n = 0): <none>
[16:20:41.991] Packages needed by future strategies (n = 0): <none>
[16:20:41.992] {
[16:20:41.992]     {
[16:20:41.992]         {
[16:20:41.992]             ...future.startTime <- base::Sys.time()
[16:20:41.992]             {
[16:20:41.992]                 {
[16:20:41.992]                   {
[16:20:41.992]                     {
[16:20:41.992]                       base::local({
[16:20:41.992]                         has_future <- base::requireNamespace("future", 
[16:20:41.992]                           quietly = TRUE)
[16:20:41.992]                         if (has_future) {
[16:20:41.992]                           ns <- base::getNamespace("future")
[16:20:41.992]                           version <- ns[[".package"]][["version"]]
[16:20:41.992]                           if (is.null(version)) 
[16:20:41.992]                             version <- utils::packageVersion("future")
[16:20:41.992]                         }
[16:20:41.992]                         else {
[16:20:41.992]                           version <- NULL
[16:20:41.992]                         }
[16:20:41.992]                         if (!has_future || version < "1.8.0") {
[16:20:41.992]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:41.992]                             "", base::R.version$version.string), 
[16:20:41.992]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:41.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:41.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:41.992]                               "release", "version")], collapse = " "), 
[16:20:41.992]                             hostname = base::Sys.info()[["nodename"]])
[16:20:41.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:41.992]                             info)
[16:20:41.992]                           info <- base::paste(info, collapse = "; ")
[16:20:41.992]                           if (!has_future) {
[16:20:41.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:41.992]                               info)
[16:20:41.992]                           }
[16:20:41.992]                           else {
[16:20:41.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:41.992]                               info, version)
[16:20:41.992]                           }
[16:20:41.992]                           base::stop(msg)
[16:20:41.992]                         }
[16:20:41.992]                       })
[16:20:41.992]                     }
[16:20:41.992]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:41.992]                     base::options(mc.cores = 1L)
[16:20:41.992]                   }
[16:20:41.992]                   ...future.strategy.old <- future::plan("list")
[16:20:41.992]                   options(future.plan = NULL)
[16:20:41.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:41.992]                 }
[16:20:41.992]                 ...future.workdir <- getwd()
[16:20:41.992]             }
[16:20:41.992]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:41.992]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:41.992]         }
[16:20:41.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:41.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:41.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:41.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:41.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:41.992]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:41.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:41.992]             base::names(...future.oldOptions))
[16:20:41.992]     }
[16:20:41.992]     if (FALSE) {
[16:20:41.992]     }
[16:20:41.992]     else {
[16:20:41.992]         if (TRUE) {
[16:20:41.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:41.992]                 open = "w")
[16:20:41.992]         }
[16:20:41.992]         else {
[16:20:41.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:41.992]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:41.992]         }
[16:20:41.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:41.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:41.992]             base::sink(type = "output", split = FALSE)
[16:20:41.992]             base::close(...future.stdout)
[16:20:41.992]         }, add = TRUE)
[16:20:41.992]     }
[16:20:41.992]     ...future.frame <- base::sys.nframe()
[16:20:41.992]     ...future.conditions <- base::list()
[16:20:41.992]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:41.992]     if (FALSE) {
[16:20:41.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:41.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:41.992]     }
[16:20:41.992]     ...future.result <- base::tryCatch({
[16:20:41.992]         base::withCallingHandlers({
[16:20:41.992]             ...future.value <- base::withVisible(base::local({
[16:20:41.992]                 withCallingHandlers({
[16:20:41.992]                   NULL
[16:20:41.992]                 }, immediateCondition = function(cond) {
[16:20:41.992]                   save_rds <- function (object, pathname, ...) 
[16:20:41.992]                   {
[16:20:41.992]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:41.992]                     if (file_test("-f", pathname_tmp)) {
[16:20:41.992]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.992]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:41.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.992]                         fi_tmp[["mtime"]])
[16:20:41.992]                     }
[16:20:41.992]                     tryCatch({
[16:20:41.992]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:41.992]                     }, error = function(ex) {
[16:20:41.992]                       msg <- conditionMessage(ex)
[16:20:41.992]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.992]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:41.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.992]                         fi_tmp[["mtime"]], msg)
[16:20:41.992]                       ex$message <- msg
[16:20:41.992]                       stop(ex)
[16:20:41.992]                     })
[16:20:41.992]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:41.992]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:41.992]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:41.992]                       fi_tmp <- file.info(pathname_tmp)
[16:20:41.992]                       fi <- file.info(pathname)
[16:20:41.992]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:41.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:41.992]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:41.992]                         fi[["size"]], fi[["mtime"]])
[16:20:41.992]                       stop(msg)
[16:20:41.992]                     }
[16:20:41.992]                     invisible(pathname)
[16:20:41.992]                   }
[16:20:41.992]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:41.992]                     rootPath = tempdir()) 
[16:20:41.992]                   {
[16:20:41.992]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:41.992]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:41.992]                       tmpdir = path, fileext = ".rds")
[16:20:41.992]                     save_rds(obj, file)
[16:20:41.992]                   }
[16:20:41.992]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:41.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.992]                   {
[16:20:41.992]                     inherits <- base::inherits
[16:20:41.992]                     invokeRestart <- base::invokeRestart
[16:20:41.992]                     is.null <- base::is.null
[16:20:41.992]                     muffled <- FALSE
[16:20:41.992]                     if (inherits(cond, "message")) {
[16:20:41.992]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:41.992]                       if (muffled) 
[16:20:41.992]                         invokeRestart("muffleMessage")
[16:20:41.992]                     }
[16:20:41.992]                     else if (inherits(cond, "warning")) {
[16:20:41.992]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:41.992]                       if (muffled) 
[16:20:41.992]                         invokeRestart("muffleWarning")
[16:20:41.992]                     }
[16:20:41.992]                     else if (inherits(cond, "condition")) {
[16:20:41.992]                       if (!is.null(pattern)) {
[16:20:41.992]                         computeRestarts <- base::computeRestarts
[16:20:41.992]                         grepl <- base::grepl
[16:20:41.992]                         restarts <- computeRestarts(cond)
[16:20:41.992]                         for (restart in restarts) {
[16:20:41.992]                           name <- restart$name
[16:20:41.992]                           if (is.null(name)) 
[16:20:41.992]                             next
[16:20:41.992]                           if (!grepl(pattern, name)) 
[16:20:41.992]                             next
[16:20:41.992]                           invokeRestart(restart)
[16:20:41.992]                           muffled <- TRUE
[16:20:41.992]                           break
[16:20:41.992]                         }
[16:20:41.992]                       }
[16:20:41.992]                     }
[16:20:41.992]                     invisible(muffled)
[16:20:41.992]                   }
[16:20:41.992]                   muffleCondition(cond)
[16:20:41.992]                 })
[16:20:41.992]             }))
[16:20:41.992]             future::FutureResult(value = ...future.value$value, 
[16:20:41.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.992]                   ...future.rng), globalenv = if (FALSE) 
[16:20:41.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:41.992]                     ...future.globalenv.names))
[16:20:41.992]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:41.992]         }, condition = base::local({
[16:20:41.992]             c <- base::c
[16:20:41.992]             inherits <- base::inherits
[16:20:41.992]             invokeRestart <- base::invokeRestart
[16:20:41.992]             length <- base::length
[16:20:41.992]             list <- base::list
[16:20:41.992]             seq.int <- base::seq.int
[16:20:41.992]             signalCondition <- base::signalCondition
[16:20:41.992]             sys.calls <- base::sys.calls
[16:20:41.992]             `[[` <- base::`[[`
[16:20:41.992]             `+` <- base::`+`
[16:20:41.992]             `<<-` <- base::`<<-`
[16:20:41.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:41.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:41.992]                   3L)]
[16:20:41.992]             }
[16:20:41.992]             function(cond) {
[16:20:41.992]                 is_error <- inherits(cond, "error")
[16:20:41.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:41.992]                   NULL)
[16:20:41.992]                 if (is_error) {
[16:20:41.992]                   sessionInformation <- function() {
[16:20:41.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:41.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:41.992]                       search = base::search(), system = base::Sys.info())
[16:20:41.992]                   }
[16:20:41.992]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:41.992]                     cond$call), session = sessionInformation(), 
[16:20:41.992]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:41.992]                   signalCondition(cond)
[16:20:41.992]                 }
[16:20:41.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:41.992]                 "immediateCondition"))) {
[16:20:41.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:41.992]                   ...future.conditions[[length(...future.conditions) + 
[16:20:41.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:41.992]                   if (TRUE && !signal) {
[16:20:41.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.992]                     {
[16:20:41.992]                       inherits <- base::inherits
[16:20:41.992]                       invokeRestart <- base::invokeRestart
[16:20:41.992]                       is.null <- base::is.null
[16:20:41.992]                       muffled <- FALSE
[16:20:41.992]                       if (inherits(cond, "message")) {
[16:20:41.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.992]                         if (muffled) 
[16:20:41.992]                           invokeRestart("muffleMessage")
[16:20:41.992]                       }
[16:20:41.992]                       else if (inherits(cond, "warning")) {
[16:20:41.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.992]                         if (muffled) 
[16:20:41.992]                           invokeRestart("muffleWarning")
[16:20:41.992]                       }
[16:20:41.992]                       else if (inherits(cond, "condition")) {
[16:20:41.992]                         if (!is.null(pattern)) {
[16:20:41.992]                           computeRestarts <- base::computeRestarts
[16:20:41.992]                           grepl <- base::grepl
[16:20:41.992]                           restarts <- computeRestarts(cond)
[16:20:41.992]                           for (restart in restarts) {
[16:20:41.992]                             name <- restart$name
[16:20:41.992]                             if (is.null(name)) 
[16:20:41.992]                               next
[16:20:41.992]                             if (!grepl(pattern, name)) 
[16:20:41.992]                               next
[16:20:41.992]                             invokeRestart(restart)
[16:20:41.992]                             muffled <- TRUE
[16:20:41.992]                             break
[16:20:41.992]                           }
[16:20:41.992]                         }
[16:20:41.992]                       }
[16:20:41.992]                       invisible(muffled)
[16:20:41.992]                     }
[16:20:41.992]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.992]                   }
[16:20:41.992]                 }
[16:20:41.992]                 else {
[16:20:41.992]                   if (TRUE) {
[16:20:41.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:41.992]                     {
[16:20:41.992]                       inherits <- base::inherits
[16:20:41.992]                       invokeRestart <- base::invokeRestart
[16:20:41.992]                       is.null <- base::is.null
[16:20:41.992]                       muffled <- FALSE
[16:20:41.992]                       if (inherits(cond, "message")) {
[16:20:41.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:41.992]                         if (muffled) 
[16:20:41.992]                           invokeRestart("muffleMessage")
[16:20:41.992]                       }
[16:20:41.992]                       else if (inherits(cond, "warning")) {
[16:20:41.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:41.992]                         if (muffled) 
[16:20:41.992]                           invokeRestart("muffleWarning")
[16:20:41.992]                       }
[16:20:41.992]                       else if (inherits(cond, "condition")) {
[16:20:41.992]                         if (!is.null(pattern)) {
[16:20:41.992]                           computeRestarts <- base::computeRestarts
[16:20:41.992]                           grepl <- base::grepl
[16:20:41.992]                           restarts <- computeRestarts(cond)
[16:20:41.992]                           for (restart in restarts) {
[16:20:41.992]                             name <- restart$name
[16:20:41.992]                             if (is.null(name)) 
[16:20:41.992]                               next
[16:20:41.992]                             if (!grepl(pattern, name)) 
[16:20:41.992]                               next
[16:20:41.992]                             invokeRestart(restart)
[16:20:41.992]                             muffled <- TRUE
[16:20:41.992]                             break
[16:20:41.992]                           }
[16:20:41.992]                         }
[16:20:41.992]                       }
[16:20:41.992]                       invisible(muffled)
[16:20:41.992]                     }
[16:20:41.992]                     muffleCondition(cond, pattern = "^muffle")
[16:20:41.992]                   }
[16:20:41.992]                 }
[16:20:41.992]             }
[16:20:41.992]         }))
[16:20:41.992]     }, error = function(ex) {
[16:20:41.992]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:41.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:41.992]                 ...future.rng), started = ...future.startTime, 
[16:20:41.992]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:41.992]             version = "1.8"), class = "FutureResult")
[16:20:41.992]     }, finally = {
[16:20:41.992]         if (!identical(...future.workdir, getwd())) 
[16:20:41.992]             setwd(...future.workdir)
[16:20:41.992]         {
[16:20:41.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:41.992]                 ...future.oldOptions$nwarnings <- NULL
[16:20:41.992]             }
[16:20:41.992]             base::options(...future.oldOptions)
[16:20:41.992]             if (.Platform$OS.type == "windows") {
[16:20:41.992]                 old_names <- names(...future.oldEnvVars)
[16:20:41.992]                 envs <- base::Sys.getenv()
[16:20:41.992]                 names <- names(envs)
[16:20:41.992]                 common <- intersect(names, old_names)
[16:20:41.992]                 added <- setdiff(names, old_names)
[16:20:41.992]                 removed <- setdiff(old_names, names)
[16:20:41.992]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:41.992]                   envs[common]]
[16:20:41.992]                 NAMES <- toupper(changed)
[16:20:41.992]                 args <- list()
[16:20:41.992]                 for (kk in seq_along(NAMES)) {
[16:20:41.992]                   name <- changed[[kk]]
[16:20:41.992]                   NAME <- NAMES[[kk]]
[16:20:41.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.992]                     next
[16:20:41.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.992]                 }
[16:20:41.992]                 NAMES <- toupper(added)
[16:20:41.992]                 for (kk in seq_along(NAMES)) {
[16:20:41.992]                   name <- added[[kk]]
[16:20:41.992]                   NAME <- NAMES[[kk]]
[16:20:41.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.992]                     next
[16:20:41.992]                   args[[name]] <- ""
[16:20:41.992]                 }
[16:20:41.992]                 NAMES <- toupper(removed)
[16:20:41.992]                 for (kk in seq_along(NAMES)) {
[16:20:41.992]                   name <- removed[[kk]]
[16:20:41.992]                   NAME <- NAMES[[kk]]
[16:20:41.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:41.992]                     next
[16:20:41.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:41.992]                 }
[16:20:41.992]                 if (length(args) > 0) 
[16:20:41.992]                   base::do.call(base::Sys.setenv, args = args)
[16:20:41.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:41.992]             }
[16:20:41.992]             else {
[16:20:41.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:41.992]             }
[16:20:41.992]             {
[16:20:41.992]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:41.992]                   0L) {
[16:20:41.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:41.992]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:41.992]                   base::options(opts)
[16:20:41.992]                 }
[16:20:41.992]                 {
[16:20:41.992]                   {
[16:20:41.992]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:41.992]                     NULL
[16:20:41.992]                   }
[16:20:41.992]                   options(future.plan = NULL)
[16:20:41.992]                   if (is.na(NA_character_)) 
[16:20:41.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:41.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:41.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:41.992]                     .init = FALSE)
[16:20:41.992]                 }
[16:20:41.992]             }
[16:20:41.992]         }
[16:20:41.992]     })
[16:20:41.992]     if (TRUE) {
[16:20:41.992]         base::sink(type = "output", split = FALSE)
[16:20:41.992]         if (TRUE) {
[16:20:41.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:41.992]         }
[16:20:41.992]         else {
[16:20:41.992]             ...future.result["stdout"] <- base::list(NULL)
[16:20:41.992]         }
[16:20:41.992]         base::close(...future.stdout)
[16:20:41.992]         ...future.stdout <- NULL
[16:20:41.992]     }
[16:20:41.992]     ...future.result$conditions <- ...future.conditions
[16:20:41.992]     ...future.result$finished <- base::Sys.time()
[16:20:41.992]     ...future.result
[16:20:41.992] }
[16:20:41.995] requestCore(): workers = 2
[16:20:41.997] MulticoreFuture started
[16:20:41.997] - Launch lazy future ... done
[16:20:41.998] run() for ‘MulticoreFuture’ ... done
List of 6
[16:20:41.998] plan(): Setting new future strategy stack:
 $ a:[16:20:41.999] List of future strategies:
[16:20:41.999] 1. sequential:
[16:20:41.999]    - args: function (..., envir = parent.frame())
[16:20:41.999]    - tweaked: FALSE
[16:20:41.999]    - call: NULL
 num 1
 $ b:[16:20:41.999] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c1a8c80> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed09fe1568> 
 $  : NULL
 $  : NULL
 $  :[16:20:42.002] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[16:20:42.002] List of future strategies:
[16:20:42.002] 1. multicore:
[16:20:42.002]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:42.002]    - tweaked: FALSE
[16:20:42.002]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c1a8c80> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed09fe1568> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ :[16:20:42.007] plan(): nbrOfWorkers() = 2
 chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:42.011] resolve() on list ...
[16:20:42.012]  recursive: 0
[16:20:42.012]  length: 6
[16:20:42.012]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:42.012] signalConditionsASAP(numeric, pos=1) ...
[16:20:42.012] - nx: 6
[16:20:42.012] - relay: TRUE
[16:20:42.013] - stdout: TRUE
[16:20:42.013] - signal: TRUE
[16:20:42.013] - resignal: FALSE
[16:20:42.013] - force: TRUE
[16:20:42.013] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.013] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.013]  - until=2
[16:20:42.013]  - relaying element #2
[16:20:42.014] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.014] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.014] signalConditionsASAP(NULL, pos=1) ... done
[16:20:42.014]  length: 5 (resolved future 1)
[16:20:42.014] Future #2
[16:20:42.014] result() for MulticoreFuture ...
[16:20:42.015] result() for MulticoreFuture ...
[16:20:42.015] result() for MulticoreFuture ... done
[16:20:42.016] result() for MulticoreFuture ... done
[16:20:42.016] result() for MulticoreFuture ...
[16:20:42.016] result() for MulticoreFuture ... done
[16:20:42.016] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:42.016] - nx: 6
[16:20:42.016] - relay: TRUE
[16:20:42.016] - stdout: TRUE
[16:20:42.017] - signal: TRUE
[16:20:42.017] - resignal: FALSE
[16:20:42.017] - force: TRUE
[16:20:42.017] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.017] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.017]  - until=2
[16:20:42.017]  - relaying element #2
[16:20:42.017] result() for MulticoreFuture ...
[16:20:42.018] result() for MulticoreFuture ... done
[16:20:42.018] result() for MulticoreFuture ...
[16:20:42.018] result() for MulticoreFuture ... done
[16:20:42.018] result() for MulticoreFuture ...
[16:20:42.018] result() for MulticoreFuture ... done
[16:20:42.018] result() for MulticoreFuture ...
[16:20:42.018] result() for MulticoreFuture ... done
[16:20:42.019] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.019] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.019] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:42.019]  length: 4 (resolved future 2)
[16:20:42.019] Future #3
[16:20:42.019] result() for MulticoreFuture ...
[16:20:42.020] result() for MulticoreFuture ...
[16:20:42.020] result() for MulticoreFuture ... done
[16:20:42.021] result() for MulticoreFuture ... done
[16:20:42.021] result() for MulticoreFuture ...
[16:20:42.021] result() for MulticoreFuture ... done
[16:20:42.021] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:42.021] - nx: 6
[16:20:42.022] - relay: TRUE
[16:20:42.022] - stdout: TRUE
[16:20:42.022] - signal: TRUE
[16:20:42.022] - resignal: FALSE
[16:20:42.022] - force: TRUE
[16:20:42.022] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.023] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.023]  - until=3
[16:20:42.023]  - relaying element #3
[16:20:42.023] result() for MulticoreFuture ...
[16:20:42.023] result() for MulticoreFuture ... done
[16:20:42.024] result() for MulticoreFuture ...
[16:20:42.024] result() for MulticoreFuture ... done
[16:20:42.024] result() for MulticoreFuture ...
[16:20:42.024] result() for MulticoreFuture ... done
[16:20:42.024] result() for MulticoreFuture ...
[16:20:42.024] result() for MulticoreFuture ... done
[16:20:42.024] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.024] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.024] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:42.025]  length: 3 (resolved future 3)
[16:20:42.025] signalConditionsASAP(NULL, pos=4) ...
[16:20:42.025] - nx: 6
[16:20:42.025] - relay: TRUE
[16:20:42.025] - stdout: TRUE
[16:20:42.025] - signal: TRUE
[16:20:42.025] - resignal: FALSE
[16:20:42.025] - force: TRUE
[16:20:42.025] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.026] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.026]  - until=5
[16:20:42.026]  - relaying element #5
[16:20:42.026] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:42.026] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.026] signalConditionsASAP(NULL, pos=4) ... done
[16:20:42.026]  length: 2 (resolved future 4)
[16:20:42.028] signalConditionsASAP(NULL, pos=5) ...
[16:20:42.029] - nx: 6
[16:20:42.029] - relay: TRUE
[16:20:42.029] - stdout: TRUE
[16:20:42.029] - signal: TRUE
[16:20:42.029] - resignal: FALSE
[16:20:42.029] - force: TRUE
[16:20:42.029] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:42.030] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.030]  - until=6
[16:20:42.030]  - relaying element #6
[16:20:42.030] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:42.030] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.030] signalConditionsASAP(NULL, pos=5) ... done
[16:20:42.030]  length: 1 (resolved future 5)
[16:20:42.030] signalConditionsASAP(numeric, pos=6) ...
[16:20:42.031] - nx: 6
[16:20:42.031] - relay: TRUE
[16:20:42.031] - stdout: TRUE
[16:20:42.031] - signal: TRUE
[16:20:42.031] - resignal: FALSE
[16:20:42.031] - force: TRUE
[16:20:42.031] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:42.031] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.031]  - until=6
[16:20:42.032] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.032] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.032] signalConditionsASAP(numeric, pos=6) ... done
[16:20:42.032]  length: 0 (resolved future 6)
[16:20:42.032] Relaying remaining futures
[16:20:42.032] signalConditionsASAP(NULL, pos=0) ...
[16:20:42.032] - nx: 6
[16:20:42.032] - relay: TRUE
[16:20:42.033] - stdout: TRUE
[16:20:42.033] - signal: TRUE
[16:20:42.033] - resignal: FALSE
[16:20:42.033] - force: TRUE
[16:20:42.033] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.033] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:42.033] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.033] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.034] signalConditionsASAP(NULL, pos=0) ... done
[16:20:42.034] resolve() on list ... DONE
[16:20:42.034] result() for MulticoreFuture ...
[16:20:42.034] result() for MulticoreFuture ... done
[16:20:42.034] result() for MulticoreFuture ...
[16:20:42.034] result() for MulticoreFuture ... done
[16:20:42.034] result() for MulticoreFuture ...
[16:20:42.034] result() for MulticoreFuture ... done
[16:20:42.035] result() for MulticoreFuture ...
[16:20:42.035] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:20:42.038] getGlobalsAndPackages() ...
[16:20:42.038] Searching for globals...
[16:20:42.039] 
[16:20:42.039] Searching for globals ... DONE
[16:20:42.039] - globals: [0] <none>
[16:20:42.039] getGlobalsAndPackages() ... DONE
[16:20:42.039] run() for ‘Future’ ...
[16:20:42.039] - state: ‘created’
[16:20:42.039] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:42.044] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:42.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:42.044]   - Field: ‘label’
[16:20:42.044]   - Field: ‘local’
[16:20:42.044]   - Field: ‘owner’
[16:20:42.044]   - Field: ‘envir’
[16:20:42.044]   - Field: ‘workers’
[16:20:42.044]   - Field: ‘packages’
[16:20:42.045]   - Field: ‘gc’
[16:20:42.045]   - Field: ‘job’
[16:20:42.045]   - Field: ‘conditions’
[16:20:42.045]   - Field: ‘expr’
[16:20:42.045]   - Field: ‘uuid’
[16:20:42.045]   - Field: ‘seed’
[16:20:42.045]   - Field: ‘version’
[16:20:42.045]   - Field: ‘result’
[16:20:42.045]   - Field: ‘asynchronous’
[16:20:42.045]   - Field: ‘calls’
[16:20:42.045]   - Field: ‘globals’
[16:20:42.046]   - Field: ‘stdout’
[16:20:42.046]   - Field: ‘earlySignal’
[16:20:42.046]   - Field: ‘lazy’
[16:20:42.046]   - Field: ‘state’
[16:20:42.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:42.046] - Launch lazy future ...
[16:20:42.046] Packages needed by the future expression (n = 0): <none>
[16:20:42.046] Packages needed by future strategies (n = 0): <none>
[16:20:42.047] {
[16:20:42.047]     {
[16:20:42.047]         {
[16:20:42.047]             ...future.startTime <- base::Sys.time()
[16:20:42.047]             {
[16:20:42.047]                 {
[16:20:42.047]                   {
[16:20:42.047]                     {
[16:20:42.047]                       base::local({
[16:20:42.047]                         has_future <- base::requireNamespace("future", 
[16:20:42.047]                           quietly = TRUE)
[16:20:42.047]                         if (has_future) {
[16:20:42.047]                           ns <- base::getNamespace("future")
[16:20:42.047]                           version <- ns[[".package"]][["version"]]
[16:20:42.047]                           if (is.null(version)) 
[16:20:42.047]                             version <- utils::packageVersion("future")
[16:20:42.047]                         }
[16:20:42.047]                         else {
[16:20:42.047]                           version <- NULL
[16:20:42.047]                         }
[16:20:42.047]                         if (!has_future || version < "1.8.0") {
[16:20:42.047]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:42.047]                             "", base::R.version$version.string), 
[16:20:42.047]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:42.047]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:42.047]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:42.047]                               "release", "version")], collapse = " "), 
[16:20:42.047]                             hostname = base::Sys.info()[["nodename"]])
[16:20:42.047]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:42.047]                             info)
[16:20:42.047]                           info <- base::paste(info, collapse = "; ")
[16:20:42.047]                           if (!has_future) {
[16:20:42.047]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:42.047]                               info)
[16:20:42.047]                           }
[16:20:42.047]                           else {
[16:20:42.047]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:42.047]                               info, version)
[16:20:42.047]                           }
[16:20:42.047]                           base::stop(msg)
[16:20:42.047]                         }
[16:20:42.047]                       })
[16:20:42.047]                     }
[16:20:42.047]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:42.047]                     base::options(mc.cores = 1L)
[16:20:42.047]                   }
[16:20:42.047]                   ...future.strategy.old <- future::plan("list")
[16:20:42.047]                   options(future.plan = NULL)
[16:20:42.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.047]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:42.047]                 }
[16:20:42.047]                 ...future.workdir <- getwd()
[16:20:42.047]             }
[16:20:42.047]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:42.047]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:42.047]         }
[16:20:42.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:42.047]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:42.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:42.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:42.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:42.047]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:42.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:42.047]             base::names(...future.oldOptions))
[16:20:42.047]     }
[16:20:42.047]     if (FALSE) {
[16:20:42.047]     }
[16:20:42.047]     else {
[16:20:42.047]         if (TRUE) {
[16:20:42.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:42.047]                 open = "w")
[16:20:42.047]         }
[16:20:42.047]         else {
[16:20:42.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:42.047]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:42.047]         }
[16:20:42.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:42.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:42.047]             base::sink(type = "output", split = FALSE)
[16:20:42.047]             base::close(...future.stdout)
[16:20:42.047]         }, add = TRUE)
[16:20:42.047]     }
[16:20:42.047]     ...future.frame <- base::sys.nframe()
[16:20:42.047]     ...future.conditions <- base::list()
[16:20:42.047]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:42.047]     if (FALSE) {
[16:20:42.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:42.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:42.047]     }
[16:20:42.047]     ...future.result <- base::tryCatch({
[16:20:42.047]         base::withCallingHandlers({
[16:20:42.047]             ...future.value <- base::withVisible(base::local({
[16:20:42.047]                 withCallingHandlers({
[16:20:42.047]                   2
[16:20:42.047]                 }, immediateCondition = function(cond) {
[16:20:42.047]                   save_rds <- function (object, pathname, ...) 
[16:20:42.047]                   {
[16:20:42.047]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:42.047]                     if (file_test("-f", pathname_tmp)) {
[16:20:42.047]                       fi_tmp <- file.info(pathname_tmp)
[16:20:42.047]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:42.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:42.047]                         fi_tmp[["mtime"]])
[16:20:42.047]                     }
[16:20:42.047]                     tryCatch({
[16:20:42.047]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:42.047]                     }, error = function(ex) {
[16:20:42.047]                       msg <- conditionMessage(ex)
[16:20:42.047]                       fi_tmp <- file.info(pathname_tmp)
[16:20:42.047]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:42.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:42.047]                         fi_tmp[["mtime"]], msg)
[16:20:42.047]                       ex$message <- msg
[16:20:42.047]                       stop(ex)
[16:20:42.047]                     })
[16:20:42.047]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:42.047]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:42.047]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:42.047]                       fi_tmp <- file.info(pathname_tmp)
[16:20:42.047]                       fi <- file.info(pathname)
[16:20:42.047]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:42.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:42.047]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:42.047]                         fi[["size"]], fi[["mtime"]])
[16:20:42.047]                       stop(msg)
[16:20:42.047]                     }
[16:20:42.047]                     invisible(pathname)
[16:20:42.047]                   }
[16:20:42.047]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:42.047]                     rootPath = tempdir()) 
[16:20:42.047]                   {
[16:20:42.047]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:42.047]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:42.047]                       tmpdir = path, fileext = ".rds")
[16:20:42.047]                     save_rds(obj, file)
[16:20:42.047]                   }
[16:20:42.047]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:42.047]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.047]                   {
[16:20:42.047]                     inherits <- base::inherits
[16:20:42.047]                     invokeRestart <- base::invokeRestart
[16:20:42.047]                     is.null <- base::is.null
[16:20:42.047]                     muffled <- FALSE
[16:20:42.047]                     if (inherits(cond, "message")) {
[16:20:42.047]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:42.047]                       if (muffled) 
[16:20:42.047]                         invokeRestart("muffleMessage")
[16:20:42.047]                     }
[16:20:42.047]                     else if (inherits(cond, "warning")) {
[16:20:42.047]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:42.047]                       if (muffled) 
[16:20:42.047]                         invokeRestart("muffleWarning")
[16:20:42.047]                     }
[16:20:42.047]                     else if (inherits(cond, "condition")) {
[16:20:42.047]                       if (!is.null(pattern)) {
[16:20:42.047]                         computeRestarts <- base::computeRestarts
[16:20:42.047]                         grepl <- base::grepl
[16:20:42.047]                         restarts <- computeRestarts(cond)
[16:20:42.047]                         for (restart in restarts) {
[16:20:42.047]                           name <- restart$name
[16:20:42.047]                           if (is.null(name)) 
[16:20:42.047]                             next
[16:20:42.047]                           if (!grepl(pattern, name)) 
[16:20:42.047]                             next
[16:20:42.047]                           invokeRestart(restart)
[16:20:42.047]                           muffled <- TRUE
[16:20:42.047]                           break
[16:20:42.047]                         }
[16:20:42.047]                       }
[16:20:42.047]                     }
[16:20:42.047]                     invisible(muffled)
[16:20:42.047]                   }
[16:20:42.047]                   muffleCondition(cond)
[16:20:42.047]                 })
[16:20:42.047]             }))
[16:20:42.047]             future::FutureResult(value = ...future.value$value, 
[16:20:42.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.047]                   ...future.rng), globalenv = if (FALSE) 
[16:20:42.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:42.047]                     ...future.globalenv.names))
[16:20:42.047]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:42.047]         }, condition = base::local({
[16:20:42.047]             c <- base::c
[16:20:42.047]             inherits <- base::inherits
[16:20:42.047]             invokeRestart <- base::invokeRestart
[16:20:42.047]             length <- base::length
[16:20:42.047]             list <- base::list
[16:20:42.047]             seq.int <- base::seq.int
[16:20:42.047]             signalCondition <- base::signalCondition
[16:20:42.047]             sys.calls <- base::sys.calls
[16:20:42.047]             `[[` <- base::`[[`
[16:20:42.047]             `+` <- base::`+`
[16:20:42.047]             `<<-` <- base::`<<-`
[16:20:42.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:42.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:42.047]                   3L)]
[16:20:42.047]             }
[16:20:42.047]             function(cond) {
[16:20:42.047]                 is_error <- inherits(cond, "error")
[16:20:42.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:42.047]                   NULL)
[16:20:42.047]                 if (is_error) {
[16:20:42.047]                   sessionInformation <- function() {
[16:20:42.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:42.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:42.047]                       search = base::search(), system = base::Sys.info())
[16:20:42.047]                   }
[16:20:42.047]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:42.047]                     cond$call), session = sessionInformation(), 
[16:20:42.047]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:42.047]                   signalCondition(cond)
[16:20:42.047]                 }
[16:20:42.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:42.047]                 "immediateCondition"))) {
[16:20:42.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:42.047]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:42.047]                   if (TRUE && !signal) {
[16:20:42.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.047]                     {
[16:20:42.047]                       inherits <- base::inherits
[16:20:42.047]                       invokeRestart <- base::invokeRestart
[16:20:42.047]                       is.null <- base::is.null
[16:20:42.047]                       muffled <- FALSE
[16:20:42.047]                       if (inherits(cond, "message")) {
[16:20:42.047]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.047]                         if (muffled) 
[16:20:42.047]                           invokeRestart("muffleMessage")
[16:20:42.047]                       }
[16:20:42.047]                       else if (inherits(cond, "warning")) {
[16:20:42.047]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.047]                         if (muffled) 
[16:20:42.047]                           invokeRestart("muffleWarning")
[16:20:42.047]                       }
[16:20:42.047]                       else if (inherits(cond, "condition")) {
[16:20:42.047]                         if (!is.null(pattern)) {
[16:20:42.047]                           computeRestarts <- base::computeRestarts
[16:20:42.047]                           grepl <- base::grepl
[16:20:42.047]                           restarts <- computeRestarts(cond)
[16:20:42.047]                           for (restart in restarts) {
[16:20:42.047]                             name <- restart$name
[16:20:42.047]                             if (is.null(name)) 
[16:20:42.047]                               next
[16:20:42.047]                             if (!grepl(pattern, name)) 
[16:20:42.047]                               next
[16:20:42.047]                             invokeRestart(restart)
[16:20:42.047]                             muffled <- TRUE
[16:20:42.047]                             break
[16:20:42.047]                           }
[16:20:42.047]                         }
[16:20:42.047]                       }
[16:20:42.047]                       invisible(muffled)
[16:20:42.047]                     }
[16:20:42.047]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.047]                   }
[16:20:42.047]                 }
[16:20:42.047]                 else {
[16:20:42.047]                   if (TRUE) {
[16:20:42.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.047]                     {
[16:20:42.047]                       inherits <- base::inherits
[16:20:42.047]                       invokeRestart <- base::invokeRestart
[16:20:42.047]                       is.null <- base::is.null
[16:20:42.047]                       muffled <- FALSE
[16:20:42.047]                       if (inherits(cond, "message")) {
[16:20:42.047]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.047]                         if (muffled) 
[16:20:42.047]                           invokeRestart("muffleMessage")
[16:20:42.047]                       }
[16:20:42.047]                       else if (inherits(cond, "warning")) {
[16:20:42.047]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.047]                         if (muffled) 
[16:20:42.047]                           invokeRestart("muffleWarning")
[16:20:42.047]                       }
[16:20:42.047]                       else if (inherits(cond, "condition")) {
[16:20:42.047]                         if (!is.null(pattern)) {
[16:20:42.047]                           computeRestarts <- base::computeRestarts
[16:20:42.047]                           grepl <- base::grepl
[16:20:42.047]                           restarts <- computeRestarts(cond)
[16:20:42.047]                           for (restart in restarts) {
[16:20:42.047]                             name <- restart$name
[16:20:42.047]                             if (is.null(name)) 
[16:20:42.047]                               next
[16:20:42.047]                             if (!grepl(pattern, name)) 
[16:20:42.047]                               next
[16:20:42.047]                             invokeRestart(restart)
[16:20:42.047]                             muffled <- TRUE
[16:20:42.047]                             break
[16:20:42.047]                           }
[16:20:42.047]                         }
[16:20:42.047]                       }
[16:20:42.047]                       invisible(muffled)
[16:20:42.047]                     }
[16:20:42.047]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.047]                   }
[16:20:42.047]                 }
[16:20:42.047]             }
[16:20:42.047]         }))
[16:20:42.047]     }, error = function(ex) {
[16:20:42.047]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:42.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.047]                 ...future.rng), started = ...future.startTime, 
[16:20:42.047]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:42.047]             version = "1.8"), class = "FutureResult")
[16:20:42.047]     }, finally = {
[16:20:42.047]         if (!identical(...future.workdir, getwd())) 
[16:20:42.047]             setwd(...future.workdir)
[16:20:42.047]         {
[16:20:42.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:42.047]                 ...future.oldOptions$nwarnings <- NULL
[16:20:42.047]             }
[16:20:42.047]             base::options(...future.oldOptions)
[16:20:42.047]             if (.Platform$OS.type == "windows") {
[16:20:42.047]                 old_names <- names(...future.oldEnvVars)
[16:20:42.047]                 envs <- base::Sys.getenv()
[16:20:42.047]                 names <- names(envs)
[16:20:42.047]                 common <- intersect(names, old_names)
[16:20:42.047]                 added <- setdiff(names, old_names)
[16:20:42.047]                 removed <- setdiff(old_names, names)
[16:20:42.047]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:42.047]                   envs[common]]
[16:20:42.047]                 NAMES <- toupper(changed)
[16:20:42.047]                 args <- list()
[16:20:42.047]                 for (kk in seq_along(NAMES)) {
[16:20:42.047]                   name <- changed[[kk]]
[16:20:42.047]                   NAME <- NAMES[[kk]]
[16:20:42.047]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.047]                     next
[16:20:42.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.047]                 }
[16:20:42.047]                 NAMES <- toupper(added)
[16:20:42.047]                 for (kk in seq_along(NAMES)) {
[16:20:42.047]                   name <- added[[kk]]
[16:20:42.047]                   NAME <- NAMES[[kk]]
[16:20:42.047]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.047]                     next
[16:20:42.047]                   args[[name]] <- ""
[16:20:42.047]                 }
[16:20:42.047]                 NAMES <- toupper(removed)
[16:20:42.047]                 for (kk in seq_along(NAMES)) {
[16:20:42.047]                   name <- removed[[kk]]
[16:20:42.047]                   NAME <- NAMES[[kk]]
[16:20:42.047]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.047]                     next
[16:20:42.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.047]                 }
[16:20:42.047]                 if (length(args) > 0) 
[16:20:42.047]                   base::do.call(base::Sys.setenv, args = args)
[16:20:42.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:42.047]             }
[16:20:42.047]             else {
[16:20:42.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:42.047]             }
[16:20:42.047]             {
[16:20:42.047]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:42.047]                   0L) {
[16:20:42.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:42.047]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:42.047]                   base::options(opts)
[16:20:42.047]                 }
[16:20:42.047]                 {
[16:20:42.047]                   {
[16:20:42.047]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:42.047]                     NULL
[16:20:42.047]                   }
[16:20:42.047]                   options(future.plan = NULL)
[16:20:42.047]                   if (is.na(NA_character_)) 
[16:20:42.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:42.047]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:42.047]                     .init = FALSE)
[16:20:42.047]                 }
[16:20:42.047]             }
[16:20:42.047]         }
[16:20:42.047]     })
[16:20:42.047]     if (TRUE) {
[16:20:42.047]         base::sink(type = "output", split = FALSE)
[16:20:42.047]         if (TRUE) {
[16:20:42.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:42.047]         }
[16:20:42.047]         else {
[16:20:42.047]             ...future.result["stdout"] <- base::list(NULL)
[16:20:42.047]         }
[16:20:42.047]         base::close(...future.stdout)
[16:20:42.047]         ...future.stdout <- NULL
[16:20:42.047]     }
[16:20:42.047]     ...future.result$conditions <- ...future.conditions
[16:20:42.047]     ...future.result$finished <- base::Sys.time()
[16:20:42.047]     ...future.result
[16:20:42.047] }
[16:20:42.049] requestCore(): workers = 2
[16:20:42.051] MulticoreFuture started
[16:20:42.051] - Launch lazy future ... done
[16:20:42.052] run() for ‘MulticoreFuture’ ... done
[16:20:42.052] getGlobalsAndPackages() ...
[16:20:42.052] Searching for globals...
[16:20:42.052] plan(): Setting new future strategy stack:
[16:20:42.053] 
[16:20:42.053] List of future strategies:
[16:20:42.053] 1. sequential:
[16:20:42.053]    - args: function (..., envir = parent.frame())
[16:20:42.053]    - tweaked: FALSE
[16:20:42.053]    - call: NULL
[16:20:42.053] Searching for globals ... DONE
[16:20:42.053] - globals: [0] <none>
[16:20:42.053] plan(): nbrOfWorkers() = 1
[16:20:42.054] getGlobalsAndPackages() ... DONE
[16:20:42.054] run() for ‘Future’ ...
[16:20:42.054] - state: ‘created’
[16:20:42.055] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:42.055] plan(): Setting new future strategy stack:
[16:20:42.056] List of future strategies:
[16:20:42.056] 1. multicore:
[16:20:42.056]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:42.056]    - tweaked: FALSE
[16:20:42.056]    - call: plan(strategy)
[16:20:42.060] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:42.060] plan(): nbrOfWorkers() = 2
[16:20:42.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:42.060]   - Field: ‘label’
[16:20:42.060]   - Field: ‘local’
[16:20:42.061]   - Field: ‘owner’
[16:20:42.061]   - Field: ‘envir’
[16:20:42.061]   - Field: ‘workers’
[16:20:42.061]   - Field: ‘packages’
[16:20:42.061]   - Field: ‘gc’
[16:20:42.061]   - Field: ‘job’
[16:20:42.062]   - Field: ‘conditions’
[16:20:42.062]   - Field: ‘expr’
[16:20:42.062]   - Field: ‘uuid’
[16:20:42.062]   - Field: ‘seed’
[16:20:42.062]   - Field: ‘version’
[16:20:42.062]   - Field: ‘result’
[16:20:42.063]   - Field: ‘asynchronous’
[16:20:42.063]   - Field: ‘calls’
[16:20:42.063]   - Field: ‘globals’
[16:20:42.063]   - Field: ‘stdout’
[16:20:42.063]   - Field: ‘earlySignal’
[16:20:42.063]   - Field: ‘lazy’
[16:20:42.063]   - Field: ‘state’
[16:20:42.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:42.064] - Launch lazy future ...
[16:20:42.064] Packages needed by the future expression (n = 0): <none>
[16:20:42.064] Packages needed by future strategies (n = 0): <none>
[16:20:42.065] {
[16:20:42.065]     {
[16:20:42.065]         {
[16:20:42.065]             ...future.startTime <- base::Sys.time()
[16:20:42.065]             {
[16:20:42.065]                 {
[16:20:42.065]                   {
[16:20:42.065]                     {
[16:20:42.065]                       base::local({
[16:20:42.065]                         has_future <- base::requireNamespace("future", 
[16:20:42.065]                           quietly = TRUE)
[16:20:42.065]                         if (has_future) {
[16:20:42.065]                           ns <- base::getNamespace("future")
[16:20:42.065]                           version <- ns[[".package"]][["version"]]
[16:20:42.065]                           if (is.null(version)) 
[16:20:42.065]                             version <- utils::packageVersion("future")
[16:20:42.065]                         }
[16:20:42.065]                         else {
[16:20:42.065]                           version <- NULL
[16:20:42.065]                         }
[16:20:42.065]                         if (!has_future || version < "1.8.0") {
[16:20:42.065]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:42.065]                             "", base::R.version$version.string), 
[16:20:42.065]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:42.065]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:42.065]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:42.065]                               "release", "version")], collapse = " "), 
[16:20:42.065]                             hostname = base::Sys.info()[["nodename"]])
[16:20:42.065]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:42.065]                             info)
[16:20:42.065]                           info <- base::paste(info, collapse = "; ")
[16:20:42.065]                           if (!has_future) {
[16:20:42.065]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:42.065]                               info)
[16:20:42.065]                           }
[16:20:42.065]                           else {
[16:20:42.065]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:42.065]                               info, version)
[16:20:42.065]                           }
[16:20:42.065]                           base::stop(msg)
[16:20:42.065]                         }
[16:20:42.065]                       })
[16:20:42.065]                     }
[16:20:42.065]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:42.065]                     base::options(mc.cores = 1L)
[16:20:42.065]                   }
[16:20:42.065]                   ...future.strategy.old <- future::plan("list")
[16:20:42.065]                   options(future.plan = NULL)
[16:20:42.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:42.065]                 }
[16:20:42.065]                 ...future.workdir <- getwd()
[16:20:42.065]             }
[16:20:42.065]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:42.065]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:42.065]         }
[16:20:42.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:42.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:42.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:42.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:42.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:42.065]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:42.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:42.065]             base::names(...future.oldOptions))
[16:20:42.065]     }
[16:20:42.065]     if (FALSE) {
[16:20:42.065]     }
[16:20:42.065]     else {
[16:20:42.065]         if (TRUE) {
[16:20:42.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:42.065]                 open = "w")
[16:20:42.065]         }
[16:20:42.065]         else {
[16:20:42.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:42.065]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:42.065]         }
[16:20:42.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:42.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:42.065]             base::sink(type = "output", split = FALSE)
[16:20:42.065]             base::close(...future.stdout)
[16:20:42.065]         }, add = TRUE)
[16:20:42.065]     }
[16:20:42.065]     ...future.frame <- base::sys.nframe()
[16:20:42.065]     ...future.conditions <- base::list()
[16:20:42.065]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:42.065]     if (FALSE) {
[16:20:42.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:42.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:42.065]     }
[16:20:42.065]     ...future.result <- base::tryCatch({
[16:20:42.065]         base::withCallingHandlers({
[16:20:42.065]             ...future.value <- base::withVisible(base::local({
[16:20:42.065]                 withCallingHandlers({
[16:20:42.065]                   NULL
[16:20:42.065]                 }, immediateCondition = function(cond) {
[16:20:42.065]                   save_rds <- function (object, pathname, ...) 
[16:20:42.065]                   {
[16:20:42.065]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:42.065]                     if (file_test("-f", pathname_tmp)) {
[16:20:42.065]                       fi_tmp <- file.info(pathname_tmp)
[16:20:42.065]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:42.065]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:42.065]                         fi_tmp[["mtime"]])
[16:20:42.065]                     }
[16:20:42.065]                     tryCatch({
[16:20:42.065]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:42.065]                     }, error = function(ex) {
[16:20:42.065]                       msg <- conditionMessage(ex)
[16:20:42.065]                       fi_tmp <- file.info(pathname_tmp)
[16:20:42.065]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:42.065]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:42.065]                         fi_tmp[["mtime"]], msg)
[16:20:42.065]                       ex$message <- msg
[16:20:42.065]                       stop(ex)
[16:20:42.065]                     })
[16:20:42.065]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:42.065]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:42.065]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:42.065]                       fi_tmp <- file.info(pathname_tmp)
[16:20:42.065]                       fi <- file.info(pathname)
[16:20:42.065]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:42.065]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:42.065]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:42.065]                         fi[["size"]], fi[["mtime"]])
[16:20:42.065]                       stop(msg)
[16:20:42.065]                     }
[16:20:42.065]                     invisible(pathname)
[16:20:42.065]                   }
[16:20:42.065]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:42.065]                     rootPath = tempdir()) 
[16:20:42.065]                   {
[16:20:42.065]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:42.065]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:42.065]                       tmpdir = path, fileext = ".rds")
[16:20:42.065]                     save_rds(obj, file)
[16:20:42.065]                   }
[16:20:42.065]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:42.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.065]                   {
[16:20:42.065]                     inherits <- base::inherits
[16:20:42.065]                     invokeRestart <- base::invokeRestart
[16:20:42.065]                     is.null <- base::is.null
[16:20:42.065]                     muffled <- FALSE
[16:20:42.065]                     if (inherits(cond, "message")) {
[16:20:42.065]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:42.065]                       if (muffled) 
[16:20:42.065]                         invokeRestart("muffleMessage")
[16:20:42.065]                     }
[16:20:42.065]                     else if (inherits(cond, "warning")) {
[16:20:42.065]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:42.065]                       if (muffled) 
[16:20:42.065]                         invokeRestart("muffleWarning")
[16:20:42.065]                     }
[16:20:42.065]                     else if (inherits(cond, "condition")) {
[16:20:42.065]                       if (!is.null(pattern)) {
[16:20:42.065]                         computeRestarts <- base::computeRestarts
[16:20:42.065]                         grepl <- base::grepl
[16:20:42.065]                         restarts <- computeRestarts(cond)
[16:20:42.065]                         for (restart in restarts) {
[16:20:42.065]                           name <- restart$name
[16:20:42.065]                           if (is.null(name)) 
[16:20:42.065]                             next
[16:20:42.065]                           if (!grepl(pattern, name)) 
[16:20:42.065]                             next
[16:20:42.065]                           invokeRestart(restart)
[16:20:42.065]                           muffled <- TRUE
[16:20:42.065]                           break
[16:20:42.065]                         }
[16:20:42.065]                       }
[16:20:42.065]                     }
[16:20:42.065]                     invisible(muffled)
[16:20:42.065]                   }
[16:20:42.065]                   muffleCondition(cond)
[16:20:42.065]                 })
[16:20:42.065]             }))
[16:20:42.065]             future::FutureResult(value = ...future.value$value, 
[16:20:42.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.065]                   ...future.rng), globalenv = if (FALSE) 
[16:20:42.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:42.065]                     ...future.globalenv.names))
[16:20:42.065]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:42.065]         }, condition = base::local({
[16:20:42.065]             c <- base::c
[16:20:42.065]             inherits <- base::inherits
[16:20:42.065]             invokeRestart <- base::invokeRestart
[16:20:42.065]             length <- base::length
[16:20:42.065]             list <- base::list
[16:20:42.065]             seq.int <- base::seq.int
[16:20:42.065]             signalCondition <- base::signalCondition
[16:20:42.065]             sys.calls <- base::sys.calls
[16:20:42.065]             `[[` <- base::`[[`
[16:20:42.065]             `+` <- base::`+`
[16:20:42.065]             `<<-` <- base::`<<-`
[16:20:42.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:42.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:42.065]                   3L)]
[16:20:42.065]             }
[16:20:42.065]             function(cond) {
[16:20:42.065]                 is_error <- inherits(cond, "error")
[16:20:42.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:42.065]                   NULL)
[16:20:42.065]                 if (is_error) {
[16:20:42.065]                   sessionInformation <- function() {
[16:20:42.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:42.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:42.065]                       search = base::search(), system = base::Sys.info())
[16:20:42.065]                   }
[16:20:42.065]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:42.065]                     cond$call), session = sessionInformation(), 
[16:20:42.065]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:42.065]                   signalCondition(cond)
[16:20:42.065]                 }
[16:20:42.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:42.065]                 "immediateCondition"))) {
[16:20:42.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:42.065]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:42.065]                   if (TRUE && !signal) {
[16:20:42.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.065]                     {
[16:20:42.065]                       inherits <- base::inherits
[16:20:42.065]                       invokeRestart <- base::invokeRestart
[16:20:42.065]                       is.null <- base::is.null
[16:20:42.065]                       muffled <- FALSE
[16:20:42.065]                       if (inherits(cond, "message")) {
[16:20:42.065]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.065]                         if (muffled) 
[16:20:42.065]                           invokeRestart("muffleMessage")
[16:20:42.065]                       }
[16:20:42.065]                       else if (inherits(cond, "warning")) {
[16:20:42.065]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.065]                         if (muffled) 
[16:20:42.065]                           invokeRestart("muffleWarning")
[16:20:42.065]                       }
[16:20:42.065]                       else if (inherits(cond, "condition")) {
[16:20:42.065]                         if (!is.null(pattern)) {
[16:20:42.065]                           computeRestarts <- base::computeRestarts
[16:20:42.065]                           grepl <- base::grepl
[16:20:42.065]                           restarts <- computeRestarts(cond)
[16:20:42.065]                           for (restart in restarts) {
[16:20:42.065]                             name <- restart$name
[16:20:42.065]                             if (is.null(name)) 
[16:20:42.065]                               next
[16:20:42.065]                             if (!grepl(pattern, name)) 
[16:20:42.065]                               next
[16:20:42.065]                             invokeRestart(restart)
[16:20:42.065]                             muffled <- TRUE
[16:20:42.065]                             break
[16:20:42.065]                           }
[16:20:42.065]                         }
[16:20:42.065]                       }
[16:20:42.065]                       invisible(muffled)
[16:20:42.065]                     }
[16:20:42.065]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.065]                   }
[16:20:42.065]                 }
[16:20:42.065]                 else {
[16:20:42.065]                   if (TRUE) {
[16:20:42.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.065]                     {
[16:20:42.065]                       inherits <- base::inherits
[16:20:42.065]                       invokeRestart <- base::invokeRestart
[16:20:42.065]                       is.null <- base::is.null
[16:20:42.065]                       muffled <- FALSE
[16:20:42.065]                       if (inherits(cond, "message")) {
[16:20:42.065]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.065]                         if (muffled) 
[16:20:42.065]                           invokeRestart("muffleMessage")
[16:20:42.065]                       }
[16:20:42.065]                       else if (inherits(cond, "warning")) {
[16:20:42.065]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.065]                         if (muffled) 
[16:20:42.065]                           invokeRestart("muffleWarning")
[16:20:42.065]                       }
[16:20:42.065]                       else if (inherits(cond, "condition")) {
[16:20:42.065]                         if (!is.null(pattern)) {
[16:20:42.065]                           computeRestarts <- base::computeRestarts
[16:20:42.065]                           grepl <- base::grepl
[16:20:42.065]                           restarts <- computeRestarts(cond)
[16:20:42.065]                           for (restart in restarts) {
[16:20:42.065]                             name <- restart$name
[16:20:42.065]                             if (is.null(name)) 
[16:20:42.065]                               next
[16:20:42.065]                             if (!grepl(pattern, name)) 
[16:20:42.065]                               next
[16:20:42.065]                             invokeRestart(restart)
[16:20:42.065]                             muffled <- TRUE
[16:20:42.065]                             break
[16:20:42.065]                           }
[16:20:42.065]                         }
[16:20:42.065]                       }
[16:20:42.065]                       invisible(muffled)
[16:20:42.065]                     }
[16:20:42.065]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.065]                   }
[16:20:42.065]                 }
[16:20:42.065]             }
[16:20:42.065]         }))
[16:20:42.065]     }, error = function(ex) {
[16:20:42.065]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:42.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.065]                 ...future.rng), started = ...future.startTime, 
[16:20:42.065]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:42.065]             version = "1.8"), class = "FutureResult")
[16:20:42.065]     }, finally = {
[16:20:42.065]         if (!identical(...future.workdir, getwd())) 
[16:20:42.065]             setwd(...future.workdir)
[16:20:42.065]         {
[16:20:42.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:42.065]                 ...future.oldOptions$nwarnings <- NULL
[16:20:42.065]             }
[16:20:42.065]             base::options(...future.oldOptions)
[16:20:42.065]             if (.Platform$OS.type == "windows") {
[16:20:42.065]                 old_names <- names(...future.oldEnvVars)
[16:20:42.065]                 envs <- base::Sys.getenv()
[16:20:42.065]                 names <- names(envs)
[16:20:42.065]                 common <- intersect(names, old_names)
[16:20:42.065]                 added <- setdiff(names, old_names)
[16:20:42.065]                 removed <- setdiff(old_names, names)
[16:20:42.065]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:42.065]                   envs[common]]
[16:20:42.065]                 NAMES <- toupper(changed)
[16:20:42.065]                 args <- list()
[16:20:42.065]                 for (kk in seq_along(NAMES)) {
[16:20:42.065]                   name <- changed[[kk]]
[16:20:42.065]                   NAME <- NAMES[[kk]]
[16:20:42.065]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.065]                     next
[16:20:42.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.065]                 }
[16:20:42.065]                 NAMES <- toupper(added)
[16:20:42.065]                 for (kk in seq_along(NAMES)) {
[16:20:42.065]                   name <- added[[kk]]
[16:20:42.065]                   NAME <- NAMES[[kk]]
[16:20:42.065]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.065]                     next
[16:20:42.065]                   args[[name]] <- ""
[16:20:42.065]                 }
[16:20:42.065]                 NAMES <- toupper(removed)
[16:20:42.065]                 for (kk in seq_along(NAMES)) {
[16:20:42.065]                   name <- removed[[kk]]
[16:20:42.065]                   NAME <- NAMES[[kk]]
[16:20:42.065]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.065]                     next
[16:20:42.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.065]                 }
[16:20:42.065]                 if (length(args) > 0) 
[16:20:42.065]                   base::do.call(base::Sys.setenv, args = args)
[16:20:42.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:42.065]             }
[16:20:42.065]             else {
[16:20:42.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:42.065]             }
[16:20:42.065]             {
[16:20:42.065]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:42.065]                   0L) {
[16:20:42.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:42.065]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:42.065]                   base::options(opts)
[16:20:42.065]                 }
[16:20:42.065]                 {
[16:20:42.065]                   {
[16:20:42.065]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:42.065]                     NULL
[16:20:42.065]                   }
[16:20:42.065]                   options(future.plan = NULL)
[16:20:42.065]                   if (is.na(NA_character_)) 
[16:20:42.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:42.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:42.065]                     .init = FALSE)
[16:20:42.065]                 }
[16:20:42.065]             }
[16:20:42.065]         }
[16:20:42.065]     })
[16:20:42.065]     if (TRUE) {
[16:20:42.065]         base::sink(type = "output", split = FALSE)
[16:20:42.065]         if (TRUE) {
[16:20:42.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:42.065]         }
[16:20:42.065]         else {
[16:20:42.065]             ...future.result["stdout"] <- base::list(NULL)
[16:20:42.065]         }
[16:20:42.065]         base::close(...future.stdout)
[16:20:42.065]         ...future.stdout <- NULL
[16:20:42.065]     }
[16:20:42.065]     ...future.result$conditions <- ...future.conditions
[16:20:42.065]     ...future.result$finished <- base::Sys.time()
[16:20:42.065]     ...future.result
[16:20:42.065] }
[16:20:42.069] requestCore(): workers = 2
[16:20:42.071] MulticoreFuture started
[16:20:42.072] - Launch lazy future ... done
[16:20:42.072] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[16:20:42.072] plan(): Setting new future strategy stack:
 num 1
 $ b:[16:20:42.073] List of future strategies:
[16:20:42.073] 1. sequential:
[16:20:42.073]    - args: function (..., envir = parent.frame())
[16:20:42.073]    - tweaked: FALSE
[16:20:42.073]    - call: NULL
[16:20:42.074] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0bbcafa0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c0b6318> 
 $  :[16:20:42.076] plan(): Setting new future strategy stack:
[16:20:42.076] List of future strategies:
[16:20:42.076] 1. multicore:
[16:20:42.076]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:42.076]    - tweaked: FALSE
[16:20:42.076]    - call: plan(strategy)
 NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0bbcafa0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c0b6318> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")=[16:20:42.086] plan(): nbrOfWorkers() = 2
 int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:42.093] resolve() on list ...
[16:20:42.093]  recursive: 0
[16:20:42.094]  length: 6
[16:20:42.094]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:42.094] signalConditionsASAP(numeric, pos=1) ...
[16:20:42.094] - nx: 6
[16:20:42.094] - relay: TRUE
[16:20:42.094] - stdout: TRUE
[16:20:42.094] - signal: TRUE
[16:20:42.095] - resignal: FALSE
[16:20:42.095] - force: TRUE
[16:20:42.095] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.095] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.095]  - until=2
[16:20:42.095]  - relaying element #2
[16:20:42.095] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.095] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.096] signalConditionsASAP(NULL, pos=1) ... done
[16:20:42.096]  length: 5 (resolved future 1)
[16:20:42.096] Future #2
[16:20:42.096] result() for MulticoreFuture ...
[16:20:42.097] result() for MulticoreFuture ...
[16:20:42.097] result() for MulticoreFuture ... done
[16:20:42.097] result() for MulticoreFuture ... done
[16:20:42.097] result() for MulticoreFuture ...
[16:20:42.098] result() for MulticoreFuture ... done
[16:20:42.098] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:42.098] - nx: 6
[16:20:42.098] - relay: TRUE
[16:20:42.098] - stdout: TRUE
[16:20:42.098] - signal: TRUE
[16:20:42.098] - resignal: FALSE
[16:20:42.098] - force: TRUE
[16:20:42.098] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.099] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.099]  - until=2
[16:20:42.099]  - relaying element #2
[16:20:42.099] result() for MulticoreFuture ...
[16:20:42.099] result() for MulticoreFuture ... done
[16:20:42.099] result() for MulticoreFuture ...
[16:20:42.099] result() for MulticoreFuture ... done
[16:20:42.100] result() for MulticoreFuture ...
[16:20:42.100] result() for MulticoreFuture ... done
[16:20:42.100] result() for MulticoreFuture ...
[16:20:42.100] result() for MulticoreFuture ... done
[16:20:42.100] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.100] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.100] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:42.100]  length: 4 (resolved future 2)
[16:20:42.101] Future #3
[16:20:42.101] result() for MulticoreFuture ...
[16:20:42.101] result() for MulticoreFuture ...
[16:20:42.102] result() for MulticoreFuture ... done
[16:20:42.102] result() for MulticoreFuture ... done
[16:20:42.102] result() for MulticoreFuture ...
[16:20:42.102] result() for MulticoreFuture ... done
[16:20:42.102] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:42.102] - nx: 6
[16:20:42.102] - relay: TRUE
[16:20:42.102] - stdout: TRUE
[16:20:42.102] - signal: TRUE
[16:20:42.103] - resignal: FALSE
[16:20:42.103] - force: TRUE
[16:20:42.103] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.103] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.103]  - until=3
[16:20:42.103]  - relaying element #3
[16:20:42.103] result() for MulticoreFuture ...
[16:20:42.103] result() for MulticoreFuture ... done
[16:20:42.103] result() for MulticoreFuture ...
[16:20:42.104] result() for MulticoreFuture ... done
[16:20:42.104] result() for MulticoreFuture ...
[16:20:42.104] result() for MulticoreFuture ... done
[16:20:42.104] result() for MulticoreFuture ...
[16:20:42.104] result() for MulticoreFuture ... done
[16:20:42.104] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.104] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.104] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:42.104]  length: 3 (resolved future 3)
[16:20:42.105] signalConditionsASAP(NULL, pos=4) ...
[16:20:42.105] - nx: 6
[16:20:42.105] - relay: TRUE
[16:20:42.105] - stdout: TRUE
[16:20:42.105] - signal: TRUE
[16:20:42.105] - resignal: FALSE
[16:20:42.105] - force: TRUE
[16:20:42.105] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.105] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.105]  - until=5
[16:20:42.106]  - relaying element #5
[16:20:42.106] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:42.106] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.106] signalConditionsASAP(NULL, pos=4) ... done
[16:20:42.106]  length: 2 (resolved future 4)
[16:20:42.106] signalConditionsASAP(NULL, pos=5) ...
[16:20:42.106] - nx: 6
[16:20:42.106] - relay: TRUE
[16:20:42.106] - stdout: TRUE
[16:20:42.106] - signal: TRUE
[16:20:42.106] - resignal: FALSE
[16:20:42.107] - force: TRUE
[16:20:42.107] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:42.107] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.107]  - until=6
[16:20:42.107]  - relaying element #6
[16:20:42.107] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:42.107] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.107] signalConditionsASAP(NULL, pos=5) ... done
[16:20:42.107]  length: 1 (resolved future 5)
[16:20:42.107] signalConditionsASAP(numeric, pos=6) ...
[16:20:42.108] - nx: 6
[16:20:42.108] - relay: TRUE
[16:20:42.108] - stdout: TRUE
[16:20:42.108] - signal: TRUE
[16:20:42.108] - resignal: FALSE
[16:20:42.108] - force: TRUE
[16:20:42.108] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:42.108] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.108]  - until=6
[16:20:42.108] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.109] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.109] signalConditionsASAP(numeric, pos=6) ... done
[16:20:42.109]  length: 0 (resolved future 6)
[16:20:42.109] Relaying remaining futures
[16:20:42.109] signalConditionsASAP(NULL, pos=0) ...
[16:20:42.109] - nx: 6
[16:20:42.109] - relay: TRUE
[16:20:42.109] - stdout: TRUE
[16:20:42.109] - signal: TRUE
[16:20:42.109] - resignal: FALSE
[16:20:42.109] - force: TRUE
[16:20:42.110] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.110] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:42.110] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.110] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.110] signalConditionsASAP(NULL, pos=0) ... done
[16:20:42.110] resolve() on list ... DONE
[16:20:42.110] result() for MulticoreFuture ...
[16:20:42.110] result() for MulticoreFuture ... done
[16:20:42.110] result() for MulticoreFuture ...
[16:20:42.111] result() for MulticoreFuture ... done
[16:20:42.111] result() for MulticoreFuture ...
[16:20:42.111] result() for MulticoreFuture ... done
[16:20:42.111] result() for MulticoreFuture ...
[16:20:42.111] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[16:20:42.117] plan(): Setting new future strategy stack:
[16:20:42.117] List of future strategies:
[16:20:42.117] 1. multisession:
[16:20:42.117]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:42.117]    - tweaked: FALSE
[16:20:42.117]    - call: plan(strategy)
[16:20:42.117] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:20:42.117] multisession:
[16:20:42.117] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:42.117] - tweaked: FALSE
[16:20:42.117] - call: plan(strategy)
[16:20:42.123] getGlobalsAndPackages() ...
[16:20:42.124] Not searching for globals
[16:20:42.124] - globals: [0] <none>
[16:20:42.124] getGlobalsAndPackages() ... DONE
[16:20:42.124] [local output] makeClusterPSOCK() ...
[16:20:42.163] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:20:42.164] [local output] Base port: 11348
[16:20:42.164] [local output] Getting setup options for 2 cluster nodes ...
[16:20:42.164] [local output]  - Node 1 of 2 ...
[16:20:42.165] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:42.166] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZGO0ru/worker.rank=1.parallelly.parent=81506.13e6251f8941.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpZGO0ru/worker.rank=1.parallelly.parent=81506.13e6251f8941.pid")'’
[16:20:42.355] - Possible to infer worker's PID: TRUE
[16:20:42.356] [local output] Rscript port: 11348

[16:20:42.356] [local output]  - Node 2 of 2 ...
[16:20:42.357] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:42.357] [local output] Rscript port: 11348

[16:20:42.357] [local output] Getting setup options for 2 cluster nodes ... done
[16:20:42.358] [local output]  - Parallel setup requested for some PSOCK nodes
[16:20:42.358] [local output] Setting up PSOCK nodes in parallel
[16:20:42.358] List of 36
[16:20:42.358]  $ worker          : chr "localhost"
[16:20:42.358]   ..- attr(*, "localhost")= logi TRUE
[16:20:42.358]  $ master          : chr "localhost"
[16:20:42.358]  $ port            : int 11348
[16:20:42.358]  $ connectTimeout  : num 120
[16:20:42.358]  $ timeout         : num 2592000
[16:20:42.358]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:20:42.358]  $ homogeneous     : logi TRUE
[16:20:42.358]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:20:42.358]  $ rscript_envs    : NULL
[16:20:42.358]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:42.358]  $ rscript_startup : NULL
[16:20:42.358]  $ rscript_sh      : chr "sh"
[16:20:42.358]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:42.358]  $ methods         : logi TRUE
[16:20:42.358]  $ socketOptions   : chr "no-delay"
[16:20:42.358]  $ useXDR          : logi FALSE
[16:20:42.358]  $ outfile         : chr "/dev/null"
[16:20:42.358]  $ renice          : int NA
[16:20:42.358]  $ rshcmd          : NULL
[16:20:42.358]  $ user            : chr(0) 
[16:20:42.358]  $ revtunnel       : logi FALSE
[16:20:42.358]  $ rshlogfile      : NULL
[16:20:42.358]  $ rshopts         : chr(0) 
[16:20:42.358]  $ rank            : int 1
[16:20:42.358]  $ manual          : logi FALSE
[16:20:42.358]  $ dryrun          : logi FALSE
[16:20:42.358]  $ quiet           : logi FALSE
[16:20:42.358]  $ setup_strategy  : chr "parallel"
[16:20:42.358]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:42.358]  $ pidfile         : chr "/tmp/RtmpZGO0ru/worker.rank=1.parallelly.parent=81506.13e6251f8941.pid"
[16:20:42.358]  $ rshcmd_label    : NULL
[16:20:42.358]  $ rsh_call        : NULL
[16:20:42.358]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:42.358]  $ localMachine    : logi TRUE
[16:20:42.358]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:20:42.358]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:20:42.358]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:20:42.358]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:20:42.358]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:20:42.358]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:20:42.358]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:20:42.358]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:20:42.358]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:20:42.358]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:20:42.358]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:20:42.358]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:20:42.358]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:20:42.358]  $ arguments       :List of 28
[16:20:42.358]   ..$ worker          : chr "localhost"
[16:20:42.358]   ..$ master          : NULL
[16:20:42.358]   ..$ port            : int 11348
[16:20:42.358]   ..$ connectTimeout  : num 120
[16:20:42.358]   ..$ timeout         : num 2592000
[16:20:42.358]   ..$ rscript         : NULL
[16:20:42.358]   ..$ homogeneous     : NULL
[16:20:42.358]   ..$ rscript_args    : NULL
[16:20:42.358]   ..$ rscript_envs    : NULL
[16:20:42.358]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:42.358]   ..$ rscript_startup : NULL
[16:20:42.358]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:20:42.358]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:42.358]   ..$ methods         : logi TRUE
[16:20:42.358]   ..$ socketOptions   : chr "no-delay"
[16:20:42.358]   ..$ useXDR          : logi FALSE
[16:20:42.358]   ..$ outfile         : chr "/dev/null"
[16:20:42.358]   ..$ renice          : int NA
[16:20:42.358]   ..$ rshcmd          : NULL
[16:20:42.358]   ..$ user            : NULL
[16:20:42.358]   ..$ revtunnel       : logi NA
[16:20:42.358]   ..$ rshlogfile      : NULL
[16:20:42.358]   ..$ rshopts         : NULL
[16:20:42.358]   ..$ rank            : int 1
[16:20:42.358]   ..$ manual          : logi FALSE
[16:20:42.358]   ..$ dryrun          : logi FALSE
[16:20:42.358]   ..$ quiet           : logi FALSE
[16:20:42.358]   ..$ setup_strategy  : chr "parallel"
[16:20:42.358]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:20:42.375] [local output] System call to launch all workers:
[16:20:42.375] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZGO0ru/worker.rank=1.parallelly.parent=81506.13e6251f8941.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11348 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:20:42.375] [local output] Starting PSOCK main server
[16:20:42.381] [local output] Workers launched
[16:20:42.381] [local output] Waiting for workers to connect back
[16:20:42.381]  - [local output] 0 workers out of 2 ready
[16:20:42.630]  - [local output] 0 workers out of 2 ready
[16:20:42.631]  - [local output] 1 workers out of 2 ready
[16:20:42.631]  - [local output] 2 workers out of 2 ready
[16:20:42.631] [local output] Launching of workers completed
[16:20:42.632] [local output] Collecting session information from workers
[16:20:42.632] [local output]  - Worker #1 of 2
[16:20:42.633] [local output]  - Worker #2 of 2
[16:20:42.633] [local output] makeClusterPSOCK() ... done
[16:20:42.645] Packages needed by the future expression (n = 0): <none>
[16:20:42.645] Packages needed by future strategies (n = 0): <none>
[16:20:42.645] {
[16:20:42.645]     {
[16:20:42.645]         {
[16:20:42.645]             ...future.startTime <- base::Sys.time()
[16:20:42.645]             {
[16:20:42.645]                 {
[16:20:42.645]                   {
[16:20:42.645]                     {
[16:20:42.645]                       base::local({
[16:20:42.645]                         has_future <- base::requireNamespace("future", 
[16:20:42.645]                           quietly = TRUE)
[16:20:42.645]                         if (has_future) {
[16:20:42.645]                           ns <- base::getNamespace("future")
[16:20:42.645]                           version <- ns[[".package"]][["version"]]
[16:20:42.645]                           if (is.null(version)) 
[16:20:42.645]                             version <- utils::packageVersion("future")
[16:20:42.645]                         }
[16:20:42.645]                         else {
[16:20:42.645]                           version <- NULL
[16:20:42.645]                         }
[16:20:42.645]                         if (!has_future || version < "1.8.0") {
[16:20:42.645]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:42.645]                             "", base::R.version$version.string), 
[16:20:42.645]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:42.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:42.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:42.645]                               "release", "version")], collapse = " "), 
[16:20:42.645]                             hostname = base::Sys.info()[["nodename"]])
[16:20:42.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:42.645]                             info)
[16:20:42.645]                           info <- base::paste(info, collapse = "; ")
[16:20:42.645]                           if (!has_future) {
[16:20:42.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:42.645]                               info)
[16:20:42.645]                           }
[16:20:42.645]                           else {
[16:20:42.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:42.645]                               info, version)
[16:20:42.645]                           }
[16:20:42.645]                           base::stop(msg)
[16:20:42.645]                         }
[16:20:42.645]                       })
[16:20:42.645]                     }
[16:20:42.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:42.645]                     base::options(mc.cores = 1L)
[16:20:42.645]                   }
[16:20:42.645]                   ...future.strategy.old <- future::plan("list")
[16:20:42.645]                   options(future.plan = NULL)
[16:20:42.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:42.645]                 }
[16:20:42.645]                 ...future.workdir <- getwd()
[16:20:42.645]             }
[16:20:42.645]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:42.645]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:42.645]         }
[16:20:42.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:42.645]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:42.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:42.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:42.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:42.645]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:42.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:42.645]             base::names(...future.oldOptions))
[16:20:42.645]     }
[16:20:42.645]     if (FALSE) {
[16:20:42.645]     }
[16:20:42.645]     else {
[16:20:42.645]         if (TRUE) {
[16:20:42.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:42.645]                 open = "w")
[16:20:42.645]         }
[16:20:42.645]         else {
[16:20:42.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:42.645]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:42.645]         }
[16:20:42.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:42.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:42.645]             base::sink(type = "output", split = FALSE)
[16:20:42.645]             base::close(...future.stdout)
[16:20:42.645]         }, add = TRUE)
[16:20:42.645]     }
[16:20:42.645]     ...future.frame <- base::sys.nframe()
[16:20:42.645]     ...future.conditions <- base::list()
[16:20:42.645]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:42.645]     if (FALSE) {
[16:20:42.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:42.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:42.645]     }
[16:20:42.645]     ...future.result <- base::tryCatch({
[16:20:42.645]         base::withCallingHandlers({
[16:20:42.645]             ...future.value <- base::withVisible(base::local({
[16:20:42.645]                 ...future.makeSendCondition <- base::local({
[16:20:42.645]                   sendCondition <- NULL
[16:20:42.645]                   function(frame = 1L) {
[16:20:42.645]                     if (is.function(sendCondition)) 
[16:20:42.645]                       return(sendCondition)
[16:20:42.645]                     ns <- getNamespace("parallel")
[16:20:42.645]                     if (exists("sendData", mode = "function", 
[16:20:42.645]                       envir = ns)) {
[16:20:42.645]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:42.645]                         envir = ns)
[16:20:42.645]                       envir <- sys.frame(frame)
[16:20:42.645]                       master <- NULL
[16:20:42.645]                       while (!identical(envir, .GlobalEnv) && 
[16:20:42.645]                         !identical(envir, emptyenv())) {
[16:20:42.645]                         if (exists("master", mode = "list", envir = envir, 
[16:20:42.645]                           inherits = FALSE)) {
[16:20:42.645]                           master <- get("master", mode = "list", 
[16:20:42.645]                             envir = envir, inherits = FALSE)
[16:20:42.645]                           if (inherits(master, c("SOCKnode", 
[16:20:42.645]                             "SOCK0node"))) {
[16:20:42.645]                             sendCondition <<- function(cond) {
[16:20:42.645]                               data <- list(type = "VALUE", value = cond, 
[16:20:42.645]                                 success = TRUE)
[16:20:42.645]                               parallel_sendData(master, data)
[16:20:42.645]                             }
[16:20:42.645]                             return(sendCondition)
[16:20:42.645]                           }
[16:20:42.645]                         }
[16:20:42.645]                         frame <- frame + 1L
[16:20:42.645]                         envir <- sys.frame(frame)
[16:20:42.645]                       }
[16:20:42.645]                     }
[16:20:42.645]                     sendCondition <<- function(cond) NULL
[16:20:42.645]                   }
[16:20:42.645]                 })
[16:20:42.645]                 withCallingHandlers({
[16:20:42.645]                   NA
[16:20:42.645]                 }, immediateCondition = function(cond) {
[16:20:42.645]                   sendCondition <- ...future.makeSendCondition()
[16:20:42.645]                   sendCondition(cond)
[16:20:42.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.645]                   {
[16:20:42.645]                     inherits <- base::inherits
[16:20:42.645]                     invokeRestart <- base::invokeRestart
[16:20:42.645]                     is.null <- base::is.null
[16:20:42.645]                     muffled <- FALSE
[16:20:42.645]                     if (inherits(cond, "message")) {
[16:20:42.645]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:42.645]                       if (muffled) 
[16:20:42.645]                         invokeRestart("muffleMessage")
[16:20:42.645]                     }
[16:20:42.645]                     else if (inherits(cond, "warning")) {
[16:20:42.645]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:42.645]                       if (muffled) 
[16:20:42.645]                         invokeRestart("muffleWarning")
[16:20:42.645]                     }
[16:20:42.645]                     else if (inherits(cond, "condition")) {
[16:20:42.645]                       if (!is.null(pattern)) {
[16:20:42.645]                         computeRestarts <- base::computeRestarts
[16:20:42.645]                         grepl <- base::grepl
[16:20:42.645]                         restarts <- computeRestarts(cond)
[16:20:42.645]                         for (restart in restarts) {
[16:20:42.645]                           name <- restart$name
[16:20:42.645]                           if (is.null(name)) 
[16:20:42.645]                             next
[16:20:42.645]                           if (!grepl(pattern, name)) 
[16:20:42.645]                             next
[16:20:42.645]                           invokeRestart(restart)
[16:20:42.645]                           muffled <- TRUE
[16:20:42.645]                           break
[16:20:42.645]                         }
[16:20:42.645]                       }
[16:20:42.645]                     }
[16:20:42.645]                     invisible(muffled)
[16:20:42.645]                   }
[16:20:42.645]                   muffleCondition(cond)
[16:20:42.645]                 })
[16:20:42.645]             }))
[16:20:42.645]             future::FutureResult(value = ...future.value$value, 
[16:20:42.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.645]                   ...future.rng), globalenv = if (FALSE) 
[16:20:42.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:42.645]                     ...future.globalenv.names))
[16:20:42.645]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:42.645]         }, condition = base::local({
[16:20:42.645]             c <- base::c
[16:20:42.645]             inherits <- base::inherits
[16:20:42.645]             invokeRestart <- base::invokeRestart
[16:20:42.645]             length <- base::length
[16:20:42.645]             list <- base::list
[16:20:42.645]             seq.int <- base::seq.int
[16:20:42.645]             signalCondition <- base::signalCondition
[16:20:42.645]             sys.calls <- base::sys.calls
[16:20:42.645]             `[[` <- base::`[[`
[16:20:42.645]             `+` <- base::`+`
[16:20:42.645]             `<<-` <- base::`<<-`
[16:20:42.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:42.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:42.645]                   3L)]
[16:20:42.645]             }
[16:20:42.645]             function(cond) {
[16:20:42.645]                 is_error <- inherits(cond, "error")
[16:20:42.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:42.645]                   NULL)
[16:20:42.645]                 if (is_error) {
[16:20:42.645]                   sessionInformation <- function() {
[16:20:42.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:42.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:42.645]                       search = base::search(), system = base::Sys.info())
[16:20:42.645]                   }
[16:20:42.645]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:42.645]                     cond$call), session = sessionInformation(), 
[16:20:42.645]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:42.645]                   signalCondition(cond)
[16:20:42.645]                 }
[16:20:42.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:42.645]                 "immediateCondition"))) {
[16:20:42.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:42.645]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:42.645]                   if (TRUE && !signal) {
[16:20:42.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.645]                     {
[16:20:42.645]                       inherits <- base::inherits
[16:20:42.645]                       invokeRestart <- base::invokeRestart
[16:20:42.645]                       is.null <- base::is.null
[16:20:42.645]                       muffled <- FALSE
[16:20:42.645]                       if (inherits(cond, "message")) {
[16:20:42.645]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.645]                         if (muffled) 
[16:20:42.645]                           invokeRestart("muffleMessage")
[16:20:42.645]                       }
[16:20:42.645]                       else if (inherits(cond, "warning")) {
[16:20:42.645]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.645]                         if (muffled) 
[16:20:42.645]                           invokeRestart("muffleWarning")
[16:20:42.645]                       }
[16:20:42.645]                       else if (inherits(cond, "condition")) {
[16:20:42.645]                         if (!is.null(pattern)) {
[16:20:42.645]                           computeRestarts <- base::computeRestarts
[16:20:42.645]                           grepl <- base::grepl
[16:20:42.645]                           restarts <- computeRestarts(cond)
[16:20:42.645]                           for (restart in restarts) {
[16:20:42.645]                             name <- restart$name
[16:20:42.645]                             if (is.null(name)) 
[16:20:42.645]                               next
[16:20:42.645]                             if (!grepl(pattern, name)) 
[16:20:42.645]                               next
[16:20:42.645]                             invokeRestart(restart)
[16:20:42.645]                             muffled <- TRUE
[16:20:42.645]                             break
[16:20:42.645]                           }
[16:20:42.645]                         }
[16:20:42.645]                       }
[16:20:42.645]                       invisible(muffled)
[16:20:42.645]                     }
[16:20:42.645]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.645]                   }
[16:20:42.645]                 }
[16:20:42.645]                 else {
[16:20:42.645]                   if (TRUE) {
[16:20:42.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.645]                     {
[16:20:42.645]                       inherits <- base::inherits
[16:20:42.645]                       invokeRestart <- base::invokeRestart
[16:20:42.645]                       is.null <- base::is.null
[16:20:42.645]                       muffled <- FALSE
[16:20:42.645]                       if (inherits(cond, "message")) {
[16:20:42.645]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.645]                         if (muffled) 
[16:20:42.645]                           invokeRestart("muffleMessage")
[16:20:42.645]                       }
[16:20:42.645]                       else if (inherits(cond, "warning")) {
[16:20:42.645]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.645]                         if (muffled) 
[16:20:42.645]                           invokeRestart("muffleWarning")
[16:20:42.645]                       }
[16:20:42.645]                       else if (inherits(cond, "condition")) {
[16:20:42.645]                         if (!is.null(pattern)) {
[16:20:42.645]                           computeRestarts <- base::computeRestarts
[16:20:42.645]                           grepl <- base::grepl
[16:20:42.645]                           restarts <- computeRestarts(cond)
[16:20:42.645]                           for (restart in restarts) {
[16:20:42.645]                             name <- restart$name
[16:20:42.645]                             if (is.null(name)) 
[16:20:42.645]                               next
[16:20:42.645]                             if (!grepl(pattern, name)) 
[16:20:42.645]                               next
[16:20:42.645]                             invokeRestart(restart)
[16:20:42.645]                             muffled <- TRUE
[16:20:42.645]                             break
[16:20:42.645]                           }
[16:20:42.645]                         }
[16:20:42.645]                       }
[16:20:42.645]                       invisible(muffled)
[16:20:42.645]                     }
[16:20:42.645]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.645]                   }
[16:20:42.645]                 }
[16:20:42.645]             }
[16:20:42.645]         }))
[16:20:42.645]     }, error = function(ex) {
[16:20:42.645]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:42.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.645]                 ...future.rng), started = ...future.startTime, 
[16:20:42.645]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:42.645]             version = "1.8"), class = "FutureResult")
[16:20:42.645]     }, finally = {
[16:20:42.645]         if (!identical(...future.workdir, getwd())) 
[16:20:42.645]             setwd(...future.workdir)
[16:20:42.645]         {
[16:20:42.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:42.645]                 ...future.oldOptions$nwarnings <- NULL
[16:20:42.645]             }
[16:20:42.645]             base::options(...future.oldOptions)
[16:20:42.645]             if (.Platform$OS.type == "windows") {
[16:20:42.645]                 old_names <- names(...future.oldEnvVars)
[16:20:42.645]                 envs <- base::Sys.getenv()
[16:20:42.645]                 names <- names(envs)
[16:20:42.645]                 common <- intersect(names, old_names)
[16:20:42.645]                 added <- setdiff(names, old_names)
[16:20:42.645]                 removed <- setdiff(old_names, names)
[16:20:42.645]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:42.645]                   envs[common]]
[16:20:42.645]                 NAMES <- toupper(changed)
[16:20:42.645]                 args <- list()
[16:20:42.645]                 for (kk in seq_along(NAMES)) {
[16:20:42.645]                   name <- changed[[kk]]
[16:20:42.645]                   NAME <- NAMES[[kk]]
[16:20:42.645]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.645]                     next
[16:20:42.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.645]                 }
[16:20:42.645]                 NAMES <- toupper(added)
[16:20:42.645]                 for (kk in seq_along(NAMES)) {
[16:20:42.645]                   name <- added[[kk]]
[16:20:42.645]                   NAME <- NAMES[[kk]]
[16:20:42.645]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.645]                     next
[16:20:42.645]                   args[[name]] <- ""
[16:20:42.645]                 }
[16:20:42.645]                 NAMES <- toupper(removed)
[16:20:42.645]                 for (kk in seq_along(NAMES)) {
[16:20:42.645]                   name <- removed[[kk]]
[16:20:42.645]                   NAME <- NAMES[[kk]]
[16:20:42.645]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.645]                     next
[16:20:42.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.645]                 }
[16:20:42.645]                 if (length(args) > 0) 
[16:20:42.645]                   base::do.call(base::Sys.setenv, args = args)
[16:20:42.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:42.645]             }
[16:20:42.645]             else {
[16:20:42.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:42.645]             }
[16:20:42.645]             {
[16:20:42.645]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:42.645]                   0L) {
[16:20:42.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:42.645]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:42.645]                   base::options(opts)
[16:20:42.645]                 }
[16:20:42.645]                 {
[16:20:42.645]                   {
[16:20:42.645]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:42.645]                     NULL
[16:20:42.645]                   }
[16:20:42.645]                   options(future.plan = NULL)
[16:20:42.645]                   if (is.na(NA_character_)) 
[16:20:42.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:42.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:42.645]                     .init = FALSE)
[16:20:42.645]                 }
[16:20:42.645]             }
[16:20:42.645]         }
[16:20:42.645]     })
[16:20:42.645]     if (TRUE) {
[16:20:42.645]         base::sink(type = "output", split = FALSE)
[16:20:42.645]         if (TRUE) {
[16:20:42.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:42.645]         }
[16:20:42.645]         else {
[16:20:42.645]             ...future.result["stdout"] <- base::list(NULL)
[16:20:42.645]         }
[16:20:42.645]         base::close(...future.stdout)
[16:20:42.645]         ...future.stdout <- NULL
[16:20:42.645]     }
[16:20:42.645]     ...future.result$conditions <- ...future.conditions
[16:20:42.645]     ...future.result$finished <- base::Sys.time()
[16:20:42.645]     ...future.result
[16:20:42.645] }
[16:20:42.709] MultisessionFuture started
[16:20:42.709] result() for ClusterFuture ...
[16:20:42.710] receiveMessageFromWorker() for ClusterFuture ...
[16:20:42.710] - Validating connection of MultisessionFuture
[16:20:42.752] - received message: FutureResult
[16:20:42.752] - Received FutureResult
[16:20:42.752] - Erased future from FutureRegistry
[16:20:42.753] result() for ClusterFuture ...
[16:20:42.753] - result already collected: FutureResult
[16:20:42.753] result() for ClusterFuture ... done
[16:20:42.753] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:42.753] result() for ClusterFuture ... done
[16:20:42.753] result() for ClusterFuture ...
[16:20:42.754] - result already collected: FutureResult
[16:20:42.754] result() for ClusterFuture ... done
[16:20:42.754] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:20:42.758] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:20:42.758] getGlobalsAndPackages() ...
[16:20:42.759] Searching for globals...
[16:20:42.759] 
[16:20:42.759] Searching for globals ... DONE
[16:20:42.759] - globals: [0] <none>
[16:20:42.759] getGlobalsAndPackages() ... DONE
[16:20:42.760] run() for ‘Future’ ...
[16:20:42.760] - state: ‘created’
[16:20:42.760] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:42.774] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:42.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:42.774]   - Field: ‘node’
[16:20:42.775]   - Field: ‘label’
[16:20:42.775]   - Field: ‘local’
[16:20:42.775]   - Field: ‘owner’
[16:20:42.775]   - Field: ‘envir’
[16:20:42.775]   - Field: ‘workers’
[16:20:42.775]   - Field: ‘packages’
[16:20:42.775]   - Field: ‘gc’
[16:20:42.775]   - Field: ‘conditions’
[16:20:42.775]   - Field: ‘persistent’
[16:20:42.776]   - Field: ‘expr’
[16:20:42.776]   - Field: ‘uuid’
[16:20:42.776]   - Field: ‘seed’
[16:20:42.776]   - Field: ‘version’
[16:20:42.776]   - Field: ‘result’
[16:20:42.776]   - Field: ‘asynchronous’
[16:20:42.776]   - Field: ‘calls’
[16:20:42.776]   - Field: ‘globals’
[16:20:42.776]   - Field: ‘stdout’
[16:20:42.777]   - Field: ‘earlySignal’
[16:20:42.777]   - Field: ‘lazy’
[16:20:42.777]   - Field: ‘state’
[16:20:42.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:42.777] - Launch lazy future ...
[16:20:42.777] Packages needed by the future expression (n = 0): <none>
[16:20:42.778] Packages needed by future strategies (n = 0): <none>
[16:20:42.778] {
[16:20:42.778]     {
[16:20:42.778]         {
[16:20:42.778]             ...future.startTime <- base::Sys.time()
[16:20:42.778]             {
[16:20:42.778]                 {
[16:20:42.778]                   {
[16:20:42.778]                     {
[16:20:42.778]                       base::local({
[16:20:42.778]                         has_future <- base::requireNamespace("future", 
[16:20:42.778]                           quietly = TRUE)
[16:20:42.778]                         if (has_future) {
[16:20:42.778]                           ns <- base::getNamespace("future")
[16:20:42.778]                           version <- ns[[".package"]][["version"]]
[16:20:42.778]                           if (is.null(version)) 
[16:20:42.778]                             version <- utils::packageVersion("future")
[16:20:42.778]                         }
[16:20:42.778]                         else {
[16:20:42.778]                           version <- NULL
[16:20:42.778]                         }
[16:20:42.778]                         if (!has_future || version < "1.8.0") {
[16:20:42.778]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:42.778]                             "", base::R.version$version.string), 
[16:20:42.778]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:42.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:42.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:42.778]                               "release", "version")], collapse = " "), 
[16:20:42.778]                             hostname = base::Sys.info()[["nodename"]])
[16:20:42.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:42.778]                             info)
[16:20:42.778]                           info <- base::paste(info, collapse = "; ")
[16:20:42.778]                           if (!has_future) {
[16:20:42.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:42.778]                               info)
[16:20:42.778]                           }
[16:20:42.778]                           else {
[16:20:42.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:42.778]                               info, version)
[16:20:42.778]                           }
[16:20:42.778]                           base::stop(msg)
[16:20:42.778]                         }
[16:20:42.778]                       })
[16:20:42.778]                     }
[16:20:42.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:42.778]                     base::options(mc.cores = 1L)
[16:20:42.778]                   }
[16:20:42.778]                   ...future.strategy.old <- future::plan("list")
[16:20:42.778]                   options(future.plan = NULL)
[16:20:42.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:42.778]                 }
[16:20:42.778]                 ...future.workdir <- getwd()
[16:20:42.778]             }
[16:20:42.778]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:42.778]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:42.778]         }
[16:20:42.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:42.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:42.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:42.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:42.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:42.778]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:42.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:42.778]             base::names(...future.oldOptions))
[16:20:42.778]     }
[16:20:42.778]     if (FALSE) {
[16:20:42.778]     }
[16:20:42.778]     else {
[16:20:42.778]         if (TRUE) {
[16:20:42.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:42.778]                 open = "w")
[16:20:42.778]         }
[16:20:42.778]         else {
[16:20:42.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:42.778]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:42.778]         }
[16:20:42.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:42.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:42.778]             base::sink(type = "output", split = FALSE)
[16:20:42.778]             base::close(...future.stdout)
[16:20:42.778]         }, add = TRUE)
[16:20:42.778]     }
[16:20:42.778]     ...future.frame <- base::sys.nframe()
[16:20:42.778]     ...future.conditions <- base::list()
[16:20:42.778]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:42.778]     if (FALSE) {
[16:20:42.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:42.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:42.778]     }
[16:20:42.778]     ...future.result <- base::tryCatch({
[16:20:42.778]         base::withCallingHandlers({
[16:20:42.778]             ...future.value <- base::withVisible(base::local({
[16:20:42.778]                 ...future.makeSendCondition <- base::local({
[16:20:42.778]                   sendCondition <- NULL
[16:20:42.778]                   function(frame = 1L) {
[16:20:42.778]                     if (is.function(sendCondition)) 
[16:20:42.778]                       return(sendCondition)
[16:20:42.778]                     ns <- getNamespace("parallel")
[16:20:42.778]                     if (exists("sendData", mode = "function", 
[16:20:42.778]                       envir = ns)) {
[16:20:42.778]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:42.778]                         envir = ns)
[16:20:42.778]                       envir <- sys.frame(frame)
[16:20:42.778]                       master <- NULL
[16:20:42.778]                       while (!identical(envir, .GlobalEnv) && 
[16:20:42.778]                         !identical(envir, emptyenv())) {
[16:20:42.778]                         if (exists("master", mode = "list", envir = envir, 
[16:20:42.778]                           inherits = FALSE)) {
[16:20:42.778]                           master <- get("master", mode = "list", 
[16:20:42.778]                             envir = envir, inherits = FALSE)
[16:20:42.778]                           if (inherits(master, c("SOCKnode", 
[16:20:42.778]                             "SOCK0node"))) {
[16:20:42.778]                             sendCondition <<- function(cond) {
[16:20:42.778]                               data <- list(type = "VALUE", value = cond, 
[16:20:42.778]                                 success = TRUE)
[16:20:42.778]                               parallel_sendData(master, data)
[16:20:42.778]                             }
[16:20:42.778]                             return(sendCondition)
[16:20:42.778]                           }
[16:20:42.778]                         }
[16:20:42.778]                         frame <- frame + 1L
[16:20:42.778]                         envir <- sys.frame(frame)
[16:20:42.778]                       }
[16:20:42.778]                     }
[16:20:42.778]                     sendCondition <<- function(cond) NULL
[16:20:42.778]                   }
[16:20:42.778]                 })
[16:20:42.778]                 withCallingHandlers({
[16:20:42.778]                   2
[16:20:42.778]                 }, immediateCondition = function(cond) {
[16:20:42.778]                   sendCondition <- ...future.makeSendCondition()
[16:20:42.778]                   sendCondition(cond)
[16:20:42.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.778]                   {
[16:20:42.778]                     inherits <- base::inherits
[16:20:42.778]                     invokeRestart <- base::invokeRestart
[16:20:42.778]                     is.null <- base::is.null
[16:20:42.778]                     muffled <- FALSE
[16:20:42.778]                     if (inherits(cond, "message")) {
[16:20:42.778]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:42.778]                       if (muffled) 
[16:20:42.778]                         invokeRestart("muffleMessage")
[16:20:42.778]                     }
[16:20:42.778]                     else if (inherits(cond, "warning")) {
[16:20:42.778]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:42.778]                       if (muffled) 
[16:20:42.778]                         invokeRestart("muffleWarning")
[16:20:42.778]                     }
[16:20:42.778]                     else if (inherits(cond, "condition")) {
[16:20:42.778]                       if (!is.null(pattern)) {
[16:20:42.778]                         computeRestarts <- base::computeRestarts
[16:20:42.778]                         grepl <- base::grepl
[16:20:42.778]                         restarts <- computeRestarts(cond)
[16:20:42.778]                         for (restart in restarts) {
[16:20:42.778]                           name <- restart$name
[16:20:42.778]                           if (is.null(name)) 
[16:20:42.778]                             next
[16:20:42.778]                           if (!grepl(pattern, name)) 
[16:20:42.778]                             next
[16:20:42.778]                           invokeRestart(restart)
[16:20:42.778]                           muffled <- TRUE
[16:20:42.778]                           break
[16:20:42.778]                         }
[16:20:42.778]                       }
[16:20:42.778]                     }
[16:20:42.778]                     invisible(muffled)
[16:20:42.778]                   }
[16:20:42.778]                   muffleCondition(cond)
[16:20:42.778]                 })
[16:20:42.778]             }))
[16:20:42.778]             future::FutureResult(value = ...future.value$value, 
[16:20:42.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.778]                   ...future.rng), globalenv = if (FALSE) 
[16:20:42.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:42.778]                     ...future.globalenv.names))
[16:20:42.778]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:42.778]         }, condition = base::local({
[16:20:42.778]             c <- base::c
[16:20:42.778]             inherits <- base::inherits
[16:20:42.778]             invokeRestart <- base::invokeRestart
[16:20:42.778]             length <- base::length
[16:20:42.778]             list <- base::list
[16:20:42.778]             seq.int <- base::seq.int
[16:20:42.778]             signalCondition <- base::signalCondition
[16:20:42.778]             sys.calls <- base::sys.calls
[16:20:42.778]             `[[` <- base::`[[`
[16:20:42.778]             `+` <- base::`+`
[16:20:42.778]             `<<-` <- base::`<<-`
[16:20:42.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:42.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:42.778]                   3L)]
[16:20:42.778]             }
[16:20:42.778]             function(cond) {
[16:20:42.778]                 is_error <- inherits(cond, "error")
[16:20:42.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:42.778]                   NULL)
[16:20:42.778]                 if (is_error) {
[16:20:42.778]                   sessionInformation <- function() {
[16:20:42.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:42.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:42.778]                       search = base::search(), system = base::Sys.info())
[16:20:42.778]                   }
[16:20:42.778]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:42.778]                     cond$call), session = sessionInformation(), 
[16:20:42.778]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:42.778]                   signalCondition(cond)
[16:20:42.778]                 }
[16:20:42.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:42.778]                 "immediateCondition"))) {
[16:20:42.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:42.778]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:42.778]                   if (TRUE && !signal) {
[16:20:42.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.778]                     {
[16:20:42.778]                       inherits <- base::inherits
[16:20:42.778]                       invokeRestart <- base::invokeRestart
[16:20:42.778]                       is.null <- base::is.null
[16:20:42.778]                       muffled <- FALSE
[16:20:42.778]                       if (inherits(cond, "message")) {
[16:20:42.778]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.778]                         if (muffled) 
[16:20:42.778]                           invokeRestart("muffleMessage")
[16:20:42.778]                       }
[16:20:42.778]                       else if (inherits(cond, "warning")) {
[16:20:42.778]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.778]                         if (muffled) 
[16:20:42.778]                           invokeRestart("muffleWarning")
[16:20:42.778]                       }
[16:20:42.778]                       else if (inherits(cond, "condition")) {
[16:20:42.778]                         if (!is.null(pattern)) {
[16:20:42.778]                           computeRestarts <- base::computeRestarts
[16:20:42.778]                           grepl <- base::grepl
[16:20:42.778]                           restarts <- computeRestarts(cond)
[16:20:42.778]                           for (restart in restarts) {
[16:20:42.778]                             name <- restart$name
[16:20:42.778]                             if (is.null(name)) 
[16:20:42.778]                               next
[16:20:42.778]                             if (!grepl(pattern, name)) 
[16:20:42.778]                               next
[16:20:42.778]                             invokeRestart(restart)
[16:20:42.778]                             muffled <- TRUE
[16:20:42.778]                             break
[16:20:42.778]                           }
[16:20:42.778]                         }
[16:20:42.778]                       }
[16:20:42.778]                       invisible(muffled)
[16:20:42.778]                     }
[16:20:42.778]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.778]                   }
[16:20:42.778]                 }
[16:20:42.778]                 else {
[16:20:42.778]                   if (TRUE) {
[16:20:42.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.778]                     {
[16:20:42.778]                       inherits <- base::inherits
[16:20:42.778]                       invokeRestart <- base::invokeRestart
[16:20:42.778]                       is.null <- base::is.null
[16:20:42.778]                       muffled <- FALSE
[16:20:42.778]                       if (inherits(cond, "message")) {
[16:20:42.778]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.778]                         if (muffled) 
[16:20:42.778]                           invokeRestart("muffleMessage")
[16:20:42.778]                       }
[16:20:42.778]                       else if (inherits(cond, "warning")) {
[16:20:42.778]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.778]                         if (muffled) 
[16:20:42.778]                           invokeRestart("muffleWarning")
[16:20:42.778]                       }
[16:20:42.778]                       else if (inherits(cond, "condition")) {
[16:20:42.778]                         if (!is.null(pattern)) {
[16:20:42.778]                           computeRestarts <- base::computeRestarts
[16:20:42.778]                           grepl <- base::grepl
[16:20:42.778]                           restarts <- computeRestarts(cond)
[16:20:42.778]                           for (restart in restarts) {
[16:20:42.778]                             name <- restart$name
[16:20:42.778]                             if (is.null(name)) 
[16:20:42.778]                               next
[16:20:42.778]                             if (!grepl(pattern, name)) 
[16:20:42.778]                               next
[16:20:42.778]                             invokeRestart(restart)
[16:20:42.778]                             muffled <- TRUE
[16:20:42.778]                             break
[16:20:42.778]                           }
[16:20:42.778]                         }
[16:20:42.778]                       }
[16:20:42.778]                       invisible(muffled)
[16:20:42.778]                     }
[16:20:42.778]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.778]                   }
[16:20:42.778]                 }
[16:20:42.778]             }
[16:20:42.778]         }))
[16:20:42.778]     }, error = function(ex) {
[16:20:42.778]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:42.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.778]                 ...future.rng), started = ...future.startTime, 
[16:20:42.778]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:42.778]             version = "1.8"), class = "FutureResult")
[16:20:42.778]     }, finally = {
[16:20:42.778]         if (!identical(...future.workdir, getwd())) 
[16:20:42.778]             setwd(...future.workdir)
[16:20:42.778]         {
[16:20:42.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:42.778]                 ...future.oldOptions$nwarnings <- NULL
[16:20:42.778]             }
[16:20:42.778]             base::options(...future.oldOptions)
[16:20:42.778]             if (.Platform$OS.type == "windows") {
[16:20:42.778]                 old_names <- names(...future.oldEnvVars)
[16:20:42.778]                 envs <- base::Sys.getenv()
[16:20:42.778]                 names <- names(envs)
[16:20:42.778]                 common <- intersect(names, old_names)
[16:20:42.778]                 added <- setdiff(names, old_names)
[16:20:42.778]                 removed <- setdiff(old_names, names)
[16:20:42.778]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:42.778]                   envs[common]]
[16:20:42.778]                 NAMES <- toupper(changed)
[16:20:42.778]                 args <- list()
[16:20:42.778]                 for (kk in seq_along(NAMES)) {
[16:20:42.778]                   name <- changed[[kk]]
[16:20:42.778]                   NAME <- NAMES[[kk]]
[16:20:42.778]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.778]                     next
[16:20:42.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.778]                 }
[16:20:42.778]                 NAMES <- toupper(added)
[16:20:42.778]                 for (kk in seq_along(NAMES)) {
[16:20:42.778]                   name <- added[[kk]]
[16:20:42.778]                   NAME <- NAMES[[kk]]
[16:20:42.778]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.778]                     next
[16:20:42.778]                   args[[name]] <- ""
[16:20:42.778]                 }
[16:20:42.778]                 NAMES <- toupper(removed)
[16:20:42.778]                 for (kk in seq_along(NAMES)) {
[16:20:42.778]                   name <- removed[[kk]]
[16:20:42.778]                   NAME <- NAMES[[kk]]
[16:20:42.778]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.778]                     next
[16:20:42.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.778]                 }
[16:20:42.778]                 if (length(args) > 0) 
[16:20:42.778]                   base::do.call(base::Sys.setenv, args = args)
[16:20:42.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:42.778]             }
[16:20:42.778]             else {
[16:20:42.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:42.778]             }
[16:20:42.778]             {
[16:20:42.778]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:42.778]                   0L) {
[16:20:42.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:42.778]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:42.778]                   base::options(opts)
[16:20:42.778]                 }
[16:20:42.778]                 {
[16:20:42.778]                   {
[16:20:42.778]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:42.778]                     NULL
[16:20:42.778]                   }
[16:20:42.778]                   options(future.plan = NULL)
[16:20:42.778]                   if (is.na(NA_character_)) 
[16:20:42.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:42.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:42.778]                     .init = FALSE)
[16:20:42.778]                 }
[16:20:42.778]             }
[16:20:42.778]         }
[16:20:42.778]     })
[16:20:42.778]     if (TRUE) {
[16:20:42.778]         base::sink(type = "output", split = FALSE)
[16:20:42.778]         if (TRUE) {
[16:20:42.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:42.778]         }
[16:20:42.778]         else {
[16:20:42.778]             ...future.result["stdout"] <- base::list(NULL)
[16:20:42.778]         }
[16:20:42.778]         base::close(...future.stdout)
[16:20:42.778]         ...future.stdout <- NULL
[16:20:42.778]     }
[16:20:42.778]     ...future.result$conditions <- ...future.conditions
[16:20:42.778]     ...future.result$finished <- base::Sys.time()
[16:20:42.778]     ...future.result
[16:20:42.778] }
[16:20:42.781] MultisessionFuture started
[16:20:42.782] - Launch lazy future ... done
[16:20:42.782] run() for ‘MultisessionFuture’ ... done
[16:20:42.782] getGlobalsAndPackages() ...
[16:20:42.782] Searching for globals...
[16:20:42.783] 
[16:20:42.783] Searching for globals ... DONE
[16:20:42.783] - globals: [0] <none>
[16:20:42.783] getGlobalsAndPackages() ... DONE
[16:20:42.784] run() for ‘Future’ ...
[16:20:42.784] - state: ‘created’
[16:20:42.784] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:42.799] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:42.799] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:42.799]   - Field: ‘node’
[16:20:42.799]   - Field: ‘label’
[16:20:42.800]   - Field: ‘local’
[16:20:42.800]   - Field: ‘owner’
[16:20:42.800]   - Field: ‘envir’
[16:20:42.800]   - Field: ‘workers’
[16:20:42.800]   - Field: ‘packages’
[16:20:42.800]   - Field: ‘gc’
[16:20:42.800]   - Field: ‘conditions’
[16:20:42.800]   - Field: ‘persistent’
[16:20:42.800]   - Field: ‘expr’
[16:20:42.801]   - Field: ‘uuid’
[16:20:42.801]   - Field: ‘seed’
[16:20:42.801]   - Field: ‘version’
[16:20:42.801]   - Field: ‘result’
[16:20:42.801]   - Field: ‘asynchronous’
[16:20:42.801]   - Field: ‘calls’
[16:20:42.801]   - Field: ‘globals’
[16:20:42.801]   - Field: ‘stdout’
[16:20:42.801]   - Field: ‘earlySignal’
[16:20:42.802]   - Field: ‘lazy’
[16:20:42.802]   - Field: ‘state’
[16:20:42.802] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:42.802] - Launch lazy future ...
[16:20:42.802] Packages needed by the future expression (n = 0): <none>
[16:20:42.802] Packages needed by future strategies (n = 0): <none>
[16:20:42.803] {
[16:20:42.803]     {
[16:20:42.803]         {
[16:20:42.803]             ...future.startTime <- base::Sys.time()
[16:20:42.803]             {
[16:20:42.803]                 {
[16:20:42.803]                   {
[16:20:42.803]                     {
[16:20:42.803]                       base::local({
[16:20:42.803]                         has_future <- base::requireNamespace("future", 
[16:20:42.803]                           quietly = TRUE)
[16:20:42.803]                         if (has_future) {
[16:20:42.803]                           ns <- base::getNamespace("future")
[16:20:42.803]                           version <- ns[[".package"]][["version"]]
[16:20:42.803]                           if (is.null(version)) 
[16:20:42.803]                             version <- utils::packageVersion("future")
[16:20:42.803]                         }
[16:20:42.803]                         else {
[16:20:42.803]                           version <- NULL
[16:20:42.803]                         }
[16:20:42.803]                         if (!has_future || version < "1.8.0") {
[16:20:42.803]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:42.803]                             "", base::R.version$version.string), 
[16:20:42.803]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:42.803]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:42.803]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:42.803]                               "release", "version")], collapse = " "), 
[16:20:42.803]                             hostname = base::Sys.info()[["nodename"]])
[16:20:42.803]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:42.803]                             info)
[16:20:42.803]                           info <- base::paste(info, collapse = "; ")
[16:20:42.803]                           if (!has_future) {
[16:20:42.803]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:42.803]                               info)
[16:20:42.803]                           }
[16:20:42.803]                           else {
[16:20:42.803]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:42.803]                               info, version)
[16:20:42.803]                           }
[16:20:42.803]                           base::stop(msg)
[16:20:42.803]                         }
[16:20:42.803]                       })
[16:20:42.803]                     }
[16:20:42.803]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:42.803]                     base::options(mc.cores = 1L)
[16:20:42.803]                   }
[16:20:42.803]                   ...future.strategy.old <- future::plan("list")
[16:20:42.803]                   options(future.plan = NULL)
[16:20:42.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:42.803]                 }
[16:20:42.803]                 ...future.workdir <- getwd()
[16:20:42.803]             }
[16:20:42.803]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:42.803]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:42.803]         }
[16:20:42.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:42.803]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:42.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:42.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:42.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:42.803]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:42.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:42.803]             base::names(...future.oldOptions))
[16:20:42.803]     }
[16:20:42.803]     if (FALSE) {
[16:20:42.803]     }
[16:20:42.803]     else {
[16:20:42.803]         if (TRUE) {
[16:20:42.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:42.803]                 open = "w")
[16:20:42.803]         }
[16:20:42.803]         else {
[16:20:42.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:42.803]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:42.803]         }
[16:20:42.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:42.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:42.803]             base::sink(type = "output", split = FALSE)
[16:20:42.803]             base::close(...future.stdout)
[16:20:42.803]         }, add = TRUE)
[16:20:42.803]     }
[16:20:42.803]     ...future.frame <- base::sys.nframe()
[16:20:42.803]     ...future.conditions <- base::list()
[16:20:42.803]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:42.803]     if (FALSE) {
[16:20:42.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:42.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:42.803]     }
[16:20:42.803]     ...future.result <- base::tryCatch({
[16:20:42.803]         base::withCallingHandlers({
[16:20:42.803]             ...future.value <- base::withVisible(base::local({
[16:20:42.803]                 ...future.makeSendCondition <- base::local({
[16:20:42.803]                   sendCondition <- NULL
[16:20:42.803]                   function(frame = 1L) {
[16:20:42.803]                     if (is.function(sendCondition)) 
[16:20:42.803]                       return(sendCondition)
[16:20:42.803]                     ns <- getNamespace("parallel")
[16:20:42.803]                     if (exists("sendData", mode = "function", 
[16:20:42.803]                       envir = ns)) {
[16:20:42.803]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:42.803]                         envir = ns)
[16:20:42.803]                       envir <- sys.frame(frame)
[16:20:42.803]                       master <- NULL
[16:20:42.803]                       while (!identical(envir, .GlobalEnv) && 
[16:20:42.803]                         !identical(envir, emptyenv())) {
[16:20:42.803]                         if (exists("master", mode = "list", envir = envir, 
[16:20:42.803]                           inherits = FALSE)) {
[16:20:42.803]                           master <- get("master", mode = "list", 
[16:20:42.803]                             envir = envir, inherits = FALSE)
[16:20:42.803]                           if (inherits(master, c("SOCKnode", 
[16:20:42.803]                             "SOCK0node"))) {
[16:20:42.803]                             sendCondition <<- function(cond) {
[16:20:42.803]                               data <- list(type = "VALUE", value = cond, 
[16:20:42.803]                                 success = TRUE)
[16:20:42.803]                               parallel_sendData(master, data)
[16:20:42.803]                             }
[16:20:42.803]                             return(sendCondition)
[16:20:42.803]                           }
[16:20:42.803]                         }
[16:20:42.803]                         frame <- frame + 1L
[16:20:42.803]                         envir <- sys.frame(frame)
[16:20:42.803]                       }
[16:20:42.803]                     }
[16:20:42.803]                     sendCondition <<- function(cond) NULL
[16:20:42.803]                   }
[16:20:42.803]                 })
[16:20:42.803]                 withCallingHandlers({
[16:20:42.803]                   NULL
[16:20:42.803]                 }, immediateCondition = function(cond) {
[16:20:42.803]                   sendCondition <- ...future.makeSendCondition()
[16:20:42.803]                   sendCondition(cond)
[16:20:42.803]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.803]                   {
[16:20:42.803]                     inherits <- base::inherits
[16:20:42.803]                     invokeRestart <- base::invokeRestart
[16:20:42.803]                     is.null <- base::is.null
[16:20:42.803]                     muffled <- FALSE
[16:20:42.803]                     if (inherits(cond, "message")) {
[16:20:42.803]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:42.803]                       if (muffled) 
[16:20:42.803]                         invokeRestart("muffleMessage")
[16:20:42.803]                     }
[16:20:42.803]                     else if (inherits(cond, "warning")) {
[16:20:42.803]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:42.803]                       if (muffled) 
[16:20:42.803]                         invokeRestart("muffleWarning")
[16:20:42.803]                     }
[16:20:42.803]                     else if (inherits(cond, "condition")) {
[16:20:42.803]                       if (!is.null(pattern)) {
[16:20:42.803]                         computeRestarts <- base::computeRestarts
[16:20:42.803]                         grepl <- base::grepl
[16:20:42.803]                         restarts <- computeRestarts(cond)
[16:20:42.803]                         for (restart in restarts) {
[16:20:42.803]                           name <- restart$name
[16:20:42.803]                           if (is.null(name)) 
[16:20:42.803]                             next
[16:20:42.803]                           if (!grepl(pattern, name)) 
[16:20:42.803]                             next
[16:20:42.803]                           invokeRestart(restart)
[16:20:42.803]                           muffled <- TRUE
[16:20:42.803]                           break
[16:20:42.803]                         }
[16:20:42.803]                       }
[16:20:42.803]                     }
[16:20:42.803]                     invisible(muffled)
[16:20:42.803]                   }
[16:20:42.803]                   muffleCondition(cond)
[16:20:42.803]                 })
[16:20:42.803]             }))
[16:20:42.803]             future::FutureResult(value = ...future.value$value, 
[16:20:42.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.803]                   ...future.rng), globalenv = if (FALSE) 
[16:20:42.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:42.803]                     ...future.globalenv.names))
[16:20:42.803]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:42.803]         }, condition = base::local({
[16:20:42.803]             c <- base::c
[16:20:42.803]             inherits <- base::inherits
[16:20:42.803]             invokeRestart <- base::invokeRestart
[16:20:42.803]             length <- base::length
[16:20:42.803]             list <- base::list
[16:20:42.803]             seq.int <- base::seq.int
[16:20:42.803]             signalCondition <- base::signalCondition
[16:20:42.803]             sys.calls <- base::sys.calls
[16:20:42.803]             `[[` <- base::`[[`
[16:20:42.803]             `+` <- base::`+`
[16:20:42.803]             `<<-` <- base::`<<-`
[16:20:42.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:42.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:42.803]                   3L)]
[16:20:42.803]             }
[16:20:42.803]             function(cond) {
[16:20:42.803]                 is_error <- inherits(cond, "error")
[16:20:42.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:42.803]                   NULL)
[16:20:42.803]                 if (is_error) {
[16:20:42.803]                   sessionInformation <- function() {
[16:20:42.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:42.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:42.803]                       search = base::search(), system = base::Sys.info())
[16:20:42.803]                   }
[16:20:42.803]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:42.803]                     cond$call), session = sessionInformation(), 
[16:20:42.803]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:42.803]                   signalCondition(cond)
[16:20:42.803]                 }
[16:20:42.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:42.803]                 "immediateCondition"))) {
[16:20:42.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:42.803]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:42.803]                   if (TRUE && !signal) {
[16:20:42.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.803]                     {
[16:20:42.803]                       inherits <- base::inherits
[16:20:42.803]                       invokeRestart <- base::invokeRestart
[16:20:42.803]                       is.null <- base::is.null
[16:20:42.803]                       muffled <- FALSE
[16:20:42.803]                       if (inherits(cond, "message")) {
[16:20:42.803]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.803]                         if (muffled) 
[16:20:42.803]                           invokeRestart("muffleMessage")
[16:20:42.803]                       }
[16:20:42.803]                       else if (inherits(cond, "warning")) {
[16:20:42.803]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.803]                         if (muffled) 
[16:20:42.803]                           invokeRestart("muffleWarning")
[16:20:42.803]                       }
[16:20:42.803]                       else if (inherits(cond, "condition")) {
[16:20:42.803]                         if (!is.null(pattern)) {
[16:20:42.803]                           computeRestarts <- base::computeRestarts
[16:20:42.803]                           grepl <- base::grepl
[16:20:42.803]                           restarts <- computeRestarts(cond)
[16:20:42.803]                           for (restart in restarts) {
[16:20:42.803]                             name <- restart$name
[16:20:42.803]                             if (is.null(name)) 
[16:20:42.803]                               next
[16:20:42.803]                             if (!grepl(pattern, name)) 
[16:20:42.803]                               next
[16:20:42.803]                             invokeRestart(restart)
[16:20:42.803]                             muffled <- TRUE
[16:20:42.803]                             break
[16:20:42.803]                           }
[16:20:42.803]                         }
[16:20:42.803]                       }
[16:20:42.803]                       invisible(muffled)
[16:20:42.803]                     }
[16:20:42.803]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.803]                   }
[16:20:42.803]                 }
[16:20:42.803]                 else {
[16:20:42.803]                   if (TRUE) {
[16:20:42.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.803]                     {
[16:20:42.803]                       inherits <- base::inherits
[16:20:42.803]                       invokeRestart <- base::invokeRestart
[16:20:42.803]                       is.null <- base::is.null
[16:20:42.803]                       muffled <- FALSE
[16:20:42.803]                       if (inherits(cond, "message")) {
[16:20:42.803]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.803]                         if (muffled) 
[16:20:42.803]                           invokeRestart("muffleMessage")
[16:20:42.803]                       }
[16:20:42.803]                       else if (inherits(cond, "warning")) {
[16:20:42.803]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.803]                         if (muffled) 
[16:20:42.803]                           invokeRestart("muffleWarning")
[16:20:42.803]                       }
[16:20:42.803]                       else if (inherits(cond, "condition")) {
[16:20:42.803]                         if (!is.null(pattern)) {
[16:20:42.803]                           computeRestarts <- base::computeRestarts
[16:20:42.803]                           grepl <- base::grepl
[16:20:42.803]                           restarts <- computeRestarts(cond)
[16:20:42.803]                           for (restart in restarts) {
[16:20:42.803]                             name <- restart$name
[16:20:42.803]                             if (is.null(name)) 
[16:20:42.803]                               next
[16:20:42.803]                             if (!grepl(pattern, name)) 
[16:20:42.803]                               next
[16:20:42.803]                             invokeRestart(restart)
[16:20:42.803]                             muffled <- TRUE
[16:20:42.803]                             break
[16:20:42.803]                           }
[16:20:42.803]                         }
[16:20:42.803]                       }
[16:20:42.803]                       invisible(muffled)
[16:20:42.803]                     }
[16:20:42.803]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.803]                   }
[16:20:42.803]                 }
[16:20:42.803]             }
[16:20:42.803]         }))
[16:20:42.803]     }, error = function(ex) {
[16:20:42.803]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:42.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.803]                 ...future.rng), started = ...future.startTime, 
[16:20:42.803]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:42.803]             version = "1.8"), class = "FutureResult")
[16:20:42.803]     }, finally = {
[16:20:42.803]         if (!identical(...future.workdir, getwd())) 
[16:20:42.803]             setwd(...future.workdir)
[16:20:42.803]         {
[16:20:42.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:42.803]                 ...future.oldOptions$nwarnings <- NULL
[16:20:42.803]             }
[16:20:42.803]             base::options(...future.oldOptions)
[16:20:42.803]             if (.Platform$OS.type == "windows") {
[16:20:42.803]                 old_names <- names(...future.oldEnvVars)
[16:20:42.803]                 envs <- base::Sys.getenv()
[16:20:42.803]                 names <- names(envs)
[16:20:42.803]                 common <- intersect(names, old_names)
[16:20:42.803]                 added <- setdiff(names, old_names)
[16:20:42.803]                 removed <- setdiff(old_names, names)
[16:20:42.803]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:42.803]                   envs[common]]
[16:20:42.803]                 NAMES <- toupper(changed)
[16:20:42.803]                 args <- list()
[16:20:42.803]                 for (kk in seq_along(NAMES)) {
[16:20:42.803]                   name <- changed[[kk]]
[16:20:42.803]                   NAME <- NAMES[[kk]]
[16:20:42.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.803]                     next
[16:20:42.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.803]                 }
[16:20:42.803]                 NAMES <- toupper(added)
[16:20:42.803]                 for (kk in seq_along(NAMES)) {
[16:20:42.803]                   name <- added[[kk]]
[16:20:42.803]                   NAME <- NAMES[[kk]]
[16:20:42.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.803]                     next
[16:20:42.803]                   args[[name]] <- ""
[16:20:42.803]                 }
[16:20:42.803]                 NAMES <- toupper(removed)
[16:20:42.803]                 for (kk in seq_along(NAMES)) {
[16:20:42.803]                   name <- removed[[kk]]
[16:20:42.803]                   NAME <- NAMES[[kk]]
[16:20:42.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.803]                     next
[16:20:42.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.803]                 }
[16:20:42.803]                 if (length(args) > 0) 
[16:20:42.803]                   base::do.call(base::Sys.setenv, args = args)
[16:20:42.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:42.803]             }
[16:20:42.803]             else {
[16:20:42.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:42.803]             }
[16:20:42.803]             {
[16:20:42.803]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:42.803]                   0L) {
[16:20:42.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:42.803]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:42.803]                   base::options(opts)
[16:20:42.803]                 }
[16:20:42.803]                 {
[16:20:42.803]                   {
[16:20:42.803]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:42.803]                     NULL
[16:20:42.803]                   }
[16:20:42.803]                   options(future.plan = NULL)
[16:20:42.803]                   if (is.na(NA_character_)) 
[16:20:42.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:42.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:42.803]                     .init = FALSE)
[16:20:42.803]                 }
[16:20:42.803]             }
[16:20:42.803]         }
[16:20:42.803]     })
[16:20:42.803]     if (TRUE) {
[16:20:42.803]         base::sink(type = "output", split = FALSE)
[16:20:42.803]         if (TRUE) {
[16:20:42.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:42.803]         }
[16:20:42.803]         else {
[16:20:42.803]             ...future.result["stdout"] <- base::list(NULL)
[16:20:42.803]         }
[16:20:42.803]         base::close(...future.stdout)
[16:20:42.803]         ...future.stdout <- NULL
[16:20:42.803]     }
[16:20:42.803]     ...future.result$conditions <- ...future.conditions
[16:20:42.803]     ...future.result$finished <- base::Sys.time()
[16:20:42.803]     ...future.result
[16:20:42.803] }
[16:20:42.856] MultisessionFuture started
[16:20:42.856] - Launch lazy future ... done
[16:20:42.856] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0d21cac0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0d67d080> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0d21cac0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0d67d080> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:20:42.862] receiveMessageFromWorker() for ClusterFuture ...
[16:20:42.862] - Validating connection of MultisessionFuture
[16:20:42.862] - received message: FutureResult
[16:20:42.863] - Received FutureResult
[16:20:42.863] - Erased future from FutureRegistry
[16:20:42.863] result() for ClusterFuture ...
[16:20:42.863] - result already collected: FutureResult
[16:20:42.863] result() for ClusterFuture ... done
[16:20:42.863] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:42.875] resolve() on list ...
[16:20:42.875]  recursive: 0
[16:20:42.875]  length: 6
[16:20:42.875]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:42.875] signalConditionsASAP(numeric, pos=1) ...
[16:20:42.875] - nx: 6
[16:20:42.875] - relay: TRUE
[16:20:42.875] - stdout: TRUE
[16:20:42.875] - signal: TRUE
[16:20:42.876] - resignal: FALSE
[16:20:42.876] - force: TRUE
[16:20:42.876] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.876] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.876]  - until=2
[16:20:42.876]  - relaying element #2
[16:20:42.876] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.876] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.877] signalConditionsASAP(NULL, pos=1) ... done
[16:20:42.877]  length: 5 (resolved future 1)
[16:20:42.877] Future #2
[16:20:42.877] result() for ClusterFuture ...
[16:20:42.877] - result already collected: FutureResult
[16:20:42.877] result() for ClusterFuture ... done
[16:20:42.877] result() for ClusterFuture ...
[16:20:42.877] - result already collected: FutureResult
[16:20:42.877] result() for ClusterFuture ... done
[16:20:42.878] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:42.878] - nx: 6
[16:20:42.878] - relay: TRUE
[16:20:42.878] - stdout: TRUE
[16:20:42.878] - signal: TRUE
[16:20:42.878] - resignal: FALSE
[16:20:42.878] - force: TRUE
[16:20:42.878] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.878] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.879]  - until=2
[16:20:42.879]  - relaying element #2
[16:20:42.879] result() for ClusterFuture ...
[16:20:42.879] - result already collected: FutureResult
[16:20:42.879] result() for ClusterFuture ... done
[16:20:42.879] result() for ClusterFuture ...
[16:20:42.879] - result already collected: FutureResult
[16:20:42.879] result() for ClusterFuture ... done
[16:20:42.879] result() for ClusterFuture ...
[16:20:42.880] - result already collected: FutureResult
[16:20:42.880] result() for ClusterFuture ... done
[16:20:42.880] result() for ClusterFuture ...
[16:20:42.880] - result already collected: FutureResult
[16:20:42.880] result() for ClusterFuture ... done
[16:20:42.880] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.880] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.880] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:42.880]  length: 4 (resolved future 2)
[16:20:42.890] receiveMessageFromWorker() for ClusterFuture ...
[16:20:42.890] - Validating connection of MultisessionFuture
[16:20:42.890] - received message: FutureResult
[16:20:42.891] - Received FutureResult
[16:20:42.891] - Erased future from FutureRegistry
[16:20:42.891] result() for ClusterFuture ...
[16:20:42.891] - result already collected: FutureResult
[16:20:42.891] result() for ClusterFuture ... done
[16:20:42.891] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:42.891] Future #3
[16:20:42.891] result() for ClusterFuture ...
[16:20:42.892] - result already collected: FutureResult
[16:20:42.892] result() for ClusterFuture ... done
[16:20:42.892] result() for ClusterFuture ...
[16:20:42.892] - result already collected: FutureResult
[16:20:42.892] result() for ClusterFuture ... done
[16:20:42.892] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:42.892] - nx: 6
[16:20:42.892] - relay: TRUE
[16:20:42.892] - stdout: TRUE
[16:20:42.893] - signal: TRUE
[16:20:42.893] - resignal: FALSE
[16:20:42.893] - force: TRUE
[16:20:42.893] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.893] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.893]  - until=3
[16:20:42.893]  - relaying element #3
[16:20:42.893] result() for ClusterFuture ...
[16:20:42.893] - result already collected: FutureResult
[16:20:42.894] result() for ClusterFuture ... done
[16:20:42.894] result() for ClusterFuture ...
[16:20:42.894] - result already collected: FutureResult
[16:20:42.894] result() for ClusterFuture ... done
[16:20:42.894] result() for ClusterFuture ...
[16:20:42.894] - result already collected: FutureResult
[16:20:42.894] result() for ClusterFuture ... done
[16:20:42.894] result() for ClusterFuture ...
[16:20:42.894] - result already collected: FutureResult
[16:20:42.895] result() for ClusterFuture ... done
[16:20:42.895] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.895] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.895] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:42.895]  length: 3 (resolved future 3)
[16:20:42.895] signalConditionsASAP(NULL, pos=4) ...
[16:20:42.895] - nx: 6
[16:20:42.895] - relay: TRUE
[16:20:42.895] - stdout: TRUE
[16:20:42.896] - signal: TRUE
[16:20:42.896] - resignal: FALSE
[16:20:42.896] - force: TRUE
[16:20:42.896] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.896] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.896]  - until=5
[16:20:42.896]  - relaying element #5
[16:20:42.896] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:42.897] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.897] signalConditionsASAP(NULL, pos=4) ... done
[16:20:42.897]  length: 2 (resolved future 4)
[16:20:42.897] signalConditionsASAP(NULL, pos=5) ...
[16:20:42.897] - nx: 6
[16:20:42.897] - relay: TRUE
[16:20:42.897] - stdout: TRUE
[16:20:42.897] - signal: TRUE
[16:20:42.897] - resignal: FALSE
[16:20:42.897] - force: TRUE
[16:20:42.898] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:42.898] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.898]  - until=6
[16:20:42.898]  - relaying element #6
[16:20:42.898] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:42.898] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.898] signalConditionsASAP(NULL, pos=5) ... done
[16:20:42.898]  length: 1 (resolved future 5)
[16:20:42.898] signalConditionsASAP(numeric, pos=6) ...
[16:20:42.899] - nx: 6
[16:20:42.899] - relay: TRUE
[16:20:42.899] - stdout: TRUE
[16:20:42.899] - signal: TRUE
[16:20:42.899] - resignal: FALSE
[16:20:42.899] - force: TRUE
[16:20:42.899] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:42.899] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.899]  - until=6
[16:20:42.900] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.900] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.900] signalConditionsASAP(numeric, pos=6) ... done
[16:20:42.900]  length: 0 (resolved future 6)
[16:20:42.900] Relaying remaining futures
[16:20:42.900] signalConditionsASAP(NULL, pos=0) ...
[16:20:42.900] - nx: 6
[16:20:42.900] - relay: TRUE
[16:20:42.900] - stdout: TRUE
[16:20:42.901] - signal: TRUE
[16:20:42.901] - resignal: FALSE
[16:20:42.901] - force: TRUE
[16:20:42.901] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.901] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:42.903] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.903] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.904] signalConditionsASAP(NULL, pos=0) ... done
[16:20:42.904] resolve() on list ... DONE
[16:20:42.904] result() for ClusterFuture ...
[16:20:42.904] - result already collected: FutureResult
[16:20:42.904] result() for ClusterFuture ... done
[16:20:42.904] result() for ClusterFuture ...
[16:20:42.904] - result already collected: FutureResult
[16:20:42.904] result() for ClusterFuture ... done
[16:20:42.904] result() for ClusterFuture ...
[16:20:42.904] - result already collected: FutureResult
[16:20:42.904] result() for ClusterFuture ... done
[16:20:42.905] result() for ClusterFuture ...
[16:20:42.905] - result already collected: FutureResult
[16:20:42.905] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[16:20:42.907] getGlobalsAndPackages() ...
[16:20:42.907] Searching for globals...
[16:20:42.907] 
[16:20:42.907] Searching for globals ... DONE
[16:20:42.907] - globals: [0] <none>
[16:20:42.907] getGlobalsAndPackages() ... DONE
[16:20:42.908] run() for ‘Future’ ...
[16:20:42.908] - state: ‘created’
[16:20:42.908] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:42.922] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:42.922] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:42.922]   - Field: ‘node’
[16:20:42.922]   - Field: ‘label’
[16:20:42.922]   - Field: ‘local’
[16:20:42.923]   - Field: ‘owner’
[16:20:42.923]   - Field: ‘envir’
[16:20:42.923]   - Field: ‘workers’
[16:20:42.923]   - Field: ‘packages’
[16:20:42.923]   - Field: ‘gc’
[16:20:42.923]   - Field: ‘conditions’
[16:20:42.923]   - Field: ‘persistent’
[16:20:42.923]   - Field: ‘expr’
[16:20:42.923]   - Field: ‘uuid’
[16:20:42.923]   - Field: ‘seed’
[16:20:42.923]   - Field: ‘version’
[16:20:42.924]   - Field: ‘result’
[16:20:42.924]   - Field: ‘asynchronous’
[16:20:42.924]   - Field: ‘calls’
[16:20:42.924]   - Field: ‘globals’
[16:20:42.924]   - Field: ‘stdout’
[16:20:42.924]   - Field: ‘earlySignal’
[16:20:42.924]   - Field: ‘lazy’
[16:20:42.924]   - Field: ‘state’
[16:20:42.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:42.924] - Launch lazy future ...
[16:20:42.925] Packages needed by the future expression (n = 0): <none>
[16:20:42.925] Packages needed by future strategies (n = 0): <none>
[16:20:42.925] {
[16:20:42.925]     {
[16:20:42.925]         {
[16:20:42.925]             ...future.startTime <- base::Sys.time()
[16:20:42.925]             {
[16:20:42.925]                 {
[16:20:42.925]                   {
[16:20:42.925]                     {
[16:20:42.925]                       base::local({
[16:20:42.925]                         has_future <- base::requireNamespace("future", 
[16:20:42.925]                           quietly = TRUE)
[16:20:42.925]                         if (has_future) {
[16:20:42.925]                           ns <- base::getNamespace("future")
[16:20:42.925]                           version <- ns[[".package"]][["version"]]
[16:20:42.925]                           if (is.null(version)) 
[16:20:42.925]                             version <- utils::packageVersion("future")
[16:20:42.925]                         }
[16:20:42.925]                         else {
[16:20:42.925]                           version <- NULL
[16:20:42.925]                         }
[16:20:42.925]                         if (!has_future || version < "1.8.0") {
[16:20:42.925]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:42.925]                             "", base::R.version$version.string), 
[16:20:42.925]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:42.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:42.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:42.925]                               "release", "version")], collapse = " "), 
[16:20:42.925]                             hostname = base::Sys.info()[["nodename"]])
[16:20:42.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:42.925]                             info)
[16:20:42.925]                           info <- base::paste(info, collapse = "; ")
[16:20:42.925]                           if (!has_future) {
[16:20:42.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:42.925]                               info)
[16:20:42.925]                           }
[16:20:42.925]                           else {
[16:20:42.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:42.925]                               info, version)
[16:20:42.925]                           }
[16:20:42.925]                           base::stop(msg)
[16:20:42.925]                         }
[16:20:42.925]                       })
[16:20:42.925]                     }
[16:20:42.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:42.925]                     base::options(mc.cores = 1L)
[16:20:42.925]                   }
[16:20:42.925]                   ...future.strategy.old <- future::plan("list")
[16:20:42.925]                   options(future.plan = NULL)
[16:20:42.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:42.925]                 }
[16:20:42.925]                 ...future.workdir <- getwd()
[16:20:42.925]             }
[16:20:42.925]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:42.925]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:42.925]         }
[16:20:42.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:42.925]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:42.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:42.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:42.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:42.925]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:42.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:42.925]             base::names(...future.oldOptions))
[16:20:42.925]     }
[16:20:42.925]     if (FALSE) {
[16:20:42.925]     }
[16:20:42.925]     else {
[16:20:42.925]         if (TRUE) {
[16:20:42.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:42.925]                 open = "w")
[16:20:42.925]         }
[16:20:42.925]         else {
[16:20:42.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:42.925]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:42.925]         }
[16:20:42.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:42.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:42.925]             base::sink(type = "output", split = FALSE)
[16:20:42.925]             base::close(...future.stdout)
[16:20:42.925]         }, add = TRUE)
[16:20:42.925]     }
[16:20:42.925]     ...future.frame <- base::sys.nframe()
[16:20:42.925]     ...future.conditions <- base::list()
[16:20:42.925]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:42.925]     if (FALSE) {
[16:20:42.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:42.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:42.925]     }
[16:20:42.925]     ...future.result <- base::tryCatch({
[16:20:42.925]         base::withCallingHandlers({
[16:20:42.925]             ...future.value <- base::withVisible(base::local({
[16:20:42.925]                 ...future.makeSendCondition <- base::local({
[16:20:42.925]                   sendCondition <- NULL
[16:20:42.925]                   function(frame = 1L) {
[16:20:42.925]                     if (is.function(sendCondition)) 
[16:20:42.925]                       return(sendCondition)
[16:20:42.925]                     ns <- getNamespace("parallel")
[16:20:42.925]                     if (exists("sendData", mode = "function", 
[16:20:42.925]                       envir = ns)) {
[16:20:42.925]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:42.925]                         envir = ns)
[16:20:42.925]                       envir <- sys.frame(frame)
[16:20:42.925]                       master <- NULL
[16:20:42.925]                       while (!identical(envir, .GlobalEnv) && 
[16:20:42.925]                         !identical(envir, emptyenv())) {
[16:20:42.925]                         if (exists("master", mode = "list", envir = envir, 
[16:20:42.925]                           inherits = FALSE)) {
[16:20:42.925]                           master <- get("master", mode = "list", 
[16:20:42.925]                             envir = envir, inherits = FALSE)
[16:20:42.925]                           if (inherits(master, c("SOCKnode", 
[16:20:42.925]                             "SOCK0node"))) {
[16:20:42.925]                             sendCondition <<- function(cond) {
[16:20:42.925]                               data <- list(type = "VALUE", value = cond, 
[16:20:42.925]                                 success = TRUE)
[16:20:42.925]                               parallel_sendData(master, data)
[16:20:42.925]                             }
[16:20:42.925]                             return(sendCondition)
[16:20:42.925]                           }
[16:20:42.925]                         }
[16:20:42.925]                         frame <- frame + 1L
[16:20:42.925]                         envir <- sys.frame(frame)
[16:20:42.925]                       }
[16:20:42.925]                     }
[16:20:42.925]                     sendCondition <<- function(cond) NULL
[16:20:42.925]                   }
[16:20:42.925]                 })
[16:20:42.925]                 withCallingHandlers({
[16:20:42.925]                   2
[16:20:42.925]                 }, immediateCondition = function(cond) {
[16:20:42.925]                   sendCondition <- ...future.makeSendCondition()
[16:20:42.925]                   sendCondition(cond)
[16:20:42.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.925]                   {
[16:20:42.925]                     inherits <- base::inherits
[16:20:42.925]                     invokeRestart <- base::invokeRestart
[16:20:42.925]                     is.null <- base::is.null
[16:20:42.925]                     muffled <- FALSE
[16:20:42.925]                     if (inherits(cond, "message")) {
[16:20:42.925]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:42.925]                       if (muffled) 
[16:20:42.925]                         invokeRestart("muffleMessage")
[16:20:42.925]                     }
[16:20:42.925]                     else if (inherits(cond, "warning")) {
[16:20:42.925]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:42.925]                       if (muffled) 
[16:20:42.925]                         invokeRestart("muffleWarning")
[16:20:42.925]                     }
[16:20:42.925]                     else if (inherits(cond, "condition")) {
[16:20:42.925]                       if (!is.null(pattern)) {
[16:20:42.925]                         computeRestarts <- base::computeRestarts
[16:20:42.925]                         grepl <- base::grepl
[16:20:42.925]                         restarts <- computeRestarts(cond)
[16:20:42.925]                         for (restart in restarts) {
[16:20:42.925]                           name <- restart$name
[16:20:42.925]                           if (is.null(name)) 
[16:20:42.925]                             next
[16:20:42.925]                           if (!grepl(pattern, name)) 
[16:20:42.925]                             next
[16:20:42.925]                           invokeRestart(restart)
[16:20:42.925]                           muffled <- TRUE
[16:20:42.925]                           break
[16:20:42.925]                         }
[16:20:42.925]                       }
[16:20:42.925]                     }
[16:20:42.925]                     invisible(muffled)
[16:20:42.925]                   }
[16:20:42.925]                   muffleCondition(cond)
[16:20:42.925]                 })
[16:20:42.925]             }))
[16:20:42.925]             future::FutureResult(value = ...future.value$value, 
[16:20:42.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.925]                   ...future.rng), globalenv = if (FALSE) 
[16:20:42.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:42.925]                     ...future.globalenv.names))
[16:20:42.925]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:42.925]         }, condition = base::local({
[16:20:42.925]             c <- base::c
[16:20:42.925]             inherits <- base::inherits
[16:20:42.925]             invokeRestart <- base::invokeRestart
[16:20:42.925]             length <- base::length
[16:20:42.925]             list <- base::list
[16:20:42.925]             seq.int <- base::seq.int
[16:20:42.925]             signalCondition <- base::signalCondition
[16:20:42.925]             sys.calls <- base::sys.calls
[16:20:42.925]             `[[` <- base::`[[`
[16:20:42.925]             `+` <- base::`+`
[16:20:42.925]             `<<-` <- base::`<<-`
[16:20:42.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:42.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:42.925]                   3L)]
[16:20:42.925]             }
[16:20:42.925]             function(cond) {
[16:20:42.925]                 is_error <- inherits(cond, "error")
[16:20:42.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:42.925]                   NULL)
[16:20:42.925]                 if (is_error) {
[16:20:42.925]                   sessionInformation <- function() {
[16:20:42.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:42.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:42.925]                       search = base::search(), system = base::Sys.info())
[16:20:42.925]                   }
[16:20:42.925]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:42.925]                     cond$call), session = sessionInformation(), 
[16:20:42.925]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:42.925]                   signalCondition(cond)
[16:20:42.925]                 }
[16:20:42.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:42.925]                 "immediateCondition"))) {
[16:20:42.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:42.925]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:42.925]                   if (TRUE && !signal) {
[16:20:42.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.925]                     {
[16:20:42.925]                       inherits <- base::inherits
[16:20:42.925]                       invokeRestart <- base::invokeRestart
[16:20:42.925]                       is.null <- base::is.null
[16:20:42.925]                       muffled <- FALSE
[16:20:42.925]                       if (inherits(cond, "message")) {
[16:20:42.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.925]                         if (muffled) 
[16:20:42.925]                           invokeRestart("muffleMessage")
[16:20:42.925]                       }
[16:20:42.925]                       else if (inherits(cond, "warning")) {
[16:20:42.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.925]                         if (muffled) 
[16:20:42.925]                           invokeRestart("muffleWarning")
[16:20:42.925]                       }
[16:20:42.925]                       else if (inherits(cond, "condition")) {
[16:20:42.925]                         if (!is.null(pattern)) {
[16:20:42.925]                           computeRestarts <- base::computeRestarts
[16:20:42.925]                           grepl <- base::grepl
[16:20:42.925]                           restarts <- computeRestarts(cond)
[16:20:42.925]                           for (restart in restarts) {
[16:20:42.925]                             name <- restart$name
[16:20:42.925]                             if (is.null(name)) 
[16:20:42.925]                               next
[16:20:42.925]                             if (!grepl(pattern, name)) 
[16:20:42.925]                               next
[16:20:42.925]                             invokeRestart(restart)
[16:20:42.925]                             muffled <- TRUE
[16:20:42.925]                             break
[16:20:42.925]                           }
[16:20:42.925]                         }
[16:20:42.925]                       }
[16:20:42.925]                       invisible(muffled)
[16:20:42.925]                     }
[16:20:42.925]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.925]                   }
[16:20:42.925]                 }
[16:20:42.925]                 else {
[16:20:42.925]                   if (TRUE) {
[16:20:42.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.925]                     {
[16:20:42.925]                       inherits <- base::inherits
[16:20:42.925]                       invokeRestart <- base::invokeRestart
[16:20:42.925]                       is.null <- base::is.null
[16:20:42.925]                       muffled <- FALSE
[16:20:42.925]                       if (inherits(cond, "message")) {
[16:20:42.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.925]                         if (muffled) 
[16:20:42.925]                           invokeRestart("muffleMessage")
[16:20:42.925]                       }
[16:20:42.925]                       else if (inherits(cond, "warning")) {
[16:20:42.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.925]                         if (muffled) 
[16:20:42.925]                           invokeRestart("muffleWarning")
[16:20:42.925]                       }
[16:20:42.925]                       else if (inherits(cond, "condition")) {
[16:20:42.925]                         if (!is.null(pattern)) {
[16:20:42.925]                           computeRestarts <- base::computeRestarts
[16:20:42.925]                           grepl <- base::grepl
[16:20:42.925]                           restarts <- computeRestarts(cond)
[16:20:42.925]                           for (restart in restarts) {
[16:20:42.925]                             name <- restart$name
[16:20:42.925]                             if (is.null(name)) 
[16:20:42.925]                               next
[16:20:42.925]                             if (!grepl(pattern, name)) 
[16:20:42.925]                               next
[16:20:42.925]                             invokeRestart(restart)
[16:20:42.925]                             muffled <- TRUE
[16:20:42.925]                             break
[16:20:42.925]                           }
[16:20:42.925]                         }
[16:20:42.925]                       }
[16:20:42.925]                       invisible(muffled)
[16:20:42.925]                     }
[16:20:42.925]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.925]                   }
[16:20:42.925]                 }
[16:20:42.925]             }
[16:20:42.925]         }))
[16:20:42.925]     }, error = function(ex) {
[16:20:42.925]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:42.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.925]                 ...future.rng), started = ...future.startTime, 
[16:20:42.925]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:42.925]             version = "1.8"), class = "FutureResult")
[16:20:42.925]     }, finally = {
[16:20:42.925]         if (!identical(...future.workdir, getwd())) 
[16:20:42.925]             setwd(...future.workdir)
[16:20:42.925]         {
[16:20:42.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:42.925]                 ...future.oldOptions$nwarnings <- NULL
[16:20:42.925]             }
[16:20:42.925]             base::options(...future.oldOptions)
[16:20:42.925]             if (.Platform$OS.type == "windows") {
[16:20:42.925]                 old_names <- names(...future.oldEnvVars)
[16:20:42.925]                 envs <- base::Sys.getenv()
[16:20:42.925]                 names <- names(envs)
[16:20:42.925]                 common <- intersect(names, old_names)
[16:20:42.925]                 added <- setdiff(names, old_names)
[16:20:42.925]                 removed <- setdiff(old_names, names)
[16:20:42.925]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:42.925]                   envs[common]]
[16:20:42.925]                 NAMES <- toupper(changed)
[16:20:42.925]                 args <- list()
[16:20:42.925]                 for (kk in seq_along(NAMES)) {
[16:20:42.925]                   name <- changed[[kk]]
[16:20:42.925]                   NAME <- NAMES[[kk]]
[16:20:42.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.925]                     next
[16:20:42.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.925]                 }
[16:20:42.925]                 NAMES <- toupper(added)
[16:20:42.925]                 for (kk in seq_along(NAMES)) {
[16:20:42.925]                   name <- added[[kk]]
[16:20:42.925]                   NAME <- NAMES[[kk]]
[16:20:42.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.925]                     next
[16:20:42.925]                   args[[name]] <- ""
[16:20:42.925]                 }
[16:20:42.925]                 NAMES <- toupper(removed)
[16:20:42.925]                 for (kk in seq_along(NAMES)) {
[16:20:42.925]                   name <- removed[[kk]]
[16:20:42.925]                   NAME <- NAMES[[kk]]
[16:20:42.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.925]                     next
[16:20:42.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.925]                 }
[16:20:42.925]                 if (length(args) > 0) 
[16:20:42.925]                   base::do.call(base::Sys.setenv, args = args)
[16:20:42.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:42.925]             }
[16:20:42.925]             else {
[16:20:42.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:42.925]             }
[16:20:42.925]             {
[16:20:42.925]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:42.925]                   0L) {
[16:20:42.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:42.925]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:42.925]                   base::options(opts)
[16:20:42.925]                 }
[16:20:42.925]                 {
[16:20:42.925]                   {
[16:20:42.925]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:42.925]                     NULL
[16:20:42.925]                   }
[16:20:42.925]                   options(future.plan = NULL)
[16:20:42.925]                   if (is.na(NA_character_)) 
[16:20:42.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:42.925]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:42.925]                     .init = FALSE)
[16:20:42.925]                 }
[16:20:42.925]             }
[16:20:42.925]         }
[16:20:42.925]     })
[16:20:42.925]     if (TRUE) {
[16:20:42.925]         base::sink(type = "output", split = FALSE)
[16:20:42.925]         if (TRUE) {
[16:20:42.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:42.925]         }
[16:20:42.925]         else {
[16:20:42.925]             ...future.result["stdout"] <- base::list(NULL)
[16:20:42.925]         }
[16:20:42.925]         base::close(...future.stdout)
[16:20:42.925]         ...future.stdout <- NULL
[16:20:42.925]     }
[16:20:42.925]     ...future.result$conditions <- ...future.conditions
[16:20:42.925]     ...future.result$finished <- base::Sys.time()
[16:20:42.925]     ...future.result
[16:20:42.925] }
[16:20:42.928] MultisessionFuture started
[16:20:42.928] - Launch lazy future ... done
[16:20:42.929] run() for ‘MultisessionFuture’ ... done
[16:20:42.929] getGlobalsAndPackages() ...
[16:20:42.929] Searching for globals...
[16:20:42.929] 
[16:20:42.930] Searching for globals ... DONE
[16:20:42.930] - globals: [0] <none>
[16:20:42.930] getGlobalsAndPackages() ... DONE
[16:20:42.930] run() for ‘Future’ ...
[16:20:42.930] - state: ‘created’
[16:20:42.931] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:42.944] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:42.945] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:42.945]   - Field: ‘node’
[16:20:42.945]   - Field: ‘label’
[16:20:42.945]   - Field: ‘local’
[16:20:42.945]   - Field: ‘owner’
[16:20:42.945]   - Field: ‘envir’
[16:20:42.945]   - Field: ‘workers’
[16:20:42.945]   - Field: ‘packages’
[16:20:42.945]   - Field: ‘gc’
[16:20:42.945]   - Field: ‘conditions’
[16:20:42.945]   - Field: ‘persistent’
[16:20:42.946]   - Field: ‘expr’
[16:20:42.946]   - Field: ‘uuid’
[16:20:42.946]   - Field: ‘seed’
[16:20:42.946]   - Field: ‘version’
[16:20:42.946]   - Field: ‘result’
[16:20:42.946]   - Field: ‘asynchronous’
[16:20:42.946]   - Field: ‘calls’
[16:20:42.946]   - Field: ‘globals’
[16:20:42.946]   - Field: ‘stdout’
[16:20:42.946]   - Field: ‘earlySignal’
[16:20:42.946]   - Field: ‘lazy’
[16:20:42.947]   - Field: ‘state’
[16:20:42.947] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:42.947] - Launch lazy future ...
[16:20:42.947] Packages needed by the future expression (n = 0): <none>
[16:20:42.947] Packages needed by future strategies (n = 0): <none>
[16:20:42.948] {
[16:20:42.948]     {
[16:20:42.948]         {
[16:20:42.948]             ...future.startTime <- base::Sys.time()
[16:20:42.948]             {
[16:20:42.948]                 {
[16:20:42.948]                   {
[16:20:42.948]                     {
[16:20:42.948]                       base::local({
[16:20:42.948]                         has_future <- base::requireNamespace("future", 
[16:20:42.948]                           quietly = TRUE)
[16:20:42.948]                         if (has_future) {
[16:20:42.948]                           ns <- base::getNamespace("future")
[16:20:42.948]                           version <- ns[[".package"]][["version"]]
[16:20:42.948]                           if (is.null(version)) 
[16:20:42.948]                             version <- utils::packageVersion("future")
[16:20:42.948]                         }
[16:20:42.948]                         else {
[16:20:42.948]                           version <- NULL
[16:20:42.948]                         }
[16:20:42.948]                         if (!has_future || version < "1.8.0") {
[16:20:42.948]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:42.948]                             "", base::R.version$version.string), 
[16:20:42.948]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:42.948]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:42.948]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:42.948]                               "release", "version")], collapse = " "), 
[16:20:42.948]                             hostname = base::Sys.info()[["nodename"]])
[16:20:42.948]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:42.948]                             info)
[16:20:42.948]                           info <- base::paste(info, collapse = "; ")
[16:20:42.948]                           if (!has_future) {
[16:20:42.948]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:42.948]                               info)
[16:20:42.948]                           }
[16:20:42.948]                           else {
[16:20:42.948]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:42.948]                               info, version)
[16:20:42.948]                           }
[16:20:42.948]                           base::stop(msg)
[16:20:42.948]                         }
[16:20:42.948]                       })
[16:20:42.948]                     }
[16:20:42.948]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:42.948]                     base::options(mc.cores = 1L)
[16:20:42.948]                   }
[16:20:42.948]                   ...future.strategy.old <- future::plan("list")
[16:20:42.948]                   options(future.plan = NULL)
[16:20:42.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:42.948]                 }
[16:20:42.948]                 ...future.workdir <- getwd()
[16:20:42.948]             }
[16:20:42.948]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:42.948]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:42.948]         }
[16:20:42.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:42.948]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:42.948]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:42.948]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:42.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:42.948]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:42.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:42.948]             base::names(...future.oldOptions))
[16:20:42.948]     }
[16:20:42.948]     if (FALSE) {
[16:20:42.948]     }
[16:20:42.948]     else {
[16:20:42.948]         if (TRUE) {
[16:20:42.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:42.948]                 open = "w")
[16:20:42.948]         }
[16:20:42.948]         else {
[16:20:42.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:42.948]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:42.948]         }
[16:20:42.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:42.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:42.948]             base::sink(type = "output", split = FALSE)
[16:20:42.948]             base::close(...future.stdout)
[16:20:42.948]         }, add = TRUE)
[16:20:42.948]     }
[16:20:42.948]     ...future.frame <- base::sys.nframe()
[16:20:42.948]     ...future.conditions <- base::list()
[16:20:42.948]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:42.948]     if (FALSE) {
[16:20:42.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:42.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:42.948]     }
[16:20:42.948]     ...future.result <- base::tryCatch({
[16:20:42.948]         base::withCallingHandlers({
[16:20:42.948]             ...future.value <- base::withVisible(base::local({
[16:20:42.948]                 ...future.makeSendCondition <- base::local({
[16:20:42.948]                   sendCondition <- NULL
[16:20:42.948]                   function(frame = 1L) {
[16:20:42.948]                     if (is.function(sendCondition)) 
[16:20:42.948]                       return(sendCondition)
[16:20:42.948]                     ns <- getNamespace("parallel")
[16:20:42.948]                     if (exists("sendData", mode = "function", 
[16:20:42.948]                       envir = ns)) {
[16:20:42.948]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:42.948]                         envir = ns)
[16:20:42.948]                       envir <- sys.frame(frame)
[16:20:42.948]                       master <- NULL
[16:20:42.948]                       while (!identical(envir, .GlobalEnv) && 
[16:20:42.948]                         !identical(envir, emptyenv())) {
[16:20:42.948]                         if (exists("master", mode = "list", envir = envir, 
[16:20:42.948]                           inherits = FALSE)) {
[16:20:42.948]                           master <- get("master", mode = "list", 
[16:20:42.948]                             envir = envir, inherits = FALSE)
[16:20:42.948]                           if (inherits(master, c("SOCKnode", 
[16:20:42.948]                             "SOCK0node"))) {
[16:20:42.948]                             sendCondition <<- function(cond) {
[16:20:42.948]                               data <- list(type = "VALUE", value = cond, 
[16:20:42.948]                                 success = TRUE)
[16:20:42.948]                               parallel_sendData(master, data)
[16:20:42.948]                             }
[16:20:42.948]                             return(sendCondition)
[16:20:42.948]                           }
[16:20:42.948]                         }
[16:20:42.948]                         frame <- frame + 1L
[16:20:42.948]                         envir <- sys.frame(frame)
[16:20:42.948]                       }
[16:20:42.948]                     }
[16:20:42.948]                     sendCondition <<- function(cond) NULL
[16:20:42.948]                   }
[16:20:42.948]                 })
[16:20:42.948]                 withCallingHandlers({
[16:20:42.948]                   NULL
[16:20:42.948]                 }, immediateCondition = function(cond) {
[16:20:42.948]                   sendCondition <- ...future.makeSendCondition()
[16:20:42.948]                   sendCondition(cond)
[16:20:42.948]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.948]                   {
[16:20:42.948]                     inherits <- base::inherits
[16:20:42.948]                     invokeRestart <- base::invokeRestart
[16:20:42.948]                     is.null <- base::is.null
[16:20:42.948]                     muffled <- FALSE
[16:20:42.948]                     if (inherits(cond, "message")) {
[16:20:42.948]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:42.948]                       if (muffled) 
[16:20:42.948]                         invokeRestart("muffleMessage")
[16:20:42.948]                     }
[16:20:42.948]                     else if (inherits(cond, "warning")) {
[16:20:42.948]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:42.948]                       if (muffled) 
[16:20:42.948]                         invokeRestart("muffleWarning")
[16:20:42.948]                     }
[16:20:42.948]                     else if (inherits(cond, "condition")) {
[16:20:42.948]                       if (!is.null(pattern)) {
[16:20:42.948]                         computeRestarts <- base::computeRestarts
[16:20:42.948]                         grepl <- base::grepl
[16:20:42.948]                         restarts <- computeRestarts(cond)
[16:20:42.948]                         for (restart in restarts) {
[16:20:42.948]                           name <- restart$name
[16:20:42.948]                           if (is.null(name)) 
[16:20:42.948]                             next
[16:20:42.948]                           if (!grepl(pattern, name)) 
[16:20:42.948]                             next
[16:20:42.948]                           invokeRestart(restart)
[16:20:42.948]                           muffled <- TRUE
[16:20:42.948]                           break
[16:20:42.948]                         }
[16:20:42.948]                       }
[16:20:42.948]                     }
[16:20:42.948]                     invisible(muffled)
[16:20:42.948]                   }
[16:20:42.948]                   muffleCondition(cond)
[16:20:42.948]                 })
[16:20:42.948]             }))
[16:20:42.948]             future::FutureResult(value = ...future.value$value, 
[16:20:42.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.948]                   ...future.rng), globalenv = if (FALSE) 
[16:20:42.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:42.948]                     ...future.globalenv.names))
[16:20:42.948]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:42.948]         }, condition = base::local({
[16:20:42.948]             c <- base::c
[16:20:42.948]             inherits <- base::inherits
[16:20:42.948]             invokeRestart <- base::invokeRestart
[16:20:42.948]             length <- base::length
[16:20:42.948]             list <- base::list
[16:20:42.948]             seq.int <- base::seq.int
[16:20:42.948]             signalCondition <- base::signalCondition
[16:20:42.948]             sys.calls <- base::sys.calls
[16:20:42.948]             `[[` <- base::`[[`
[16:20:42.948]             `+` <- base::`+`
[16:20:42.948]             `<<-` <- base::`<<-`
[16:20:42.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:42.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:42.948]                   3L)]
[16:20:42.948]             }
[16:20:42.948]             function(cond) {
[16:20:42.948]                 is_error <- inherits(cond, "error")
[16:20:42.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:42.948]                   NULL)
[16:20:42.948]                 if (is_error) {
[16:20:42.948]                   sessionInformation <- function() {
[16:20:42.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:42.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:42.948]                       search = base::search(), system = base::Sys.info())
[16:20:42.948]                   }
[16:20:42.948]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:42.948]                     cond$call), session = sessionInformation(), 
[16:20:42.948]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:42.948]                   signalCondition(cond)
[16:20:42.948]                 }
[16:20:42.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:42.948]                 "immediateCondition"))) {
[16:20:42.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:42.948]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:42.948]                   if (TRUE && !signal) {
[16:20:42.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.948]                     {
[16:20:42.948]                       inherits <- base::inherits
[16:20:42.948]                       invokeRestart <- base::invokeRestart
[16:20:42.948]                       is.null <- base::is.null
[16:20:42.948]                       muffled <- FALSE
[16:20:42.948]                       if (inherits(cond, "message")) {
[16:20:42.948]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.948]                         if (muffled) 
[16:20:42.948]                           invokeRestart("muffleMessage")
[16:20:42.948]                       }
[16:20:42.948]                       else if (inherits(cond, "warning")) {
[16:20:42.948]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.948]                         if (muffled) 
[16:20:42.948]                           invokeRestart("muffleWarning")
[16:20:42.948]                       }
[16:20:42.948]                       else if (inherits(cond, "condition")) {
[16:20:42.948]                         if (!is.null(pattern)) {
[16:20:42.948]                           computeRestarts <- base::computeRestarts
[16:20:42.948]                           grepl <- base::grepl
[16:20:42.948]                           restarts <- computeRestarts(cond)
[16:20:42.948]                           for (restart in restarts) {
[16:20:42.948]                             name <- restart$name
[16:20:42.948]                             if (is.null(name)) 
[16:20:42.948]                               next
[16:20:42.948]                             if (!grepl(pattern, name)) 
[16:20:42.948]                               next
[16:20:42.948]                             invokeRestart(restart)
[16:20:42.948]                             muffled <- TRUE
[16:20:42.948]                             break
[16:20:42.948]                           }
[16:20:42.948]                         }
[16:20:42.948]                       }
[16:20:42.948]                       invisible(muffled)
[16:20:42.948]                     }
[16:20:42.948]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.948]                   }
[16:20:42.948]                 }
[16:20:42.948]                 else {
[16:20:42.948]                   if (TRUE) {
[16:20:42.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.948]                     {
[16:20:42.948]                       inherits <- base::inherits
[16:20:42.948]                       invokeRestart <- base::invokeRestart
[16:20:42.948]                       is.null <- base::is.null
[16:20:42.948]                       muffled <- FALSE
[16:20:42.948]                       if (inherits(cond, "message")) {
[16:20:42.948]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.948]                         if (muffled) 
[16:20:42.948]                           invokeRestart("muffleMessage")
[16:20:42.948]                       }
[16:20:42.948]                       else if (inherits(cond, "warning")) {
[16:20:42.948]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.948]                         if (muffled) 
[16:20:42.948]                           invokeRestart("muffleWarning")
[16:20:42.948]                       }
[16:20:42.948]                       else if (inherits(cond, "condition")) {
[16:20:42.948]                         if (!is.null(pattern)) {
[16:20:42.948]                           computeRestarts <- base::computeRestarts
[16:20:42.948]                           grepl <- base::grepl
[16:20:42.948]                           restarts <- computeRestarts(cond)
[16:20:42.948]                           for (restart in restarts) {
[16:20:42.948]                             name <- restart$name
[16:20:42.948]                             if (is.null(name)) 
[16:20:42.948]                               next
[16:20:42.948]                             if (!grepl(pattern, name)) 
[16:20:42.948]                               next
[16:20:42.948]                             invokeRestart(restart)
[16:20:42.948]                             muffled <- TRUE
[16:20:42.948]                             break
[16:20:42.948]                           }
[16:20:42.948]                         }
[16:20:42.948]                       }
[16:20:42.948]                       invisible(muffled)
[16:20:42.948]                     }
[16:20:42.948]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.948]                   }
[16:20:42.948]                 }
[16:20:42.948]             }
[16:20:42.948]         }))
[16:20:42.948]     }, error = function(ex) {
[16:20:42.948]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:42.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.948]                 ...future.rng), started = ...future.startTime, 
[16:20:42.948]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:42.948]             version = "1.8"), class = "FutureResult")
[16:20:42.948]     }, finally = {
[16:20:42.948]         if (!identical(...future.workdir, getwd())) 
[16:20:42.948]             setwd(...future.workdir)
[16:20:42.948]         {
[16:20:42.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:42.948]                 ...future.oldOptions$nwarnings <- NULL
[16:20:42.948]             }
[16:20:42.948]             base::options(...future.oldOptions)
[16:20:42.948]             if (.Platform$OS.type == "windows") {
[16:20:42.948]                 old_names <- names(...future.oldEnvVars)
[16:20:42.948]                 envs <- base::Sys.getenv()
[16:20:42.948]                 names <- names(envs)
[16:20:42.948]                 common <- intersect(names, old_names)
[16:20:42.948]                 added <- setdiff(names, old_names)
[16:20:42.948]                 removed <- setdiff(old_names, names)
[16:20:42.948]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:42.948]                   envs[common]]
[16:20:42.948]                 NAMES <- toupper(changed)
[16:20:42.948]                 args <- list()
[16:20:42.948]                 for (kk in seq_along(NAMES)) {
[16:20:42.948]                   name <- changed[[kk]]
[16:20:42.948]                   NAME <- NAMES[[kk]]
[16:20:42.948]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.948]                     next
[16:20:42.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.948]                 }
[16:20:42.948]                 NAMES <- toupper(added)
[16:20:42.948]                 for (kk in seq_along(NAMES)) {
[16:20:42.948]                   name <- added[[kk]]
[16:20:42.948]                   NAME <- NAMES[[kk]]
[16:20:42.948]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.948]                     next
[16:20:42.948]                   args[[name]] <- ""
[16:20:42.948]                 }
[16:20:42.948]                 NAMES <- toupper(removed)
[16:20:42.948]                 for (kk in seq_along(NAMES)) {
[16:20:42.948]                   name <- removed[[kk]]
[16:20:42.948]                   NAME <- NAMES[[kk]]
[16:20:42.948]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.948]                     next
[16:20:42.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.948]                 }
[16:20:42.948]                 if (length(args) > 0) 
[16:20:42.948]                   base::do.call(base::Sys.setenv, args = args)
[16:20:42.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:42.948]             }
[16:20:42.948]             else {
[16:20:42.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:42.948]             }
[16:20:42.948]             {
[16:20:42.948]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:42.948]                   0L) {
[16:20:42.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:42.948]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:42.948]                   base::options(opts)
[16:20:42.948]                 }
[16:20:42.948]                 {
[16:20:42.948]                   {
[16:20:42.948]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:42.948]                     NULL
[16:20:42.948]                   }
[16:20:42.948]                   options(future.plan = NULL)
[16:20:42.948]                   if (is.na(NA_character_)) 
[16:20:42.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:42.948]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:42.948]                     .init = FALSE)
[16:20:42.948]                 }
[16:20:42.948]             }
[16:20:42.948]         }
[16:20:42.948]     })
[16:20:42.948]     if (TRUE) {
[16:20:42.948]         base::sink(type = "output", split = FALSE)
[16:20:42.948]         if (TRUE) {
[16:20:42.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:42.948]         }
[16:20:42.948]         else {
[16:20:42.948]             ...future.result["stdout"] <- base::list(NULL)
[16:20:42.948]         }
[16:20:42.948]         base::close(...future.stdout)
[16:20:42.948]         ...future.stdout <- NULL
[16:20:42.948]     }
[16:20:42.948]     ...future.result$conditions <- ...future.conditions
[16:20:42.948]     ...future.result$finished <- base::Sys.time()
[16:20:42.948]     ...future.result
[16:20:42.948] }
[16:20:42.950] MultisessionFuture started
[16:20:42.951] - Launch lazy future ... done
[16:20:42.951] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c6b92f0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c012e08> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c6b92f0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c012e08> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:20:42.958] receiveMessageFromWorker() for ClusterFuture ...
[16:20:42.958] - Validating connection of MultisessionFuture
[16:20:42.958] - received message: FutureResult
[16:20:42.959] - Received FutureResult
[16:20:42.959] - Erased future from FutureRegistry
[16:20:42.959] result() for ClusterFuture ...
[16:20:42.959] - result already collected: FutureResult
[16:20:42.959] result() for ClusterFuture ... done
[16:20:42.959] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:42.959] receiveMessageFromWorker() for ClusterFuture ...
[16:20:42.960] - Validating connection of MultisessionFuture
[16:20:42.960] - received message: FutureResult
[16:20:42.960] - Received FutureResult
[16:20:42.960] - Erased future from FutureRegistry
[16:20:42.960] result() for ClusterFuture ...
[16:20:42.960] - result already collected: FutureResult
[16:20:42.960] result() for ClusterFuture ... done
[16:20:42.960] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:42.962] resolve() on list ...
[16:20:42.962]  recursive: 0
[16:20:42.962]  length: 6
[16:20:42.962]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:42.962] signalConditionsASAP(numeric, pos=1) ...
[16:20:42.962] - nx: 6
[16:20:42.962] - relay: TRUE
[16:20:42.963] - stdout: TRUE
[16:20:42.963] - signal: TRUE
[16:20:42.963] - resignal: FALSE
[16:20:42.963] - force: TRUE
[16:20:42.963] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.963] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.963]  - until=2
[16:20:42.963]  - relaying element #2
[16:20:42.963] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.963] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.963] signalConditionsASAP(NULL, pos=1) ... done
[16:20:42.964]  length: 5 (resolved future 1)
[16:20:42.964] Future #2
[16:20:42.964] result() for ClusterFuture ...
[16:20:42.964] - result already collected: FutureResult
[16:20:42.964] result() for ClusterFuture ... done
[16:20:42.964] result() for ClusterFuture ...
[16:20:42.964] - result already collected: FutureResult
[16:20:42.964] result() for ClusterFuture ... done
[16:20:42.964] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:42.964] - nx: 6
[16:20:42.965] - relay: TRUE
[16:20:42.965] - stdout: TRUE
[16:20:42.965] - signal: TRUE
[16:20:42.965] - resignal: FALSE
[16:20:42.965] - force: TRUE
[16:20:42.965] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.965] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:42.965]  - until=2
[16:20:42.965]  - relaying element #2
[16:20:42.965] result() for ClusterFuture ...
[16:20:42.965] - result already collected: FutureResult
[16:20:42.965] result() for ClusterFuture ... done
[16:20:42.966] result() for ClusterFuture ...
[16:20:42.966] - result already collected: FutureResult
[16:20:42.966] result() for ClusterFuture ... done
[16:20:42.966] result() for ClusterFuture ...
[16:20:42.966] - result already collected: FutureResult
[16:20:42.966] result() for ClusterFuture ... done
[16:20:42.966] result() for ClusterFuture ...
[16:20:42.966] - result already collected: FutureResult
[16:20:42.966] result() for ClusterFuture ... done
[16:20:42.966] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.966] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.967] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:42.967]  length: 4 (resolved future 2)
[16:20:42.967] Future #3
[16:20:42.967] result() for ClusterFuture ...
[16:20:42.967] - result already collected: FutureResult
[16:20:42.967] result() for ClusterFuture ... done
[16:20:42.967] result() for ClusterFuture ...
[16:20:42.967] - result already collected: FutureResult
[16:20:42.967] result() for ClusterFuture ... done
[16:20:42.967] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:42.967] - nx: 6
[16:20:42.968] - relay: TRUE
[16:20:42.968] - stdout: TRUE
[16:20:42.968] - signal: TRUE
[16:20:42.968] - resignal: FALSE
[16:20:42.968] - force: TRUE
[16:20:42.968] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.968] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:42.968]  - until=3
[16:20:42.968]  - relaying element #3
[16:20:42.968] result() for ClusterFuture ...
[16:20:42.968] - result already collected: FutureResult
[16:20:42.968] result() for ClusterFuture ... done
[16:20:42.969] result() for ClusterFuture ...
[16:20:42.969] - result already collected: FutureResult
[16:20:42.969] result() for ClusterFuture ... done
[16:20:42.969] result() for ClusterFuture ...
[16:20:42.969] - result already collected: FutureResult
[16:20:42.969] result() for ClusterFuture ... done
[16:20:42.969] result() for ClusterFuture ...
[16:20:42.969] - result already collected: FutureResult
[16:20:42.969] result() for ClusterFuture ... done
[16:20:42.969] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.969] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.970] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:42.970]  length: 3 (resolved future 3)
[16:20:42.970] signalConditionsASAP(NULL, pos=4) ...
[16:20:42.970] - nx: 6
[16:20:42.970] - relay: TRUE
[16:20:42.970] - stdout: TRUE
[16:20:42.970] - signal: TRUE
[16:20:42.970] - resignal: FALSE
[16:20:42.970] - force: TRUE
[16:20:42.970] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.970] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.970]  - until=5
[16:20:42.971]  - relaying element #5
[16:20:42.971] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:42.971] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.971] signalConditionsASAP(NULL, pos=4) ... done
[16:20:42.971]  length: 2 (resolved future 4)
[16:20:42.971] signalConditionsASAP(NULL, pos=5) ...
[16:20:42.971] - nx: 6
[16:20:42.971] - relay: TRUE
[16:20:42.971] - stdout: TRUE
[16:20:42.971] - signal: TRUE
[16:20:42.971] - resignal: FALSE
[16:20:42.971] - force: TRUE
[16:20:42.972] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:42.972] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.972]  - until=6
[16:20:42.972]  - relaying element #6
[16:20:42.972] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:42.972] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.972] signalConditionsASAP(NULL, pos=5) ... done
[16:20:42.972]  length: 1 (resolved future 5)
[16:20:42.972] signalConditionsASAP(numeric, pos=6) ...
[16:20:42.972] - nx: 6
[16:20:42.972] - relay: TRUE
[16:20:42.973] - stdout: TRUE
[16:20:42.973] - signal: TRUE
[16:20:42.973] - resignal: FALSE
[16:20:42.973] - force: TRUE
[16:20:42.973] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:42.973] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.973]  - until=6
[16:20:42.973] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.973] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.973] signalConditionsASAP(numeric, pos=6) ... done
[16:20:42.973]  length: 0 (resolved future 6)
[16:20:42.974] Relaying remaining futures
[16:20:42.974] signalConditionsASAP(NULL, pos=0) ...
[16:20:42.974] - nx: 6
[16:20:42.974] - relay: TRUE
[16:20:42.974] - stdout: TRUE
[16:20:42.974] - signal: TRUE
[16:20:42.974] - resignal: FALSE
[16:20:42.974] - force: TRUE
[16:20:42.974] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.974] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:42.974] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:42.974] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:42.975] signalConditionsASAP(NULL, pos=0) ... done
[16:20:42.975] resolve() on list ... DONE
[16:20:42.975] result() for ClusterFuture ...
[16:20:42.975] - result already collected: FutureResult
[16:20:42.975] result() for ClusterFuture ... done
[16:20:42.975] result() for ClusterFuture ...
[16:20:42.975] - result already collected: FutureResult
[16:20:42.975] result() for ClusterFuture ... done
[16:20:42.975] result() for ClusterFuture ...
[16:20:42.975] - result already collected: FutureResult
[16:20:42.975] result() for ClusterFuture ... done
[16:20:42.975] result() for ClusterFuture ...
[16:20:42.976] - result already collected: FutureResult
[16:20:42.976] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:20:42.979] getGlobalsAndPackages() ...
[16:20:42.979] Searching for globals...
[16:20:42.979] 
[16:20:42.979] Searching for globals ... DONE
[16:20:42.979] - globals: [0] <none>
[16:20:42.979] getGlobalsAndPackages() ... DONE
[16:20:42.980] run() for ‘Future’ ...
[16:20:42.980] - state: ‘created’
[16:20:42.980] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:42.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:42.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:42.994]   - Field: ‘node’
[16:20:42.994]   - Field: ‘label’
[16:20:42.994]   - Field: ‘local’
[16:20:42.994]   - Field: ‘owner’
[16:20:42.994]   - Field: ‘envir’
[16:20:42.994]   - Field: ‘workers’
[16:20:42.994]   - Field: ‘packages’
[16:20:42.994]   - Field: ‘gc’
[16:20:42.994]   - Field: ‘conditions’
[16:20:42.995]   - Field: ‘persistent’
[16:20:42.995]   - Field: ‘expr’
[16:20:42.995]   - Field: ‘uuid’
[16:20:42.995]   - Field: ‘seed’
[16:20:42.995]   - Field: ‘version’
[16:20:42.995]   - Field: ‘result’
[16:20:42.995]   - Field: ‘asynchronous’
[16:20:42.995]   - Field: ‘calls’
[16:20:42.995]   - Field: ‘globals’
[16:20:42.995]   - Field: ‘stdout’
[16:20:42.995]   - Field: ‘earlySignal’
[16:20:42.996]   - Field: ‘lazy’
[16:20:42.996]   - Field: ‘state’
[16:20:42.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:42.996] - Launch lazy future ...
[16:20:42.996] Packages needed by the future expression (n = 0): <none>
[16:20:42.996] Packages needed by future strategies (n = 0): <none>
[16:20:42.997] {
[16:20:42.997]     {
[16:20:42.997]         {
[16:20:42.997]             ...future.startTime <- base::Sys.time()
[16:20:42.997]             {
[16:20:42.997]                 {
[16:20:42.997]                   {
[16:20:42.997]                     {
[16:20:42.997]                       base::local({
[16:20:42.997]                         has_future <- base::requireNamespace("future", 
[16:20:42.997]                           quietly = TRUE)
[16:20:42.997]                         if (has_future) {
[16:20:42.997]                           ns <- base::getNamespace("future")
[16:20:42.997]                           version <- ns[[".package"]][["version"]]
[16:20:42.997]                           if (is.null(version)) 
[16:20:42.997]                             version <- utils::packageVersion("future")
[16:20:42.997]                         }
[16:20:42.997]                         else {
[16:20:42.997]                           version <- NULL
[16:20:42.997]                         }
[16:20:42.997]                         if (!has_future || version < "1.8.0") {
[16:20:42.997]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:42.997]                             "", base::R.version$version.string), 
[16:20:42.997]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:42.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:42.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:42.997]                               "release", "version")], collapse = " "), 
[16:20:42.997]                             hostname = base::Sys.info()[["nodename"]])
[16:20:42.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:42.997]                             info)
[16:20:42.997]                           info <- base::paste(info, collapse = "; ")
[16:20:42.997]                           if (!has_future) {
[16:20:42.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:42.997]                               info)
[16:20:42.997]                           }
[16:20:42.997]                           else {
[16:20:42.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:42.997]                               info, version)
[16:20:42.997]                           }
[16:20:42.997]                           base::stop(msg)
[16:20:42.997]                         }
[16:20:42.997]                       })
[16:20:42.997]                     }
[16:20:42.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:42.997]                     base::options(mc.cores = 1L)
[16:20:42.997]                   }
[16:20:42.997]                   ...future.strategy.old <- future::plan("list")
[16:20:42.997]                   options(future.plan = NULL)
[16:20:42.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:42.997]                 }
[16:20:42.997]                 ...future.workdir <- getwd()
[16:20:42.997]             }
[16:20:42.997]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:42.997]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:42.997]         }
[16:20:42.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:42.997]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:42.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:42.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:42.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:42.997]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:42.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:42.997]             base::names(...future.oldOptions))
[16:20:42.997]     }
[16:20:42.997]     if (FALSE) {
[16:20:42.997]     }
[16:20:42.997]     else {
[16:20:42.997]         if (TRUE) {
[16:20:42.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:42.997]                 open = "w")
[16:20:42.997]         }
[16:20:42.997]         else {
[16:20:42.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:42.997]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:42.997]         }
[16:20:42.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:42.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:42.997]             base::sink(type = "output", split = FALSE)
[16:20:42.997]             base::close(...future.stdout)
[16:20:42.997]         }, add = TRUE)
[16:20:42.997]     }
[16:20:42.997]     ...future.frame <- base::sys.nframe()
[16:20:42.997]     ...future.conditions <- base::list()
[16:20:42.997]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:42.997]     if (FALSE) {
[16:20:42.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:42.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:42.997]     }
[16:20:42.997]     ...future.result <- base::tryCatch({
[16:20:42.997]         base::withCallingHandlers({
[16:20:42.997]             ...future.value <- base::withVisible(base::local({
[16:20:42.997]                 ...future.makeSendCondition <- base::local({
[16:20:42.997]                   sendCondition <- NULL
[16:20:42.997]                   function(frame = 1L) {
[16:20:42.997]                     if (is.function(sendCondition)) 
[16:20:42.997]                       return(sendCondition)
[16:20:42.997]                     ns <- getNamespace("parallel")
[16:20:42.997]                     if (exists("sendData", mode = "function", 
[16:20:42.997]                       envir = ns)) {
[16:20:42.997]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:42.997]                         envir = ns)
[16:20:42.997]                       envir <- sys.frame(frame)
[16:20:42.997]                       master <- NULL
[16:20:42.997]                       while (!identical(envir, .GlobalEnv) && 
[16:20:42.997]                         !identical(envir, emptyenv())) {
[16:20:42.997]                         if (exists("master", mode = "list", envir = envir, 
[16:20:42.997]                           inherits = FALSE)) {
[16:20:42.997]                           master <- get("master", mode = "list", 
[16:20:42.997]                             envir = envir, inherits = FALSE)
[16:20:42.997]                           if (inherits(master, c("SOCKnode", 
[16:20:42.997]                             "SOCK0node"))) {
[16:20:42.997]                             sendCondition <<- function(cond) {
[16:20:42.997]                               data <- list(type = "VALUE", value = cond, 
[16:20:42.997]                                 success = TRUE)
[16:20:42.997]                               parallel_sendData(master, data)
[16:20:42.997]                             }
[16:20:42.997]                             return(sendCondition)
[16:20:42.997]                           }
[16:20:42.997]                         }
[16:20:42.997]                         frame <- frame + 1L
[16:20:42.997]                         envir <- sys.frame(frame)
[16:20:42.997]                       }
[16:20:42.997]                     }
[16:20:42.997]                     sendCondition <<- function(cond) NULL
[16:20:42.997]                   }
[16:20:42.997]                 })
[16:20:42.997]                 withCallingHandlers({
[16:20:42.997]                   2
[16:20:42.997]                 }, immediateCondition = function(cond) {
[16:20:42.997]                   sendCondition <- ...future.makeSendCondition()
[16:20:42.997]                   sendCondition(cond)
[16:20:42.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.997]                   {
[16:20:42.997]                     inherits <- base::inherits
[16:20:42.997]                     invokeRestart <- base::invokeRestart
[16:20:42.997]                     is.null <- base::is.null
[16:20:42.997]                     muffled <- FALSE
[16:20:42.997]                     if (inherits(cond, "message")) {
[16:20:42.997]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:42.997]                       if (muffled) 
[16:20:42.997]                         invokeRestart("muffleMessage")
[16:20:42.997]                     }
[16:20:42.997]                     else if (inherits(cond, "warning")) {
[16:20:42.997]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:42.997]                       if (muffled) 
[16:20:42.997]                         invokeRestart("muffleWarning")
[16:20:42.997]                     }
[16:20:42.997]                     else if (inherits(cond, "condition")) {
[16:20:42.997]                       if (!is.null(pattern)) {
[16:20:42.997]                         computeRestarts <- base::computeRestarts
[16:20:42.997]                         grepl <- base::grepl
[16:20:42.997]                         restarts <- computeRestarts(cond)
[16:20:42.997]                         for (restart in restarts) {
[16:20:42.997]                           name <- restart$name
[16:20:42.997]                           if (is.null(name)) 
[16:20:42.997]                             next
[16:20:42.997]                           if (!grepl(pattern, name)) 
[16:20:42.997]                             next
[16:20:42.997]                           invokeRestart(restart)
[16:20:42.997]                           muffled <- TRUE
[16:20:42.997]                           break
[16:20:42.997]                         }
[16:20:42.997]                       }
[16:20:42.997]                     }
[16:20:42.997]                     invisible(muffled)
[16:20:42.997]                   }
[16:20:42.997]                   muffleCondition(cond)
[16:20:42.997]                 })
[16:20:42.997]             }))
[16:20:42.997]             future::FutureResult(value = ...future.value$value, 
[16:20:42.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.997]                   ...future.rng), globalenv = if (FALSE) 
[16:20:42.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:42.997]                     ...future.globalenv.names))
[16:20:42.997]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:42.997]         }, condition = base::local({
[16:20:42.997]             c <- base::c
[16:20:42.997]             inherits <- base::inherits
[16:20:42.997]             invokeRestart <- base::invokeRestart
[16:20:42.997]             length <- base::length
[16:20:42.997]             list <- base::list
[16:20:42.997]             seq.int <- base::seq.int
[16:20:42.997]             signalCondition <- base::signalCondition
[16:20:42.997]             sys.calls <- base::sys.calls
[16:20:42.997]             `[[` <- base::`[[`
[16:20:42.997]             `+` <- base::`+`
[16:20:42.997]             `<<-` <- base::`<<-`
[16:20:42.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:42.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:42.997]                   3L)]
[16:20:42.997]             }
[16:20:42.997]             function(cond) {
[16:20:42.997]                 is_error <- inherits(cond, "error")
[16:20:42.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:42.997]                   NULL)
[16:20:42.997]                 if (is_error) {
[16:20:42.997]                   sessionInformation <- function() {
[16:20:42.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:42.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:42.997]                       search = base::search(), system = base::Sys.info())
[16:20:42.997]                   }
[16:20:42.997]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:42.997]                     cond$call), session = sessionInformation(), 
[16:20:42.997]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:42.997]                   signalCondition(cond)
[16:20:42.997]                 }
[16:20:42.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:42.997]                 "immediateCondition"))) {
[16:20:42.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:42.997]                   ...future.conditions[[length(...future.conditions) + 
[16:20:42.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:42.997]                   if (TRUE && !signal) {
[16:20:42.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.997]                     {
[16:20:42.997]                       inherits <- base::inherits
[16:20:42.997]                       invokeRestart <- base::invokeRestart
[16:20:42.997]                       is.null <- base::is.null
[16:20:42.997]                       muffled <- FALSE
[16:20:42.997]                       if (inherits(cond, "message")) {
[16:20:42.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.997]                         if (muffled) 
[16:20:42.997]                           invokeRestart("muffleMessage")
[16:20:42.997]                       }
[16:20:42.997]                       else if (inherits(cond, "warning")) {
[16:20:42.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.997]                         if (muffled) 
[16:20:42.997]                           invokeRestart("muffleWarning")
[16:20:42.997]                       }
[16:20:42.997]                       else if (inherits(cond, "condition")) {
[16:20:42.997]                         if (!is.null(pattern)) {
[16:20:42.997]                           computeRestarts <- base::computeRestarts
[16:20:42.997]                           grepl <- base::grepl
[16:20:42.997]                           restarts <- computeRestarts(cond)
[16:20:42.997]                           for (restart in restarts) {
[16:20:42.997]                             name <- restart$name
[16:20:42.997]                             if (is.null(name)) 
[16:20:42.997]                               next
[16:20:42.997]                             if (!grepl(pattern, name)) 
[16:20:42.997]                               next
[16:20:42.997]                             invokeRestart(restart)
[16:20:42.997]                             muffled <- TRUE
[16:20:42.997]                             break
[16:20:42.997]                           }
[16:20:42.997]                         }
[16:20:42.997]                       }
[16:20:42.997]                       invisible(muffled)
[16:20:42.997]                     }
[16:20:42.997]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.997]                   }
[16:20:42.997]                 }
[16:20:42.997]                 else {
[16:20:42.997]                   if (TRUE) {
[16:20:42.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:42.997]                     {
[16:20:42.997]                       inherits <- base::inherits
[16:20:42.997]                       invokeRestart <- base::invokeRestart
[16:20:42.997]                       is.null <- base::is.null
[16:20:42.997]                       muffled <- FALSE
[16:20:42.997]                       if (inherits(cond, "message")) {
[16:20:42.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:42.997]                         if (muffled) 
[16:20:42.997]                           invokeRestart("muffleMessage")
[16:20:42.997]                       }
[16:20:42.997]                       else if (inherits(cond, "warning")) {
[16:20:42.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:42.997]                         if (muffled) 
[16:20:42.997]                           invokeRestart("muffleWarning")
[16:20:42.997]                       }
[16:20:42.997]                       else if (inherits(cond, "condition")) {
[16:20:42.997]                         if (!is.null(pattern)) {
[16:20:42.997]                           computeRestarts <- base::computeRestarts
[16:20:42.997]                           grepl <- base::grepl
[16:20:42.997]                           restarts <- computeRestarts(cond)
[16:20:42.997]                           for (restart in restarts) {
[16:20:42.997]                             name <- restart$name
[16:20:42.997]                             if (is.null(name)) 
[16:20:42.997]                               next
[16:20:42.997]                             if (!grepl(pattern, name)) 
[16:20:42.997]                               next
[16:20:42.997]                             invokeRestart(restart)
[16:20:42.997]                             muffled <- TRUE
[16:20:42.997]                             break
[16:20:42.997]                           }
[16:20:42.997]                         }
[16:20:42.997]                       }
[16:20:42.997]                       invisible(muffled)
[16:20:42.997]                     }
[16:20:42.997]                     muffleCondition(cond, pattern = "^muffle")
[16:20:42.997]                   }
[16:20:42.997]                 }
[16:20:42.997]             }
[16:20:42.997]         }))
[16:20:42.997]     }, error = function(ex) {
[16:20:42.997]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:42.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:42.997]                 ...future.rng), started = ...future.startTime, 
[16:20:42.997]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:42.997]             version = "1.8"), class = "FutureResult")
[16:20:42.997]     }, finally = {
[16:20:42.997]         if (!identical(...future.workdir, getwd())) 
[16:20:42.997]             setwd(...future.workdir)
[16:20:42.997]         {
[16:20:42.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:42.997]                 ...future.oldOptions$nwarnings <- NULL
[16:20:42.997]             }
[16:20:42.997]             base::options(...future.oldOptions)
[16:20:42.997]             if (.Platform$OS.type == "windows") {
[16:20:42.997]                 old_names <- names(...future.oldEnvVars)
[16:20:42.997]                 envs <- base::Sys.getenv()
[16:20:42.997]                 names <- names(envs)
[16:20:42.997]                 common <- intersect(names, old_names)
[16:20:42.997]                 added <- setdiff(names, old_names)
[16:20:42.997]                 removed <- setdiff(old_names, names)
[16:20:42.997]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:42.997]                   envs[common]]
[16:20:42.997]                 NAMES <- toupper(changed)
[16:20:42.997]                 args <- list()
[16:20:42.997]                 for (kk in seq_along(NAMES)) {
[16:20:42.997]                   name <- changed[[kk]]
[16:20:42.997]                   NAME <- NAMES[[kk]]
[16:20:42.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.997]                     next
[16:20:42.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.997]                 }
[16:20:42.997]                 NAMES <- toupper(added)
[16:20:42.997]                 for (kk in seq_along(NAMES)) {
[16:20:42.997]                   name <- added[[kk]]
[16:20:42.997]                   NAME <- NAMES[[kk]]
[16:20:42.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.997]                     next
[16:20:42.997]                   args[[name]] <- ""
[16:20:42.997]                 }
[16:20:42.997]                 NAMES <- toupper(removed)
[16:20:42.997]                 for (kk in seq_along(NAMES)) {
[16:20:42.997]                   name <- removed[[kk]]
[16:20:42.997]                   NAME <- NAMES[[kk]]
[16:20:42.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:42.997]                     next
[16:20:42.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:42.997]                 }
[16:20:42.997]                 if (length(args) > 0) 
[16:20:42.997]                   base::do.call(base::Sys.setenv, args = args)
[16:20:42.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:42.997]             }
[16:20:42.997]             else {
[16:20:42.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:42.997]             }
[16:20:42.997]             {
[16:20:42.997]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:42.997]                   0L) {
[16:20:42.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:42.997]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:42.997]                   base::options(opts)
[16:20:42.997]                 }
[16:20:42.997]                 {
[16:20:42.997]                   {
[16:20:42.997]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:42.997]                     NULL
[16:20:42.997]                   }
[16:20:42.997]                   options(future.plan = NULL)
[16:20:42.997]                   if (is.na(NA_character_)) 
[16:20:42.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:42.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:42.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:42.997]                     .init = FALSE)
[16:20:42.997]                 }
[16:20:42.997]             }
[16:20:42.997]         }
[16:20:42.997]     })
[16:20:42.997]     if (TRUE) {
[16:20:42.997]         base::sink(type = "output", split = FALSE)
[16:20:42.997]         if (TRUE) {
[16:20:42.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:42.997]         }
[16:20:42.997]         else {
[16:20:42.997]             ...future.result["stdout"] <- base::list(NULL)
[16:20:42.997]         }
[16:20:42.997]         base::close(...future.stdout)
[16:20:42.997]         ...future.stdout <- NULL
[16:20:42.997]     }
[16:20:42.997]     ...future.result$conditions <- ...future.conditions
[16:20:42.997]     ...future.result$finished <- base::Sys.time()
[16:20:42.997]     ...future.result
[16:20:42.997] }
[16:20:43.000] MultisessionFuture started
[16:20:43.000] - Launch lazy future ... done
[16:20:43.000] run() for ‘MultisessionFuture’ ... done
[16:20:43.000] getGlobalsAndPackages() ...
[16:20:43.000] Searching for globals...
[16:20:43.001] 
[16:20:43.001] Searching for globals ... DONE
[16:20:43.001] - globals: [0] <none>
[16:20:43.001] getGlobalsAndPackages() ... DONE
[16:20:43.002] run() for ‘Future’ ...
[16:20:43.002] - state: ‘created’
[16:20:43.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.015] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:43.016]   - Field: ‘node’
[16:20:43.016]   - Field: ‘label’
[16:20:43.016]   - Field: ‘local’
[16:20:43.016]   - Field: ‘owner’
[16:20:43.016]   - Field: ‘envir’
[16:20:43.016]   - Field: ‘workers’
[16:20:43.016]   - Field: ‘packages’
[16:20:43.016]   - Field: ‘gc’
[16:20:43.017]   - Field: ‘conditions’
[16:20:43.017]   - Field: ‘persistent’
[16:20:43.017]   - Field: ‘expr’
[16:20:43.017]   - Field: ‘uuid’
[16:20:43.017]   - Field: ‘seed’
[16:20:43.017]   - Field: ‘version’
[16:20:43.017]   - Field: ‘result’
[16:20:43.017]   - Field: ‘asynchronous’
[16:20:43.017]   - Field: ‘calls’
[16:20:43.017]   - Field: ‘globals’
[16:20:43.017]   - Field: ‘stdout’
[16:20:43.018]   - Field: ‘earlySignal’
[16:20:43.018]   - Field: ‘lazy’
[16:20:43.018]   - Field: ‘state’
[16:20:43.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:43.018] - Launch lazy future ...
[16:20:43.018] Packages needed by the future expression (n = 0): <none>
[16:20:43.018] Packages needed by future strategies (n = 0): <none>
[16:20:43.019] {
[16:20:43.019]     {
[16:20:43.019]         {
[16:20:43.019]             ...future.startTime <- base::Sys.time()
[16:20:43.019]             {
[16:20:43.019]                 {
[16:20:43.019]                   {
[16:20:43.019]                     {
[16:20:43.019]                       base::local({
[16:20:43.019]                         has_future <- base::requireNamespace("future", 
[16:20:43.019]                           quietly = TRUE)
[16:20:43.019]                         if (has_future) {
[16:20:43.019]                           ns <- base::getNamespace("future")
[16:20:43.019]                           version <- ns[[".package"]][["version"]]
[16:20:43.019]                           if (is.null(version)) 
[16:20:43.019]                             version <- utils::packageVersion("future")
[16:20:43.019]                         }
[16:20:43.019]                         else {
[16:20:43.019]                           version <- NULL
[16:20:43.019]                         }
[16:20:43.019]                         if (!has_future || version < "1.8.0") {
[16:20:43.019]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.019]                             "", base::R.version$version.string), 
[16:20:43.019]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.019]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.019]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.019]                               "release", "version")], collapse = " "), 
[16:20:43.019]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.019]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.019]                             info)
[16:20:43.019]                           info <- base::paste(info, collapse = "; ")
[16:20:43.019]                           if (!has_future) {
[16:20:43.019]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.019]                               info)
[16:20:43.019]                           }
[16:20:43.019]                           else {
[16:20:43.019]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.019]                               info, version)
[16:20:43.019]                           }
[16:20:43.019]                           base::stop(msg)
[16:20:43.019]                         }
[16:20:43.019]                       })
[16:20:43.019]                     }
[16:20:43.019]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.019]                     base::options(mc.cores = 1L)
[16:20:43.019]                   }
[16:20:43.019]                   ...future.strategy.old <- future::plan("list")
[16:20:43.019]                   options(future.plan = NULL)
[16:20:43.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.019]                 }
[16:20:43.019]                 ...future.workdir <- getwd()
[16:20:43.019]             }
[16:20:43.019]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.019]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.019]         }
[16:20:43.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.019]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.019]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.019]             base::names(...future.oldOptions))
[16:20:43.019]     }
[16:20:43.019]     if (FALSE) {
[16:20:43.019]     }
[16:20:43.019]     else {
[16:20:43.019]         if (TRUE) {
[16:20:43.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.019]                 open = "w")
[16:20:43.019]         }
[16:20:43.019]         else {
[16:20:43.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.019]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.019]         }
[16:20:43.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.019]             base::sink(type = "output", split = FALSE)
[16:20:43.019]             base::close(...future.stdout)
[16:20:43.019]         }, add = TRUE)
[16:20:43.019]     }
[16:20:43.019]     ...future.frame <- base::sys.nframe()
[16:20:43.019]     ...future.conditions <- base::list()
[16:20:43.019]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.019]     if (FALSE) {
[16:20:43.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.019]     }
[16:20:43.019]     ...future.result <- base::tryCatch({
[16:20:43.019]         base::withCallingHandlers({
[16:20:43.019]             ...future.value <- base::withVisible(base::local({
[16:20:43.019]                 ...future.makeSendCondition <- base::local({
[16:20:43.019]                   sendCondition <- NULL
[16:20:43.019]                   function(frame = 1L) {
[16:20:43.019]                     if (is.function(sendCondition)) 
[16:20:43.019]                       return(sendCondition)
[16:20:43.019]                     ns <- getNamespace("parallel")
[16:20:43.019]                     if (exists("sendData", mode = "function", 
[16:20:43.019]                       envir = ns)) {
[16:20:43.019]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:43.019]                         envir = ns)
[16:20:43.019]                       envir <- sys.frame(frame)
[16:20:43.019]                       master <- NULL
[16:20:43.019]                       while (!identical(envir, .GlobalEnv) && 
[16:20:43.019]                         !identical(envir, emptyenv())) {
[16:20:43.019]                         if (exists("master", mode = "list", envir = envir, 
[16:20:43.019]                           inherits = FALSE)) {
[16:20:43.019]                           master <- get("master", mode = "list", 
[16:20:43.019]                             envir = envir, inherits = FALSE)
[16:20:43.019]                           if (inherits(master, c("SOCKnode", 
[16:20:43.019]                             "SOCK0node"))) {
[16:20:43.019]                             sendCondition <<- function(cond) {
[16:20:43.019]                               data <- list(type = "VALUE", value = cond, 
[16:20:43.019]                                 success = TRUE)
[16:20:43.019]                               parallel_sendData(master, data)
[16:20:43.019]                             }
[16:20:43.019]                             return(sendCondition)
[16:20:43.019]                           }
[16:20:43.019]                         }
[16:20:43.019]                         frame <- frame + 1L
[16:20:43.019]                         envir <- sys.frame(frame)
[16:20:43.019]                       }
[16:20:43.019]                     }
[16:20:43.019]                     sendCondition <<- function(cond) NULL
[16:20:43.019]                   }
[16:20:43.019]                 })
[16:20:43.019]                 withCallingHandlers({
[16:20:43.019]                   NULL
[16:20:43.019]                 }, immediateCondition = function(cond) {
[16:20:43.019]                   sendCondition <- ...future.makeSendCondition()
[16:20:43.019]                   sendCondition(cond)
[16:20:43.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.019]                   {
[16:20:43.019]                     inherits <- base::inherits
[16:20:43.019]                     invokeRestart <- base::invokeRestart
[16:20:43.019]                     is.null <- base::is.null
[16:20:43.019]                     muffled <- FALSE
[16:20:43.019]                     if (inherits(cond, "message")) {
[16:20:43.019]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.019]                       if (muffled) 
[16:20:43.019]                         invokeRestart("muffleMessage")
[16:20:43.019]                     }
[16:20:43.019]                     else if (inherits(cond, "warning")) {
[16:20:43.019]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.019]                       if (muffled) 
[16:20:43.019]                         invokeRestart("muffleWarning")
[16:20:43.019]                     }
[16:20:43.019]                     else if (inherits(cond, "condition")) {
[16:20:43.019]                       if (!is.null(pattern)) {
[16:20:43.019]                         computeRestarts <- base::computeRestarts
[16:20:43.019]                         grepl <- base::grepl
[16:20:43.019]                         restarts <- computeRestarts(cond)
[16:20:43.019]                         for (restart in restarts) {
[16:20:43.019]                           name <- restart$name
[16:20:43.019]                           if (is.null(name)) 
[16:20:43.019]                             next
[16:20:43.019]                           if (!grepl(pattern, name)) 
[16:20:43.019]                             next
[16:20:43.019]                           invokeRestart(restart)
[16:20:43.019]                           muffled <- TRUE
[16:20:43.019]                           break
[16:20:43.019]                         }
[16:20:43.019]                       }
[16:20:43.019]                     }
[16:20:43.019]                     invisible(muffled)
[16:20:43.019]                   }
[16:20:43.019]                   muffleCondition(cond)
[16:20:43.019]                 })
[16:20:43.019]             }))
[16:20:43.019]             future::FutureResult(value = ...future.value$value, 
[16:20:43.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.019]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.019]                     ...future.globalenv.names))
[16:20:43.019]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.019]         }, condition = base::local({
[16:20:43.019]             c <- base::c
[16:20:43.019]             inherits <- base::inherits
[16:20:43.019]             invokeRestart <- base::invokeRestart
[16:20:43.019]             length <- base::length
[16:20:43.019]             list <- base::list
[16:20:43.019]             seq.int <- base::seq.int
[16:20:43.019]             signalCondition <- base::signalCondition
[16:20:43.019]             sys.calls <- base::sys.calls
[16:20:43.019]             `[[` <- base::`[[`
[16:20:43.019]             `+` <- base::`+`
[16:20:43.019]             `<<-` <- base::`<<-`
[16:20:43.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.019]                   3L)]
[16:20:43.019]             }
[16:20:43.019]             function(cond) {
[16:20:43.019]                 is_error <- inherits(cond, "error")
[16:20:43.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.019]                   NULL)
[16:20:43.019]                 if (is_error) {
[16:20:43.019]                   sessionInformation <- function() {
[16:20:43.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.019]                       search = base::search(), system = base::Sys.info())
[16:20:43.019]                   }
[16:20:43.019]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.019]                     cond$call), session = sessionInformation(), 
[16:20:43.019]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.019]                   signalCondition(cond)
[16:20:43.019]                 }
[16:20:43.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.019]                 "immediateCondition"))) {
[16:20:43.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.019]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.019]                   if (TRUE && !signal) {
[16:20:43.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.019]                     {
[16:20:43.019]                       inherits <- base::inherits
[16:20:43.019]                       invokeRestart <- base::invokeRestart
[16:20:43.019]                       is.null <- base::is.null
[16:20:43.019]                       muffled <- FALSE
[16:20:43.019]                       if (inherits(cond, "message")) {
[16:20:43.019]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.019]                         if (muffled) 
[16:20:43.019]                           invokeRestart("muffleMessage")
[16:20:43.019]                       }
[16:20:43.019]                       else if (inherits(cond, "warning")) {
[16:20:43.019]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.019]                         if (muffled) 
[16:20:43.019]                           invokeRestart("muffleWarning")
[16:20:43.019]                       }
[16:20:43.019]                       else if (inherits(cond, "condition")) {
[16:20:43.019]                         if (!is.null(pattern)) {
[16:20:43.019]                           computeRestarts <- base::computeRestarts
[16:20:43.019]                           grepl <- base::grepl
[16:20:43.019]                           restarts <- computeRestarts(cond)
[16:20:43.019]                           for (restart in restarts) {
[16:20:43.019]                             name <- restart$name
[16:20:43.019]                             if (is.null(name)) 
[16:20:43.019]                               next
[16:20:43.019]                             if (!grepl(pattern, name)) 
[16:20:43.019]                               next
[16:20:43.019]                             invokeRestart(restart)
[16:20:43.019]                             muffled <- TRUE
[16:20:43.019]                             break
[16:20:43.019]                           }
[16:20:43.019]                         }
[16:20:43.019]                       }
[16:20:43.019]                       invisible(muffled)
[16:20:43.019]                     }
[16:20:43.019]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.019]                   }
[16:20:43.019]                 }
[16:20:43.019]                 else {
[16:20:43.019]                   if (TRUE) {
[16:20:43.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.019]                     {
[16:20:43.019]                       inherits <- base::inherits
[16:20:43.019]                       invokeRestart <- base::invokeRestart
[16:20:43.019]                       is.null <- base::is.null
[16:20:43.019]                       muffled <- FALSE
[16:20:43.019]                       if (inherits(cond, "message")) {
[16:20:43.019]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.019]                         if (muffled) 
[16:20:43.019]                           invokeRestart("muffleMessage")
[16:20:43.019]                       }
[16:20:43.019]                       else if (inherits(cond, "warning")) {
[16:20:43.019]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.019]                         if (muffled) 
[16:20:43.019]                           invokeRestart("muffleWarning")
[16:20:43.019]                       }
[16:20:43.019]                       else if (inherits(cond, "condition")) {
[16:20:43.019]                         if (!is.null(pattern)) {
[16:20:43.019]                           computeRestarts <- base::computeRestarts
[16:20:43.019]                           grepl <- base::grepl
[16:20:43.019]                           restarts <- computeRestarts(cond)
[16:20:43.019]                           for (restart in restarts) {
[16:20:43.019]                             name <- restart$name
[16:20:43.019]                             if (is.null(name)) 
[16:20:43.019]                               next
[16:20:43.019]                             if (!grepl(pattern, name)) 
[16:20:43.019]                               next
[16:20:43.019]                             invokeRestart(restart)
[16:20:43.019]                             muffled <- TRUE
[16:20:43.019]                             break
[16:20:43.019]                           }
[16:20:43.019]                         }
[16:20:43.019]                       }
[16:20:43.019]                       invisible(muffled)
[16:20:43.019]                     }
[16:20:43.019]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.019]                   }
[16:20:43.019]                 }
[16:20:43.019]             }
[16:20:43.019]         }))
[16:20:43.019]     }, error = function(ex) {
[16:20:43.019]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.019]                 ...future.rng), started = ...future.startTime, 
[16:20:43.019]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.019]             version = "1.8"), class = "FutureResult")
[16:20:43.019]     }, finally = {
[16:20:43.019]         if (!identical(...future.workdir, getwd())) 
[16:20:43.019]             setwd(...future.workdir)
[16:20:43.019]         {
[16:20:43.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.019]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.019]             }
[16:20:43.019]             base::options(...future.oldOptions)
[16:20:43.019]             if (.Platform$OS.type == "windows") {
[16:20:43.019]                 old_names <- names(...future.oldEnvVars)
[16:20:43.019]                 envs <- base::Sys.getenv()
[16:20:43.019]                 names <- names(envs)
[16:20:43.019]                 common <- intersect(names, old_names)
[16:20:43.019]                 added <- setdiff(names, old_names)
[16:20:43.019]                 removed <- setdiff(old_names, names)
[16:20:43.019]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.019]                   envs[common]]
[16:20:43.019]                 NAMES <- toupper(changed)
[16:20:43.019]                 args <- list()
[16:20:43.019]                 for (kk in seq_along(NAMES)) {
[16:20:43.019]                   name <- changed[[kk]]
[16:20:43.019]                   NAME <- NAMES[[kk]]
[16:20:43.019]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.019]                     next
[16:20:43.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.019]                 }
[16:20:43.019]                 NAMES <- toupper(added)
[16:20:43.019]                 for (kk in seq_along(NAMES)) {
[16:20:43.019]                   name <- added[[kk]]
[16:20:43.019]                   NAME <- NAMES[[kk]]
[16:20:43.019]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.019]                     next
[16:20:43.019]                   args[[name]] <- ""
[16:20:43.019]                 }
[16:20:43.019]                 NAMES <- toupper(removed)
[16:20:43.019]                 for (kk in seq_along(NAMES)) {
[16:20:43.019]                   name <- removed[[kk]]
[16:20:43.019]                   NAME <- NAMES[[kk]]
[16:20:43.019]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.019]                     next
[16:20:43.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.019]                 }
[16:20:43.019]                 if (length(args) > 0) 
[16:20:43.019]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.019]             }
[16:20:43.019]             else {
[16:20:43.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.019]             }
[16:20:43.019]             {
[16:20:43.019]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.019]                   0L) {
[16:20:43.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.019]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.019]                   base::options(opts)
[16:20:43.019]                 }
[16:20:43.019]                 {
[16:20:43.019]                   {
[16:20:43.019]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.019]                     NULL
[16:20:43.019]                   }
[16:20:43.019]                   options(future.plan = NULL)
[16:20:43.019]                   if (is.na(NA_character_)) 
[16:20:43.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.019]                     .init = FALSE)
[16:20:43.019]                 }
[16:20:43.019]             }
[16:20:43.019]         }
[16:20:43.019]     })
[16:20:43.019]     if (TRUE) {
[16:20:43.019]         base::sink(type = "output", split = FALSE)
[16:20:43.019]         if (TRUE) {
[16:20:43.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.019]         }
[16:20:43.019]         else {
[16:20:43.019]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.019]         }
[16:20:43.019]         base::close(...future.stdout)
[16:20:43.019]         ...future.stdout <- NULL
[16:20:43.019]     }
[16:20:43.019]     ...future.result$conditions <- ...future.conditions
[16:20:43.019]     ...future.result$finished <- base::Sys.time()
[16:20:43.019]     ...future.result
[16:20:43.019] }
[16:20:43.022] MultisessionFuture started
[16:20:43.022] - Launch lazy future ... done
[16:20:43.022] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0d966480> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0dd6a750> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0d966480> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0dd6a750> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:20:43.028] receiveMessageFromWorker() for ClusterFuture ...
[16:20:43.028] - Validating connection of MultisessionFuture
[16:20:43.028] - received message: FutureResult
[16:20:43.029] - Received FutureResult
[16:20:43.029] - Erased future from FutureRegistry
[16:20:43.029] result() for ClusterFuture ...
[16:20:43.029] - result already collected: FutureResult
[16:20:43.031] result() for ClusterFuture ... done
[16:20:43.031] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:43.031] receiveMessageFromWorker() for ClusterFuture ...
[16:20:43.031] - Validating connection of MultisessionFuture
[16:20:43.032] - received message: FutureResult
[16:20:43.032] - Received FutureResult
[16:20:43.032] - Erased future from FutureRegistry
[16:20:43.032] result() for ClusterFuture ...
[16:20:43.032] - result already collected: FutureResult
[16:20:43.032] result() for ClusterFuture ... done
[16:20:43.032] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:43.034] resolve() on list ...
[16:20:43.034]  recursive: 0
[16:20:43.034]  length: 6
[16:20:43.034]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:43.034] signalConditionsASAP(numeric, pos=1) ...
[16:20:43.034] - nx: 6
[16:20:43.034] - relay: TRUE
[16:20:43.034] - stdout: TRUE
[16:20:43.034] - signal: TRUE
[16:20:43.034] - resignal: FALSE
[16:20:43.034] - force: TRUE
[16:20:43.035] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.035] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.035]  - until=2
[16:20:43.035]  - relaying element #2
[16:20:43.035] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.035] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.035] signalConditionsASAP(NULL, pos=1) ... done
[16:20:43.035]  length: 5 (resolved future 1)
[16:20:43.035] Future #2
[16:20:43.035] result() for ClusterFuture ...
[16:20:43.035] - result already collected: FutureResult
[16:20:43.036] result() for ClusterFuture ... done
[16:20:43.036] result() for ClusterFuture ...
[16:20:43.036] - result already collected: FutureResult
[16:20:43.036] result() for ClusterFuture ... done
[16:20:43.036] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:43.036] - nx: 6
[16:20:43.036] - relay: TRUE
[16:20:43.036] - stdout: TRUE
[16:20:43.036] - signal: TRUE
[16:20:43.036] - resignal: FALSE
[16:20:43.036] - force: TRUE
[16:20:43.037] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.037] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.037]  - until=2
[16:20:43.037]  - relaying element #2
[16:20:43.037] result() for ClusterFuture ...
[16:20:43.037] - result already collected: FutureResult
[16:20:43.037] result() for ClusterFuture ... done
[16:20:43.037] result() for ClusterFuture ...
[16:20:43.037] - result already collected: FutureResult
[16:20:43.037] result() for ClusterFuture ... done
[16:20:43.037] result() for ClusterFuture ...
[16:20:43.038] - result already collected: FutureResult
[16:20:43.038] result() for ClusterFuture ... done
[16:20:43.038] result() for ClusterFuture ...
[16:20:43.038] - result already collected: FutureResult
[16:20:43.038] result() for ClusterFuture ... done
[16:20:43.038] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.038] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.038] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:43.038]  length: 4 (resolved future 2)
[16:20:43.038] Future #3
[16:20:43.038] result() for ClusterFuture ...
[16:20:43.039] - result already collected: FutureResult
[16:20:43.039] result() for ClusterFuture ... done
[16:20:43.039] result() for ClusterFuture ...
[16:20:43.039] - result already collected: FutureResult
[16:20:43.039] result() for ClusterFuture ... done
[16:20:43.039] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:43.039] - nx: 6
[16:20:43.039] - relay: TRUE
[16:20:43.039] - stdout: TRUE
[16:20:43.039] - signal: TRUE
[16:20:43.039] - resignal: FALSE
[16:20:43.039] - force: TRUE
[16:20:43.039] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.040] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.040]  - until=3
[16:20:43.040]  - relaying element #3
[16:20:43.040] result() for ClusterFuture ...
[16:20:43.040] - result already collected: FutureResult
[16:20:43.040] result() for ClusterFuture ... done
[16:20:43.040] result() for ClusterFuture ...
[16:20:43.040] - result already collected: FutureResult
[16:20:43.040] result() for ClusterFuture ... done
[16:20:43.040] result() for ClusterFuture ...
[16:20:43.040] - result already collected: FutureResult
[16:20:43.041] result() for ClusterFuture ... done
[16:20:43.041] result() for ClusterFuture ...
[16:20:43.041] - result already collected: FutureResult
[16:20:43.041] result() for ClusterFuture ... done
[16:20:43.041] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.041] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.041] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:43.041]  length: 3 (resolved future 3)
[16:20:43.041] signalConditionsASAP(NULL, pos=4) ...
[16:20:43.041] - nx: 6
[16:20:43.041] - relay: TRUE
[16:20:43.041] - stdout: TRUE
[16:20:43.042] - signal: TRUE
[16:20:43.042] - resignal: FALSE
[16:20:43.042] - force: TRUE
[16:20:43.042] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.042] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.042]  - until=5
[16:20:43.042]  - relaying element #5
[16:20:43.042] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:43.042] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.042] signalConditionsASAP(NULL, pos=4) ... done
[16:20:43.042]  length: 2 (resolved future 4)
[16:20:43.042] signalConditionsASAP(NULL, pos=5) ...
[16:20:43.043] - nx: 6
[16:20:43.043] - relay: TRUE
[16:20:43.043] - stdout: TRUE
[16:20:43.043] - signal: TRUE
[16:20:43.043] - resignal: FALSE
[16:20:43.043] - force: TRUE
[16:20:43.043] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:43.043] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.043]  - until=6
[16:20:43.043]  - relaying element #6
[16:20:43.043] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:43.043] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.044] signalConditionsASAP(NULL, pos=5) ... done
[16:20:43.044]  length: 1 (resolved future 5)
[16:20:43.044] signalConditionsASAP(numeric, pos=6) ...
[16:20:43.044] - nx: 6
[16:20:43.044] - relay: TRUE
[16:20:43.044] - stdout: TRUE
[16:20:43.044] - signal: TRUE
[16:20:43.044] - resignal: FALSE
[16:20:43.044] - force: TRUE
[16:20:43.044] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:43.044] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.045]  - until=6
[16:20:43.045] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:43.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.045] signalConditionsASAP(numeric, pos=6) ... done
[16:20:43.045]  length: 0 (resolved future 6)
[16:20:43.045] Relaying remaining futures
[16:20:43.045] signalConditionsASAP(NULL, pos=0) ...
[16:20:43.045] - nx: 6
[16:20:43.045] - relay: TRUE
[16:20:43.045] - stdout: TRUE
[16:20:43.045] - signal: TRUE
[16:20:43.045] - resignal: FALSE
[16:20:43.046] - force: TRUE
[16:20:43.046] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:43.046] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:43.046] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:43.046] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.046] signalConditionsASAP(NULL, pos=0) ... done
[16:20:43.046] resolve() on list ... DONE
[16:20:43.046] result() for ClusterFuture ...
[16:20:43.046] - result already collected: FutureResult
[16:20:43.046] result() for ClusterFuture ... done
[16:20:43.046] result() for ClusterFuture ...
[16:20:43.047] - result already collected: FutureResult
[16:20:43.047] result() for ClusterFuture ... done
[16:20:43.047] result() for ClusterFuture ...
[16:20:43.047] - result already collected: FutureResult
[16:20:43.047] result() for ClusterFuture ... done
[16:20:43.047] result() for ClusterFuture ...
[16:20:43.047] - result already collected: FutureResult
[16:20:43.047] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:20:43.050] getGlobalsAndPackages() ...
[16:20:43.050] Searching for globals...
[16:20:43.051] 
[16:20:43.051] Searching for globals ... DONE
[16:20:43.051] - globals: [0] <none>
[16:20:43.051] getGlobalsAndPackages() ... DONE
[16:20:43.051] run() for ‘Future’ ...
[16:20:43.051] - state: ‘created’
[16:20:43.051] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.069] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:43.069]   - Field: ‘node’
[16:20:43.069]   - Field: ‘label’
[16:20:43.069]   - Field: ‘local’
[16:20:43.069]   - Field: ‘owner’
[16:20:43.069]   - Field: ‘envir’
[16:20:43.069]   - Field: ‘workers’
[16:20:43.069]   - Field: ‘packages’
[16:20:43.070]   - Field: ‘gc’
[16:20:43.070]   - Field: ‘conditions’
[16:20:43.070]   - Field: ‘persistent’
[16:20:43.070]   - Field: ‘expr’
[16:20:43.070]   - Field: ‘uuid’
[16:20:43.070]   - Field: ‘seed’
[16:20:43.070]   - Field: ‘version’
[16:20:43.070]   - Field: ‘result’
[16:20:43.070]   - Field: ‘asynchronous’
[16:20:43.070]   - Field: ‘calls’
[16:20:43.070]   - Field: ‘globals’
[16:20:43.071]   - Field: ‘stdout’
[16:20:43.071]   - Field: ‘earlySignal’
[16:20:43.071]   - Field: ‘lazy’
[16:20:43.071]   - Field: ‘state’
[16:20:43.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:43.071] - Launch lazy future ...
[16:20:43.071] Packages needed by the future expression (n = 0): <none>
[16:20:43.071] Packages needed by future strategies (n = 0): <none>
[16:20:43.072] {
[16:20:43.072]     {
[16:20:43.072]         {
[16:20:43.072]             ...future.startTime <- base::Sys.time()
[16:20:43.072]             {
[16:20:43.072]                 {
[16:20:43.072]                   {
[16:20:43.072]                     {
[16:20:43.072]                       base::local({
[16:20:43.072]                         has_future <- base::requireNamespace("future", 
[16:20:43.072]                           quietly = TRUE)
[16:20:43.072]                         if (has_future) {
[16:20:43.072]                           ns <- base::getNamespace("future")
[16:20:43.072]                           version <- ns[[".package"]][["version"]]
[16:20:43.072]                           if (is.null(version)) 
[16:20:43.072]                             version <- utils::packageVersion("future")
[16:20:43.072]                         }
[16:20:43.072]                         else {
[16:20:43.072]                           version <- NULL
[16:20:43.072]                         }
[16:20:43.072]                         if (!has_future || version < "1.8.0") {
[16:20:43.072]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.072]                             "", base::R.version$version.string), 
[16:20:43.072]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.072]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.072]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.072]                               "release", "version")], collapse = " "), 
[16:20:43.072]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.072]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.072]                             info)
[16:20:43.072]                           info <- base::paste(info, collapse = "; ")
[16:20:43.072]                           if (!has_future) {
[16:20:43.072]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.072]                               info)
[16:20:43.072]                           }
[16:20:43.072]                           else {
[16:20:43.072]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.072]                               info, version)
[16:20:43.072]                           }
[16:20:43.072]                           base::stop(msg)
[16:20:43.072]                         }
[16:20:43.072]                       })
[16:20:43.072]                     }
[16:20:43.072]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.072]                     base::options(mc.cores = 1L)
[16:20:43.072]                   }
[16:20:43.072]                   ...future.strategy.old <- future::plan("list")
[16:20:43.072]                   options(future.plan = NULL)
[16:20:43.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.072]                 }
[16:20:43.072]                 ...future.workdir <- getwd()
[16:20:43.072]             }
[16:20:43.072]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.072]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.072]         }
[16:20:43.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.072]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.072]             base::names(...future.oldOptions))
[16:20:43.072]     }
[16:20:43.072]     if (FALSE) {
[16:20:43.072]     }
[16:20:43.072]     else {
[16:20:43.072]         if (TRUE) {
[16:20:43.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.072]                 open = "w")
[16:20:43.072]         }
[16:20:43.072]         else {
[16:20:43.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.072]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.072]         }
[16:20:43.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.072]             base::sink(type = "output", split = FALSE)
[16:20:43.072]             base::close(...future.stdout)
[16:20:43.072]         }, add = TRUE)
[16:20:43.072]     }
[16:20:43.072]     ...future.frame <- base::sys.nframe()
[16:20:43.072]     ...future.conditions <- base::list()
[16:20:43.072]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.072]     if (FALSE) {
[16:20:43.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.072]     }
[16:20:43.072]     ...future.result <- base::tryCatch({
[16:20:43.072]         base::withCallingHandlers({
[16:20:43.072]             ...future.value <- base::withVisible(base::local({
[16:20:43.072]                 ...future.makeSendCondition <- base::local({
[16:20:43.072]                   sendCondition <- NULL
[16:20:43.072]                   function(frame = 1L) {
[16:20:43.072]                     if (is.function(sendCondition)) 
[16:20:43.072]                       return(sendCondition)
[16:20:43.072]                     ns <- getNamespace("parallel")
[16:20:43.072]                     if (exists("sendData", mode = "function", 
[16:20:43.072]                       envir = ns)) {
[16:20:43.072]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:43.072]                         envir = ns)
[16:20:43.072]                       envir <- sys.frame(frame)
[16:20:43.072]                       master <- NULL
[16:20:43.072]                       while (!identical(envir, .GlobalEnv) && 
[16:20:43.072]                         !identical(envir, emptyenv())) {
[16:20:43.072]                         if (exists("master", mode = "list", envir = envir, 
[16:20:43.072]                           inherits = FALSE)) {
[16:20:43.072]                           master <- get("master", mode = "list", 
[16:20:43.072]                             envir = envir, inherits = FALSE)
[16:20:43.072]                           if (inherits(master, c("SOCKnode", 
[16:20:43.072]                             "SOCK0node"))) {
[16:20:43.072]                             sendCondition <<- function(cond) {
[16:20:43.072]                               data <- list(type = "VALUE", value = cond, 
[16:20:43.072]                                 success = TRUE)
[16:20:43.072]                               parallel_sendData(master, data)
[16:20:43.072]                             }
[16:20:43.072]                             return(sendCondition)
[16:20:43.072]                           }
[16:20:43.072]                         }
[16:20:43.072]                         frame <- frame + 1L
[16:20:43.072]                         envir <- sys.frame(frame)
[16:20:43.072]                       }
[16:20:43.072]                     }
[16:20:43.072]                     sendCondition <<- function(cond) NULL
[16:20:43.072]                   }
[16:20:43.072]                 })
[16:20:43.072]                 withCallingHandlers({
[16:20:43.072]                   2
[16:20:43.072]                 }, immediateCondition = function(cond) {
[16:20:43.072]                   sendCondition <- ...future.makeSendCondition()
[16:20:43.072]                   sendCondition(cond)
[16:20:43.072]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.072]                   {
[16:20:43.072]                     inherits <- base::inherits
[16:20:43.072]                     invokeRestart <- base::invokeRestart
[16:20:43.072]                     is.null <- base::is.null
[16:20:43.072]                     muffled <- FALSE
[16:20:43.072]                     if (inherits(cond, "message")) {
[16:20:43.072]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.072]                       if (muffled) 
[16:20:43.072]                         invokeRestart("muffleMessage")
[16:20:43.072]                     }
[16:20:43.072]                     else if (inherits(cond, "warning")) {
[16:20:43.072]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.072]                       if (muffled) 
[16:20:43.072]                         invokeRestart("muffleWarning")
[16:20:43.072]                     }
[16:20:43.072]                     else if (inherits(cond, "condition")) {
[16:20:43.072]                       if (!is.null(pattern)) {
[16:20:43.072]                         computeRestarts <- base::computeRestarts
[16:20:43.072]                         grepl <- base::grepl
[16:20:43.072]                         restarts <- computeRestarts(cond)
[16:20:43.072]                         for (restart in restarts) {
[16:20:43.072]                           name <- restart$name
[16:20:43.072]                           if (is.null(name)) 
[16:20:43.072]                             next
[16:20:43.072]                           if (!grepl(pattern, name)) 
[16:20:43.072]                             next
[16:20:43.072]                           invokeRestart(restart)
[16:20:43.072]                           muffled <- TRUE
[16:20:43.072]                           break
[16:20:43.072]                         }
[16:20:43.072]                       }
[16:20:43.072]                     }
[16:20:43.072]                     invisible(muffled)
[16:20:43.072]                   }
[16:20:43.072]                   muffleCondition(cond)
[16:20:43.072]                 })
[16:20:43.072]             }))
[16:20:43.072]             future::FutureResult(value = ...future.value$value, 
[16:20:43.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.072]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.072]                     ...future.globalenv.names))
[16:20:43.072]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.072]         }, condition = base::local({
[16:20:43.072]             c <- base::c
[16:20:43.072]             inherits <- base::inherits
[16:20:43.072]             invokeRestart <- base::invokeRestart
[16:20:43.072]             length <- base::length
[16:20:43.072]             list <- base::list
[16:20:43.072]             seq.int <- base::seq.int
[16:20:43.072]             signalCondition <- base::signalCondition
[16:20:43.072]             sys.calls <- base::sys.calls
[16:20:43.072]             `[[` <- base::`[[`
[16:20:43.072]             `+` <- base::`+`
[16:20:43.072]             `<<-` <- base::`<<-`
[16:20:43.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.072]                   3L)]
[16:20:43.072]             }
[16:20:43.072]             function(cond) {
[16:20:43.072]                 is_error <- inherits(cond, "error")
[16:20:43.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.072]                   NULL)
[16:20:43.072]                 if (is_error) {
[16:20:43.072]                   sessionInformation <- function() {
[16:20:43.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.072]                       search = base::search(), system = base::Sys.info())
[16:20:43.072]                   }
[16:20:43.072]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.072]                     cond$call), session = sessionInformation(), 
[16:20:43.072]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.072]                   signalCondition(cond)
[16:20:43.072]                 }
[16:20:43.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.072]                 "immediateCondition"))) {
[16:20:43.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.072]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.072]                   if (TRUE && !signal) {
[16:20:43.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.072]                     {
[16:20:43.072]                       inherits <- base::inherits
[16:20:43.072]                       invokeRestart <- base::invokeRestart
[16:20:43.072]                       is.null <- base::is.null
[16:20:43.072]                       muffled <- FALSE
[16:20:43.072]                       if (inherits(cond, "message")) {
[16:20:43.072]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.072]                         if (muffled) 
[16:20:43.072]                           invokeRestart("muffleMessage")
[16:20:43.072]                       }
[16:20:43.072]                       else if (inherits(cond, "warning")) {
[16:20:43.072]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.072]                         if (muffled) 
[16:20:43.072]                           invokeRestart("muffleWarning")
[16:20:43.072]                       }
[16:20:43.072]                       else if (inherits(cond, "condition")) {
[16:20:43.072]                         if (!is.null(pattern)) {
[16:20:43.072]                           computeRestarts <- base::computeRestarts
[16:20:43.072]                           grepl <- base::grepl
[16:20:43.072]                           restarts <- computeRestarts(cond)
[16:20:43.072]                           for (restart in restarts) {
[16:20:43.072]                             name <- restart$name
[16:20:43.072]                             if (is.null(name)) 
[16:20:43.072]                               next
[16:20:43.072]                             if (!grepl(pattern, name)) 
[16:20:43.072]                               next
[16:20:43.072]                             invokeRestart(restart)
[16:20:43.072]                             muffled <- TRUE
[16:20:43.072]                             break
[16:20:43.072]                           }
[16:20:43.072]                         }
[16:20:43.072]                       }
[16:20:43.072]                       invisible(muffled)
[16:20:43.072]                     }
[16:20:43.072]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.072]                   }
[16:20:43.072]                 }
[16:20:43.072]                 else {
[16:20:43.072]                   if (TRUE) {
[16:20:43.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.072]                     {
[16:20:43.072]                       inherits <- base::inherits
[16:20:43.072]                       invokeRestart <- base::invokeRestart
[16:20:43.072]                       is.null <- base::is.null
[16:20:43.072]                       muffled <- FALSE
[16:20:43.072]                       if (inherits(cond, "message")) {
[16:20:43.072]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.072]                         if (muffled) 
[16:20:43.072]                           invokeRestart("muffleMessage")
[16:20:43.072]                       }
[16:20:43.072]                       else if (inherits(cond, "warning")) {
[16:20:43.072]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.072]                         if (muffled) 
[16:20:43.072]                           invokeRestart("muffleWarning")
[16:20:43.072]                       }
[16:20:43.072]                       else if (inherits(cond, "condition")) {
[16:20:43.072]                         if (!is.null(pattern)) {
[16:20:43.072]                           computeRestarts <- base::computeRestarts
[16:20:43.072]                           grepl <- base::grepl
[16:20:43.072]                           restarts <- computeRestarts(cond)
[16:20:43.072]                           for (restart in restarts) {
[16:20:43.072]                             name <- restart$name
[16:20:43.072]                             if (is.null(name)) 
[16:20:43.072]                               next
[16:20:43.072]                             if (!grepl(pattern, name)) 
[16:20:43.072]                               next
[16:20:43.072]                             invokeRestart(restart)
[16:20:43.072]                             muffled <- TRUE
[16:20:43.072]                             break
[16:20:43.072]                           }
[16:20:43.072]                         }
[16:20:43.072]                       }
[16:20:43.072]                       invisible(muffled)
[16:20:43.072]                     }
[16:20:43.072]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.072]                   }
[16:20:43.072]                 }
[16:20:43.072]             }
[16:20:43.072]         }))
[16:20:43.072]     }, error = function(ex) {
[16:20:43.072]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.072]                 ...future.rng), started = ...future.startTime, 
[16:20:43.072]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.072]             version = "1.8"), class = "FutureResult")
[16:20:43.072]     }, finally = {
[16:20:43.072]         if (!identical(...future.workdir, getwd())) 
[16:20:43.072]             setwd(...future.workdir)
[16:20:43.072]         {
[16:20:43.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.072]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.072]             }
[16:20:43.072]             base::options(...future.oldOptions)
[16:20:43.072]             if (.Platform$OS.type == "windows") {
[16:20:43.072]                 old_names <- names(...future.oldEnvVars)
[16:20:43.072]                 envs <- base::Sys.getenv()
[16:20:43.072]                 names <- names(envs)
[16:20:43.072]                 common <- intersect(names, old_names)
[16:20:43.072]                 added <- setdiff(names, old_names)
[16:20:43.072]                 removed <- setdiff(old_names, names)
[16:20:43.072]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.072]                   envs[common]]
[16:20:43.072]                 NAMES <- toupper(changed)
[16:20:43.072]                 args <- list()
[16:20:43.072]                 for (kk in seq_along(NAMES)) {
[16:20:43.072]                   name <- changed[[kk]]
[16:20:43.072]                   NAME <- NAMES[[kk]]
[16:20:43.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.072]                     next
[16:20:43.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.072]                 }
[16:20:43.072]                 NAMES <- toupper(added)
[16:20:43.072]                 for (kk in seq_along(NAMES)) {
[16:20:43.072]                   name <- added[[kk]]
[16:20:43.072]                   NAME <- NAMES[[kk]]
[16:20:43.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.072]                     next
[16:20:43.072]                   args[[name]] <- ""
[16:20:43.072]                 }
[16:20:43.072]                 NAMES <- toupper(removed)
[16:20:43.072]                 for (kk in seq_along(NAMES)) {
[16:20:43.072]                   name <- removed[[kk]]
[16:20:43.072]                   NAME <- NAMES[[kk]]
[16:20:43.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.072]                     next
[16:20:43.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.072]                 }
[16:20:43.072]                 if (length(args) > 0) 
[16:20:43.072]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.072]             }
[16:20:43.072]             else {
[16:20:43.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.072]             }
[16:20:43.072]             {
[16:20:43.072]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.072]                   0L) {
[16:20:43.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.072]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.072]                   base::options(opts)
[16:20:43.072]                 }
[16:20:43.072]                 {
[16:20:43.072]                   {
[16:20:43.072]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.072]                     NULL
[16:20:43.072]                   }
[16:20:43.072]                   options(future.plan = NULL)
[16:20:43.072]                   if (is.na(NA_character_)) 
[16:20:43.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.072]                     .init = FALSE)
[16:20:43.072]                 }
[16:20:43.072]             }
[16:20:43.072]         }
[16:20:43.072]     })
[16:20:43.072]     if (TRUE) {
[16:20:43.072]         base::sink(type = "output", split = FALSE)
[16:20:43.072]         if (TRUE) {
[16:20:43.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.072]         }
[16:20:43.072]         else {
[16:20:43.072]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.072]         }
[16:20:43.072]         base::close(...future.stdout)
[16:20:43.072]         ...future.stdout <- NULL
[16:20:43.072]     }
[16:20:43.072]     ...future.result$conditions <- ...future.conditions
[16:20:43.072]     ...future.result$finished <- base::Sys.time()
[16:20:43.072]     ...future.result
[16:20:43.072] }
[16:20:43.075] MultisessionFuture started
[16:20:43.075] - Launch lazy future ... done
[16:20:43.075] run() for ‘MultisessionFuture’ ... done
[16:20:43.075] getGlobalsAndPackages() ...
[16:20:43.075] Searching for globals...
[16:20:43.076] 
[16:20:43.076] Searching for globals ... DONE
[16:20:43.076] - globals: [0] <none>
[16:20:43.076] getGlobalsAndPackages() ... DONE
[16:20:43.077] run() for ‘Future’ ...
[16:20:43.077] - state: ‘created’
[16:20:43.077] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.091] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.091] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:43.091]   - Field: ‘node’
[16:20:43.091]   - Field: ‘label’
[16:20:43.091]   - Field: ‘local’
[16:20:43.091]   - Field: ‘owner’
[16:20:43.091]   - Field: ‘envir’
[16:20:43.091]   - Field: ‘workers’
[16:20:43.091]   - Field: ‘packages’
[16:20:43.092]   - Field: ‘gc’
[16:20:43.092]   - Field: ‘conditions’
[16:20:43.092]   - Field: ‘persistent’
[16:20:43.092]   - Field: ‘expr’
[16:20:43.092]   - Field: ‘uuid’
[16:20:43.092]   - Field: ‘seed’
[16:20:43.092]   - Field: ‘version’
[16:20:43.092]   - Field: ‘result’
[16:20:43.092]   - Field: ‘asynchronous’
[16:20:43.092]   - Field: ‘calls’
[16:20:43.092]   - Field: ‘globals’
[16:20:43.093]   - Field: ‘stdout’
[16:20:43.093]   - Field: ‘earlySignal’
[16:20:43.093]   - Field: ‘lazy’
[16:20:43.093]   - Field: ‘state’
[16:20:43.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:43.093] - Launch lazy future ...
[16:20:43.093] Packages needed by the future expression (n = 0): <none>
[16:20:43.093] Packages needed by future strategies (n = 0): <none>
[16:20:43.094] {
[16:20:43.094]     {
[16:20:43.094]         {
[16:20:43.094]             ...future.startTime <- base::Sys.time()
[16:20:43.094]             {
[16:20:43.094]                 {
[16:20:43.094]                   {
[16:20:43.094]                     {
[16:20:43.094]                       base::local({
[16:20:43.094]                         has_future <- base::requireNamespace("future", 
[16:20:43.094]                           quietly = TRUE)
[16:20:43.094]                         if (has_future) {
[16:20:43.094]                           ns <- base::getNamespace("future")
[16:20:43.094]                           version <- ns[[".package"]][["version"]]
[16:20:43.094]                           if (is.null(version)) 
[16:20:43.094]                             version <- utils::packageVersion("future")
[16:20:43.094]                         }
[16:20:43.094]                         else {
[16:20:43.094]                           version <- NULL
[16:20:43.094]                         }
[16:20:43.094]                         if (!has_future || version < "1.8.0") {
[16:20:43.094]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.094]                             "", base::R.version$version.string), 
[16:20:43.094]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.094]                               "release", "version")], collapse = " "), 
[16:20:43.094]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.094]                             info)
[16:20:43.094]                           info <- base::paste(info, collapse = "; ")
[16:20:43.094]                           if (!has_future) {
[16:20:43.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.094]                               info)
[16:20:43.094]                           }
[16:20:43.094]                           else {
[16:20:43.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.094]                               info, version)
[16:20:43.094]                           }
[16:20:43.094]                           base::stop(msg)
[16:20:43.094]                         }
[16:20:43.094]                       })
[16:20:43.094]                     }
[16:20:43.094]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.094]                     base::options(mc.cores = 1L)
[16:20:43.094]                   }
[16:20:43.094]                   ...future.strategy.old <- future::plan("list")
[16:20:43.094]                   options(future.plan = NULL)
[16:20:43.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.094]                 }
[16:20:43.094]                 ...future.workdir <- getwd()
[16:20:43.094]             }
[16:20:43.094]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.094]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.094]         }
[16:20:43.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.094]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.094]             base::names(...future.oldOptions))
[16:20:43.094]     }
[16:20:43.094]     if (FALSE) {
[16:20:43.094]     }
[16:20:43.094]     else {
[16:20:43.094]         if (TRUE) {
[16:20:43.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.094]                 open = "w")
[16:20:43.094]         }
[16:20:43.094]         else {
[16:20:43.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.094]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.094]         }
[16:20:43.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.094]             base::sink(type = "output", split = FALSE)
[16:20:43.094]             base::close(...future.stdout)
[16:20:43.094]         }, add = TRUE)
[16:20:43.094]     }
[16:20:43.094]     ...future.frame <- base::sys.nframe()
[16:20:43.094]     ...future.conditions <- base::list()
[16:20:43.094]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.094]     if (FALSE) {
[16:20:43.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.094]     }
[16:20:43.094]     ...future.result <- base::tryCatch({
[16:20:43.094]         base::withCallingHandlers({
[16:20:43.094]             ...future.value <- base::withVisible(base::local({
[16:20:43.094]                 ...future.makeSendCondition <- base::local({
[16:20:43.094]                   sendCondition <- NULL
[16:20:43.094]                   function(frame = 1L) {
[16:20:43.094]                     if (is.function(sendCondition)) 
[16:20:43.094]                       return(sendCondition)
[16:20:43.094]                     ns <- getNamespace("parallel")
[16:20:43.094]                     if (exists("sendData", mode = "function", 
[16:20:43.094]                       envir = ns)) {
[16:20:43.094]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:43.094]                         envir = ns)
[16:20:43.094]                       envir <- sys.frame(frame)
[16:20:43.094]                       master <- NULL
[16:20:43.094]                       while (!identical(envir, .GlobalEnv) && 
[16:20:43.094]                         !identical(envir, emptyenv())) {
[16:20:43.094]                         if (exists("master", mode = "list", envir = envir, 
[16:20:43.094]                           inherits = FALSE)) {
[16:20:43.094]                           master <- get("master", mode = "list", 
[16:20:43.094]                             envir = envir, inherits = FALSE)
[16:20:43.094]                           if (inherits(master, c("SOCKnode", 
[16:20:43.094]                             "SOCK0node"))) {
[16:20:43.094]                             sendCondition <<- function(cond) {
[16:20:43.094]                               data <- list(type = "VALUE", value = cond, 
[16:20:43.094]                                 success = TRUE)
[16:20:43.094]                               parallel_sendData(master, data)
[16:20:43.094]                             }
[16:20:43.094]                             return(sendCondition)
[16:20:43.094]                           }
[16:20:43.094]                         }
[16:20:43.094]                         frame <- frame + 1L
[16:20:43.094]                         envir <- sys.frame(frame)
[16:20:43.094]                       }
[16:20:43.094]                     }
[16:20:43.094]                     sendCondition <<- function(cond) NULL
[16:20:43.094]                   }
[16:20:43.094]                 })
[16:20:43.094]                 withCallingHandlers({
[16:20:43.094]                   NULL
[16:20:43.094]                 }, immediateCondition = function(cond) {
[16:20:43.094]                   sendCondition <- ...future.makeSendCondition()
[16:20:43.094]                   sendCondition(cond)
[16:20:43.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.094]                   {
[16:20:43.094]                     inherits <- base::inherits
[16:20:43.094]                     invokeRestart <- base::invokeRestart
[16:20:43.094]                     is.null <- base::is.null
[16:20:43.094]                     muffled <- FALSE
[16:20:43.094]                     if (inherits(cond, "message")) {
[16:20:43.094]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.094]                       if (muffled) 
[16:20:43.094]                         invokeRestart("muffleMessage")
[16:20:43.094]                     }
[16:20:43.094]                     else if (inherits(cond, "warning")) {
[16:20:43.094]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.094]                       if (muffled) 
[16:20:43.094]                         invokeRestart("muffleWarning")
[16:20:43.094]                     }
[16:20:43.094]                     else if (inherits(cond, "condition")) {
[16:20:43.094]                       if (!is.null(pattern)) {
[16:20:43.094]                         computeRestarts <- base::computeRestarts
[16:20:43.094]                         grepl <- base::grepl
[16:20:43.094]                         restarts <- computeRestarts(cond)
[16:20:43.094]                         for (restart in restarts) {
[16:20:43.094]                           name <- restart$name
[16:20:43.094]                           if (is.null(name)) 
[16:20:43.094]                             next
[16:20:43.094]                           if (!grepl(pattern, name)) 
[16:20:43.094]                             next
[16:20:43.094]                           invokeRestart(restart)
[16:20:43.094]                           muffled <- TRUE
[16:20:43.094]                           break
[16:20:43.094]                         }
[16:20:43.094]                       }
[16:20:43.094]                     }
[16:20:43.094]                     invisible(muffled)
[16:20:43.094]                   }
[16:20:43.094]                   muffleCondition(cond)
[16:20:43.094]                 })
[16:20:43.094]             }))
[16:20:43.094]             future::FutureResult(value = ...future.value$value, 
[16:20:43.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.094]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.094]                     ...future.globalenv.names))
[16:20:43.094]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.094]         }, condition = base::local({
[16:20:43.094]             c <- base::c
[16:20:43.094]             inherits <- base::inherits
[16:20:43.094]             invokeRestart <- base::invokeRestart
[16:20:43.094]             length <- base::length
[16:20:43.094]             list <- base::list
[16:20:43.094]             seq.int <- base::seq.int
[16:20:43.094]             signalCondition <- base::signalCondition
[16:20:43.094]             sys.calls <- base::sys.calls
[16:20:43.094]             `[[` <- base::`[[`
[16:20:43.094]             `+` <- base::`+`
[16:20:43.094]             `<<-` <- base::`<<-`
[16:20:43.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.094]                   3L)]
[16:20:43.094]             }
[16:20:43.094]             function(cond) {
[16:20:43.094]                 is_error <- inherits(cond, "error")
[16:20:43.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.094]                   NULL)
[16:20:43.094]                 if (is_error) {
[16:20:43.094]                   sessionInformation <- function() {
[16:20:43.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.094]                       search = base::search(), system = base::Sys.info())
[16:20:43.094]                   }
[16:20:43.094]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.094]                     cond$call), session = sessionInformation(), 
[16:20:43.094]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.094]                   signalCondition(cond)
[16:20:43.094]                 }
[16:20:43.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.094]                 "immediateCondition"))) {
[16:20:43.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.094]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.094]                   if (TRUE && !signal) {
[16:20:43.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.094]                     {
[16:20:43.094]                       inherits <- base::inherits
[16:20:43.094]                       invokeRestart <- base::invokeRestart
[16:20:43.094]                       is.null <- base::is.null
[16:20:43.094]                       muffled <- FALSE
[16:20:43.094]                       if (inherits(cond, "message")) {
[16:20:43.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.094]                         if (muffled) 
[16:20:43.094]                           invokeRestart("muffleMessage")
[16:20:43.094]                       }
[16:20:43.094]                       else if (inherits(cond, "warning")) {
[16:20:43.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.094]                         if (muffled) 
[16:20:43.094]                           invokeRestart("muffleWarning")
[16:20:43.094]                       }
[16:20:43.094]                       else if (inherits(cond, "condition")) {
[16:20:43.094]                         if (!is.null(pattern)) {
[16:20:43.094]                           computeRestarts <- base::computeRestarts
[16:20:43.094]                           grepl <- base::grepl
[16:20:43.094]                           restarts <- computeRestarts(cond)
[16:20:43.094]                           for (restart in restarts) {
[16:20:43.094]                             name <- restart$name
[16:20:43.094]                             if (is.null(name)) 
[16:20:43.094]                               next
[16:20:43.094]                             if (!grepl(pattern, name)) 
[16:20:43.094]                               next
[16:20:43.094]                             invokeRestart(restart)
[16:20:43.094]                             muffled <- TRUE
[16:20:43.094]                             break
[16:20:43.094]                           }
[16:20:43.094]                         }
[16:20:43.094]                       }
[16:20:43.094]                       invisible(muffled)
[16:20:43.094]                     }
[16:20:43.094]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.094]                   }
[16:20:43.094]                 }
[16:20:43.094]                 else {
[16:20:43.094]                   if (TRUE) {
[16:20:43.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.094]                     {
[16:20:43.094]                       inherits <- base::inherits
[16:20:43.094]                       invokeRestart <- base::invokeRestart
[16:20:43.094]                       is.null <- base::is.null
[16:20:43.094]                       muffled <- FALSE
[16:20:43.094]                       if (inherits(cond, "message")) {
[16:20:43.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.094]                         if (muffled) 
[16:20:43.094]                           invokeRestart("muffleMessage")
[16:20:43.094]                       }
[16:20:43.094]                       else if (inherits(cond, "warning")) {
[16:20:43.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.094]                         if (muffled) 
[16:20:43.094]                           invokeRestart("muffleWarning")
[16:20:43.094]                       }
[16:20:43.094]                       else if (inherits(cond, "condition")) {
[16:20:43.094]                         if (!is.null(pattern)) {
[16:20:43.094]                           computeRestarts <- base::computeRestarts
[16:20:43.094]                           grepl <- base::grepl
[16:20:43.094]                           restarts <- computeRestarts(cond)
[16:20:43.094]                           for (restart in restarts) {
[16:20:43.094]                             name <- restart$name
[16:20:43.094]                             if (is.null(name)) 
[16:20:43.094]                               next
[16:20:43.094]                             if (!grepl(pattern, name)) 
[16:20:43.094]                               next
[16:20:43.094]                             invokeRestart(restart)
[16:20:43.094]                             muffled <- TRUE
[16:20:43.094]                             break
[16:20:43.094]                           }
[16:20:43.094]                         }
[16:20:43.094]                       }
[16:20:43.094]                       invisible(muffled)
[16:20:43.094]                     }
[16:20:43.094]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.094]                   }
[16:20:43.094]                 }
[16:20:43.094]             }
[16:20:43.094]         }))
[16:20:43.094]     }, error = function(ex) {
[16:20:43.094]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.094]                 ...future.rng), started = ...future.startTime, 
[16:20:43.094]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.094]             version = "1.8"), class = "FutureResult")
[16:20:43.094]     }, finally = {
[16:20:43.094]         if (!identical(...future.workdir, getwd())) 
[16:20:43.094]             setwd(...future.workdir)
[16:20:43.094]         {
[16:20:43.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.094]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.094]             }
[16:20:43.094]             base::options(...future.oldOptions)
[16:20:43.094]             if (.Platform$OS.type == "windows") {
[16:20:43.094]                 old_names <- names(...future.oldEnvVars)
[16:20:43.094]                 envs <- base::Sys.getenv()
[16:20:43.094]                 names <- names(envs)
[16:20:43.094]                 common <- intersect(names, old_names)
[16:20:43.094]                 added <- setdiff(names, old_names)
[16:20:43.094]                 removed <- setdiff(old_names, names)
[16:20:43.094]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.094]                   envs[common]]
[16:20:43.094]                 NAMES <- toupper(changed)
[16:20:43.094]                 args <- list()
[16:20:43.094]                 for (kk in seq_along(NAMES)) {
[16:20:43.094]                   name <- changed[[kk]]
[16:20:43.094]                   NAME <- NAMES[[kk]]
[16:20:43.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.094]                     next
[16:20:43.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.094]                 }
[16:20:43.094]                 NAMES <- toupper(added)
[16:20:43.094]                 for (kk in seq_along(NAMES)) {
[16:20:43.094]                   name <- added[[kk]]
[16:20:43.094]                   NAME <- NAMES[[kk]]
[16:20:43.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.094]                     next
[16:20:43.094]                   args[[name]] <- ""
[16:20:43.094]                 }
[16:20:43.094]                 NAMES <- toupper(removed)
[16:20:43.094]                 for (kk in seq_along(NAMES)) {
[16:20:43.094]                   name <- removed[[kk]]
[16:20:43.094]                   NAME <- NAMES[[kk]]
[16:20:43.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.094]                     next
[16:20:43.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.094]                 }
[16:20:43.094]                 if (length(args) > 0) 
[16:20:43.094]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.094]             }
[16:20:43.094]             else {
[16:20:43.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.094]             }
[16:20:43.094]             {
[16:20:43.094]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.094]                   0L) {
[16:20:43.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.094]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.094]                   base::options(opts)
[16:20:43.094]                 }
[16:20:43.094]                 {
[16:20:43.094]                   {
[16:20:43.094]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.094]                     NULL
[16:20:43.094]                   }
[16:20:43.094]                   options(future.plan = NULL)
[16:20:43.094]                   if (is.na(NA_character_)) 
[16:20:43.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.094]                     .init = FALSE)
[16:20:43.094]                 }
[16:20:43.094]             }
[16:20:43.094]         }
[16:20:43.094]     })
[16:20:43.094]     if (TRUE) {
[16:20:43.094]         base::sink(type = "output", split = FALSE)
[16:20:43.094]         if (TRUE) {
[16:20:43.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.094]         }
[16:20:43.094]         else {
[16:20:43.094]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.094]         }
[16:20:43.094]         base::close(...future.stdout)
[16:20:43.094]         ...future.stdout <- NULL
[16:20:43.094]     }
[16:20:43.094]     ...future.result$conditions <- ...future.conditions
[16:20:43.094]     ...future.result$finished <- base::Sys.time()
[16:20:43.094]     ...future.result
[16:20:43.094] }
[16:20:43.097] MultisessionFuture started
[16:20:43.097] - Launch lazy future ... done
[16:20:43.097] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0b601018> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0cf963d8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0b601018> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0cf963d8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:43.102] receiveMessageFromWorker() for ClusterFuture ...
[16:20:43.103] - Validating connection of MultisessionFuture
[16:20:43.103] - received message: FutureResult
[16:20:43.103] - Received FutureResult
[16:20:43.103] - Erased future from FutureRegistry
[16:20:43.103] result() for ClusterFuture ...
[16:20:43.103] - result already collected: FutureResult
[16:20:43.103] result() for ClusterFuture ... done
[16:20:43.103] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:43.104] receiveMessageFromWorker() for ClusterFuture ...
[16:20:43.104] - Validating connection of MultisessionFuture
[16:20:43.104] - received message: FutureResult
[16:20:43.104] - Received FutureResult
[16:20:43.104] - Erased future from FutureRegistry
[16:20:43.104] result() for ClusterFuture ...
[16:20:43.104] - result already collected: FutureResult
[16:20:43.104] result() for ClusterFuture ... done
[16:20:43.105] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:43.106] resolve() on list ...
[16:20:43.106]  recursive: 0
[16:20:43.106]  length: 6
[16:20:43.107]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:43.107] signalConditionsASAP(numeric, pos=1) ...
[16:20:43.107] - nx: 6
[16:20:43.107] - relay: TRUE
[16:20:43.107] - stdout: TRUE
[16:20:43.107] - signal: TRUE
[16:20:43.107] - resignal: FALSE
[16:20:43.107] - force: TRUE
[16:20:43.107] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.107] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.107]  - until=2
[16:20:43.108]  - relaying element #2
[16:20:43.108] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.108] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.108] signalConditionsASAP(NULL, pos=1) ... done
[16:20:43.108]  length: 5 (resolved future 1)
[16:20:43.108] Future #2
[16:20:43.108] result() for ClusterFuture ...
[16:20:43.108] - result already collected: FutureResult
[16:20:43.108] result() for ClusterFuture ... done
[16:20:43.108] result() for ClusterFuture ...
[16:20:43.109] - result already collected: FutureResult
[16:20:43.109] result() for ClusterFuture ... done
[16:20:43.109] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:43.109] - nx: 6
[16:20:43.109] - relay: TRUE
[16:20:43.109] - stdout: TRUE
[16:20:43.109] - signal: TRUE
[16:20:43.109] - resignal: FALSE
[16:20:43.109] - force: TRUE
[16:20:43.109] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.109] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.110]  - until=2
[16:20:43.110]  - relaying element #2
[16:20:43.110] result() for ClusterFuture ...
[16:20:43.110] - result already collected: FutureResult
[16:20:43.110] result() for ClusterFuture ... done
[16:20:43.110] result() for ClusterFuture ...
[16:20:43.110] - result already collected: FutureResult
[16:20:43.110] result() for ClusterFuture ... done
[16:20:43.110] result() for ClusterFuture ...
[16:20:43.110] - result already collected: FutureResult
[16:20:43.110] result() for ClusterFuture ... done
[16:20:43.111] result() for ClusterFuture ...
[16:20:43.111] - result already collected: FutureResult
[16:20:43.111] result() for ClusterFuture ... done
[16:20:43.111] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.111] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.111] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:43.111]  length: 4 (resolved future 2)
[16:20:43.111] Future #3
[16:20:43.111] result() for ClusterFuture ...
[16:20:43.111] - result already collected: FutureResult
[16:20:43.111] result() for ClusterFuture ... done
[16:20:43.111] result() for ClusterFuture ...
[16:20:43.112] - result already collected: FutureResult
[16:20:43.112] result() for ClusterFuture ... done
[16:20:43.112] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:43.112] - nx: 6
[16:20:43.112] - relay: TRUE
[16:20:43.112] - stdout: TRUE
[16:20:43.112] - signal: TRUE
[16:20:43.112] - resignal: FALSE
[16:20:43.112] - force: TRUE
[16:20:43.112] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.112] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.113]  - until=3
[16:20:43.113]  - relaying element #3
[16:20:43.113] result() for ClusterFuture ...
[16:20:43.113] - result already collected: FutureResult
[16:20:43.113] result() for ClusterFuture ... done
[16:20:43.113] result() for ClusterFuture ...
[16:20:43.113] - result already collected: FutureResult
[16:20:43.113] result() for ClusterFuture ... done
[16:20:43.113] result() for ClusterFuture ...
[16:20:43.113] - result already collected: FutureResult
[16:20:43.113] result() for ClusterFuture ... done
[16:20:43.114] result() for ClusterFuture ...
[16:20:43.114] - result already collected: FutureResult
[16:20:43.114] result() for ClusterFuture ... done
[16:20:43.114] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.114] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.114] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:43.114]  length: 3 (resolved future 3)
[16:20:43.114] signalConditionsASAP(NULL, pos=4) ...
[16:20:43.114] - nx: 6
[16:20:43.114] - relay: TRUE
[16:20:43.114] - stdout: TRUE
[16:20:43.114] - signal: TRUE
[16:20:43.115] - resignal: FALSE
[16:20:43.115] - force: TRUE
[16:20:43.115] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.115] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.115]  - until=5
[16:20:43.115]  - relaying element #5
[16:20:43.115] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:43.115] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.115] signalConditionsASAP(NULL, pos=4) ... done
[16:20:43.115]  length: 2 (resolved future 4)
[16:20:43.115] signalConditionsASAP(NULL, pos=5) ...
[16:20:43.116] - nx: 6
[16:20:43.116] - relay: TRUE
[16:20:43.116] - stdout: TRUE
[16:20:43.116] - signal: TRUE
[16:20:43.116] - resignal: FALSE
[16:20:43.116] - force: TRUE
[16:20:43.116] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:43.116] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.116]  - until=6
[16:20:43.116]  - relaying element #6
[16:20:43.116] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:43.116] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.117] signalConditionsASAP(NULL, pos=5) ... done
[16:20:43.117]  length: 1 (resolved future 5)
[16:20:43.117] signalConditionsASAP(numeric, pos=6) ...
[16:20:43.117] - nx: 6
[16:20:43.117] - relay: TRUE
[16:20:43.117] - stdout: TRUE
[16:20:43.117] - signal: TRUE
[16:20:43.117] - resignal: FALSE
[16:20:43.117] - force: TRUE
[16:20:43.117] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:43.117] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.117]  - until=6
[16:20:43.118] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:43.118] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.118] signalConditionsASAP(numeric, pos=6) ... done
[16:20:43.118]  length: 0 (resolved future 6)
[16:20:43.118] Relaying remaining futures
[16:20:43.118] signalConditionsASAP(NULL, pos=0) ...
[16:20:43.118] - nx: 6
[16:20:43.118] - relay: TRUE
[16:20:43.118] - stdout: TRUE
[16:20:43.118] - signal: TRUE
[16:20:43.118] - resignal: FALSE
[16:20:43.118] - force: TRUE
[16:20:43.119] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:43.119] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:43.119] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:43.119] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.119] signalConditionsASAP(NULL, pos=0) ... done
[16:20:43.119] resolve() on list ... DONE
[16:20:43.119] result() for ClusterFuture ...
[16:20:43.119] - result already collected: FutureResult
[16:20:43.119] result() for ClusterFuture ... done
[16:20:43.119] result() for ClusterFuture ...
[16:20:43.119] - result already collected: FutureResult
[16:20:43.120] result() for ClusterFuture ... done
[16:20:43.120] result() for ClusterFuture ...
[16:20:43.120] - result already collected: FutureResult
[16:20:43.120] result() for ClusterFuture ... done
[16:20:43.120] result() for ClusterFuture ...
[16:20:43.120] - result already collected: FutureResult
[16:20:43.120] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:20:43.123] getGlobalsAndPackages() ...
[16:20:43.123] Searching for globals...
[16:20:43.124] 
[16:20:43.124] Searching for globals ... DONE
[16:20:43.124] - globals: [0] <none>
[16:20:43.124] getGlobalsAndPackages() ... DONE
[16:20:43.124] run() for ‘Future’ ...
[16:20:43.124] - state: ‘created’
[16:20:43.125] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.140] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:43.140]   - Field: ‘node’
[16:20:43.140]   - Field: ‘label’
[16:20:43.140]   - Field: ‘local’
[16:20:43.140]   - Field: ‘owner’
[16:20:43.141]   - Field: ‘envir’
[16:20:43.141]   - Field: ‘workers’
[16:20:43.141]   - Field: ‘packages’
[16:20:43.141]   - Field: ‘gc’
[16:20:43.141]   - Field: ‘conditions’
[16:20:43.141]   - Field: ‘persistent’
[16:20:43.141]   - Field: ‘expr’
[16:20:43.141]   - Field: ‘uuid’
[16:20:43.141]   - Field: ‘seed’
[16:20:43.141]   - Field: ‘version’
[16:20:43.141]   - Field: ‘result’
[16:20:43.141]   - Field: ‘asynchronous’
[16:20:43.142]   - Field: ‘calls’
[16:20:43.142]   - Field: ‘globals’
[16:20:43.142]   - Field: ‘stdout’
[16:20:43.142]   - Field: ‘earlySignal’
[16:20:43.142]   - Field: ‘lazy’
[16:20:43.142]   - Field: ‘state’
[16:20:43.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:43.142] - Launch lazy future ...
[16:20:43.142] Packages needed by the future expression (n = 0): <none>
[16:20:43.143] Packages needed by future strategies (n = 0): <none>
[16:20:43.143] {
[16:20:43.143]     {
[16:20:43.143]         {
[16:20:43.143]             ...future.startTime <- base::Sys.time()
[16:20:43.143]             {
[16:20:43.143]                 {
[16:20:43.143]                   {
[16:20:43.143]                     {
[16:20:43.143]                       base::local({
[16:20:43.143]                         has_future <- base::requireNamespace("future", 
[16:20:43.143]                           quietly = TRUE)
[16:20:43.143]                         if (has_future) {
[16:20:43.143]                           ns <- base::getNamespace("future")
[16:20:43.143]                           version <- ns[[".package"]][["version"]]
[16:20:43.143]                           if (is.null(version)) 
[16:20:43.143]                             version <- utils::packageVersion("future")
[16:20:43.143]                         }
[16:20:43.143]                         else {
[16:20:43.143]                           version <- NULL
[16:20:43.143]                         }
[16:20:43.143]                         if (!has_future || version < "1.8.0") {
[16:20:43.143]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.143]                             "", base::R.version$version.string), 
[16:20:43.143]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.143]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.143]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.143]                               "release", "version")], collapse = " "), 
[16:20:43.143]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.143]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.143]                             info)
[16:20:43.143]                           info <- base::paste(info, collapse = "; ")
[16:20:43.143]                           if (!has_future) {
[16:20:43.143]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.143]                               info)
[16:20:43.143]                           }
[16:20:43.143]                           else {
[16:20:43.143]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.143]                               info, version)
[16:20:43.143]                           }
[16:20:43.143]                           base::stop(msg)
[16:20:43.143]                         }
[16:20:43.143]                       })
[16:20:43.143]                     }
[16:20:43.143]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.143]                     base::options(mc.cores = 1L)
[16:20:43.143]                   }
[16:20:43.143]                   ...future.strategy.old <- future::plan("list")
[16:20:43.143]                   options(future.plan = NULL)
[16:20:43.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.143]                 }
[16:20:43.143]                 ...future.workdir <- getwd()
[16:20:43.143]             }
[16:20:43.143]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.143]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.143]         }
[16:20:43.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.143]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.143]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.143]             base::names(...future.oldOptions))
[16:20:43.143]     }
[16:20:43.143]     if (FALSE) {
[16:20:43.143]     }
[16:20:43.143]     else {
[16:20:43.143]         if (TRUE) {
[16:20:43.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.143]                 open = "w")
[16:20:43.143]         }
[16:20:43.143]         else {
[16:20:43.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.143]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.143]         }
[16:20:43.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.143]             base::sink(type = "output", split = FALSE)
[16:20:43.143]             base::close(...future.stdout)
[16:20:43.143]         }, add = TRUE)
[16:20:43.143]     }
[16:20:43.143]     ...future.frame <- base::sys.nframe()
[16:20:43.143]     ...future.conditions <- base::list()
[16:20:43.143]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.143]     if (FALSE) {
[16:20:43.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.143]     }
[16:20:43.143]     ...future.result <- base::tryCatch({
[16:20:43.143]         base::withCallingHandlers({
[16:20:43.143]             ...future.value <- base::withVisible(base::local({
[16:20:43.143]                 ...future.makeSendCondition <- base::local({
[16:20:43.143]                   sendCondition <- NULL
[16:20:43.143]                   function(frame = 1L) {
[16:20:43.143]                     if (is.function(sendCondition)) 
[16:20:43.143]                       return(sendCondition)
[16:20:43.143]                     ns <- getNamespace("parallel")
[16:20:43.143]                     if (exists("sendData", mode = "function", 
[16:20:43.143]                       envir = ns)) {
[16:20:43.143]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:43.143]                         envir = ns)
[16:20:43.143]                       envir <- sys.frame(frame)
[16:20:43.143]                       master <- NULL
[16:20:43.143]                       while (!identical(envir, .GlobalEnv) && 
[16:20:43.143]                         !identical(envir, emptyenv())) {
[16:20:43.143]                         if (exists("master", mode = "list", envir = envir, 
[16:20:43.143]                           inherits = FALSE)) {
[16:20:43.143]                           master <- get("master", mode = "list", 
[16:20:43.143]                             envir = envir, inherits = FALSE)
[16:20:43.143]                           if (inherits(master, c("SOCKnode", 
[16:20:43.143]                             "SOCK0node"))) {
[16:20:43.143]                             sendCondition <<- function(cond) {
[16:20:43.143]                               data <- list(type = "VALUE", value = cond, 
[16:20:43.143]                                 success = TRUE)
[16:20:43.143]                               parallel_sendData(master, data)
[16:20:43.143]                             }
[16:20:43.143]                             return(sendCondition)
[16:20:43.143]                           }
[16:20:43.143]                         }
[16:20:43.143]                         frame <- frame + 1L
[16:20:43.143]                         envir <- sys.frame(frame)
[16:20:43.143]                       }
[16:20:43.143]                     }
[16:20:43.143]                     sendCondition <<- function(cond) NULL
[16:20:43.143]                   }
[16:20:43.143]                 })
[16:20:43.143]                 withCallingHandlers({
[16:20:43.143]                   2
[16:20:43.143]                 }, immediateCondition = function(cond) {
[16:20:43.143]                   sendCondition <- ...future.makeSendCondition()
[16:20:43.143]                   sendCondition(cond)
[16:20:43.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.143]                   {
[16:20:43.143]                     inherits <- base::inherits
[16:20:43.143]                     invokeRestart <- base::invokeRestart
[16:20:43.143]                     is.null <- base::is.null
[16:20:43.143]                     muffled <- FALSE
[16:20:43.143]                     if (inherits(cond, "message")) {
[16:20:43.143]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.143]                       if (muffled) 
[16:20:43.143]                         invokeRestart("muffleMessage")
[16:20:43.143]                     }
[16:20:43.143]                     else if (inherits(cond, "warning")) {
[16:20:43.143]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.143]                       if (muffled) 
[16:20:43.143]                         invokeRestart("muffleWarning")
[16:20:43.143]                     }
[16:20:43.143]                     else if (inherits(cond, "condition")) {
[16:20:43.143]                       if (!is.null(pattern)) {
[16:20:43.143]                         computeRestarts <- base::computeRestarts
[16:20:43.143]                         grepl <- base::grepl
[16:20:43.143]                         restarts <- computeRestarts(cond)
[16:20:43.143]                         for (restart in restarts) {
[16:20:43.143]                           name <- restart$name
[16:20:43.143]                           if (is.null(name)) 
[16:20:43.143]                             next
[16:20:43.143]                           if (!grepl(pattern, name)) 
[16:20:43.143]                             next
[16:20:43.143]                           invokeRestart(restart)
[16:20:43.143]                           muffled <- TRUE
[16:20:43.143]                           break
[16:20:43.143]                         }
[16:20:43.143]                       }
[16:20:43.143]                     }
[16:20:43.143]                     invisible(muffled)
[16:20:43.143]                   }
[16:20:43.143]                   muffleCondition(cond)
[16:20:43.143]                 })
[16:20:43.143]             }))
[16:20:43.143]             future::FutureResult(value = ...future.value$value, 
[16:20:43.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.143]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.143]                     ...future.globalenv.names))
[16:20:43.143]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.143]         }, condition = base::local({
[16:20:43.143]             c <- base::c
[16:20:43.143]             inherits <- base::inherits
[16:20:43.143]             invokeRestart <- base::invokeRestart
[16:20:43.143]             length <- base::length
[16:20:43.143]             list <- base::list
[16:20:43.143]             seq.int <- base::seq.int
[16:20:43.143]             signalCondition <- base::signalCondition
[16:20:43.143]             sys.calls <- base::sys.calls
[16:20:43.143]             `[[` <- base::`[[`
[16:20:43.143]             `+` <- base::`+`
[16:20:43.143]             `<<-` <- base::`<<-`
[16:20:43.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.143]                   3L)]
[16:20:43.143]             }
[16:20:43.143]             function(cond) {
[16:20:43.143]                 is_error <- inherits(cond, "error")
[16:20:43.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.143]                   NULL)
[16:20:43.143]                 if (is_error) {
[16:20:43.143]                   sessionInformation <- function() {
[16:20:43.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.143]                       search = base::search(), system = base::Sys.info())
[16:20:43.143]                   }
[16:20:43.143]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.143]                     cond$call), session = sessionInformation(), 
[16:20:43.143]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.143]                   signalCondition(cond)
[16:20:43.143]                 }
[16:20:43.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.143]                 "immediateCondition"))) {
[16:20:43.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.143]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.143]                   if (TRUE && !signal) {
[16:20:43.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.143]                     {
[16:20:43.143]                       inherits <- base::inherits
[16:20:43.143]                       invokeRestart <- base::invokeRestart
[16:20:43.143]                       is.null <- base::is.null
[16:20:43.143]                       muffled <- FALSE
[16:20:43.143]                       if (inherits(cond, "message")) {
[16:20:43.143]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.143]                         if (muffled) 
[16:20:43.143]                           invokeRestart("muffleMessage")
[16:20:43.143]                       }
[16:20:43.143]                       else if (inherits(cond, "warning")) {
[16:20:43.143]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.143]                         if (muffled) 
[16:20:43.143]                           invokeRestart("muffleWarning")
[16:20:43.143]                       }
[16:20:43.143]                       else if (inherits(cond, "condition")) {
[16:20:43.143]                         if (!is.null(pattern)) {
[16:20:43.143]                           computeRestarts <- base::computeRestarts
[16:20:43.143]                           grepl <- base::grepl
[16:20:43.143]                           restarts <- computeRestarts(cond)
[16:20:43.143]                           for (restart in restarts) {
[16:20:43.143]                             name <- restart$name
[16:20:43.143]                             if (is.null(name)) 
[16:20:43.143]                               next
[16:20:43.143]                             if (!grepl(pattern, name)) 
[16:20:43.143]                               next
[16:20:43.143]                             invokeRestart(restart)
[16:20:43.143]                             muffled <- TRUE
[16:20:43.143]                             break
[16:20:43.143]                           }
[16:20:43.143]                         }
[16:20:43.143]                       }
[16:20:43.143]                       invisible(muffled)
[16:20:43.143]                     }
[16:20:43.143]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.143]                   }
[16:20:43.143]                 }
[16:20:43.143]                 else {
[16:20:43.143]                   if (TRUE) {
[16:20:43.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.143]                     {
[16:20:43.143]                       inherits <- base::inherits
[16:20:43.143]                       invokeRestart <- base::invokeRestart
[16:20:43.143]                       is.null <- base::is.null
[16:20:43.143]                       muffled <- FALSE
[16:20:43.143]                       if (inherits(cond, "message")) {
[16:20:43.143]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.143]                         if (muffled) 
[16:20:43.143]                           invokeRestart("muffleMessage")
[16:20:43.143]                       }
[16:20:43.143]                       else if (inherits(cond, "warning")) {
[16:20:43.143]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.143]                         if (muffled) 
[16:20:43.143]                           invokeRestart("muffleWarning")
[16:20:43.143]                       }
[16:20:43.143]                       else if (inherits(cond, "condition")) {
[16:20:43.143]                         if (!is.null(pattern)) {
[16:20:43.143]                           computeRestarts <- base::computeRestarts
[16:20:43.143]                           grepl <- base::grepl
[16:20:43.143]                           restarts <- computeRestarts(cond)
[16:20:43.143]                           for (restart in restarts) {
[16:20:43.143]                             name <- restart$name
[16:20:43.143]                             if (is.null(name)) 
[16:20:43.143]                               next
[16:20:43.143]                             if (!grepl(pattern, name)) 
[16:20:43.143]                               next
[16:20:43.143]                             invokeRestart(restart)
[16:20:43.143]                             muffled <- TRUE
[16:20:43.143]                             break
[16:20:43.143]                           }
[16:20:43.143]                         }
[16:20:43.143]                       }
[16:20:43.143]                       invisible(muffled)
[16:20:43.143]                     }
[16:20:43.143]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.143]                   }
[16:20:43.143]                 }
[16:20:43.143]             }
[16:20:43.143]         }))
[16:20:43.143]     }, error = function(ex) {
[16:20:43.143]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.143]                 ...future.rng), started = ...future.startTime, 
[16:20:43.143]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.143]             version = "1.8"), class = "FutureResult")
[16:20:43.143]     }, finally = {
[16:20:43.143]         if (!identical(...future.workdir, getwd())) 
[16:20:43.143]             setwd(...future.workdir)
[16:20:43.143]         {
[16:20:43.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.143]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.143]             }
[16:20:43.143]             base::options(...future.oldOptions)
[16:20:43.143]             if (.Platform$OS.type == "windows") {
[16:20:43.143]                 old_names <- names(...future.oldEnvVars)
[16:20:43.143]                 envs <- base::Sys.getenv()
[16:20:43.143]                 names <- names(envs)
[16:20:43.143]                 common <- intersect(names, old_names)
[16:20:43.143]                 added <- setdiff(names, old_names)
[16:20:43.143]                 removed <- setdiff(old_names, names)
[16:20:43.143]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.143]                   envs[common]]
[16:20:43.143]                 NAMES <- toupper(changed)
[16:20:43.143]                 args <- list()
[16:20:43.143]                 for (kk in seq_along(NAMES)) {
[16:20:43.143]                   name <- changed[[kk]]
[16:20:43.143]                   NAME <- NAMES[[kk]]
[16:20:43.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.143]                     next
[16:20:43.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.143]                 }
[16:20:43.143]                 NAMES <- toupper(added)
[16:20:43.143]                 for (kk in seq_along(NAMES)) {
[16:20:43.143]                   name <- added[[kk]]
[16:20:43.143]                   NAME <- NAMES[[kk]]
[16:20:43.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.143]                     next
[16:20:43.143]                   args[[name]] <- ""
[16:20:43.143]                 }
[16:20:43.143]                 NAMES <- toupper(removed)
[16:20:43.143]                 for (kk in seq_along(NAMES)) {
[16:20:43.143]                   name <- removed[[kk]]
[16:20:43.143]                   NAME <- NAMES[[kk]]
[16:20:43.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.143]                     next
[16:20:43.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.143]                 }
[16:20:43.143]                 if (length(args) > 0) 
[16:20:43.143]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.143]             }
[16:20:43.143]             else {
[16:20:43.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.143]             }
[16:20:43.143]             {
[16:20:43.143]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.143]                   0L) {
[16:20:43.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.143]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.143]                   base::options(opts)
[16:20:43.143]                 }
[16:20:43.143]                 {
[16:20:43.143]                   {
[16:20:43.143]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.143]                     NULL
[16:20:43.143]                   }
[16:20:43.143]                   options(future.plan = NULL)
[16:20:43.143]                   if (is.na(NA_character_)) 
[16:20:43.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.143]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.143]                     .init = FALSE)
[16:20:43.143]                 }
[16:20:43.143]             }
[16:20:43.143]         }
[16:20:43.143]     })
[16:20:43.143]     if (TRUE) {
[16:20:43.143]         base::sink(type = "output", split = FALSE)
[16:20:43.143]         if (TRUE) {
[16:20:43.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.143]         }
[16:20:43.143]         else {
[16:20:43.143]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.143]         }
[16:20:43.143]         base::close(...future.stdout)
[16:20:43.143]         ...future.stdout <- NULL
[16:20:43.143]     }
[16:20:43.143]     ...future.result$conditions <- ...future.conditions
[16:20:43.143]     ...future.result$finished <- base::Sys.time()
[16:20:43.143]     ...future.result
[16:20:43.143] }
[16:20:43.146] MultisessionFuture started
[16:20:43.146] - Launch lazy future ... done
[16:20:43.146] run() for ‘MultisessionFuture’ ... done
[16:20:43.146] getGlobalsAndPackages() ...
[16:20:43.147] Searching for globals...
[16:20:43.147] 
[16:20:43.147] Searching for globals ... DONE
[16:20:43.147] - globals: [0] <none>
[16:20:43.147] getGlobalsAndPackages() ... DONE
[16:20:43.148] run() for ‘Future’ ...
[16:20:43.148] - state: ‘created’
[16:20:43.148] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.161] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:43.162]   - Field: ‘node’
[16:20:43.162]   - Field: ‘label’
[16:20:43.162]   - Field: ‘local’
[16:20:43.162]   - Field: ‘owner’
[16:20:43.162]   - Field: ‘envir’
[16:20:43.162]   - Field: ‘workers’
[16:20:43.162]   - Field: ‘packages’
[16:20:43.162]   - Field: ‘gc’
[16:20:43.162]   - Field: ‘conditions’
[16:20:43.162]   - Field: ‘persistent’
[16:20:43.162]   - Field: ‘expr’
[16:20:43.163]   - Field: ‘uuid’
[16:20:43.163]   - Field: ‘seed’
[16:20:43.163]   - Field: ‘version’
[16:20:43.163]   - Field: ‘result’
[16:20:43.163]   - Field: ‘asynchronous’
[16:20:43.163]   - Field: ‘calls’
[16:20:43.163]   - Field: ‘globals’
[16:20:43.163]   - Field: ‘stdout’
[16:20:43.163]   - Field: ‘earlySignal’
[16:20:43.163]   - Field: ‘lazy’
[16:20:43.163]   - Field: ‘state’
[16:20:43.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:43.164] - Launch lazy future ...
[16:20:43.164] Packages needed by the future expression (n = 0): <none>
[16:20:43.164] Packages needed by future strategies (n = 0): <none>
[16:20:43.164] {
[16:20:43.164]     {
[16:20:43.164]         {
[16:20:43.164]             ...future.startTime <- base::Sys.time()
[16:20:43.164]             {
[16:20:43.164]                 {
[16:20:43.164]                   {
[16:20:43.164]                     {
[16:20:43.164]                       base::local({
[16:20:43.164]                         has_future <- base::requireNamespace("future", 
[16:20:43.164]                           quietly = TRUE)
[16:20:43.164]                         if (has_future) {
[16:20:43.164]                           ns <- base::getNamespace("future")
[16:20:43.164]                           version <- ns[[".package"]][["version"]]
[16:20:43.164]                           if (is.null(version)) 
[16:20:43.164]                             version <- utils::packageVersion("future")
[16:20:43.164]                         }
[16:20:43.164]                         else {
[16:20:43.164]                           version <- NULL
[16:20:43.164]                         }
[16:20:43.164]                         if (!has_future || version < "1.8.0") {
[16:20:43.164]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.164]                             "", base::R.version$version.string), 
[16:20:43.164]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.164]                               "release", "version")], collapse = " "), 
[16:20:43.164]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.164]                             info)
[16:20:43.164]                           info <- base::paste(info, collapse = "; ")
[16:20:43.164]                           if (!has_future) {
[16:20:43.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.164]                               info)
[16:20:43.164]                           }
[16:20:43.164]                           else {
[16:20:43.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.164]                               info, version)
[16:20:43.164]                           }
[16:20:43.164]                           base::stop(msg)
[16:20:43.164]                         }
[16:20:43.164]                       })
[16:20:43.164]                     }
[16:20:43.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.164]                     base::options(mc.cores = 1L)
[16:20:43.164]                   }
[16:20:43.164]                   ...future.strategy.old <- future::plan("list")
[16:20:43.164]                   options(future.plan = NULL)
[16:20:43.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.164]                 }
[16:20:43.164]                 ...future.workdir <- getwd()
[16:20:43.164]             }
[16:20:43.164]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.164]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.164]         }
[16:20:43.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.164]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.164]             base::names(...future.oldOptions))
[16:20:43.164]     }
[16:20:43.164]     if (FALSE) {
[16:20:43.164]     }
[16:20:43.164]     else {
[16:20:43.164]         if (TRUE) {
[16:20:43.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.164]                 open = "w")
[16:20:43.164]         }
[16:20:43.164]         else {
[16:20:43.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.164]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.164]         }
[16:20:43.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.164]             base::sink(type = "output", split = FALSE)
[16:20:43.164]             base::close(...future.stdout)
[16:20:43.164]         }, add = TRUE)
[16:20:43.164]     }
[16:20:43.164]     ...future.frame <- base::sys.nframe()
[16:20:43.164]     ...future.conditions <- base::list()
[16:20:43.164]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.164]     if (FALSE) {
[16:20:43.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.164]     }
[16:20:43.164]     ...future.result <- base::tryCatch({
[16:20:43.164]         base::withCallingHandlers({
[16:20:43.164]             ...future.value <- base::withVisible(base::local({
[16:20:43.164]                 ...future.makeSendCondition <- base::local({
[16:20:43.164]                   sendCondition <- NULL
[16:20:43.164]                   function(frame = 1L) {
[16:20:43.164]                     if (is.function(sendCondition)) 
[16:20:43.164]                       return(sendCondition)
[16:20:43.164]                     ns <- getNamespace("parallel")
[16:20:43.164]                     if (exists("sendData", mode = "function", 
[16:20:43.164]                       envir = ns)) {
[16:20:43.164]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:43.164]                         envir = ns)
[16:20:43.164]                       envir <- sys.frame(frame)
[16:20:43.164]                       master <- NULL
[16:20:43.164]                       while (!identical(envir, .GlobalEnv) && 
[16:20:43.164]                         !identical(envir, emptyenv())) {
[16:20:43.164]                         if (exists("master", mode = "list", envir = envir, 
[16:20:43.164]                           inherits = FALSE)) {
[16:20:43.164]                           master <- get("master", mode = "list", 
[16:20:43.164]                             envir = envir, inherits = FALSE)
[16:20:43.164]                           if (inherits(master, c("SOCKnode", 
[16:20:43.164]                             "SOCK0node"))) {
[16:20:43.164]                             sendCondition <<- function(cond) {
[16:20:43.164]                               data <- list(type = "VALUE", value = cond, 
[16:20:43.164]                                 success = TRUE)
[16:20:43.164]                               parallel_sendData(master, data)
[16:20:43.164]                             }
[16:20:43.164]                             return(sendCondition)
[16:20:43.164]                           }
[16:20:43.164]                         }
[16:20:43.164]                         frame <- frame + 1L
[16:20:43.164]                         envir <- sys.frame(frame)
[16:20:43.164]                       }
[16:20:43.164]                     }
[16:20:43.164]                     sendCondition <<- function(cond) NULL
[16:20:43.164]                   }
[16:20:43.164]                 })
[16:20:43.164]                 withCallingHandlers({
[16:20:43.164]                   NULL
[16:20:43.164]                 }, immediateCondition = function(cond) {
[16:20:43.164]                   sendCondition <- ...future.makeSendCondition()
[16:20:43.164]                   sendCondition(cond)
[16:20:43.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.164]                   {
[16:20:43.164]                     inherits <- base::inherits
[16:20:43.164]                     invokeRestart <- base::invokeRestart
[16:20:43.164]                     is.null <- base::is.null
[16:20:43.164]                     muffled <- FALSE
[16:20:43.164]                     if (inherits(cond, "message")) {
[16:20:43.164]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.164]                       if (muffled) 
[16:20:43.164]                         invokeRestart("muffleMessage")
[16:20:43.164]                     }
[16:20:43.164]                     else if (inherits(cond, "warning")) {
[16:20:43.164]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.164]                       if (muffled) 
[16:20:43.164]                         invokeRestart("muffleWarning")
[16:20:43.164]                     }
[16:20:43.164]                     else if (inherits(cond, "condition")) {
[16:20:43.164]                       if (!is.null(pattern)) {
[16:20:43.164]                         computeRestarts <- base::computeRestarts
[16:20:43.164]                         grepl <- base::grepl
[16:20:43.164]                         restarts <- computeRestarts(cond)
[16:20:43.164]                         for (restart in restarts) {
[16:20:43.164]                           name <- restart$name
[16:20:43.164]                           if (is.null(name)) 
[16:20:43.164]                             next
[16:20:43.164]                           if (!grepl(pattern, name)) 
[16:20:43.164]                             next
[16:20:43.164]                           invokeRestart(restart)
[16:20:43.164]                           muffled <- TRUE
[16:20:43.164]                           break
[16:20:43.164]                         }
[16:20:43.164]                       }
[16:20:43.164]                     }
[16:20:43.164]                     invisible(muffled)
[16:20:43.164]                   }
[16:20:43.164]                   muffleCondition(cond)
[16:20:43.164]                 })
[16:20:43.164]             }))
[16:20:43.164]             future::FutureResult(value = ...future.value$value, 
[16:20:43.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.164]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.164]                     ...future.globalenv.names))
[16:20:43.164]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.164]         }, condition = base::local({
[16:20:43.164]             c <- base::c
[16:20:43.164]             inherits <- base::inherits
[16:20:43.164]             invokeRestart <- base::invokeRestart
[16:20:43.164]             length <- base::length
[16:20:43.164]             list <- base::list
[16:20:43.164]             seq.int <- base::seq.int
[16:20:43.164]             signalCondition <- base::signalCondition
[16:20:43.164]             sys.calls <- base::sys.calls
[16:20:43.164]             `[[` <- base::`[[`
[16:20:43.164]             `+` <- base::`+`
[16:20:43.164]             `<<-` <- base::`<<-`
[16:20:43.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.164]                   3L)]
[16:20:43.164]             }
[16:20:43.164]             function(cond) {
[16:20:43.164]                 is_error <- inherits(cond, "error")
[16:20:43.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.164]                   NULL)
[16:20:43.164]                 if (is_error) {
[16:20:43.164]                   sessionInformation <- function() {
[16:20:43.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.164]                       search = base::search(), system = base::Sys.info())
[16:20:43.164]                   }
[16:20:43.164]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.164]                     cond$call), session = sessionInformation(), 
[16:20:43.164]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.164]                   signalCondition(cond)
[16:20:43.164]                 }
[16:20:43.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.164]                 "immediateCondition"))) {
[16:20:43.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.164]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.164]                   if (TRUE && !signal) {
[16:20:43.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.164]                     {
[16:20:43.164]                       inherits <- base::inherits
[16:20:43.164]                       invokeRestart <- base::invokeRestart
[16:20:43.164]                       is.null <- base::is.null
[16:20:43.164]                       muffled <- FALSE
[16:20:43.164]                       if (inherits(cond, "message")) {
[16:20:43.164]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.164]                         if (muffled) 
[16:20:43.164]                           invokeRestart("muffleMessage")
[16:20:43.164]                       }
[16:20:43.164]                       else if (inherits(cond, "warning")) {
[16:20:43.164]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.164]                         if (muffled) 
[16:20:43.164]                           invokeRestart("muffleWarning")
[16:20:43.164]                       }
[16:20:43.164]                       else if (inherits(cond, "condition")) {
[16:20:43.164]                         if (!is.null(pattern)) {
[16:20:43.164]                           computeRestarts <- base::computeRestarts
[16:20:43.164]                           grepl <- base::grepl
[16:20:43.164]                           restarts <- computeRestarts(cond)
[16:20:43.164]                           for (restart in restarts) {
[16:20:43.164]                             name <- restart$name
[16:20:43.164]                             if (is.null(name)) 
[16:20:43.164]                               next
[16:20:43.164]                             if (!grepl(pattern, name)) 
[16:20:43.164]                               next
[16:20:43.164]                             invokeRestart(restart)
[16:20:43.164]                             muffled <- TRUE
[16:20:43.164]                             break
[16:20:43.164]                           }
[16:20:43.164]                         }
[16:20:43.164]                       }
[16:20:43.164]                       invisible(muffled)
[16:20:43.164]                     }
[16:20:43.164]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.164]                   }
[16:20:43.164]                 }
[16:20:43.164]                 else {
[16:20:43.164]                   if (TRUE) {
[16:20:43.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.164]                     {
[16:20:43.164]                       inherits <- base::inherits
[16:20:43.164]                       invokeRestart <- base::invokeRestart
[16:20:43.164]                       is.null <- base::is.null
[16:20:43.164]                       muffled <- FALSE
[16:20:43.164]                       if (inherits(cond, "message")) {
[16:20:43.164]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.164]                         if (muffled) 
[16:20:43.164]                           invokeRestart("muffleMessage")
[16:20:43.164]                       }
[16:20:43.164]                       else if (inherits(cond, "warning")) {
[16:20:43.164]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.164]                         if (muffled) 
[16:20:43.164]                           invokeRestart("muffleWarning")
[16:20:43.164]                       }
[16:20:43.164]                       else if (inherits(cond, "condition")) {
[16:20:43.164]                         if (!is.null(pattern)) {
[16:20:43.164]                           computeRestarts <- base::computeRestarts
[16:20:43.164]                           grepl <- base::grepl
[16:20:43.164]                           restarts <- computeRestarts(cond)
[16:20:43.164]                           for (restart in restarts) {
[16:20:43.164]                             name <- restart$name
[16:20:43.164]                             if (is.null(name)) 
[16:20:43.164]                               next
[16:20:43.164]                             if (!grepl(pattern, name)) 
[16:20:43.164]                               next
[16:20:43.164]                             invokeRestart(restart)
[16:20:43.164]                             muffled <- TRUE
[16:20:43.164]                             break
[16:20:43.164]                           }
[16:20:43.164]                         }
[16:20:43.164]                       }
[16:20:43.164]                       invisible(muffled)
[16:20:43.164]                     }
[16:20:43.164]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.164]                   }
[16:20:43.164]                 }
[16:20:43.164]             }
[16:20:43.164]         }))
[16:20:43.164]     }, error = function(ex) {
[16:20:43.164]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.164]                 ...future.rng), started = ...future.startTime, 
[16:20:43.164]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.164]             version = "1.8"), class = "FutureResult")
[16:20:43.164]     }, finally = {
[16:20:43.164]         if (!identical(...future.workdir, getwd())) 
[16:20:43.164]             setwd(...future.workdir)
[16:20:43.164]         {
[16:20:43.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.164]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.164]             }
[16:20:43.164]             base::options(...future.oldOptions)
[16:20:43.164]             if (.Platform$OS.type == "windows") {
[16:20:43.164]                 old_names <- names(...future.oldEnvVars)
[16:20:43.164]                 envs <- base::Sys.getenv()
[16:20:43.164]                 names <- names(envs)
[16:20:43.164]                 common <- intersect(names, old_names)
[16:20:43.164]                 added <- setdiff(names, old_names)
[16:20:43.164]                 removed <- setdiff(old_names, names)
[16:20:43.164]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.164]                   envs[common]]
[16:20:43.164]                 NAMES <- toupper(changed)
[16:20:43.164]                 args <- list()
[16:20:43.164]                 for (kk in seq_along(NAMES)) {
[16:20:43.164]                   name <- changed[[kk]]
[16:20:43.164]                   NAME <- NAMES[[kk]]
[16:20:43.164]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.164]                     next
[16:20:43.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.164]                 }
[16:20:43.164]                 NAMES <- toupper(added)
[16:20:43.164]                 for (kk in seq_along(NAMES)) {
[16:20:43.164]                   name <- added[[kk]]
[16:20:43.164]                   NAME <- NAMES[[kk]]
[16:20:43.164]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.164]                     next
[16:20:43.164]                   args[[name]] <- ""
[16:20:43.164]                 }
[16:20:43.164]                 NAMES <- toupper(removed)
[16:20:43.164]                 for (kk in seq_along(NAMES)) {
[16:20:43.164]                   name <- removed[[kk]]
[16:20:43.164]                   NAME <- NAMES[[kk]]
[16:20:43.164]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.164]                     next
[16:20:43.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.164]                 }
[16:20:43.164]                 if (length(args) > 0) 
[16:20:43.164]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.164]             }
[16:20:43.164]             else {
[16:20:43.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.164]             }
[16:20:43.164]             {
[16:20:43.164]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.164]                   0L) {
[16:20:43.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.164]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.164]                   base::options(opts)
[16:20:43.164]                 }
[16:20:43.164]                 {
[16:20:43.164]                   {
[16:20:43.164]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.164]                     NULL
[16:20:43.164]                   }
[16:20:43.164]                   options(future.plan = NULL)
[16:20:43.164]                   if (is.na(NA_character_)) 
[16:20:43.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.164]                     .init = FALSE)
[16:20:43.164]                 }
[16:20:43.164]             }
[16:20:43.164]         }
[16:20:43.164]     })
[16:20:43.164]     if (TRUE) {
[16:20:43.164]         base::sink(type = "output", split = FALSE)
[16:20:43.164]         if (TRUE) {
[16:20:43.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.164]         }
[16:20:43.164]         else {
[16:20:43.164]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.164]         }
[16:20:43.164]         base::close(...future.stdout)
[16:20:43.164]         ...future.stdout <- NULL
[16:20:43.164]     }
[16:20:43.164]     ...future.result$conditions <- ...future.conditions
[16:20:43.164]     ...future.result$finished <- base::Sys.time()
[16:20:43.164]     ...future.result
[16:20:43.164] }
[16:20:43.167] MultisessionFuture started
[16:20:43.167] - Launch lazy future ... done
[16:20:43.167] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0e1e73d8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c6359d8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0e1e73d8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55ed0c6359d8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:43.173] receiveMessageFromWorker() for ClusterFuture ...
[16:20:43.173] - Validating connection of MultisessionFuture
[16:20:43.173] - received message: FutureResult
[16:20:43.173] - Received FutureResult
[16:20:43.174] - Erased future from FutureRegistry
[16:20:43.174] result() for ClusterFuture ...
[16:20:43.174] - result already collected: FutureResult
[16:20:43.174] result() for ClusterFuture ... done
[16:20:43.174] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:43.174] receiveMessageFromWorker() for ClusterFuture ...
[16:20:43.174] - Validating connection of MultisessionFuture
[16:20:43.175] - received message: FutureResult
[16:20:43.175] - Received FutureResult
[16:20:43.175] - Erased future from FutureRegistry
[16:20:43.175] result() for ClusterFuture ...
[16:20:43.175] - result already collected: FutureResult
[16:20:43.175] result() for ClusterFuture ... done
[16:20:43.175] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:20:43.177] resolve() on list ...
[16:20:43.177]  recursive: 0
[16:20:43.177]  length: 6
[16:20:43.177]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:20:43.178] signalConditionsASAP(numeric, pos=1) ...
[16:20:43.178] - nx: 6
[16:20:43.178] - relay: TRUE
[16:20:43.178] - stdout: TRUE
[16:20:43.178] - signal: TRUE
[16:20:43.178] - resignal: FALSE
[16:20:43.178] - force: TRUE
[16:20:43.178] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.178] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.178]  - until=2
[16:20:43.178]  - relaying element #2
[16:20:43.179] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.179] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.179] signalConditionsASAP(NULL, pos=1) ... done
[16:20:43.179]  length: 5 (resolved future 1)
[16:20:43.179] Future #2
[16:20:43.179] result() for ClusterFuture ...
[16:20:43.179] - result already collected: FutureResult
[16:20:43.179] result() for ClusterFuture ... done
[16:20:43.179] result() for ClusterFuture ...
[16:20:43.179] - result already collected: FutureResult
[16:20:43.179] result() for ClusterFuture ... done
[16:20:43.180] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:43.180] - nx: 6
[16:20:43.180] - relay: TRUE
[16:20:43.180] - stdout: TRUE
[16:20:43.180] - signal: TRUE
[16:20:43.180] - resignal: FALSE
[16:20:43.180] - force: TRUE
[16:20:43.180] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.180] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:43.180]  - until=2
[16:20:43.180]  - relaying element #2
[16:20:43.181] result() for ClusterFuture ...
[16:20:43.181] - result already collected: FutureResult
[16:20:43.181] result() for ClusterFuture ... done
[16:20:43.181] result() for ClusterFuture ...
[16:20:43.181] - result already collected: FutureResult
[16:20:43.181] result() for ClusterFuture ... done
[16:20:43.181] result() for ClusterFuture ...
[16:20:43.181] - result already collected: FutureResult
[16:20:43.181] result() for ClusterFuture ... done
[16:20:43.181] result() for ClusterFuture ...
[16:20:43.181] - result already collected: FutureResult
[16:20:43.182] result() for ClusterFuture ... done
[16:20:43.182] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.182] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.182] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:43.182]  length: 4 (resolved future 2)
[16:20:43.182] Future #3
[16:20:43.182] result() for ClusterFuture ...
[16:20:43.182] - result already collected: FutureResult
[16:20:43.182] result() for ClusterFuture ... done
[16:20:43.182] result() for ClusterFuture ...
[16:20:43.182] - result already collected: FutureResult
[16:20:43.183] result() for ClusterFuture ... done
[16:20:43.183] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:43.183] - nx: 6
[16:20:43.183] - relay: TRUE
[16:20:43.183] - stdout: TRUE
[16:20:43.183] - signal: TRUE
[16:20:43.183] - resignal: FALSE
[16:20:43.183] - force: TRUE
[16:20:43.183] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.183] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:43.183]  - until=3
[16:20:43.183]  - relaying element #3
[16:20:43.184] result() for ClusterFuture ...
[16:20:43.184] - result already collected: FutureResult
[16:20:43.184] result() for ClusterFuture ... done
[16:20:43.184] result() for ClusterFuture ...
[16:20:43.184] - result already collected: FutureResult
[16:20:43.184] result() for ClusterFuture ... done
[16:20:43.184] result() for ClusterFuture ...
[16:20:43.184] - result already collected: FutureResult
[16:20:43.184] result() for ClusterFuture ... done
[16:20:43.184] result() for ClusterFuture ...
[16:20:43.184] - result already collected: FutureResult
[16:20:43.185] result() for ClusterFuture ... done
[16:20:43.185] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.185] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.185] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:43.185]  length: 3 (resolved future 3)
[16:20:43.185] signalConditionsASAP(NULL, pos=4) ...
[16:20:43.185] - nx: 6
[16:20:43.185] - relay: TRUE
[16:20:43.185] - stdout: TRUE
[16:20:43.185] - signal: TRUE
[16:20:43.185] - resignal: FALSE
[16:20:43.186] - force: TRUE
[16:20:43.186] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.186] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.186]  - until=5
[16:20:43.186]  - relaying element #5
[16:20:43.186] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:43.186] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.186] signalConditionsASAP(NULL, pos=4) ... done
[16:20:43.186]  length: 2 (resolved future 4)
[16:20:43.186] signalConditionsASAP(NULL, pos=5) ...
[16:20:43.186] - nx: 6
[16:20:43.186] - relay: TRUE
[16:20:43.187] - stdout: TRUE
[16:20:43.187] - signal: TRUE
[16:20:43.187] - resignal: FALSE
[16:20:43.187] - force: TRUE
[16:20:43.187] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:43.187] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.187]  - until=6
[16:20:43.187]  - relaying element #6
[16:20:43.187] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:43.187] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.187] signalConditionsASAP(NULL, pos=5) ... done
[16:20:43.187]  length: 1 (resolved future 5)
[16:20:43.188] signalConditionsASAP(numeric, pos=6) ...
[16:20:43.188] - nx: 6
[16:20:43.188] - relay: TRUE
[16:20:43.188] - stdout: TRUE
[16:20:43.188] - signal: TRUE
[16:20:43.188] - resignal: FALSE
[16:20:43.188] - force: TRUE
[16:20:43.188] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:43.188] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.188]  - until=6
[16:20:43.188] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:43.189] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.189] signalConditionsASAP(numeric, pos=6) ... done
[16:20:43.189]  length: 0 (resolved future 6)
[16:20:43.189] Relaying remaining futures
[16:20:43.189] signalConditionsASAP(NULL, pos=0) ...
[16:20:43.189] - nx: 6
[16:20:43.189] - relay: TRUE
[16:20:43.189] - stdout: TRUE
[16:20:43.189] - signal: TRUE
[16:20:43.189] - resignal: FALSE
[16:20:43.189] - force: TRUE
[16:20:43.189] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:43.190] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:20:43.190] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:43.190] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:43.190] signalConditionsASAP(NULL, pos=0) ... done
[16:20:43.190] resolve() on list ... DONE
[16:20:43.190] result() for ClusterFuture ...
[16:20:43.190] - result already collected: FutureResult
[16:20:43.190] result() for ClusterFuture ... done
[16:20:43.190] result() for ClusterFuture ...
[16:20:43.190] - result already collected: FutureResult
[16:20:43.190] result() for ClusterFuture ... done
[16:20:43.191] result() for ClusterFuture ...
[16:20:43.191] - result already collected: FutureResult
[16:20:43.191] result() for ClusterFuture ... done
[16:20:43.191] result() for ClusterFuture ...
[16:20:43.191] - result already collected: FutureResult
[16:20:43.191] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[16:20:43.195] plan(): Setting new future strategy stack:
[16:20:43.195] List of future strategies:
[16:20:43.195] 1. multicore:
[16:20:43.195]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.195]    - tweaked: FALSE
[16:20:43.195]    - call: plan(strategy)
[16:20:43.200] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:20:43.201] getGlobalsAndPackages() ...
[16:20:43.201] Searching for globals...
[16:20:43.201] 
[16:20:43.201] Searching for globals ... DONE
[16:20:43.201] - globals: [0] <none>
[16:20:43.202] getGlobalsAndPackages() ... DONE
[16:20:43.202] run() for ‘Future’ ...
[16:20:43.202] - state: ‘created’
[16:20:43.202] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.206] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.206] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.206]   - Field: ‘label’
[16:20:43.206]   - Field: ‘local’
[16:20:43.207]   - Field: ‘owner’
[16:20:43.207]   - Field: ‘envir’
[16:20:43.207]   - Field: ‘workers’
[16:20:43.207]   - Field: ‘packages’
[16:20:43.207]   - Field: ‘gc’
[16:20:43.207]   - Field: ‘job’
[16:20:43.207]   - Field: ‘conditions’
[16:20:43.207]   - Field: ‘expr’
[16:20:43.207]   - Field: ‘uuid’
[16:20:43.208]   - Field: ‘seed’
[16:20:43.208]   - Field: ‘version’
[16:20:43.208]   - Field: ‘result’
[16:20:43.208]   - Field: ‘asynchronous’
[16:20:43.208]   - Field: ‘calls’
[16:20:43.208]   - Field: ‘globals’
[16:20:43.208]   - Field: ‘stdout’
[16:20:43.208]   - Field: ‘earlySignal’
[16:20:43.209]   - Field: ‘lazy’
[16:20:43.209]   - Field: ‘state’
[16:20:43.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.209] - Launch lazy future ...
[16:20:43.209] Packages needed by the future expression (n = 0): <none>
[16:20:43.209] Packages needed by future strategies (n = 0): <none>
[16:20:43.210] {
[16:20:43.210]     {
[16:20:43.210]         {
[16:20:43.210]             ...future.startTime <- base::Sys.time()
[16:20:43.210]             {
[16:20:43.210]                 {
[16:20:43.210]                   {
[16:20:43.210]                     {
[16:20:43.210]                       base::local({
[16:20:43.210]                         has_future <- base::requireNamespace("future", 
[16:20:43.210]                           quietly = TRUE)
[16:20:43.210]                         if (has_future) {
[16:20:43.210]                           ns <- base::getNamespace("future")
[16:20:43.210]                           version <- ns[[".package"]][["version"]]
[16:20:43.210]                           if (is.null(version)) 
[16:20:43.210]                             version <- utils::packageVersion("future")
[16:20:43.210]                         }
[16:20:43.210]                         else {
[16:20:43.210]                           version <- NULL
[16:20:43.210]                         }
[16:20:43.210]                         if (!has_future || version < "1.8.0") {
[16:20:43.210]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.210]                             "", base::R.version$version.string), 
[16:20:43.210]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.210]                               "release", "version")], collapse = " "), 
[16:20:43.210]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.210]                             info)
[16:20:43.210]                           info <- base::paste(info, collapse = "; ")
[16:20:43.210]                           if (!has_future) {
[16:20:43.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.210]                               info)
[16:20:43.210]                           }
[16:20:43.210]                           else {
[16:20:43.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.210]                               info, version)
[16:20:43.210]                           }
[16:20:43.210]                           base::stop(msg)
[16:20:43.210]                         }
[16:20:43.210]                       })
[16:20:43.210]                     }
[16:20:43.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.210]                     base::options(mc.cores = 1L)
[16:20:43.210]                   }
[16:20:43.210]                   ...future.strategy.old <- future::plan("list")
[16:20:43.210]                   options(future.plan = NULL)
[16:20:43.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.210]                 }
[16:20:43.210]                 ...future.workdir <- getwd()
[16:20:43.210]             }
[16:20:43.210]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.210]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.210]         }
[16:20:43.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.210]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.210]             base::names(...future.oldOptions))
[16:20:43.210]     }
[16:20:43.210]     if (FALSE) {
[16:20:43.210]     }
[16:20:43.210]     else {
[16:20:43.210]         if (TRUE) {
[16:20:43.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.210]                 open = "w")
[16:20:43.210]         }
[16:20:43.210]         else {
[16:20:43.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.210]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.210]         }
[16:20:43.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.210]             base::sink(type = "output", split = FALSE)
[16:20:43.210]             base::close(...future.stdout)
[16:20:43.210]         }, add = TRUE)
[16:20:43.210]     }
[16:20:43.210]     ...future.frame <- base::sys.nframe()
[16:20:43.210]     ...future.conditions <- base::list()
[16:20:43.210]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.210]     if (FALSE) {
[16:20:43.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.210]     }
[16:20:43.210]     ...future.result <- base::tryCatch({
[16:20:43.210]         base::withCallingHandlers({
[16:20:43.210]             ...future.value <- base::withVisible(base::local({
[16:20:43.210]                 withCallingHandlers({
[16:20:43.210]                   2
[16:20:43.210]                 }, immediateCondition = function(cond) {
[16:20:43.210]                   save_rds <- function (object, pathname, ...) 
[16:20:43.210]                   {
[16:20:43.210]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.210]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.210]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.210]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.210]                         fi_tmp[["mtime"]])
[16:20:43.210]                     }
[16:20:43.210]                     tryCatch({
[16:20:43.210]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.210]                     }, error = function(ex) {
[16:20:43.210]                       msg <- conditionMessage(ex)
[16:20:43.210]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.210]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.210]                         fi_tmp[["mtime"]], msg)
[16:20:43.210]                       ex$message <- msg
[16:20:43.210]                       stop(ex)
[16:20:43.210]                     })
[16:20:43.210]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.210]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.210]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.210]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.210]                       fi <- file.info(pathname)
[16:20:43.210]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.210]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.210]                         fi[["size"]], fi[["mtime"]])
[16:20:43.210]                       stop(msg)
[16:20:43.210]                     }
[16:20:43.210]                     invisible(pathname)
[16:20:43.210]                   }
[16:20:43.210]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.210]                     rootPath = tempdir()) 
[16:20:43.210]                   {
[16:20:43.210]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.210]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.210]                       tmpdir = path, fileext = ".rds")
[16:20:43.210]                     save_rds(obj, file)
[16:20:43.210]                   }
[16:20:43.210]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.210]                   {
[16:20:43.210]                     inherits <- base::inherits
[16:20:43.210]                     invokeRestart <- base::invokeRestart
[16:20:43.210]                     is.null <- base::is.null
[16:20:43.210]                     muffled <- FALSE
[16:20:43.210]                     if (inherits(cond, "message")) {
[16:20:43.210]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.210]                       if (muffled) 
[16:20:43.210]                         invokeRestart("muffleMessage")
[16:20:43.210]                     }
[16:20:43.210]                     else if (inherits(cond, "warning")) {
[16:20:43.210]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.210]                       if (muffled) 
[16:20:43.210]                         invokeRestart("muffleWarning")
[16:20:43.210]                     }
[16:20:43.210]                     else if (inherits(cond, "condition")) {
[16:20:43.210]                       if (!is.null(pattern)) {
[16:20:43.210]                         computeRestarts <- base::computeRestarts
[16:20:43.210]                         grepl <- base::grepl
[16:20:43.210]                         restarts <- computeRestarts(cond)
[16:20:43.210]                         for (restart in restarts) {
[16:20:43.210]                           name <- restart$name
[16:20:43.210]                           if (is.null(name)) 
[16:20:43.210]                             next
[16:20:43.210]                           if (!grepl(pattern, name)) 
[16:20:43.210]                             next
[16:20:43.210]                           invokeRestart(restart)
[16:20:43.210]                           muffled <- TRUE
[16:20:43.210]                           break
[16:20:43.210]                         }
[16:20:43.210]                       }
[16:20:43.210]                     }
[16:20:43.210]                     invisible(muffled)
[16:20:43.210]                   }
[16:20:43.210]                   muffleCondition(cond)
[16:20:43.210]                 })
[16:20:43.210]             }))
[16:20:43.210]             future::FutureResult(value = ...future.value$value, 
[16:20:43.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.210]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.210]                     ...future.globalenv.names))
[16:20:43.210]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.210]         }, condition = base::local({
[16:20:43.210]             c <- base::c
[16:20:43.210]             inherits <- base::inherits
[16:20:43.210]             invokeRestart <- base::invokeRestart
[16:20:43.210]             length <- base::length
[16:20:43.210]             list <- base::list
[16:20:43.210]             seq.int <- base::seq.int
[16:20:43.210]             signalCondition <- base::signalCondition
[16:20:43.210]             sys.calls <- base::sys.calls
[16:20:43.210]             `[[` <- base::`[[`
[16:20:43.210]             `+` <- base::`+`
[16:20:43.210]             `<<-` <- base::`<<-`
[16:20:43.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.210]                   3L)]
[16:20:43.210]             }
[16:20:43.210]             function(cond) {
[16:20:43.210]                 is_error <- inherits(cond, "error")
[16:20:43.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.210]                   NULL)
[16:20:43.210]                 if (is_error) {
[16:20:43.210]                   sessionInformation <- function() {
[16:20:43.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.210]                       search = base::search(), system = base::Sys.info())
[16:20:43.210]                   }
[16:20:43.210]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.210]                     cond$call), session = sessionInformation(), 
[16:20:43.210]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.210]                   signalCondition(cond)
[16:20:43.210]                 }
[16:20:43.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.210]                 "immediateCondition"))) {
[16:20:43.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.210]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.210]                   if (TRUE && !signal) {
[16:20:43.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.210]                     {
[16:20:43.210]                       inherits <- base::inherits
[16:20:43.210]                       invokeRestart <- base::invokeRestart
[16:20:43.210]                       is.null <- base::is.null
[16:20:43.210]                       muffled <- FALSE
[16:20:43.210]                       if (inherits(cond, "message")) {
[16:20:43.210]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.210]                         if (muffled) 
[16:20:43.210]                           invokeRestart("muffleMessage")
[16:20:43.210]                       }
[16:20:43.210]                       else if (inherits(cond, "warning")) {
[16:20:43.210]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.210]                         if (muffled) 
[16:20:43.210]                           invokeRestart("muffleWarning")
[16:20:43.210]                       }
[16:20:43.210]                       else if (inherits(cond, "condition")) {
[16:20:43.210]                         if (!is.null(pattern)) {
[16:20:43.210]                           computeRestarts <- base::computeRestarts
[16:20:43.210]                           grepl <- base::grepl
[16:20:43.210]                           restarts <- computeRestarts(cond)
[16:20:43.210]                           for (restart in restarts) {
[16:20:43.210]                             name <- restart$name
[16:20:43.210]                             if (is.null(name)) 
[16:20:43.210]                               next
[16:20:43.210]                             if (!grepl(pattern, name)) 
[16:20:43.210]                               next
[16:20:43.210]                             invokeRestart(restart)
[16:20:43.210]                             muffled <- TRUE
[16:20:43.210]                             break
[16:20:43.210]                           }
[16:20:43.210]                         }
[16:20:43.210]                       }
[16:20:43.210]                       invisible(muffled)
[16:20:43.210]                     }
[16:20:43.210]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.210]                   }
[16:20:43.210]                 }
[16:20:43.210]                 else {
[16:20:43.210]                   if (TRUE) {
[16:20:43.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.210]                     {
[16:20:43.210]                       inherits <- base::inherits
[16:20:43.210]                       invokeRestart <- base::invokeRestart
[16:20:43.210]                       is.null <- base::is.null
[16:20:43.210]                       muffled <- FALSE
[16:20:43.210]                       if (inherits(cond, "message")) {
[16:20:43.210]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.210]                         if (muffled) 
[16:20:43.210]                           invokeRestart("muffleMessage")
[16:20:43.210]                       }
[16:20:43.210]                       else if (inherits(cond, "warning")) {
[16:20:43.210]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.210]                         if (muffled) 
[16:20:43.210]                           invokeRestart("muffleWarning")
[16:20:43.210]                       }
[16:20:43.210]                       else if (inherits(cond, "condition")) {
[16:20:43.210]                         if (!is.null(pattern)) {
[16:20:43.210]                           computeRestarts <- base::computeRestarts
[16:20:43.210]                           grepl <- base::grepl
[16:20:43.210]                           restarts <- computeRestarts(cond)
[16:20:43.210]                           for (restart in restarts) {
[16:20:43.210]                             name <- restart$name
[16:20:43.210]                             if (is.null(name)) 
[16:20:43.210]                               next
[16:20:43.210]                             if (!grepl(pattern, name)) 
[16:20:43.210]                               next
[16:20:43.210]                             invokeRestart(restart)
[16:20:43.210]                             muffled <- TRUE
[16:20:43.210]                             break
[16:20:43.210]                           }
[16:20:43.210]                         }
[16:20:43.210]                       }
[16:20:43.210]                       invisible(muffled)
[16:20:43.210]                     }
[16:20:43.210]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.210]                   }
[16:20:43.210]                 }
[16:20:43.210]             }
[16:20:43.210]         }))
[16:20:43.210]     }, error = function(ex) {
[16:20:43.210]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.210]                 ...future.rng), started = ...future.startTime, 
[16:20:43.210]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.210]             version = "1.8"), class = "FutureResult")
[16:20:43.210]     }, finally = {
[16:20:43.210]         if (!identical(...future.workdir, getwd())) 
[16:20:43.210]             setwd(...future.workdir)
[16:20:43.210]         {
[16:20:43.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.210]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.210]             }
[16:20:43.210]             base::options(...future.oldOptions)
[16:20:43.210]             if (.Platform$OS.type == "windows") {
[16:20:43.210]                 old_names <- names(...future.oldEnvVars)
[16:20:43.210]                 envs <- base::Sys.getenv()
[16:20:43.210]                 names <- names(envs)
[16:20:43.210]                 common <- intersect(names, old_names)
[16:20:43.210]                 added <- setdiff(names, old_names)
[16:20:43.210]                 removed <- setdiff(old_names, names)
[16:20:43.210]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.210]                   envs[common]]
[16:20:43.210]                 NAMES <- toupper(changed)
[16:20:43.210]                 args <- list()
[16:20:43.210]                 for (kk in seq_along(NAMES)) {
[16:20:43.210]                   name <- changed[[kk]]
[16:20:43.210]                   NAME <- NAMES[[kk]]
[16:20:43.210]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.210]                     next
[16:20:43.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.210]                 }
[16:20:43.210]                 NAMES <- toupper(added)
[16:20:43.210]                 for (kk in seq_along(NAMES)) {
[16:20:43.210]                   name <- added[[kk]]
[16:20:43.210]                   NAME <- NAMES[[kk]]
[16:20:43.210]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.210]                     next
[16:20:43.210]                   args[[name]] <- ""
[16:20:43.210]                 }
[16:20:43.210]                 NAMES <- toupper(removed)
[16:20:43.210]                 for (kk in seq_along(NAMES)) {
[16:20:43.210]                   name <- removed[[kk]]
[16:20:43.210]                   NAME <- NAMES[[kk]]
[16:20:43.210]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.210]                     next
[16:20:43.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.210]                 }
[16:20:43.210]                 if (length(args) > 0) 
[16:20:43.210]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.210]             }
[16:20:43.210]             else {
[16:20:43.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.210]             }
[16:20:43.210]             {
[16:20:43.210]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.210]                   0L) {
[16:20:43.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.210]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.210]                   base::options(opts)
[16:20:43.210]                 }
[16:20:43.210]                 {
[16:20:43.210]                   {
[16:20:43.210]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.210]                     NULL
[16:20:43.210]                   }
[16:20:43.210]                   options(future.plan = NULL)
[16:20:43.210]                   if (is.na(NA_character_)) 
[16:20:43.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.210]                     .init = FALSE)
[16:20:43.210]                 }
[16:20:43.210]             }
[16:20:43.210]         }
[16:20:43.210]     })
[16:20:43.210]     if (TRUE) {
[16:20:43.210]         base::sink(type = "output", split = FALSE)
[16:20:43.210]         if (TRUE) {
[16:20:43.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.210]         }
[16:20:43.210]         else {
[16:20:43.210]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.210]         }
[16:20:43.210]         base::close(...future.stdout)
[16:20:43.210]         ...future.stdout <- NULL
[16:20:43.210]     }
[16:20:43.210]     ...future.result$conditions <- ...future.conditions
[16:20:43.210]     ...future.result$finished <- base::Sys.time()
[16:20:43.210]     ...future.result
[16:20:43.210] }
[16:20:43.212] requestCore(): workers = 2
[16:20:43.214] MulticoreFuture started
[16:20:43.215] - Launch lazy future ... done
[16:20:43.215] run() for ‘MulticoreFuture’ ... done
[16:20:43.215] getGlobalsAndPackages() ...
[16:20:43.215] Searching for globals...
[16:20:43.216] plan(): Setting new future strategy stack:
[16:20:43.216] 
[16:20:43.216] Searching for globals ... DONE
[16:20:43.216] List of future strategies:
[16:20:43.216] 1. sequential:
[16:20:43.216]    - args: function (..., envir = parent.frame())
[16:20:43.216]    - tweaked: FALSE
[16:20:43.216]    - call: NULL
[16:20:43.217] - globals: [0] <none>
[16:20:43.217] getGlobalsAndPackages() ... DONE
[16:20:43.217] plan(): nbrOfWorkers() = 1
[16:20:43.217] run() for ‘Future’ ...
[16:20:43.217] - state: ‘created’
[16:20:43.217] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.218] plan(): Setting new future strategy stack:
[16:20:43.219] List of future strategies:
[16:20:43.219] 1. multicore:
[16:20:43.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.219]    - tweaked: FALSE
[16:20:43.219]    - call: plan(strategy)
[16:20:43.223] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.223] plan(): nbrOfWorkers() = 2
[16:20:43.223] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.223]   - Field: ‘label’
[16:20:43.223]   - Field: ‘local’
[16:20:43.223]   - Field: ‘owner’
[16:20:43.223]   - Field: ‘envir’
[16:20:43.224]   - Field: ‘workers’
[16:20:43.224]   - Field: ‘packages’
[16:20:43.224]   - Field: ‘gc’
[16:20:43.224]   - Field: ‘job’
[16:20:43.224]   - Field: ‘conditions’
[16:20:43.224]   - Field: ‘expr’
[16:20:43.225]   - Field: ‘uuid’
[16:20:43.225]   - Field: ‘seed’
[16:20:43.225]   - Field: ‘version’
[16:20:43.225]   - Field: ‘result’
[16:20:43.225]   - Field: ‘asynchronous’
[16:20:43.225]   - Field: ‘calls’
[16:20:43.225]   - Field: ‘globals’
[16:20:43.225]   - Field: ‘stdout’
[16:20:43.226]   - Field: ‘earlySignal’
[16:20:43.226]   - Field: ‘lazy’
[16:20:43.226]   - Field: ‘state’
[16:20:43.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.226] - Launch lazy future ...
[16:20:43.227] Packages needed by the future expression (n = 0): <none>
[16:20:43.227] Packages needed by future strategies (n = 0): <none>
[16:20:43.227] {
[16:20:43.227]     {
[16:20:43.227]         {
[16:20:43.227]             ...future.startTime <- base::Sys.time()
[16:20:43.227]             {
[16:20:43.227]                 {
[16:20:43.227]                   {
[16:20:43.227]                     {
[16:20:43.227]                       base::local({
[16:20:43.227]                         has_future <- base::requireNamespace("future", 
[16:20:43.227]                           quietly = TRUE)
[16:20:43.227]                         if (has_future) {
[16:20:43.227]                           ns <- base::getNamespace("future")
[16:20:43.227]                           version <- ns[[".package"]][["version"]]
[16:20:43.227]                           if (is.null(version)) 
[16:20:43.227]                             version <- utils::packageVersion("future")
[16:20:43.227]                         }
[16:20:43.227]                         else {
[16:20:43.227]                           version <- NULL
[16:20:43.227]                         }
[16:20:43.227]                         if (!has_future || version < "1.8.0") {
[16:20:43.227]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.227]                             "", base::R.version$version.string), 
[16:20:43.227]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.227]                               "release", "version")], collapse = " "), 
[16:20:43.227]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.227]                             info)
[16:20:43.227]                           info <- base::paste(info, collapse = "; ")
[16:20:43.227]                           if (!has_future) {
[16:20:43.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.227]                               info)
[16:20:43.227]                           }
[16:20:43.227]                           else {
[16:20:43.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.227]                               info, version)
[16:20:43.227]                           }
[16:20:43.227]                           base::stop(msg)
[16:20:43.227]                         }
[16:20:43.227]                       })
[16:20:43.227]                     }
[16:20:43.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.227]                     base::options(mc.cores = 1L)
[16:20:43.227]                   }
[16:20:43.227]                   ...future.strategy.old <- future::plan("list")
[16:20:43.227]                   options(future.plan = NULL)
[16:20:43.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.227]                 }
[16:20:43.227]                 ...future.workdir <- getwd()
[16:20:43.227]             }
[16:20:43.227]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.227]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.227]         }
[16:20:43.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.227]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.227]             base::names(...future.oldOptions))
[16:20:43.227]     }
[16:20:43.227]     if (FALSE) {
[16:20:43.227]     }
[16:20:43.227]     else {
[16:20:43.227]         if (TRUE) {
[16:20:43.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.227]                 open = "w")
[16:20:43.227]         }
[16:20:43.227]         else {
[16:20:43.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.227]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.227]         }
[16:20:43.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.227]             base::sink(type = "output", split = FALSE)
[16:20:43.227]             base::close(...future.stdout)
[16:20:43.227]         }, add = TRUE)
[16:20:43.227]     }
[16:20:43.227]     ...future.frame <- base::sys.nframe()
[16:20:43.227]     ...future.conditions <- base::list()
[16:20:43.227]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.227]     if (FALSE) {
[16:20:43.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.227]     }
[16:20:43.227]     ...future.result <- base::tryCatch({
[16:20:43.227]         base::withCallingHandlers({
[16:20:43.227]             ...future.value <- base::withVisible(base::local({
[16:20:43.227]                 withCallingHandlers({
[16:20:43.227]                   NULL
[16:20:43.227]                 }, immediateCondition = function(cond) {
[16:20:43.227]                   save_rds <- function (object, pathname, ...) 
[16:20:43.227]                   {
[16:20:43.227]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.227]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.227]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.227]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.227]                         fi_tmp[["mtime"]])
[16:20:43.227]                     }
[16:20:43.227]                     tryCatch({
[16:20:43.227]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.227]                     }, error = function(ex) {
[16:20:43.227]                       msg <- conditionMessage(ex)
[16:20:43.227]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.227]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.227]                         fi_tmp[["mtime"]], msg)
[16:20:43.227]                       ex$message <- msg
[16:20:43.227]                       stop(ex)
[16:20:43.227]                     })
[16:20:43.227]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.227]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.227]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.227]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.227]                       fi <- file.info(pathname)
[16:20:43.227]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.227]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.227]                         fi[["size"]], fi[["mtime"]])
[16:20:43.227]                       stop(msg)
[16:20:43.227]                     }
[16:20:43.227]                     invisible(pathname)
[16:20:43.227]                   }
[16:20:43.227]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.227]                     rootPath = tempdir()) 
[16:20:43.227]                   {
[16:20:43.227]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.227]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.227]                       tmpdir = path, fileext = ".rds")
[16:20:43.227]                     save_rds(obj, file)
[16:20:43.227]                   }
[16:20:43.227]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.227]                   {
[16:20:43.227]                     inherits <- base::inherits
[16:20:43.227]                     invokeRestart <- base::invokeRestart
[16:20:43.227]                     is.null <- base::is.null
[16:20:43.227]                     muffled <- FALSE
[16:20:43.227]                     if (inherits(cond, "message")) {
[16:20:43.227]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.227]                       if (muffled) 
[16:20:43.227]                         invokeRestart("muffleMessage")
[16:20:43.227]                     }
[16:20:43.227]                     else if (inherits(cond, "warning")) {
[16:20:43.227]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.227]                       if (muffled) 
[16:20:43.227]                         invokeRestart("muffleWarning")
[16:20:43.227]                     }
[16:20:43.227]                     else if (inherits(cond, "condition")) {
[16:20:43.227]                       if (!is.null(pattern)) {
[16:20:43.227]                         computeRestarts <- base::computeRestarts
[16:20:43.227]                         grepl <- base::grepl
[16:20:43.227]                         restarts <- computeRestarts(cond)
[16:20:43.227]                         for (restart in restarts) {
[16:20:43.227]                           name <- restart$name
[16:20:43.227]                           if (is.null(name)) 
[16:20:43.227]                             next
[16:20:43.227]                           if (!grepl(pattern, name)) 
[16:20:43.227]                             next
[16:20:43.227]                           invokeRestart(restart)
[16:20:43.227]                           muffled <- TRUE
[16:20:43.227]                           break
[16:20:43.227]                         }
[16:20:43.227]                       }
[16:20:43.227]                     }
[16:20:43.227]                     invisible(muffled)
[16:20:43.227]                   }
[16:20:43.227]                   muffleCondition(cond)
[16:20:43.227]                 })
[16:20:43.227]             }))
[16:20:43.227]             future::FutureResult(value = ...future.value$value, 
[16:20:43.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.227]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.227]                     ...future.globalenv.names))
[16:20:43.227]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.227]         }, condition = base::local({
[16:20:43.227]             c <- base::c
[16:20:43.227]             inherits <- base::inherits
[16:20:43.227]             invokeRestart <- base::invokeRestart
[16:20:43.227]             length <- base::length
[16:20:43.227]             list <- base::list
[16:20:43.227]             seq.int <- base::seq.int
[16:20:43.227]             signalCondition <- base::signalCondition
[16:20:43.227]             sys.calls <- base::sys.calls
[16:20:43.227]             `[[` <- base::`[[`
[16:20:43.227]             `+` <- base::`+`
[16:20:43.227]             `<<-` <- base::`<<-`
[16:20:43.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.227]                   3L)]
[16:20:43.227]             }
[16:20:43.227]             function(cond) {
[16:20:43.227]                 is_error <- inherits(cond, "error")
[16:20:43.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.227]                   NULL)
[16:20:43.227]                 if (is_error) {
[16:20:43.227]                   sessionInformation <- function() {
[16:20:43.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.227]                       search = base::search(), system = base::Sys.info())
[16:20:43.227]                   }
[16:20:43.227]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.227]                     cond$call), session = sessionInformation(), 
[16:20:43.227]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.227]                   signalCondition(cond)
[16:20:43.227]                 }
[16:20:43.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.227]                 "immediateCondition"))) {
[16:20:43.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.227]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.227]                   if (TRUE && !signal) {
[16:20:43.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.227]                     {
[16:20:43.227]                       inherits <- base::inherits
[16:20:43.227]                       invokeRestart <- base::invokeRestart
[16:20:43.227]                       is.null <- base::is.null
[16:20:43.227]                       muffled <- FALSE
[16:20:43.227]                       if (inherits(cond, "message")) {
[16:20:43.227]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.227]                         if (muffled) 
[16:20:43.227]                           invokeRestart("muffleMessage")
[16:20:43.227]                       }
[16:20:43.227]                       else if (inherits(cond, "warning")) {
[16:20:43.227]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.227]                         if (muffled) 
[16:20:43.227]                           invokeRestart("muffleWarning")
[16:20:43.227]                       }
[16:20:43.227]                       else if (inherits(cond, "condition")) {
[16:20:43.227]                         if (!is.null(pattern)) {
[16:20:43.227]                           computeRestarts <- base::computeRestarts
[16:20:43.227]                           grepl <- base::grepl
[16:20:43.227]                           restarts <- computeRestarts(cond)
[16:20:43.227]                           for (restart in restarts) {
[16:20:43.227]                             name <- restart$name
[16:20:43.227]                             if (is.null(name)) 
[16:20:43.227]                               next
[16:20:43.227]                             if (!grepl(pattern, name)) 
[16:20:43.227]                               next
[16:20:43.227]                             invokeRestart(restart)
[16:20:43.227]                             muffled <- TRUE
[16:20:43.227]                             break
[16:20:43.227]                           }
[16:20:43.227]                         }
[16:20:43.227]                       }
[16:20:43.227]                       invisible(muffled)
[16:20:43.227]                     }
[16:20:43.227]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.227]                   }
[16:20:43.227]                 }
[16:20:43.227]                 else {
[16:20:43.227]                   if (TRUE) {
[16:20:43.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.227]                     {
[16:20:43.227]                       inherits <- base::inherits
[16:20:43.227]                       invokeRestart <- base::invokeRestart
[16:20:43.227]                       is.null <- base::is.null
[16:20:43.227]                       muffled <- FALSE
[16:20:43.227]                       if (inherits(cond, "message")) {
[16:20:43.227]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.227]                         if (muffled) 
[16:20:43.227]                           invokeRestart("muffleMessage")
[16:20:43.227]                       }
[16:20:43.227]                       else if (inherits(cond, "warning")) {
[16:20:43.227]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.227]                         if (muffled) 
[16:20:43.227]                           invokeRestart("muffleWarning")
[16:20:43.227]                       }
[16:20:43.227]                       else if (inherits(cond, "condition")) {
[16:20:43.227]                         if (!is.null(pattern)) {
[16:20:43.227]                           computeRestarts <- base::computeRestarts
[16:20:43.227]                           grepl <- base::grepl
[16:20:43.227]                           restarts <- computeRestarts(cond)
[16:20:43.227]                           for (restart in restarts) {
[16:20:43.227]                             name <- restart$name
[16:20:43.227]                             if (is.null(name)) 
[16:20:43.227]                               next
[16:20:43.227]                             if (!grepl(pattern, name)) 
[16:20:43.227]                               next
[16:20:43.227]                             invokeRestart(restart)
[16:20:43.227]                             muffled <- TRUE
[16:20:43.227]                             break
[16:20:43.227]                           }
[16:20:43.227]                         }
[16:20:43.227]                       }
[16:20:43.227]                       invisible(muffled)
[16:20:43.227]                     }
[16:20:43.227]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.227]                   }
[16:20:43.227]                 }
[16:20:43.227]             }
[16:20:43.227]         }))
[16:20:43.227]     }, error = function(ex) {
[16:20:43.227]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.227]                 ...future.rng), started = ...future.startTime, 
[16:20:43.227]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.227]             version = "1.8"), class = "FutureResult")
[16:20:43.227]     }, finally = {
[16:20:43.227]         if (!identical(...future.workdir, getwd())) 
[16:20:43.227]             setwd(...future.workdir)
[16:20:43.227]         {
[16:20:43.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.227]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.227]             }
[16:20:43.227]             base::options(...future.oldOptions)
[16:20:43.227]             if (.Platform$OS.type == "windows") {
[16:20:43.227]                 old_names <- names(...future.oldEnvVars)
[16:20:43.227]                 envs <- base::Sys.getenv()
[16:20:43.227]                 names <- names(envs)
[16:20:43.227]                 common <- intersect(names, old_names)
[16:20:43.227]                 added <- setdiff(names, old_names)
[16:20:43.227]                 removed <- setdiff(old_names, names)
[16:20:43.227]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.227]                   envs[common]]
[16:20:43.227]                 NAMES <- toupper(changed)
[16:20:43.227]                 args <- list()
[16:20:43.227]                 for (kk in seq_along(NAMES)) {
[16:20:43.227]                   name <- changed[[kk]]
[16:20:43.227]                   NAME <- NAMES[[kk]]
[16:20:43.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.227]                     next
[16:20:43.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.227]                 }
[16:20:43.227]                 NAMES <- toupper(added)
[16:20:43.227]                 for (kk in seq_along(NAMES)) {
[16:20:43.227]                   name <- added[[kk]]
[16:20:43.227]                   NAME <- NAMES[[kk]]
[16:20:43.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.227]                     next
[16:20:43.227]                   args[[name]] <- ""
[16:20:43.227]                 }
[16:20:43.227]                 NAMES <- toupper(removed)
[16:20:43.227]                 for (kk in seq_along(NAMES)) {
[16:20:43.227]                   name <- removed[[kk]]
[16:20:43.227]                   NAME <- NAMES[[kk]]
[16:20:43.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.227]                     next
[16:20:43.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.227]                 }
[16:20:43.227]                 if (length(args) > 0) 
[16:20:43.227]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.227]             }
[16:20:43.227]             else {
[16:20:43.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.227]             }
[16:20:43.227]             {
[16:20:43.227]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.227]                   0L) {
[16:20:43.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.227]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.227]                   base::options(opts)
[16:20:43.227]                 }
[16:20:43.227]                 {
[16:20:43.227]                   {
[16:20:43.227]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.227]                     NULL
[16:20:43.227]                   }
[16:20:43.227]                   options(future.plan = NULL)
[16:20:43.227]                   if (is.na(NA_character_)) 
[16:20:43.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.227]                     .init = FALSE)
[16:20:43.227]                 }
[16:20:43.227]             }
[16:20:43.227]         }
[16:20:43.227]     })
[16:20:43.227]     if (TRUE) {
[16:20:43.227]         base::sink(type = "output", split = FALSE)
[16:20:43.227]         if (TRUE) {
[16:20:43.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.227]         }
[16:20:43.227]         else {
[16:20:43.227]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.227]         }
[16:20:43.227]         base::close(...future.stdout)
[16:20:43.227]         ...future.stdout <- NULL
[16:20:43.227]     }
[16:20:43.227]     ...future.result$conditions <- ...future.conditions
[16:20:43.227]     ...future.result$finished <- base::Sys.time()
[16:20:43.227]     ...future.result
[16:20:43.227] }
[16:20:43.231] requestCore(): workers = 2
[16:20:43.234] MulticoreFuture started
[16:20:43.234] - Launch lazy future ... done
[16:20:43.234] run() for ‘MulticoreFuture’ ... done
[16:20:43.235] plan(): Setting new future strategy stack:
[16:20:43.235] getGlobalsAndPackages() ...
[16:20:43.235] Searching for globals...
[16:20:43.235] List of future strategies:
[16:20:43.235] 1. sequential:
[16:20:43.235]    - args: function (..., envir = parent.frame())
[16:20:43.235]    - tweaked: FALSE
[16:20:43.235]    - call: NULL
[16:20:43.236] plan(): nbrOfWorkers() = 1
[16:20:43.236] - globals found: [1] ‘{’
[16:20:43.237] Searching for globals ... DONE
[16:20:43.237] Resolving globals: FALSE
[16:20:43.237] 
[16:20:43.237] 
[16:20:43.238] getGlobalsAndPackages() ... DONE
[16:20:43.238] plan(): Setting new future strategy stack:
[16:20:43.238] run() for ‘Future’ ...
[16:20:43.238] - state: ‘created’
[16:20:43.238] List of future strategies:
[16:20:43.238] 1. multicore:
[16:20:43.238]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.238]    - tweaked: FALSE
[16:20:43.238]    - call: plan(strategy)
[16:20:43.238] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.243] plan(): nbrOfWorkers() = 2
[16:20:43.244] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.244] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.244]   - Field: ‘label’
[16:20:43.244]   - Field: ‘local’
[16:20:43.244]   - Field: ‘owner’
[16:20:43.245]   - Field: ‘envir’
[16:20:43.245]   - Field: ‘workers’
[16:20:43.245]   - Field: ‘packages’
[16:20:43.245]   - Field: ‘gc’
[16:20:43.245]   - Field: ‘job’
[16:20:43.245]   - Field: ‘conditions’
[16:20:43.245]   - Field: ‘expr’
[16:20:43.246]   - Field: ‘uuid’
[16:20:43.246]   - Field: ‘seed’
[16:20:43.246]   - Field: ‘version’
[16:20:43.246]   - Field: ‘result’
[16:20:43.246]   - Field: ‘asynchronous’
[16:20:43.246]   - Field: ‘calls’
[16:20:43.246]   - Field: ‘globals’
[16:20:43.246]   - Field: ‘stdout’
[16:20:43.247]   - Field: ‘earlySignal’
[16:20:43.247]   - Field: ‘lazy’
[16:20:43.247]   - Field: ‘state’
[16:20:43.247] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.247] - Launch lazy future ...
[16:20:43.248] Packages needed by the future expression (n = 0): <none>
[16:20:43.248] Packages needed by future strategies (n = 0): <none>
[16:20:43.248] {
[16:20:43.248]     {
[16:20:43.248]         {
[16:20:43.248]             ...future.startTime <- base::Sys.time()
[16:20:43.248]             {
[16:20:43.248]                 {
[16:20:43.248]                   {
[16:20:43.248]                     {
[16:20:43.248]                       base::local({
[16:20:43.248]                         has_future <- base::requireNamespace("future", 
[16:20:43.248]                           quietly = TRUE)
[16:20:43.248]                         if (has_future) {
[16:20:43.248]                           ns <- base::getNamespace("future")
[16:20:43.248]                           version <- ns[[".package"]][["version"]]
[16:20:43.248]                           if (is.null(version)) 
[16:20:43.248]                             version <- utils::packageVersion("future")
[16:20:43.248]                         }
[16:20:43.248]                         else {
[16:20:43.248]                           version <- NULL
[16:20:43.248]                         }
[16:20:43.248]                         if (!has_future || version < "1.8.0") {
[16:20:43.248]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.248]                             "", base::R.version$version.string), 
[16:20:43.248]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.248]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.248]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.248]                               "release", "version")], collapse = " "), 
[16:20:43.248]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.248]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.248]                             info)
[16:20:43.248]                           info <- base::paste(info, collapse = "; ")
[16:20:43.248]                           if (!has_future) {
[16:20:43.248]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.248]                               info)
[16:20:43.248]                           }
[16:20:43.248]                           else {
[16:20:43.248]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.248]                               info, version)
[16:20:43.248]                           }
[16:20:43.248]                           base::stop(msg)
[16:20:43.248]                         }
[16:20:43.248]                       })
[16:20:43.248]                     }
[16:20:43.248]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.248]                     base::options(mc.cores = 1L)
[16:20:43.248]                   }
[16:20:43.248]                   ...future.strategy.old <- future::plan("list")
[16:20:43.248]                   options(future.plan = NULL)
[16:20:43.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.248]                 }
[16:20:43.248]                 ...future.workdir <- getwd()
[16:20:43.248]             }
[16:20:43.248]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.248]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.248]         }
[16:20:43.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.248]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.248]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.248]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.248]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.248]             base::names(...future.oldOptions))
[16:20:43.248]     }
[16:20:43.248]     if (FALSE) {
[16:20:43.248]     }
[16:20:43.248]     else {
[16:20:43.248]         if (TRUE) {
[16:20:43.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.248]                 open = "w")
[16:20:43.248]         }
[16:20:43.248]         else {
[16:20:43.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.248]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.248]         }
[16:20:43.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.248]             base::sink(type = "output", split = FALSE)
[16:20:43.248]             base::close(...future.stdout)
[16:20:43.248]         }, add = TRUE)
[16:20:43.248]     }
[16:20:43.248]     ...future.frame <- base::sys.nframe()
[16:20:43.248]     ...future.conditions <- base::list()
[16:20:43.248]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.248]     if (FALSE) {
[16:20:43.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.248]     }
[16:20:43.248]     ...future.result <- base::tryCatch({
[16:20:43.248]         base::withCallingHandlers({
[16:20:43.248]             ...future.value <- base::withVisible(base::local({
[16:20:43.248]                 withCallingHandlers({
[16:20:43.248]                   {
[16:20:43.248]                     4
[16:20:43.248]                   }
[16:20:43.248]                 }, immediateCondition = function(cond) {
[16:20:43.248]                   save_rds <- function (object, pathname, ...) 
[16:20:43.248]                   {
[16:20:43.248]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.248]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.248]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.248]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.248]                         fi_tmp[["mtime"]])
[16:20:43.248]                     }
[16:20:43.248]                     tryCatch({
[16:20:43.248]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.248]                     }, error = function(ex) {
[16:20:43.248]                       msg <- conditionMessage(ex)
[16:20:43.248]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.248]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.248]                         fi_tmp[["mtime"]], msg)
[16:20:43.248]                       ex$message <- msg
[16:20:43.248]                       stop(ex)
[16:20:43.248]                     })
[16:20:43.248]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.248]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.248]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.248]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.248]                       fi <- file.info(pathname)
[16:20:43.248]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.248]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.248]                         fi[["size"]], fi[["mtime"]])
[16:20:43.248]                       stop(msg)
[16:20:43.248]                     }
[16:20:43.248]                     invisible(pathname)
[16:20:43.248]                   }
[16:20:43.248]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.248]                     rootPath = tempdir()) 
[16:20:43.248]                   {
[16:20:43.248]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.248]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.248]                       tmpdir = path, fileext = ".rds")
[16:20:43.248]                     save_rds(obj, file)
[16:20:43.248]                   }
[16:20:43.248]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.248]                   {
[16:20:43.248]                     inherits <- base::inherits
[16:20:43.248]                     invokeRestart <- base::invokeRestart
[16:20:43.248]                     is.null <- base::is.null
[16:20:43.248]                     muffled <- FALSE
[16:20:43.248]                     if (inherits(cond, "message")) {
[16:20:43.248]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.248]                       if (muffled) 
[16:20:43.248]                         invokeRestart("muffleMessage")
[16:20:43.248]                     }
[16:20:43.248]                     else if (inherits(cond, "warning")) {
[16:20:43.248]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.248]                       if (muffled) 
[16:20:43.248]                         invokeRestart("muffleWarning")
[16:20:43.248]                     }
[16:20:43.248]                     else if (inherits(cond, "condition")) {
[16:20:43.248]                       if (!is.null(pattern)) {
[16:20:43.248]                         computeRestarts <- base::computeRestarts
[16:20:43.248]                         grepl <- base::grepl
[16:20:43.248]                         restarts <- computeRestarts(cond)
[16:20:43.248]                         for (restart in restarts) {
[16:20:43.248]                           name <- restart$name
[16:20:43.248]                           if (is.null(name)) 
[16:20:43.248]                             next
[16:20:43.248]                           if (!grepl(pattern, name)) 
[16:20:43.248]                             next
[16:20:43.248]                           invokeRestart(restart)
[16:20:43.248]                           muffled <- TRUE
[16:20:43.248]                           break
[16:20:43.248]                         }
[16:20:43.248]                       }
[16:20:43.248]                     }
[16:20:43.248]                     invisible(muffled)
[16:20:43.248]                   }
[16:20:43.248]                   muffleCondition(cond)
[16:20:43.248]                 })
[16:20:43.248]             }))
[16:20:43.248]             future::FutureResult(value = ...future.value$value, 
[16:20:43.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.248]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.248]                     ...future.globalenv.names))
[16:20:43.248]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.248]         }, condition = base::local({
[16:20:43.248]             c <- base::c
[16:20:43.248]             inherits <- base::inherits
[16:20:43.248]             invokeRestart <- base::invokeRestart
[16:20:43.248]             length <- base::length
[16:20:43.248]             list <- base::list
[16:20:43.248]             seq.int <- base::seq.int
[16:20:43.248]             signalCondition <- base::signalCondition
[16:20:43.248]             sys.calls <- base::sys.calls
[16:20:43.248]             `[[` <- base::`[[`
[16:20:43.248]             `+` <- base::`+`
[16:20:43.248]             `<<-` <- base::`<<-`
[16:20:43.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.248]                   3L)]
[16:20:43.248]             }
[16:20:43.248]             function(cond) {
[16:20:43.248]                 is_error <- inherits(cond, "error")
[16:20:43.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.248]                   NULL)
[16:20:43.248]                 if (is_error) {
[16:20:43.248]                   sessionInformation <- function() {
[16:20:43.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.248]                       search = base::search(), system = base::Sys.info())
[16:20:43.248]                   }
[16:20:43.248]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.248]                     cond$call), session = sessionInformation(), 
[16:20:43.248]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.248]                   signalCondition(cond)
[16:20:43.248]                 }
[16:20:43.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.248]                 "immediateCondition"))) {
[16:20:43.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.248]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.248]                   if (TRUE && !signal) {
[16:20:43.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.248]                     {
[16:20:43.248]                       inherits <- base::inherits
[16:20:43.248]                       invokeRestart <- base::invokeRestart
[16:20:43.248]                       is.null <- base::is.null
[16:20:43.248]                       muffled <- FALSE
[16:20:43.248]                       if (inherits(cond, "message")) {
[16:20:43.248]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.248]                         if (muffled) 
[16:20:43.248]                           invokeRestart("muffleMessage")
[16:20:43.248]                       }
[16:20:43.248]                       else if (inherits(cond, "warning")) {
[16:20:43.248]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.248]                         if (muffled) 
[16:20:43.248]                           invokeRestart("muffleWarning")
[16:20:43.248]                       }
[16:20:43.248]                       else if (inherits(cond, "condition")) {
[16:20:43.248]                         if (!is.null(pattern)) {
[16:20:43.248]                           computeRestarts <- base::computeRestarts
[16:20:43.248]                           grepl <- base::grepl
[16:20:43.248]                           restarts <- computeRestarts(cond)
[16:20:43.248]                           for (restart in restarts) {
[16:20:43.248]                             name <- restart$name
[16:20:43.248]                             if (is.null(name)) 
[16:20:43.248]                               next
[16:20:43.248]                             if (!grepl(pattern, name)) 
[16:20:43.248]                               next
[16:20:43.248]                             invokeRestart(restart)
[16:20:43.248]                             muffled <- TRUE
[16:20:43.248]                             break
[16:20:43.248]                           }
[16:20:43.248]                         }
[16:20:43.248]                       }
[16:20:43.248]                       invisible(muffled)
[16:20:43.248]                     }
[16:20:43.248]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.248]                   }
[16:20:43.248]                 }
[16:20:43.248]                 else {
[16:20:43.248]                   if (TRUE) {
[16:20:43.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.248]                     {
[16:20:43.248]                       inherits <- base::inherits
[16:20:43.248]                       invokeRestart <- base::invokeRestart
[16:20:43.248]                       is.null <- base::is.null
[16:20:43.248]                       muffled <- FALSE
[16:20:43.248]                       if (inherits(cond, "message")) {
[16:20:43.248]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.248]                         if (muffled) 
[16:20:43.248]                           invokeRestart("muffleMessage")
[16:20:43.248]                       }
[16:20:43.248]                       else if (inherits(cond, "warning")) {
[16:20:43.248]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.248]                         if (muffled) 
[16:20:43.248]                           invokeRestart("muffleWarning")
[16:20:43.248]                       }
[16:20:43.248]                       else if (inherits(cond, "condition")) {
[16:20:43.248]                         if (!is.null(pattern)) {
[16:20:43.248]                           computeRestarts <- base::computeRestarts
[16:20:43.248]                           grepl <- base::grepl
[16:20:43.248]                           restarts <- computeRestarts(cond)
[16:20:43.248]                           for (restart in restarts) {
[16:20:43.248]                             name <- restart$name
[16:20:43.248]                             if (is.null(name)) 
[16:20:43.248]                               next
[16:20:43.248]                             if (!grepl(pattern, name)) 
[16:20:43.248]                               next
[16:20:43.248]                             invokeRestart(restart)
[16:20:43.248]                             muffled <- TRUE
[16:20:43.248]                             break
[16:20:43.248]                           }
[16:20:43.248]                         }
[16:20:43.248]                       }
[16:20:43.248]                       invisible(muffled)
[16:20:43.248]                     }
[16:20:43.248]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.248]                   }
[16:20:43.248]                 }
[16:20:43.248]             }
[16:20:43.248]         }))
[16:20:43.248]     }, error = function(ex) {
[16:20:43.248]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.248]                 ...future.rng), started = ...future.startTime, 
[16:20:43.248]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.248]             version = "1.8"), class = "FutureResult")
[16:20:43.248]     }, finally = {
[16:20:43.248]         if (!identical(...future.workdir, getwd())) 
[16:20:43.248]             setwd(...future.workdir)
[16:20:43.248]         {
[16:20:43.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.248]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.248]             }
[16:20:43.248]             base::options(...future.oldOptions)
[16:20:43.248]             if (.Platform$OS.type == "windows") {
[16:20:43.248]                 old_names <- names(...future.oldEnvVars)
[16:20:43.248]                 envs <- base::Sys.getenv()
[16:20:43.248]                 names <- names(envs)
[16:20:43.248]                 common <- intersect(names, old_names)
[16:20:43.248]                 added <- setdiff(names, old_names)
[16:20:43.248]                 removed <- setdiff(old_names, names)
[16:20:43.248]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.248]                   envs[common]]
[16:20:43.248]                 NAMES <- toupper(changed)
[16:20:43.248]                 args <- list()
[16:20:43.248]                 for (kk in seq_along(NAMES)) {
[16:20:43.248]                   name <- changed[[kk]]
[16:20:43.248]                   NAME <- NAMES[[kk]]
[16:20:43.248]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.248]                     next
[16:20:43.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.248]                 }
[16:20:43.248]                 NAMES <- toupper(added)
[16:20:43.248]                 for (kk in seq_along(NAMES)) {
[16:20:43.248]                   name <- added[[kk]]
[16:20:43.248]                   NAME <- NAMES[[kk]]
[16:20:43.248]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.248]                     next
[16:20:43.248]                   args[[name]] <- ""
[16:20:43.248]                 }
[16:20:43.248]                 NAMES <- toupper(removed)
[16:20:43.248]                 for (kk in seq_along(NAMES)) {
[16:20:43.248]                   name <- removed[[kk]]
[16:20:43.248]                   NAME <- NAMES[[kk]]
[16:20:43.248]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.248]                     next
[16:20:43.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.248]                 }
[16:20:43.248]                 if (length(args) > 0) 
[16:20:43.248]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.248]             }
[16:20:43.248]             else {
[16:20:43.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.248]             }
[16:20:43.248]             {
[16:20:43.248]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.248]                   0L) {
[16:20:43.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.248]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.248]                   base::options(opts)
[16:20:43.248]                 }
[16:20:43.248]                 {
[16:20:43.248]                   {
[16:20:43.248]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.248]                     NULL
[16:20:43.248]                   }
[16:20:43.248]                   options(future.plan = NULL)
[16:20:43.248]                   if (is.na(NA_character_)) 
[16:20:43.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.248]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.248]                     .init = FALSE)
[16:20:43.248]                 }
[16:20:43.248]             }
[16:20:43.248]         }
[16:20:43.248]     })
[16:20:43.248]     if (TRUE) {
[16:20:43.248]         base::sink(type = "output", split = FALSE)
[16:20:43.248]         if (TRUE) {
[16:20:43.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.248]         }
[16:20:43.248]         else {
[16:20:43.248]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.248]         }
[16:20:43.248]         base::close(...future.stdout)
[16:20:43.248]         ...future.stdout <- NULL
[16:20:43.248]     }
[16:20:43.248]     ...future.result$conditions <- ...future.conditions
[16:20:43.248]     ...future.result$finished <- base::Sys.time()
[16:20:43.248]     ...future.result
[16:20:43.248] }
[16:20:43.251] requestCore(): workers = 2
[16:20:43.252] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:43.263] result() for MulticoreFuture ...
[16:20:43.263] result() for MulticoreFuture ...
[16:20:43.264] result() for MulticoreFuture ... done
[16:20:43.264] result() for MulticoreFuture ... done
[16:20:43.264] result() for MulticoreFuture ...
[16:20:43.264] result() for MulticoreFuture ... done
[16:20:43.267] MulticoreFuture started
[16:20:43.267] - Launch lazy future ... done
[16:20:43.267] run() for ‘MulticoreFuture’ ... done
[16:20:43.268] plan(): Setting new future strategy stack:
<environment: 0x55ed0d712fa0> 
[16:20:43.268] List of future strategies:
[16:20:43.268] 1. sequential:
[16:20:43.268]    - args: function (..., envir = parent.frame())
[16:20:43.268]    - tweaked: FALSE
[16:20:43.268]    - call: NULL
[16:20:43.269] plan(): nbrOfWorkers() = 1
<environment: 0x55ed0e191770> 
[16:20:43.272] plan(): Setting new future strategy stack:
[16:20:43.272] List of future strategies:
[16:20:43.272] 1. multicore:
[16:20:43.272]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.272]    - tweaked: FALSE
[16:20:43.272]    - call: plan(strategy)
[16:20:43.277] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:43.279] resolve() on environment ...
[16:20:43.279]  recursive: 0
[16:20:43.286]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:43.287] signalConditionsASAP(numeric, pos=1) ...
[16:20:43.287] - nx: 4
[16:20:43.287] - relay: TRUE
[16:20:43.287] - stdout: TRUE
[16:20:43.287] - signal: TRUE
[16:20:43.287] - resignal: FALSE
[16:20:43.287] - force: TRUE
[16:20:43.288] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.288] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.288]  - until=2
[16:20:43.288]  - relaying element #2
[16:20:43.288] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.288] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.288] signalConditionsASAP(NULL, pos=1) ... done
[16:20:43.289]  length: 3 (resolved future 1)
[16:20:43.289] Future #2
[16:20:43.289] result() for MulticoreFuture ...
[16:20:43.289] result() for MulticoreFuture ... done
[16:20:43.289] result() for MulticoreFuture ...
[16:20:43.289] result() for MulticoreFuture ... done
[16:20:43.289] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:43.290] - nx: 4
[16:20:43.290] - relay: TRUE
[16:20:43.290] - stdout: TRUE
[16:20:43.290] - signal: TRUE
[16:20:43.290] - resignal: FALSE
[16:20:43.290] - force: TRUE
[16:20:43.290] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.290] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.291]  - until=2
[16:20:43.291]  - relaying element #2
[16:20:43.291] result() for MulticoreFuture ...
[16:20:43.291] result() for MulticoreFuture ... done
[16:20:43.291] result() for MulticoreFuture ...
[16:20:43.291] result() for MulticoreFuture ... done
[16:20:43.291] result() for MulticoreFuture ...
[16:20:43.292] result() for MulticoreFuture ... done
[16:20:43.292] result() for MulticoreFuture ...
[16:20:43.292] result() for MulticoreFuture ... done
[16:20:43.292] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.292] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.292] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:43.292]  length: 2 (resolved future 2)
[16:20:43.293] Future #3
[16:20:43.293] result() for MulticoreFuture ...
[16:20:43.294] result() for MulticoreFuture ...
[16:20:43.294] result() for MulticoreFuture ... done
[16:20:43.294] result() for MulticoreFuture ... done
[16:20:43.294] result() for MulticoreFuture ...
[16:20:43.294] result() for MulticoreFuture ... done
[16:20:43.294] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:43.295] - nx: 4
[16:20:43.295] - relay: TRUE
[16:20:43.295] - stdout: TRUE
[16:20:43.295] - signal: TRUE
[16:20:43.295] - resignal: FALSE
[16:20:43.295] - force: TRUE
[16:20:43.295] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.295] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.296]  - until=3
[16:20:43.296]  - relaying element #3
[16:20:43.296] result() for MulticoreFuture ...
[16:20:43.296] result() for MulticoreFuture ... done
[16:20:43.296] result() for MulticoreFuture ...
[16:20:43.296] result() for MulticoreFuture ... done
[16:20:43.296] result() for MulticoreFuture ...
[16:20:43.297] result() for MulticoreFuture ... done
[16:20:43.297] result() for MulticoreFuture ...
[16:20:43.297] result() for MulticoreFuture ... done
[16:20:43.297] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.297] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.297] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:43.297]  length: 1 (resolved future 3)
[16:20:43.298] Future #4
[16:20:43.298] result() for MulticoreFuture ...
[16:20:43.299] result() for MulticoreFuture ...
[16:20:43.299] result() for MulticoreFuture ... done
[16:20:43.299] result() for MulticoreFuture ... done
[16:20:43.299] result() for MulticoreFuture ...
[16:20:43.299] result() for MulticoreFuture ... done
[16:20:43.299] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:43.300] - nx: 4
[16:20:43.300] - relay: TRUE
[16:20:43.300] - stdout: TRUE
[16:20:43.300] - signal: TRUE
[16:20:43.300] - resignal: FALSE
[16:20:43.300] - force: TRUE
[16:20:43.300] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.301] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.301]  - until=4
[16:20:43.301]  - relaying element #4
[16:20:43.301] result() for MulticoreFuture ...
[16:20:43.301] result() for MulticoreFuture ... done
[16:20:43.301] result() for MulticoreFuture ...
[16:20:43.301] result() for MulticoreFuture ... done
[16:20:43.302] result() for MulticoreFuture ...
[16:20:43.302] result() for MulticoreFuture ... done
[16:20:43.302] result() for MulticoreFuture ...
[16:20:43.302] result() for MulticoreFuture ... done
[16:20:43.302] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.302] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.303] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:43.303]  length: 0 (resolved future 4)
[16:20:43.303] Relaying remaining futures
[16:20:43.303] signalConditionsASAP(NULL, pos=0) ...
[16:20:43.303] - nx: 4
[16:20:43.303] - relay: TRUE
[16:20:43.303] - stdout: TRUE
[16:20:43.303] - signal: TRUE
[16:20:43.303] - resignal: FALSE
[16:20:43.303] - force: TRUE
[16:20:43.304] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.304] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:43.304] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.304] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.304] signalConditionsASAP(NULL, pos=0) ... done
[16:20:43.304] resolve() on environment ... DONE
[16:20:43.304] result() for MulticoreFuture ...
[16:20:43.304] result() for MulticoreFuture ... done
[16:20:43.305] result() for MulticoreFuture ...
[16:20:43.305] result() for MulticoreFuture ... done
[16:20:43.305] result() for MulticoreFuture ...
[16:20:43.305] result() for MulticoreFuture ... done
[16:20:43.305] result() for MulticoreFuture ...
[16:20:43.305] result() for MulticoreFuture ... done
[16:20:43.305] result() for MulticoreFuture ...
[16:20:43.305] result() for MulticoreFuture ... done
[16:20:43.305] result() for MulticoreFuture ...
[16:20:43.306] result() for MulticoreFuture ... done
<environment: 0x55ed0e246e00> 
Dimensions: c(1, 6)
[16:20:43.306] getGlobalsAndPackages() ...
[16:20:43.306] Searching for globals...
[16:20:43.307] 
[16:20:43.307] Searching for globals ... DONE
[16:20:43.307] - globals: [0] <none>
[16:20:43.307] getGlobalsAndPackages() ... DONE
[16:20:43.307] run() for ‘Future’ ...
[16:20:43.307] - state: ‘created’
[16:20:43.308] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.312] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.312]   - Field: ‘label’
[16:20:43.312]   - Field: ‘local’
[16:20:43.312]   - Field: ‘owner’
[16:20:43.312]   - Field: ‘envir’
[16:20:43.313]   - Field: ‘workers’
[16:20:43.313]   - Field: ‘packages’
[16:20:43.313]   - Field: ‘gc’
[16:20:43.313]   - Field: ‘job’
[16:20:43.313]   - Field: ‘conditions’
[16:20:43.313]   - Field: ‘expr’
[16:20:43.313]   - Field: ‘uuid’
[16:20:43.313]   - Field: ‘seed’
[16:20:43.313]   - Field: ‘version’
[16:20:43.314]   - Field: ‘result’
[16:20:43.314]   - Field: ‘asynchronous’
[16:20:43.314]   - Field: ‘calls’
[16:20:43.314]   - Field: ‘globals’
[16:20:43.314]   - Field: ‘stdout’
[16:20:43.314]   - Field: ‘earlySignal’
[16:20:43.314]   - Field: ‘lazy’
[16:20:43.314]   - Field: ‘state’
[16:20:43.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.315] - Launch lazy future ...
[16:20:43.315] Packages needed by the future expression (n = 0): <none>
[16:20:43.315] Packages needed by future strategies (n = 0): <none>
[16:20:43.316] {
[16:20:43.316]     {
[16:20:43.316]         {
[16:20:43.316]             ...future.startTime <- base::Sys.time()
[16:20:43.316]             {
[16:20:43.316]                 {
[16:20:43.316]                   {
[16:20:43.316]                     {
[16:20:43.316]                       base::local({
[16:20:43.316]                         has_future <- base::requireNamespace("future", 
[16:20:43.316]                           quietly = TRUE)
[16:20:43.316]                         if (has_future) {
[16:20:43.316]                           ns <- base::getNamespace("future")
[16:20:43.316]                           version <- ns[[".package"]][["version"]]
[16:20:43.316]                           if (is.null(version)) 
[16:20:43.316]                             version <- utils::packageVersion("future")
[16:20:43.316]                         }
[16:20:43.316]                         else {
[16:20:43.316]                           version <- NULL
[16:20:43.316]                         }
[16:20:43.316]                         if (!has_future || version < "1.8.0") {
[16:20:43.316]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.316]                             "", base::R.version$version.string), 
[16:20:43.316]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.316]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.316]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.316]                               "release", "version")], collapse = " "), 
[16:20:43.316]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.316]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.316]                             info)
[16:20:43.316]                           info <- base::paste(info, collapse = "; ")
[16:20:43.316]                           if (!has_future) {
[16:20:43.316]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.316]                               info)
[16:20:43.316]                           }
[16:20:43.316]                           else {
[16:20:43.316]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.316]                               info, version)
[16:20:43.316]                           }
[16:20:43.316]                           base::stop(msg)
[16:20:43.316]                         }
[16:20:43.316]                       })
[16:20:43.316]                     }
[16:20:43.316]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.316]                     base::options(mc.cores = 1L)
[16:20:43.316]                   }
[16:20:43.316]                   ...future.strategy.old <- future::plan("list")
[16:20:43.316]                   options(future.plan = NULL)
[16:20:43.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.316]                 }
[16:20:43.316]                 ...future.workdir <- getwd()
[16:20:43.316]             }
[16:20:43.316]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.316]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.316]         }
[16:20:43.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.316]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.316]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.316]             base::names(...future.oldOptions))
[16:20:43.316]     }
[16:20:43.316]     if (FALSE) {
[16:20:43.316]     }
[16:20:43.316]     else {
[16:20:43.316]         if (TRUE) {
[16:20:43.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.316]                 open = "w")
[16:20:43.316]         }
[16:20:43.316]         else {
[16:20:43.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.316]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.316]         }
[16:20:43.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.316]             base::sink(type = "output", split = FALSE)
[16:20:43.316]             base::close(...future.stdout)
[16:20:43.316]         }, add = TRUE)
[16:20:43.316]     }
[16:20:43.316]     ...future.frame <- base::sys.nframe()
[16:20:43.316]     ...future.conditions <- base::list()
[16:20:43.316]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.316]     if (FALSE) {
[16:20:43.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.316]     }
[16:20:43.316]     ...future.result <- base::tryCatch({
[16:20:43.316]         base::withCallingHandlers({
[16:20:43.316]             ...future.value <- base::withVisible(base::local({
[16:20:43.316]                 withCallingHandlers({
[16:20:43.316]                   2
[16:20:43.316]                 }, immediateCondition = function(cond) {
[16:20:43.316]                   save_rds <- function (object, pathname, ...) 
[16:20:43.316]                   {
[16:20:43.316]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.316]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.316]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.316]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.316]                         fi_tmp[["mtime"]])
[16:20:43.316]                     }
[16:20:43.316]                     tryCatch({
[16:20:43.316]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.316]                     }, error = function(ex) {
[16:20:43.316]                       msg <- conditionMessage(ex)
[16:20:43.316]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.316]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.316]                         fi_tmp[["mtime"]], msg)
[16:20:43.316]                       ex$message <- msg
[16:20:43.316]                       stop(ex)
[16:20:43.316]                     })
[16:20:43.316]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.316]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.316]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.316]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.316]                       fi <- file.info(pathname)
[16:20:43.316]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.316]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.316]                         fi[["size"]], fi[["mtime"]])
[16:20:43.316]                       stop(msg)
[16:20:43.316]                     }
[16:20:43.316]                     invisible(pathname)
[16:20:43.316]                   }
[16:20:43.316]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.316]                     rootPath = tempdir()) 
[16:20:43.316]                   {
[16:20:43.316]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.316]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.316]                       tmpdir = path, fileext = ".rds")
[16:20:43.316]                     save_rds(obj, file)
[16:20:43.316]                   }
[16:20:43.316]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.316]                   {
[16:20:43.316]                     inherits <- base::inherits
[16:20:43.316]                     invokeRestart <- base::invokeRestart
[16:20:43.316]                     is.null <- base::is.null
[16:20:43.316]                     muffled <- FALSE
[16:20:43.316]                     if (inherits(cond, "message")) {
[16:20:43.316]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.316]                       if (muffled) 
[16:20:43.316]                         invokeRestart("muffleMessage")
[16:20:43.316]                     }
[16:20:43.316]                     else if (inherits(cond, "warning")) {
[16:20:43.316]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.316]                       if (muffled) 
[16:20:43.316]                         invokeRestart("muffleWarning")
[16:20:43.316]                     }
[16:20:43.316]                     else if (inherits(cond, "condition")) {
[16:20:43.316]                       if (!is.null(pattern)) {
[16:20:43.316]                         computeRestarts <- base::computeRestarts
[16:20:43.316]                         grepl <- base::grepl
[16:20:43.316]                         restarts <- computeRestarts(cond)
[16:20:43.316]                         for (restart in restarts) {
[16:20:43.316]                           name <- restart$name
[16:20:43.316]                           if (is.null(name)) 
[16:20:43.316]                             next
[16:20:43.316]                           if (!grepl(pattern, name)) 
[16:20:43.316]                             next
[16:20:43.316]                           invokeRestart(restart)
[16:20:43.316]                           muffled <- TRUE
[16:20:43.316]                           break
[16:20:43.316]                         }
[16:20:43.316]                       }
[16:20:43.316]                     }
[16:20:43.316]                     invisible(muffled)
[16:20:43.316]                   }
[16:20:43.316]                   muffleCondition(cond)
[16:20:43.316]                 })
[16:20:43.316]             }))
[16:20:43.316]             future::FutureResult(value = ...future.value$value, 
[16:20:43.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.316]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.316]                     ...future.globalenv.names))
[16:20:43.316]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.316]         }, condition = base::local({
[16:20:43.316]             c <- base::c
[16:20:43.316]             inherits <- base::inherits
[16:20:43.316]             invokeRestart <- base::invokeRestart
[16:20:43.316]             length <- base::length
[16:20:43.316]             list <- base::list
[16:20:43.316]             seq.int <- base::seq.int
[16:20:43.316]             signalCondition <- base::signalCondition
[16:20:43.316]             sys.calls <- base::sys.calls
[16:20:43.316]             `[[` <- base::`[[`
[16:20:43.316]             `+` <- base::`+`
[16:20:43.316]             `<<-` <- base::`<<-`
[16:20:43.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.316]                   3L)]
[16:20:43.316]             }
[16:20:43.316]             function(cond) {
[16:20:43.316]                 is_error <- inherits(cond, "error")
[16:20:43.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.316]                   NULL)
[16:20:43.316]                 if (is_error) {
[16:20:43.316]                   sessionInformation <- function() {
[16:20:43.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.316]                       search = base::search(), system = base::Sys.info())
[16:20:43.316]                   }
[16:20:43.316]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.316]                     cond$call), session = sessionInformation(), 
[16:20:43.316]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.316]                   signalCondition(cond)
[16:20:43.316]                 }
[16:20:43.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.316]                 "immediateCondition"))) {
[16:20:43.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.316]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.316]                   if (TRUE && !signal) {
[16:20:43.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.316]                     {
[16:20:43.316]                       inherits <- base::inherits
[16:20:43.316]                       invokeRestart <- base::invokeRestart
[16:20:43.316]                       is.null <- base::is.null
[16:20:43.316]                       muffled <- FALSE
[16:20:43.316]                       if (inherits(cond, "message")) {
[16:20:43.316]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.316]                         if (muffled) 
[16:20:43.316]                           invokeRestart("muffleMessage")
[16:20:43.316]                       }
[16:20:43.316]                       else if (inherits(cond, "warning")) {
[16:20:43.316]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.316]                         if (muffled) 
[16:20:43.316]                           invokeRestart("muffleWarning")
[16:20:43.316]                       }
[16:20:43.316]                       else if (inherits(cond, "condition")) {
[16:20:43.316]                         if (!is.null(pattern)) {
[16:20:43.316]                           computeRestarts <- base::computeRestarts
[16:20:43.316]                           grepl <- base::grepl
[16:20:43.316]                           restarts <- computeRestarts(cond)
[16:20:43.316]                           for (restart in restarts) {
[16:20:43.316]                             name <- restart$name
[16:20:43.316]                             if (is.null(name)) 
[16:20:43.316]                               next
[16:20:43.316]                             if (!grepl(pattern, name)) 
[16:20:43.316]                               next
[16:20:43.316]                             invokeRestart(restart)
[16:20:43.316]                             muffled <- TRUE
[16:20:43.316]                             break
[16:20:43.316]                           }
[16:20:43.316]                         }
[16:20:43.316]                       }
[16:20:43.316]                       invisible(muffled)
[16:20:43.316]                     }
[16:20:43.316]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.316]                   }
[16:20:43.316]                 }
[16:20:43.316]                 else {
[16:20:43.316]                   if (TRUE) {
[16:20:43.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.316]                     {
[16:20:43.316]                       inherits <- base::inherits
[16:20:43.316]                       invokeRestart <- base::invokeRestart
[16:20:43.316]                       is.null <- base::is.null
[16:20:43.316]                       muffled <- FALSE
[16:20:43.316]                       if (inherits(cond, "message")) {
[16:20:43.316]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.316]                         if (muffled) 
[16:20:43.316]                           invokeRestart("muffleMessage")
[16:20:43.316]                       }
[16:20:43.316]                       else if (inherits(cond, "warning")) {
[16:20:43.316]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.316]                         if (muffled) 
[16:20:43.316]                           invokeRestart("muffleWarning")
[16:20:43.316]                       }
[16:20:43.316]                       else if (inherits(cond, "condition")) {
[16:20:43.316]                         if (!is.null(pattern)) {
[16:20:43.316]                           computeRestarts <- base::computeRestarts
[16:20:43.316]                           grepl <- base::grepl
[16:20:43.316]                           restarts <- computeRestarts(cond)
[16:20:43.316]                           for (restart in restarts) {
[16:20:43.316]                             name <- restart$name
[16:20:43.316]                             if (is.null(name)) 
[16:20:43.316]                               next
[16:20:43.316]                             if (!grepl(pattern, name)) 
[16:20:43.316]                               next
[16:20:43.316]                             invokeRestart(restart)
[16:20:43.316]                             muffled <- TRUE
[16:20:43.316]                             break
[16:20:43.316]                           }
[16:20:43.316]                         }
[16:20:43.316]                       }
[16:20:43.316]                       invisible(muffled)
[16:20:43.316]                     }
[16:20:43.316]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.316]                   }
[16:20:43.316]                 }
[16:20:43.316]             }
[16:20:43.316]         }))
[16:20:43.316]     }, error = function(ex) {
[16:20:43.316]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.316]                 ...future.rng), started = ...future.startTime, 
[16:20:43.316]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.316]             version = "1.8"), class = "FutureResult")
[16:20:43.316]     }, finally = {
[16:20:43.316]         if (!identical(...future.workdir, getwd())) 
[16:20:43.316]             setwd(...future.workdir)
[16:20:43.316]         {
[16:20:43.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.316]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.316]             }
[16:20:43.316]             base::options(...future.oldOptions)
[16:20:43.316]             if (.Platform$OS.type == "windows") {
[16:20:43.316]                 old_names <- names(...future.oldEnvVars)
[16:20:43.316]                 envs <- base::Sys.getenv()
[16:20:43.316]                 names <- names(envs)
[16:20:43.316]                 common <- intersect(names, old_names)
[16:20:43.316]                 added <- setdiff(names, old_names)
[16:20:43.316]                 removed <- setdiff(old_names, names)
[16:20:43.316]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.316]                   envs[common]]
[16:20:43.316]                 NAMES <- toupper(changed)
[16:20:43.316]                 args <- list()
[16:20:43.316]                 for (kk in seq_along(NAMES)) {
[16:20:43.316]                   name <- changed[[kk]]
[16:20:43.316]                   NAME <- NAMES[[kk]]
[16:20:43.316]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.316]                     next
[16:20:43.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.316]                 }
[16:20:43.316]                 NAMES <- toupper(added)
[16:20:43.316]                 for (kk in seq_along(NAMES)) {
[16:20:43.316]                   name <- added[[kk]]
[16:20:43.316]                   NAME <- NAMES[[kk]]
[16:20:43.316]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.316]                     next
[16:20:43.316]                   args[[name]] <- ""
[16:20:43.316]                 }
[16:20:43.316]                 NAMES <- toupper(removed)
[16:20:43.316]                 for (kk in seq_along(NAMES)) {
[16:20:43.316]                   name <- removed[[kk]]
[16:20:43.316]                   NAME <- NAMES[[kk]]
[16:20:43.316]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.316]                     next
[16:20:43.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.316]                 }
[16:20:43.316]                 if (length(args) > 0) 
[16:20:43.316]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.316]             }
[16:20:43.316]             else {
[16:20:43.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.316]             }
[16:20:43.316]             {
[16:20:43.316]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.316]                   0L) {
[16:20:43.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.316]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.316]                   base::options(opts)
[16:20:43.316]                 }
[16:20:43.316]                 {
[16:20:43.316]                   {
[16:20:43.316]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.316]                     NULL
[16:20:43.316]                   }
[16:20:43.316]                   options(future.plan = NULL)
[16:20:43.316]                   if (is.na(NA_character_)) 
[16:20:43.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.316]                     .init = FALSE)
[16:20:43.316]                 }
[16:20:43.316]             }
[16:20:43.316]         }
[16:20:43.316]     })
[16:20:43.316]     if (TRUE) {
[16:20:43.316]         base::sink(type = "output", split = FALSE)
[16:20:43.316]         if (TRUE) {
[16:20:43.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.316]         }
[16:20:43.316]         else {
[16:20:43.316]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.316]         }
[16:20:43.316]         base::close(...future.stdout)
[16:20:43.316]         ...future.stdout <- NULL
[16:20:43.316]     }
[16:20:43.316]     ...future.result$conditions <- ...future.conditions
[16:20:43.316]     ...future.result$finished <- base::Sys.time()
[16:20:43.316]     ...future.result
[16:20:43.316] }
[16:20:43.318] requestCore(): workers = 2
[16:20:43.320] MulticoreFuture started
[16:20:43.321] - Launch lazy future ... done
[16:20:43.321] run() for ‘MulticoreFuture’ ... done
[16:20:43.321] getGlobalsAndPackages() ...
[16:20:43.321] Searching for globals...
[16:20:43.321] plan(): Setting new future strategy stack:
[16:20:43.322] List of future strategies:
[16:20:43.322] 1. sequential:
[16:20:43.322]    - args: function (..., envir = parent.frame())
[16:20:43.322]    - tweaked: FALSE
[16:20:43.322]    - call: NULL
[16:20:43.322] 
[16:20:43.323] Searching for globals ... DONE
[16:20:43.323] plan(): nbrOfWorkers() = 1
[16:20:43.323] - globals: [0] <none>
[16:20:43.323] getGlobalsAndPackages() ... DONE
[16:20:43.323] run() for ‘Future’ ...
[16:20:43.324] - state: ‘created’
[16:20:43.324] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.325] plan(): Setting new future strategy stack:
[16:20:43.325] List of future strategies:
[16:20:43.325] 1. multicore:
[16:20:43.325]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.325]    - tweaked: FALSE
[16:20:43.325]    - call: plan(strategy)
[16:20:43.329] plan(): nbrOfWorkers() = 2
[16:20:43.329] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.330]   - Field: ‘label’
[16:20:43.330]   - Field: ‘local’
[16:20:43.330]   - Field: ‘owner’
[16:20:43.330]   - Field: ‘envir’
[16:20:43.330]   - Field: ‘workers’
[16:20:43.330]   - Field: ‘packages’
[16:20:43.331]   - Field: ‘gc’
[16:20:43.331]   - Field: ‘job’
[16:20:43.331]   - Field: ‘conditions’
[16:20:43.331]   - Field: ‘expr’
[16:20:43.331]   - Field: ‘uuid’
[16:20:43.331]   - Field: ‘seed’
[16:20:43.332]   - Field: ‘version’
[16:20:43.332]   - Field: ‘result’
[16:20:43.332]   - Field: ‘asynchronous’
[16:20:43.332]   - Field: ‘calls’
[16:20:43.333]   - Field: ‘globals’
[16:20:43.333]   - Field: ‘stdout’
[16:20:43.333]   - Field: ‘earlySignal’
[16:20:43.333]   - Field: ‘lazy’
[16:20:43.333]   - Field: ‘state’
[16:20:43.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.334] - Launch lazy future ...
[16:20:43.334] Packages needed by the future expression (n = 0): <none>
[16:20:43.334] Packages needed by future strategies (n = 0): <none>
[16:20:43.335] {
[16:20:43.335]     {
[16:20:43.335]         {
[16:20:43.335]             ...future.startTime <- base::Sys.time()
[16:20:43.335]             {
[16:20:43.335]                 {
[16:20:43.335]                   {
[16:20:43.335]                     {
[16:20:43.335]                       base::local({
[16:20:43.335]                         has_future <- base::requireNamespace("future", 
[16:20:43.335]                           quietly = TRUE)
[16:20:43.335]                         if (has_future) {
[16:20:43.335]                           ns <- base::getNamespace("future")
[16:20:43.335]                           version <- ns[[".package"]][["version"]]
[16:20:43.335]                           if (is.null(version)) 
[16:20:43.335]                             version <- utils::packageVersion("future")
[16:20:43.335]                         }
[16:20:43.335]                         else {
[16:20:43.335]                           version <- NULL
[16:20:43.335]                         }
[16:20:43.335]                         if (!has_future || version < "1.8.0") {
[16:20:43.335]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.335]                             "", base::R.version$version.string), 
[16:20:43.335]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.335]                               "release", "version")], collapse = " "), 
[16:20:43.335]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.335]                             info)
[16:20:43.335]                           info <- base::paste(info, collapse = "; ")
[16:20:43.335]                           if (!has_future) {
[16:20:43.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.335]                               info)
[16:20:43.335]                           }
[16:20:43.335]                           else {
[16:20:43.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.335]                               info, version)
[16:20:43.335]                           }
[16:20:43.335]                           base::stop(msg)
[16:20:43.335]                         }
[16:20:43.335]                       })
[16:20:43.335]                     }
[16:20:43.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.335]                     base::options(mc.cores = 1L)
[16:20:43.335]                   }
[16:20:43.335]                   ...future.strategy.old <- future::plan("list")
[16:20:43.335]                   options(future.plan = NULL)
[16:20:43.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.335]                 }
[16:20:43.335]                 ...future.workdir <- getwd()
[16:20:43.335]             }
[16:20:43.335]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.335]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.335]         }
[16:20:43.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.335]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.335]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.335]             base::names(...future.oldOptions))
[16:20:43.335]     }
[16:20:43.335]     if (FALSE) {
[16:20:43.335]     }
[16:20:43.335]     else {
[16:20:43.335]         if (TRUE) {
[16:20:43.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.335]                 open = "w")
[16:20:43.335]         }
[16:20:43.335]         else {
[16:20:43.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.335]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.335]         }
[16:20:43.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.335]             base::sink(type = "output", split = FALSE)
[16:20:43.335]             base::close(...future.stdout)
[16:20:43.335]         }, add = TRUE)
[16:20:43.335]     }
[16:20:43.335]     ...future.frame <- base::sys.nframe()
[16:20:43.335]     ...future.conditions <- base::list()
[16:20:43.335]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.335]     if (FALSE) {
[16:20:43.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.335]     }
[16:20:43.335]     ...future.result <- base::tryCatch({
[16:20:43.335]         base::withCallingHandlers({
[16:20:43.335]             ...future.value <- base::withVisible(base::local({
[16:20:43.335]                 withCallingHandlers({
[16:20:43.335]                   NULL
[16:20:43.335]                 }, immediateCondition = function(cond) {
[16:20:43.335]                   save_rds <- function (object, pathname, ...) 
[16:20:43.335]                   {
[16:20:43.335]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.335]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.335]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.335]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.335]                         fi_tmp[["mtime"]])
[16:20:43.335]                     }
[16:20:43.335]                     tryCatch({
[16:20:43.335]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.335]                     }, error = function(ex) {
[16:20:43.335]                       msg <- conditionMessage(ex)
[16:20:43.335]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.335]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.335]                         fi_tmp[["mtime"]], msg)
[16:20:43.335]                       ex$message <- msg
[16:20:43.335]                       stop(ex)
[16:20:43.335]                     })
[16:20:43.335]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.335]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.335]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.335]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.335]                       fi <- file.info(pathname)
[16:20:43.335]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.335]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.335]                         fi[["size"]], fi[["mtime"]])
[16:20:43.335]                       stop(msg)
[16:20:43.335]                     }
[16:20:43.335]                     invisible(pathname)
[16:20:43.335]                   }
[16:20:43.335]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.335]                     rootPath = tempdir()) 
[16:20:43.335]                   {
[16:20:43.335]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.335]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.335]                       tmpdir = path, fileext = ".rds")
[16:20:43.335]                     save_rds(obj, file)
[16:20:43.335]                   }
[16:20:43.335]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.335]                   {
[16:20:43.335]                     inherits <- base::inherits
[16:20:43.335]                     invokeRestart <- base::invokeRestart
[16:20:43.335]                     is.null <- base::is.null
[16:20:43.335]                     muffled <- FALSE
[16:20:43.335]                     if (inherits(cond, "message")) {
[16:20:43.335]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.335]                       if (muffled) 
[16:20:43.335]                         invokeRestart("muffleMessage")
[16:20:43.335]                     }
[16:20:43.335]                     else if (inherits(cond, "warning")) {
[16:20:43.335]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.335]                       if (muffled) 
[16:20:43.335]                         invokeRestart("muffleWarning")
[16:20:43.335]                     }
[16:20:43.335]                     else if (inherits(cond, "condition")) {
[16:20:43.335]                       if (!is.null(pattern)) {
[16:20:43.335]                         computeRestarts <- base::computeRestarts
[16:20:43.335]                         grepl <- base::grepl
[16:20:43.335]                         restarts <- computeRestarts(cond)
[16:20:43.335]                         for (restart in restarts) {
[16:20:43.335]                           name <- restart$name
[16:20:43.335]                           if (is.null(name)) 
[16:20:43.335]                             next
[16:20:43.335]                           if (!grepl(pattern, name)) 
[16:20:43.335]                             next
[16:20:43.335]                           invokeRestart(restart)
[16:20:43.335]                           muffled <- TRUE
[16:20:43.335]                           break
[16:20:43.335]                         }
[16:20:43.335]                       }
[16:20:43.335]                     }
[16:20:43.335]                     invisible(muffled)
[16:20:43.335]                   }
[16:20:43.335]                   muffleCondition(cond)
[16:20:43.335]                 })
[16:20:43.335]             }))
[16:20:43.335]             future::FutureResult(value = ...future.value$value, 
[16:20:43.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.335]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.335]                     ...future.globalenv.names))
[16:20:43.335]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.335]         }, condition = base::local({
[16:20:43.335]             c <- base::c
[16:20:43.335]             inherits <- base::inherits
[16:20:43.335]             invokeRestart <- base::invokeRestart
[16:20:43.335]             length <- base::length
[16:20:43.335]             list <- base::list
[16:20:43.335]             seq.int <- base::seq.int
[16:20:43.335]             signalCondition <- base::signalCondition
[16:20:43.335]             sys.calls <- base::sys.calls
[16:20:43.335]             `[[` <- base::`[[`
[16:20:43.335]             `+` <- base::`+`
[16:20:43.335]             `<<-` <- base::`<<-`
[16:20:43.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.335]                   3L)]
[16:20:43.335]             }
[16:20:43.335]             function(cond) {
[16:20:43.335]                 is_error <- inherits(cond, "error")
[16:20:43.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.335]                   NULL)
[16:20:43.335]                 if (is_error) {
[16:20:43.335]                   sessionInformation <- function() {
[16:20:43.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.335]                       search = base::search(), system = base::Sys.info())
[16:20:43.335]                   }
[16:20:43.335]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.335]                     cond$call), session = sessionInformation(), 
[16:20:43.335]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.335]                   signalCondition(cond)
[16:20:43.335]                 }
[16:20:43.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.335]                 "immediateCondition"))) {
[16:20:43.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.335]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.335]                   if (TRUE && !signal) {
[16:20:43.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.335]                     {
[16:20:43.335]                       inherits <- base::inherits
[16:20:43.335]                       invokeRestart <- base::invokeRestart
[16:20:43.335]                       is.null <- base::is.null
[16:20:43.335]                       muffled <- FALSE
[16:20:43.335]                       if (inherits(cond, "message")) {
[16:20:43.335]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.335]                         if (muffled) 
[16:20:43.335]                           invokeRestart("muffleMessage")
[16:20:43.335]                       }
[16:20:43.335]                       else if (inherits(cond, "warning")) {
[16:20:43.335]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.335]                         if (muffled) 
[16:20:43.335]                           invokeRestart("muffleWarning")
[16:20:43.335]                       }
[16:20:43.335]                       else if (inherits(cond, "condition")) {
[16:20:43.335]                         if (!is.null(pattern)) {
[16:20:43.335]                           computeRestarts <- base::computeRestarts
[16:20:43.335]                           grepl <- base::grepl
[16:20:43.335]                           restarts <- computeRestarts(cond)
[16:20:43.335]                           for (restart in restarts) {
[16:20:43.335]                             name <- restart$name
[16:20:43.335]                             if (is.null(name)) 
[16:20:43.335]                               next
[16:20:43.335]                             if (!grepl(pattern, name)) 
[16:20:43.335]                               next
[16:20:43.335]                             invokeRestart(restart)
[16:20:43.335]                             muffled <- TRUE
[16:20:43.335]                             break
[16:20:43.335]                           }
[16:20:43.335]                         }
[16:20:43.335]                       }
[16:20:43.335]                       invisible(muffled)
[16:20:43.335]                     }
[16:20:43.335]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.335]                   }
[16:20:43.335]                 }
[16:20:43.335]                 else {
[16:20:43.335]                   if (TRUE) {
[16:20:43.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.335]                     {
[16:20:43.335]                       inherits <- base::inherits
[16:20:43.335]                       invokeRestart <- base::invokeRestart
[16:20:43.335]                       is.null <- base::is.null
[16:20:43.335]                       muffled <- FALSE
[16:20:43.335]                       if (inherits(cond, "message")) {
[16:20:43.335]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.335]                         if (muffled) 
[16:20:43.335]                           invokeRestart("muffleMessage")
[16:20:43.335]                       }
[16:20:43.335]                       else if (inherits(cond, "warning")) {
[16:20:43.335]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.335]                         if (muffled) 
[16:20:43.335]                           invokeRestart("muffleWarning")
[16:20:43.335]                       }
[16:20:43.335]                       else if (inherits(cond, "condition")) {
[16:20:43.335]                         if (!is.null(pattern)) {
[16:20:43.335]                           computeRestarts <- base::computeRestarts
[16:20:43.335]                           grepl <- base::grepl
[16:20:43.335]                           restarts <- computeRestarts(cond)
[16:20:43.335]                           for (restart in restarts) {
[16:20:43.335]                             name <- restart$name
[16:20:43.335]                             if (is.null(name)) 
[16:20:43.335]                               next
[16:20:43.335]                             if (!grepl(pattern, name)) 
[16:20:43.335]                               next
[16:20:43.335]                             invokeRestart(restart)
[16:20:43.335]                             muffled <- TRUE
[16:20:43.335]                             break
[16:20:43.335]                           }
[16:20:43.335]                         }
[16:20:43.335]                       }
[16:20:43.335]                       invisible(muffled)
[16:20:43.335]                     }
[16:20:43.335]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.335]                   }
[16:20:43.335]                 }
[16:20:43.335]             }
[16:20:43.335]         }))
[16:20:43.335]     }, error = function(ex) {
[16:20:43.335]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.335]                 ...future.rng), started = ...future.startTime, 
[16:20:43.335]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.335]             version = "1.8"), class = "FutureResult")
[16:20:43.335]     }, finally = {
[16:20:43.335]         if (!identical(...future.workdir, getwd())) 
[16:20:43.335]             setwd(...future.workdir)
[16:20:43.335]         {
[16:20:43.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.335]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.335]             }
[16:20:43.335]             base::options(...future.oldOptions)
[16:20:43.335]             if (.Platform$OS.type == "windows") {
[16:20:43.335]                 old_names <- names(...future.oldEnvVars)
[16:20:43.335]                 envs <- base::Sys.getenv()
[16:20:43.335]                 names <- names(envs)
[16:20:43.335]                 common <- intersect(names, old_names)
[16:20:43.335]                 added <- setdiff(names, old_names)
[16:20:43.335]                 removed <- setdiff(old_names, names)
[16:20:43.335]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.335]                   envs[common]]
[16:20:43.335]                 NAMES <- toupper(changed)
[16:20:43.335]                 args <- list()
[16:20:43.335]                 for (kk in seq_along(NAMES)) {
[16:20:43.335]                   name <- changed[[kk]]
[16:20:43.335]                   NAME <- NAMES[[kk]]
[16:20:43.335]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.335]                     next
[16:20:43.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.335]                 }
[16:20:43.335]                 NAMES <- toupper(added)
[16:20:43.335]                 for (kk in seq_along(NAMES)) {
[16:20:43.335]                   name <- added[[kk]]
[16:20:43.335]                   NAME <- NAMES[[kk]]
[16:20:43.335]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.335]                     next
[16:20:43.335]                   args[[name]] <- ""
[16:20:43.335]                 }
[16:20:43.335]                 NAMES <- toupper(removed)
[16:20:43.335]                 for (kk in seq_along(NAMES)) {
[16:20:43.335]                   name <- removed[[kk]]
[16:20:43.335]                   NAME <- NAMES[[kk]]
[16:20:43.335]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.335]                     next
[16:20:43.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.335]                 }
[16:20:43.335]                 if (length(args) > 0) 
[16:20:43.335]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.335]             }
[16:20:43.335]             else {
[16:20:43.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.335]             }
[16:20:43.335]             {
[16:20:43.335]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.335]                   0L) {
[16:20:43.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.335]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.335]                   base::options(opts)
[16:20:43.335]                 }
[16:20:43.335]                 {
[16:20:43.335]                   {
[16:20:43.335]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.335]                     NULL
[16:20:43.335]                   }
[16:20:43.335]                   options(future.plan = NULL)
[16:20:43.335]                   if (is.na(NA_character_)) 
[16:20:43.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.335]                     .init = FALSE)
[16:20:43.335]                 }
[16:20:43.335]             }
[16:20:43.335]         }
[16:20:43.335]     })
[16:20:43.335]     if (TRUE) {
[16:20:43.335]         base::sink(type = "output", split = FALSE)
[16:20:43.335]         if (TRUE) {
[16:20:43.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.335]         }
[16:20:43.335]         else {
[16:20:43.335]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.335]         }
[16:20:43.335]         base::close(...future.stdout)
[16:20:43.335]         ...future.stdout <- NULL
[16:20:43.335]     }
[16:20:43.335]     ...future.result$conditions <- ...future.conditions
[16:20:43.335]     ...future.result$finished <- base::Sys.time()
[16:20:43.335]     ...future.result
[16:20:43.335] }
[16:20:43.339] requestCore(): workers = 2
[16:20:43.341] MulticoreFuture started
[16:20:43.342] - Launch lazy future ... done
[16:20:43.342] run() for ‘MulticoreFuture’ ... done
[16:20:43.342] plan(): Setting new future strategy stack:
[16:20:43.343] getGlobalsAndPackages() ...
[16:20:43.343] Searching for globals...
[16:20:43.343] List of future strategies:
[16:20:43.343] 1. sequential:
[16:20:43.343]    - args: function (..., envir = parent.frame())
[16:20:43.343]    - tweaked: FALSE
[16:20:43.343]    - call: NULL
[16:20:43.344] plan(): nbrOfWorkers() = 1
[16:20:43.344] - globals found: [1] ‘{’
[16:20:43.345] Searching for globals ... DONE
[16:20:43.345] Resolving globals: FALSE
[16:20:43.345] 
[16:20:43.345] 
[16:20:43.346] plan(): Setting new future strategy stack:
[16:20:43.346] getGlobalsAndPackages() ... DONE
[16:20:43.346] run() for ‘Future’ ...
[16:20:43.346] List of future strategies:
[16:20:43.346] 1. multicore:
[16:20:43.346]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.346]    - tweaked: FALSE
[16:20:43.346]    - call: plan(strategy)
[16:20:43.346] - state: ‘created’
[16:20:43.346] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.351] plan(): nbrOfWorkers() = 2
[16:20:43.351] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.351] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.351]   - Field: ‘label’
[16:20:43.351]   - Field: ‘local’
[16:20:43.352]   - Field: ‘owner’
[16:20:43.352]   - Field: ‘envir’
[16:20:43.352]   - Field: ‘workers’
[16:20:43.352]   - Field: ‘packages’
[16:20:43.352]   - Field: ‘gc’
[16:20:43.352]   - Field: ‘job’
[16:20:43.352]   - Field: ‘conditions’
[16:20:43.353]   - Field: ‘expr’
[16:20:43.353]   - Field: ‘uuid’
[16:20:43.353]   - Field: ‘seed’
[16:20:43.353]   - Field: ‘version’
[16:20:43.353]   - Field: ‘result’
[16:20:43.353]   - Field: ‘asynchronous’
[16:20:43.353]   - Field: ‘calls’
[16:20:43.354]   - Field: ‘globals’
[16:20:43.354]   - Field: ‘stdout’
[16:20:43.354]   - Field: ‘earlySignal’
[16:20:43.354]   - Field: ‘lazy’
[16:20:43.354]   - Field: ‘state’
[16:20:43.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.354] - Launch lazy future ...
[16:20:43.355] Packages needed by the future expression (n = 0): <none>
[16:20:43.355] Packages needed by future strategies (n = 0): <none>
[16:20:43.356] {
[16:20:43.356]     {
[16:20:43.356]         {
[16:20:43.356]             ...future.startTime <- base::Sys.time()
[16:20:43.356]             {
[16:20:43.356]                 {
[16:20:43.356]                   {
[16:20:43.356]                     {
[16:20:43.356]                       base::local({
[16:20:43.356]                         has_future <- base::requireNamespace("future", 
[16:20:43.356]                           quietly = TRUE)
[16:20:43.356]                         if (has_future) {
[16:20:43.356]                           ns <- base::getNamespace("future")
[16:20:43.356]                           version <- ns[[".package"]][["version"]]
[16:20:43.356]                           if (is.null(version)) 
[16:20:43.356]                             version <- utils::packageVersion("future")
[16:20:43.356]                         }
[16:20:43.356]                         else {
[16:20:43.356]                           version <- NULL
[16:20:43.356]                         }
[16:20:43.356]                         if (!has_future || version < "1.8.0") {
[16:20:43.356]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.356]                             "", base::R.version$version.string), 
[16:20:43.356]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.356]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.356]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.356]                               "release", "version")], collapse = " "), 
[16:20:43.356]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.356]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.356]                             info)
[16:20:43.356]                           info <- base::paste(info, collapse = "; ")
[16:20:43.356]                           if (!has_future) {
[16:20:43.356]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.356]                               info)
[16:20:43.356]                           }
[16:20:43.356]                           else {
[16:20:43.356]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.356]                               info, version)
[16:20:43.356]                           }
[16:20:43.356]                           base::stop(msg)
[16:20:43.356]                         }
[16:20:43.356]                       })
[16:20:43.356]                     }
[16:20:43.356]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.356]                     base::options(mc.cores = 1L)
[16:20:43.356]                   }
[16:20:43.356]                   ...future.strategy.old <- future::plan("list")
[16:20:43.356]                   options(future.plan = NULL)
[16:20:43.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.356]                 }
[16:20:43.356]                 ...future.workdir <- getwd()
[16:20:43.356]             }
[16:20:43.356]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.356]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.356]         }
[16:20:43.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.356]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.356]             base::names(...future.oldOptions))
[16:20:43.356]     }
[16:20:43.356]     if (FALSE) {
[16:20:43.356]     }
[16:20:43.356]     else {
[16:20:43.356]         if (TRUE) {
[16:20:43.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.356]                 open = "w")
[16:20:43.356]         }
[16:20:43.356]         else {
[16:20:43.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.356]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.356]         }
[16:20:43.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.356]             base::sink(type = "output", split = FALSE)
[16:20:43.356]             base::close(...future.stdout)
[16:20:43.356]         }, add = TRUE)
[16:20:43.356]     }
[16:20:43.356]     ...future.frame <- base::sys.nframe()
[16:20:43.356]     ...future.conditions <- base::list()
[16:20:43.356]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.356]     if (FALSE) {
[16:20:43.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.356]     }
[16:20:43.356]     ...future.result <- base::tryCatch({
[16:20:43.356]         base::withCallingHandlers({
[16:20:43.356]             ...future.value <- base::withVisible(base::local({
[16:20:43.356]                 withCallingHandlers({
[16:20:43.356]                   {
[16:20:43.356]                     4
[16:20:43.356]                   }
[16:20:43.356]                 }, immediateCondition = function(cond) {
[16:20:43.356]                   save_rds <- function (object, pathname, ...) 
[16:20:43.356]                   {
[16:20:43.356]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.356]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.356]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.356]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.356]                         fi_tmp[["mtime"]])
[16:20:43.356]                     }
[16:20:43.356]                     tryCatch({
[16:20:43.356]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.356]                     }, error = function(ex) {
[16:20:43.356]                       msg <- conditionMessage(ex)
[16:20:43.356]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.356]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.356]                         fi_tmp[["mtime"]], msg)
[16:20:43.356]                       ex$message <- msg
[16:20:43.356]                       stop(ex)
[16:20:43.356]                     })
[16:20:43.356]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.356]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.356]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.356]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.356]                       fi <- file.info(pathname)
[16:20:43.356]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.356]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.356]                         fi[["size"]], fi[["mtime"]])
[16:20:43.356]                       stop(msg)
[16:20:43.356]                     }
[16:20:43.356]                     invisible(pathname)
[16:20:43.356]                   }
[16:20:43.356]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.356]                     rootPath = tempdir()) 
[16:20:43.356]                   {
[16:20:43.356]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.356]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.356]                       tmpdir = path, fileext = ".rds")
[16:20:43.356]                     save_rds(obj, file)
[16:20:43.356]                   }
[16:20:43.356]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.356]                   {
[16:20:43.356]                     inherits <- base::inherits
[16:20:43.356]                     invokeRestart <- base::invokeRestart
[16:20:43.356]                     is.null <- base::is.null
[16:20:43.356]                     muffled <- FALSE
[16:20:43.356]                     if (inherits(cond, "message")) {
[16:20:43.356]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.356]                       if (muffled) 
[16:20:43.356]                         invokeRestart("muffleMessage")
[16:20:43.356]                     }
[16:20:43.356]                     else if (inherits(cond, "warning")) {
[16:20:43.356]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.356]                       if (muffled) 
[16:20:43.356]                         invokeRestart("muffleWarning")
[16:20:43.356]                     }
[16:20:43.356]                     else if (inherits(cond, "condition")) {
[16:20:43.356]                       if (!is.null(pattern)) {
[16:20:43.356]                         computeRestarts <- base::computeRestarts
[16:20:43.356]                         grepl <- base::grepl
[16:20:43.356]                         restarts <- computeRestarts(cond)
[16:20:43.356]                         for (restart in restarts) {
[16:20:43.356]                           name <- restart$name
[16:20:43.356]                           if (is.null(name)) 
[16:20:43.356]                             next
[16:20:43.356]                           if (!grepl(pattern, name)) 
[16:20:43.356]                             next
[16:20:43.356]                           invokeRestart(restart)
[16:20:43.356]                           muffled <- TRUE
[16:20:43.356]                           break
[16:20:43.356]                         }
[16:20:43.356]                       }
[16:20:43.356]                     }
[16:20:43.356]                     invisible(muffled)
[16:20:43.356]                   }
[16:20:43.356]                   muffleCondition(cond)
[16:20:43.356]                 })
[16:20:43.356]             }))
[16:20:43.356]             future::FutureResult(value = ...future.value$value, 
[16:20:43.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.356]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.356]                     ...future.globalenv.names))
[16:20:43.356]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.356]         }, condition = base::local({
[16:20:43.356]             c <- base::c
[16:20:43.356]             inherits <- base::inherits
[16:20:43.356]             invokeRestart <- base::invokeRestart
[16:20:43.356]             length <- base::length
[16:20:43.356]             list <- base::list
[16:20:43.356]             seq.int <- base::seq.int
[16:20:43.356]             signalCondition <- base::signalCondition
[16:20:43.356]             sys.calls <- base::sys.calls
[16:20:43.356]             `[[` <- base::`[[`
[16:20:43.356]             `+` <- base::`+`
[16:20:43.356]             `<<-` <- base::`<<-`
[16:20:43.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.356]                   3L)]
[16:20:43.356]             }
[16:20:43.356]             function(cond) {
[16:20:43.356]                 is_error <- inherits(cond, "error")
[16:20:43.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.356]                   NULL)
[16:20:43.356]                 if (is_error) {
[16:20:43.356]                   sessionInformation <- function() {
[16:20:43.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.356]                       search = base::search(), system = base::Sys.info())
[16:20:43.356]                   }
[16:20:43.356]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.356]                     cond$call), session = sessionInformation(), 
[16:20:43.356]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.356]                   signalCondition(cond)
[16:20:43.356]                 }
[16:20:43.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.356]                 "immediateCondition"))) {
[16:20:43.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.356]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.356]                   if (TRUE && !signal) {
[16:20:43.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.356]                     {
[16:20:43.356]                       inherits <- base::inherits
[16:20:43.356]                       invokeRestart <- base::invokeRestart
[16:20:43.356]                       is.null <- base::is.null
[16:20:43.356]                       muffled <- FALSE
[16:20:43.356]                       if (inherits(cond, "message")) {
[16:20:43.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.356]                         if (muffled) 
[16:20:43.356]                           invokeRestart("muffleMessage")
[16:20:43.356]                       }
[16:20:43.356]                       else if (inherits(cond, "warning")) {
[16:20:43.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.356]                         if (muffled) 
[16:20:43.356]                           invokeRestart("muffleWarning")
[16:20:43.356]                       }
[16:20:43.356]                       else if (inherits(cond, "condition")) {
[16:20:43.356]                         if (!is.null(pattern)) {
[16:20:43.356]                           computeRestarts <- base::computeRestarts
[16:20:43.356]                           grepl <- base::grepl
[16:20:43.356]                           restarts <- computeRestarts(cond)
[16:20:43.356]                           for (restart in restarts) {
[16:20:43.356]                             name <- restart$name
[16:20:43.356]                             if (is.null(name)) 
[16:20:43.356]                               next
[16:20:43.356]                             if (!grepl(pattern, name)) 
[16:20:43.356]                               next
[16:20:43.356]                             invokeRestart(restart)
[16:20:43.356]                             muffled <- TRUE
[16:20:43.356]                             break
[16:20:43.356]                           }
[16:20:43.356]                         }
[16:20:43.356]                       }
[16:20:43.356]                       invisible(muffled)
[16:20:43.356]                     }
[16:20:43.356]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.356]                   }
[16:20:43.356]                 }
[16:20:43.356]                 else {
[16:20:43.356]                   if (TRUE) {
[16:20:43.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.356]                     {
[16:20:43.356]                       inherits <- base::inherits
[16:20:43.356]                       invokeRestart <- base::invokeRestart
[16:20:43.356]                       is.null <- base::is.null
[16:20:43.356]                       muffled <- FALSE
[16:20:43.356]                       if (inherits(cond, "message")) {
[16:20:43.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.356]                         if (muffled) 
[16:20:43.356]                           invokeRestart("muffleMessage")
[16:20:43.356]                       }
[16:20:43.356]                       else if (inherits(cond, "warning")) {
[16:20:43.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.356]                         if (muffled) 
[16:20:43.356]                           invokeRestart("muffleWarning")
[16:20:43.356]                       }
[16:20:43.356]                       else if (inherits(cond, "condition")) {
[16:20:43.356]                         if (!is.null(pattern)) {
[16:20:43.356]                           computeRestarts <- base::computeRestarts
[16:20:43.356]                           grepl <- base::grepl
[16:20:43.356]                           restarts <- computeRestarts(cond)
[16:20:43.356]                           for (restart in restarts) {
[16:20:43.356]                             name <- restart$name
[16:20:43.356]                             if (is.null(name)) 
[16:20:43.356]                               next
[16:20:43.356]                             if (!grepl(pattern, name)) 
[16:20:43.356]                               next
[16:20:43.356]                             invokeRestart(restart)
[16:20:43.356]                             muffled <- TRUE
[16:20:43.356]                             break
[16:20:43.356]                           }
[16:20:43.356]                         }
[16:20:43.356]                       }
[16:20:43.356]                       invisible(muffled)
[16:20:43.356]                     }
[16:20:43.356]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.356]                   }
[16:20:43.356]                 }
[16:20:43.356]             }
[16:20:43.356]         }))
[16:20:43.356]     }, error = function(ex) {
[16:20:43.356]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.356]                 ...future.rng), started = ...future.startTime, 
[16:20:43.356]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.356]             version = "1.8"), class = "FutureResult")
[16:20:43.356]     }, finally = {
[16:20:43.356]         if (!identical(...future.workdir, getwd())) 
[16:20:43.356]             setwd(...future.workdir)
[16:20:43.356]         {
[16:20:43.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.356]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.356]             }
[16:20:43.356]             base::options(...future.oldOptions)
[16:20:43.356]             if (.Platform$OS.type == "windows") {
[16:20:43.356]                 old_names <- names(...future.oldEnvVars)
[16:20:43.356]                 envs <- base::Sys.getenv()
[16:20:43.356]                 names <- names(envs)
[16:20:43.356]                 common <- intersect(names, old_names)
[16:20:43.356]                 added <- setdiff(names, old_names)
[16:20:43.356]                 removed <- setdiff(old_names, names)
[16:20:43.356]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.356]                   envs[common]]
[16:20:43.356]                 NAMES <- toupper(changed)
[16:20:43.356]                 args <- list()
[16:20:43.356]                 for (kk in seq_along(NAMES)) {
[16:20:43.356]                   name <- changed[[kk]]
[16:20:43.356]                   NAME <- NAMES[[kk]]
[16:20:43.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.356]                     next
[16:20:43.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.356]                 }
[16:20:43.356]                 NAMES <- toupper(added)
[16:20:43.356]                 for (kk in seq_along(NAMES)) {
[16:20:43.356]                   name <- added[[kk]]
[16:20:43.356]                   NAME <- NAMES[[kk]]
[16:20:43.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.356]                     next
[16:20:43.356]                   args[[name]] <- ""
[16:20:43.356]                 }
[16:20:43.356]                 NAMES <- toupper(removed)
[16:20:43.356]                 for (kk in seq_along(NAMES)) {
[16:20:43.356]                   name <- removed[[kk]]
[16:20:43.356]                   NAME <- NAMES[[kk]]
[16:20:43.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.356]                     next
[16:20:43.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.356]                 }
[16:20:43.356]                 if (length(args) > 0) 
[16:20:43.356]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.356]             }
[16:20:43.356]             else {
[16:20:43.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.356]             }
[16:20:43.356]             {
[16:20:43.356]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.356]                   0L) {
[16:20:43.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.356]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.356]                   base::options(opts)
[16:20:43.356]                 }
[16:20:43.356]                 {
[16:20:43.356]                   {
[16:20:43.356]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.356]                     NULL
[16:20:43.356]                   }
[16:20:43.356]                   options(future.plan = NULL)
[16:20:43.356]                   if (is.na(NA_character_)) 
[16:20:43.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.356]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.356]                     .init = FALSE)
[16:20:43.356]                 }
[16:20:43.356]             }
[16:20:43.356]         }
[16:20:43.356]     })
[16:20:43.356]     if (TRUE) {
[16:20:43.356]         base::sink(type = "output", split = FALSE)
[16:20:43.356]         if (TRUE) {
[16:20:43.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.356]         }
[16:20:43.356]         else {
[16:20:43.356]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.356]         }
[16:20:43.356]         base::close(...future.stdout)
[16:20:43.356]         ...future.stdout <- NULL
[16:20:43.356]     }
[16:20:43.356]     ...future.result$conditions <- ...future.conditions
[16:20:43.356]     ...future.result$finished <- base::Sys.time()
[16:20:43.356]     ...future.result
[16:20:43.356] }
[16:20:43.359] requestCore(): workers = 2
[16:20:43.359] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:43.382] result() for MulticoreFuture ...
[16:20:43.383] result() for MulticoreFuture ...
[16:20:43.383] result() for MulticoreFuture ... done
[16:20:43.383] result() for MulticoreFuture ... done
[16:20:43.383] result() for MulticoreFuture ...
[16:20:43.384] result() for MulticoreFuture ... done
[16:20:43.386] MulticoreFuture started
[16:20:43.387] - Launch lazy future ... done
[16:20:43.387] run() for ‘MulticoreFuture’ ... done
[16:20:43.388] plan(): Setting new future strategy stack:
<environment: 0x55ed0bf31968> 
[16:20:43.388] List of future strategies:
[16:20:43.388] 1. sequential:
[16:20:43.388]    - args: function (..., envir = parent.frame())
[16:20:43.388]    - tweaked: FALSE
[16:20:43.388]    - call: NULL
[16:20:43.389] plan(): nbrOfWorkers() = 1
<environment: 0x55ed0d8d6818> 
[16:20:43.392] plan(): Setting new future strategy stack:
[16:20:43.392] List of future strategies:
[16:20:43.392] 1. multicore:
[16:20:43.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.392]    - tweaked: FALSE
[16:20:43.392]    - call: plan(strategy)
[16:20:43.397] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:43.399] resolve() on environment ...
[16:20:43.399]  recursive: 0
[16:20:43.400]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:43.400] signalConditionsASAP(numeric, pos=1) ...
[16:20:43.400] - nx: 4
[16:20:43.401] - relay: TRUE
[16:20:43.401] - stdout: TRUE
[16:20:43.401] - signal: TRUE
[16:20:43.401] - resignal: FALSE
[16:20:43.401] - force: TRUE
[16:20:43.401] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.401] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.401]  - until=2
[16:20:43.402]  - relaying element #2
[16:20:43.402] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.402] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.402] signalConditionsASAP(NULL, pos=1) ... done
[16:20:43.402]  length: 3 (resolved future 1)
[16:20:43.402] Future #2
[16:20:43.402] result() for MulticoreFuture ...
[16:20:43.403] result() for MulticoreFuture ... done
[16:20:43.403] result() for MulticoreFuture ...
[16:20:43.403] result() for MulticoreFuture ... done
[16:20:43.403] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:43.403] - nx: 4
[16:20:43.403] - relay: TRUE
[16:20:43.403] - stdout: TRUE
[16:20:43.404] - signal: TRUE
[16:20:43.404] - resignal: FALSE
[16:20:43.404] - force: TRUE
[16:20:43.404] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.404] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.404]  - until=2
[16:20:43.404]  - relaying element #2
[16:20:43.404] result() for MulticoreFuture ...
[16:20:43.405] result() for MulticoreFuture ... done
[16:20:43.405] result() for MulticoreFuture ...
[16:20:43.405] result() for MulticoreFuture ... done
[16:20:43.405] result() for MulticoreFuture ...
[16:20:43.405] result() for MulticoreFuture ... done
[16:20:43.405] result() for MulticoreFuture ...
[16:20:43.405] result() for MulticoreFuture ... done
[16:20:43.405] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.406] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.406] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:43.406]  length: 2 (resolved future 2)
[16:20:43.406] Future #3
[16:20:43.406] result() for MulticoreFuture ...
[16:20:43.407] result() for MulticoreFuture ...
[16:20:43.407] result() for MulticoreFuture ... done
[16:20:43.407] result() for MulticoreFuture ... done
[16:20:43.408] result() for MulticoreFuture ...
[16:20:43.408] result() for MulticoreFuture ... done
[16:20:43.408] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:43.408] - nx: 4
[16:20:43.408] - relay: TRUE
[16:20:43.408] - stdout: TRUE
[16:20:43.408] - signal: TRUE
[16:20:43.408] - resignal: FALSE
[16:20:43.409] - force: TRUE
[16:20:43.409] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.409] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.409]  - until=3
[16:20:43.409]  - relaying element #3
[16:20:43.409] result() for MulticoreFuture ...
[16:20:43.409] result() for MulticoreFuture ... done
[16:20:43.410] result() for MulticoreFuture ...
[16:20:43.410] result() for MulticoreFuture ... done
[16:20:43.410] result() for MulticoreFuture ...
[16:20:43.410] result() for MulticoreFuture ... done
[16:20:43.410] result() for MulticoreFuture ...
[16:20:43.410] result() for MulticoreFuture ... done
[16:20:43.410] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.411] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.411] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:43.411]  length: 1 (resolved future 3)
[16:20:43.411] Future #4
[16:20:43.411] result() for MulticoreFuture ...
[16:20:43.412] result() for MulticoreFuture ...
[16:20:43.412] result() for MulticoreFuture ... done
[16:20:43.412] result() for MulticoreFuture ... done
[16:20:43.412] result() for MulticoreFuture ...
[16:20:43.413] result() for MulticoreFuture ... done
[16:20:43.413] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:43.413] - nx: 4
[16:20:43.413] - relay: TRUE
[16:20:43.413] - stdout: TRUE
[16:20:43.414] - signal: TRUE
[16:20:43.414] - resignal: FALSE
[16:20:43.414] - force: TRUE
[16:20:43.414] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.414] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.414]  - until=4
[16:20:43.414]  - relaying element #4
[16:20:43.415] result() for MulticoreFuture ...
[16:20:43.415] result() for MulticoreFuture ... done
[16:20:43.415] result() for MulticoreFuture ...
[16:20:43.415] result() for MulticoreFuture ... done
[16:20:43.415] result() for MulticoreFuture ...
[16:20:43.415] result() for MulticoreFuture ... done
[16:20:43.416] result() for MulticoreFuture ...
[16:20:43.416] result() for MulticoreFuture ... done
[16:20:43.416] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.416] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.416] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:43.416]  length: 0 (resolved future 4)
[16:20:43.416] Relaying remaining futures
[16:20:43.416] signalConditionsASAP(NULL, pos=0) ...
[16:20:43.416] - nx: 4
[16:20:43.417] - relay: TRUE
[16:20:43.417] - stdout: TRUE
[16:20:43.417] - signal: TRUE
[16:20:43.417] - resignal: FALSE
[16:20:43.417] - force: TRUE
[16:20:43.417] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.417] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:43.417] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.417] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.417] signalConditionsASAP(NULL, pos=0) ... done
[16:20:43.418] resolve() on environment ... DONE
[16:20:43.418] result() for MulticoreFuture ...
[16:20:43.418] result() for MulticoreFuture ... done
[16:20:43.418] result() for MulticoreFuture ...
[16:20:43.418] result() for MulticoreFuture ... done
[16:20:43.418] result() for MulticoreFuture ...
[16:20:43.418] result() for MulticoreFuture ... done
[16:20:43.418] result() for MulticoreFuture ...
[16:20:43.418] result() for MulticoreFuture ... done
[16:20:43.419] result() for MulticoreFuture ...
[16:20:43.419] result() for MulticoreFuture ... done
[16:20:43.419] result() for MulticoreFuture ...
[16:20:43.419] result() for MulticoreFuture ... done
<environment: 0x55ed0d98d920> 
Dimensions: c(2, 3)
[16:20:43.419] getGlobalsAndPackages() ...
[16:20:43.419] Searching for globals...
[16:20:43.420] 
[16:20:43.420] Searching for globals ... DONE
[16:20:43.420] - globals: [0] <none>
[16:20:43.420] getGlobalsAndPackages() ... DONE
[16:20:43.421] run() for ‘Future’ ...
[16:20:43.421] - state: ‘created’
[16:20:43.421] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.425] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.425]   - Field: ‘label’
[16:20:43.425]   - Field: ‘local’
[16:20:43.426]   - Field: ‘owner’
[16:20:43.426]   - Field: ‘envir’
[16:20:43.426]   - Field: ‘workers’
[16:20:43.426]   - Field: ‘packages’
[16:20:43.426]   - Field: ‘gc’
[16:20:43.426]   - Field: ‘job’
[16:20:43.426]   - Field: ‘conditions’
[16:20:43.426]   - Field: ‘expr’
[16:20:43.426]   - Field: ‘uuid’
[16:20:43.426]   - Field: ‘seed’
[16:20:43.427]   - Field: ‘version’
[16:20:43.427]   - Field: ‘result’
[16:20:43.427]   - Field: ‘asynchronous’
[16:20:43.427]   - Field: ‘calls’
[16:20:43.427]   - Field: ‘globals’
[16:20:43.427]   - Field: ‘stdout’
[16:20:43.427]   - Field: ‘earlySignal’
[16:20:43.427]   - Field: ‘lazy’
[16:20:43.427]   - Field: ‘state’
[16:20:43.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.431] - Launch lazy future ...
[16:20:43.431] Packages needed by the future expression (n = 0): <none>
[16:20:43.431] Packages needed by future strategies (n = 0): <none>
[16:20:43.432] {
[16:20:43.432]     {
[16:20:43.432]         {
[16:20:43.432]             ...future.startTime <- base::Sys.time()
[16:20:43.432]             {
[16:20:43.432]                 {
[16:20:43.432]                   {
[16:20:43.432]                     {
[16:20:43.432]                       base::local({
[16:20:43.432]                         has_future <- base::requireNamespace("future", 
[16:20:43.432]                           quietly = TRUE)
[16:20:43.432]                         if (has_future) {
[16:20:43.432]                           ns <- base::getNamespace("future")
[16:20:43.432]                           version <- ns[[".package"]][["version"]]
[16:20:43.432]                           if (is.null(version)) 
[16:20:43.432]                             version <- utils::packageVersion("future")
[16:20:43.432]                         }
[16:20:43.432]                         else {
[16:20:43.432]                           version <- NULL
[16:20:43.432]                         }
[16:20:43.432]                         if (!has_future || version < "1.8.0") {
[16:20:43.432]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.432]                             "", base::R.version$version.string), 
[16:20:43.432]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.432]                               "release", "version")], collapse = " "), 
[16:20:43.432]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.432]                             info)
[16:20:43.432]                           info <- base::paste(info, collapse = "; ")
[16:20:43.432]                           if (!has_future) {
[16:20:43.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.432]                               info)
[16:20:43.432]                           }
[16:20:43.432]                           else {
[16:20:43.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.432]                               info, version)
[16:20:43.432]                           }
[16:20:43.432]                           base::stop(msg)
[16:20:43.432]                         }
[16:20:43.432]                       })
[16:20:43.432]                     }
[16:20:43.432]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.432]                     base::options(mc.cores = 1L)
[16:20:43.432]                   }
[16:20:43.432]                   ...future.strategy.old <- future::plan("list")
[16:20:43.432]                   options(future.plan = NULL)
[16:20:43.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.432]                 }
[16:20:43.432]                 ...future.workdir <- getwd()
[16:20:43.432]             }
[16:20:43.432]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.432]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.432]         }
[16:20:43.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.432]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.432]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.432]             base::names(...future.oldOptions))
[16:20:43.432]     }
[16:20:43.432]     if (FALSE) {
[16:20:43.432]     }
[16:20:43.432]     else {
[16:20:43.432]         if (TRUE) {
[16:20:43.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.432]                 open = "w")
[16:20:43.432]         }
[16:20:43.432]         else {
[16:20:43.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.432]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.432]         }
[16:20:43.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.432]             base::sink(type = "output", split = FALSE)
[16:20:43.432]             base::close(...future.stdout)
[16:20:43.432]         }, add = TRUE)
[16:20:43.432]     }
[16:20:43.432]     ...future.frame <- base::sys.nframe()
[16:20:43.432]     ...future.conditions <- base::list()
[16:20:43.432]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.432]     if (FALSE) {
[16:20:43.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.432]     }
[16:20:43.432]     ...future.result <- base::tryCatch({
[16:20:43.432]         base::withCallingHandlers({
[16:20:43.432]             ...future.value <- base::withVisible(base::local({
[16:20:43.432]                 withCallingHandlers({
[16:20:43.432]                   2
[16:20:43.432]                 }, immediateCondition = function(cond) {
[16:20:43.432]                   save_rds <- function (object, pathname, ...) 
[16:20:43.432]                   {
[16:20:43.432]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.432]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.432]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.432]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.432]                         fi_tmp[["mtime"]])
[16:20:43.432]                     }
[16:20:43.432]                     tryCatch({
[16:20:43.432]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.432]                     }, error = function(ex) {
[16:20:43.432]                       msg <- conditionMessage(ex)
[16:20:43.432]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.432]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.432]                         fi_tmp[["mtime"]], msg)
[16:20:43.432]                       ex$message <- msg
[16:20:43.432]                       stop(ex)
[16:20:43.432]                     })
[16:20:43.432]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.432]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.432]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.432]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.432]                       fi <- file.info(pathname)
[16:20:43.432]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.432]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.432]                         fi[["size"]], fi[["mtime"]])
[16:20:43.432]                       stop(msg)
[16:20:43.432]                     }
[16:20:43.432]                     invisible(pathname)
[16:20:43.432]                   }
[16:20:43.432]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.432]                     rootPath = tempdir()) 
[16:20:43.432]                   {
[16:20:43.432]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.432]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.432]                       tmpdir = path, fileext = ".rds")
[16:20:43.432]                     save_rds(obj, file)
[16:20:43.432]                   }
[16:20:43.432]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.432]                   {
[16:20:43.432]                     inherits <- base::inherits
[16:20:43.432]                     invokeRestart <- base::invokeRestart
[16:20:43.432]                     is.null <- base::is.null
[16:20:43.432]                     muffled <- FALSE
[16:20:43.432]                     if (inherits(cond, "message")) {
[16:20:43.432]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.432]                       if (muffled) 
[16:20:43.432]                         invokeRestart("muffleMessage")
[16:20:43.432]                     }
[16:20:43.432]                     else if (inherits(cond, "warning")) {
[16:20:43.432]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.432]                       if (muffled) 
[16:20:43.432]                         invokeRestart("muffleWarning")
[16:20:43.432]                     }
[16:20:43.432]                     else if (inherits(cond, "condition")) {
[16:20:43.432]                       if (!is.null(pattern)) {
[16:20:43.432]                         computeRestarts <- base::computeRestarts
[16:20:43.432]                         grepl <- base::grepl
[16:20:43.432]                         restarts <- computeRestarts(cond)
[16:20:43.432]                         for (restart in restarts) {
[16:20:43.432]                           name <- restart$name
[16:20:43.432]                           if (is.null(name)) 
[16:20:43.432]                             next
[16:20:43.432]                           if (!grepl(pattern, name)) 
[16:20:43.432]                             next
[16:20:43.432]                           invokeRestart(restart)
[16:20:43.432]                           muffled <- TRUE
[16:20:43.432]                           break
[16:20:43.432]                         }
[16:20:43.432]                       }
[16:20:43.432]                     }
[16:20:43.432]                     invisible(muffled)
[16:20:43.432]                   }
[16:20:43.432]                   muffleCondition(cond)
[16:20:43.432]                 })
[16:20:43.432]             }))
[16:20:43.432]             future::FutureResult(value = ...future.value$value, 
[16:20:43.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.432]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.432]                     ...future.globalenv.names))
[16:20:43.432]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.432]         }, condition = base::local({
[16:20:43.432]             c <- base::c
[16:20:43.432]             inherits <- base::inherits
[16:20:43.432]             invokeRestart <- base::invokeRestart
[16:20:43.432]             length <- base::length
[16:20:43.432]             list <- base::list
[16:20:43.432]             seq.int <- base::seq.int
[16:20:43.432]             signalCondition <- base::signalCondition
[16:20:43.432]             sys.calls <- base::sys.calls
[16:20:43.432]             `[[` <- base::`[[`
[16:20:43.432]             `+` <- base::`+`
[16:20:43.432]             `<<-` <- base::`<<-`
[16:20:43.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.432]                   3L)]
[16:20:43.432]             }
[16:20:43.432]             function(cond) {
[16:20:43.432]                 is_error <- inherits(cond, "error")
[16:20:43.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.432]                   NULL)
[16:20:43.432]                 if (is_error) {
[16:20:43.432]                   sessionInformation <- function() {
[16:20:43.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.432]                       search = base::search(), system = base::Sys.info())
[16:20:43.432]                   }
[16:20:43.432]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.432]                     cond$call), session = sessionInformation(), 
[16:20:43.432]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.432]                   signalCondition(cond)
[16:20:43.432]                 }
[16:20:43.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.432]                 "immediateCondition"))) {
[16:20:43.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.432]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.432]                   if (TRUE && !signal) {
[16:20:43.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.432]                     {
[16:20:43.432]                       inherits <- base::inherits
[16:20:43.432]                       invokeRestart <- base::invokeRestart
[16:20:43.432]                       is.null <- base::is.null
[16:20:43.432]                       muffled <- FALSE
[16:20:43.432]                       if (inherits(cond, "message")) {
[16:20:43.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.432]                         if (muffled) 
[16:20:43.432]                           invokeRestart("muffleMessage")
[16:20:43.432]                       }
[16:20:43.432]                       else if (inherits(cond, "warning")) {
[16:20:43.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.432]                         if (muffled) 
[16:20:43.432]                           invokeRestart("muffleWarning")
[16:20:43.432]                       }
[16:20:43.432]                       else if (inherits(cond, "condition")) {
[16:20:43.432]                         if (!is.null(pattern)) {
[16:20:43.432]                           computeRestarts <- base::computeRestarts
[16:20:43.432]                           grepl <- base::grepl
[16:20:43.432]                           restarts <- computeRestarts(cond)
[16:20:43.432]                           for (restart in restarts) {
[16:20:43.432]                             name <- restart$name
[16:20:43.432]                             if (is.null(name)) 
[16:20:43.432]                               next
[16:20:43.432]                             if (!grepl(pattern, name)) 
[16:20:43.432]                               next
[16:20:43.432]                             invokeRestart(restart)
[16:20:43.432]                             muffled <- TRUE
[16:20:43.432]                             break
[16:20:43.432]                           }
[16:20:43.432]                         }
[16:20:43.432]                       }
[16:20:43.432]                       invisible(muffled)
[16:20:43.432]                     }
[16:20:43.432]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.432]                   }
[16:20:43.432]                 }
[16:20:43.432]                 else {
[16:20:43.432]                   if (TRUE) {
[16:20:43.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.432]                     {
[16:20:43.432]                       inherits <- base::inherits
[16:20:43.432]                       invokeRestart <- base::invokeRestart
[16:20:43.432]                       is.null <- base::is.null
[16:20:43.432]                       muffled <- FALSE
[16:20:43.432]                       if (inherits(cond, "message")) {
[16:20:43.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.432]                         if (muffled) 
[16:20:43.432]                           invokeRestart("muffleMessage")
[16:20:43.432]                       }
[16:20:43.432]                       else if (inherits(cond, "warning")) {
[16:20:43.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.432]                         if (muffled) 
[16:20:43.432]                           invokeRestart("muffleWarning")
[16:20:43.432]                       }
[16:20:43.432]                       else if (inherits(cond, "condition")) {
[16:20:43.432]                         if (!is.null(pattern)) {
[16:20:43.432]                           computeRestarts <- base::computeRestarts
[16:20:43.432]                           grepl <- base::grepl
[16:20:43.432]                           restarts <- computeRestarts(cond)
[16:20:43.432]                           for (restart in restarts) {
[16:20:43.432]                             name <- restart$name
[16:20:43.432]                             if (is.null(name)) 
[16:20:43.432]                               next
[16:20:43.432]                             if (!grepl(pattern, name)) 
[16:20:43.432]                               next
[16:20:43.432]                             invokeRestart(restart)
[16:20:43.432]                             muffled <- TRUE
[16:20:43.432]                             break
[16:20:43.432]                           }
[16:20:43.432]                         }
[16:20:43.432]                       }
[16:20:43.432]                       invisible(muffled)
[16:20:43.432]                     }
[16:20:43.432]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.432]                   }
[16:20:43.432]                 }
[16:20:43.432]             }
[16:20:43.432]         }))
[16:20:43.432]     }, error = function(ex) {
[16:20:43.432]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.432]                 ...future.rng), started = ...future.startTime, 
[16:20:43.432]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.432]             version = "1.8"), class = "FutureResult")
[16:20:43.432]     }, finally = {
[16:20:43.432]         if (!identical(...future.workdir, getwd())) 
[16:20:43.432]             setwd(...future.workdir)
[16:20:43.432]         {
[16:20:43.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.432]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.432]             }
[16:20:43.432]             base::options(...future.oldOptions)
[16:20:43.432]             if (.Platform$OS.type == "windows") {
[16:20:43.432]                 old_names <- names(...future.oldEnvVars)
[16:20:43.432]                 envs <- base::Sys.getenv()
[16:20:43.432]                 names <- names(envs)
[16:20:43.432]                 common <- intersect(names, old_names)
[16:20:43.432]                 added <- setdiff(names, old_names)
[16:20:43.432]                 removed <- setdiff(old_names, names)
[16:20:43.432]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.432]                   envs[common]]
[16:20:43.432]                 NAMES <- toupper(changed)
[16:20:43.432]                 args <- list()
[16:20:43.432]                 for (kk in seq_along(NAMES)) {
[16:20:43.432]                   name <- changed[[kk]]
[16:20:43.432]                   NAME <- NAMES[[kk]]
[16:20:43.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.432]                     next
[16:20:43.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.432]                 }
[16:20:43.432]                 NAMES <- toupper(added)
[16:20:43.432]                 for (kk in seq_along(NAMES)) {
[16:20:43.432]                   name <- added[[kk]]
[16:20:43.432]                   NAME <- NAMES[[kk]]
[16:20:43.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.432]                     next
[16:20:43.432]                   args[[name]] <- ""
[16:20:43.432]                 }
[16:20:43.432]                 NAMES <- toupper(removed)
[16:20:43.432]                 for (kk in seq_along(NAMES)) {
[16:20:43.432]                   name <- removed[[kk]]
[16:20:43.432]                   NAME <- NAMES[[kk]]
[16:20:43.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.432]                     next
[16:20:43.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.432]                 }
[16:20:43.432]                 if (length(args) > 0) 
[16:20:43.432]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.432]             }
[16:20:43.432]             else {
[16:20:43.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.432]             }
[16:20:43.432]             {
[16:20:43.432]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.432]                   0L) {
[16:20:43.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.432]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.432]                   base::options(opts)
[16:20:43.432]                 }
[16:20:43.432]                 {
[16:20:43.432]                   {
[16:20:43.432]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.432]                     NULL
[16:20:43.432]                   }
[16:20:43.432]                   options(future.plan = NULL)
[16:20:43.432]                   if (is.na(NA_character_)) 
[16:20:43.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.432]                     .init = FALSE)
[16:20:43.432]                 }
[16:20:43.432]             }
[16:20:43.432]         }
[16:20:43.432]     })
[16:20:43.432]     if (TRUE) {
[16:20:43.432]         base::sink(type = "output", split = FALSE)
[16:20:43.432]         if (TRUE) {
[16:20:43.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.432]         }
[16:20:43.432]         else {
[16:20:43.432]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.432]         }
[16:20:43.432]         base::close(...future.stdout)
[16:20:43.432]         ...future.stdout <- NULL
[16:20:43.432]     }
[16:20:43.432]     ...future.result$conditions <- ...future.conditions
[16:20:43.432]     ...future.result$finished <- base::Sys.time()
[16:20:43.432]     ...future.result
[16:20:43.432] }
[16:20:43.434] requestCore(): workers = 2
[16:20:43.436] MulticoreFuture started
[16:20:43.437] - Launch lazy future ... done
[16:20:43.437] run() for ‘MulticoreFuture’ ... done
[16:20:43.437] getGlobalsAndPackages() ...
[16:20:43.437] Searching for globals...
[16:20:43.438] plan(): Setting new future strategy stack:
[16:20:43.438] 
[16:20:43.438] Searching for globals ... DONE
[16:20:43.438] - globals: [0] <none>
[16:20:43.438] List of future strategies:
[16:20:43.438] 1. sequential:
[16:20:43.438]    - args: function (..., envir = parent.frame())
[16:20:43.438]    - tweaked: FALSE
[16:20:43.438]    - call: NULL
[16:20:43.438] getGlobalsAndPackages() ... DONE
[16:20:43.439] plan(): nbrOfWorkers() = 1
[16:20:43.439] run() for ‘Future’ ...
[16:20:43.439] - state: ‘created’
[16:20:43.439] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.440] plan(): Setting new future strategy stack:
[16:20:43.441] List of future strategies:
[16:20:43.441] 1. multicore:
[16:20:43.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.441]    - tweaked: FALSE
[16:20:43.441]    - call: plan(strategy)
[16:20:43.445] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.445] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.445]   - Field: ‘label’
[16:20:43.446] plan(): nbrOfWorkers() = 2
[16:20:43.446]   - Field: ‘local’
[16:20:43.446]   - Field: ‘owner’
[16:20:43.446]   - Field: ‘envir’
[16:20:43.446]   - Field: ‘workers’
[16:20:43.446]   - Field: ‘packages’
[16:20:43.447]   - Field: ‘gc’
[16:20:43.447]   - Field: ‘job’
[16:20:43.447]   - Field: ‘conditions’
[16:20:43.447]   - Field: ‘expr’
[16:20:43.447]   - Field: ‘uuid’
[16:20:43.447]   - Field: ‘seed’
[16:20:43.447]   - Field: ‘version’
[16:20:43.448]   - Field: ‘result’
[16:20:43.448]   - Field: ‘asynchronous’
[16:20:43.448]   - Field: ‘calls’
[16:20:43.448]   - Field: ‘globals’
[16:20:43.448]   - Field: ‘stdout’
[16:20:43.448]   - Field: ‘earlySignal’
[16:20:43.448]   - Field: ‘lazy’
[16:20:43.449]   - Field: ‘state’
[16:20:43.449] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.449] - Launch lazy future ...
[16:20:43.449] Packages needed by the future expression (n = 0): <none>
[16:20:43.450] Packages needed by future strategies (n = 0): <none>
[16:20:43.450] {
[16:20:43.450]     {
[16:20:43.450]         {
[16:20:43.450]             ...future.startTime <- base::Sys.time()
[16:20:43.450]             {
[16:20:43.450]                 {
[16:20:43.450]                   {
[16:20:43.450]                     {
[16:20:43.450]                       base::local({
[16:20:43.450]                         has_future <- base::requireNamespace("future", 
[16:20:43.450]                           quietly = TRUE)
[16:20:43.450]                         if (has_future) {
[16:20:43.450]                           ns <- base::getNamespace("future")
[16:20:43.450]                           version <- ns[[".package"]][["version"]]
[16:20:43.450]                           if (is.null(version)) 
[16:20:43.450]                             version <- utils::packageVersion("future")
[16:20:43.450]                         }
[16:20:43.450]                         else {
[16:20:43.450]                           version <- NULL
[16:20:43.450]                         }
[16:20:43.450]                         if (!has_future || version < "1.8.0") {
[16:20:43.450]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.450]                             "", base::R.version$version.string), 
[16:20:43.450]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.450]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.450]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.450]                               "release", "version")], collapse = " "), 
[16:20:43.450]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.450]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.450]                             info)
[16:20:43.450]                           info <- base::paste(info, collapse = "; ")
[16:20:43.450]                           if (!has_future) {
[16:20:43.450]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.450]                               info)
[16:20:43.450]                           }
[16:20:43.450]                           else {
[16:20:43.450]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.450]                               info, version)
[16:20:43.450]                           }
[16:20:43.450]                           base::stop(msg)
[16:20:43.450]                         }
[16:20:43.450]                       })
[16:20:43.450]                     }
[16:20:43.450]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.450]                     base::options(mc.cores = 1L)
[16:20:43.450]                   }
[16:20:43.450]                   ...future.strategy.old <- future::plan("list")
[16:20:43.450]                   options(future.plan = NULL)
[16:20:43.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.450]                 }
[16:20:43.450]                 ...future.workdir <- getwd()
[16:20:43.450]             }
[16:20:43.450]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.450]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.450]         }
[16:20:43.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.450]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.450]             base::names(...future.oldOptions))
[16:20:43.450]     }
[16:20:43.450]     if (FALSE) {
[16:20:43.450]     }
[16:20:43.450]     else {
[16:20:43.450]         if (TRUE) {
[16:20:43.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.450]                 open = "w")
[16:20:43.450]         }
[16:20:43.450]         else {
[16:20:43.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.450]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.450]         }
[16:20:43.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.450]             base::sink(type = "output", split = FALSE)
[16:20:43.450]             base::close(...future.stdout)
[16:20:43.450]         }, add = TRUE)
[16:20:43.450]     }
[16:20:43.450]     ...future.frame <- base::sys.nframe()
[16:20:43.450]     ...future.conditions <- base::list()
[16:20:43.450]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.450]     if (FALSE) {
[16:20:43.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.450]     }
[16:20:43.450]     ...future.result <- base::tryCatch({
[16:20:43.450]         base::withCallingHandlers({
[16:20:43.450]             ...future.value <- base::withVisible(base::local({
[16:20:43.450]                 withCallingHandlers({
[16:20:43.450]                   NULL
[16:20:43.450]                 }, immediateCondition = function(cond) {
[16:20:43.450]                   save_rds <- function (object, pathname, ...) 
[16:20:43.450]                   {
[16:20:43.450]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.450]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.450]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.450]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.450]                         fi_tmp[["mtime"]])
[16:20:43.450]                     }
[16:20:43.450]                     tryCatch({
[16:20:43.450]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.450]                     }, error = function(ex) {
[16:20:43.450]                       msg <- conditionMessage(ex)
[16:20:43.450]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.450]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.450]                         fi_tmp[["mtime"]], msg)
[16:20:43.450]                       ex$message <- msg
[16:20:43.450]                       stop(ex)
[16:20:43.450]                     })
[16:20:43.450]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.450]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.450]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.450]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.450]                       fi <- file.info(pathname)
[16:20:43.450]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.450]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.450]                         fi[["size"]], fi[["mtime"]])
[16:20:43.450]                       stop(msg)
[16:20:43.450]                     }
[16:20:43.450]                     invisible(pathname)
[16:20:43.450]                   }
[16:20:43.450]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.450]                     rootPath = tempdir()) 
[16:20:43.450]                   {
[16:20:43.450]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.450]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.450]                       tmpdir = path, fileext = ".rds")
[16:20:43.450]                     save_rds(obj, file)
[16:20:43.450]                   }
[16:20:43.450]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.450]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.450]                   {
[16:20:43.450]                     inherits <- base::inherits
[16:20:43.450]                     invokeRestart <- base::invokeRestart
[16:20:43.450]                     is.null <- base::is.null
[16:20:43.450]                     muffled <- FALSE
[16:20:43.450]                     if (inherits(cond, "message")) {
[16:20:43.450]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.450]                       if (muffled) 
[16:20:43.450]                         invokeRestart("muffleMessage")
[16:20:43.450]                     }
[16:20:43.450]                     else if (inherits(cond, "warning")) {
[16:20:43.450]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.450]                       if (muffled) 
[16:20:43.450]                         invokeRestart("muffleWarning")
[16:20:43.450]                     }
[16:20:43.450]                     else if (inherits(cond, "condition")) {
[16:20:43.450]                       if (!is.null(pattern)) {
[16:20:43.450]                         computeRestarts <- base::computeRestarts
[16:20:43.450]                         grepl <- base::grepl
[16:20:43.450]                         restarts <- computeRestarts(cond)
[16:20:43.450]                         for (restart in restarts) {
[16:20:43.450]                           name <- restart$name
[16:20:43.450]                           if (is.null(name)) 
[16:20:43.450]                             next
[16:20:43.450]                           if (!grepl(pattern, name)) 
[16:20:43.450]                             next
[16:20:43.450]                           invokeRestart(restart)
[16:20:43.450]                           muffled <- TRUE
[16:20:43.450]                           break
[16:20:43.450]                         }
[16:20:43.450]                       }
[16:20:43.450]                     }
[16:20:43.450]                     invisible(muffled)
[16:20:43.450]                   }
[16:20:43.450]                   muffleCondition(cond)
[16:20:43.450]                 })
[16:20:43.450]             }))
[16:20:43.450]             future::FutureResult(value = ...future.value$value, 
[16:20:43.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.450]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.450]                     ...future.globalenv.names))
[16:20:43.450]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.450]         }, condition = base::local({
[16:20:43.450]             c <- base::c
[16:20:43.450]             inherits <- base::inherits
[16:20:43.450]             invokeRestart <- base::invokeRestart
[16:20:43.450]             length <- base::length
[16:20:43.450]             list <- base::list
[16:20:43.450]             seq.int <- base::seq.int
[16:20:43.450]             signalCondition <- base::signalCondition
[16:20:43.450]             sys.calls <- base::sys.calls
[16:20:43.450]             `[[` <- base::`[[`
[16:20:43.450]             `+` <- base::`+`
[16:20:43.450]             `<<-` <- base::`<<-`
[16:20:43.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.450]                   3L)]
[16:20:43.450]             }
[16:20:43.450]             function(cond) {
[16:20:43.450]                 is_error <- inherits(cond, "error")
[16:20:43.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.450]                   NULL)
[16:20:43.450]                 if (is_error) {
[16:20:43.450]                   sessionInformation <- function() {
[16:20:43.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.450]                       search = base::search(), system = base::Sys.info())
[16:20:43.450]                   }
[16:20:43.450]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.450]                     cond$call), session = sessionInformation(), 
[16:20:43.450]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.450]                   signalCondition(cond)
[16:20:43.450]                 }
[16:20:43.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.450]                 "immediateCondition"))) {
[16:20:43.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.450]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.450]                   if (TRUE && !signal) {
[16:20:43.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.450]                     {
[16:20:43.450]                       inherits <- base::inherits
[16:20:43.450]                       invokeRestart <- base::invokeRestart
[16:20:43.450]                       is.null <- base::is.null
[16:20:43.450]                       muffled <- FALSE
[16:20:43.450]                       if (inherits(cond, "message")) {
[16:20:43.450]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.450]                         if (muffled) 
[16:20:43.450]                           invokeRestart("muffleMessage")
[16:20:43.450]                       }
[16:20:43.450]                       else if (inherits(cond, "warning")) {
[16:20:43.450]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.450]                         if (muffled) 
[16:20:43.450]                           invokeRestart("muffleWarning")
[16:20:43.450]                       }
[16:20:43.450]                       else if (inherits(cond, "condition")) {
[16:20:43.450]                         if (!is.null(pattern)) {
[16:20:43.450]                           computeRestarts <- base::computeRestarts
[16:20:43.450]                           grepl <- base::grepl
[16:20:43.450]                           restarts <- computeRestarts(cond)
[16:20:43.450]                           for (restart in restarts) {
[16:20:43.450]                             name <- restart$name
[16:20:43.450]                             if (is.null(name)) 
[16:20:43.450]                               next
[16:20:43.450]                             if (!grepl(pattern, name)) 
[16:20:43.450]                               next
[16:20:43.450]                             invokeRestart(restart)
[16:20:43.450]                             muffled <- TRUE
[16:20:43.450]                             break
[16:20:43.450]                           }
[16:20:43.450]                         }
[16:20:43.450]                       }
[16:20:43.450]                       invisible(muffled)
[16:20:43.450]                     }
[16:20:43.450]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.450]                   }
[16:20:43.450]                 }
[16:20:43.450]                 else {
[16:20:43.450]                   if (TRUE) {
[16:20:43.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.450]                     {
[16:20:43.450]                       inherits <- base::inherits
[16:20:43.450]                       invokeRestart <- base::invokeRestart
[16:20:43.450]                       is.null <- base::is.null
[16:20:43.450]                       muffled <- FALSE
[16:20:43.450]                       if (inherits(cond, "message")) {
[16:20:43.450]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.450]                         if (muffled) 
[16:20:43.450]                           invokeRestart("muffleMessage")
[16:20:43.450]                       }
[16:20:43.450]                       else if (inherits(cond, "warning")) {
[16:20:43.450]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.450]                         if (muffled) 
[16:20:43.450]                           invokeRestart("muffleWarning")
[16:20:43.450]                       }
[16:20:43.450]                       else if (inherits(cond, "condition")) {
[16:20:43.450]                         if (!is.null(pattern)) {
[16:20:43.450]                           computeRestarts <- base::computeRestarts
[16:20:43.450]                           grepl <- base::grepl
[16:20:43.450]                           restarts <- computeRestarts(cond)
[16:20:43.450]                           for (restart in restarts) {
[16:20:43.450]                             name <- restart$name
[16:20:43.450]                             if (is.null(name)) 
[16:20:43.450]                               next
[16:20:43.450]                             if (!grepl(pattern, name)) 
[16:20:43.450]                               next
[16:20:43.450]                             invokeRestart(restart)
[16:20:43.450]                             muffled <- TRUE
[16:20:43.450]                             break
[16:20:43.450]                           }
[16:20:43.450]                         }
[16:20:43.450]                       }
[16:20:43.450]                       invisible(muffled)
[16:20:43.450]                     }
[16:20:43.450]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.450]                   }
[16:20:43.450]                 }
[16:20:43.450]             }
[16:20:43.450]         }))
[16:20:43.450]     }, error = function(ex) {
[16:20:43.450]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.450]                 ...future.rng), started = ...future.startTime, 
[16:20:43.450]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.450]             version = "1.8"), class = "FutureResult")
[16:20:43.450]     }, finally = {
[16:20:43.450]         if (!identical(...future.workdir, getwd())) 
[16:20:43.450]             setwd(...future.workdir)
[16:20:43.450]         {
[16:20:43.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.450]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.450]             }
[16:20:43.450]             base::options(...future.oldOptions)
[16:20:43.450]             if (.Platform$OS.type == "windows") {
[16:20:43.450]                 old_names <- names(...future.oldEnvVars)
[16:20:43.450]                 envs <- base::Sys.getenv()
[16:20:43.450]                 names <- names(envs)
[16:20:43.450]                 common <- intersect(names, old_names)
[16:20:43.450]                 added <- setdiff(names, old_names)
[16:20:43.450]                 removed <- setdiff(old_names, names)
[16:20:43.450]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.450]                   envs[common]]
[16:20:43.450]                 NAMES <- toupper(changed)
[16:20:43.450]                 args <- list()
[16:20:43.450]                 for (kk in seq_along(NAMES)) {
[16:20:43.450]                   name <- changed[[kk]]
[16:20:43.450]                   NAME <- NAMES[[kk]]
[16:20:43.450]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.450]                     next
[16:20:43.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.450]                 }
[16:20:43.450]                 NAMES <- toupper(added)
[16:20:43.450]                 for (kk in seq_along(NAMES)) {
[16:20:43.450]                   name <- added[[kk]]
[16:20:43.450]                   NAME <- NAMES[[kk]]
[16:20:43.450]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.450]                     next
[16:20:43.450]                   args[[name]] <- ""
[16:20:43.450]                 }
[16:20:43.450]                 NAMES <- toupper(removed)
[16:20:43.450]                 for (kk in seq_along(NAMES)) {
[16:20:43.450]                   name <- removed[[kk]]
[16:20:43.450]                   NAME <- NAMES[[kk]]
[16:20:43.450]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.450]                     next
[16:20:43.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.450]                 }
[16:20:43.450]                 if (length(args) > 0) 
[16:20:43.450]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.450]             }
[16:20:43.450]             else {
[16:20:43.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.450]             }
[16:20:43.450]             {
[16:20:43.450]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.450]                   0L) {
[16:20:43.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.450]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.450]                   base::options(opts)
[16:20:43.450]                 }
[16:20:43.450]                 {
[16:20:43.450]                   {
[16:20:43.450]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.450]                     NULL
[16:20:43.450]                   }
[16:20:43.450]                   options(future.plan = NULL)
[16:20:43.450]                   if (is.na(NA_character_)) 
[16:20:43.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.450]                     .init = FALSE)
[16:20:43.450]                 }
[16:20:43.450]             }
[16:20:43.450]         }
[16:20:43.450]     })
[16:20:43.450]     if (TRUE) {
[16:20:43.450]         base::sink(type = "output", split = FALSE)
[16:20:43.450]         if (TRUE) {
[16:20:43.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.450]         }
[16:20:43.450]         else {
[16:20:43.450]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.450]         }
[16:20:43.450]         base::close(...future.stdout)
[16:20:43.450]         ...future.stdout <- NULL
[16:20:43.450]     }
[16:20:43.450]     ...future.result$conditions <- ...future.conditions
[16:20:43.450]     ...future.result$finished <- base::Sys.time()
[16:20:43.450]     ...future.result
[16:20:43.450] }
[16:20:43.454] requestCore(): workers = 2
[16:20:43.456] MulticoreFuture started
[16:20:43.457] - Launch lazy future ... done
[16:20:43.457] run() for ‘MulticoreFuture’ ... done
[16:20:43.458] getGlobalsAndPackages() ...
[16:20:43.458] plan(): Setting new future strategy stack:
[16:20:43.458] Searching for globals...
[16:20:43.458] List of future strategies:
[16:20:43.458] 1. sequential:
[16:20:43.458]    - args: function (..., envir = parent.frame())
[16:20:43.458]    - tweaked: FALSE
[16:20:43.458]    - call: NULL
[16:20:43.459] plan(): nbrOfWorkers() = 1
[16:20:43.459] - globals found: [1] ‘{’
[16:20:43.459] Searching for globals ... DONE
[16:20:43.459] Resolving globals: FALSE
[16:20:43.460] 
[16:20:43.460] 
[16:20:43.460] getGlobalsAndPackages() ... DONE
[16:20:43.461] plan(): Setting new future strategy stack:
[16:20:43.461] run() for ‘Future’ ...
[16:20:43.461] - state: ‘created’
[16:20:43.461] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.461] List of future strategies:
[16:20:43.461] 1. multicore:
[16:20:43.461]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.461]    - tweaked: FALSE
[16:20:43.461]    - call: plan(strategy)
[16:20:43.466] plan(): nbrOfWorkers() = 2
[16:20:43.466] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.466]   - Field: ‘label’
[16:20:43.467]   - Field: ‘local’
[16:20:43.467]   - Field: ‘owner’
[16:20:43.467]   - Field: ‘envir’
[16:20:43.467]   - Field: ‘workers’
[16:20:43.467]   - Field: ‘packages’
[16:20:43.467]   - Field: ‘gc’
[16:20:43.467]   - Field: ‘job’
[16:20:43.468]   - Field: ‘conditions’
[16:20:43.468]   - Field: ‘expr’
[16:20:43.468]   - Field: ‘uuid’
[16:20:43.468]   - Field: ‘seed’
[16:20:43.468]   - Field: ‘version’
[16:20:43.468]   - Field: ‘result’
[16:20:43.468]   - Field: ‘asynchronous’
[16:20:43.469]   - Field: ‘calls’
[16:20:43.469]   - Field: ‘globals’
[16:20:43.469]   - Field: ‘stdout’
[16:20:43.469]   - Field: ‘earlySignal’
[16:20:43.469]   - Field: ‘lazy’
[16:20:43.469]   - Field: ‘state’
[16:20:43.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.470] - Launch lazy future ...
[16:20:43.470] Packages needed by the future expression (n = 0): <none>
[16:20:43.470] Packages needed by future strategies (n = 0): <none>
[16:20:43.471] {
[16:20:43.471]     {
[16:20:43.471]         {
[16:20:43.471]             ...future.startTime <- base::Sys.time()
[16:20:43.471]             {
[16:20:43.471]                 {
[16:20:43.471]                   {
[16:20:43.471]                     {
[16:20:43.471]                       base::local({
[16:20:43.471]                         has_future <- base::requireNamespace("future", 
[16:20:43.471]                           quietly = TRUE)
[16:20:43.471]                         if (has_future) {
[16:20:43.471]                           ns <- base::getNamespace("future")
[16:20:43.471]                           version <- ns[[".package"]][["version"]]
[16:20:43.471]                           if (is.null(version)) 
[16:20:43.471]                             version <- utils::packageVersion("future")
[16:20:43.471]                         }
[16:20:43.471]                         else {
[16:20:43.471]                           version <- NULL
[16:20:43.471]                         }
[16:20:43.471]                         if (!has_future || version < "1.8.0") {
[16:20:43.471]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.471]                             "", base::R.version$version.string), 
[16:20:43.471]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.471]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.471]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.471]                               "release", "version")], collapse = " "), 
[16:20:43.471]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.471]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.471]                             info)
[16:20:43.471]                           info <- base::paste(info, collapse = "; ")
[16:20:43.471]                           if (!has_future) {
[16:20:43.471]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.471]                               info)
[16:20:43.471]                           }
[16:20:43.471]                           else {
[16:20:43.471]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.471]                               info, version)
[16:20:43.471]                           }
[16:20:43.471]                           base::stop(msg)
[16:20:43.471]                         }
[16:20:43.471]                       })
[16:20:43.471]                     }
[16:20:43.471]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.471]                     base::options(mc.cores = 1L)
[16:20:43.471]                   }
[16:20:43.471]                   ...future.strategy.old <- future::plan("list")
[16:20:43.471]                   options(future.plan = NULL)
[16:20:43.471]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.471]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.471]                 }
[16:20:43.471]                 ...future.workdir <- getwd()
[16:20:43.471]             }
[16:20:43.471]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.471]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.471]         }
[16:20:43.471]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.471]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.471]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.471]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.471]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.471]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.471]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.471]             base::names(...future.oldOptions))
[16:20:43.471]     }
[16:20:43.471]     if (FALSE) {
[16:20:43.471]     }
[16:20:43.471]     else {
[16:20:43.471]         if (TRUE) {
[16:20:43.471]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.471]                 open = "w")
[16:20:43.471]         }
[16:20:43.471]         else {
[16:20:43.471]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.471]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.471]         }
[16:20:43.471]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.471]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.471]             base::sink(type = "output", split = FALSE)
[16:20:43.471]             base::close(...future.stdout)
[16:20:43.471]         }, add = TRUE)
[16:20:43.471]     }
[16:20:43.471]     ...future.frame <- base::sys.nframe()
[16:20:43.471]     ...future.conditions <- base::list()
[16:20:43.471]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.471]     if (FALSE) {
[16:20:43.471]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.471]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.471]     }
[16:20:43.471]     ...future.result <- base::tryCatch({
[16:20:43.471]         base::withCallingHandlers({
[16:20:43.471]             ...future.value <- base::withVisible(base::local({
[16:20:43.471]                 withCallingHandlers({
[16:20:43.471]                   {
[16:20:43.471]                     4
[16:20:43.471]                   }
[16:20:43.471]                 }, immediateCondition = function(cond) {
[16:20:43.471]                   save_rds <- function (object, pathname, ...) 
[16:20:43.471]                   {
[16:20:43.471]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.471]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.471]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.471]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.471]                         fi_tmp[["mtime"]])
[16:20:43.471]                     }
[16:20:43.471]                     tryCatch({
[16:20:43.471]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.471]                     }, error = function(ex) {
[16:20:43.471]                       msg <- conditionMessage(ex)
[16:20:43.471]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.471]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.471]                         fi_tmp[["mtime"]], msg)
[16:20:43.471]                       ex$message <- msg
[16:20:43.471]                       stop(ex)
[16:20:43.471]                     })
[16:20:43.471]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.471]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.471]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.471]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.471]                       fi <- file.info(pathname)
[16:20:43.471]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.471]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.471]                         fi[["size"]], fi[["mtime"]])
[16:20:43.471]                       stop(msg)
[16:20:43.471]                     }
[16:20:43.471]                     invisible(pathname)
[16:20:43.471]                   }
[16:20:43.471]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.471]                     rootPath = tempdir()) 
[16:20:43.471]                   {
[16:20:43.471]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.471]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.471]                       tmpdir = path, fileext = ".rds")
[16:20:43.471]                     save_rds(obj, file)
[16:20:43.471]                   }
[16:20:43.471]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.471]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.471]                   {
[16:20:43.471]                     inherits <- base::inherits
[16:20:43.471]                     invokeRestart <- base::invokeRestart
[16:20:43.471]                     is.null <- base::is.null
[16:20:43.471]                     muffled <- FALSE
[16:20:43.471]                     if (inherits(cond, "message")) {
[16:20:43.471]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.471]                       if (muffled) 
[16:20:43.471]                         invokeRestart("muffleMessage")
[16:20:43.471]                     }
[16:20:43.471]                     else if (inherits(cond, "warning")) {
[16:20:43.471]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.471]                       if (muffled) 
[16:20:43.471]                         invokeRestart("muffleWarning")
[16:20:43.471]                     }
[16:20:43.471]                     else if (inherits(cond, "condition")) {
[16:20:43.471]                       if (!is.null(pattern)) {
[16:20:43.471]                         computeRestarts <- base::computeRestarts
[16:20:43.471]                         grepl <- base::grepl
[16:20:43.471]                         restarts <- computeRestarts(cond)
[16:20:43.471]                         for (restart in restarts) {
[16:20:43.471]                           name <- restart$name
[16:20:43.471]                           if (is.null(name)) 
[16:20:43.471]                             next
[16:20:43.471]                           if (!grepl(pattern, name)) 
[16:20:43.471]                             next
[16:20:43.471]                           invokeRestart(restart)
[16:20:43.471]                           muffled <- TRUE
[16:20:43.471]                           break
[16:20:43.471]                         }
[16:20:43.471]                       }
[16:20:43.471]                     }
[16:20:43.471]                     invisible(muffled)
[16:20:43.471]                   }
[16:20:43.471]                   muffleCondition(cond)
[16:20:43.471]                 })
[16:20:43.471]             }))
[16:20:43.471]             future::FutureResult(value = ...future.value$value, 
[16:20:43.471]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.471]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.471]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.471]                     ...future.globalenv.names))
[16:20:43.471]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.471]         }, condition = base::local({
[16:20:43.471]             c <- base::c
[16:20:43.471]             inherits <- base::inherits
[16:20:43.471]             invokeRestart <- base::invokeRestart
[16:20:43.471]             length <- base::length
[16:20:43.471]             list <- base::list
[16:20:43.471]             seq.int <- base::seq.int
[16:20:43.471]             signalCondition <- base::signalCondition
[16:20:43.471]             sys.calls <- base::sys.calls
[16:20:43.471]             `[[` <- base::`[[`
[16:20:43.471]             `+` <- base::`+`
[16:20:43.471]             `<<-` <- base::`<<-`
[16:20:43.471]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.471]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.471]                   3L)]
[16:20:43.471]             }
[16:20:43.471]             function(cond) {
[16:20:43.471]                 is_error <- inherits(cond, "error")
[16:20:43.471]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.471]                   NULL)
[16:20:43.471]                 if (is_error) {
[16:20:43.471]                   sessionInformation <- function() {
[16:20:43.471]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.471]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.471]                       search = base::search(), system = base::Sys.info())
[16:20:43.471]                   }
[16:20:43.471]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.471]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.471]                     cond$call), session = sessionInformation(), 
[16:20:43.471]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.471]                   signalCondition(cond)
[16:20:43.471]                 }
[16:20:43.471]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.471]                 "immediateCondition"))) {
[16:20:43.471]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.471]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.471]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.471]                   if (TRUE && !signal) {
[16:20:43.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.471]                     {
[16:20:43.471]                       inherits <- base::inherits
[16:20:43.471]                       invokeRestart <- base::invokeRestart
[16:20:43.471]                       is.null <- base::is.null
[16:20:43.471]                       muffled <- FALSE
[16:20:43.471]                       if (inherits(cond, "message")) {
[16:20:43.471]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.471]                         if (muffled) 
[16:20:43.471]                           invokeRestart("muffleMessage")
[16:20:43.471]                       }
[16:20:43.471]                       else if (inherits(cond, "warning")) {
[16:20:43.471]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.471]                         if (muffled) 
[16:20:43.471]                           invokeRestart("muffleWarning")
[16:20:43.471]                       }
[16:20:43.471]                       else if (inherits(cond, "condition")) {
[16:20:43.471]                         if (!is.null(pattern)) {
[16:20:43.471]                           computeRestarts <- base::computeRestarts
[16:20:43.471]                           grepl <- base::grepl
[16:20:43.471]                           restarts <- computeRestarts(cond)
[16:20:43.471]                           for (restart in restarts) {
[16:20:43.471]                             name <- restart$name
[16:20:43.471]                             if (is.null(name)) 
[16:20:43.471]                               next
[16:20:43.471]                             if (!grepl(pattern, name)) 
[16:20:43.471]                               next
[16:20:43.471]                             invokeRestart(restart)
[16:20:43.471]                             muffled <- TRUE
[16:20:43.471]                             break
[16:20:43.471]                           }
[16:20:43.471]                         }
[16:20:43.471]                       }
[16:20:43.471]                       invisible(muffled)
[16:20:43.471]                     }
[16:20:43.471]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.471]                   }
[16:20:43.471]                 }
[16:20:43.471]                 else {
[16:20:43.471]                   if (TRUE) {
[16:20:43.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.471]                     {
[16:20:43.471]                       inherits <- base::inherits
[16:20:43.471]                       invokeRestart <- base::invokeRestart
[16:20:43.471]                       is.null <- base::is.null
[16:20:43.471]                       muffled <- FALSE
[16:20:43.471]                       if (inherits(cond, "message")) {
[16:20:43.471]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.471]                         if (muffled) 
[16:20:43.471]                           invokeRestart("muffleMessage")
[16:20:43.471]                       }
[16:20:43.471]                       else if (inherits(cond, "warning")) {
[16:20:43.471]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.471]                         if (muffled) 
[16:20:43.471]                           invokeRestart("muffleWarning")
[16:20:43.471]                       }
[16:20:43.471]                       else if (inherits(cond, "condition")) {
[16:20:43.471]                         if (!is.null(pattern)) {
[16:20:43.471]                           computeRestarts <- base::computeRestarts
[16:20:43.471]                           grepl <- base::grepl
[16:20:43.471]                           restarts <- computeRestarts(cond)
[16:20:43.471]                           for (restart in restarts) {
[16:20:43.471]                             name <- restart$name
[16:20:43.471]                             if (is.null(name)) 
[16:20:43.471]                               next
[16:20:43.471]                             if (!grepl(pattern, name)) 
[16:20:43.471]                               next
[16:20:43.471]                             invokeRestart(restart)
[16:20:43.471]                             muffled <- TRUE
[16:20:43.471]                             break
[16:20:43.471]                           }
[16:20:43.471]                         }
[16:20:43.471]                       }
[16:20:43.471]                       invisible(muffled)
[16:20:43.471]                     }
[16:20:43.471]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.471]                   }
[16:20:43.471]                 }
[16:20:43.471]             }
[16:20:43.471]         }))
[16:20:43.471]     }, error = function(ex) {
[16:20:43.471]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.471]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.471]                 ...future.rng), started = ...future.startTime, 
[16:20:43.471]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.471]             version = "1.8"), class = "FutureResult")
[16:20:43.471]     }, finally = {
[16:20:43.471]         if (!identical(...future.workdir, getwd())) 
[16:20:43.471]             setwd(...future.workdir)
[16:20:43.471]         {
[16:20:43.471]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.471]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.471]             }
[16:20:43.471]             base::options(...future.oldOptions)
[16:20:43.471]             if (.Platform$OS.type == "windows") {
[16:20:43.471]                 old_names <- names(...future.oldEnvVars)
[16:20:43.471]                 envs <- base::Sys.getenv()
[16:20:43.471]                 names <- names(envs)
[16:20:43.471]                 common <- intersect(names, old_names)
[16:20:43.471]                 added <- setdiff(names, old_names)
[16:20:43.471]                 removed <- setdiff(old_names, names)
[16:20:43.471]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.471]                   envs[common]]
[16:20:43.471]                 NAMES <- toupper(changed)
[16:20:43.471]                 args <- list()
[16:20:43.471]                 for (kk in seq_along(NAMES)) {
[16:20:43.471]                   name <- changed[[kk]]
[16:20:43.471]                   NAME <- NAMES[[kk]]
[16:20:43.471]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.471]                     next
[16:20:43.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.471]                 }
[16:20:43.471]                 NAMES <- toupper(added)
[16:20:43.471]                 for (kk in seq_along(NAMES)) {
[16:20:43.471]                   name <- added[[kk]]
[16:20:43.471]                   NAME <- NAMES[[kk]]
[16:20:43.471]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.471]                     next
[16:20:43.471]                   args[[name]] <- ""
[16:20:43.471]                 }
[16:20:43.471]                 NAMES <- toupper(removed)
[16:20:43.471]                 for (kk in seq_along(NAMES)) {
[16:20:43.471]                   name <- removed[[kk]]
[16:20:43.471]                   NAME <- NAMES[[kk]]
[16:20:43.471]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.471]                     next
[16:20:43.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.471]                 }
[16:20:43.471]                 if (length(args) > 0) 
[16:20:43.471]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.471]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.471]             }
[16:20:43.471]             else {
[16:20:43.471]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.471]             }
[16:20:43.471]             {
[16:20:43.471]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.471]                   0L) {
[16:20:43.471]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.471]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.471]                   base::options(opts)
[16:20:43.471]                 }
[16:20:43.471]                 {
[16:20:43.471]                   {
[16:20:43.471]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.471]                     NULL
[16:20:43.471]                   }
[16:20:43.471]                   options(future.plan = NULL)
[16:20:43.471]                   if (is.na(NA_character_)) 
[16:20:43.471]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.471]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.471]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.471]                     .init = FALSE)
[16:20:43.471]                 }
[16:20:43.471]             }
[16:20:43.471]         }
[16:20:43.471]     })
[16:20:43.471]     if (TRUE) {
[16:20:43.471]         base::sink(type = "output", split = FALSE)
[16:20:43.471]         if (TRUE) {
[16:20:43.471]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.471]         }
[16:20:43.471]         else {
[16:20:43.471]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.471]         }
[16:20:43.471]         base::close(...future.stdout)
[16:20:43.471]         ...future.stdout <- NULL
[16:20:43.471]     }
[16:20:43.471]     ...future.result$conditions <- ...future.conditions
[16:20:43.471]     ...future.result$finished <- base::Sys.time()
[16:20:43.471]     ...future.result
[16:20:43.471] }
[16:20:43.474] requestCore(): workers = 2
[16:20:43.475] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:43.485] result() for MulticoreFuture ...
[16:20:43.486] result() for MulticoreFuture ...
[16:20:43.487] result() for MulticoreFuture ... done
[16:20:43.487] result() for MulticoreFuture ... done
[16:20:43.487] result() for MulticoreFuture ...
[16:20:43.487] result() for MulticoreFuture ... done
[16:20:43.490] MulticoreFuture started
[16:20:43.491] - Launch lazy future ... done
[16:20:43.491] run() for ‘MulticoreFuture’ ... done
[16:20:43.491] plan(): Setting new future strategy stack:
<environment: 0x55ed0e06b7a0> 
[16:20:43.492] List of future strategies:
[16:20:43.492] 1. sequential:
[16:20:43.492]    - args: function (..., envir = parent.frame())
[16:20:43.492]    - tweaked: FALSE
[16:20:43.492]    - call: NULL
[16:20:43.493] plan(): nbrOfWorkers() = 1
<environment: 0x55ed0bc10a38> 
[16:20:43.495] plan(): Setting new future strategy stack:
[16:20:43.495] List of future strategies:
[16:20:43.495] 1. multicore:
[16:20:43.495]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.495]    - tweaked: FALSE
[16:20:43.495]    - call: plan(strategy)
[16:20:43.500] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:43.503] resolve() on environment ...
[16:20:43.503]  recursive: 0
[16:20:43.504]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:43.504] signalConditionsASAP(numeric, pos=1) ...
[16:20:43.504] - nx: 4
[16:20:43.504] - relay: TRUE
[16:20:43.504] - stdout: TRUE
[16:20:43.505] - signal: TRUE
[16:20:43.505] - resignal: FALSE
[16:20:43.505] - force: TRUE
[16:20:43.505] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.505] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.506]  - until=2
[16:20:43.506]  - relaying element #2
[16:20:43.506] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.506] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.506] signalConditionsASAP(NULL, pos=1) ... done
[16:20:43.506]  length: 3 (resolved future 1)
[16:20:43.507] Future #2
[16:20:43.507] result() for MulticoreFuture ...
[16:20:43.507] result() for MulticoreFuture ... done
[16:20:43.507] result() for MulticoreFuture ...
[16:20:43.507] result() for MulticoreFuture ... done
[16:20:43.507] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:43.507] - nx: 4
[16:20:43.508] - relay: TRUE
[16:20:43.508] - stdout: TRUE
[16:20:43.508] - signal: TRUE
[16:20:43.508] - resignal: FALSE
[16:20:43.508] - force: TRUE
[16:20:43.508] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.509] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.509]  - until=2
[16:20:43.509]  - relaying element #2
[16:20:43.509] result() for MulticoreFuture ...
[16:20:43.509] result() for MulticoreFuture ... done
[16:20:43.509] result() for MulticoreFuture ...
[16:20:43.510] result() for MulticoreFuture ... done
[16:20:43.510] result() for MulticoreFuture ...
[16:20:43.510] result() for MulticoreFuture ... done
[16:20:43.510] result() for MulticoreFuture ...
[16:20:43.510] result() for MulticoreFuture ... done
[16:20:43.510] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.511] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.511] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:43.511]  length: 2 (resolved future 2)
[16:20:43.511] Future #3
[16:20:43.511] result() for MulticoreFuture ...
[16:20:43.513] result() for MulticoreFuture ...
[16:20:43.513] result() for MulticoreFuture ... done
[16:20:43.513] result() for MulticoreFuture ... done
[16:20:43.513] result() for MulticoreFuture ...
[16:20:43.513] result() for MulticoreFuture ... done
[16:20:43.513] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:43.513] - nx: 4
[16:20:43.514] - relay: TRUE
[16:20:43.514] - stdout: TRUE
[16:20:43.514] - signal: TRUE
[16:20:43.514] - resignal: FALSE
[16:20:43.514] - force: TRUE
[16:20:43.514] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.514] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.515]  - until=3
[16:20:43.515]  - relaying element #3
[16:20:43.515] result() for MulticoreFuture ...
[16:20:43.515] result() for MulticoreFuture ... done
[16:20:43.515] result() for MulticoreFuture ...
[16:20:43.515] result() for MulticoreFuture ... done
[16:20:43.515] result() for MulticoreFuture ...
[16:20:43.515] result() for MulticoreFuture ... done
[16:20:43.516] result() for MulticoreFuture ...
[16:20:43.516] result() for MulticoreFuture ... done
[16:20:43.516] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.516] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.516] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:43.516]  length: 1 (resolved future 3)
[16:20:43.517] Future #4
[16:20:43.517] result() for MulticoreFuture ...
[16:20:43.518] result() for MulticoreFuture ...
[16:20:43.518] result() for MulticoreFuture ... done
[16:20:43.518] result() for MulticoreFuture ... done
[16:20:43.518] result() for MulticoreFuture ...
[16:20:43.518] result() for MulticoreFuture ... done
[16:20:43.518] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:43.518] - nx: 4
[16:20:43.519] - relay: TRUE
[16:20:43.519] - stdout: TRUE
[16:20:43.519] - signal: TRUE
[16:20:43.519] - resignal: FALSE
[16:20:43.519] - force: TRUE
[16:20:43.519] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.519] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.519]  - until=4
[16:20:43.520]  - relaying element #4
[16:20:43.520] result() for MulticoreFuture ...
[16:20:43.520] result() for MulticoreFuture ... done
[16:20:43.520] result() for MulticoreFuture ...
[16:20:43.520] result() for MulticoreFuture ... done
[16:20:43.520] result() for MulticoreFuture ...
[16:20:43.520] result() for MulticoreFuture ... done
[16:20:43.520] result() for MulticoreFuture ...
[16:20:43.521] result() for MulticoreFuture ... done
[16:20:43.521] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.521] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.521] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:43.521]  length: 0 (resolved future 4)
[16:20:43.521] Relaying remaining futures
[16:20:43.521] signalConditionsASAP(NULL, pos=0) ...
[16:20:43.521] - nx: 4
[16:20:43.521] - relay: TRUE
[16:20:43.522] - stdout: TRUE
[16:20:43.522] - signal: TRUE
[16:20:43.522] - resignal: FALSE
[16:20:43.522] - force: TRUE
[16:20:43.522] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.522] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:43.522] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.522] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.522] signalConditionsASAP(NULL, pos=0) ... done
[16:20:43.522] resolve() on environment ... DONE
[16:20:43.523] result() for MulticoreFuture ...
[16:20:43.523] result() for MulticoreFuture ... done
[16:20:43.523] result() for MulticoreFuture ...
[16:20:43.523] result() for MulticoreFuture ... done
[16:20:43.523] result() for MulticoreFuture ...
[16:20:43.523] result() for MulticoreFuture ... done
[16:20:43.523] result() for MulticoreFuture ...
[16:20:43.523] result() for MulticoreFuture ... done
[16:20:43.524] result() for MulticoreFuture ...
[16:20:43.524] result() for MulticoreFuture ... done
[16:20:43.524] result() for MulticoreFuture ...
[16:20:43.524] result() for MulticoreFuture ... done
<environment: 0x55ed0a312c58> 
Dimensions: c(2, 3, 1)
[16:20:43.524] getGlobalsAndPackages() ...
[16:20:43.525] Searching for globals...
[16:20:43.525] 
[16:20:43.525] Searching for globals ... DONE
[16:20:43.525] - globals: [0] <none>
[16:20:43.525] getGlobalsAndPackages() ... DONE
[16:20:43.526] run() for ‘Future’ ...
[16:20:43.526] - state: ‘created’
[16:20:43.526] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.530] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.530]   - Field: ‘label’
[16:20:43.530]   - Field: ‘local’
[16:20:43.531]   - Field: ‘owner’
[16:20:43.531]   - Field: ‘envir’
[16:20:43.531]   - Field: ‘workers’
[16:20:43.531]   - Field: ‘packages’
[16:20:43.531]   - Field: ‘gc’
[16:20:43.531]   - Field: ‘job’
[16:20:43.531]   - Field: ‘conditions’
[16:20:43.531]   - Field: ‘expr’
[16:20:43.531]   - Field: ‘uuid’
[16:20:43.532]   - Field: ‘seed’
[16:20:43.532]   - Field: ‘version’
[16:20:43.532]   - Field: ‘result’
[16:20:43.532]   - Field: ‘asynchronous’
[16:20:43.532]   - Field: ‘calls’
[16:20:43.532]   - Field: ‘globals’
[16:20:43.532]   - Field: ‘stdout’
[16:20:43.532]   - Field: ‘earlySignal’
[16:20:43.532]   - Field: ‘lazy’
[16:20:43.533]   - Field: ‘state’
[16:20:43.533] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.533] - Launch lazy future ...
[16:20:43.533] Packages needed by the future expression (n = 0): <none>
[16:20:43.533] Packages needed by future strategies (n = 0): <none>
[16:20:43.534] {
[16:20:43.534]     {
[16:20:43.534]         {
[16:20:43.534]             ...future.startTime <- base::Sys.time()
[16:20:43.534]             {
[16:20:43.534]                 {
[16:20:43.534]                   {
[16:20:43.534]                     {
[16:20:43.534]                       base::local({
[16:20:43.534]                         has_future <- base::requireNamespace("future", 
[16:20:43.534]                           quietly = TRUE)
[16:20:43.534]                         if (has_future) {
[16:20:43.534]                           ns <- base::getNamespace("future")
[16:20:43.534]                           version <- ns[[".package"]][["version"]]
[16:20:43.534]                           if (is.null(version)) 
[16:20:43.534]                             version <- utils::packageVersion("future")
[16:20:43.534]                         }
[16:20:43.534]                         else {
[16:20:43.534]                           version <- NULL
[16:20:43.534]                         }
[16:20:43.534]                         if (!has_future || version < "1.8.0") {
[16:20:43.534]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.534]                             "", base::R.version$version.string), 
[16:20:43.534]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.534]                               "release", "version")], collapse = " "), 
[16:20:43.534]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.534]                             info)
[16:20:43.534]                           info <- base::paste(info, collapse = "; ")
[16:20:43.534]                           if (!has_future) {
[16:20:43.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.534]                               info)
[16:20:43.534]                           }
[16:20:43.534]                           else {
[16:20:43.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.534]                               info, version)
[16:20:43.534]                           }
[16:20:43.534]                           base::stop(msg)
[16:20:43.534]                         }
[16:20:43.534]                       })
[16:20:43.534]                     }
[16:20:43.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.534]                     base::options(mc.cores = 1L)
[16:20:43.534]                   }
[16:20:43.534]                   ...future.strategy.old <- future::plan("list")
[16:20:43.534]                   options(future.plan = NULL)
[16:20:43.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.534]                 }
[16:20:43.534]                 ...future.workdir <- getwd()
[16:20:43.534]             }
[16:20:43.534]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.534]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.534]         }
[16:20:43.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.534]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.534]             base::names(...future.oldOptions))
[16:20:43.534]     }
[16:20:43.534]     if (FALSE) {
[16:20:43.534]     }
[16:20:43.534]     else {
[16:20:43.534]         if (TRUE) {
[16:20:43.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.534]                 open = "w")
[16:20:43.534]         }
[16:20:43.534]         else {
[16:20:43.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.534]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.534]         }
[16:20:43.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.534]             base::sink(type = "output", split = FALSE)
[16:20:43.534]             base::close(...future.stdout)
[16:20:43.534]         }, add = TRUE)
[16:20:43.534]     }
[16:20:43.534]     ...future.frame <- base::sys.nframe()
[16:20:43.534]     ...future.conditions <- base::list()
[16:20:43.534]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.534]     if (FALSE) {
[16:20:43.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.534]     }
[16:20:43.534]     ...future.result <- base::tryCatch({
[16:20:43.534]         base::withCallingHandlers({
[16:20:43.534]             ...future.value <- base::withVisible(base::local({
[16:20:43.534]                 withCallingHandlers({
[16:20:43.534]                   2
[16:20:43.534]                 }, immediateCondition = function(cond) {
[16:20:43.534]                   save_rds <- function (object, pathname, ...) 
[16:20:43.534]                   {
[16:20:43.534]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.534]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.534]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.534]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.534]                         fi_tmp[["mtime"]])
[16:20:43.534]                     }
[16:20:43.534]                     tryCatch({
[16:20:43.534]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.534]                     }, error = function(ex) {
[16:20:43.534]                       msg <- conditionMessage(ex)
[16:20:43.534]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.534]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.534]                         fi_tmp[["mtime"]], msg)
[16:20:43.534]                       ex$message <- msg
[16:20:43.534]                       stop(ex)
[16:20:43.534]                     })
[16:20:43.534]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.534]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.534]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.534]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.534]                       fi <- file.info(pathname)
[16:20:43.534]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.534]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.534]                         fi[["size"]], fi[["mtime"]])
[16:20:43.534]                       stop(msg)
[16:20:43.534]                     }
[16:20:43.534]                     invisible(pathname)
[16:20:43.534]                   }
[16:20:43.534]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.534]                     rootPath = tempdir()) 
[16:20:43.534]                   {
[16:20:43.534]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.534]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.534]                       tmpdir = path, fileext = ".rds")
[16:20:43.534]                     save_rds(obj, file)
[16:20:43.534]                   }
[16:20:43.534]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.534]                   {
[16:20:43.534]                     inherits <- base::inherits
[16:20:43.534]                     invokeRestart <- base::invokeRestart
[16:20:43.534]                     is.null <- base::is.null
[16:20:43.534]                     muffled <- FALSE
[16:20:43.534]                     if (inherits(cond, "message")) {
[16:20:43.534]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.534]                       if (muffled) 
[16:20:43.534]                         invokeRestart("muffleMessage")
[16:20:43.534]                     }
[16:20:43.534]                     else if (inherits(cond, "warning")) {
[16:20:43.534]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.534]                       if (muffled) 
[16:20:43.534]                         invokeRestart("muffleWarning")
[16:20:43.534]                     }
[16:20:43.534]                     else if (inherits(cond, "condition")) {
[16:20:43.534]                       if (!is.null(pattern)) {
[16:20:43.534]                         computeRestarts <- base::computeRestarts
[16:20:43.534]                         grepl <- base::grepl
[16:20:43.534]                         restarts <- computeRestarts(cond)
[16:20:43.534]                         for (restart in restarts) {
[16:20:43.534]                           name <- restart$name
[16:20:43.534]                           if (is.null(name)) 
[16:20:43.534]                             next
[16:20:43.534]                           if (!grepl(pattern, name)) 
[16:20:43.534]                             next
[16:20:43.534]                           invokeRestart(restart)
[16:20:43.534]                           muffled <- TRUE
[16:20:43.534]                           break
[16:20:43.534]                         }
[16:20:43.534]                       }
[16:20:43.534]                     }
[16:20:43.534]                     invisible(muffled)
[16:20:43.534]                   }
[16:20:43.534]                   muffleCondition(cond)
[16:20:43.534]                 })
[16:20:43.534]             }))
[16:20:43.534]             future::FutureResult(value = ...future.value$value, 
[16:20:43.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.534]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.534]                     ...future.globalenv.names))
[16:20:43.534]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.534]         }, condition = base::local({
[16:20:43.534]             c <- base::c
[16:20:43.534]             inherits <- base::inherits
[16:20:43.534]             invokeRestart <- base::invokeRestart
[16:20:43.534]             length <- base::length
[16:20:43.534]             list <- base::list
[16:20:43.534]             seq.int <- base::seq.int
[16:20:43.534]             signalCondition <- base::signalCondition
[16:20:43.534]             sys.calls <- base::sys.calls
[16:20:43.534]             `[[` <- base::`[[`
[16:20:43.534]             `+` <- base::`+`
[16:20:43.534]             `<<-` <- base::`<<-`
[16:20:43.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.534]                   3L)]
[16:20:43.534]             }
[16:20:43.534]             function(cond) {
[16:20:43.534]                 is_error <- inherits(cond, "error")
[16:20:43.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.534]                   NULL)
[16:20:43.534]                 if (is_error) {
[16:20:43.534]                   sessionInformation <- function() {
[16:20:43.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.534]                       search = base::search(), system = base::Sys.info())
[16:20:43.534]                   }
[16:20:43.534]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.534]                     cond$call), session = sessionInformation(), 
[16:20:43.534]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.534]                   signalCondition(cond)
[16:20:43.534]                 }
[16:20:43.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.534]                 "immediateCondition"))) {
[16:20:43.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.534]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.534]                   if (TRUE && !signal) {
[16:20:43.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.534]                     {
[16:20:43.534]                       inherits <- base::inherits
[16:20:43.534]                       invokeRestart <- base::invokeRestart
[16:20:43.534]                       is.null <- base::is.null
[16:20:43.534]                       muffled <- FALSE
[16:20:43.534]                       if (inherits(cond, "message")) {
[16:20:43.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.534]                         if (muffled) 
[16:20:43.534]                           invokeRestart("muffleMessage")
[16:20:43.534]                       }
[16:20:43.534]                       else if (inherits(cond, "warning")) {
[16:20:43.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.534]                         if (muffled) 
[16:20:43.534]                           invokeRestart("muffleWarning")
[16:20:43.534]                       }
[16:20:43.534]                       else if (inherits(cond, "condition")) {
[16:20:43.534]                         if (!is.null(pattern)) {
[16:20:43.534]                           computeRestarts <- base::computeRestarts
[16:20:43.534]                           grepl <- base::grepl
[16:20:43.534]                           restarts <- computeRestarts(cond)
[16:20:43.534]                           for (restart in restarts) {
[16:20:43.534]                             name <- restart$name
[16:20:43.534]                             if (is.null(name)) 
[16:20:43.534]                               next
[16:20:43.534]                             if (!grepl(pattern, name)) 
[16:20:43.534]                               next
[16:20:43.534]                             invokeRestart(restart)
[16:20:43.534]                             muffled <- TRUE
[16:20:43.534]                             break
[16:20:43.534]                           }
[16:20:43.534]                         }
[16:20:43.534]                       }
[16:20:43.534]                       invisible(muffled)
[16:20:43.534]                     }
[16:20:43.534]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.534]                   }
[16:20:43.534]                 }
[16:20:43.534]                 else {
[16:20:43.534]                   if (TRUE) {
[16:20:43.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.534]                     {
[16:20:43.534]                       inherits <- base::inherits
[16:20:43.534]                       invokeRestart <- base::invokeRestart
[16:20:43.534]                       is.null <- base::is.null
[16:20:43.534]                       muffled <- FALSE
[16:20:43.534]                       if (inherits(cond, "message")) {
[16:20:43.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.534]                         if (muffled) 
[16:20:43.534]                           invokeRestart("muffleMessage")
[16:20:43.534]                       }
[16:20:43.534]                       else if (inherits(cond, "warning")) {
[16:20:43.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.534]                         if (muffled) 
[16:20:43.534]                           invokeRestart("muffleWarning")
[16:20:43.534]                       }
[16:20:43.534]                       else if (inherits(cond, "condition")) {
[16:20:43.534]                         if (!is.null(pattern)) {
[16:20:43.534]                           computeRestarts <- base::computeRestarts
[16:20:43.534]                           grepl <- base::grepl
[16:20:43.534]                           restarts <- computeRestarts(cond)
[16:20:43.534]                           for (restart in restarts) {
[16:20:43.534]                             name <- restart$name
[16:20:43.534]                             if (is.null(name)) 
[16:20:43.534]                               next
[16:20:43.534]                             if (!grepl(pattern, name)) 
[16:20:43.534]                               next
[16:20:43.534]                             invokeRestart(restart)
[16:20:43.534]                             muffled <- TRUE
[16:20:43.534]                             break
[16:20:43.534]                           }
[16:20:43.534]                         }
[16:20:43.534]                       }
[16:20:43.534]                       invisible(muffled)
[16:20:43.534]                     }
[16:20:43.534]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.534]                   }
[16:20:43.534]                 }
[16:20:43.534]             }
[16:20:43.534]         }))
[16:20:43.534]     }, error = function(ex) {
[16:20:43.534]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.534]                 ...future.rng), started = ...future.startTime, 
[16:20:43.534]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.534]             version = "1.8"), class = "FutureResult")
[16:20:43.534]     }, finally = {
[16:20:43.534]         if (!identical(...future.workdir, getwd())) 
[16:20:43.534]             setwd(...future.workdir)
[16:20:43.534]         {
[16:20:43.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.534]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.534]             }
[16:20:43.534]             base::options(...future.oldOptions)
[16:20:43.534]             if (.Platform$OS.type == "windows") {
[16:20:43.534]                 old_names <- names(...future.oldEnvVars)
[16:20:43.534]                 envs <- base::Sys.getenv()
[16:20:43.534]                 names <- names(envs)
[16:20:43.534]                 common <- intersect(names, old_names)
[16:20:43.534]                 added <- setdiff(names, old_names)
[16:20:43.534]                 removed <- setdiff(old_names, names)
[16:20:43.534]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.534]                   envs[common]]
[16:20:43.534]                 NAMES <- toupper(changed)
[16:20:43.534]                 args <- list()
[16:20:43.534]                 for (kk in seq_along(NAMES)) {
[16:20:43.534]                   name <- changed[[kk]]
[16:20:43.534]                   NAME <- NAMES[[kk]]
[16:20:43.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.534]                     next
[16:20:43.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.534]                 }
[16:20:43.534]                 NAMES <- toupper(added)
[16:20:43.534]                 for (kk in seq_along(NAMES)) {
[16:20:43.534]                   name <- added[[kk]]
[16:20:43.534]                   NAME <- NAMES[[kk]]
[16:20:43.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.534]                     next
[16:20:43.534]                   args[[name]] <- ""
[16:20:43.534]                 }
[16:20:43.534]                 NAMES <- toupper(removed)
[16:20:43.534]                 for (kk in seq_along(NAMES)) {
[16:20:43.534]                   name <- removed[[kk]]
[16:20:43.534]                   NAME <- NAMES[[kk]]
[16:20:43.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.534]                     next
[16:20:43.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.534]                 }
[16:20:43.534]                 if (length(args) > 0) 
[16:20:43.534]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.534]             }
[16:20:43.534]             else {
[16:20:43.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.534]             }
[16:20:43.534]             {
[16:20:43.534]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.534]                   0L) {
[16:20:43.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.534]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.534]                   base::options(opts)
[16:20:43.534]                 }
[16:20:43.534]                 {
[16:20:43.534]                   {
[16:20:43.534]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.534]                     NULL
[16:20:43.534]                   }
[16:20:43.534]                   options(future.plan = NULL)
[16:20:43.534]                   if (is.na(NA_character_)) 
[16:20:43.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.534]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.534]                     .init = FALSE)
[16:20:43.534]                 }
[16:20:43.534]             }
[16:20:43.534]         }
[16:20:43.534]     })
[16:20:43.534]     if (TRUE) {
[16:20:43.534]         base::sink(type = "output", split = FALSE)
[16:20:43.534]         if (TRUE) {
[16:20:43.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.534]         }
[16:20:43.534]         else {
[16:20:43.534]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.534]         }
[16:20:43.534]         base::close(...future.stdout)
[16:20:43.534]         ...future.stdout <- NULL
[16:20:43.534]     }
[16:20:43.534]     ...future.result$conditions <- ...future.conditions
[16:20:43.534]     ...future.result$finished <- base::Sys.time()
[16:20:43.534]     ...future.result
[16:20:43.534] }
[16:20:43.536] requestCore(): workers = 2
[16:20:43.539] MulticoreFuture started
[16:20:43.539] - Launch lazy future ... done
[16:20:43.539] run() for ‘MulticoreFuture’ ... done
[16:20:43.540] plan(): Setting new future strategy stack:
[16:20:43.540] getGlobalsAndPackages() ...
[16:20:43.540] Searching for globals...
[16:20:43.540] List of future strategies:
[16:20:43.540] 1. sequential:
[16:20:43.540]    - args: function (..., envir = parent.frame())
[16:20:43.540]    - tweaked: FALSE
[16:20:43.540]    - call: NULL
[16:20:43.541] plan(): nbrOfWorkers() = 1
[16:20:43.541] 
[16:20:43.541] Searching for globals ... DONE
[16:20:43.542] - globals: [0] <none>
[16:20:43.542] getGlobalsAndPackages() ... DONE
[16:20:43.542] run() for ‘Future’ ...
[16:20:43.542] - state: ‘created’
[16:20:43.543] plan(): Setting new future strategy stack:
[16:20:43.543] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.543] List of future strategies:
[16:20:43.543] 1. multicore:
[16:20:43.543]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.543]    - tweaked: FALSE
[16:20:43.543]    - call: plan(strategy)
[16:20:43.547] plan(): nbrOfWorkers() = 2
[16:20:43.548] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.548]   - Field: ‘label’
[16:20:43.548]   - Field: ‘local’
[16:20:43.548]   - Field: ‘owner’
[16:20:43.548]   - Field: ‘envir’
[16:20:43.549]   - Field: ‘workers’
[16:20:43.549]   - Field: ‘packages’
[16:20:43.549]   - Field: ‘gc’
[16:20:43.549]   - Field: ‘job’
[16:20:43.549]   - Field: ‘conditions’
[16:20:43.549]   - Field: ‘expr’
[16:20:43.549]   - Field: ‘uuid’
[16:20:43.549]   - Field: ‘seed’
[16:20:43.550]   - Field: ‘version’
[16:20:43.550]   - Field: ‘result’
[16:20:43.550]   - Field: ‘asynchronous’
[16:20:43.550]   - Field: ‘calls’
[16:20:43.550]   - Field: ‘globals’
[16:20:43.550]   - Field: ‘stdout’
[16:20:43.550]   - Field: ‘earlySignal’
[16:20:43.551]   - Field: ‘lazy’
[16:20:43.551]   - Field: ‘state’
[16:20:43.551] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.551] - Launch lazy future ...
[16:20:43.552] Packages needed by the future expression (n = 0): <none>
[16:20:43.552] Packages needed by future strategies (n = 0): <none>
[16:20:43.552] {
[16:20:43.552]     {
[16:20:43.552]         {
[16:20:43.552]             ...future.startTime <- base::Sys.time()
[16:20:43.552]             {
[16:20:43.552]                 {
[16:20:43.552]                   {
[16:20:43.552]                     {
[16:20:43.552]                       base::local({
[16:20:43.552]                         has_future <- base::requireNamespace("future", 
[16:20:43.552]                           quietly = TRUE)
[16:20:43.552]                         if (has_future) {
[16:20:43.552]                           ns <- base::getNamespace("future")
[16:20:43.552]                           version <- ns[[".package"]][["version"]]
[16:20:43.552]                           if (is.null(version)) 
[16:20:43.552]                             version <- utils::packageVersion("future")
[16:20:43.552]                         }
[16:20:43.552]                         else {
[16:20:43.552]                           version <- NULL
[16:20:43.552]                         }
[16:20:43.552]                         if (!has_future || version < "1.8.0") {
[16:20:43.552]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.552]                             "", base::R.version$version.string), 
[16:20:43.552]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.552]                               "release", "version")], collapse = " "), 
[16:20:43.552]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.552]                             info)
[16:20:43.552]                           info <- base::paste(info, collapse = "; ")
[16:20:43.552]                           if (!has_future) {
[16:20:43.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.552]                               info)
[16:20:43.552]                           }
[16:20:43.552]                           else {
[16:20:43.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.552]                               info, version)
[16:20:43.552]                           }
[16:20:43.552]                           base::stop(msg)
[16:20:43.552]                         }
[16:20:43.552]                       })
[16:20:43.552]                     }
[16:20:43.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.552]                     base::options(mc.cores = 1L)
[16:20:43.552]                   }
[16:20:43.552]                   ...future.strategy.old <- future::plan("list")
[16:20:43.552]                   options(future.plan = NULL)
[16:20:43.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.552]                 }
[16:20:43.552]                 ...future.workdir <- getwd()
[16:20:43.552]             }
[16:20:43.552]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.552]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.552]         }
[16:20:43.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.552]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.552]             base::names(...future.oldOptions))
[16:20:43.552]     }
[16:20:43.552]     if (FALSE) {
[16:20:43.552]     }
[16:20:43.552]     else {
[16:20:43.552]         if (TRUE) {
[16:20:43.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.552]                 open = "w")
[16:20:43.552]         }
[16:20:43.552]         else {
[16:20:43.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.552]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.552]         }
[16:20:43.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.552]             base::sink(type = "output", split = FALSE)
[16:20:43.552]             base::close(...future.stdout)
[16:20:43.552]         }, add = TRUE)
[16:20:43.552]     }
[16:20:43.552]     ...future.frame <- base::sys.nframe()
[16:20:43.552]     ...future.conditions <- base::list()
[16:20:43.552]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.552]     if (FALSE) {
[16:20:43.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.552]     }
[16:20:43.552]     ...future.result <- base::tryCatch({
[16:20:43.552]         base::withCallingHandlers({
[16:20:43.552]             ...future.value <- base::withVisible(base::local({
[16:20:43.552]                 withCallingHandlers({
[16:20:43.552]                   NULL
[16:20:43.552]                 }, immediateCondition = function(cond) {
[16:20:43.552]                   save_rds <- function (object, pathname, ...) 
[16:20:43.552]                   {
[16:20:43.552]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.552]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.552]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.552]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.552]                         fi_tmp[["mtime"]])
[16:20:43.552]                     }
[16:20:43.552]                     tryCatch({
[16:20:43.552]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.552]                     }, error = function(ex) {
[16:20:43.552]                       msg <- conditionMessage(ex)
[16:20:43.552]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.552]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.552]                         fi_tmp[["mtime"]], msg)
[16:20:43.552]                       ex$message <- msg
[16:20:43.552]                       stop(ex)
[16:20:43.552]                     })
[16:20:43.552]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.552]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.552]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.552]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.552]                       fi <- file.info(pathname)
[16:20:43.552]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.552]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.552]                         fi[["size"]], fi[["mtime"]])
[16:20:43.552]                       stop(msg)
[16:20:43.552]                     }
[16:20:43.552]                     invisible(pathname)
[16:20:43.552]                   }
[16:20:43.552]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.552]                     rootPath = tempdir()) 
[16:20:43.552]                   {
[16:20:43.552]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.552]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.552]                       tmpdir = path, fileext = ".rds")
[16:20:43.552]                     save_rds(obj, file)
[16:20:43.552]                   }
[16:20:43.552]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.552]                   {
[16:20:43.552]                     inherits <- base::inherits
[16:20:43.552]                     invokeRestart <- base::invokeRestart
[16:20:43.552]                     is.null <- base::is.null
[16:20:43.552]                     muffled <- FALSE
[16:20:43.552]                     if (inherits(cond, "message")) {
[16:20:43.552]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.552]                       if (muffled) 
[16:20:43.552]                         invokeRestart("muffleMessage")
[16:20:43.552]                     }
[16:20:43.552]                     else if (inherits(cond, "warning")) {
[16:20:43.552]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.552]                       if (muffled) 
[16:20:43.552]                         invokeRestart("muffleWarning")
[16:20:43.552]                     }
[16:20:43.552]                     else if (inherits(cond, "condition")) {
[16:20:43.552]                       if (!is.null(pattern)) {
[16:20:43.552]                         computeRestarts <- base::computeRestarts
[16:20:43.552]                         grepl <- base::grepl
[16:20:43.552]                         restarts <- computeRestarts(cond)
[16:20:43.552]                         for (restart in restarts) {
[16:20:43.552]                           name <- restart$name
[16:20:43.552]                           if (is.null(name)) 
[16:20:43.552]                             next
[16:20:43.552]                           if (!grepl(pattern, name)) 
[16:20:43.552]                             next
[16:20:43.552]                           invokeRestart(restart)
[16:20:43.552]                           muffled <- TRUE
[16:20:43.552]                           break
[16:20:43.552]                         }
[16:20:43.552]                       }
[16:20:43.552]                     }
[16:20:43.552]                     invisible(muffled)
[16:20:43.552]                   }
[16:20:43.552]                   muffleCondition(cond)
[16:20:43.552]                 })
[16:20:43.552]             }))
[16:20:43.552]             future::FutureResult(value = ...future.value$value, 
[16:20:43.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.552]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.552]                     ...future.globalenv.names))
[16:20:43.552]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.552]         }, condition = base::local({
[16:20:43.552]             c <- base::c
[16:20:43.552]             inherits <- base::inherits
[16:20:43.552]             invokeRestart <- base::invokeRestart
[16:20:43.552]             length <- base::length
[16:20:43.552]             list <- base::list
[16:20:43.552]             seq.int <- base::seq.int
[16:20:43.552]             signalCondition <- base::signalCondition
[16:20:43.552]             sys.calls <- base::sys.calls
[16:20:43.552]             `[[` <- base::`[[`
[16:20:43.552]             `+` <- base::`+`
[16:20:43.552]             `<<-` <- base::`<<-`
[16:20:43.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.552]                   3L)]
[16:20:43.552]             }
[16:20:43.552]             function(cond) {
[16:20:43.552]                 is_error <- inherits(cond, "error")
[16:20:43.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.552]                   NULL)
[16:20:43.552]                 if (is_error) {
[16:20:43.552]                   sessionInformation <- function() {
[16:20:43.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.552]                       search = base::search(), system = base::Sys.info())
[16:20:43.552]                   }
[16:20:43.552]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.552]                     cond$call), session = sessionInformation(), 
[16:20:43.552]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.552]                   signalCondition(cond)
[16:20:43.552]                 }
[16:20:43.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.552]                 "immediateCondition"))) {
[16:20:43.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.552]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.552]                   if (TRUE && !signal) {
[16:20:43.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.552]                     {
[16:20:43.552]                       inherits <- base::inherits
[16:20:43.552]                       invokeRestart <- base::invokeRestart
[16:20:43.552]                       is.null <- base::is.null
[16:20:43.552]                       muffled <- FALSE
[16:20:43.552]                       if (inherits(cond, "message")) {
[16:20:43.552]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.552]                         if (muffled) 
[16:20:43.552]                           invokeRestart("muffleMessage")
[16:20:43.552]                       }
[16:20:43.552]                       else if (inherits(cond, "warning")) {
[16:20:43.552]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.552]                         if (muffled) 
[16:20:43.552]                           invokeRestart("muffleWarning")
[16:20:43.552]                       }
[16:20:43.552]                       else if (inherits(cond, "condition")) {
[16:20:43.552]                         if (!is.null(pattern)) {
[16:20:43.552]                           computeRestarts <- base::computeRestarts
[16:20:43.552]                           grepl <- base::grepl
[16:20:43.552]                           restarts <- computeRestarts(cond)
[16:20:43.552]                           for (restart in restarts) {
[16:20:43.552]                             name <- restart$name
[16:20:43.552]                             if (is.null(name)) 
[16:20:43.552]                               next
[16:20:43.552]                             if (!grepl(pattern, name)) 
[16:20:43.552]                               next
[16:20:43.552]                             invokeRestart(restart)
[16:20:43.552]                             muffled <- TRUE
[16:20:43.552]                             break
[16:20:43.552]                           }
[16:20:43.552]                         }
[16:20:43.552]                       }
[16:20:43.552]                       invisible(muffled)
[16:20:43.552]                     }
[16:20:43.552]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.552]                   }
[16:20:43.552]                 }
[16:20:43.552]                 else {
[16:20:43.552]                   if (TRUE) {
[16:20:43.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.552]                     {
[16:20:43.552]                       inherits <- base::inherits
[16:20:43.552]                       invokeRestart <- base::invokeRestart
[16:20:43.552]                       is.null <- base::is.null
[16:20:43.552]                       muffled <- FALSE
[16:20:43.552]                       if (inherits(cond, "message")) {
[16:20:43.552]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.552]                         if (muffled) 
[16:20:43.552]                           invokeRestart("muffleMessage")
[16:20:43.552]                       }
[16:20:43.552]                       else if (inherits(cond, "warning")) {
[16:20:43.552]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.552]                         if (muffled) 
[16:20:43.552]                           invokeRestart("muffleWarning")
[16:20:43.552]                       }
[16:20:43.552]                       else if (inherits(cond, "condition")) {
[16:20:43.552]                         if (!is.null(pattern)) {
[16:20:43.552]                           computeRestarts <- base::computeRestarts
[16:20:43.552]                           grepl <- base::grepl
[16:20:43.552]                           restarts <- computeRestarts(cond)
[16:20:43.552]                           for (restart in restarts) {
[16:20:43.552]                             name <- restart$name
[16:20:43.552]                             if (is.null(name)) 
[16:20:43.552]                               next
[16:20:43.552]                             if (!grepl(pattern, name)) 
[16:20:43.552]                               next
[16:20:43.552]                             invokeRestart(restart)
[16:20:43.552]                             muffled <- TRUE
[16:20:43.552]                             break
[16:20:43.552]                           }
[16:20:43.552]                         }
[16:20:43.552]                       }
[16:20:43.552]                       invisible(muffled)
[16:20:43.552]                     }
[16:20:43.552]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.552]                   }
[16:20:43.552]                 }
[16:20:43.552]             }
[16:20:43.552]         }))
[16:20:43.552]     }, error = function(ex) {
[16:20:43.552]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.552]                 ...future.rng), started = ...future.startTime, 
[16:20:43.552]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.552]             version = "1.8"), class = "FutureResult")
[16:20:43.552]     }, finally = {
[16:20:43.552]         if (!identical(...future.workdir, getwd())) 
[16:20:43.552]             setwd(...future.workdir)
[16:20:43.552]         {
[16:20:43.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.552]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.552]             }
[16:20:43.552]             base::options(...future.oldOptions)
[16:20:43.552]             if (.Platform$OS.type == "windows") {
[16:20:43.552]                 old_names <- names(...future.oldEnvVars)
[16:20:43.552]                 envs <- base::Sys.getenv()
[16:20:43.552]                 names <- names(envs)
[16:20:43.552]                 common <- intersect(names, old_names)
[16:20:43.552]                 added <- setdiff(names, old_names)
[16:20:43.552]                 removed <- setdiff(old_names, names)
[16:20:43.552]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.552]                   envs[common]]
[16:20:43.552]                 NAMES <- toupper(changed)
[16:20:43.552]                 args <- list()
[16:20:43.552]                 for (kk in seq_along(NAMES)) {
[16:20:43.552]                   name <- changed[[kk]]
[16:20:43.552]                   NAME <- NAMES[[kk]]
[16:20:43.552]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.552]                     next
[16:20:43.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.552]                 }
[16:20:43.552]                 NAMES <- toupper(added)
[16:20:43.552]                 for (kk in seq_along(NAMES)) {
[16:20:43.552]                   name <- added[[kk]]
[16:20:43.552]                   NAME <- NAMES[[kk]]
[16:20:43.552]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.552]                     next
[16:20:43.552]                   args[[name]] <- ""
[16:20:43.552]                 }
[16:20:43.552]                 NAMES <- toupper(removed)
[16:20:43.552]                 for (kk in seq_along(NAMES)) {
[16:20:43.552]                   name <- removed[[kk]]
[16:20:43.552]                   NAME <- NAMES[[kk]]
[16:20:43.552]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.552]                     next
[16:20:43.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.552]                 }
[16:20:43.552]                 if (length(args) > 0) 
[16:20:43.552]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.552]             }
[16:20:43.552]             else {
[16:20:43.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.552]             }
[16:20:43.552]             {
[16:20:43.552]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.552]                   0L) {
[16:20:43.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.552]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.552]                   base::options(opts)
[16:20:43.552]                 }
[16:20:43.552]                 {
[16:20:43.552]                   {
[16:20:43.552]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.552]                     NULL
[16:20:43.552]                   }
[16:20:43.552]                   options(future.plan = NULL)
[16:20:43.552]                   if (is.na(NA_character_)) 
[16:20:43.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.552]                     .init = FALSE)
[16:20:43.552]                 }
[16:20:43.552]             }
[16:20:43.552]         }
[16:20:43.552]     })
[16:20:43.552]     if (TRUE) {
[16:20:43.552]         base::sink(type = "output", split = FALSE)
[16:20:43.552]         if (TRUE) {
[16:20:43.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.552]         }
[16:20:43.552]         else {
[16:20:43.552]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.552]         }
[16:20:43.552]         base::close(...future.stdout)
[16:20:43.552]         ...future.stdout <- NULL
[16:20:43.552]     }
[16:20:43.552]     ...future.result$conditions <- ...future.conditions
[16:20:43.552]     ...future.result$finished <- base::Sys.time()
[16:20:43.552]     ...future.result
[16:20:43.552] }
[16:20:43.556] requestCore(): workers = 2
[16:20:43.558] MulticoreFuture started
[16:20:43.558] - Launch lazy future ... done
[16:20:43.558] run() for ‘MulticoreFuture’ ... done
[16:20:43.559] plan(): Setting new future strategy stack:
[16:20:43.559] getGlobalsAndPackages() ...
[16:20:43.559] Searching for globals...
[16:20:43.559] List of future strategies:
[16:20:43.559] 1. sequential:
[16:20:43.559]    - args: function (..., envir = parent.frame())
[16:20:43.559]    - tweaked: FALSE
[16:20:43.559]    - call: NULL
[16:20:43.560] plan(): nbrOfWorkers() = 1
[16:20:43.561] - globals found: [1] ‘{’
[16:20:43.561] Searching for globals ... DONE
[16:20:43.561] Resolving globals: FALSE
[16:20:43.562] 
[16:20:43.562] 
[16:20:43.562] getGlobalsAndPackages() ... DONE
[16:20:43.562] plan(): Setting new future strategy stack:
[16:20:43.562] run() for ‘Future’ ...
[16:20:43.562] - state: ‘created’
[16:20:43.562] List of future strategies:
[16:20:43.562] 1. multicore:
[16:20:43.562]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.562]    - tweaked: FALSE
[16:20:43.562]    - call: plan(strategy)
[16:20:43.563] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.567] plan(): nbrOfWorkers() = 2
[16:20:43.567] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.567] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.568]   - Field: ‘label’
[16:20:43.568]   - Field: ‘local’
[16:20:43.568]   - Field: ‘owner’
[16:20:43.568]   - Field: ‘envir’
[16:20:43.568]   - Field: ‘workers’
[16:20:43.568]   - Field: ‘packages’
[16:20:43.568]   - Field: ‘gc’
[16:20:43.569]   - Field: ‘job’
[16:20:43.569]   - Field: ‘conditions’
[16:20:43.569]   - Field: ‘expr’
[16:20:43.569]   - Field: ‘uuid’
[16:20:43.569]   - Field: ‘seed’
[16:20:43.569]   - Field: ‘version’
[16:20:43.569]   - Field: ‘result’
[16:20:43.570]   - Field: ‘asynchronous’
[16:20:43.570]   - Field: ‘calls’
[16:20:43.570]   - Field: ‘globals’
[16:20:43.570]   - Field: ‘stdout’
[16:20:43.570]   - Field: ‘earlySignal’
[16:20:43.570]   - Field: ‘lazy’
[16:20:43.570]   - Field: ‘state’
[16:20:43.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.571] - Launch lazy future ...
[16:20:43.571] Packages needed by the future expression (n = 0): <none>
[16:20:43.571] Packages needed by future strategies (n = 0): <none>
[16:20:43.572] {
[16:20:43.572]     {
[16:20:43.572]         {
[16:20:43.572]             ...future.startTime <- base::Sys.time()
[16:20:43.572]             {
[16:20:43.572]                 {
[16:20:43.572]                   {
[16:20:43.572]                     {
[16:20:43.572]                       base::local({
[16:20:43.572]                         has_future <- base::requireNamespace("future", 
[16:20:43.572]                           quietly = TRUE)
[16:20:43.572]                         if (has_future) {
[16:20:43.572]                           ns <- base::getNamespace("future")
[16:20:43.572]                           version <- ns[[".package"]][["version"]]
[16:20:43.572]                           if (is.null(version)) 
[16:20:43.572]                             version <- utils::packageVersion("future")
[16:20:43.572]                         }
[16:20:43.572]                         else {
[16:20:43.572]                           version <- NULL
[16:20:43.572]                         }
[16:20:43.572]                         if (!has_future || version < "1.8.0") {
[16:20:43.572]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.572]                             "", base::R.version$version.string), 
[16:20:43.572]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.572]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.572]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.572]                               "release", "version")], collapse = " "), 
[16:20:43.572]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.572]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.572]                             info)
[16:20:43.572]                           info <- base::paste(info, collapse = "; ")
[16:20:43.572]                           if (!has_future) {
[16:20:43.572]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.572]                               info)
[16:20:43.572]                           }
[16:20:43.572]                           else {
[16:20:43.572]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.572]                               info, version)
[16:20:43.572]                           }
[16:20:43.572]                           base::stop(msg)
[16:20:43.572]                         }
[16:20:43.572]                       })
[16:20:43.572]                     }
[16:20:43.572]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.572]                     base::options(mc.cores = 1L)
[16:20:43.572]                   }
[16:20:43.572]                   ...future.strategy.old <- future::plan("list")
[16:20:43.572]                   options(future.plan = NULL)
[16:20:43.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.572]                 }
[16:20:43.572]                 ...future.workdir <- getwd()
[16:20:43.572]             }
[16:20:43.572]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.572]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.572]         }
[16:20:43.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.572]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.572]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.572]             base::names(...future.oldOptions))
[16:20:43.572]     }
[16:20:43.572]     if (FALSE) {
[16:20:43.572]     }
[16:20:43.572]     else {
[16:20:43.572]         if (TRUE) {
[16:20:43.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.572]                 open = "w")
[16:20:43.572]         }
[16:20:43.572]         else {
[16:20:43.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.572]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.572]         }
[16:20:43.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.572]             base::sink(type = "output", split = FALSE)
[16:20:43.572]             base::close(...future.stdout)
[16:20:43.572]         }, add = TRUE)
[16:20:43.572]     }
[16:20:43.572]     ...future.frame <- base::sys.nframe()
[16:20:43.572]     ...future.conditions <- base::list()
[16:20:43.572]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.572]     if (FALSE) {
[16:20:43.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.572]     }
[16:20:43.572]     ...future.result <- base::tryCatch({
[16:20:43.572]         base::withCallingHandlers({
[16:20:43.572]             ...future.value <- base::withVisible(base::local({
[16:20:43.572]                 withCallingHandlers({
[16:20:43.572]                   {
[16:20:43.572]                     4
[16:20:43.572]                   }
[16:20:43.572]                 }, immediateCondition = function(cond) {
[16:20:43.572]                   save_rds <- function (object, pathname, ...) 
[16:20:43.572]                   {
[16:20:43.572]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.572]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.572]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.572]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.572]                         fi_tmp[["mtime"]])
[16:20:43.572]                     }
[16:20:43.572]                     tryCatch({
[16:20:43.572]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.572]                     }, error = function(ex) {
[16:20:43.572]                       msg <- conditionMessage(ex)
[16:20:43.572]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.572]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.572]                         fi_tmp[["mtime"]], msg)
[16:20:43.572]                       ex$message <- msg
[16:20:43.572]                       stop(ex)
[16:20:43.572]                     })
[16:20:43.572]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.572]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.572]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.572]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.572]                       fi <- file.info(pathname)
[16:20:43.572]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.572]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.572]                         fi[["size"]], fi[["mtime"]])
[16:20:43.572]                       stop(msg)
[16:20:43.572]                     }
[16:20:43.572]                     invisible(pathname)
[16:20:43.572]                   }
[16:20:43.572]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.572]                     rootPath = tempdir()) 
[16:20:43.572]                   {
[16:20:43.572]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.572]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.572]                       tmpdir = path, fileext = ".rds")
[16:20:43.572]                     save_rds(obj, file)
[16:20:43.572]                   }
[16:20:43.572]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.572]                   {
[16:20:43.572]                     inherits <- base::inherits
[16:20:43.572]                     invokeRestart <- base::invokeRestart
[16:20:43.572]                     is.null <- base::is.null
[16:20:43.572]                     muffled <- FALSE
[16:20:43.572]                     if (inherits(cond, "message")) {
[16:20:43.572]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.572]                       if (muffled) 
[16:20:43.572]                         invokeRestart("muffleMessage")
[16:20:43.572]                     }
[16:20:43.572]                     else if (inherits(cond, "warning")) {
[16:20:43.572]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.572]                       if (muffled) 
[16:20:43.572]                         invokeRestart("muffleWarning")
[16:20:43.572]                     }
[16:20:43.572]                     else if (inherits(cond, "condition")) {
[16:20:43.572]                       if (!is.null(pattern)) {
[16:20:43.572]                         computeRestarts <- base::computeRestarts
[16:20:43.572]                         grepl <- base::grepl
[16:20:43.572]                         restarts <- computeRestarts(cond)
[16:20:43.572]                         for (restart in restarts) {
[16:20:43.572]                           name <- restart$name
[16:20:43.572]                           if (is.null(name)) 
[16:20:43.572]                             next
[16:20:43.572]                           if (!grepl(pattern, name)) 
[16:20:43.572]                             next
[16:20:43.572]                           invokeRestart(restart)
[16:20:43.572]                           muffled <- TRUE
[16:20:43.572]                           break
[16:20:43.572]                         }
[16:20:43.572]                       }
[16:20:43.572]                     }
[16:20:43.572]                     invisible(muffled)
[16:20:43.572]                   }
[16:20:43.572]                   muffleCondition(cond)
[16:20:43.572]                 })
[16:20:43.572]             }))
[16:20:43.572]             future::FutureResult(value = ...future.value$value, 
[16:20:43.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.572]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.572]                     ...future.globalenv.names))
[16:20:43.572]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.572]         }, condition = base::local({
[16:20:43.572]             c <- base::c
[16:20:43.572]             inherits <- base::inherits
[16:20:43.572]             invokeRestart <- base::invokeRestart
[16:20:43.572]             length <- base::length
[16:20:43.572]             list <- base::list
[16:20:43.572]             seq.int <- base::seq.int
[16:20:43.572]             signalCondition <- base::signalCondition
[16:20:43.572]             sys.calls <- base::sys.calls
[16:20:43.572]             `[[` <- base::`[[`
[16:20:43.572]             `+` <- base::`+`
[16:20:43.572]             `<<-` <- base::`<<-`
[16:20:43.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.572]                   3L)]
[16:20:43.572]             }
[16:20:43.572]             function(cond) {
[16:20:43.572]                 is_error <- inherits(cond, "error")
[16:20:43.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.572]                   NULL)
[16:20:43.572]                 if (is_error) {
[16:20:43.572]                   sessionInformation <- function() {
[16:20:43.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.572]                       search = base::search(), system = base::Sys.info())
[16:20:43.572]                   }
[16:20:43.572]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.572]                     cond$call), session = sessionInformation(), 
[16:20:43.572]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.572]                   signalCondition(cond)
[16:20:43.572]                 }
[16:20:43.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.572]                 "immediateCondition"))) {
[16:20:43.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.572]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.572]                   if (TRUE && !signal) {
[16:20:43.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.572]                     {
[16:20:43.572]                       inherits <- base::inherits
[16:20:43.572]                       invokeRestart <- base::invokeRestart
[16:20:43.572]                       is.null <- base::is.null
[16:20:43.572]                       muffled <- FALSE
[16:20:43.572]                       if (inherits(cond, "message")) {
[16:20:43.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.572]                         if (muffled) 
[16:20:43.572]                           invokeRestart("muffleMessage")
[16:20:43.572]                       }
[16:20:43.572]                       else if (inherits(cond, "warning")) {
[16:20:43.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.572]                         if (muffled) 
[16:20:43.572]                           invokeRestart("muffleWarning")
[16:20:43.572]                       }
[16:20:43.572]                       else if (inherits(cond, "condition")) {
[16:20:43.572]                         if (!is.null(pattern)) {
[16:20:43.572]                           computeRestarts <- base::computeRestarts
[16:20:43.572]                           grepl <- base::grepl
[16:20:43.572]                           restarts <- computeRestarts(cond)
[16:20:43.572]                           for (restart in restarts) {
[16:20:43.572]                             name <- restart$name
[16:20:43.572]                             if (is.null(name)) 
[16:20:43.572]                               next
[16:20:43.572]                             if (!grepl(pattern, name)) 
[16:20:43.572]                               next
[16:20:43.572]                             invokeRestart(restart)
[16:20:43.572]                             muffled <- TRUE
[16:20:43.572]                             break
[16:20:43.572]                           }
[16:20:43.572]                         }
[16:20:43.572]                       }
[16:20:43.572]                       invisible(muffled)
[16:20:43.572]                     }
[16:20:43.572]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.572]                   }
[16:20:43.572]                 }
[16:20:43.572]                 else {
[16:20:43.572]                   if (TRUE) {
[16:20:43.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.572]                     {
[16:20:43.572]                       inherits <- base::inherits
[16:20:43.572]                       invokeRestart <- base::invokeRestart
[16:20:43.572]                       is.null <- base::is.null
[16:20:43.572]                       muffled <- FALSE
[16:20:43.572]                       if (inherits(cond, "message")) {
[16:20:43.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.572]                         if (muffled) 
[16:20:43.572]                           invokeRestart("muffleMessage")
[16:20:43.572]                       }
[16:20:43.572]                       else if (inherits(cond, "warning")) {
[16:20:43.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.572]                         if (muffled) 
[16:20:43.572]                           invokeRestart("muffleWarning")
[16:20:43.572]                       }
[16:20:43.572]                       else if (inherits(cond, "condition")) {
[16:20:43.572]                         if (!is.null(pattern)) {
[16:20:43.572]                           computeRestarts <- base::computeRestarts
[16:20:43.572]                           grepl <- base::grepl
[16:20:43.572]                           restarts <- computeRestarts(cond)
[16:20:43.572]                           for (restart in restarts) {
[16:20:43.572]                             name <- restart$name
[16:20:43.572]                             if (is.null(name)) 
[16:20:43.572]                               next
[16:20:43.572]                             if (!grepl(pattern, name)) 
[16:20:43.572]                               next
[16:20:43.572]                             invokeRestart(restart)
[16:20:43.572]                             muffled <- TRUE
[16:20:43.572]                             break
[16:20:43.572]                           }
[16:20:43.572]                         }
[16:20:43.572]                       }
[16:20:43.572]                       invisible(muffled)
[16:20:43.572]                     }
[16:20:43.572]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.572]                   }
[16:20:43.572]                 }
[16:20:43.572]             }
[16:20:43.572]         }))
[16:20:43.572]     }, error = function(ex) {
[16:20:43.572]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.572]                 ...future.rng), started = ...future.startTime, 
[16:20:43.572]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.572]             version = "1.8"), class = "FutureResult")
[16:20:43.572]     }, finally = {
[16:20:43.572]         if (!identical(...future.workdir, getwd())) 
[16:20:43.572]             setwd(...future.workdir)
[16:20:43.572]         {
[16:20:43.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.572]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.572]             }
[16:20:43.572]             base::options(...future.oldOptions)
[16:20:43.572]             if (.Platform$OS.type == "windows") {
[16:20:43.572]                 old_names <- names(...future.oldEnvVars)
[16:20:43.572]                 envs <- base::Sys.getenv()
[16:20:43.572]                 names <- names(envs)
[16:20:43.572]                 common <- intersect(names, old_names)
[16:20:43.572]                 added <- setdiff(names, old_names)
[16:20:43.572]                 removed <- setdiff(old_names, names)
[16:20:43.572]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.572]                   envs[common]]
[16:20:43.572]                 NAMES <- toupper(changed)
[16:20:43.572]                 args <- list()
[16:20:43.572]                 for (kk in seq_along(NAMES)) {
[16:20:43.572]                   name <- changed[[kk]]
[16:20:43.572]                   NAME <- NAMES[[kk]]
[16:20:43.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.572]                     next
[16:20:43.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.572]                 }
[16:20:43.572]                 NAMES <- toupper(added)
[16:20:43.572]                 for (kk in seq_along(NAMES)) {
[16:20:43.572]                   name <- added[[kk]]
[16:20:43.572]                   NAME <- NAMES[[kk]]
[16:20:43.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.572]                     next
[16:20:43.572]                   args[[name]] <- ""
[16:20:43.572]                 }
[16:20:43.572]                 NAMES <- toupper(removed)
[16:20:43.572]                 for (kk in seq_along(NAMES)) {
[16:20:43.572]                   name <- removed[[kk]]
[16:20:43.572]                   NAME <- NAMES[[kk]]
[16:20:43.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.572]                     next
[16:20:43.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.572]                 }
[16:20:43.572]                 if (length(args) > 0) 
[16:20:43.572]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.572]             }
[16:20:43.572]             else {
[16:20:43.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.572]             }
[16:20:43.572]             {
[16:20:43.572]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.572]                   0L) {
[16:20:43.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.572]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.572]                   base::options(opts)
[16:20:43.572]                 }
[16:20:43.572]                 {
[16:20:43.572]                   {
[16:20:43.572]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.572]                     NULL
[16:20:43.572]                   }
[16:20:43.572]                   options(future.plan = NULL)
[16:20:43.572]                   if (is.na(NA_character_)) 
[16:20:43.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.572]                     .init = FALSE)
[16:20:43.572]                 }
[16:20:43.572]             }
[16:20:43.572]         }
[16:20:43.572]     })
[16:20:43.572]     if (TRUE) {
[16:20:43.572]         base::sink(type = "output", split = FALSE)
[16:20:43.572]         if (TRUE) {
[16:20:43.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.572]         }
[16:20:43.572]         else {
[16:20:43.572]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.572]         }
[16:20:43.572]         base::close(...future.stdout)
[16:20:43.572]         ...future.stdout <- NULL
[16:20:43.572]     }
[16:20:43.572]     ...future.result$conditions <- ...future.conditions
[16:20:43.572]     ...future.result$finished <- base::Sys.time()
[16:20:43.572]     ...future.result
[16:20:43.572] }
[16:20:43.575] requestCore(): workers = 2
[16:20:43.575] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:43.586] result() for MulticoreFuture ...
[16:20:43.587] result() for MulticoreFuture ...
[16:20:43.587] result() for MulticoreFuture ... done
[16:20:43.587] result() for MulticoreFuture ... done
[16:20:43.587] result() for MulticoreFuture ...
[16:20:43.587] result() for MulticoreFuture ... done
[16:20:43.590] MulticoreFuture started
[16:20:43.590] - Launch lazy future ... done
[16:20:43.591] run() for ‘MulticoreFuture’ ... done
[16:20:43.591] plan(): Setting new future strategy stack:
<environment: 0x55ed0d1c1c30> 
[16:20:43.592] List of future strategies:
[16:20:43.592] 1. sequential:
[16:20:43.592]    - args: function (..., envir = parent.frame())
[16:20:43.592]    - tweaked: FALSE
[16:20:43.592]    - call: NULL
[16:20:43.593] plan(): nbrOfWorkers() = 1
<environment: 0x55ed0dd62be8> 
[16:20:43.595] plan(): Setting new future strategy stack:
[16:20:43.595] List of future strategies:
[16:20:43.595] 1. multicore:
[16:20:43.595]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.595]    - tweaked: FALSE
[16:20:43.595]    - call: plan(strategy)
[16:20:43.600] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:43.602] resolve() on environment ...
[16:20:43.603]  recursive: 0
[16:20:43.603]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:43.604] signalConditionsASAP(numeric, pos=1) ...
[16:20:43.604] - nx: 4
[16:20:43.604] - relay: TRUE
[16:20:43.604] - stdout: TRUE
[16:20:43.604] - signal: TRUE
[16:20:43.604] - resignal: FALSE
[16:20:43.604] - force: TRUE
[16:20:43.604] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.605] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.605]  - until=2
[16:20:43.605]  - relaying element #2
[16:20:43.605] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.605] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.605] signalConditionsASAP(NULL, pos=1) ... done
[16:20:43.605]  length: 3 (resolved future 1)
[16:20:43.606] Future #2
[16:20:43.606] result() for MulticoreFuture ...
[16:20:43.606] result() for MulticoreFuture ... done
[16:20:43.606] result() for MulticoreFuture ...
[16:20:43.606] result() for MulticoreFuture ... done
[16:20:43.606] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:43.606] - nx: 4
[16:20:43.607] - relay: TRUE
[16:20:43.607] - stdout: TRUE
[16:20:43.607] - signal: TRUE
[16:20:43.607] - resignal: FALSE
[16:20:43.607] - force: TRUE
[16:20:43.607] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.607] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.607]  - until=2
[16:20:43.608]  - relaying element #2
[16:20:43.608] result() for MulticoreFuture ...
[16:20:43.608] result() for MulticoreFuture ... done
[16:20:43.608] result() for MulticoreFuture ...
[16:20:43.608] result() for MulticoreFuture ... done
[16:20:43.608] result() for MulticoreFuture ...
[16:20:43.608] result() for MulticoreFuture ... done
[16:20:43.609] result() for MulticoreFuture ...
[16:20:43.609] result() for MulticoreFuture ... done
[16:20:43.609] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.609] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.609] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:43.609]  length: 2 (resolved future 2)
[16:20:43.609] Future #3
[16:20:43.610] result() for MulticoreFuture ...
[16:20:43.610] result() for MulticoreFuture ...
[16:20:43.611] result() for MulticoreFuture ... done
[16:20:43.611] result() for MulticoreFuture ... done
[16:20:43.611] result() for MulticoreFuture ...
[16:20:43.611] result() for MulticoreFuture ... done
[16:20:43.611] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:43.611] - nx: 4
[16:20:43.611] - relay: TRUE
[16:20:43.611] - stdout: TRUE
[16:20:43.612] - signal: TRUE
[16:20:43.612] - resignal: FALSE
[16:20:43.612] - force: TRUE
[16:20:43.612] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.612] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.612]  - until=3
[16:20:43.612]  - relaying element #3
[16:20:43.612] result() for MulticoreFuture ...
[16:20:43.613] result() for MulticoreFuture ... done
[16:20:43.613] result() for MulticoreFuture ...
[16:20:43.613] result() for MulticoreFuture ... done
[16:20:43.613] result() for MulticoreFuture ...
[16:20:43.613] result() for MulticoreFuture ... done
[16:20:43.613] result() for MulticoreFuture ...
[16:20:43.613] result() for MulticoreFuture ... done
[16:20:43.613] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.614] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.614] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:43.614]  length: 1 (resolved future 3)
[16:20:43.614] Future #4
[16:20:43.614] result() for MulticoreFuture ...
[16:20:43.615] result() for MulticoreFuture ...
[16:20:43.615] result() for MulticoreFuture ... done
[16:20:43.615] result() for MulticoreFuture ... done
[16:20:43.615] result() for MulticoreFuture ...
[16:20:43.616] result() for MulticoreFuture ... done
[16:20:43.616] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:43.616] - nx: 4
[16:20:43.624] - relay: TRUE
[16:20:43.624] - stdout: TRUE
[16:20:43.624] - signal: TRUE
[16:20:43.624] - resignal: FALSE
[16:20:43.624] - force: TRUE
[16:20:43.624] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.624] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.624]  - until=4
[16:20:43.624]  - relaying element #4
[16:20:43.625] result() for MulticoreFuture ...
[16:20:43.625] result() for MulticoreFuture ... done
[16:20:43.625] result() for MulticoreFuture ...
[16:20:43.625] result() for MulticoreFuture ... done
[16:20:43.625] result() for MulticoreFuture ...
[16:20:43.625] result() for MulticoreFuture ... done
[16:20:43.625] result() for MulticoreFuture ...
[16:20:43.625] result() for MulticoreFuture ... done
[16:20:43.625] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.625] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.626] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:43.626]  length: 0 (resolved future 4)
[16:20:43.626] Relaying remaining futures
[16:20:43.626] signalConditionsASAP(NULL, pos=0) ...
[16:20:43.626] - nx: 4
[16:20:43.626] - relay: TRUE
[16:20:43.626] - stdout: TRUE
[16:20:43.626] - signal: TRUE
[16:20:43.626] - resignal: FALSE
[16:20:43.626] - force: TRUE
[16:20:43.627] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.627] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:43.627] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.627] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.627] signalConditionsASAP(NULL, pos=0) ... done
[16:20:43.627] resolve() on environment ... DONE
[16:20:43.627] result() for MulticoreFuture ...
[16:20:43.627] result() for MulticoreFuture ... done
[16:20:43.627] result() for MulticoreFuture ...
[16:20:43.627] result() for MulticoreFuture ... done
[16:20:43.628] result() for MulticoreFuture ...
[16:20:43.628] result() for MulticoreFuture ... done
[16:20:43.628] result() for MulticoreFuture ...
[16:20:43.628] result() for MulticoreFuture ... done
[16:20:43.628] result() for MulticoreFuture ...
[16:20:43.628] result() for MulticoreFuture ... done
[16:20:43.628] result() for MulticoreFuture ...
[16:20:43.628] result() for MulticoreFuture ... done
<environment: 0x55ed0de19318> 
Dimensions: c(2, 1, 3, 1)
[16:20:43.629] getGlobalsAndPackages() ...
[16:20:43.629] Searching for globals...
[16:20:43.629] 
[16:20:43.630] Searching for globals ... DONE
[16:20:43.630] - globals: [0] <none>
[16:20:43.630] getGlobalsAndPackages() ... DONE
[16:20:43.630] run() for ‘Future’ ...
[16:20:43.630] - state: ‘created’
[16:20:43.630] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.635] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.635]   - Field: ‘label’
[16:20:43.635]   - Field: ‘local’
[16:20:43.635]   - Field: ‘owner’
[16:20:43.635]   - Field: ‘envir’
[16:20:43.635]   - Field: ‘workers’
[16:20:43.635]   - Field: ‘packages’
[16:20:43.635]   - Field: ‘gc’
[16:20:43.636]   - Field: ‘job’
[16:20:43.636]   - Field: ‘conditions’
[16:20:43.636]   - Field: ‘expr’
[16:20:43.636]   - Field: ‘uuid’
[16:20:43.636]   - Field: ‘seed’
[16:20:43.636]   - Field: ‘version’
[16:20:43.636]   - Field: ‘result’
[16:20:43.636]   - Field: ‘asynchronous’
[16:20:43.636]   - Field: ‘calls’
[16:20:43.637]   - Field: ‘globals’
[16:20:43.637]   - Field: ‘stdout’
[16:20:43.637]   - Field: ‘earlySignal’
[16:20:43.637]   - Field: ‘lazy’
[16:20:43.637]   - Field: ‘state’
[16:20:43.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.637] - Launch lazy future ...
[16:20:43.637] Packages needed by the future expression (n = 0): <none>
[16:20:43.638] Packages needed by future strategies (n = 0): <none>
[16:20:43.638] {
[16:20:43.638]     {
[16:20:43.638]         {
[16:20:43.638]             ...future.startTime <- base::Sys.time()
[16:20:43.638]             {
[16:20:43.638]                 {
[16:20:43.638]                   {
[16:20:43.638]                     {
[16:20:43.638]                       base::local({
[16:20:43.638]                         has_future <- base::requireNamespace("future", 
[16:20:43.638]                           quietly = TRUE)
[16:20:43.638]                         if (has_future) {
[16:20:43.638]                           ns <- base::getNamespace("future")
[16:20:43.638]                           version <- ns[[".package"]][["version"]]
[16:20:43.638]                           if (is.null(version)) 
[16:20:43.638]                             version <- utils::packageVersion("future")
[16:20:43.638]                         }
[16:20:43.638]                         else {
[16:20:43.638]                           version <- NULL
[16:20:43.638]                         }
[16:20:43.638]                         if (!has_future || version < "1.8.0") {
[16:20:43.638]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.638]                             "", base::R.version$version.string), 
[16:20:43.638]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.638]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.638]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.638]                               "release", "version")], collapse = " "), 
[16:20:43.638]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.638]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.638]                             info)
[16:20:43.638]                           info <- base::paste(info, collapse = "; ")
[16:20:43.638]                           if (!has_future) {
[16:20:43.638]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.638]                               info)
[16:20:43.638]                           }
[16:20:43.638]                           else {
[16:20:43.638]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.638]                               info, version)
[16:20:43.638]                           }
[16:20:43.638]                           base::stop(msg)
[16:20:43.638]                         }
[16:20:43.638]                       })
[16:20:43.638]                     }
[16:20:43.638]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.638]                     base::options(mc.cores = 1L)
[16:20:43.638]                   }
[16:20:43.638]                   ...future.strategy.old <- future::plan("list")
[16:20:43.638]                   options(future.plan = NULL)
[16:20:43.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.638]                 }
[16:20:43.638]                 ...future.workdir <- getwd()
[16:20:43.638]             }
[16:20:43.638]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.638]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.638]         }
[16:20:43.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.638]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.638]             base::names(...future.oldOptions))
[16:20:43.638]     }
[16:20:43.638]     if (FALSE) {
[16:20:43.638]     }
[16:20:43.638]     else {
[16:20:43.638]         if (TRUE) {
[16:20:43.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.638]                 open = "w")
[16:20:43.638]         }
[16:20:43.638]         else {
[16:20:43.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.638]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.638]         }
[16:20:43.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.638]             base::sink(type = "output", split = FALSE)
[16:20:43.638]             base::close(...future.stdout)
[16:20:43.638]         }, add = TRUE)
[16:20:43.638]     }
[16:20:43.638]     ...future.frame <- base::sys.nframe()
[16:20:43.638]     ...future.conditions <- base::list()
[16:20:43.638]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.638]     if (FALSE) {
[16:20:43.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.638]     }
[16:20:43.638]     ...future.result <- base::tryCatch({
[16:20:43.638]         base::withCallingHandlers({
[16:20:43.638]             ...future.value <- base::withVisible(base::local({
[16:20:43.638]                 withCallingHandlers({
[16:20:43.638]                   2
[16:20:43.638]                 }, immediateCondition = function(cond) {
[16:20:43.638]                   save_rds <- function (object, pathname, ...) 
[16:20:43.638]                   {
[16:20:43.638]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.638]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.638]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.638]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.638]                         fi_tmp[["mtime"]])
[16:20:43.638]                     }
[16:20:43.638]                     tryCatch({
[16:20:43.638]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.638]                     }, error = function(ex) {
[16:20:43.638]                       msg <- conditionMessage(ex)
[16:20:43.638]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.638]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.638]                         fi_tmp[["mtime"]], msg)
[16:20:43.638]                       ex$message <- msg
[16:20:43.638]                       stop(ex)
[16:20:43.638]                     })
[16:20:43.638]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.638]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.638]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.638]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.638]                       fi <- file.info(pathname)
[16:20:43.638]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.638]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.638]                         fi[["size"]], fi[["mtime"]])
[16:20:43.638]                       stop(msg)
[16:20:43.638]                     }
[16:20:43.638]                     invisible(pathname)
[16:20:43.638]                   }
[16:20:43.638]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.638]                     rootPath = tempdir()) 
[16:20:43.638]                   {
[16:20:43.638]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.638]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.638]                       tmpdir = path, fileext = ".rds")
[16:20:43.638]                     save_rds(obj, file)
[16:20:43.638]                   }
[16:20:43.638]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.638]                   {
[16:20:43.638]                     inherits <- base::inherits
[16:20:43.638]                     invokeRestart <- base::invokeRestart
[16:20:43.638]                     is.null <- base::is.null
[16:20:43.638]                     muffled <- FALSE
[16:20:43.638]                     if (inherits(cond, "message")) {
[16:20:43.638]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.638]                       if (muffled) 
[16:20:43.638]                         invokeRestart("muffleMessage")
[16:20:43.638]                     }
[16:20:43.638]                     else if (inherits(cond, "warning")) {
[16:20:43.638]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.638]                       if (muffled) 
[16:20:43.638]                         invokeRestart("muffleWarning")
[16:20:43.638]                     }
[16:20:43.638]                     else if (inherits(cond, "condition")) {
[16:20:43.638]                       if (!is.null(pattern)) {
[16:20:43.638]                         computeRestarts <- base::computeRestarts
[16:20:43.638]                         grepl <- base::grepl
[16:20:43.638]                         restarts <- computeRestarts(cond)
[16:20:43.638]                         for (restart in restarts) {
[16:20:43.638]                           name <- restart$name
[16:20:43.638]                           if (is.null(name)) 
[16:20:43.638]                             next
[16:20:43.638]                           if (!grepl(pattern, name)) 
[16:20:43.638]                             next
[16:20:43.638]                           invokeRestart(restart)
[16:20:43.638]                           muffled <- TRUE
[16:20:43.638]                           break
[16:20:43.638]                         }
[16:20:43.638]                       }
[16:20:43.638]                     }
[16:20:43.638]                     invisible(muffled)
[16:20:43.638]                   }
[16:20:43.638]                   muffleCondition(cond)
[16:20:43.638]                 })
[16:20:43.638]             }))
[16:20:43.638]             future::FutureResult(value = ...future.value$value, 
[16:20:43.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.638]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.638]                     ...future.globalenv.names))
[16:20:43.638]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.638]         }, condition = base::local({
[16:20:43.638]             c <- base::c
[16:20:43.638]             inherits <- base::inherits
[16:20:43.638]             invokeRestart <- base::invokeRestart
[16:20:43.638]             length <- base::length
[16:20:43.638]             list <- base::list
[16:20:43.638]             seq.int <- base::seq.int
[16:20:43.638]             signalCondition <- base::signalCondition
[16:20:43.638]             sys.calls <- base::sys.calls
[16:20:43.638]             `[[` <- base::`[[`
[16:20:43.638]             `+` <- base::`+`
[16:20:43.638]             `<<-` <- base::`<<-`
[16:20:43.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.638]                   3L)]
[16:20:43.638]             }
[16:20:43.638]             function(cond) {
[16:20:43.638]                 is_error <- inherits(cond, "error")
[16:20:43.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.638]                   NULL)
[16:20:43.638]                 if (is_error) {
[16:20:43.638]                   sessionInformation <- function() {
[16:20:43.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.638]                       search = base::search(), system = base::Sys.info())
[16:20:43.638]                   }
[16:20:43.638]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.638]                     cond$call), session = sessionInformation(), 
[16:20:43.638]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.638]                   signalCondition(cond)
[16:20:43.638]                 }
[16:20:43.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.638]                 "immediateCondition"))) {
[16:20:43.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.638]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.638]                   if (TRUE && !signal) {
[16:20:43.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.638]                     {
[16:20:43.638]                       inherits <- base::inherits
[16:20:43.638]                       invokeRestart <- base::invokeRestart
[16:20:43.638]                       is.null <- base::is.null
[16:20:43.638]                       muffled <- FALSE
[16:20:43.638]                       if (inherits(cond, "message")) {
[16:20:43.638]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.638]                         if (muffled) 
[16:20:43.638]                           invokeRestart("muffleMessage")
[16:20:43.638]                       }
[16:20:43.638]                       else if (inherits(cond, "warning")) {
[16:20:43.638]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.638]                         if (muffled) 
[16:20:43.638]                           invokeRestart("muffleWarning")
[16:20:43.638]                       }
[16:20:43.638]                       else if (inherits(cond, "condition")) {
[16:20:43.638]                         if (!is.null(pattern)) {
[16:20:43.638]                           computeRestarts <- base::computeRestarts
[16:20:43.638]                           grepl <- base::grepl
[16:20:43.638]                           restarts <- computeRestarts(cond)
[16:20:43.638]                           for (restart in restarts) {
[16:20:43.638]                             name <- restart$name
[16:20:43.638]                             if (is.null(name)) 
[16:20:43.638]                               next
[16:20:43.638]                             if (!grepl(pattern, name)) 
[16:20:43.638]                               next
[16:20:43.638]                             invokeRestart(restart)
[16:20:43.638]                             muffled <- TRUE
[16:20:43.638]                             break
[16:20:43.638]                           }
[16:20:43.638]                         }
[16:20:43.638]                       }
[16:20:43.638]                       invisible(muffled)
[16:20:43.638]                     }
[16:20:43.638]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.638]                   }
[16:20:43.638]                 }
[16:20:43.638]                 else {
[16:20:43.638]                   if (TRUE) {
[16:20:43.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.638]                     {
[16:20:43.638]                       inherits <- base::inherits
[16:20:43.638]                       invokeRestart <- base::invokeRestart
[16:20:43.638]                       is.null <- base::is.null
[16:20:43.638]                       muffled <- FALSE
[16:20:43.638]                       if (inherits(cond, "message")) {
[16:20:43.638]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.638]                         if (muffled) 
[16:20:43.638]                           invokeRestart("muffleMessage")
[16:20:43.638]                       }
[16:20:43.638]                       else if (inherits(cond, "warning")) {
[16:20:43.638]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.638]                         if (muffled) 
[16:20:43.638]                           invokeRestart("muffleWarning")
[16:20:43.638]                       }
[16:20:43.638]                       else if (inherits(cond, "condition")) {
[16:20:43.638]                         if (!is.null(pattern)) {
[16:20:43.638]                           computeRestarts <- base::computeRestarts
[16:20:43.638]                           grepl <- base::grepl
[16:20:43.638]                           restarts <- computeRestarts(cond)
[16:20:43.638]                           for (restart in restarts) {
[16:20:43.638]                             name <- restart$name
[16:20:43.638]                             if (is.null(name)) 
[16:20:43.638]                               next
[16:20:43.638]                             if (!grepl(pattern, name)) 
[16:20:43.638]                               next
[16:20:43.638]                             invokeRestart(restart)
[16:20:43.638]                             muffled <- TRUE
[16:20:43.638]                             break
[16:20:43.638]                           }
[16:20:43.638]                         }
[16:20:43.638]                       }
[16:20:43.638]                       invisible(muffled)
[16:20:43.638]                     }
[16:20:43.638]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.638]                   }
[16:20:43.638]                 }
[16:20:43.638]             }
[16:20:43.638]         }))
[16:20:43.638]     }, error = function(ex) {
[16:20:43.638]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.638]                 ...future.rng), started = ...future.startTime, 
[16:20:43.638]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.638]             version = "1.8"), class = "FutureResult")
[16:20:43.638]     }, finally = {
[16:20:43.638]         if (!identical(...future.workdir, getwd())) 
[16:20:43.638]             setwd(...future.workdir)
[16:20:43.638]         {
[16:20:43.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.638]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.638]             }
[16:20:43.638]             base::options(...future.oldOptions)
[16:20:43.638]             if (.Platform$OS.type == "windows") {
[16:20:43.638]                 old_names <- names(...future.oldEnvVars)
[16:20:43.638]                 envs <- base::Sys.getenv()
[16:20:43.638]                 names <- names(envs)
[16:20:43.638]                 common <- intersect(names, old_names)
[16:20:43.638]                 added <- setdiff(names, old_names)
[16:20:43.638]                 removed <- setdiff(old_names, names)
[16:20:43.638]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.638]                   envs[common]]
[16:20:43.638]                 NAMES <- toupper(changed)
[16:20:43.638]                 args <- list()
[16:20:43.638]                 for (kk in seq_along(NAMES)) {
[16:20:43.638]                   name <- changed[[kk]]
[16:20:43.638]                   NAME <- NAMES[[kk]]
[16:20:43.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.638]                     next
[16:20:43.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.638]                 }
[16:20:43.638]                 NAMES <- toupper(added)
[16:20:43.638]                 for (kk in seq_along(NAMES)) {
[16:20:43.638]                   name <- added[[kk]]
[16:20:43.638]                   NAME <- NAMES[[kk]]
[16:20:43.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.638]                     next
[16:20:43.638]                   args[[name]] <- ""
[16:20:43.638]                 }
[16:20:43.638]                 NAMES <- toupper(removed)
[16:20:43.638]                 for (kk in seq_along(NAMES)) {
[16:20:43.638]                   name <- removed[[kk]]
[16:20:43.638]                   NAME <- NAMES[[kk]]
[16:20:43.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.638]                     next
[16:20:43.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.638]                 }
[16:20:43.638]                 if (length(args) > 0) 
[16:20:43.638]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.638]             }
[16:20:43.638]             else {
[16:20:43.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.638]             }
[16:20:43.638]             {
[16:20:43.638]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.638]                   0L) {
[16:20:43.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.638]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.638]                   base::options(opts)
[16:20:43.638]                 }
[16:20:43.638]                 {
[16:20:43.638]                   {
[16:20:43.638]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.638]                     NULL
[16:20:43.638]                   }
[16:20:43.638]                   options(future.plan = NULL)
[16:20:43.638]                   if (is.na(NA_character_)) 
[16:20:43.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.638]                     .init = FALSE)
[16:20:43.638]                 }
[16:20:43.638]             }
[16:20:43.638]         }
[16:20:43.638]     })
[16:20:43.638]     if (TRUE) {
[16:20:43.638]         base::sink(type = "output", split = FALSE)
[16:20:43.638]         if (TRUE) {
[16:20:43.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.638]         }
[16:20:43.638]         else {
[16:20:43.638]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.638]         }
[16:20:43.638]         base::close(...future.stdout)
[16:20:43.638]         ...future.stdout <- NULL
[16:20:43.638]     }
[16:20:43.638]     ...future.result$conditions <- ...future.conditions
[16:20:43.638]     ...future.result$finished <- base::Sys.time()
[16:20:43.638]     ...future.result
[16:20:43.638] }
[16:20:43.640] requestCore(): workers = 2
[16:20:43.643] MulticoreFuture started
[16:20:43.643] - Launch lazy future ... done
[16:20:43.643] run() for ‘MulticoreFuture’ ... done
[16:20:43.644] getGlobalsAndPackages() ...
[16:20:43.644] Searching for globals...
[16:20:43.644] plan(): Setting new future strategy stack:
[16:20:43.645] 
[16:20:43.645] Searching for globals ... DONE
[16:20:43.644] List of future strategies:
[16:20:43.644] 1. sequential:
[16:20:43.644]    - args: function (..., envir = parent.frame())
[16:20:43.644]    - tweaked: FALSE
[16:20:43.644]    - call: NULL
[16:20:43.645] - globals: [0] <none>
[16:20:43.645] getGlobalsAndPackages() ... DONE
[16:20:43.645] plan(): nbrOfWorkers() = 1
[16:20:43.646] run() for ‘Future’ ...
[16:20:43.646] - state: ‘created’
[16:20:43.646] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.647] plan(): Setting new future strategy stack:
[16:20:43.647] List of future strategies:
[16:20:43.647] 1. multicore:
[16:20:43.647]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.647]    - tweaked: FALSE
[16:20:43.647]    - call: plan(strategy)
[16:20:43.651] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.651]   - Field: ‘label’
[16:20:43.651] plan(): nbrOfWorkers() = 2
[16:20:43.651]   - Field: ‘local’
[16:20:43.652]   - Field: ‘owner’
[16:20:43.652]   - Field: ‘envir’
[16:20:43.652]   - Field: ‘workers’
[16:20:43.652]   - Field: ‘packages’
[16:20:43.652]   - Field: ‘gc’
[16:20:43.652]   - Field: ‘job’
[16:20:43.652]   - Field: ‘conditions’
[16:20:43.653]   - Field: ‘expr’
[16:20:43.653]   - Field: ‘uuid’
[16:20:43.653]   - Field: ‘seed’
[16:20:43.653]   - Field: ‘version’
[16:20:43.653]   - Field: ‘result’
[16:20:43.653]   - Field: ‘asynchronous’
[16:20:43.653]   - Field: ‘calls’
[16:20:43.654]   - Field: ‘globals’
[16:20:43.654]   - Field: ‘stdout’
[16:20:43.654]   - Field: ‘earlySignal’
[16:20:43.654]   - Field: ‘lazy’
[16:20:43.654]   - Field: ‘state’
[16:20:43.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.654] - Launch lazy future ...
[16:20:43.655] Packages needed by the future expression (n = 0): <none>
[16:20:43.655] Packages needed by future strategies (n = 0): <none>
[16:20:43.656] {
[16:20:43.656]     {
[16:20:43.656]         {
[16:20:43.656]             ...future.startTime <- base::Sys.time()
[16:20:43.656]             {
[16:20:43.656]                 {
[16:20:43.656]                   {
[16:20:43.656]                     {
[16:20:43.656]                       base::local({
[16:20:43.656]                         has_future <- base::requireNamespace("future", 
[16:20:43.656]                           quietly = TRUE)
[16:20:43.656]                         if (has_future) {
[16:20:43.656]                           ns <- base::getNamespace("future")
[16:20:43.656]                           version <- ns[[".package"]][["version"]]
[16:20:43.656]                           if (is.null(version)) 
[16:20:43.656]                             version <- utils::packageVersion("future")
[16:20:43.656]                         }
[16:20:43.656]                         else {
[16:20:43.656]                           version <- NULL
[16:20:43.656]                         }
[16:20:43.656]                         if (!has_future || version < "1.8.0") {
[16:20:43.656]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.656]                             "", base::R.version$version.string), 
[16:20:43.656]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.656]                               "release", "version")], collapse = " "), 
[16:20:43.656]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.656]                             info)
[16:20:43.656]                           info <- base::paste(info, collapse = "; ")
[16:20:43.656]                           if (!has_future) {
[16:20:43.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.656]                               info)
[16:20:43.656]                           }
[16:20:43.656]                           else {
[16:20:43.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.656]                               info, version)
[16:20:43.656]                           }
[16:20:43.656]                           base::stop(msg)
[16:20:43.656]                         }
[16:20:43.656]                       })
[16:20:43.656]                     }
[16:20:43.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.656]                     base::options(mc.cores = 1L)
[16:20:43.656]                   }
[16:20:43.656]                   ...future.strategy.old <- future::plan("list")
[16:20:43.656]                   options(future.plan = NULL)
[16:20:43.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.656]                 }
[16:20:43.656]                 ...future.workdir <- getwd()
[16:20:43.656]             }
[16:20:43.656]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.656]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.656]         }
[16:20:43.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.656]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.656]             base::names(...future.oldOptions))
[16:20:43.656]     }
[16:20:43.656]     if (FALSE) {
[16:20:43.656]     }
[16:20:43.656]     else {
[16:20:43.656]         if (TRUE) {
[16:20:43.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.656]                 open = "w")
[16:20:43.656]         }
[16:20:43.656]         else {
[16:20:43.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.656]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.656]         }
[16:20:43.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.656]             base::sink(type = "output", split = FALSE)
[16:20:43.656]             base::close(...future.stdout)
[16:20:43.656]         }, add = TRUE)
[16:20:43.656]     }
[16:20:43.656]     ...future.frame <- base::sys.nframe()
[16:20:43.656]     ...future.conditions <- base::list()
[16:20:43.656]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.656]     if (FALSE) {
[16:20:43.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.656]     }
[16:20:43.656]     ...future.result <- base::tryCatch({
[16:20:43.656]         base::withCallingHandlers({
[16:20:43.656]             ...future.value <- base::withVisible(base::local({
[16:20:43.656]                 withCallingHandlers({
[16:20:43.656]                   NULL
[16:20:43.656]                 }, immediateCondition = function(cond) {
[16:20:43.656]                   save_rds <- function (object, pathname, ...) 
[16:20:43.656]                   {
[16:20:43.656]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.656]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.656]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.656]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.656]                         fi_tmp[["mtime"]])
[16:20:43.656]                     }
[16:20:43.656]                     tryCatch({
[16:20:43.656]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.656]                     }, error = function(ex) {
[16:20:43.656]                       msg <- conditionMessage(ex)
[16:20:43.656]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.656]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.656]                         fi_tmp[["mtime"]], msg)
[16:20:43.656]                       ex$message <- msg
[16:20:43.656]                       stop(ex)
[16:20:43.656]                     })
[16:20:43.656]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.656]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.656]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.656]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.656]                       fi <- file.info(pathname)
[16:20:43.656]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.656]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.656]                         fi[["size"]], fi[["mtime"]])
[16:20:43.656]                       stop(msg)
[16:20:43.656]                     }
[16:20:43.656]                     invisible(pathname)
[16:20:43.656]                   }
[16:20:43.656]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.656]                     rootPath = tempdir()) 
[16:20:43.656]                   {
[16:20:43.656]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.656]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.656]                       tmpdir = path, fileext = ".rds")
[16:20:43.656]                     save_rds(obj, file)
[16:20:43.656]                   }
[16:20:43.656]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.656]                   {
[16:20:43.656]                     inherits <- base::inherits
[16:20:43.656]                     invokeRestart <- base::invokeRestart
[16:20:43.656]                     is.null <- base::is.null
[16:20:43.656]                     muffled <- FALSE
[16:20:43.656]                     if (inherits(cond, "message")) {
[16:20:43.656]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.656]                       if (muffled) 
[16:20:43.656]                         invokeRestart("muffleMessage")
[16:20:43.656]                     }
[16:20:43.656]                     else if (inherits(cond, "warning")) {
[16:20:43.656]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.656]                       if (muffled) 
[16:20:43.656]                         invokeRestart("muffleWarning")
[16:20:43.656]                     }
[16:20:43.656]                     else if (inherits(cond, "condition")) {
[16:20:43.656]                       if (!is.null(pattern)) {
[16:20:43.656]                         computeRestarts <- base::computeRestarts
[16:20:43.656]                         grepl <- base::grepl
[16:20:43.656]                         restarts <- computeRestarts(cond)
[16:20:43.656]                         for (restart in restarts) {
[16:20:43.656]                           name <- restart$name
[16:20:43.656]                           if (is.null(name)) 
[16:20:43.656]                             next
[16:20:43.656]                           if (!grepl(pattern, name)) 
[16:20:43.656]                             next
[16:20:43.656]                           invokeRestart(restart)
[16:20:43.656]                           muffled <- TRUE
[16:20:43.656]                           break
[16:20:43.656]                         }
[16:20:43.656]                       }
[16:20:43.656]                     }
[16:20:43.656]                     invisible(muffled)
[16:20:43.656]                   }
[16:20:43.656]                   muffleCondition(cond)
[16:20:43.656]                 })
[16:20:43.656]             }))
[16:20:43.656]             future::FutureResult(value = ...future.value$value, 
[16:20:43.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.656]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.656]                     ...future.globalenv.names))
[16:20:43.656]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.656]         }, condition = base::local({
[16:20:43.656]             c <- base::c
[16:20:43.656]             inherits <- base::inherits
[16:20:43.656]             invokeRestart <- base::invokeRestart
[16:20:43.656]             length <- base::length
[16:20:43.656]             list <- base::list
[16:20:43.656]             seq.int <- base::seq.int
[16:20:43.656]             signalCondition <- base::signalCondition
[16:20:43.656]             sys.calls <- base::sys.calls
[16:20:43.656]             `[[` <- base::`[[`
[16:20:43.656]             `+` <- base::`+`
[16:20:43.656]             `<<-` <- base::`<<-`
[16:20:43.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.656]                   3L)]
[16:20:43.656]             }
[16:20:43.656]             function(cond) {
[16:20:43.656]                 is_error <- inherits(cond, "error")
[16:20:43.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.656]                   NULL)
[16:20:43.656]                 if (is_error) {
[16:20:43.656]                   sessionInformation <- function() {
[16:20:43.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.656]                       search = base::search(), system = base::Sys.info())
[16:20:43.656]                   }
[16:20:43.656]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.656]                     cond$call), session = sessionInformation(), 
[16:20:43.656]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.656]                   signalCondition(cond)
[16:20:43.656]                 }
[16:20:43.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.656]                 "immediateCondition"))) {
[16:20:43.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.656]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.656]                   if (TRUE && !signal) {
[16:20:43.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.656]                     {
[16:20:43.656]                       inherits <- base::inherits
[16:20:43.656]                       invokeRestart <- base::invokeRestart
[16:20:43.656]                       is.null <- base::is.null
[16:20:43.656]                       muffled <- FALSE
[16:20:43.656]                       if (inherits(cond, "message")) {
[16:20:43.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.656]                         if (muffled) 
[16:20:43.656]                           invokeRestart("muffleMessage")
[16:20:43.656]                       }
[16:20:43.656]                       else if (inherits(cond, "warning")) {
[16:20:43.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.656]                         if (muffled) 
[16:20:43.656]                           invokeRestart("muffleWarning")
[16:20:43.656]                       }
[16:20:43.656]                       else if (inherits(cond, "condition")) {
[16:20:43.656]                         if (!is.null(pattern)) {
[16:20:43.656]                           computeRestarts <- base::computeRestarts
[16:20:43.656]                           grepl <- base::grepl
[16:20:43.656]                           restarts <- computeRestarts(cond)
[16:20:43.656]                           for (restart in restarts) {
[16:20:43.656]                             name <- restart$name
[16:20:43.656]                             if (is.null(name)) 
[16:20:43.656]                               next
[16:20:43.656]                             if (!grepl(pattern, name)) 
[16:20:43.656]                               next
[16:20:43.656]                             invokeRestart(restart)
[16:20:43.656]                             muffled <- TRUE
[16:20:43.656]                             break
[16:20:43.656]                           }
[16:20:43.656]                         }
[16:20:43.656]                       }
[16:20:43.656]                       invisible(muffled)
[16:20:43.656]                     }
[16:20:43.656]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.656]                   }
[16:20:43.656]                 }
[16:20:43.656]                 else {
[16:20:43.656]                   if (TRUE) {
[16:20:43.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.656]                     {
[16:20:43.656]                       inherits <- base::inherits
[16:20:43.656]                       invokeRestart <- base::invokeRestart
[16:20:43.656]                       is.null <- base::is.null
[16:20:43.656]                       muffled <- FALSE
[16:20:43.656]                       if (inherits(cond, "message")) {
[16:20:43.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.656]                         if (muffled) 
[16:20:43.656]                           invokeRestart("muffleMessage")
[16:20:43.656]                       }
[16:20:43.656]                       else if (inherits(cond, "warning")) {
[16:20:43.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.656]                         if (muffled) 
[16:20:43.656]                           invokeRestart("muffleWarning")
[16:20:43.656]                       }
[16:20:43.656]                       else if (inherits(cond, "condition")) {
[16:20:43.656]                         if (!is.null(pattern)) {
[16:20:43.656]                           computeRestarts <- base::computeRestarts
[16:20:43.656]                           grepl <- base::grepl
[16:20:43.656]                           restarts <- computeRestarts(cond)
[16:20:43.656]                           for (restart in restarts) {
[16:20:43.656]                             name <- restart$name
[16:20:43.656]                             if (is.null(name)) 
[16:20:43.656]                               next
[16:20:43.656]                             if (!grepl(pattern, name)) 
[16:20:43.656]                               next
[16:20:43.656]                             invokeRestart(restart)
[16:20:43.656]                             muffled <- TRUE
[16:20:43.656]                             break
[16:20:43.656]                           }
[16:20:43.656]                         }
[16:20:43.656]                       }
[16:20:43.656]                       invisible(muffled)
[16:20:43.656]                     }
[16:20:43.656]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.656]                   }
[16:20:43.656]                 }
[16:20:43.656]             }
[16:20:43.656]         }))
[16:20:43.656]     }, error = function(ex) {
[16:20:43.656]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.656]                 ...future.rng), started = ...future.startTime, 
[16:20:43.656]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.656]             version = "1.8"), class = "FutureResult")
[16:20:43.656]     }, finally = {
[16:20:43.656]         if (!identical(...future.workdir, getwd())) 
[16:20:43.656]             setwd(...future.workdir)
[16:20:43.656]         {
[16:20:43.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.656]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.656]             }
[16:20:43.656]             base::options(...future.oldOptions)
[16:20:43.656]             if (.Platform$OS.type == "windows") {
[16:20:43.656]                 old_names <- names(...future.oldEnvVars)
[16:20:43.656]                 envs <- base::Sys.getenv()
[16:20:43.656]                 names <- names(envs)
[16:20:43.656]                 common <- intersect(names, old_names)
[16:20:43.656]                 added <- setdiff(names, old_names)
[16:20:43.656]                 removed <- setdiff(old_names, names)
[16:20:43.656]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.656]                   envs[common]]
[16:20:43.656]                 NAMES <- toupper(changed)
[16:20:43.656]                 args <- list()
[16:20:43.656]                 for (kk in seq_along(NAMES)) {
[16:20:43.656]                   name <- changed[[kk]]
[16:20:43.656]                   NAME <- NAMES[[kk]]
[16:20:43.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.656]                     next
[16:20:43.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.656]                 }
[16:20:43.656]                 NAMES <- toupper(added)
[16:20:43.656]                 for (kk in seq_along(NAMES)) {
[16:20:43.656]                   name <- added[[kk]]
[16:20:43.656]                   NAME <- NAMES[[kk]]
[16:20:43.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.656]                     next
[16:20:43.656]                   args[[name]] <- ""
[16:20:43.656]                 }
[16:20:43.656]                 NAMES <- toupper(removed)
[16:20:43.656]                 for (kk in seq_along(NAMES)) {
[16:20:43.656]                   name <- removed[[kk]]
[16:20:43.656]                   NAME <- NAMES[[kk]]
[16:20:43.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.656]                     next
[16:20:43.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.656]                 }
[16:20:43.656]                 if (length(args) > 0) 
[16:20:43.656]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.656]             }
[16:20:43.656]             else {
[16:20:43.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.656]             }
[16:20:43.656]             {
[16:20:43.656]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.656]                   0L) {
[16:20:43.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.656]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.656]                   base::options(opts)
[16:20:43.656]                 }
[16:20:43.656]                 {
[16:20:43.656]                   {
[16:20:43.656]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.656]                     NULL
[16:20:43.656]                   }
[16:20:43.656]                   options(future.plan = NULL)
[16:20:43.656]                   if (is.na(NA_character_)) 
[16:20:43.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.656]                     .init = FALSE)
[16:20:43.656]                 }
[16:20:43.656]             }
[16:20:43.656]         }
[16:20:43.656]     })
[16:20:43.656]     if (TRUE) {
[16:20:43.656]         base::sink(type = "output", split = FALSE)
[16:20:43.656]         if (TRUE) {
[16:20:43.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.656]         }
[16:20:43.656]         else {
[16:20:43.656]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.656]         }
[16:20:43.656]         base::close(...future.stdout)
[16:20:43.656]         ...future.stdout <- NULL
[16:20:43.656]     }
[16:20:43.656]     ...future.result$conditions <- ...future.conditions
[16:20:43.656]     ...future.result$finished <- base::Sys.time()
[16:20:43.656]     ...future.result
[16:20:43.656] }
[16:20:43.659] requestCore(): workers = 2
[16:20:43.662] MulticoreFuture started
[16:20:43.662] - Launch lazy future ... done
[16:20:43.662] run() for ‘MulticoreFuture’ ... done
[16:20:43.663] plan(): Setting new future strategy stack:
[16:20:43.663] getGlobalsAndPackages() ...
[16:20:43.663] Searching for globals...
[16:20:43.663] List of future strategies:
[16:20:43.663] 1. sequential:
[16:20:43.663]    - args: function (..., envir = parent.frame())
[16:20:43.663]    - tweaked: FALSE
[16:20:43.663]    - call: NULL
[16:20:43.664] plan(): nbrOfWorkers() = 1
[16:20:43.665] - globals found: [1] ‘{’
[16:20:43.665] Searching for globals ... DONE
[16:20:43.665] Resolving globals: FALSE
[16:20:43.666] 
[16:20:43.666] 
[16:20:43.666] getGlobalsAndPackages() ... DONE
[16:20:43.666] plan(): Setting new future strategy stack:
[16:20:43.667] run() for ‘Future’ ...
[16:20:43.667] - state: ‘created’
[16:20:43.666] List of future strategies:
[16:20:43.666] 1. multicore:
[16:20:43.666]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.666]    - tweaked: FALSE
[16:20:43.666]    - call: plan(strategy)
[16:20:43.667] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:43.672] plan(): nbrOfWorkers() = 2
[16:20:43.673] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:43.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:43.673]   - Field: ‘label’
[16:20:43.673]   - Field: ‘local’
[16:20:43.674]   - Field: ‘owner’
[16:20:43.674]   - Field: ‘envir’
[16:20:43.674]   - Field: ‘workers’
[16:20:43.674]   - Field: ‘packages’
[16:20:43.674]   - Field: ‘gc’
[16:20:43.674]   - Field: ‘job’
[16:20:43.675]   - Field: ‘conditions’
[16:20:43.675]   - Field: ‘expr’
[16:20:43.675]   - Field: ‘uuid’
[16:20:43.675]   - Field: ‘seed’
[16:20:43.675]   - Field: ‘version’
[16:20:43.676]   - Field: ‘result’
[16:20:43.676]   - Field: ‘asynchronous’
[16:20:43.676]   - Field: ‘calls’
[16:20:43.676]   - Field: ‘globals’
[16:20:43.676]   - Field: ‘stdout’
[16:20:43.676]   - Field: ‘earlySignal’
[16:20:43.677]   - Field: ‘lazy’
[16:20:43.677]   - Field: ‘state’
[16:20:43.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:43.677] - Launch lazy future ...
[16:20:43.678] Packages needed by the future expression (n = 0): <none>
[16:20:43.678] Packages needed by future strategies (n = 0): <none>
[16:20:43.679] {
[16:20:43.679]     {
[16:20:43.679]         {
[16:20:43.679]             ...future.startTime <- base::Sys.time()
[16:20:43.679]             {
[16:20:43.679]                 {
[16:20:43.679]                   {
[16:20:43.679]                     {
[16:20:43.679]                       base::local({
[16:20:43.679]                         has_future <- base::requireNamespace("future", 
[16:20:43.679]                           quietly = TRUE)
[16:20:43.679]                         if (has_future) {
[16:20:43.679]                           ns <- base::getNamespace("future")
[16:20:43.679]                           version <- ns[[".package"]][["version"]]
[16:20:43.679]                           if (is.null(version)) 
[16:20:43.679]                             version <- utils::packageVersion("future")
[16:20:43.679]                         }
[16:20:43.679]                         else {
[16:20:43.679]                           version <- NULL
[16:20:43.679]                         }
[16:20:43.679]                         if (!has_future || version < "1.8.0") {
[16:20:43.679]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:43.679]                             "", base::R.version$version.string), 
[16:20:43.679]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:43.679]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:43.679]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:43.679]                               "release", "version")], collapse = " "), 
[16:20:43.679]                             hostname = base::Sys.info()[["nodename"]])
[16:20:43.679]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:43.679]                             info)
[16:20:43.679]                           info <- base::paste(info, collapse = "; ")
[16:20:43.679]                           if (!has_future) {
[16:20:43.679]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:43.679]                               info)
[16:20:43.679]                           }
[16:20:43.679]                           else {
[16:20:43.679]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:43.679]                               info, version)
[16:20:43.679]                           }
[16:20:43.679]                           base::stop(msg)
[16:20:43.679]                         }
[16:20:43.679]                       })
[16:20:43.679]                     }
[16:20:43.679]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:43.679]                     base::options(mc.cores = 1L)
[16:20:43.679]                   }
[16:20:43.679]                   ...future.strategy.old <- future::plan("list")
[16:20:43.679]                   options(future.plan = NULL)
[16:20:43.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:43.679]                 }
[16:20:43.679]                 ...future.workdir <- getwd()
[16:20:43.679]             }
[16:20:43.679]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:43.679]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:43.679]         }
[16:20:43.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:43.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:43.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:43.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:43.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:43.679]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:43.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:43.679]             base::names(...future.oldOptions))
[16:20:43.679]     }
[16:20:43.679]     if (FALSE) {
[16:20:43.679]     }
[16:20:43.679]     else {
[16:20:43.679]         if (TRUE) {
[16:20:43.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:43.679]                 open = "w")
[16:20:43.679]         }
[16:20:43.679]         else {
[16:20:43.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:43.679]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:43.679]         }
[16:20:43.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:43.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:43.679]             base::sink(type = "output", split = FALSE)
[16:20:43.679]             base::close(...future.stdout)
[16:20:43.679]         }, add = TRUE)
[16:20:43.679]     }
[16:20:43.679]     ...future.frame <- base::sys.nframe()
[16:20:43.679]     ...future.conditions <- base::list()
[16:20:43.679]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:43.679]     if (FALSE) {
[16:20:43.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:43.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:43.679]     }
[16:20:43.679]     ...future.result <- base::tryCatch({
[16:20:43.679]         base::withCallingHandlers({
[16:20:43.679]             ...future.value <- base::withVisible(base::local({
[16:20:43.679]                 withCallingHandlers({
[16:20:43.679]                   {
[16:20:43.679]                     4
[16:20:43.679]                   }
[16:20:43.679]                 }, immediateCondition = function(cond) {
[16:20:43.679]                   save_rds <- function (object, pathname, ...) 
[16:20:43.679]                   {
[16:20:43.679]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:43.679]                     if (file_test("-f", pathname_tmp)) {
[16:20:43.679]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.679]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:43.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.679]                         fi_tmp[["mtime"]])
[16:20:43.679]                     }
[16:20:43.679]                     tryCatch({
[16:20:43.679]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:43.679]                     }, error = function(ex) {
[16:20:43.679]                       msg <- conditionMessage(ex)
[16:20:43.679]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.679]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:43.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.679]                         fi_tmp[["mtime"]], msg)
[16:20:43.679]                       ex$message <- msg
[16:20:43.679]                       stop(ex)
[16:20:43.679]                     })
[16:20:43.679]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:43.679]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:43.679]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:43.679]                       fi_tmp <- file.info(pathname_tmp)
[16:20:43.679]                       fi <- file.info(pathname)
[16:20:43.679]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:43.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:43.679]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:43.679]                         fi[["size"]], fi[["mtime"]])
[16:20:43.679]                       stop(msg)
[16:20:43.679]                     }
[16:20:43.679]                     invisible(pathname)
[16:20:43.679]                   }
[16:20:43.679]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:43.679]                     rootPath = tempdir()) 
[16:20:43.679]                   {
[16:20:43.679]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:43.679]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:43.679]                       tmpdir = path, fileext = ".rds")
[16:20:43.679]                     save_rds(obj, file)
[16:20:43.679]                   }
[16:20:43.679]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:43.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.679]                   {
[16:20:43.679]                     inherits <- base::inherits
[16:20:43.679]                     invokeRestart <- base::invokeRestart
[16:20:43.679]                     is.null <- base::is.null
[16:20:43.679]                     muffled <- FALSE
[16:20:43.679]                     if (inherits(cond, "message")) {
[16:20:43.679]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:43.679]                       if (muffled) 
[16:20:43.679]                         invokeRestart("muffleMessage")
[16:20:43.679]                     }
[16:20:43.679]                     else if (inherits(cond, "warning")) {
[16:20:43.679]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:43.679]                       if (muffled) 
[16:20:43.679]                         invokeRestart("muffleWarning")
[16:20:43.679]                     }
[16:20:43.679]                     else if (inherits(cond, "condition")) {
[16:20:43.679]                       if (!is.null(pattern)) {
[16:20:43.679]                         computeRestarts <- base::computeRestarts
[16:20:43.679]                         grepl <- base::grepl
[16:20:43.679]                         restarts <- computeRestarts(cond)
[16:20:43.679]                         for (restart in restarts) {
[16:20:43.679]                           name <- restart$name
[16:20:43.679]                           if (is.null(name)) 
[16:20:43.679]                             next
[16:20:43.679]                           if (!grepl(pattern, name)) 
[16:20:43.679]                             next
[16:20:43.679]                           invokeRestart(restart)
[16:20:43.679]                           muffled <- TRUE
[16:20:43.679]                           break
[16:20:43.679]                         }
[16:20:43.679]                       }
[16:20:43.679]                     }
[16:20:43.679]                     invisible(muffled)
[16:20:43.679]                   }
[16:20:43.679]                   muffleCondition(cond)
[16:20:43.679]                 })
[16:20:43.679]             }))
[16:20:43.679]             future::FutureResult(value = ...future.value$value, 
[16:20:43.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.679]                   ...future.rng), globalenv = if (FALSE) 
[16:20:43.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:43.679]                     ...future.globalenv.names))
[16:20:43.679]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:43.679]         }, condition = base::local({
[16:20:43.679]             c <- base::c
[16:20:43.679]             inherits <- base::inherits
[16:20:43.679]             invokeRestart <- base::invokeRestart
[16:20:43.679]             length <- base::length
[16:20:43.679]             list <- base::list
[16:20:43.679]             seq.int <- base::seq.int
[16:20:43.679]             signalCondition <- base::signalCondition
[16:20:43.679]             sys.calls <- base::sys.calls
[16:20:43.679]             `[[` <- base::`[[`
[16:20:43.679]             `+` <- base::`+`
[16:20:43.679]             `<<-` <- base::`<<-`
[16:20:43.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:43.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:43.679]                   3L)]
[16:20:43.679]             }
[16:20:43.679]             function(cond) {
[16:20:43.679]                 is_error <- inherits(cond, "error")
[16:20:43.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:43.679]                   NULL)
[16:20:43.679]                 if (is_error) {
[16:20:43.679]                   sessionInformation <- function() {
[16:20:43.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:43.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:43.679]                       search = base::search(), system = base::Sys.info())
[16:20:43.679]                   }
[16:20:43.679]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:43.679]                     cond$call), session = sessionInformation(), 
[16:20:43.679]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:43.679]                   signalCondition(cond)
[16:20:43.679]                 }
[16:20:43.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:43.679]                 "immediateCondition"))) {
[16:20:43.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:43.679]                   ...future.conditions[[length(...future.conditions) + 
[16:20:43.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:43.679]                   if (TRUE && !signal) {
[16:20:43.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.679]                     {
[16:20:43.679]                       inherits <- base::inherits
[16:20:43.679]                       invokeRestart <- base::invokeRestart
[16:20:43.679]                       is.null <- base::is.null
[16:20:43.679]                       muffled <- FALSE
[16:20:43.679]                       if (inherits(cond, "message")) {
[16:20:43.679]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.679]                         if (muffled) 
[16:20:43.679]                           invokeRestart("muffleMessage")
[16:20:43.679]                       }
[16:20:43.679]                       else if (inherits(cond, "warning")) {
[16:20:43.679]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.679]                         if (muffled) 
[16:20:43.679]                           invokeRestart("muffleWarning")
[16:20:43.679]                       }
[16:20:43.679]                       else if (inherits(cond, "condition")) {
[16:20:43.679]                         if (!is.null(pattern)) {
[16:20:43.679]                           computeRestarts <- base::computeRestarts
[16:20:43.679]                           grepl <- base::grepl
[16:20:43.679]                           restarts <- computeRestarts(cond)
[16:20:43.679]                           for (restart in restarts) {
[16:20:43.679]                             name <- restart$name
[16:20:43.679]                             if (is.null(name)) 
[16:20:43.679]                               next
[16:20:43.679]                             if (!grepl(pattern, name)) 
[16:20:43.679]                               next
[16:20:43.679]                             invokeRestart(restart)
[16:20:43.679]                             muffled <- TRUE
[16:20:43.679]                             break
[16:20:43.679]                           }
[16:20:43.679]                         }
[16:20:43.679]                       }
[16:20:43.679]                       invisible(muffled)
[16:20:43.679]                     }
[16:20:43.679]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.679]                   }
[16:20:43.679]                 }
[16:20:43.679]                 else {
[16:20:43.679]                   if (TRUE) {
[16:20:43.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:43.679]                     {
[16:20:43.679]                       inherits <- base::inherits
[16:20:43.679]                       invokeRestart <- base::invokeRestart
[16:20:43.679]                       is.null <- base::is.null
[16:20:43.679]                       muffled <- FALSE
[16:20:43.679]                       if (inherits(cond, "message")) {
[16:20:43.679]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:43.679]                         if (muffled) 
[16:20:43.679]                           invokeRestart("muffleMessage")
[16:20:43.679]                       }
[16:20:43.679]                       else if (inherits(cond, "warning")) {
[16:20:43.679]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:43.679]                         if (muffled) 
[16:20:43.679]                           invokeRestart("muffleWarning")
[16:20:43.679]                       }
[16:20:43.679]                       else if (inherits(cond, "condition")) {
[16:20:43.679]                         if (!is.null(pattern)) {
[16:20:43.679]                           computeRestarts <- base::computeRestarts
[16:20:43.679]                           grepl <- base::grepl
[16:20:43.679]                           restarts <- computeRestarts(cond)
[16:20:43.679]                           for (restart in restarts) {
[16:20:43.679]                             name <- restart$name
[16:20:43.679]                             if (is.null(name)) 
[16:20:43.679]                               next
[16:20:43.679]                             if (!grepl(pattern, name)) 
[16:20:43.679]                               next
[16:20:43.679]                             invokeRestart(restart)
[16:20:43.679]                             muffled <- TRUE
[16:20:43.679]                             break
[16:20:43.679]                           }
[16:20:43.679]                         }
[16:20:43.679]                       }
[16:20:43.679]                       invisible(muffled)
[16:20:43.679]                     }
[16:20:43.679]                     muffleCondition(cond, pattern = "^muffle")
[16:20:43.679]                   }
[16:20:43.679]                 }
[16:20:43.679]             }
[16:20:43.679]         }))
[16:20:43.679]     }, error = function(ex) {
[16:20:43.679]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:43.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:43.679]                 ...future.rng), started = ...future.startTime, 
[16:20:43.679]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:43.679]             version = "1.8"), class = "FutureResult")
[16:20:43.679]     }, finally = {
[16:20:43.679]         if (!identical(...future.workdir, getwd())) 
[16:20:43.679]             setwd(...future.workdir)
[16:20:43.679]         {
[16:20:43.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:43.679]                 ...future.oldOptions$nwarnings <- NULL
[16:20:43.679]             }
[16:20:43.679]             base::options(...future.oldOptions)
[16:20:43.679]             if (.Platform$OS.type == "windows") {
[16:20:43.679]                 old_names <- names(...future.oldEnvVars)
[16:20:43.679]                 envs <- base::Sys.getenv()
[16:20:43.679]                 names <- names(envs)
[16:20:43.679]                 common <- intersect(names, old_names)
[16:20:43.679]                 added <- setdiff(names, old_names)
[16:20:43.679]                 removed <- setdiff(old_names, names)
[16:20:43.679]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:43.679]                   envs[common]]
[16:20:43.679]                 NAMES <- toupper(changed)
[16:20:43.679]                 args <- list()
[16:20:43.679]                 for (kk in seq_along(NAMES)) {
[16:20:43.679]                   name <- changed[[kk]]
[16:20:43.679]                   NAME <- NAMES[[kk]]
[16:20:43.679]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.679]                     next
[16:20:43.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.679]                 }
[16:20:43.679]                 NAMES <- toupper(added)
[16:20:43.679]                 for (kk in seq_along(NAMES)) {
[16:20:43.679]                   name <- added[[kk]]
[16:20:43.679]                   NAME <- NAMES[[kk]]
[16:20:43.679]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.679]                     next
[16:20:43.679]                   args[[name]] <- ""
[16:20:43.679]                 }
[16:20:43.679]                 NAMES <- toupper(removed)
[16:20:43.679]                 for (kk in seq_along(NAMES)) {
[16:20:43.679]                   name <- removed[[kk]]
[16:20:43.679]                   NAME <- NAMES[[kk]]
[16:20:43.679]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:43.679]                     next
[16:20:43.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:43.679]                 }
[16:20:43.679]                 if (length(args) > 0) 
[16:20:43.679]                   base::do.call(base::Sys.setenv, args = args)
[16:20:43.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:43.679]             }
[16:20:43.679]             else {
[16:20:43.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:43.679]             }
[16:20:43.679]             {
[16:20:43.679]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:43.679]                   0L) {
[16:20:43.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:43.679]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:43.679]                   base::options(opts)
[16:20:43.679]                 }
[16:20:43.679]                 {
[16:20:43.679]                   {
[16:20:43.679]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:43.679]                     NULL
[16:20:43.679]                   }
[16:20:43.679]                   options(future.plan = NULL)
[16:20:43.679]                   if (is.na(NA_character_)) 
[16:20:43.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:43.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:43.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:43.679]                     .init = FALSE)
[16:20:43.679]                 }
[16:20:43.679]             }
[16:20:43.679]         }
[16:20:43.679]     })
[16:20:43.679]     if (TRUE) {
[16:20:43.679]         base::sink(type = "output", split = FALSE)
[16:20:43.679]         if (TRUE) {
[16:20:43.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:43.679]         }
[16:20:43.679]         else {
[16:20:43.679]             ...future.result["stdout"] <- base::list(NULL)
[16:20:43.679]         }
[16:20:43.679]         base::close(...future.stdout)
[16:20:43.679]         ...future.stdout <- NULL
[16:20:43.679]     }
[16:20:43.679]     ...future.result$conditions <- ...future.conditions
[16:20:43.679]     ...future.result$finished <- base::Sys.time()
[16:20:43.679]     ...future.result
[16:20:43.679] }
[16:20:43.682] requestCore(): workers = 2
[16:20:43.682] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:43.693] result() for MulticoreFuture ...
[16:20:43.695] result() for MulticoreFuture ...
[16:20:43.695] result() for MulticoreFuture ... done
[16:20:43.695] result() for MulticoreFuture ... done
[16:20:43.695] result() for MulticoreFuture ...
[16:20:43.695] result() for MulticoreFuture ... done
[16:20:43.699] MulticoreFuture started
[16:20:43.699] - Launch lazy future ... done
[16:20:43.699] run() for ‘MulticoreFuture’ ... done
[16:20:43.700] plan(): Setting new future strategy stack:
<environment: 0x55ed0c707ff8> 
[16:20:43.700] List of future strategies:
[16:20:43.700] 1. sequential:
[16:20:43.700]    - args: function (..., envir = parent.frame())
[16:20:43.700]    - tweaked: FALSE
[16:20:43.700]    - call: NULL
[16:20:43.701] plan(): nbrOfWorkers() = 1
<environment: 0x55ed0c992bd0> 
[16:20:43.703] plan(): Setting new future strategy stack:
[16:20:43.703] List of future strategies:
[16:20:43.703] 1. multicore:
[16:20:43.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:43.703]    - tweaked: FALSE
[16:20:43.703]    - call: plan(strategy)
[16:20:43.709] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:43.712] resolve() on environment ...
[16:20:43.712]  recursive: 0
[16:20:43.713]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:43.713] signalConditionsASAP(numeric, pos=1) ...
[16:20:43.713] - nx: 4
[16:20:43.713] - relay: TRUE
[16:20:43.714] - stdout: TRUE
[16:20:43.714] - signal: TRUE
[16:20:43.714] - resignal: FALSE
[16:20:43.714] - force: TRUE
[16:20:43.714] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.714] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.714]  - until=2
[16:20:43.715]  - relaying element #2
[16:20:43.715] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.715] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.715] signalConditionsASAP(NULL, pos=1) ... done
[16:20:43.715]  length: 3 (resolved future 1)
[16:20:43.715] Future #2
[16:20:43.716] result() for MulticoreFuture ...
[16:20:43.716] result() for MulticoreFuture ... done
[16:20:43.716] result() for MulticoreFuture ...
[16:20:43.716] result() for MulticoreFuture ... done
[16:20:43.716] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:43.716] - nx: 4
[16:20:43.717] - relay: TRUE
[16:20:43.717] - stdout: TRUE
[16:20:43.717] - signal: TRUE
[16:20:43.717] - resignal: FALSE
[16:20:43.717] - force: TRUE
[16:20:43.717] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:43.717] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:43.718]  - until=2
[16:20:43.718]  - relaying element #2
[16:20:43.718] result() for MulticoreFuture ...
[16:20:43.718] result() for MulticoreFuture ... done
[16:20:43.718] result() for MulticoreFuture ...
[16:20:43.718] result() for MulticoreFuture ... done
[16:20:43.718] result() for MulticoreFuture ...
[16:20:43.719] result() for MulticoreFuture ... done
[16:20:43.719] result() for MulticoreFuture ...
[16:20:43.719] result() for MulticoreFuture ... done
[16:20:43.719] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.719] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.719] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:43.719]  length: 2 (resolved future 2)
[16:20:43.720] Future #3
[16:20:43.720] result() for MulticoreFuture ...
[16:20:43.721] result() for MulticoreFuture ...
[16:20:43.721] result() for MulticoreFuture ... done
[16:20:43.721] result() for MulticoreFuture ... done
[16:20:43.721] result() for MulticoreFuture ...
[16:20:43.721] result() for MulticoreFuture ... done
[16:20:43.721] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:43.722] - nx: 4
[16:20:43.722] - relay: TRUE
[16:20:43.722] - stdout: TRUE
[16:20:43.722] - signal: TRUE
[16:20:43.722] - resignal: FALSE
[16:20:43.722] - force: TRUE
[16:20:43.722] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:43.722] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:43.723]  - until=3
[16:20:43.723]  - relaying element #3
[16:20:43.723] result() for MulticoreFuture ...
[16:20:43.723] result() for MulticoreFuture ... done
[16:20:43.723] result() for MulticoreFuture ...
[16:20:43.723] result() for MulticoreFuture ... done
[16:20:43.723] result() for MulticoreFuture ...
[16:20:43.723] result() for MulticoreFuture ... done
[16:20:43.724] result() for MulticoreFuture ...
[16:20:43.724] result() for MulticoreFuture ... done
[16:20:43.724] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.724] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.724] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:43.724]  length: 1 (resolved future 3)
[16:20:43.725] Future #4
[16:20:43.725] result() for MulticoreFuture ...
[16:20:43.725] result() for MulticoreFuture ...
[16:20:43.725] result() for MulticoreFuture ... done
[16:20:43.726] result() for MulticoreFuture ... done
[16:20:43.726] result() for MulticoreFuture ...
[16:20:43.726] result() for MulticoreFuture ... done
[16:20:43.726] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:43.726] - nx: 4
[16:20:43.726] - relay: TRUE
[16:20:43.726] - stdout: TRUE
[16:20:43.727] - signal: TRUE
[16:20:43.727] - resignal: FALSE
[16:20:43.727] - force: TRUE
[16:20:43.727] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:43.727] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:43.727]  - until=4
[16:20:43.727]  - relaying element #4
[16:20:43.727] result() for MulticoreFuture ...
[16:20:43.727] result() for MulticoreFuture ... done
[16:20:43.728] result() for MulticoreFuture ...
[16:20:43.728] result() for MulticoreFuture ... done
[16:20:43.728] result() for MulticoreFuture ...
[16:20:43.728] result() for MulticoreFuture ... done
[16:20:43.728] result() for MulticoreFuture ...
[16:20:43.728] result() for MulticoreFuture ... done
[16:20:43.728] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.728] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.728] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:43.729]  length: 0 (resolved future 4)
[16:20:43.729] Relaying remaining futures
[16:20:43.729] signalConditionsASAP(NULL, pos=0) ...
[16:20:43.729] - nx: 4
[16:20:43.729] - relay: TRUE
[16:20:43.729] - stdout: TRUE
[16:20:43.729] - signal: TRUE
[16:20:43.729] - resignal: FALSE
[16:20:43.729] - force: TRUE
[16:20:43.729] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.730] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:43.730] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:43.730] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:43.730] signalConditionsASAP(NULL, pos=0) ... done
[16:20:43.730] resolve() on environment ... DONE
[16:20:43.730] result() for MulticoreFuture ...
[16:20:43.730] result() for MulticoreFuture ... done
[16:20:43.730] result() for MulticoreFuture ...
[16:20:43.731] result() for MulticoreFuture ... done
[16:20:43.731] result() for MulticoreFuture ...
[16:20:43.731] result() for MulticoreFuture ... done
[16:20:43.731] result() for MulticoreFuture ...
[16:20:43.731] result() for MulticoreFuture ... done
[16:20:43.731] result() for MulticoreFuture ...
[16:20:43.731] result() for MulticoreFuture ... done
[16:20:43.731] result() for MulticoreFuture ...
[16:20:43.731] result() for MulticoreFuture ... done
<environment: 0x55ed0cab0748> 
Type of future: multisession
[16:20:43.732] plan(): Setting new future strategy stack:
[16:20:43.732] List of future strategies:
[16:20:43.732] 1. multisession:
[16:20:43.732]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:43.732]    - tweaked: FALSE
[16:20:43.732]    - call: plan(strategy)
[16:20:43.733] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:20:43.733] multisession:
[16:20:43.733] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:43.733] - tweaked: FALSE
[16:20:43.733] - call: plan(strategy)
[16:20:43.737] getGlobalsAndPackages() ...
[16:20:43.738] Not searching for globals
[16:20:43.738] - globals: [0] <none>
[16:20:43.738] getGlobalsAndPackages() ... DONE
[16:20:43.738] [local output] makeClusterPSOCK() ...
[16:20:43.742] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:20:43.743] [local output] Base port: 11680
[16:20:43.743] [local output] Getting setup options for 2 cluster nodes ...
[16:20:43.743] [local output]  - Node 1 of 2 ...
[16:20:43.744] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:43.744] [local output] Rscript port: 11680

[16:20:43.745] [local output]  - Node 2 of 2 ...
[16:20:43.745] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:43.746] [local output] Rscript port: 11680

[16:20:43.746] [local output] Getting setup options for 2 cluster nodes ... done
[16:20:43.746] [local output]  - Parallel setup requested for some PSOCK nodes
[16:20:43.746] [local output] Setting up PSOCK nodes in parallel
[16:20:43.746] List of 36
[16:20:43.746]  $ worker          : chr "localhost"
[16:20:43.746]   ..- attr(*, "localhost")= logi TRUE
[16:20:43.746]  $ master          : chr "localhost"
[16:20:43.746]  $ port            : int 11680
[16:20:43.746]  $ connectTimeout  : num 120
[16:20:43.746]  $ timeout         : num 2592000
[16:20:43.746]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:20:43.746]  $ homogeneous     : logi TRUE
[16:20:43.746]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:20:43.746]  $ rscript_envs    : NULL
[16:20:43.746]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:43.746]  $ rscript_startup : NULL
[16:20:43.746]  $ rscript_sh      : chr "sh"
[16:20:43.746]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:43.746]  $ methods         : logi TRUE
[16:20:43.746]  $ socketOptions   : chr "no-delay"
[16:20:43.746]  $ useXDR          : logi FALSE
[16:20:43.746]  $ outfile         : chr "/dev/null"
[16:20:43.746]  $ renice          : int NA
[16:20:43.746]  $ rshcmd          : NULL
[16:20:43.746]  $ user            : chr(0) 
[16:20:43.746]  $ revtunnel       : logi FALSE
[16:20:43.746]  $ rshlogfile      : NULL
[16:20:43.746]  $ rshopts         : chr(0) 
[16:20:43.746]  $ rank            : int 1
[16:20:43.746]  $ manual          : logi FALSE
[16:20:43.746]  $ dryrun          : logi FALSE
[16:20:43.746]  $ quiet           : logi FALSE
[16:20:43.746]  $ setup_strategy  : chr "parallel"
[16:20:43.746]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:43.746]  $ pidfile         : chr "/tmp/RtmpZGO0ru/worker.rank=1.parallelly.parent=81506.13e62102844e7.pid"
[16:20:43.746]  $ rshcmd_label    : NULL
[16:20:43.746]  $ rsh_call        : NULL
[16:20:43.746]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:43.746]  $ localMachine    : logi TRUE
[16:20:43.746]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:20:43.746]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:20:43.746]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:20:43.746]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:20:43.746]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:20:43.746]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:20:43.746]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:20:43.746]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:20:43.746]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:20:43.746]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:20:43.746]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:20:43.746]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:20:43.746]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:20:43.746]  $ arguments       :List of 28
[16:20:43.746]   ..$ worker          : chr "localhost"
[16:20:43.746]   ..$ master          : NULL
[16:20:43.746]   ..$ port            : int 11680
[16:20:43.746]   ..$ connectTimeout  : num 120
[16:20:43.746]   ..$ timeout         : num 2592000
[16:20:43.746]   ..$ rscript         : NULL
[16:20:43.746]   ..$ homogeneous     : NULL
[16:20:43.746]   ..$ rscript_args    : NULL
[16:20:43.746]   ..$ rscript_envs    : NULL
[16:20:43.746]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:43.746]   ..$ rscript_startup : NULL
[16:20:43.746]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:20:43.746]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:43.746]   ..$ methods         : logi TRUE
[16:20:43.746]   ..$ socketOptions   : chr "no-delay"
[16:20:43.746]   ..$ useXDR          : logi FALSE
[16:20:43.746]   ..$ outfile         : chr "/dev/null"
[16:20:43.746]   ..$ renice          : int NA
[16:20:43.746]   ..$ rshcmd          : NULL
[16:20:43.746]   ..$ user            : NULL
[16:20:43.746]   ..$ revtunnel       : logi NA
[16:20:43.746]   ..$ rshlogfile      : NULL
[16:20:43.746]   ..$ rshopts         : NULL
[16:20:43.746]   ..$ rank            : int 1
[16:20:43.746]   ..$ manual          : logi FALSE
[16:20:43.746]   ..$ dryrun          : logi FALSE
[16:20:43.746]   ..$ quiet           : logi FALSE
[16:20:43.746]   ..$ setup_strategy  : chr "parallel"
[16:20:43.746]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:20:43.770] [local output] System call to launch all workers:
[16:20:43.770] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZGO0ru/worker.rank=1.parallelly.parent=81506.13e62102844e7.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11680 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:20:43.770] [local output] Starting PSOCK main server
[16:20:43.772] [local output] Workers launched
[16:20:43.772] [local output] Waiting for workers to connect back
[16:20:43.772]  - [local output] 0 workers out of 2 ready
[16:20:44.026]  - [local output] 0 workers out of 2 ready
[16:20:44.027]  - [local output] 1 workers out of 2 ready
[16:20:44.027]  - [local output] 2 workers out of 2 ready
[16:20:44.028] [local output] Launching of workers completed
[16:20:44.028] [local output] Collecting session information from workers
[16:20:44.028] [local output]  - Worker #1 of 2
[16:20:44.029] [local output]  - Worker #2 of 2
[16:20:44.029] [local output] makeClusterPSOCK() ... done
[16:20:44.041] Packages needed by the future expression (n = 0): <none>
[16:20:44.041] Packages needed by future strategies (n = 0): <none>
[16:20:44.041] {
[16:20:44.041]     {
[16:20:44.041]         {
[16:20:44.041]             ...future.startTime <- base::Sys.time()
[16:20:44.041]             {
[16:20:44.041]                 {
[16:20:44.041]                   {
[16:20:44.041]                     {
[16:20:44.041]                       base::local({
[16:20:44.041]                         has_future <- base::requireNamespace("future", 
[16:20:44.041]                           quietly = TRUE)
[16:20:44.041]                         if (has_future) {
[16:20:44.041]                           ns <- base::getNamespace("future")
[16:20:44.041]                           version <- ns[[".package"]][["version"]]
[16:20:44.041]                           if (is.null(version)) 
[16:20:44.041]                             version <- utils::packageVersion("future")
[16:20:44.041]                         }
[16:20:44.041]                         else {
[16:20:44.041]                           version <- NULL
[16:20:44.041]                         }
[16:20:44.041]                         if (!has_future || version < "1.8.0") {
[16:20:44.041]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.041]                             "", base::R.version$version.string), 
[16:20:44.041]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.041]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.041]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.041]                               "release", "version")], collapse = " "), 
[16:20:44.041]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.041]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.041]                             info)
[16:20:44.041]                           info <- base::paste(info, collapse = "; ")
[16:20:44.041]                           if (!has_future) {
[16:20:44.041]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.041]                               info)
[16:20:44.041]                           }
[16:20:44.041]                           else {
[16:20:44.041]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.041]                               info, version)
[16:20:44.041]                           }
[16:20:44.041]                           base::stop(msg)
[16:20:44.041]                         }
[16:20:44.041]                       })
[16:20:44.041]                     }
[16:20:44.041]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.041]                     base::options(mc.cores = 1L)
[16:20:44.041]                   }
[16:20:44.041]                   ...future.strategy.old <- future::plan("list")
[16:20:44.041]                   options(future.plan = NULL)
[16:20:44.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.041]                 }
[16:20:44.041]                 ...future.workdir <- getwd()
[16:20:44.041]             }
[16:20:44.041]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.041]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.041]         }
[16:20:44.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.041]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.041]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.041]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.041]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.041]             base::names(...future.oldOptions))
[16:20:44.041]     }
[16:20:44.041]     if (FALSE) {
[16:20:44.041]     }
[16:20:44.041]     else {
[16:20:44.041]         if (TRUE) {
[16:20:44.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.041]                 open = "w")
[16:20:44.041]         }
[16:20:44.041]         else {
[16:20:44.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.041]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.041]         }
[16:20:44.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.041]             base::sink(type = "output", split = FALSE)
[16:20:44.041]             base::close(...future.stdout)
[16:20:44.041]         }, add = TRUE)
[16:20:44.041]     }
[16:20:44.041]     ...future.frame <- base::sys.nframe()
[16:20:44.041]     ...future.conditions <- base::list()
[16:20:44.041]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.041]     if (FALSE) {
[16:20:44.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.041]     }
[16:20:44.041]     ...future.result <- base::tryCatch({
[16:20:44.041]         base::withCallingHandlers({
[16:20:44.041]             ...future.value <- base::withVisible(base::local({
[16:20:44.041]                 ...future.makeSendCondition <- base::local({
[16:20:44.041]                   sendCondition <- NULL
[16:20:44.041]                   function(frame = 1L) {
[16:20:44.041]                     if (is.function(sendCondition)) 
[16:20:44.041]                       return(sendCondition)
[16:20:44.041]                     ns <- getNamespace("parallel")
[16:20:44.041]                     if (exists("sendData", mode = "function", 
[16:20:44.041]                       envir = ns)) {
[16:20:44.041]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.041]                         envir = ns)
[16:20:44.041]                       envir <- sys.frame(frame)
[16:20:44.041]                       master <- NULL
[16:20:44.041]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.041]                         !identical(envir, emptyenv())) {
[16:20:44.041]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.041]                           inherits = FALSE)) {
[16:20:44.041]                           master <- get("master", mode = "list", 
[16:20:44.041]                             envir = envir, inherits = FALSE)
[16:20:44.041]                           if (inherits(master, c("SOCKnode", 
[16:20:44.041]                             "SOCK0node"))) {
[16:20:44.041]                             sendCondition <<- function(cond) {
[16:20:44.041]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.041]                                 success = TRUE)
[16:20:44.041]                               parallel_sendData(master, data)
[16:20:44.041]                             }
[16:20:44.041]                             return(sendCondition)
[16:20:44.041]                           }
[16:20:44.041]                         }
[16:20:44.041]                         frame <- frame + 1L
[16:20:44.041]                         envir <- sys.frame(frame)
[16:20:44.041]                       }
[16:20:44.041]                     }
[16:20:44.041]                     sendCondition <<- function(cond) NULL
[16:20:44.041]                   }
[16:20:44.041]                 })
[16:20:44.041]                 withCallingHandlers({
[16:20:44.041]                   NA
[16:20:44.041]                 }, immediateCondition = function(cond) {
[16:20:44.041]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.041]                   sendCondition(cond)
[16:20:44.041]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.041]                   {
[16:20:44.041]                     inherits <- base::inherits
[16:20:44.041]                     invokeRestart <- base::invokeRestart
[16:20:44.041]                     is.null <- base::is.null
[16:20:44.041]                     muffled <- FALSE
[16:20:44.041]                     if (inherits(cond, "message")) {
[16:20:44.041]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.041]                       if (muffled) 
[16:20:44.041]                         invokeRestart("muffleMessage")
[16:20:44.041]                     }
[16:20:44.041]                     else if (inherits(cond, "warning")) {
[16:20:44.041]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.041]                       if (muffled) 
[16:20:44.041]                         invokeRestart("muffleWarning")
[16:20:44.041]                     }
[16:20:44.041]                     else if (inherits(cond, "condition")) {
[16:20:44.041]                       if (!is.null(pattern)) {
[16:20:44.041]                         computeRestarts <- base::computeRestarts
[16:20:44.041]                         grepl <- base::grepl
[16:20:44.041]                         restarts <- computeRestarts(cond)
[16:20:44.041]                         for (restart in restarts) {
[16:20:44.041]                           name <- restart$name
[16:20:44.041]                           if (is.null(name)) 
[16:20:44.041]                             next
[16:20:44.041]                           if (!grepl(pattern, name)) 
[16:20:44.041]                             next
[16:20:44.041]                           invokeRestart(restart)
[16:20:44.041]                           muffled <- TRUE
[16:20:44.041]                           break
[16:20:44.041]                         }
[16:20:44.041]                       }
[16:20:44.041]                     }
[16:20:44.041]                     invisible(muffled)
[16:20:44.041]                   }
[16:20:44.041]                   muffleCondition(cond)
[16:20:44.041]                 })
[16:20:44.041]             }))
[16:20:44.041]             future::FutureResult(value = ...future.value$value, 
[16:20:44.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.041]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.041]                     ...future.globalenv.names))
[16:20:44.041]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.041]         }, condition = base::local({
[16:20:44.041]             c <- base::c
[16:20:44.041]             inherits <- base::inherits
[16:20:44.041]             invokeRestart <- base::invokeRestart
[16:20:44.041]             length <- base::length
[16:20:44.041]             list <- base::list
[16:20:44.041]             seq.int <- base::seq.int
[16:20:44.041]             signalCondition <- base::signalCondition
[16:20:44.041]             sys.calls <- base::sys.calls
[16:20:44.041]             `[[` <- base::`[[`
[16:20:44.041]             `+` <- base::`+`
[16:20:44.041]             `<<-` <- base::`<<-`
[16:20:44.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.041]                   3L)]
[16:20:44.041]             }
[16:20:44.041]             function(cond) {
[16:20:44.041]                 is_error <- inherits(cond, "error")
[16:20:44.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.041]                   NULL)
[16:20:44.041]                 if (is_error) {
[16:20:44.041]                   sessionInformation <- function() {
[16:20:44.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.041]                       search = base::search(), system = base::Sys.info())
[16:20:44.041]                   }
[16:20:44.041]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.041]                     cond$call), session = sessionInformation(), 
[16:20:44.041]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.041]                   signalCondition(cond)
[16:20:44.041]                 }
[16:20:44.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.041]                 "immediateCondition"))) {
[16:20:44.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.041]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.041]                   if (TRUE && !signal) {
[16:20:44.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.041]                     {
[16:20:44.041]                       inherits <- base::inherits
[16:20:44.041]                       invokeRestart <- base::invokeRestart
[16:20:44.041]                       is.null <- base::is.null
[16:20:44.041]                       muffled <- FALSE
[16:20:44.041]                       if (inherits(cond, "message")) {
[16:20:44.041]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.041]                         if (muffled) 
[16:20:44.041]                           invokeRestart("muffleMessage")
[16:20:44.041]                       }
[16:20:44.041]                       else if (inherits(cond, "warning")) {
[16:20:44.041]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.041]                         if (muffled) 
[16:20:44.041]                           invokeRestart("muffleWarning")
[16:20:44.041]                       }
[16:20:44.041]                       else if (inherits(cond, "condition")) {
[16:20:44.041]                         if (!is.null(pattern)) {
[16:20:44.041]                           computeRestarts <- base::computeRestarts
[16:20:44.041]                           grepl <- base::grepl
[16:20:44.041]                           restarts <- computeRestarts(cond)
[16:20:44.041]                           for (restart in restarts) {
[16:20:44.041]                             name <- restart$name
[16:20:44.041]                             if (is.null(name)) 
[16:20:44.041]                               next
[16:20:44.041]                             if (!grepl(pattern, name)) 
[16:20:44.041]                               next
[16:20:44.041]                             invokeRestart(restart)
[16:20:44.041]                             muffled <- TRUE
[16:20:44.041]                             break
[16:20:44.041]                           }
[16:20:44.041]                         }
[16:20:44.041]                       }
[16:20:44.041]                       invisible(muffled)
[16:20:44.041]                     }
[16:20:44.041]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.041]                   }
[16:20:44.041]                 }
[16:20:44.041]                 else {
[16:20:44.041]                   if (TRUE) {
[16:20:44.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.041]                     {
[16:20:44.041]                       inherits <- base::inherits
[16:20:44.041]                       invokeRestart <- base::invokeRestart
[16:20:44.041]                       is.null <- base::is.null
[16:20:44.041]                       muffled <- FALSE
[16:20:44.041]                       if (inherits(cond, "message")) {
[16:20:44.041]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.041]                         if (muffled) 
[16:20:44.041]                           invokeRestart("muffleMessage")
[16:20:44.041]                       }
[16:20:44.041]                       else if (inherits(cond, "warning")) {
[16:20:44.041]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.041]                         if (muffled) 
[16:20:44.041]                           invokeRestart("muffleWarning")
[16:20:44.041]                       }
[16:20:44.041]                       else if (inherits(cond, "condition")) {
[16:20:44.041]                         if (!is.null(pattern)) {
[16:20:44.041]                           computeRestarts <- base::computeRestarts
[16:20:44.041]                           grepl <- base::grepl
[16:20:44.041]                           restarts <- computeRestarts(cond)
[16:20:44.041]                           for (restart in restarts) {
[16:20:44.041]                             name <- restart$name
[16:20:44.041]                             if (is.null(name)) 
[16:20:44.041]                               next
[16:20:44.041]                             if (!grepl(pattern, name)) 
[16:20:44.041]                               next
[16:20:44.041]                             invokeRestart(restart)
[16:20:44.041]                             muffled <- TRUE
[16:20:44.041]                             break
[16:20:44.041]                           }
[16:20:44.041]                         }
[16:20:44.041]                       }
[16:20:44.041]                       invisible(muffled)
[16:20:44.041]                     }
[16:20:44.041]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.041]                   }
[16:20:44.041]                 }
[16:20:44.041]             }
[16:20:44.041]         }))
[16:20:44.041]     }, error = function(ex) {
[16:20:44.041]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.041]                 ...future.rng), started = ...future.startTime, 
[16:20:44.041]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.041]             version = "1.8"), class = "FutureResult")
[16:20:44.041]     }, finally = {
[16:20:44.041]         if (!identical(...future.workdir, getwd())) 
[16:20:44.041]             setwd(...future.workdir)
[16:20:44.041]         {
[16:20:44.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.041]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.041]             }
[16:20:44.041]             base::options(...future.oldOptions)
[16:20:44.041]             if (.Platform$OS.type == "windows") {
[16:20:44.041]                 old_names <- names(...future.oldEnvVars)
[16:20:44.041]                 envs <- base::Sys.getenv()
[16:20:44.041]                 names <- names(envs)
[16:20:44.041]                 common <- intersect(names, old_names)
[16:20:44.041]                 added <- setdiff(names, old_names)
[16:20:44.041]                 removed <- setdiff(old_names, names)
[16:20:44.041]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.041]                   envs[common]]
[16:20:44.041]                 NAMES <- toupper(changed)
[16:20:44.041]                 args <- list()
[16:20:44.041]                 for (kk in seq_along(NAMES)) {
[16:20:44.041]                   name <- changed[[kk]]
[16:20:44.041]                   NAME <- NAMES[[kk]]
[16:20:44.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.041]                     next
[16:20:44.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.041]                 }
[16:20:44.041]                 NAMES <- toupper(added)
[16:20:44.041]                 for (kk in seq_along(NAMES)) {
[16:20:44.041]                   name <- added[[kk]]
[16:20:44.041]                   NAME <- NAMES[[kk]]
[16:20:44.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.041]                     next
[16:20:44.041]                   args[[name]] <- ""
[16:20:44.041]                 }
[16:20:44.041]                 NAMES <- toupper(removed)
[16:20:44.041]                 for (kk in seq_along(NAMES)) {
[16:20:44.041]                   name <- removed[[kk]]
[16:20:44.041]                   NAME <- NAMES[[kk]]
[16:20:44.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.041]                     next
[16:20:44.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.041]                 }
[16:20:44.041]                 if (length(args) > 0) 
[16:20:44.041]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.041]             }
[16:20:44.041]             else {
[16:20:44.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.041]             }
[16:20:44.041]             {
[16:20:44.041]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.041]                   0L) {
[16:20:44.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.041]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.041]                   base::options(opts)
[16:20:44.041]                 }
[16:20:44.041]                 {
[16:20:44.041]                   {
[16:20:44.041]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.041]                     NULL
[16:20:44.041]                   }
[16:20:44.041]                   options(future.plan = NULL)
[16:20:44.041]                   if (is.na(NA_character_)) 
[16:20:44.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.041]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.041]                     .init = FALSE)
[16:20:44.041]                 }
[16:20:44.041]             }
[16:20:44.041]         }
[16:20:44.041]     })
[16:20:44.041]     if (TRUE) {
[16:20:44.041]         base::sink(type = "output", split = FALSE)
[16:20:44.041]         if (TRUE) {
[16:20:44.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.041]         }
[16:20:44.041]         else {
[16:20:44.041]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.041]         }
[16:20:44.041]         base::close(...future.stdout)
[16:20:44.041]         ...future.stdout <- NULL
[16:20:44.041]     }
[16:20:44.041]     ...future.result$conditions <- ...future.conditions
[16:20:44.041]     ...future.result$finished <- base::Sys.time()
[16:20:44.041]     ...future.result
[16:20:44.041] }
[16:20:44.095] MultisessionFuture started
[16:20:44.095] result() for ClusterFuture ...
[16:20:44.095] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.095] - Validating connection of MultisessionFuture
[16:20:44.128] - received message: FutureResult
[16:20:44.128] - Received FutureResult
[16:20:44.129] - Erased future from FutureRegistry
[16:20:44.129] result() for ClusterFuture ...
[16:20:44.129] - result already collected: FutureResult
[16:20:44.129] result() for ClusterFuture ... done
[16:20:44.129] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.129] result() for ClusterFuture ... done
[16:20:44.129] result() for ClusterFuture ...
[16:20:44.129] - result already collected: FutureResult
[16:20:44.130] result() for ClusterFuture ... done
[16:20:44.130] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:20:44.134] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:20:44.134] getGlobalsAndPackages() ...
[16:20:44.134] Searching for globals...
[16:20:44.135] 
[16:20:44.135] Searching for globals ... DONE
[16:20:44.135] - globals: [0] <none>
[16:20:44.135] getGlobalsAndPackages() ... DONE
[16:20:44.135] run() for ‘Future’ ...
[16:20:44.136] - state: ‘created’
[16:20:44.136] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.150] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.150]   - Field: ‘node’
[16:20:44.150]   - Field: ‘label’
[16:20:44.150]   - Field: ‘local’
[16:20:44.150]   - Field: ‘owner’
[16:20:44.151]   - Field: ‘envir’
[16:20:44.151]   - Field: ‘workers’
[16:20:44.151]   - Field: ‘packages’
[16:20:44.151]   - Field: ‘gc’
[16:20:44.151]   - Field: ‘conditions’
[16:20:44.151]   - Field: ‘persistent’
[16:20:44.151]   - Field: ‘expr’
[16:20:44.151]   - Field: ‘uuid’
[16:20:44.151]   - Field: ‘seed’
[16:20:44.152]   - Field: ‘version’
[16:20:44.152]   - Field: ‘result’
[16:20:44.152]   - Field: ‘asynchronous’
[16:20:44.152]   - Field: ‘calls’
[16:20:44.152]   - Field: ‘globals’
[16:20:44.152]   - Field: ‘stdout’
[16:20:44.152]   - Field: ‘earlySignal’
[16:20:44.152]   - Field: ‘lazy’
[16:20:44.152]   - Field: ‘state’
[16:20:44.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.153] - Launch lazy future ...
[16:20:44.153] Packages needed by the future expression (n = 0): <none>
[16:20:44.153] Packages needed by future strategies (n = 0): <none>
[16:20:44.154] {
[16:20:44.154]     {
[16:20:44.154]         {
[16:20:44.154]             ...future.startTime <- base::Sys.time()
[16:20:44.154]             {
[16:20:44.154]                 {
[16:20:44.154]                   {
[16:20:44.154]                     {
[16:20:44.154]                       base::local({
[16:20:44.154]                         has_future <- base::requireNamespace("future", 
[16:20:44.154]                           quietly = TRUE)
[16:20:44.154]                         if (has_future) {
[16:20:44.154]                           ns <- base::getNamespace("future")
[16:20:44.154]                           version <- ns[[".package"]][["version"]]
[16:20:44.154]                           if (is.null(version)) 
[16:20:44.154]                             version <- utils::packageVersion("future")
[16:20:44.154]                         }
[16:20:44.154]                         else {
[16:20:44.154]                           version <- NULL
[16:20:44.154]                         }
[16:20:44.154]                         if (!has_future || version < "1.8.0") {
[16:20:44.154]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.154]                             "", base::R.version$version.string), 
[16:20:44.154]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.154]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.154]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.154]                               "release", "version")], collapse = " "), 
[16:20:44.154]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.154]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.154]                             info)
[16:20:44.154]                           info <- base::paste(info, collapse = "; ")
[16:20:44.154]                           if (!has_future) {
[16:20:44.154]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.154]                               info)
[16:20:44.154]                           }
[16:20:44.154]                           else {
[16:20:44.154]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.154]                               info, version)
[16:20:44.154]                           }
[16:20:44.154]                           base::stop(msg)
[16:20:44.154]                         }
[16:20:44.154]                       })
[16:20:44.154]                     }
[16:20:44.154]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.154]                     base::options(mc.cores = 1L)
[16:20:44.154]                   }
[16:20:44.154]                   ...future.strategy.old <- future::plan("list")
[16:20:44.154]                   options(future.plan = NULL)
[16:20:44.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.154]                 }
[16:20:44.154]                 ...future.workdir <- getwd()
[16:20:44.154]             }
[16:20:44.154]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.154]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.154]         }
[16:20:44.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.154]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.154]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.154]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.154]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.154]             base::names(...future.oldOptions))
[16:20:44.154]     }
[16:20:44.154]     if (FALSE) {
[16:20:44.154]     }
[16:20:44.154]     else {
[16:20:44.154]         if (TRUE) {
[16:20:44.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.154]                 open = "w")
[16:20:44.154]         }
[16:20:44.154]         else {
[16:20:44.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.154]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.154]         }
[16:20:44.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.154]             base::sink(type = "output", split = FALSE)
[16:20:44.154]             base::close(...future.stdout)
[16:20:44.154]         }, add = TRUE)
[16:20:44.154]     }
[16:20:44.154]     ...future.frame <- base::sys.nframe()
[16:20:44.154]     ...future.conditions <- base::list()
[16:20:44.154]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.154]     if (FALSE) {
[16:20:44.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.154]     }
[16:20:44.154]     ...future.result <- base::tryCatch({
[16:20:44.154]         base::withCallingHandlers({
[16:20:44.154]             ...future.value <- base::withVisible(base::local({
[16:20:44.154]                 ...future.makeSendCondition <- base::local({
[16:20:44.154]                   sendCondition <- NULL
[16:20:44.154]                   function(frame = 1L) {
[16:20:44.154]                     if (is.function(sendCondition)) 
[16:20:44.154]                       return(sendCondition)
[16:20:44.154]                     ns <- getNamespace("parallel")
[16:20:44.154]                     if (exists("sendData", mode = "function", 
[16:20:44.154]                       envir = ns)) {
[16:20:44.154]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.154]                         envir = ns)
[16:20:44.154]                       envir <- sys.frame(frame)
[16:20:44.154]                       master <- NULL
[16:20:44.154]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.154]                         !identical(envir, emptyenv())) {
[16:20:44.154]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.154]                           inherits = FALSE)) {
[16:20:44.154]                           master <- get("master", mode = "list", 
[16:20:44.154]                             envir = envir, inherits = FALSE)
[16:20:44.154]                           if (inherits(master, c("SOCKnode", 
[16:20:44.154]                             "SOCK0node"))) {
[16:20:44.154]                             sendCondition <<- function(cond) {
[16:20:44.154]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.154]                                 success = TRUE)
[16:20:44.154]                               parallel_sendData(master, data)
[16:20:44.154]                             }
[16:20:44.154]                             return(sendCondition)
[16:20:44.154]                           }
[16:20:44.154]                         }
[16:20:44.154]                         frame <- frame + 1L
[16:20:44.154]                         envir <- sys.frame(frame)
[16:20:44.154]                       }
[16:20:44.154]                     }
[16:20:44.154]                     sendCondition <<- function(cond) NULL
[16:20:44.154]                   }
[16:20:44.154]                 })
[16:20:44.154]                 withCallingHandlers({
[16:20:44.154]                   2
[16:20:44.154]                 }, immediateCondition = function(cond) {
[16:20:44.154]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.154]                   sendCondition(cond)
[16:20:44.154]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.154]                   {
[16:20:44.154]                     inherits <- base::inherits
[16:20:44.154]                     invokeRestart <- base::invokeRestart
[16:20:44.154]                     is.null <- base::is.null
[16:20:44.154]                     muffled <- FALSE
[16:20:44.154]                     if (inherits(cond, "message")) {
[16:20:44.154]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.154]                       if (muffled) 
[16:20:44.154]                         invokeRestart("muffleMessage")
[16:20:44.154]                     }
[16:20:44.154]                     else if (inherits(cond, "warning")) {
[16:20:44.154]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.154]                       if (muffled) 
[16:20:44.154]                         invokeRestart("muffleWarning")
[16:20:44.154]                     }
[16:20:44.154]                     else if (inherits(cond, "condition")) {
[16:20:44.154]                       if (!is.null(pattern)) {
[16:20:44.154]                         computeRestarts <- base::computeRestarts
[16:20:44.154]                         grepl <- base::grepl
[16:20:44.154]                         restarts <- computeRestarts(cond)
[16:20:44.154]                         for (restart in restarts) {
[16:20:44.154]                           name <- restart$name
[16:20:44.154]                           if (is.null(name)) 
[16:20:44.154]                             next
[16:20:44.154]                           if (!grepl(pattern, name)) 
[16:20:44.154]                             next
[16:20:44.154]                           invokeRestart(restart)
[16:20:44.154]                           muffled <- TRUE
[16:20:44.154]                           break
[16:20:44.154]                         }
[16:20:44.154]                       }
[16:20:44.154]                     }
[16:20:44.154]                     invisible(muffled)
[16:20:44.154]                   }
[16:20:44.154]                   muffleCondition(cond)
[16:20:44.154]                 })
[16:20:44.154]             }))
[16:20:44.154]             future::FutureResult(value = ...future.value$value, 
[16:20:44.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.154]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.154]                     ...future.globalenv.names))
[16:20:44.154]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.154]         }, condition = base::local({
[16:20:44.154]             c <- base::c
[16:20:44.154]             inherits <- base::inherits
[16:20:44.154]             invokeRestart <- base::invokeRestart
[16:20:44.154]             length <- base::length
[16:20:44.154]             list <- base::list
[16:20:44.154]             seq.int <- base::seq.int
[16:20:44.154]             signalCondition <- base::signalCondition
[16:20:44.154]             sys.calls <- base::sys.calls
[16:20:44.154]             `[[` <- base::`[[`
[16:20:44.154]             `+` <- base::`+`
[16:20:44.154]             `<<-` <- base::`<<-`
[16:20:44.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.154]                   3L)]
[16:20:44.154]             }
[16:20:44.154]             function(cond) {
[16:20:44.154]                 is_error <- inherits(cond, "error")
[16:20:44.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.154]                   NULL)
[16:20:44.154]                 if (is_error) {
[16:20:44.154]                   sessionInformation <- function() {
[16:20:44.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.154]                       search = base::search(), system = base::Sys.info())
[16:20:44.154]                   }
[16:20:44.154]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.154]                     cond$call), session = sessionInformation(), 
[16:20:44.154]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.154]                   signalCondition(cond)
[16:20:44.154]                 }
[16:20:44.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.154]                 "immediateCondition"))) {
[16:20:44.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.154]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.154]                   if (TRUE && !signal) {
[16:20:44.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.154]                     {
[16:20:44.154]                       inherits <- base::inherits
[16:20:44.154]                       invokeRestart <- base::invokeRestart
[16:20:44.154]                       is.null <- base::is.null
[16:20:44.154]                       muffled <- FALSE
[16:20:44.154]                       if (inherits(cond, "message")) {
[16:20:44.154]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.154]                         if (muffled) 
[16:20:44.154]                           invokeRestart("muffleMessage")
[16:20:44.154]                       }
[16:20:44.154]                       else if (inherits(cond, "warning")) {
[16:20:44.154]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.154]                         if (muffled) 
[16:20:44.154]                           invokeRestart("muffleWarning")
[16:20:44.154]                       }
[16:20:44.154]                       else if (inherits(cond, "condition")) {
[16:20:44.154]                         if (!is.null(pattern)) {
[16:20:44.154]                           computeRestarts <- base::computeRestarts
[16:20:44.154]                           grepl <- base::grepl
[16:20:44.154]                           restarts <- computeRestarts(cond)
[16:20:44.154]                           for (restart in restarts) {
[16:20:44.154]                             name <- restart$name
[16:20:44.154]                             if (is.null(name)) 
[16:20:44.154]                               next
[16:20:44.154]                             if (!grepl(pattern, name)) 
[16:20:44.154]                               next
[16:20:44.154]                             invokeRestart(restart)
[16:20:44.154]                             muffled <- TRUE
[16:20:44.154]                             break
[16:20:44.154]                           }
[16:20:44.154]                         }
[16:20:44.154]                       }
[16:20:44.154]                       invisible(muffled)
[16:20:44.154]                     }
[16:20:44.154]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.154]                   }
[16:20:44.154]                 }
[16:20:44.154]                 else {
[16:20:44.154]                   if (TRUE) {
[16:20:44.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.154]                     {
[16:20:44.154]                       inherits <- base::inherits
[16:20:44.154]                       invokeRestart <- base::invokeRestart
[16:20:44.154]                       is.null <- base::is.null
[16:20:44.154]                       muffled <- FALSE
[16:20:44.154]                       if (inherits(cond, "message")) {
[16:20:44.154]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.154]                         if (muffled) 
[16:20:44.154]                           invokeRestart("muffleMessage")
[16:20:44.154]                       }
[16:20:44.154]                       else if (inherits(cond, "warning")) {
[16:20:44.154]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.154]                         if (muffled) 
[16:20:44.154]                           invokeRestart("muffleWarning")
[16:20:44.154]                       }
[16:20:44.154]                       else if (inherits(cond, "condition")) {
[16:20:44.154]                         if (!is.null(pattern)) {
[16:20:44.154]                           computeRestarts <- base::computeRestarts
[16:20:44.154]                           grepl <- base::grepl
[16:20:44.154]                           restarts <- computeRestarts(cond)
[16:20:44.154]                           for (restart in restarts) {
[16:20:44.154]                             name <- restart$name
[16:20:44.154]                             if (is.null(name)) 
[16:20:44.154]                               next
[16:20:44.154]                             if (!grepl(pattern, name)) 
[16:20:44.154]                               next
[16:20:44.154]                             invokeRestart(restart)
[16:20:44.154]                             muffled <- TRUE
[16:20:44.154]                             break
[16:20:44.154]                           }
[16:20:44.154]                         }
[16:20:44.154]                       }
[16:20:44.154]                       invisible(muffled)
[16:20:44.154]                     }
[16:20:44.154]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.154]                   }
[16:20:44.154]                 }
[16:20:44.154]             }
[16:20:44.154]         }))
[16:20:44.154]     }, error = function(ex) {
[16:20:44.154]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.154]                 ...future.rng), started = ...future.startTime, 
[16:20:44.154]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.154]             version = "1.8"), class = "FutureResult")
[16:20:44.154]     }, finally = {
[16:20:44.154]         if (!identical(...future.workdir, getwd())) 
[16:20:44.154]             setwd(...future.workdir)
[16:20:44.154]         {
[16:20:44.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.154]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.154]             }
[16:20:44.154]             base::options(...future.oldOptions)
[16:20:44.154]             if (.Platform$OS.type == "windows") {
[16:20:44.154]                 old_names <- names(...future.oldEnvVars)
[16:20:44.154]                 envs <- base::Sys.getenv()
[16:20:44.154]                 names <- names(envs)
[16:20:44.154]                 common <- intersect(names, old_names)
[16:20:44.154]                 added <- setdiff(names, old_names)
[16:20:44.154]                 removed <- setdiff(old_names, names)
[16:20:44.154]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.154]                   envs[common]]
[16:20:44.154]                 NAMES <- toupper(changed)
[16:20:44.154]                 args <- list()
[16:20:44.154]                 for (kk in seq_along(NAMES)) {
[16:20:44.154]                   name <- changed[[kk]]
[16:20:44.154]                   NAME <- NAMES[[kk]]
[16:20:44.154]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.154]                     next
[16:20:44.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.154]                 }
[16:20:44.154]                 NAMES <- toupper(added)
[16:20:44.154]                 for (kk in seq_along(NAMES)) {
[16:20:44.154]                   name <- added[[kk]]
[16:20:44.154]                   NAME <- NAMES[[kk]]
[16:20:44.154]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.154]                     next
[16:20:44.154]                   args[[name]] <- ""
[16:20:44.154]                 }
[16:20:44.154]                 NAMES <- toupper(removed)
[16:20:44.154]                 for (kk in seq_along(NAMES)) {
[16:20:44.154]                   name <- removed[[kk]]
[16:20:44.154]                   NAME <- NAMES[[kk]]
[16:20:44.154]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.154]                     next
[16:20:44.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.154]                 }
[16:20:44.154]                 if (length(args) > 0) 
[16:20:44.154]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.154]             }
[16:20:44.154]             else {
[16:20:44.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.154]             }
[16:20:44.154]             {
[16:20:44.154]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.154]                   0L) {
[16:20:44.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.154]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.154]                   base::options(opts)
[16:20:44.154]                 }
[16:20:44.154]                 {
[16:20:44.154]                   {
[16:20:44.154]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.154]                     NULL
[16:20:44.154]                   }
[16:20:44.154]                   options(future.plan = NULL)
[16:20:44.154]                   if (is.na(NA_character_)) 
[16:20:44.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.154]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.154]                     .init = FALSE)
[16:20:44.154]                 }
[16:20:44.154]             }
[16:20:44.154]         }
[16:20:44.154]     })
[16:20:44.154]     if (TRUE) {
[16:20:44.154]         base::sink(type = "output", split = FALSE)
[16:20:44.154]         if (TRUE) {
[16:20:44.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.154]         }
[16:20:44.154]         else {
[16:20:44.154]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.154]         }
[16:20:44.154]         base::close(...future.stdout)
[16:20:44.154]         ...future.stdout <- NULL
[16:20:44.154]     }
[16:20:44.154]     ...future.result$conditions <- ...future.conditions
[16:20:44.154]     ...future.result$finished <- base::Sys.time()
[16:20:44.154]     ...future.result
[16:20:44.154] }
[16:20:44.157] MultisessionFuture started
[16:20:44.157] - Launch lazy future ... done
[16:20:44.157] run() for ‘MultisessionFuture’ ... done
[16:20:44.157] getGlobalsAndPackages() ...
[16:20:44.157] Searching for globals...
[16:20:44.157] 
[16:20:44.158] Searching for globals ... DONE
[16:20:44.158] - globals: [0] <none>
[16:20:44.158] getGlobalsAndPackages() ... DONE
[16:20:44.158] run() for ‘Future’ ...
[16:20:44.158] - state: ‘created’
[16:20:44.158] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.173] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.173]   - Field: ‘node’
[16:20:44.173]   - Field: ‘label’
[16:20:44.173]   - Field: ‘local’
[16:20:44.173]   - Field: ‘owner’
[16:20:44.174]   - Field: ‘envir’
[16:20:44.174]   - Field: ‘workers’
[16:20:44.174]   - Field: ‘packages’
[16:20:44.174]   - Field: ‘gc’
[16:20:44.174]   - Field: ‘conditions’
[16:20:44.174]   - Field: ‘persistent’
[16:20:44.174]   - Field: ‘expr’
[16:20:44.174]   - Field: ‘uuid’
[16:20:44.174]   - Field: ‘seed’
[16:20:44.175]   - Field: ‘version’
[16:20:44.175]   - Field: ‘result’
[16:20:44.175]   - Field: ‘asynchronous’
[16:20:44.175]   - Field: ‘calls’
[16:20:44.175]   - Field: ‘globals’
[16:20:44.175]   - Field: ‘stdout’
[16:20:44.175]   - Field: ‘earlySignal’
[16:20:44.175]   - Field: ‘lazy’
[16:20:44.175]   - Field: ‘state’
[16:20:44.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.176] - Launch lazy future ...
[16:20:44.176] Packages needed by the future expression (n = 0): <none>
[16:20:44.176] Packages needed by future strategies (n = 0): <none>
[16:20:44.177] {
[16:20:44.177]     {
[16:20:44.177]         {
[16:20:44.177]             ...future.startTime <- base::Sys.time()
[16:20:44.177]             {
[16:20:44.177]                 {
[16:20:44.177]                   {
[16:20:44.177]                     {
[16:20:44.177]                       base::local({
[16:20:44.177]                         has_future <- base::requireNamespace("future", 
[16:20:44.177]                           quietly = TRUE)
[16:20:44.177]                         if (has_future) {
[16:20:44.177]                           ns <- base::getNamespace("future")
[16:20:44.177]                           version <- ns[[".package"]][["version"]]
[16:20:44.177]                           if (is.null(version)) 
[16:20:44.177]                             version <- utils::packageVersion("future")
[16:20:44.177]                         }
[16:20:44.177]                         else {
[16:20:44.177]                           version <- NULL
[16:20:44.177]                         }
[16:20:44.177]                         if (!has_future || version < "1.8.0") {
[16:20:44.177]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.177]                             "", base::R.version$version.string), 
[16:20:44.177]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.177]                               "release", "version")], collapse = " "), 
[16:20:44.177]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.177]                             info)
[16:20:44.177]                           info <- base::paste(info, collapse = "; ")
[16:20:44.177]                           if (!has_future) {
[16:20:44.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.177]                               info)
[16:20:44.177]                           }
[16:20:44.177]                           else {
[16:20:44.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.177]                               info, version)
[16:20:44.177]                           }
[16:20:44.177]                           base::stop(msg)
[16:20:44.177]                         }
[16:20:44.177]                       })
[16:20:44.177]                     }
[16:20:44.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.177]                     base::options(mc.cores = 1L)
[16:20:44.177]                   }
[16:20:44.177]                   ...future.strategy.old <- future::plan("list")
[16:20:44.177]                   options(future.plan = NULL)
[16:20:44.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.177]                 }
[16:20:44.177]                 ...future.workdir <- getwd()
[16:20:44.177]             }
[16:20:44.177]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.177]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.177]         }
[16:20:44.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.177]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.177]             base::names(...future.oldOptions))
[16:20:44.177]     }
[16:20:44.177]     if (FALSE) {
[16:20:44.177]     }
[16:20:44.177]     else {
[16:20:44.177]         if (TRUE) {
[16:20:44.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.177]                 open = "w")
[16:20:44.177]         }
[16:20:44.177]         else {
[16:20:44.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.177]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.177]         }
[16:20:44.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.177]             base::sink(type = "output", split = FALSE)
[16:20:44.177]             base::close(...future.stdout)
[16:20:44.177]         }, add = TRUE)
[16:20:44.177]     }
[16:20:44.177]     ...future.frame <- base::sys.nframe()
[16:20:44.177]     ...future.conditions <- base::list()
[16:20:44.177]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.177]     if (FALSE) {
[16:20:44.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.177]     }
[16:20:44.177]     ...future.result <- base::tryCatch({
[16:20:44.177]         base::withCallingHandlers({
[16:20:44.177]             ...future.value <- base::withVisible(base::local({
[16:20:44.177]                 ...future.makeSendCondition <- base::local({
[16:20:44.177]                   sendCondition <- NULL
[16:20:44.177]                   function(frame = 1L) {
[16:20:44.177]                     if (is.function(sendCondition)) 
[16:20:44.177]                       return(sendCondition)
[16:20:44.177]                     ns <- getNamespace("parallel")
[16:20:44.177]                     if (exists("sendData", mode = "function", 
[16:20:44.177]                       envir = ns)) {
[16:20:44.177]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.177]                         envir = ns)
[16:20:44.177]                       envir <- sys.frame(frame)
[16:20:44.177]                       master <- NULL
[16:20:44.177]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.177]                         !identical(envir, emptyenv())) {
[16:20:44.177]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.177]                           inherits = FALSE)) {
[16:20:44.177]                           master <- get("master", mode = "list", 
[16:20:44.177]                             envir = envir, inherits = FALSE)
[16:20:44.177]                           if (inherits(master, c("SOCKnode", 
[16:20:44.177]                             "SOCK0node"))) {
[16:20:44.177]                             sendCondition <<- function(cond) {
[16:20:44.177]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.177]                                 success = TRUE)
[16:20:44.177]                               parallel_sendData(master, data)
[16:20:44.177]                             }
[16:20:44.177]                             return(sendCondition)
[16:20:44.177]                           }
[16:20:44.177]                         }
[16:20:44.177]                         frame <- frame + 1L
[16:20:44.177]                         envir <- sys.frame(frame)
[16:20:44.177]                       }
[16:20:44.177]                     }
[16:20:44.177]                     sendCondition <<- function(cond) NULL
[16:20:44.177]                   }
[16:20:44.177]                 })
[16:20:44.177]                 withCallingHandlers({
[16:20:44.177]                   NULL
[16:20:44.177]                 }, immediateCondition = function(cond) {
[16:20:44.177]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.177]                   sendCondition(cond)
[16:20:44.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.177]                   {
[16:20:44.177]                     inherits <- base::inherits
[16:20:44.177]                     invokeRestart <- base::invokeRestart
[16:20:44.177]                     is.null <- base::is.null
[16:20:44.177]                     muffled <- FALSE
[16:20:44.177]                     if (inherits(cond, "message")) {
[16:20:44.177]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.177]                       if (muffled) 
[16:20:44.177]                         invokeRestart("muffleMessage")
[16:20:44.177]                     }
[16:20:44.177]                     else if (inherits(cond, "warning")) {
[16:20:44.177]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.177]                       if (muffled) 
[16:20:44.177]                         invokeRestart("muffleWarning")
[16:20:44.177]                     }
[16:20:44.177]                     else if (inherits(cond, "condition")) {
[16:20:44.177]                       if (!is.null(pattern)) {
[16:20:44.177]                         computeRestarts <- base::computeRestarts
[16:20:44.177]                         grepl <- base::grepl
[16:20:44.177]                         restarts <- computeRestarts(cond)
[16:20:44.177]                         for (restart in restarts) {
[16:20:44.177]                           name <- restart$name
[16:20:44.177]                           if (is.null(name)) 
[16:20:44.177]                             next
[16:20:44.177]                           if (!grepl(pattern, name)) 
[16:20:44.177]                             next
[16:20:44.177]                           invokeRestart(restart)
[16:20:44.177]                           muffled <- TRUE
[16:20:44.177]                           break
[16:20:44.177]                         }
[16:20:44.177]                       }
[16:20:44.177]                     }
[16:20:44.177]                     invisible(muffled)
[16:20:44.177]                   }
[16:20:44.177]                   muffleCondition(cond)
[16:20:44.177]                 })
[16:20:44.177]             }))
[16:20:44.177]             future::FutureResult(value = ...future.value$value, 
[16:20:44.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.177]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.177]                     ...future.globalenv.names))
[16:20:44.177]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.177]         }, condition = base::local({
[16:20:44.177]             c <- base::c
[16:20:44.177]             inherits <- base::inherits
[16:20:44.177]             invokeRestart <- base::invokeRestart
[16:20:44.177]             length <- base::length
[16:20:44.177]             list <- base::list
[16:20:44.177]             seq.int <- base::seq.int
[16:20:44.177]             signalCondition <- base::signalCondition
[16:20:44.177]             sys.calls <- base::sys.calls
[16:20:44.177]             `[[` <- base::`[[`
[16:20:44.177]             `+` <- base::`+`
[16:20:44.177]             `<<-` <- base::`<<-`
[16:20:44.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.177]                   3L)]
[16:20:44.177]             }
[16:20:44.177]             function(cond) {
[16:20:44.177]                 is_error <- inherits(cond, "error")
[16:20:44.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.177]                   NULL)
[16:20:44.177]                 if (is_error) {
[16:20:44.177]                   sessionInformation <- function() {
[16:20:44.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.177]                       search = base::search(), system = base::Sys.info())
[16:20:44.177]                   }
[16:20:44.177]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.177]                     cond$call), session = sessionInformation(), 
[16:20:44.177]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.177]                   signalCondition(cond)
[16:20:44.177]                 }
[16:20:44.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.177]                 "immediateCondition"))) {
[16:20:44.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.177]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.177]                   if (TRUE && !signal) {
[16:20:44.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.177]                     {
[16:20:44.177]                       inherits <- base::inherits
[16:20:44.177]                       invokeRestart <- base::invokeRestart
[16:20:44.177]                       is.null <- base::is.null
[16:20:44.177]                       muffled <- FALSE
[16:20:44.177]                       if (inherits(cond, "message")) {
[16:20:44.177]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.177]                         if (muffled) 
[16:20:44.177]                           invokeRestart("muffleMessage")
[16:20:44.177]                       }
[16:20:44.177]                       else if (inherits(cond, "warning")) {
[16:20:44.177]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.177]                         if (muffled) 
[16:20:44.177]                           invokeRestart("muffleWarning")
[16:20:44.177]                       }
[16:20:44.177]                       else if (inherits(cond, "condition")) {
[16:20:44.177]                         if (!is.null(pattern)) {
[16:20:44.177]                           computeRestarts <- base::computeRestarts
[16:20:44.177]                           grepl <- base::grepl
[16:20:44.177]                           restarts <- computeRestarts(cond)
[16:20:44.177]                           for (restart in restarts) {
[16:20:44.177]                             name <- restart$name
[16:20:44.177]                             if (is.null(name)) 
[16:20:44.177]                               next
[16:20:44.177]                             if (!grepl(pattern, name)) 
[16:20:44.177]                               next
[16:20:44.177]                             invokeRestart(restart)
[16:20:44.177]                             muffled <- TRUE
[16:20:44.177]                             break
[16:20:44.177]                           }
[16:20:44.177]                         }
[16:20:44.177]                       }
[16:20:44.177]                       invisible(muffled)
[16:20:44.177]                     }
[16:20:44.177]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.177]                   }
[16:20:44.177]                 }
[16:20:44.177]                 else {
[16:20:44.177]                   if (TRUE) {
[16:20:44.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.177]                     {
[16:20:44.177]                       inherits <- base::inherits
[16:20:44.177]                       invokeRestart <- base::invokeRestart
[16:20:44.177]                       is.null <- base::is.null
[16:20:44.177]                       muffled <- FALSE
[16:20:44.177]                       if (inherits(cond, "message")) {
[16:20:44.177]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.177]                         if (muffled) 
[16:20:44.177]                           invokeRestart("muffleMessage")
[16:20:44.177]                       }
[16:20:44.177]                       else if (inherits(cond, "warning")) {
[16:20:44.177]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.177]                         if (muffled) 
[16:20:44.177]                           invokeRestart("muffleWarning")
[16:20:44.177]                       }
[16:20:44.177]                       else if (inherits(cond, "condition")) {
[16:20:44.177]                         if (!is.null(pattern)) {
[16:20:44.177]                           computeRestarts <- base::computeRestarts
[16:20:44.177]                           grepl <- base::grepl
[16:20:44.177]                           restarts <- computeRestarts(cond)
[16:20:44.177]                           for (restart in restarts) {
[16:20:44.177]                             name <- restart$name
[16:20:44.177]                             if (is.null(name)) 
[16:20:44.177]                               next
[16:20:44.177]                             if (!grepl(pattern, name)) 
[16:20:44.177]                               next
[16:20:44.177]                             invokeRestart(restart)
[16:20:44.177]                             muffled <- TRUE
[16:20:44.177]                             break
[16:20:44.177]                           }
[16:20:44.177]                         }
[16:20:44.177]                       }
[16:20:44.177]                       invisible(muffled)
[16:20:44.177]                     }
[16:20:44.177]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.177]                   }
[16:20:44.177]                 }
[16:20:44.177]             }
[16:20:44.177]         }))
[16:20:44.177]     }, error = function(ex) {
[16:20:44.177]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.177]                 ...future.rng), started = ...future.startTime, 
[16:20:44.177]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.177]             version = "1.8"), class = "FutureResult")
[16:20:44.177]     }, finally = {
[16:20:44.177]         if (!identical(...future.workdir, getwd())) 
[16:20:44.177]             setwd(...future.workdir)
[16:20:44.177]         {
[16:20:44.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.177]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.177]             }
[16:20:44.177]             base::options(...future.oldOptions)
[16:20:44.177]             if (.Platform$OS.type == "windows") {
[16:20:44.177]                 old_names <- names(...future.oldEnvVars)
[16:20:44.177]                 envs <- base::Sys.getenv()
[16:20:44.177]                 names <- names(envs)
[16:20:44.177]                 common <- intersect(names, old_names)
[16:20:44.177]                 added <- setdiff(names, old_names)
[16:20:44.177]                 removed <- setdiff(old_names, names)
[16:20:44.177]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.177]                   envs[common]]
[16:20:44.177]                 NAMES <- toupper(changed)
[16:20:44.177]                 args <- list()
[16:20:44.177]                 for (kk in seq_along(NAMES)) {
[16:20:44.177]                   name <- changed[[kk]]
[16:20:44.177]                   NAME <- NAMES[[kk]]
[16:20:44.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.177]                     next
[16:20:44.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.177]                 }
[16:20:44.177]                 NAMES <- toupper(added)
[16:20:44.177]                 for (kk in seq_along(NAMES)) {
[16:20:44.177]                   name <- added[[kk]]
[16:20:44.177]                   NAME <- NAMES[[kk]]
[16:20:44.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.177]                     next
[16:20:44.177]                   args[[name]] <- ""
[16:20:44.177]                 }
[16:20:44.177]                 NAMES <- toupper(removed)
[16:20:44.177]                 for (kk in seq_along(NAMES)) {
[16:20:44.177]                   name <- removed[[kk]]
[16:20:44.177]                   NAME <- NAMES[[kk]]
[16:20:44.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.177]                     next
[16:20:44.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.177]                 }
[16:20:44.177]                 if (length(args) > 0) 
[16:20:44.177]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.177]             }
[16:20:44.177]             else {
[16:20:44.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.177]             }
[16:20:44.177]             {
[16:20:44.177]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.177]                   0L) {
[16:20:44.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.177]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.177]                   base::options(opts)
[16:20:44.177]                 }
[16:20:44.177]                 {
[16:20:44.177]                   {
[16:20:44.177]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.177]                     NULL
[16:20:44.177]                   }
[16:20:44.177]                   options(future.plan = NULL)
[16:20:44.177]                   if (is.na(NA_character_)) 
[16:20:44.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.177]                     .init = FALSE)
[16:20:44.177]                 }
[16:20:44.177]             }
[16:20:44.177]         }
[16:20:44.177]     })
[16:20:44.177]     if (TRUE) {
[16:20:44.177]         base::sink(type = "output", split = FALSE)
[16:20:44.177]         if (TRUE) {
[16:20:44.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.177]         }
[16:20:44.177]         else {
[16:20:44.177]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.177]         }
[16:20:44.177]         base::close(...future.stdout)
[16:20:44.177]         ...future.stdout <- NULL
[16:20:44.177]     }
[16:20:44.177]     ...future.result$conditions <- ...future.conditions
[16:20:44.177]     ...future.result$finished <- base::Sys.time()
[16:20:44.177]     ...future.result
[16:20:44.177] }
[16:20:44.230] MultisessionFuture started
[16:20:44.230] - Launch lazy future ... done
[16:20:44.230] run() for ‘MultisessionFuture’ ... done
[16:20:44.231] getGlobalsAndPackages() ...
[16:20:44.231] Searching for globals...
[16:20:44.232] - globals found: [1] ‘{’
[16:20:44.232] Searching for globals ... DONE
[16:20:44.232] Resolving globals: FALSE
[16:20:44.232] 
[16:20:44.232] 
[16:20:44.232] getGlobalsAndPackages() ... DONE
[16:20:44.233] run() for ‘Future’ ...
[16:20:44.233] - state: ‘created’
[16:20:44.233] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.250] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.251]   - Field: ‘node’
[16:20:44.251]   - Field: ‘label’
[16:20:44.251]   - Field: ‘local’
[16:20:44.251]   - Field: ‘owner’
[16:20:44.251]   - Field: ‘envir’
[16:20:44.252]   - Field: ‘workers’
[16:20:44.252]   - Field: ‘packages’
[16:20:44.252]   - Field: ‘gc’
[16:20:44.252]   - Field: ‘conditions’
[16:20:44.252]   - Field: ‘persistent’
[16:20:44.253]   - Field: ‘expr’
[16:20:44.253]   - Field: ‘uuid’
[16:20:44.253]   - Field: ‘seed’
[16:20:44.253]   - Field: ‘version’
[16:20:44.253]   - Field: ‘result’
[16:20:44.253]   - Field: ‘asynchronous’
[16:20:44.254]   - Field: ‘calls’
[16:20:44.254]   - Field: ‘globals’
[16:20:44.254]   - Field: ‘stdout’
[16:20:44.254]   - Field: ‘earlySignal’
[16:20:44.254]   - Field: ‘lazy’
[16:20:44.254]   - Field: ‘state’
[16:20:44.255] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.255] - Launch lazy future ...
[16:20:44.255] Packages needed by the future expression (n = 0): <none>
[16:20:44.255] Packages needed by future strategies (n = 0): <none>
[16:20:44.256] {
[16:20:44.256]     {
[16:20:44.256]         {
[16:20:44.256]             ...future.startTime <- base::Sys.time()
[16:20:44.256]             {
[16:20:44.256]                 {
[16:20:44.256]                   {
[16:20:44.256]                     {
[16:20:44.256]                       base::local({
[16:20:44.256]                         has_future <- base::requireNamespace("future", 
[16:20:44.256]                           quietly = TRUE)
[16:20:44.256]                         if (has_future) {
[16:20:44.256]                           ns <- base::getNamespace("future")
[16:20:44.256]                           version <- ns[[".package"]][["version"]]
[16:20:44.256]                           if (is.null(version)) 
[16:20:44.256]                             version <- utils::packageVersion("future")
[16:20:44.256]                         }
[16:20:44.256]                         else {
[16:20:44.256]                           version <- NULL
[16:20:44.256]                         }
[16:20:44.256]                         if (!has_future || version < "1.8.0") {
[16:20:44.256]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.256]                             "", base::R.version$version.string), 
[16:20:44.256]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.256]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.256]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.256]                               "release", "version")], collapse = " "), 
[16:20:44.256]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.256]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.256]                             info)
[16:20:44.256]                           info <- base::paste(info, collapse = "; ")
[16:20:44.256]                           if (!has_future) {
[16:20:44.256]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.256]                               info)
[16:20:44.256]                           }
[16:20:44.256]                           else {
[16:20:44.256]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.256]                               info, version)
[16:20:44.256]                           }
[16:20:44.256]                           base::stop(msg)
[16:20:44.256]                         }
[16:20:44.256]                       })
[16:20:44.256]                     }
[16:20:44.256]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.256]                     base::options(mc.cores = 1L)
[16:20:44.256]                   }
[16:20:44.256]                   ...future.strategy.old <- future::plan("list")
[16:20:44.256]                   options(future.plan = NULL)
[16:20:44.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.256]                 }
[16:20:44.256]                 ...future.workdir <- getwd()
[16:20:44.256]             }
[16:20:44.256]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.256]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.256]         }
[16:20:44.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.256]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.256]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.256]             base::names(...future.oldOptions))
[16:20:44.256]     }
[16:20:44.256]     if (FALSE) {
[16:20:44.256]     }
[16:20:44.256]     else {
[16:20:44.256]         if (TRUE) {
[16:20:44.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.256]                 open = "w")
[16:20:44.256]         }
[16:20:44.256]         else {
[16:20:44.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.256]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.256]         }
[16:20:44.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.256]             base::sink(type = "output", split = FALSE)
[16:20:44.256]             base::close(...future.stdout)
[16:20:44.256]         }, add = TRUE)
[16:20:44.256]     }
[16:20:44.256]     ...future.frame <- base::sys.nframe()
[16:20:44.256]     ...future.conditions <- base::list()
[16:20:44.256]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.256]     if (FALSE) {
[16:20:44.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.256]     }
[16:20:44.256]     ...future.result <- base::tryCatch({
[16:20:44.256]         base::withCallingHandlers({
[16:20:44.256]             ...future.value <- base::withVisible(base::local({
[16:20:44.256]                 ...future.makeSendCondition <- base::local({
[16:20:44.256]                   sendCondition <- NULL
[16:20:44.256]                   function(frame = 1L) {
[16:20:44.256]                     if (is.function(sendCondition)) 
[16:20:44.256]                       return(sendCondition)
[16:20:44.256]                     ns <- getNamespace("parallel")
[16:20:44.256]                     if (exists("sendData", mode = "function", 
[16:20:44.256]                       envir = ns)) {
[16:20:44.256]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.256]                         envir = ns)
[16:20:44.256]                       envir <- sys.frame(frame)
[16:20:44.256]                       master <- NULL
[16:20:44.256]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.256]                         !identical(envir, emptyenv())) {
[16:20:44.256]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.256]                           inherits = FALSE)) {
[16:20:44.256]                           master <- get("master", mode = "list", 
[16:20:44.256]                             envir = envir, inherits = FALSE)
[16:20:44.256]                           if (inherits(master, c("SOCKnode", 
[16:20:44.256]                             "SOCK0node"))) {
[16:20:44.256]                             sendCondition <<- function(cond) {
[16:20:44.256]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.256]                                 success = TRUE)
[16:20:44.256]                               parallel_sendData(master, data)
[16:20:44.256]                             }
[16:20:44.256]                             return(sendCondition)
[16:20:44.256]                           }
[16:20:44.256]                         }
[16:20:44.256]                         frame <- frame + 1L
[16:20:44.256]                         envir <- sys.frame(frame)
[16:20:44.256]                       }
[16:20:44.256]                     }
[16:20:44.256]                     sendCondition <<- function(cond) NULL
[16:20:44.256]                   }
[16:20:44.256]                 })
[16:20:44.256]                 withCallingHandlers({
[16:20:44.256]                   {
[16:20:44.256]                     4
[16:20:44.256]                   }
[16:20:44.256]                 }, immediateCondition = function(cond) {
[16:20:44.256]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.256]                   sendCondition(cond)
[16:20:44.256]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.256]                   {
[16:20:44.256]                     inherits <- base::inherits
[16:20:44.256]                     invokeRestart <- base::invokeRestart
[16:20:44.256]                     is.null <- base::is.null
[16:20:44.256]                     muffled <- FALSE
[16:20:44.256]                     if (inherits(cond, "message")) {
[16:20:44.256]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.256]                       if (muffled) 
[16:20:44.256]                         invokeRestart("muffleMessage")
[16:20:44.256]                     }
[16:20:44.256]                     else if (inherits(cond, "warning")) {
[16:20:44.256]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.256]                       if (muffled) 
[16:20:44.256]                         invokeRestart("muffleWarning")
[16:20:44.256]                     }
[16:20:44.256]                     else if (inherits(cond, "condition")) {
[16:20:44.256]                       if (!is.null(pattern)) {
[16:20:44.256]                         computeRestarts <- base::computeRestarts
[16:20:44.256]                         grepl <- base::grepl
[16:20:44.256]                         restarts <- computeRestarts(cond)
[16:20:44.256]                         for (restart in restarts) {
[16:20:44.256]                           name <- restart$name
[16:20:44.256]                           if (is.null(name)) 
[16:20:44.256]                             next
[16:20:44.256]                           if (!grepl(pattern, name)) 
[16:20:44.256]                             next
[16:20:44.256]                           invokeRestart(restart)
[16:20:44.256]                           muffled <- TRUE
[16:20:44.256]                           break
[16:20:44.256]                         }
[16:20:44.256]                       }
[16:20:44.256]                     }
[16:20:44.256]                     invisible(muffled)
[16:20:44.256]                   }
[16:20:44.256]                   muffleCondition(cond)
[16:20:44.256]                 })
[16:20:44.256]             }))
[16:20:44.256]             future::FutureResult(value = ...future.value$value, 
[16:20:44.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.256]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.256]                     ...future.globalenv.names))
[16:20:44.256]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.256]         }, condition = base::local({
[16:20:44.256]             c <- base::c
[16:20:44.256]             inherits <- base::inherits
[16:20:44.256]             invokeRestart <- base::invokeRestart
[16:20:44.256]             length <- base::length
[16:20:44.256]             list <- base::list
[16:20:44.256]             seq.int <- base::seq.int
[16:20:44.256]             signalCondition <- base::signalCondition
[16:20:44.256]             sys.calls <- base::sys.calls
[16:20:44.256]             `[[` <- base::`[[`
[16:20:44.256]             `+` <- base::`+`
[16:20:44.256]             `<<-` <- base::`<<-`
[16:20:44.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.256]                   3L)]
[16:20:44.256]             }
[16:20:44.256]             function(cond) {
[16:20:44.256]                 is_error <- inherits(cond, "error")
[16:20:44.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.256]                   NULL)
[16:20:44.256]                 if (is_error) {
[16:20:44.256]                   sessionInformation <- function() {
[16:20:44.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.256]                       search = base::search(), system = base::Sys.info())
[16:20:44.256]                   }
[16:20:44.256]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.256]                     cond$call), session = sessionInformation(), 
[16:20:44.256]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.256]                   signalCondition(cond)
[16:20:44.256]                 }
[16:20:44.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.256]                 "immediateCondition"))) {
[16:20:44.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.256]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.256]                   if (TRUE && !signal) {
[16:20:44.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.256]                     {
[16:20:44.256]                       inherits <- base::inherits
[16:20:44.256]                       invokeRestart <- base::invokeRestart
[16:20:44.256]                       is.null <- base::is.null
[16:20:44.256]                       muffled <- FALSE
[16:20:44.256]                       if (inherits(cond, "message")) {
[16:20:44.256]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.256]                         if (muffled) 
[16:20:44.256]                           invokeRestart("muffleMessage")
[16:20:44.256]                       }
[16:20:44.256]                       else if (inherits(cond, "warning")) {
[16:20:44.256]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.256]                         if (muffled) 
[16:20:44.256]                           invokeRestart("muffleWarning")
[16:20:44.256]                       }
[16:20:44.256]                       else if (inherits(cond, "condition")) {
[16:20:44.256]                         if (!is.null(pattern)) {
[16:20:44.256]                           computeRestarts <- base::computeRestarts
[16:20:44.256]                           grepl <- base::grepl
[16:20:44.256]                           restarts <- computeRestarts(cond)
[16:20:44.256]                           for (restart in restarts) {
[16:20:44.256]                             name <- restart$name
[16:20:44.256]                             if (is.null(name)) 
[16:20:44.256]                               next
[16:20:44.256]                             if (!grepl(pattern, name)) 
[16:20:44.256]                               next
[16:20:44.256]                             invokeRestart(restart)
[16:20:44.256]                             muffled <- TRUE
[16:20:44.256]                             break
[16:20:44.256]                           }
[16:20:44.256]                         }
[16:20:44.256]                       }
[16:20:44.256]                       invisible(muffled)
[16:20:44.256]                     }
[16:20:44.256]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.256]                   }
[16:20:44.256]                 }
[16:20:44.256]                 else {
[16:20:44.256]                   if (TRUE) {
[16:20:44.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.256]                     {
[16:20:44.256]                       inherits <- base::inherits
[16:20:44.256]                       invokeRestart <- base::invokeRestart
[16:20:44.256]                       is.null <- base::is.null
[16:20:44.256]                       muffled <- FALSE
[16:20:44.256]                       if (inherits(cond, "message")) {
[16:20:44.256]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.256]                         if (muffled) 
[16:20:44.256]                           invokeRestart("muffleMessage")
[16:20:44.256]                       }
[16:20:44.256]                       else if (inherits(cond, "warning")) {
[16:20:44.256]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.256]                         if (muffled) 
[16:20:44.256]                           invokeRestart("muffleWarning")
[16:20:44.256]                       }
[16:20:44.256]                       else if (inherits(cond, "condition")) {
[16:20:44.256]                         if (!is.null(pattern)) {
[16:20:44.256]                           computeRestarts <- base::computeRestarts
[16:20:44.256]                           grepl <- base::grepl
[16:20:44.256]                           restarts <- computeRestarts(cond)
[16:20:44.256]                           for (restart in restarts) {
[16:20:44.256]                             name <- restart$name
[16:20:44.256]                             if (is.null(name)) 
[16:20:44.256]                               next
[16:20:44.256]                             if (!grepl(pattern, name)) 
[16:20:44.256]                               next
[16:20:44.256]                             invokeRestart(restart)
[16:20:44.256]                             muffled <- TRUE
[16:20:44.256]                             break
[16:20:44.256]                           }
[16:20:44.256]                         }
[16:20:44.256]                       }
[16:20:44.256]                       invisible(muffled)
[16:20:44.256]                     }
[16:20:44.256]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.256]                   }
[16:20:44.256]                 }
[16:20:44.256]             }
[16:20:44.256]         }))
[16:20:44.256]     }, error = function(ex) {
[16:20:44.256]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.256]                 ...future.rng), started = ...future.startTime, 
[16:20:44.256]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.256]             version = "1.8"), class = "FutureResult")
[16:20:44.256]     }, finally = {
[16:20:44.256]         if (!identical(...future.workdir, getwd())) 
[16:20:44.256]             setwd(...future.workdir)
[16:20:44.256]         {
[16:20:44.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.256]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.256]             }
[16:20:44.256]             base::options(...future.oldOptions)
[16:20:44.256]             if (.Platform$OS.type == "windows") {
[16:20:44.256]                 old_names <- names(...future.oldEnvVars)
[16:20:44.256]                 envs <- base::Sys.getenv()
[16:20:44.256]                 names <- names(envs)
[16:20:44.256]                 common <- intersect(names, old_names)
[16:20:44.256]                 added <- setdiff(names, old_names)
[16:20:44.256]                 removed <- setdiff(old_names, names)
[16:20:44.256]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.256]                   envs[common]]
[16:20:44.256]                 NAMES <- toupper(changed)
[16:20:44.256]                 args <- list()
[16:20:44.256]                 for (kk in seq_along(NAMES)) {
[16:20:44.256]                   name <- changed[[kk]]
[16:20:44.256]                   NAME <- NAMES[[kk]]
[16:20:44.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.256]                     next
[16:20:44.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.256]                 }
[16:20:44.256]                 NAMES <- toupper(added)
[16:20:44.256]                 for (kk in seq_along(NAMES)) {
[16:20:44.256]                   name <- added[[kk]]
[16:20:44.256]                   NAME <- NAMES[[kk]]
[16:20:44.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.256]                     next
[16:20:44.256]                   args[[name]] <- ""
[16:20:44.256]                 }
[16:20:44.256]                 NAMES <- toupper(removed)
[16:20:44.256]                 for (kk in seq_along(NAMES)) {
[16:20:44.256]                   name <- removed[[kk]]
[16:20:44.256]                   NAME <- NAMES[[kk]]
[16:20:44.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.256]                     next
[16:20:44.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.256]                 }
[16:20:44.256]                 if (length(args) > 0) 
[16:20:44.256]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.256]             }
[16:20:44.256]             else {
[16:20:44.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.256]             }
[16:20:44.256]             {
[16:20:44.256]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.256]                   0L) {
[16:20:44.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.256]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.256]                   base::options(opts)
[16:20:44.256]                 }
[16:20:44.256]                 {
[16:20:44.256]                   {
[16:20:44.256]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.256]                     NULL
[16:20:44.256]                   }
[16:20:44.256]                   options(future.plan = NULL)
[16:20:44.256]                   if (is.na(NA_character_)) 
[16:20:44.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.256]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.256]                     .init = FALSE)
[16:20:44.256]                 }
[16:20:44.256]             }
[16:20:44.256]         }
[16:20:44.256]     })
[16:20:44.256]     if (TRUE) {
[16:20:44.256]         base::sink(type = "output", split = FALSE)
[16:20:44.256]         if (TRUE) {
[16:20:44.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.256]         }
[16:20:44.256]         else {
[16:20:44.256]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.256]         }
[16:20:44.256]         base::close(...future.stdout)
[16:20:44.256]         ...future.stdout <- NULL
[16:20:44.256]     }
[16:20:44.256]     ...future.result$conditions <- ...future.conditions
[16:20:44.256]     ...future.result$finished <- base::Sys.time()
[16:20:44.256]     ...future.result
[16:20:44.256] }
[16:20:44.260] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:44.271] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.271] - Validating connection of MultisessionFuture
[16:20:44.271] - received message: FutureResult
[16:20:44.272] - Received FutureResult
[16:20:44.272] - Erased future from FutureRegistry
[16:20:44.272] result() for ClusterFuture ...
[16:20:44.272] - result already collected: FutureResult
[16:20:44.272] result() for ClusterFuture ... done
[16:20:44.273] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.273] result() for ClusterFuture ...
[16:20:44.273] - result already collected: FutureResult
[16:20:44.273] result() for ClusterFuture ... done
[16:20:44.273] result() for ClusterFuture ...
[16:20:44.273] - result already collected: FutureResult
[16:20:44.273] result() for ClusterFuture ... done
[16:20:44.275] MultisessionFuture started
[16:20:44.275] - Launch lazy future ... done
[16:20:44.275] run() for ‘MultisessionFuture’ ... done
<environment: 0x55ed0c367418> 
<environment: 0x55ed0d246660> 
[16:20:44.277] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.277] - Validating connection of MultisessionFuture
[16:20:44.277] - received message: FutureResult
[16:20:44.277] - Received FutureResult
[16:20:44.278] - Erased future from FutureRegistry
[16:20:44.278] result() for ClusterFuture ...
[16:20:44.278] - result already collected: FutureResult
[16:20:44.278] result() for ClusterFuture ... done
[16:20:44.278] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.278] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.278] - Validating connection of MultisessionFuture
[16:20:44.279] - received message: FutureResult
[16:20:44.279] - Received FutureResult
[16:20:44.279] - Erased future from FutureRegistry
[16:20:44.279] result() for ClusterFuture ...
[16:20:44.279] - result already collected: FutureResult
[16:20:44.279] result() for ClusterFuture ... done
[16:20:44.279] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:44.280] resolve() on environment ...
[16:20:44.280]  recursive: 0
[16:20:44.281]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:44.281] signalConditionsASAP(numeric, pos=1) ...
[16:20:44.281] - nx: 4
[16:20:44.281] - relay: TRUE
[16:20:44.281] - stdout: TRUE
[16:20:44.281] - signal: TRUE
[16:20:44.281] - resignal: FALSE
[16:20:44.282] - force: TRUE
[16:20:44.282] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.282] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.282]  - until=2
[16:20:44.282]  - relaying element #2
[16:20:44.282] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.282] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.282] signalConditionsASAP(NULL, pos=1) ... done
[16:20:44.282]  length: 3 (resolved future 1)
[16:20:44.282] Future #2
[16:20:44.283] result() for ClusterFuture ...
[16:20:44.283] - result already collected: FutureResult
[16:20:44.283] result() for ClusterFuture ... done
[16:20:44.283] result() for ClusterFuture ...
[16:20:44.283] - result already collected: FutureResult
[16:20:44.283] result() for ClusterFuture ... done
[16:20:44.283] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:44.283] - nx: 4
[16:20:44.283] - relay: TRUE
[16:20:44.283] - stdout: TRUE
[16:20:44.283] - signal: TRUE
[16:20:44.283] - resignal: FALSE
[16:20:44.284] - force: TRUE
[16:20:44.284] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.284] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.284]  - until=2
[16:20:44.284]  - relaying element #2
[16:20:44.284] result() for ClusterFuture ...
[16:20:44.284] - result already collected: FutureResult
[16:20:44.284] result() for ClusterFuture ... done
[16:20:44.284] result() for ClusterFuture ...
[16:20:44.284] - result already collected: FutureResult
[16:20:44.284] result() for ClusterFuture ... done
[16:20:44.285] result() for ClusterFuture ...
[16:20:44.285] - result already collected: FutureResult
[16:20:44.285] result() for ClusterFuture ... done
[16:20:44.285] result() for ClusterFuture ...
[16:20:44.285] - result already collected: FutureResult
[16:20:44.285] result() for ClusterFuture ... done
[16:20:44.285] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.285] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.285] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:44.285]  length: 2 (resolved future 2)
[16:20:44.286] Future #3
[16:20:44.286] result() for ClusterFuture ...
[16:20:44.286] - result already collected: FutureResult
[16:20:44.286] result() for ClusterFuture ... done
[16:20:44.286] result() for ClusterFuture ...
[16:20:44.286] - result already collected: FutureResult
[16:20:44.286] result() for ClusterFuture ... done
[16:20:44.286] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:44.286] - nx: 4
[16:20:44.286] - relay: TRUE
[16:20:44.286] - stdout: TRUE
[16:20:44.286] - signal: TRUE
[16:20:44.287] - resignal: FALSE
[16:20:44.287] - force: TRUE
[16:20:44.287] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.287] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.287]  - until=3
[16:20:44.287]  - relaying element #3
[16:20:44.287] result() for ClusterFuture ...
[16:20:44.287] - result already collected: FutureResult
[16:20:44.287] result() for ClusterFuture ... done
[16:20:44.287] result() for ClusterFuture ...
[16:20:44.287] - result already collected: FutureResult
[16:20:44.287] result() for ClusterFuture ... done
[16:20:44.288] result() for ClusterFuture ...
[16:20:44.288] - result already collected: FutureResult
[16:20:44.288] result() for ClusterFuture ... done
[16:20:44.288] result() for ClusterFuture ...
[16:20:44.288] - result already collected: FutureResult
[16:20:44.288] result() for ClusterFuture ... done
[16:20:44.288] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.288] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.288] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:44.288]  length: 1 (resolved future 3)
[16:20:44.289] Future #4
[16:20:44.289] result() for ClusterFuture ...
[16:20:44.289] - result already collected: FutureResult
[16:20:44.289] result() for ClusterFuture ... done
[16:20:44.289] result() for ClusterFuture ...
[16:20:44.289] - result already collected: FutureResult
[16:20:44.289] result() for ClusterFuture ... done
[16:20:44.289] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:44.289] - nx: 4
[16:20:44.289] - relay: TRUE
[16:20:44.289] - stdout: TRUE
[16:20:44.290] - signal: TRUE
[16:20:44.290] - resignal: FALSE
[16:20:44.290] - force: TRUE
[16:20:44.290] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.290] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.290]  - until=4
[16:20:44.290]  - relaying element #4
[16:20:44.290] result() for ClusterFuture ...
[16:20:44.290] - result already collected: FutureResult
[16:20:44.290] result() for ClusterFuture ... done
[16:20:44.290] result() for ClusterFuture ...
[16:20:44.290] - result already collected: FutureResult
[16:20:44.291] result() for ClusterFuture ... done
[16:20:44.291] result() for ClusterFuture ...
[16:20:44.291] - result already collected: FutureResult
[16:20:44.291] result() for ClusterFuture ... done
[16:20:44.291] result() for ClusterFuture ...
[16:20:44.291] - result already collected: FutureResult
[16:20:44.291] result() for ClusterFuture ... done
[16:20:44.291] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.291] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.291] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:44.291]  length: 0 (resolved future 4)
[16:20:44.292] Relaying remaining futures
[16:20:44.292] signalConditionsASAP(NULL, pos=0) ...
[16:20:44.292] - nx: 4
[16:20:44.292] - relay: TRUE
[16:20:44.292] - stdout: TRUE
[16:20:44.292] - signal: TRUE
[16:20:44.292] - resignal: FALSE
[16:20:44.292] - force: TRUE
[16:20:44.292] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.292] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:44.292] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.293] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.293] signalConditionsASAP(NULL, pos=0) ... done
[16:20:44.293] resolve() on environment ... DONE
[16:20:44.293] result() for ClusterFuture ...
[16:20:44.293] - result already collected: FutureResult
[16:20:44.293] result() for ClusterFuture ... done
[16:20:44.293] result() for ClusterFuture ...
[16:20:44.293] - result already collected: FutureResult
[16:20:44.293] result() for ClusterFuture ... done
[16:20:44.293] result() for ClusterFuture ...
[16:20:44.293] - result already collected: FutureResult
[16:20:44.294] result() for ClusterFuture ... done
[16:20:44.294] result() for ClusterFuture ...
[16:20:44.294] - result already collected: FutureResult
[16:20:44.294] result() for ClusterFuture ... done
[16:20:44.294] result() for ClusterFuture ...
[16:20:44.294] - result already collected: FutureResult
[16:20:44.294] result() for ClusterFuture ... done
[16:20:44.294] result() for ClusterFuture ...
[16:20:44.294] - result already collected: FutureResult
[16:20:44.294] result() for ClusterFuture ... done
<environment: 0x55ed0d466160> 
Dimensions: c(1, 6)
[16:20:44.295] getGlobalsAndPackages() ...
[16:20:44.295] Searching for globals...
[16:20:44.295] 
[16:20:44.295] Searching for globals ... DONE
[16:20:44.295] - globals: [0] <none>
[16:20:44.295] getGlobalsAndPackages() ... DONE
[16:20:44.296] run() for ‘Future’ ...
[16:20:44.296] - state: ‘created’
[16:20:44.296] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.311] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.311]   - Field: ‘node’
[16:20:44.311]   - Field: ‘label’
[16:20:44.311]   - Field: ‘local’
[16:20:44.311]   - Field: ‘owner’
[16:20:44.311]   - Field: ‘envir’
[16:20:44.311]   - Field: ‘workers’
[16:20:44.311]   - Field: ‘packages’
[16:20:44.312]   - Field: ‘gc’
[16:20:44.312]   - Field: ‘conditions’
[16:20:44.312]   - Field: ‘persistent’
[16:20:44.312]   - Field: ‘expr’
[16:20:44.312]   - Field: ‘uuid’
[16:20:44.312]   - Field: ‘seed’
[16:20:44.312]   - Field: ‘version’
[16:20:44.312]   - Field: ‘result’
[16:20:44.312]   - Field: ‘asynchronous’
[16:20:44.312]   - Field: ‘calls’
[16:20:44.313]   - Field: ‘globals’
[16:20:44.313]   - Field: ‘stdout’
[16:20:44.313]   - Field: ‘earlySignal’
[16:20:44.313]   - Field: ‘lazy’
[16:20:44.313]   - Field: ‘state’
[16:20:44.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.313] - Launch lazy future ...
[16:20:44.313] Packages needed by the future expression (n = 0): <none>
[16:20:44.313] Packages needed by future strategies (n = 0): <none>
[16:20:44.314] {
[16:20:44.314]     {
[16:20:44.314]         {
[16:20:44.314]             ...future.startTime <- base::Sys.time()
[16:20:44.314]             {
[16:20:44.314]                 {
[16:20:44.314]                   {
[16:20:44.314]                     {
[16:20:44.314]                       base::local({
[16:20:44.314]                         has_future <- base::requireNamespace("future", 
[16:20:44.314]                           quietly = TRUE)
[16:20:44.314]                         if (has_future) {
[16:20:44.314]                           ns <- base::getNamespace("future")
[16:20:44.314]                           version <- ns[[".package"]][["version"]]
[16:20:44.314]                           if (is.null(version)) 
[16:20:44.314]                             version <- utils::packageVersion("future")
[16:20:44.314]                         }
[16:20:44.314]                         else {
[16:20:44.314]                           version <- NULL
[16:20:44.314]                         }
[16:20:44.314]                         if (!has_future || version < "1.8.0") {
[16:20:44.314]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.314]                             "", base::R.version$version.string), 
[16:20:44.314]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.314]                               "release", "version")], collapse = " "), 
[16:20:44.314]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.314]                             info)
[16:20:44.314]                           info <- base::paste(info, collapse = "; ")
[16:20:44.314]                           if (!has_future) {
[16:20:44.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.314]                               info)
[16:20:44.314]                           }
[16:20:44.314]                           else {
[16:20:44.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.314]                               info, version)
[16:20:44.314]                           }
[16:20:44.314]                           base::stop(msg)
[16:20:44.314]                         }
[16:20:44.314]                       })
[16:20:44.314]                     }
[16:20:44.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.314]                     base::options(mc.cores = 1L)
[16:20:44.314]                   }
[16:20:44.314]                   ...future.strategy.old <- future::plan("list")
[16:20:44.314]                   options(future.plan = NULL)
[16:20:44.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.314]                 }
[16:20:44.314]                 ...future.workdir <- getwd()
[16:20:44.314]             }
[16:20:44.314]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.314]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.314]         }
[16:20:44.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.314]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.314]             base::names(...future.oldOptions))
[16:20:44.314]     }
[16:20:44.314]     if (FALSE) {
[16:20:44.314]     }
[16:20:44.314]     else {
[16:20:44.314]         if (TRUE) {
[16:20:44.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.314]                 open = "w")
[16:20:44.314]         }
[16:20:44.314]         else {
[16:20:44.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.314]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.314]         }
[16:20:44.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.314]             base::sink(type = "output", split = FALSE)
[16:20:44.314]             base::close(...future.stdout)
[16:20:44.314]         }, add = TRUE)
[16:20:44.314]     }
[16:20:44.314]     ...future.frame <- base::sys.nframe()
[16:20:44.314]     ...future.conditions <- base::list()
[16:20:44.314]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.314]     if (FALSE) {
[16:20:44.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.314]     }
[16:20:44.314]     ...future.result <- base::tryCatch({
[16:20:44.314]         base::withCallingHandlers({
[16:20:44.314]             ...future.value <- base::withVisible(base::local({
[16:20:44.314]                 ...future.makeSendCondition <- base::local({
[16:20:44.314]                   sendCondition <- NULL
[16:20:44.314]                   function(frame = 1L) {
[16:20:44.314]                     if (is.function(sendCondition)) 
[16:20:44.314]                       return(sendCondition)
[16:20:44.314]                     ns <- getNamespace("parallel")
[16:20:44.314]                     if (exists("sendData", mode = "function", 
[16:20:44.314]                       envir = ns)) {
[16:20:44.314]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.314]                         envir = ns)
[16:20:44.314]                       envir <- sys.frame(frame)
[16:20:44.314]                       master <- NULL
[16:20:44.314]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.314]                         !identical(envir, emptyenv())) {
[16:20:44.314]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.314]                           inherits = FALSE)) {
[16:20:44.314]                           master <- get("master", mode = "list", 
[16:20:44.314]                             envir = envir, inherits = FALSE)
[16:20:44.314]                           if (inherits(master, c("SOCKnode", 
[16:20:44.314]                             "SOCK0node"))) {
[16:20:44.314]                             sendCondition <<- function(cond) {
[16:20:44.314]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.314]                                 success = TRUE)
[16:20:44.314]                               parallel_sendData(master, data)
[16:20:44.314]                             }
[16:20:44.314]                             return(sendCondition)
[16:20:44.314]                           }
[16:20:44.314]                         }
[16:20:44.314]                         frame <- frame + 1L
[16:20:44.314]                         envir <- sys.frame(frame)
[16:20:44.314]                       }
[16:20:44.314]                     }
[16:20:44.314]                     sendCondition <<- function(cond) NULL
[16:20:44.314]                   }
[16:20:44.314]                 })
[16:20:44.314]                 withCallingHandlers({
[16:20:44.314]                   2
[16:20:44.314]                 }, immediateCondition = function(cond) {
[16:20:44.314]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.314]                   sendCondition(cond)
[16:20:44.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.314]                   {
[16:20:44.314]                     inherits <- base::inherits
[16:20:44.314]                     invokeRestart <- base::invokeRestart
[16:20:44.314]                     is.null <- base::is.null
[16:20:44.314]                     muffled <- FALSE
[16:20:44.314]                     if (inherits(cond, "message")) {
[16:20:44.314]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.314]                       if (muffled) 
[16:20:44.314]                         invokeRestart("muffleMessage")
[16:20:44.314]                     }
[16:20:44.314]                     else if (inherits(cond, "warning")) {
[16:20:44.314]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.314]                       if (muffled) 
[16:20:44.314]                         invokeRestart("muffleWarning")
[16:20:44.314]                     }
[16:20:44.314]                     else if (inherits(cond, "condition")) {
[16:20:44.314]                       if (!is.null(pattern)) {
[16:20:44.314]                         computeRestarts <- base::computeRestarts
[16:20:44.314]                         grepl <- base::grepl
[16:20:44.314]                         restarts <- computeRestarts(cond)
[16:20:44.314]                         for (restart in restarts) {
[16:20:44.314]                           name <- restart$name
[16:20:44.314]                           if (is.null(name)) 
[16:20:44.314]                             next
[16:20:44.314]                           if (!grepl(pattern, name)) 
[16:20:44.314]                             next
[16:20:44.314]                           invokeRestart(restart)
[16:20:44.314]                           muffled <- TRUE
[16:20:44.314]                           break
[16:20:44.314]                         }
[16:20:44.314]                       }
[16:20:44.314]                     }
[16:20:44.314]                     invisible(muffled)
[16:20:44.314]                   }
[16:20:44.314]                   muffleCondition(cond)
[16:20:44.314]                 })
[16:20:44.314]             }))
[16:20:44.314]             future::FutureResult(value = ...future.value$value, 
[16:20:44.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.314]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.314]                     ...future.globalenv.names))
[16:20:44.314]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.314]         }, condition = base::local({
[16:20:44.314]             c <- base::c
[16:20:44.314]             inherits <- base::inherits
[16:20:44.314]             invokeRestart <- base::invokeRestart
[16:20:44.314]             length <- base::length
[16:20:44.314]             list <- base::list
[16:20:44.314]             seq.int <- base::seq.int
[16:20:44.314]             signalCondition <- base::signalCondition
[16:20:44.314]             sys.calls <- base::sys.calls
[16:20:44.314]             `[[` <- base::`[[`
[16:20:44.314]             `+` <- base::`+`
[16:20:44.314]             `<<-` <- base::`<<-`
[16:20:44.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.314]                   3L)]
[16:20:44.314]             }
[16:20:44.314]             function(cond) {
[16:20:44.314]                 is_error <- inherits(cond, "error")
[16:20:44.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.314]                   NULL)
[16:20:44.314]                 if (is_error) {
[16:20:44.314]                   sessionInformation <- function() {
[16:20:44.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.314]                       search = base::search(), system = base::Sys.info())
[16:20:44.314]                   }
[16:20:44.314]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.314]                     cond$call), session = sessionInformation(), 
[16:20:44.314]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.314]                   signalCondition(cond)
[16:20:44.314]                 }
[16:20:44.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.314]                 "immediateCondition"))) {
[16:20:44.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.314]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.314]                   if (TRUE && !signal) {
[16:20:44.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.314]                     {
[16:20:44.314]                       inherits <- base::inherits
[16:20:44.314]                       invokeRestart <- base::invokeRestart
[16:20:44.314]                       is.null <- base::is.null
[16:20:44.314]                       muffled <- FALSE
[16:20:44.314]                       if (inherits(cond, "message")) {
[16:20:44.314]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.314]                         if (muffled) 
[16:20:44.314]                           invokeRestart("muffleMessage")
[16:20:44.314]                       }
[16:20:44.314]                       else if (inherits(cond, "warning")) {
[16:20:44.314]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.314]                         if (muffled) 
[16:20:44.314]                           invokeRestart("muffleWarning")
[16:20:44.314]                       }
[16:20:44.314]                       else if (inherits(cond, "condition")) {
[16:20:44.314]                         if (!is.null(pattern)) {
[16:20:44.314]                           computeRestarts <- base::computeRestarts
[16:20:44.314]                           grepl <- base::grepl
[16:20:44.314]                           restarts <- computeRestarts(cond)
[16:20:44.314]                           for (restart in restarts) {
[16:20:44.314]                             name <- restart$name
[16:20:44.314]                             if (is.null(name)) 
[16:20:44.314]                               next
[16:20:44.314]                             if (!grepl(pattern, name)) 
[16:20:44.314]                               next
[16:20:44.314]                             invokeRestart(restart)
[16:20:44.314]                             muffled <- TRUE
[16:20:44.314]                             break
[16:20:44.314]                           }
[16:20:44.314]                         }
[16:20:44.314]                       }
[16:20:44.314]                       invisible(muffled)
[16:20:44.314]                     }
[16:20:44.314]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.314]                   }
[16:20:44.314]                 }
[16:20:44.314]                 else {
[16:20:44.314]                   if (TRUE) {
[16:20:44.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.314]                     {
[16:20:44.314]                       inherits <- base::inherits
[16:20:44.314]                       invokeRestart <- base::invokeRestart
[16:20:44.314]                       is.null <- base::is.null
[16:20:44.314]                       muffled <- FALSE
[16:20:44.314]                       if (inherits(cond, "message")) {
[16:20:44.314]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.314]                         if (muffled) 
[16:20:44.314]                           invokeRestart("muffleMessage")
[16:20:44.314]                       }
[16:20:44.314]                       else if (inherits(cond, "warning")) {
[16:20:44.314]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.314]                         if (muffled) 
[16:20:44.314]                           invokeRestart("muffleWarning")
[16:20:44.314]                       }
[16:20:44.314]                       else if (inherits(cond, "condition")) {
[16:20:44.314]                         if (!is.null(pattern)) {
[16:20:44.314]                           computeRestarts <- base::computeRestarts
[16:20:44.314]                           grepl <- base::grepl
[16:20:44.314]                           restarts <- computeRestarts(cond)
[16:20:44.314]                           for (restart in restarts) {
[16:20:44.314]                             name <- restart$name
[16:20:44.314]                             if (is.null(name)) 
[16:20:44.314]                               next
[16:20:44.314]                             if (!grepl(pattern, name)) 
[16:20:44.314]                               next
[16:20:44.314]                             invokeRestart(restart)
[16:20:44.314]                             muffled <- TRUE
[16:20:44.314]                             break
[16:20:44.314]                           }
[16:20:44.314]                         }
[16:20:44.314]                       }
[16:20:44.314]                       invisible(muffled)
[16:20:44.314]                     }
[16:20:44.314]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.314]                   }
[16:20:44.314]                 }
[16:20:44.314]             }
[16:20:44.314]         }))
[16:20:44.314]     }, error = function(ex) {
[16:20:44.314]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.314]                 ...future.rng), started = ...future.startTime, 
[16:20:44.314]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.314]             version = "1.8"), class = "FutureResult")
[16:20:44.314]     }, finally = {
[16:20:44.314]         if (!identical(...future.workdir, getwd())) 
[16:20:44.314]             setwd(...future.workdir)
[16:20:44.314]         {
[16:20:44.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.314]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.314]             }
[16:20:44.314]             base::options(...future.oldOptions)
[16:20:44.314]             if (.Platform$OS.type == "windows") {
[16:20:44.314]                 old_names <- names(...future.oldEnvVars)
[16:20:44.314]                 envs <- base::Sys.getenv()
[16:20:44.314]                 names <- names(envs)
[16:20:44.314]                 common <- intersect(names, old_names)
[16:20:44.314]                 added <- setdiff(names, old_names)
[16:20:44.314]                 removed <- setdiff(old_names, names)
[16:20:44.314]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.314]                   envs[common]]
[16:20:44.314]                 NAMES <- toupper(changed)
[16:20:44.314]                 args <- list()
[16:20:44.314]                 for (kk in seq_along(NAMES)) {
[16:20:44.314]                   name <- changed[[kk]]
[16:20:44.314]                   NAME <- NAMES[[kk]]
[16:20:44.314]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.314]                     next
[16:20:44.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.314]                 }
[16:20:44.314]                 NAMES <- toupper(added)
[16:20:44.314]                 for (kk in seq_along(NAMES)) {
[16:20:44.314]                   name <- added[[kk]]
[16:20:44.314]                   NAME <- NAMES[[kk]]
[16:20:44.314]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.314]                     next
[16:20:44.314]                   args[[name]] <- ""
[16:20:44.314]                 }
[16:20:44.314]                 NAMES <- toupper(removed)
[16:20:44.314]                 for (kk in seq_along(NAMES)) {
[16:20:44.314]                   name <- removed[[kk]]
[16:20:44.314]                   NAME <- NAMES[[kk]]
[16:20:44.314]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.314]                     next
[16:20:44.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.314]                 }
[16:20:44.314]                 if (length(args) > 0) 
[16:20:44.314]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.314]             }
[16:20:44.314]             else {
[16:20:44.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.314]             }
[16:20:44.314]             {
[16:20:44.314]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.314]                   0L) {
[16:20:44.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.314]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.314]                   base::options(opts)
[16:20:44.314]                 }
[16:20:44.314]                 {
[16:20:44.314]                   {
[16:20:44.314]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.314]                     NULL
[16:20:44.314]                   }
[16:20:44.314]                   options(future.plan = NULL)
[16:20:44.314]                   if (is.na(NA_character_)) 
[16:20:44.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.314]                     .init = FALSE)
[16:20:44.314]                 }
[16:20:44.314]             }
[16:20:44.314]         }
[16:20:44.314]     })
[16:20:44.314]     if (TRUE) {
[16:20:44.314]         base::sink(type = "output", split = FALSE)
[16:20:44.314]         if (TRUE) {
[16:20:44.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.314]         }
[16:20:44.314]         else {
[16:20:44.314]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.314]         }
[16:20:44.314]         base::close(...future.stdout)
[16:20:44.314]         ...future.stdout <- NULL
[16:20:44.314]     }
[16:20:44.314]     ...future.result$conditions <- ...future.conditions
[16:20:44.314]     ...future.result$finished <- base::Sys.time()
[16:20:44.314]     ...future.result
[16:20:44.314] }
[16:20:44.317] MultisessionFuture started
[16:20:44.317] - Launch lazy future ... done
[16:20:44.317] run() for ‘MultisessionFuture’ ... done
[16:20:44.317] getGlobalsAndPackages() ...
[16:20:44.317] Searching for globals...
[16:20:44.318] 
[16:20:44.318] Searching for globals ... DONE
[16:20:44.318] - globals: [0] <none>
[16:20:44.318] getGlobalsAndPackages() ... DONE
[16:20:44.318] run() for ‘Future’ ...
[16:20:44.318] - state: ‘created’
[16:20:44.319] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.335] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.335]   - Field: ‘node’
[16:20:44.335]   - Field: ‘label’
[16:20:44.335]   - Field: ‘local’
[16:20:44.335]   - Field: ‘owner’
[16:20:44.335]   - Field: ‘envir’
[16:20:44.335]   - Field: ‘workers’
[16:20:44.336]   - Field: ‘packages’
[16:20:44.336]   - Field: ‘gc’
[16:20:44.336]   - Field: ‘conditions’
[16:20:44.336]   - Field: ‘persistent’
[16:20:44.336]   - Field: ‘expr’
[16:20:44.336]   - Field: ‘uuid’
[16:20:44.336]   - Field: ‘seed’
[16:20:44.336]   - Field: ‘version’
[16:20:44.336]   - Field: ‘result’
[16:20:44.336]   - Field: ‘asynchronous’
[16:20:44.337]   - Field: ‘calls’
[16:20:44.337]   - Field: ‘globals’
[16:20:44.337]   - Field: ‘stdout’
[16:20:44.337]   - Field: ‘earlySignal’
[16:20:44.337]   - Field: ‘lazy’
[16:20:44.337]   - Field: ‘state’
[16:20:44.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.337] - Launch lazy future ...
[16:20:44.337] Packages needed by the future expression (n = 0): <none>
[16:20:44.338] Packages needed by future strategies (n = 0): <none>
[16:20:44.338] {
[16:20:44.338]     {
[16:20:44.338]         {
[16:20:44.338]             ...future.startTime <- base::Sys.time()
[16:20:44.338]             {
[16:20:44.338]                 {
[16:20:44.338]                   {
[16:20:44.338]                     {
[16:20:44.338]                       base::local({
[16:20:44.338]                         has_future <- base::requireNamespace("future", 
[16:20:44.338]                           quietly = TRUE)
[16:20:44.338]                         if (has_future) {
[16:20:44.338]                           ns <- base::getNamespace("future")
[16:20:44.338]                           version <- ns[[".package"]][["version"]]
[16:20:44.338]                           if (is.null(version)) 
[16:20:44.338]                             version <- utils::packageVersion("future")
[16:20:44.338]                         }
[16:20:44.338]                         else {
[16:20:44.338]                           version <- NULL
[16:20:44.338]                         }
[16:20:44.338]                         if (!has_future || version < "1.8.0") {
[16:20:44.338]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.338]                             "", base::R.version$version.string), 
[16:20:44.338]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.338]                               "release", "version")], collapse = " "), 
[16:20:44.338]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.338]                             info)
[16:20:44.338]                           info <- base::paste(info, collapse = "; ")
[16:20:44.338]                           if (!has_future) {
[16:20:44.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.338]                               info)
[16:20:44.338]                           }
[16:20:44.338]                           else {
[16:20:44.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.338]                               info, version)
[16:20:44.338]                           }
[16:20:44.338]                           base::stop(msg)
[16:20:44.338]                         }
[16:20:44.338]                       })
[16:20:44.338]                     }
[16:20:44.338]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.338]                     base::options(mc.cores = 1L)
[16:20:44.338]                   }
[16:20:44.338]                   ...future.strategy.old <- future::plan("list")
[16:20:44.338]                   options(future.plan = NULL)
[16:20:44.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.338]                 }
[16:20:44.338]                 ...future.workdir <- getwd()
[16:20:44.338]             }
[16:20:44.338]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.338]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.338]         }
[16:20:44.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.338]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.338]             base::names(...future.oldOptions))
[16:20:44.338]     }
[16:20:44.338]     if (FALSE) {
[16:20:44.338]     }
[16:20:44.338]     else {
[16:20:44.338]         if (TRUE) {
[16:20:44.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.338]                 open = "w")
[16:20:44.338]         }
[16:20:44.338]         else {
[16:20:44.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.338]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.338]         }
[16:20:44.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.338]             base::sink(type = "output", split = FALSE)
[16:20:44.338]             base::close(...future.stdout)
[16:20:44.338]         }, add = TRUE)
[16:20:44.338]     }
[16:20:44.338]     ...future.frame <- base::sys.nframe()
[16:20:44.338]     ...future.conditions <- base::list()
[16:20:44.338]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.338]     if (FALSE) {
[16:20:44.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.338]     }
[16:20:44.338]     ...future.result <- base::tryCatch({
[16:20:44.338]         base::withCallingHandlers({
[16:20:44.338]             ...future.value <- base::withVisible(base::local({
[16:20:44.338]                 ...future.makeSendCondition <- base::local({
[16:20:44.338]                   sendCondition <- NULL
[16:20:44.338]                   function(frame = 1L) {
[16:20:44.338]                     if (is.function(sendCondition)) 
[16:20:44.338]                       return(sendCondition)
[16:20:44.338]                     ns <- getNamespace("parallel")
[16:20:44.338]                     if (exists("sendData", mode = "function", 
[16:20:44.338]                       envir = ns)) {
[16:20:44.338]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.338]                         envir = ns)
[16:20:44.338]                       envir <- sys.frame(frame)
[16:20:44.338]                       master <- NULL
[16:20:44.338]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.338]                         !identical(envir, emptyenv())) {
[16:20:44.338]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.338]                           inherits = FALSE)) {
[16:20:44.338]                           master <- get("master", mode = "list", 
[16:20:44.338]                             envir = envir, inherits = FALSE)
[16:20:44.338]                           if (inherits(master, c("SOCKnode", 
[16:20:44.338]                             "SOCK0node"))) {
[16:20:44.338]                             sendCondition <<- function(cond) {
[16:20:44.338]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.338]                                 success = TRUE)
[16:20:44.338]                               parallel_sendData(master, data)
[16:20:44.338]                             }
[16:20:44.338]                             return(sendCondition)
[16:20:44.338]                           }
[16:20:44.338]                         }
[16:20:44.338]                         frame <- frame + 1L
[16:20:44.338]                         envir <- sys.frame(frame)
[16:20:44.338]                       }
[16:20:44.338]                     }
[16:20:44.338]                     sendCondition <<- function(cond) NULL
[16:20:44.338]                   }
[16:20:44.338]                 })
[16:20:44.338]                 withCallingHandlers({
[16:20:44.338]                   NULL
[16:20:44.338]                 }, immediateCondition = function(cond) {
[16:20:44.338]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.338]                   sendCondition(cond)
[16:20:44.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.338]                   {
[16:20:44.338]                     inherits <- base::inherits
[16:20:44.338]                     invokeRestart <- base::invokeRestart
[16:20:44.338]                     is.null <- base::is.null
[16:20:44.338]                     muffled <- FALSE
[16:20:44.338]                     if (inherits(cond, "message")) {
[16:20:44.338]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.338]                       if (muffled) 
[16:20:44.338]                         invokeRestart("muffleMessage")
[16:20:44.338]                     }
[16:20:44.338]                     else if (inherits(cond, "warning")) {
[16:20:44.338]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.338]                       if (muffled) 
[16:20:44.338]                         invokeRestart("muffleWarning")
[16:20:44.338]                     }
[16:20:44.338]                     else if (inherits(cond, "condition")) {
[16:20:44.338]                       if (!is.null(pattern)) {
[16:20:44.338]                         computeRestarts <- base::computeRestarts
[16:20:44.338]                         grepl <- base::grepl
[16:20:44.338]                         restarts <- computeRestarts(cond)
[16:20:44.338]                         for (restart in restarts) {
[16:20:44.338]                           name <- restart$name
[16:20:44.338]                           if (is.null(name)) 
[16:20:44.338]                             next
[16:20:44.338]                           if (!grepl(pattern, name)) 
[16:20:44.338]                             next
[16:20:44.338]                           invokeRestart(restart)
[16:20:44.338]                           muffled <- TRUE
[16:20:44.338]                           break
[16:20:44.338]                         }
[16:20:44.338]                       }
[16:20:44.338]                     }
[16:20:44.338]                     invisible(muffled)
[16:20:44.338]                   }
[16:20:44.338]                   muffleCondition(cond)
[16:20:44.338]                 })
[16:20:44.338]             }))
[16:20:44.338]             future::FutureResult(value = ...future.value$value, 
[16:20:44.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.338]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.338]                     ...future.globalenv.names))
[16:20:44.338]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.338]         }, condition = base::local({
[16:20:44.338]             c <- base::c
[16:20:44.338]             inherits <- base::inherits
[16:20:44.338]             invokeRestart <- base::invokeRestart
[16:20:44.338]             length <- base::length
[16:20:44.338]             list <- base::list
[16:20:44.338]             seq.int <- base::seq.int
[16:20:44.338]             signalCondition <- base::signalCondition
[16:20:44.338]             sys.calls <- base::sys.calls
[16:20:44.338]             `[[` <- base::`[[`
[16:20:44.338]             `+` <- base::`+`
[16:20:44.338]             `<<-` <- base::`<<-`
[16:20:44.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.338]                   3L)]
[16:20:44.338]             }
[16:20:44.338]             function(cond) {
[16:20:44.338]                 is_error <- inherits(cond, "error")
[16:20:44.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.338]                   NULL)
[16:20:44.338]                 if (is_error) {
[16:20:44.338]                   sessionInformation <- function() {
[16:20:44.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.338]                       search = base::search(), system = base::Sys.info())
[16:20:44.338]                   }
[16:20:44.338]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.338]                     cond$call), session = sessionInformation(), 
[16:20:44.338]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.338]                   signalCondition(cond)
[16:20:44.338]                 }
[16:20:44.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.338]                 "immediateCondition"))) {
[16:20:44.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.338]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.338]                   if (TRUE && !signal) {
[16:20:44.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.338]                     {
[16:20:44.338]                       inherits <- base::inherits
[16:20:44.338]                       invokeRestart <- base::invokeRestart
[16:20:44.338]                       is.null <- base::is.null
[16:20:44.338]                       muffled <- FALSE
[16:20:44.338]                       if (inherits(cond, "message")) {
[16:20:44.338]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.338]                         if (muffled) 
[16:20:44.338]                           invokeRestart("muffleMessage")
[16:20:44.338]                       }
[16:20:44.338]                       else if (inherits(cond, "warning")) {
[16:20:44.338]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.338]                         if (muffled) 
[16:20:44.338]                           invokeRestart("muffleWarning")
[16:20:44.338]                       }
[16:20:44.338]                       else if (inherits(cond, "condition")) {
[16:20:44.338]                         if (!is.null(pattern)) {
[16:20:44.338]                           computeRestarts <- base::computeRestarts
[16:20:44.338]                           grepl <- base::grepl
[16:20:44.338]                           restarts <- computeRestarts(cond)
[16:20:44.338]                           for (restart in restarts) {
[16:20:44.338]                             name <- restart$name
[16:20:44.338]                             if (is.null(name)) 
[16:20:44.338]                               next
[16:20:44.338]                             if (!grepl(pattern, name)) 
[16:20:44.338]                               next
[16:20:44.338]                             invokeRestart(restart)
[16:20:44.338]                             muffled <- TRUE
[16:20:44.338]                             break
[16:20:44.338]                           }
[16:20:44.338]                         }
[16:20:44.338]                       }
[16:20:44.338]                       invisible(muffled)
[16:20:44.338]                     }
[16:20:44.338]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.338]                   }
[16:20:44.338]                 }
[16:20:44.338]                 else {
[16:20:44.338]                   if (TRUE) {
[16:20:44.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.338]                     {
[16:20:44.338]                       inherits <- base::inherits
[16:20:44.338]                       invokeRestart <- base::invokeRestart
[16:20:44.338]                       is.null <- base::is.null
[16:20:44.338]                       muffled <- FALSE
[16:20:44.338]                       if (inherits(cond, "message")) {
[16:20:44.338]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.338]                         if (muffled) 
[16:20:44.338]                           invokeRestart("muffleMessage")
[16:20:44.338]                       }
[16:20:44.338]                       else if (inherits(cond, "warning")) {
[16:20:44.338]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.338]                         if (muffled) 
[16:20:44.338]                           invokeRestart("muffleWarning")
[16:20:44.338]                       }
[16:20:44.338]                       else if (inherits(cond, "condition")) {
[16:20:44.338]                         if (!is.null(pattern)) {
[16:20:44.338]                           computeRestarts <- base::computeRestarts
[16:20:44.338]                           grepl <- base::grepl
[16:20:44.338]                           restarts <- computeRestarts(cond)
[16:20:44.338]                           for (restart in restarts) {
[16:20:44.338]                             name <- restart$name
[16:20:44.338]                             if (is.null(name)) 
[16:20:44.338]                               next
[16:20:44.338]                             if (!grepl(pattern, name)) 
[16:20:44.338]                               next
[16:20:44.338]                             invokeRestart(restart)
[16:20:44.338]                             muffled <- TRUE
[16:20:44.338]                             break
[16:20:44.338]                           }
[16:20:44.338]                         }
[16:20:44.338]                       }
[16:20:44.338]                       invisible(muffled)
[16:20:44.338]                     }
[16:20:44.338]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.338]                   }
[16:20:44.338]                 }
[16:20:44.338]             }
[16:20:44.338]         }))
[16:20:44.338]     }, error = function(ex) {
[16:20:44.338]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.338]                 ...future.rng), started = ...future.startTime, 
[16:20:44.338]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.338]             version = "1.8"), class = "FutureResult")
[16:20:44.338]     }, finally = {
[16:20:44.338]         if (!identical(...future.workdir, getwd())) 
[16:20:44.338]             setwd(...future.workdir)
[16:20:44.338]         {
[16:20:44.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.338]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.338]             }
[16:20:44.338]             base::options(...future.oldOptions)
[16:20:44.338]             if (.Platform$OS.type == "windows") {
[16:20:44.338]                 old_names <- names(...future.oldEnvVars)
[16:20:44.338]                 envs <- base::Sys.getenv()
[16:20:44.338]                 names <- names(envs)
[16:20:44.338]                 common <- intersect(names, old_names)
[16:20:44.338]                 added <- setdiff(names, old_names)
[16:20:44.338]                 removed <- setdiff(old_names, names)
[16:20:44.338]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.338]                   envs[common]]
[16:20:44.338]                 NAMES <- toupper(changed)
[16:20:44.338]                 args <- list()
[16:20:44.338]                 for (kk in seq_along(NAMES)) {
[16:20:44.338]                   name <- changed[[kk]]
[16:20:44.338]                   NAME <- NAMES[[kk]]
[16:20:44.338]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.338]                     next
[16:20:44.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.338]                 }
[16:20:44.338]                 NAMES <- toupper(added)
[16:20:44.338]                 for (kk in seq_along(NAMES)) {
[16:20:44.338]                   name <- added[[kk]]
[16:20:44.338]                   NAME <- NAMES[[kk]]
[16:20:44.338]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.338]                     next
[16:20:44.338]                   args[[name]] <- ""
[16:20:44.338]                 }
[16:20:44.338]                 NAMES <- toupper(removed)
[16:20:44.338]                 for (kk in seq_along(NAMES)) {
[16:20:44.338]                   name <- removed[[kk]]
[16:20:44.338]                   NAME <- NAMES[[kk]]
[16:20:44.338]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.338]                     next
[16:20:44.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.338]                 }
[16:20:44.338]                 if (length(args) > 0) 
[16:20:44.338]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.338]             }
[16:20:44.338]             else {
[16:20:44.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.338]             }
[16:20:44.338]             {
[16:20:44.338]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.338]                   0L) {
[16:20:44.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.338]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.338]                   base::options(opts)
[16:20:44.338]                 }
[16:20:44.338]                 {
[16:20:44.338]                   {
[16:20:44.338]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.338]                     NULL
[16:20:44.338]                   }
[16:20:44.338]                   options(future.plan = NULL)
[16:20:44.338]                   if (is.na(NA_character_)) 
[16:20:44.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.338]                     .init = FALSE)
[16:20:44.338]                 }
[16:20:44.338]             }
[16:20:44.338]         }
[16:20:44.338]     })
[16:20:44.338]     if (TRUE) {
[16:20:44.338]         base::sink(type = "output", split = FALSE)
[16:20:44.338]         if (TRUE) {
[16:20:44.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.338]         }
[16:20:44.338]         else {
[16:20:44.338]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.338]         }
[16:20:44.338]         base::close(...future.stdout)
[16:20:44.338]         ...future.stdout <- NULL
[16:20:44.338]     }
[16:20:44.338]     ...future.result$conditions <- ...future.conditions
[16:20:44.338]     ...future.result$finished <- base::Sys.time()
[16:20:44.338]     ...future.result
[16:20:44.338] }
[16:20:44.341] MultisessionFuture started
[16:20:44.341] - Launch lazy future ... done
[16:20:44.341] run() for ‘MultisessionFuture’ ... done
[16:20:44.341] getGlobalsAndPackages() ...
[16:20:44.342] Searching for globals...
[16:20:44.342] - globals found: [1] ‘{’
[16:20:44.342] Searching for globals ... DONE
[16:20:44.342] Resolving globals: FALSE
[16:20:44.343] 
[16:20:44.343] 
[16:20:44.343] getGlobalsAndPackages() ... DONE
[16:20:44.343] run() for ‘Future’ ...
[16:20:44.343] - state: ‘created’
[16:20:44.343] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.357]   - Field: ‘node’
[16:20:44.357]   - Field: ‘label’
[16:20:44.357]   - Field: ‘local’
[16:20:44.357]   - Field: ‘owner’
[16:20:44.357]   - Field: ‘envir’
[16:20:44.357]   - Field: ‘workers’
[16:20:44.358]   - Field: ‘packages’
[16:20:44.358]   - Field: ‘gc’
[16:20:44.358]   - Field: ‘conditions’
[16:20:44.358]   - Field: ‘persistent’
[16:20:44.358]   - Field: ‘expr’
[16:20:44.358]   - Field: ‘uuid’
[16:20:44.358]   - Field: ‘seed’
[16:20:44.358]   - Field: ‘version’
[16:20:44.358]   - Field: ‘result’
[16:20:44.358]   - Field: ‘asynchronous’
[16:20:44.358]   - Field: ‘calls’
[16:20:44.359]   - Field: ‘globals’
[16:20:44.359]   - Field: ‘stdout’
[16:20:44.359]   - Field: ‘earlySignal’
[16:20:44.359]   - Field: ‘lazy’
[16:20:44.359]   - Field: ‘state’
[16:20:44.359] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.359] - Launch lazy future ...
[16:20:44.359] Packages needed by the future expression (n = 0): <none>
[16:20:44.359] Packages needed by future strategies (n = 0): <none>
[16:20:44.360] {
[16:20:44.360]     {
[16:20:44.360]         {
[16:20:44.360]             ...future.startTime <- base::Sys.time()
[16:20:44.360]             {
[16:20:44.360]                 {
[16:20:44.360]                   {
[16:20:44.360]                     {
[16:20:44.360]                       base::local({
[16:20:44.360]                         has_future <- base::requireNamespace("future", 
[16:20:44.360]                           quietly = TRUE)
[16:20:44.360]                         if (has_future) {
[16:20:44.360]                           ns <- base::getNamespace("future")
[16:20:44.360]                           version <- ns[[".package"]][["version"]]
[16:20:44.360]                           if (is.null(version)) 
[16:20:44.360]                             version <- utils::packageVersion("future")
[16:20:44.360]                         }
[16:20:44.360]                         else {
[16:20:44.360]                           version <- NULL
[16:20:44.360]                         }
[16:20:44.360]                         if (!has_future || version < "1.8.0") {
[16:20:44.360]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.360]                             "", base::R.version$version.string), 
[16:20:44.360]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.360]                               "release", "version")], collapse = " "), 
[16:20:44.360]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.360]                             info)
[16:20:44.360]                           info <- base::paste(info, collapse = "; ")
[16:20:44.360]                           if (!has_future) {
[16:20:44.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.360]                               info)
[16:20:44.360]                           }
[16:20:44.360]                           else {
[16:20:44.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.360]                               info, version)
[16:20:44.360]                           }
[16:20:44.360]                           base::stop(msg)
[16:20:44.360]                         }
[16:20:44.360]                       })
[16:20:44.360]                     }
[16:20:44.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.360]                     base::options(mc.cores = 1L)
[16:20:44.360]                   }
[16:20:44.360]                   ...future.strategy.old <- future::plan("list")
[16:20:44.360]                   options(future.plan = NULL)
[16:20:44.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.360]                 }
[16:20:44.360]                 ...future.workdir <- getwd()
[16:20:44.360]             }
[16:20:44.360]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.360]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.360]         }
[16:20:44.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.360]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.360]             base::names(...future.oldOptions))
[16:20:44.360]     }
[16:20:44.360]     if (FALSE) {
[16:20:44.360]     }
[16:20:44.360]     else {
[16:20:44.360]         if (TRUE) {
[16:20:44.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.360]                 open = "w")
[16:20:44.360]         }
[16:20:44.360]         else {
[16:20:44.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.360]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.360]         }
[16:20:44.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.360]             base::sink(type = "output", split = FALSE)
[16:20:44.360]             base::close(...future.stdout)
[16:20:44.360]         }, add = TRUE)
[16:20:44.360]     }
[16:20:44.360]     ...future.frame <- base::sys.nframe()
[16:20:44.360]     ...future.conditions <- base::list()
[16:20:44.360]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.360]     if (FALSE) {
[16:20:44.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.360]     }
[16:20:44.360]     ...future.result <- base::tryCatch({
[16:20:44.360]         base::withCallingHandlers({
[16:20:44.360]             ...future.value <- base::withVisible(base::local({
[16:20:44.360]                 ...future.makeSendCondition <- base::local({
[16:20:44.360]                   sendCondition <- NULL
[16:20:44.360]                   function(frame = 1L) {
[16:20:44.360]                     if (is.function(sendCondition)) 
[16:20:44.360]                       return(sendCondition)
[16:20:44.360]                     ns <- getNamespace("parallel")
[16:20:44.360]                     if (exists("sendData", mode = "function", 
[16:20:44.360]                       envir = ns)) {
[16:20:44.360]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.360]                         envir = ns)
[16:20:44.360]                       envir <- sys.frame(frame)
[16:20:44.360]                       master <- NULL
[16:20:44.360]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.360]                         !identical(envir, emptyenv())) {
[16:20:44.360]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.360]                           inherits = FALSE)) {
[16:20:44.360]                           master <- get("master", mode = "list", 
[16:20:44.360]                             envir = envir, inherits = FALSE)
[16:20:44.360]                           if (inherits(master, c("SOCKnode", 
[16:20:44.360]                             "SOCK0node"))) {
[16:20:44.360]                             sendCondition <<- function(cond) {
[16:20:44.360]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.360]                                 success = TRUE)
[16:20:44.360]                               parallel_sendData(master, data)
[16:20:44.360]                             }
[16:20:44.360]                             return(sendCondition)
[16:20:44.360]                           }
[16:20:44.360]                         }
[16:20:44.360]                         frame <- frame + 1L
[16:20:44.360]                         envir <- sys.frame(frame)
[16:20:44.360]                       }
[16:20:44.360]                     }
[16:20:44.360]                     sendCondition <<- function(cond) NULL
[16:20:44.360]                   }
[16:20:44.360]                 })
[16:20:44.360]                 withCallingHandlers({
[16:20:44.360]                   {
[16:20:44.360]                     4
[16:20:44.360]                   }
[16:20:44.360]                 }, immediateCondition = function(cond) {
[16:20:44.360]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.360]                   sendCondition(cond)
[16:20:44.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.360]                   {
[16:20:44.360]                     inherits <- base::inherits
[16:20:44.360]                     invokeRestart <- base::invokeRestart
[16:20:44.360]                     is.null <- base::is.null
[16:20:44.360]                     muffled <- FALSE
[16:20:44.360]                     if (inherits(cond, "message")) {
[16:20:44.360]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.360]                       if (muffled) 
[16:20:44.360]                         invokeRestart("muffleMessage")
[16:20:44.360]                     }
[16:20:44.360]                     else if (inherits(cond, "warning")) {
[16:20:44.360]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.360]                       if (muffled) 
[16:20:44.360]                         invokeRestart("muffleWarning")
[16:20:44.360]                     }
[16:20:44.360]                     else if (inherits(cond, "condition")) {
[16:20:44.360]                       if (!is.null(pattern)) {
[16:20:44.360]                         computeRestarts <- base::computeRestarts
[16:20:44.360]                         grepl <- base::grepl
[16:20:44.360]                         restarts <- computeRestarts(cond)
[16:20:44.360]                         for (restart in restarts) {
[16:20:44.360]                           name <- restart$name
[16:20:44.360]                           if (is.null(name)) 
[16:20:44.360]                             next
[16:20:44.360]                           if (!grepl(pattern, name)) 
[16:20:44.360]                             next
[16:20:44.360]                           invokeRestart(restart)
[16:20:44.360]                           muffled <- TRUE
[16:20:44.360]                           break
[16:20:44.360]                         }
[16:20:44.360]                       }
[16:20:44.360]                     }
[16:20:44.360]                     invisible(muffled)
[16:20:44.360]                   }
[16:20:44.360]                   muffleCondition(cond)
[16:20:44.360]                 })
[16:20:44.360]             }))
[16:20:44.360]             future::FutureResult(value = ...future.value$value, 
[16:20:44.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.360]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.360]                     ...future.globalenv.names))
[16:20:44.360]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.360]         }, condition = base::local({
[16:20:44.360]             c <- base::c
[16:20:44.360]             inherits <- base::inherits
[16:20:44.360]             invokeRestart <- base::invokeRestart
[16:20:44.360]             length <- base::length
[16:20:44.360]             list <- base::list
[16:20:44.360]             seq.int <- base::seq.int
[16:20:44.360]             signalCondition <- base::signalCondition
[16:20:44.360]             sys.calls <- base::sys.calls
[16:20:44.360]             `[[` <- base::`[[`
[16:20:44.360]             `+` <- base::`+`
[16:20:44.360]             `<<-` <- base::`<<-`
[16:20:44.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.360]                   3L)]
[16:20:44.360]             }
[16:20:44.360]             function(cond) {
[16:20:44.360]                 is_error <- inherits(cond, "error")
[16:20:44.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.360]                   NULL)
[16:20:44.360]                 if (is_error) {
[16:20:44.360]                   sessionInformation <- function() {
[16:20:44.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.360]                       search = base::search(), system = base::Sys.info())
[16:20:44.360]                   }
[16:20:44.360]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.360]                     cond$call), session = sessionInformation(), 
[16:20:44.360]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.360]                   signalCondition(cond)
[16:20:44.360]                 }
[16:20:44.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.360]                 "immediateCondition"))) {
[16:20:44.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.360]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.360]                   if (TRUE && !signal) {
[16:20:44.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.360]                     {
[16:20:44.360]                       inherits <- base::inherits
[16:20:44.360]                       invokeRestart <- base::invokeRestart
[16:20:44.360]                       is.null <- base::is.null
[16:20:44.360]                       muffled <- FALSE
[16:20:44.360]                       if (inherits(cond, "message")) {
[16:20:44.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.360]                         if (muffled) 
[16:20:44.360]                           invokeRestart("muffleMessage")
[16:20:44.360]                       }
[16:20:44.360]                       else if (inherits(cond, "warning")) {
[16:20:44.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.360]                         if (muffled) 
[16:20:44.360]                           invokeRestart("muffleWarning")
[16:20:44.360]                       }
[16:20:44.360]                       else if (inherits(cond, "condition")) {
[16:20:44.360]                         if (!is.null(pattern)) {
[16:20:44.360]                           computeRestarts <- base::computeRestarts
[16:20:44.360]                           grepl <- base::grepl
[16:20:44.360]                           restarts <- computeRestarts(cond)
[16:20:44.360]                           for (restart in restarts) {
[16:20:44.360]                             name <- restart$name
[16:20:44.360]                             if (is.null(name)) 
[16:20:44.360]                               next
[16:20:44.360]                             if (!grepl(pattern, name)) 
[16:20:44.360]                               next
[16:20:44.360]                             invokeRestart(restart)
[16:20:44.360]                             muffled <- TRUE
[16:20:44.360]                             break
[16:20:44.360]                           }
[16:20:44.360]                         }
[16:20:44.360]                       }
[16:20:44.360]                       invisible(muffled)
[16:20:44.360]                     }
[16:20:44.360]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.360]                   }
[16:20:44.360]                 }
[16:20:44.360]                 else {
[16:20:44.360]                   if (TRUE) {
[16:20:44.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.360]                     {
[16:20:44.360]                       inherits <- base::inherits
[16:20:44.360]                       invokeRestart <- base::invokeRestart
[16:20:44.360]                       is.null <- base::is.null
[16:20:44.360]                       muffled <- FALSE
[16:20:44.360]                       if (inherits(cond, "message")) {
[16:20:44.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.360]                         if (muffled) 
[16:20:44.360]                           invokeRestart("muffleMessage")
[16:20:44.360]                       }
[16:20:44.360]                       else if (inherits(cond, "warning")) {
[16:20:44.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.360]                         if (muffled) 
[16:20:44.360]                           invokeRestart("muffleWarning")
[16:20:44.360]                       }
[16:20:44.360]                       else if (inherits(cond, "condition")) {
[16:20:44.360]                         if (!is.null(pattern)) {
[16:20:44.360]                           computeRestarts <- base::computeRestarts
[16:20:44.360]                           grepl <- base::grepl
[16:20:44.360]                           restarts <- computeRestarts(cond)
[16:20:44.360]                           for (restart in restarts) {
[16:20:44.360]                             name <- restart$name
[16:20:44.360]                             if (is.null(name)) 
[16:20:44.360]                               next
[16:20:44.360]                             if (!grepl(pattern, name)) 
[16:20:44.360]                               next
[16:20:44.360]                             invokeRestart(restart)
[16:20:44.360]                             muffled <- TRUE
[16:20:44.360]                             break
[16:20:44.360]                           }
[16:20:44.360]                         }
[16:20:44.360]                       }
[16:20:44.360]                       invisible(muffled)
[16:20:44.360]                     }
[16:20:44.360]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.360]                   }
[16:20:44.360]                 }
[16:20:44.360]             }
[16:20:44.360]         }))
[16:20:44.360]     }, error = function(ex) {
[16:20:44.360]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.360]                 ...future.rng), started = ...future.startTime, 
[16:20:44.360]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.360]             version = "1.8"), class = "FutureResult")
[16:20:44.360]     }, finally = {
[16:20:44.360]         if (!identical(...future.workdir, getwd())) 
[16:20:44.360]             setwd(...future.workdir)
[16:20:44.360]         {
[16:20:44.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.360]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.360]             }
[16:20:44.360]             base::options(...future.oldOptions)
[16:20:44.360]             if (.Platform$OS.type == "windows") {
[16:20:44.360]                 old_names <- names(...future.oldEnvVars)
[16:20:44.360]                 envs <- base::Sys.getenv()
[16:20:44.360]                 names <- names(envs)
[16:20:44.360]                 common <- intersect(names, old_names)
[16:20:44.360]                 added <- setdiff(names, old_names)
[16:20:44.360]                 removed <- setdiff(old_names, names)
[16:20:44.360]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.360]                   envs[common]]
[16:20:44.360]                 NAMES <- toupper(changed)
[16:20:44.360]                 args <- list()
[16:20:44.360]                 for (kk in seq_along(NAMES)) {
[16:20:44.360]                   name <- changed[[kk]]
[16:20:44.360]                   NAME <- NAMES[[kk]]
[16:20:44.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.360]                     next
[16:20:44.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.360]                 }
[16:20:44.360]                 NAMES <- toupper(added)
[16:20:44.360]                 for (kk in seq_along(NAMES)) {
[16:20:44.360]                   name <- added[[kk]]
[16:20:44.360]                   NAME <- NAMES[[kk]]
[16:20:44.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.360]                     next
[16:20:44.360]                   args[[name]] <- ""
[16:20:44.360]                 }
[16:20:44.360]                 NAMES <- toupper(removed)
[16:20:44.360]                 for (kk in seq_along(NAMES)) {
[16:20:44.360]                   name <- removed[[kk]]
[16:20:44.360]                   NAME <- NAMES[[kk]]
[16:20:44.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.360]                     next
[16:20:44.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.360]                 }
[16:20:44.360]                 if (length(args) > 0) 
[16:20:44.360]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.360]             }
[16:20:44.360]             else {
[16:20:44.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.360]             }
[16:20:44.360]             {
[16:20:44.360]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.360]                   0L) {
[16:20:44.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.360]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.360]                   base::options(opts)
[16:20:44.360]                 }
[16:20:44.360]                 {
[16:20:44.360]                   {
[16:20:44.360]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.360]                     NULL
[16:20:44.360]                   }
[16:20:44.360]                   options(future.plan = NULL)
[16:20:44.360]                   if (is.na(NA_character_)) 
[16:20:44.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.360]                     .init = FALSE)
[16:20:44.360]                 }
[16:20:44.360]             }
[16:20:44.360]         }
[16:20:44.360]     })
[16:20:44.360]     if (TRUE) {
[16:20:44.360]         base::sink(type = "output", split = FALSE)
[16:20:44.360]         if (TRUE) {
[16:20:44.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.360]         }
[16:20:44.360]         else {
[16:20:44.360]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.360]         }
[16:20:44.360]         base::close(...future.stdout)
[16:20:44.360]         ...future.stdout <- NULL
[16:20:44.360]     }
[16:20:44.360]     ...future.result$conditions <- ...future.conditions
[16:20:44.360]     ...future.result$finished <- base::Sys.time()
[16:20:44.360]     ...future.result
[16:20:44.360] }
[16:20:44.362] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:44.373] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.373] - Validating connection of MultisessionFuture
[16:20:44.373] - received message: FutureResult
[16:20:44.373] - Received FutureResult
[16:20:44.373] - Erased future from FutureRegistry
[16:20:44.373] result() for ClusterFuture ...
[16:20:44.373] - result already collected: FutureResult
[16:20:44.374] result() for ClusterFuture ... done
[16:20:44.374] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.374] result() for ClusterFuture ...
[16:20:44.374] - result already collected: FutureResult
[16:20:44.374] result() for ClusterFuture ... done
[16:20:44.374] result() for ClusterFuture ...
[16:20:44.374] - result already collected: FutureResult
[16:20:44.374] result() for ClusterFuture ... done
[16:20:44.375] MultisessionFuture started
[16:20:44.375] - Launch lazy future ... done
[16:20:44.375] run() for ‘MultisessionFuture’ ... done
<environment: 0x55ed0dce64e8> 
<environment: 0x55ed0bed9ec0> 
[16:20:44.377] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.377] - Validating connection of MultisessionFuture
[16:20:44.377] - received message: FutureResult
[16:20:44.377] - Received FutureResult
[16:20:44.377] - Erased future from FutureRegistry
[16:20:44.378] result() for ClusterFuture ...
[16:20:44.378] - result already collected: FutureResult
[16:20:44.378] result() for ClusterFuture ... done
[16:20:44.378] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.378] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.378] - Validating connection of MultisessionFuture
[16:20:44.378] - received message: FutureResult
[16:20:44.379] - Received FutureResult
[16:20:44.379] - Erased future from FutureRegistry
[16:20:44.379] result() for ClusterFuture ...
[16:20:44.379] - result already collected: FutureResult
[16:20:44.379] result() for ClusterFuture ... done
[16:20:44.379] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:44.380] resolve() on environment ...
[16:20:44.380]  recursive: 0
[16:20:44.381]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:44.381] signalConditionsASAP(numeric, pos=1) ...
[16:20:44.381] - nx: 4
[16:20:44.381] - relay: TRUE
[16:20:44.381] - stdout: TRUE
[16:20:44.381] - signal: TRUE
[16:20:44.381] - resignal: FALSE
[16:20:44.381] - force: TRUE
[16:20:44.381] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.382] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.382]  - until=2
[16:20:44.382]  - relaying element #2
[16:20:44.382] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.382] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.382] signalConditionsASAP(NULL, pos=1) ... done
[16:20:44.382]  length: 3 (resolved future 1)
[16:20:44.382] Future #2
[16:20:44.382] result() for ClusterFuture ...
[16:20:44.382] - result already collected: FutureResult
[16:20:44.383] result() for ClusterFuture ... done
[16:20:44.383] result() for ClusterFuture ...
[16:20:44.383] - result already collected: FutureResult
[16:20:44.383] result() for ClusterFuture ... done
[16:20:44.383] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:44.383] - nx: 4
[16:20:44.383] - relay: TRUE
[16:20:44.383] - stdout: TRUE
[16:20:44.383] - signal: TRUE
[16:20:44.383] - resignal: FALSE
[16:20:44.383] - force: TRUE
[16:20:44.383] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.384] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.384]  - until=2
[16:20:44.384]  - relaying element #2
[16:20:44.384] result() for ClusterFuture ...
[16:20:44.384] - result already collected: FutureResult
[16:20:44.384] result() for ClusterFuture ... done
[16:20:44.384] result() for ClusterFuture ...
[16:20:44.384] - result already collected: FutureResult
[16:20:44.384] result() for ClusterFuture ... done
[16:20:44.384] result() for ClusterFuture ...
[16:20:44.385] - result already collected: FutureResult
[16:20:44.385] result() for ClusterFuture ... done
[16:20:44.385] result() for ClusterFuture ...
[16:20:44.385] - result already collected: FutureResult
[16:20:44.385] result() for ClusterFuture ... done
[16:20:44.385] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.385] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.385] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:44.385]  length: 2 (resolved future 2)
[16:20:44.385] Future #3
[16:20:44.385] result() for ClusterFuture ...
[16:20:44.386] - result already collected: FutureResult
[16:20:44.386] result() for ClusterFuture ... done
[16:20:44.386] result() for ClusterFuture ...
[16:20:44.386] - result already collected: FutureResult
[16:20:44.386] result() for ClusterFuture ... done
[16:20:44.386] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:44.386] - nx: 4
[16:20:44.386] - relay: TRUE
[16:20:44.386] - stdout: TRUE
[16:20:44.386] - signal: TRUE
[16:20:44.386] - resignal: FALSE
[16:20:44.386] - force: TRUE
[16:20:44.387] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.387] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.387]  - until=3
[16:20:44.387]  - relaying element #3
[16:20:44.387] result() for ClusterFuture ...
[16:20:44.387] - result already collected: FutureResult
[16:20:44.387] result() for ClusterFuture ... done
[16:20:44.387] result() for ClusterFuture ...
[16:20:44.387] - result already collected: FutureResult
[16:20:44.387] result() for ClusterFuture ... done
[16:20:44.387] result() for ClusterFuture ...
[16:20:44.388] - result already collected: FutureResult
[16:20:44.388] result() for ClusterFuture ... done
[16:20:44.388] result() for ClusterFuture ...
[16:20:44.388] - result already collected: FutureResult
[16:20:44.388] result() for ClusterFuture ... done
[16:20:44.388] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.388] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.388] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:44.388]  length: 1 (resolved future 3)
[16:20:44.388] Future #4
[16:20:44.388] result() for ClusterFuture ...
[16:20:44.389] - result already collected: FutureResult
[16:20:44.389] result() for ClusterFuture ... done
[16:20:44.389] result() for ClusterFuture ...
[16:20:44.389] - result already collected: FutureResult
[16:20:44.389] result() for ClusterFuture ... done
[16:20:44.389] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:44.389] - nx: 4
[16:20:44.389] - relay: TRUE
[16:20:44.389] - stdout: TRUE
[16:20:44.389] - signal: TRUE
[16:20:44.389] - resignal: FALSE
[16:20:44.390] - force: TRUE
[16:20:44.390] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.390] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.390]  - until=4
[16:20:44.390]  - relaying element #4
[16:20:44.390] result() for ClusterFuture ...
[16:20:44.390] - result already collected: FutureResult
[16:20:44.390] result() for ClusterFuture ... done
[16:20:44.390] result() for ClusterFuture ...
[16:20:44.390] - result already collected: FutureResult
[16:20:44.390] result() for ClusterFuture ... done
[16:20:44.391] result() for ClusterFuture ...
[16:20:44.391] - result already collected: FutureResult
[16:20:44.391] result() for ClusterFuture ... done
[16:20:44.391] result() for ClusterFuture ...
[16:20:44.391] - result already collected: FutureResult
[16:20:44.391] result() for ClusterFuture ... done
[16:20:44.391] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.391] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.391] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:44.391]  length: 0 (resolved future 4)
[16:20:44.391] Relaying remaining futures
[16:20:44.391] signalConditionsASAP(NULL, pos=0) ...
[16:20:44.392] - nx: 4
[16:20:44.392] - relay: TRUE
[16:20:44.392] - stdout: TRUE
[16:20:44.392] - signal: TRUE
[16:20:44.392] - resignal: FALSE
[16:20:44.392] - force: TRUE
[16:20:44.392] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.392] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:44.392] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.392] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.392] signalConditionsASAP(NULL, pos=0) ... done
[16:20:44.393] resolve() on environment ... DONE
[16:20:44.393] result() for ClusterFuture ...
[16:20:44.393] - result already collected: FutureResult
[16:20:44.393] result() for ClusterFuture ... done
[16:20:44.393] result() for ClusterFuture ...
[16:20:44.393] - result already collected: FutureResult
[16:20:44.393] result() for ClusterFuture ... done
[16:20:44.393] result() for ClusterFuture ...
[16:20:44.393] - result already collected: FutureResult
[16:20:44.393] result() for ClusterFuture ... done
[16:20:44.393] result() for ClusterFuture ...
[16:20:44.394] - result already collected: FutureResult
[16:20:44.394] result() for ClusterFuture ... done
[16:20:44.394] result() for ClusterFuture ...
[16:20:44.394] - result already collected: FutureResult
[16:20:44.394] result() for ClusterFuture ... done
[16:20:44.394] result() for ClusterFuture ...
[16:20:44.394] - result already collected: FutureResult
[16:20:44.394] result() for ClusterFuture ... done
<environment: 0x55ed0b4334f8> 
Dimensions: c(2, 3)
[16:20:44.394] getGlobalsAndPackages() ...
[16:20:44.395] Searching for globals...
[16:20:44.395] 
[16:20:44.395] Searching for globals ... DONE
[16:20:44.395] - globals: [0] <none>
[16:20:44.395] getGlobalsAndPackages() ... DONE
[16:20:44.395] run() for ‘Future’ ...
[16:20:44.395] - state: ‘created’
[16:20:44.396] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.410] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.410]   - Field: ‘node’
[16:20:44.410]   - Field: ‘label’
[16:20:44.410]   - Field: ‘local’
[16:20:44.410]   - Field: ‘owner’
[16:20:44.410]   - Field: ‘envir’
[16:20:44.410]   - Field: ‘workers’
[16:20:44.410]   - Field: ‘packages’
[16:20:44.411]   - Field: ‘gc’
[16:20:44.411]   - Field: ‘conditions’
[16:20:44.411]   - Field: ‘persistent’
[16:20:44.411]   - Field: ‘expr’
[16:20:44.411]   - Field: ‘uuid’
[16:20:44.411]   - Field: ‘seed’
[16:20:44.411]   - Field: ‘version’
[16:20:44.411]   - Field: ‘result’
[16:20:44.411]   - Field: ‘asynchronous’
[16:20:44.411]   - Field: ‘calls’
[16:20:44.411]   - Field: ‘globals’
[16:20:44.412]   - Field: ‘stdout’
[16:20:44.412]   - Field: ‘earlySignal’
[16:20:44.412]   - Field: ‘lazy’
[16:20:44.412]   - Field: ‘state’
[16:20:44.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.412] - Launch lazy future ...
[16:20:44.412] Packages needed by the future expression (n = 0): <none>
[16:20:44.413] Packages needed by future strategies (n = 0): <none>
[16:20:44.413] {
[16:20:44.413]     {
[16:20:44.413]         {
[16:20:44.413]             ...future.startTime <- base::Sys.time()
[16:20:44.413]             {
[16:20:44.413]                 {
[16:20:44.413]                   {
[16:20:44.413]                     {
[16:20:44.413]                       base::local({
[16:20:44.413]                         has_future <- base::requireNamespace("future", 
[16:20:44.413]                           quietly = TRUE)
[16:20:44.413]                         if (has_future) {
[16:20:44.413]                           ns <- base::getNamespace("future")
[16:20:44.413]                           version <- ns[[".package"]][["version"]]
[16:20:44.413]                           if (is.null(version)) 
[16:20:44.413]                             version <- utils::packageVersion("future")
[16:20:44.413]                         }
[16:20:44.413]                         else {
[16:20:44.413]                           version <- NULL
[16:20:44.413]                         }
[16:20:44.413]                         if (!has_future || version < "1.8.0") {
[16:20:44.413]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.413]                             "", base::R.version$version.string), 
[16:20:44.413]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.413]                               "release", "version")], collapse = " "), 
[16:20:44.413]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.413]                             info)
[16:20:44.413]                           info <- base::paste(info, collapse = "; ")
[16:20:44.413]                           if (!has_future) {
[16:20:44.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.413]                               info)
[16:20:44.413]                           }
[16:20:44.413]                           else {
[16:20:44.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.413]                               info, version)
[16:20:44.413]                           }
[16:20:44.413]                           base::stop(msg)
[16:20:44.413]                         }
[16:20:44.413]                       })
[16:20:44.413]                     }
[16:20:44.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.413]                     base::options(mc.cores = 1L)
[16:20:44.413]                   }
[16:20:44.413]                   ...future.strategy.old <- future::plan("list")
[16:20:44.413]                   options(future.plan = NULL)
[16:20:44.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.413]                 }
[16:20:44.413]                 ...future.workdir <- getwd()
[16:20:44.413]             }
[16:20:44.413]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.413]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.413]         }
[16:20:44.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.413]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.413]             base::names(...future.oldOptions))
[16:20:44.413]     }
[16:20:44.413]     if (FALSE) {
[16:20:44.413]     }
[16:20:44.413]     else {
[16:20:44.413]         if (TRUE) {
[16:20:44.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.413]                 open = "w")
[16:20:44.413]         }
[16:20:44.413]         else {
[16:20:44.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.413]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.413]         }
[16:20:44.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.413]             base::sink(type = "output", split = FALSE)
[16:20:44.413]             base::close(...future.stdout)
[16:20:44.413]         }, add = TRUE)
[16:20:44.413]     }
[16:20:44.413]     ...future.frame <- base::sys.nframe()
[16:20:44.413]     ...future.conditions <- base::list()
[16:20:44.413]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.413]     if (FALSE) {
[16:20:44.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.413]     }
[16:20:44.413]     ...future.result <- base::tryCatch({
[16:20:44.413]         base::withCallingHandlers({
[16:20:44.413]             ...future.value <- base::withVisible(base::local({
[16:20:44.413]                 ...future.makeSendCondition <- base::local({
[16:20:44.413]                   sendCondition <- NULL
[16:20:44.413]                   function(frame = 1L) {
[16:20:44.413]                     if (is.function(sendCondition)) 
[16:20:44.413]                       return(sendCondition)
[16:20:44.413]                     ns <- getNamespace("parallel")
[16:20:44.413]                     if (exists("sendData", mode = "function", 
[16:20:44.413]                       envir = ns)) {
[16:20:44.413]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.413]                         envir = ns)
[16:20:44.413]                       envir <- sys.frame(frame)
[16:20:44.413]                       master <- NULL
[16:20:44.413]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.413]                         !identical(envir, emptyenv())) {
[16:20:44.413]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.413]                           inherits = FALSE)) {
[16:20:44.413]                           master <- get("master", mode = "list", 
[16:20:44.413]                             envir = envir, inherits = FALSE)
[16:20:44.413]                           if (inherits(master, c("SOCKnode", 
[16:20:44.413]                             "SOCK0node"))) {
[16:20:44.413]                             sendCondition <<- function(cond) {
[16:20:44.413]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.413]                                 success = TRUE)
[16:20:44.413]                               parallel_sendData(master, data)
[16:20:44.413]                             }
[16:20:44.413]                             return(sendCondition)
[16:20:44.413]                           }
[16:20:44.413]                         }
[16:20:44.413]                         frame <- frame + 1L
[16:20:44.413]                         envir <- sys.frame(frame)
[16:20:44.413]                       }
[16:20:44.413]                     }
[16:20:44.413]                     sendCondition <<- function(cond) NULL
[16:20:44.413]                   }
[16:20:44.413]                 })
[16:20:44.413]                 withCallingHandlers({
[16:20:44.413]                   2
[16:20:44.413]                 }, immediateCondition = function(cond) {
[16:20:44.413]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.413]                   sendCondition(cond)
[16:20:44.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.413]                   {
[16:20:44.413]                     inherits <- base::inherits
[16:20:44.413]                     invokeRestart <- base::invokeRestart
[16:20:44.413]                     is.null <- base::is.null
[16:20:44.413]                     muffled <- FALSE
[16:20:44.413]                     if (inherits(cond, "message")) {
[16:20:44.413]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.413]                       if (muffled) 
[16:20:44.413]                         invokeRestart("muffleMessage")
[16:20:44.413]                     }
[16:20:44.413]                     else if (inherits(cond, "warning")) {
[16:20:44.413]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.413]                       if (muffled) 
[16:20:44.413]                         invokeRestart("muffleWarning")
[16:20:44.413]                     }
[16:20:44.413]                     else if (inherits(cond, "condition")) {
[16:20:44.413]                       if (!is.null(pattern)) {
[16:20:44.413]                         computeRestarts <- base::computeRestarts
[16:20:44.413]                         grepl <- base::grepl
[16:20:44.413]                         restarts <- computeRestarts(cond)
[16:20:44.413]                         for (restart in restarts) {
[16:20:44.413]                           name <- restart$name
[16:20:44.413]                           if (is.null(name)) 
[16:20:44.413]                             next
[16:20:44.413]                           if (!grepl(pattern, name)) 
[16:20:44.413]                             next
[16:20:44.413]                           invokeRestart(restart)
[16:20:44.413]                           muffled <- TRUE
[16:20:44.413]                           break
[16:20:44.413]                         }
[16:20:44.413]                       }
[16:20:44.413]                     }
[16:20:44.413]                     invisible(muffled)
[16:20:44.413]                   }
[16:20:44.413]                   muffleCondition(cond)
[16:20:44.413]                 })
[16:20:44.413]             }))
[16:20:44.413]             future::FutureResult(value = ...future.value$value, 
[16:20:44.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.413]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.413]                     ...future.globalenv.names))
[16:20:44.413]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.413]         }, condition = base::local({
[16:20:44.413]             c <- base::c
[16:20:44.413]             inherits <- base::inherits
[16:20:44.413]             invokeRestart <- base::invokeRestart
[16:20:44.413]             length <- base::length
[16:20:44.413]             list <- base::list
[16:20:44.413]             seq.int <- base::seq.int
[16:20:44.413]             signalCondition <- base::signalCondition
[16:20:44.413]             sys.calls <- base::sys.calls
[16:20:44.413]             `[[` <- base::`[[`
[16:20:44.413]             `+` <- base::`+`
[16:20:44.413]             `<<-` <- base::`<<-`
[16:20:44.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.413]                   3L)]
[16:20:44.413]             }
[16:20:44.413]             function(cond) {
[16:20:44.413]                 is_error <- inherits(cond, "error")
[16:20:44.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.413]                   NULL)
[16:20:44.413]                 if (is_error) {
[16:20:44.413]                   sessionInformation <- function() {
[16:20:44.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.413]                       search = base::search(), system = base::Sys.info())
[16:20:44.413]                   }
[16:20:44.413]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.413]                     cond$call), session = sessionInformation(), 
[16:20:44.413]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.413]                   signalCondition(cond)
[16:20:44.413]                 }
[16:20:44.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.413]                 "immediateCondition"))) {
[16:20:44.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.413]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.413]                   if (TRUE && !signal) {
[16:20:44.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.413]                     {
[16:20:44.413]                       inherits <- base::inherits
[16:20:44.413]                       invokeRestart <- base::invokeRestart
[16:20:44.413]                       is.null <- base::is.null
[16:20:44.413]                       muffled <- FALSE
[16:20:44.413]                       if (inherits(cond, "message")) {
[16:20:44.413]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.413]                         if (muffled) 
[16:20:44.413]                           invokeRestart("muffleMessage")
[16:20:44.413]                       }
[16:20:44.413]                       else if (inherits(cond, "warning")) {
[16:20:44.413]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.413]                         if (muffled) 
[16:20:44.413]                           invokeRestart("muffleWarning")
[16:20:44.413]                       }
[16:20:44.413]                       else if (inherits(cond, "condition")) {
[16:20:44.413]                         if (!is.null(pattern)) {
[16:20:44.413]                           computeRestarts <- base::computeRestarts
[16:20:44.413]                           grepl <- base::grepl
[16:20:44.413]                           restarts <- computeRestarts(cond)
[16:20:44.413]                           for (restart in restarts) {
[16:20:44.413]                             name <- restart$name
[16:20:44.413]                             if (is.null(name)) 
[16:20:44.413]                               next
[16:20:44.413]                             if (!grepl(pattern, name)) 
[16:20:44.413]                               next
[16:20:44.413]                             invokeRestart(restart)
[16:20:44.413]                             muffled <- TRUE
[16:20:44.413]                             break
[16:20:44.413]                           }
[16:20:44.413]                         }
[16:20:44.413]                       }
[16:20:44.413]                       invisible(muffled)
[16:20:44.413]                     }
[16:20:44.413]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.413]                   }
[16:20:44.413]                 }
[16:20:44.413]                 else {
[16:20:44.413]                   if (TRUE) {
[16:20:44.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.413]                     {
[16:20:44.413]                       inherits <- base::inherits
[16:20:44.413]                       invokeRestart <- base::invokeRestart
[16:20:44.413]                       is.null <- base::is.null
[16:20:44.413]                       muffled <- FALSE
[16:20:44.413]                       if (inherits(cond, "message")) {
[16:20:44.413]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.413]                         if (muffled) 
[16:20:44.413]                           invokeRestart("muffleMessage")
[16:20:44.413]                       }
[16:20:44.413]                       else if (inherits(cond, "warning")) {
[16:20:44.413]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.413]                         if (muffled) 
[16:20:44.413]                           invokeRestart("muffleWarning")
[16:20:44.413]                       }
[16:20:44.413]                       else if (inherits(cond, "condition")) {
[16:20:44.413]                         if (!is.null(pattern)) {
[16:20:44.413]                           computeRestarts <- base::computeRestarts
[16:20:44.413]                           grepl <- base::grepl
[16:20:44.413]                           restarts <- computeRestarts(cond)
[16:20:44.413]                           for (restart in restarts) {
[16:20:44.413]                             name <- restart$name
[16:20:44.413]                             if (is.null(name)) 
[16:20:44.413]                               next
[16:20:44.413]                             if (!grepl(pattern, name)) 
[16:20:44.413]                               next
[16:20:44.413]                             invokeRestart(restart)
[16:20:44.413]                             muffled <- TRUE
[16:20:44.413]                             break
[16:20:44.413]                           }
[16:20:44.413]                         }
[16:20:44.413]                       }
[16:20:44.413]                       invisible(muffled)
[16:20:44.413]                     }
[16:20:44.413]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.413]                   }
[16:20:44.413]                 }
[16:20:44.413]             }
[16:20:44.413]         }))
[16:20:44.413]     }, error = function(ex) {
[16:20:44.413]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.413]                 ...future.rng), started = ...future.startTime, 
[16:20:44.413]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.413]             version = "1.8"), class = "FutureResult")
[16:20:44.413]     }, finally = {
[16:20:44.413]         if (!identical(...future.workdir, getwd())) 
[16:20:44.413]             setwd(...future.workdir)
[16:20:44.413]         {
[16:20:44.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.413]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.413]             }
[16:20:44.413]             base::options(...future.oldOptions)
[16:20:44.413]             if (.Platform$OS.type == "windows") {
[16:20:44.413]                 old_names <- names(...future.oldEnvVars)
[16:20:44.413]                 envs <- base::Sys.getenv()
[16:20:44.413]                 names <- names(envs)
[16:20:44.413]                 common <- intersect(names, old_names)
[16:20:44.413]                 added <- setdiff(names, old_names)
[16:20:44.413]                 removed <- setdiff(old_names, names)
[16:20:44.413]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.413]                   envs[common]]
[16:20:44.413]                 NAMES <- toupper(changed)
[16:20:44.413]                 args <- list()
[16:20:44.413]                 for (kk in seq_along(NAMES)) {
[16:20:44.413]                   name <- changed[[kk]]
[16:20:44.413]                   NAME <- NAMES[[kk]]
[16:20:44.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.413]                     next
[16:20:44.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.413]                 }
[16:20:44.413]                 NAMES <- toupper(added)
[16:20:44.413]                 for (kk in seq_along(NAMES)) {
[16:20:44.413]                   name <- added[[kk]]
[16:20:44.413]                   NAME <- NAMES[[kk]]
[16:20:44.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.413]                     next
[16:20:44.413]                   args[[name]] <- ""
[16:20:44.413]                 }
[16:20:44.413]                 NAMES <- toupper(removed)
[16:20:44.413]                 for (kk in seq_along(NAMES)) {
[16:20:44.413]                   name <- removed[[kk]]
[16:20:44.413]                   NAME <- NAMES[[kk]]
[16:20:44.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.413]                     next
[16:20:44.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.413]                 }
[16:20:44.413]                 if (length(args) > 0) 
[16:20:44.413]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.413]             }
[16:20:44.413]             else {
[16:20:44.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.413]             }
[16:20:44.413]             {
[16:20:44.413]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.413]                   0L) {
[16:20:44.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.413]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.413]                   base::options(opts)
[16:20:44.413]                 }
[16:20:44.413]                 {
[16:20:44.413]                   {
[16:20:44.413]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.413]                     NULL
[16:20:44.413]                   }
[16:20:44.413]                   options(future.plan = NULL)
[16:20:44.413]                   if (is.na(NA_character_)) 
[16:20:44.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.413]                     .init = FALSE)
[16:20:44.413]                 }
[16:20:44.413]             }
[16:20:44.413]         }
[16:20:44.413]     })
[16:20:44.413]     if (TRUE) {
[16:20:44.413]         base::sink(type = "output", split = FALSE)
[16:20:44.413]         if (TRUE) {
[16:20:44.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.413]         }
[16:20:44.413]         else {
[16:20:44.413]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.413]         }
[16:20:44.413]         base::close(...future.stdout)
[16:20:44.413]         ...future.stdout <- NULL
[16:20:44.413]     }
[16:20:44.413]     ...future.result$conditions <- ...future.conditions
[16:20:44.413]     ...future.result$finished <- base::Sys.time()
[16:20:44.413]     ...future.result
[16:20:44.413] }
[16:20:44.416] MultisessionFuture started
[16:20:44.416] - Launch lazy future ... done
[16:20:44.416] run() for ‘MultisessionFuture’ ... done
[16:20:44.416] getGlobalsAndPackages() ...
[16:20:44.416] Searching for globals...
[16:20:44.416] 
[16:20:44.417] Searching for globals ... DONE
[16:20:44.417] - globals: [0] <none>
[16:20:44.417] getGlobalsAndPackages() ... DONE
[16:20:44.417] run() for ‘Future’ ...
[16:20:44.417] - state: ‘created’
[16:20:44.417] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.431] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.431] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.431]   - Field: ‘node’
[16:20:44.431]   - Field: ‘label’
[16:20:44.431]   - Field: ‘local’
[16:20:44.431]   - Field: ‘owner’
[16:20:44.431]   - Field: ‘envir’
[16:20:44.431]   - Field: ‘workers’
[16:20:44.431]   - Field: ‘packages’
[16:20:44.432]   - Field: ‘gc’
[16:20:44.432]   - Field: ‘conditions’
[16:20:44.432]   - Field: ‘persistent’
[16:20:44.432]   - Field: ‘expr’
[16:20:44.432]   - Field: ‘uuid’
[16:20:44.432]   - Field: ‘seed’
[16:20:44.432]   - Field: ‘version’
[16:20:44.432]   - Field: ‘result’
[16:20:44.432]   - Field: ‘asynchronous’
[16:20:44.432]   - Field: ‘calls’
[16:20:44.432]   - Field: ‘globals’
[16:20:44.433]   - Field: ‘stdout’
[16:20:44.433]   - Field: ‘earlySignal’
[16:20:44.433]   - Field: ‘lazy’
[16:20:44.433]   - Field: ‘state’
[16:20:44.433] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.433] - Launch lazy future ...
[16:20:44.433] Packages needed by the future expression (n = 0): <none>
[16:20:44.433] Packages needed by future strategies (n = 0): <none>
[16:20:44.434] {
[16:20:44.434]     {
[16:20:44.434]         {
[16:20:44.434]             ...future.startTime <- base::Sys.time()
[16:20:44.434]             {
[16:20:44.434]                 {
[16:20:44.434]                   {
[16:20:44.434]                     {
[16:20:44.434]                       base::local({
[16:20:44.434]                         has_future <- base::requireNamespace("future", 
[16:20:44.434]                           quietly = TRUE)
[16:20:44.434]                         if (has_future) {
[16:20:44.434]                           ns <- base::getNamespace("future")
[16:20:44.434]                           version <- ns[[".package"]][["version"]]
[16:20:44.434]                           if (is.null(version)) 
[16:20:44.434]                             version <- utils::packageVersion("future")
[16:20:44.434]                         }
[16:20:44.434]                         else {
[16:20:44.434]                           version <- NULL
[16:20:44.434]                         }
[16:20:44.434]                         if (!has_future || version < "1.8.0") {
[16:20:44.434]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.434]                             "", base::R.version$version.string), 
[16:20:44.434]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.434]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.434]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.434]                               "release", "version")], collapse = " "), 
[16:20:44.434]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.434]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.434]                             info)
[16:20:44.434]                           info <- base::paste(info, collapse = "; ")
[16:20:44.434]                           if (!has_future) {
[16:20:44.434]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.434]                               info)
[16:20:44.434]                           }
[16:20:44.434]                           else {
[16:20:44.434]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.434]                               info, version)
[16:20:44.434]                           }
[16:20:44.434]                           base::stop(msg)
[16:20:44.434]                         }
[16:20:44.434]                       })
[16:20:44.434]                     }
[16:20:44.434]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.434]                     base::options(mc.cores = 1L)
[16:20:44.434]                   }
[16:20:44.434]                   ...future.strategy.old <- future::plan("list")
[16:20:44.434]                   options(future.plan = NULL)
[16:20:44.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.434]                 }
[16:20:44.434]                 ...future.workdir <- getwd()
[16:20:44.434]             }
[16:20:44.434]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.434]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.434]         }
[16:20:44.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.434]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.434]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.434]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.434]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.434]             base::names(...future.oldOptions))
[16:20:44.434]     }
[16:20:44.434]     if (FALSE) {
[16:20:44.434]     }
[16:20:44.434]     else {
[16:20:44.434]         if (TRUE) {
[16:20:44.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.434]                 open = "w")
[16:20:44.434]         }
[16:20:44.434]         else {
[16:20:44.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.434]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.434]         }
[16:20:44.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.434]             base::sink(type = "output", split = FALSE)
[16:20:44.434]             base::close(...future.stdout)
[16:20:44.434]         }, add = TRUE)
[16:20:44.434]     }
[16:20:44.434]     ...future.frame <- base::sys.nframe()
[16:20:44.434]     ...future.conditions <- base::list()
[16:20:44.434]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.434]     if (FALSE) {
[16:20:44.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.434]     }
[16:20:44.434]     ...future.result <- base::tryCatch({
[16:20:44.434]         base::withCallingHandlers({
[16:20:44.434]             ...future.value <- base::withVisible(base::local({
[16:20:44.434]                 ...future.makeSendCondition <- base::local({
[16:20:44.434]                   sendCondition <- NULL
[16:20:44.434]                   function(frame = 1L) {
[16:20:44.434]                     if (is.function(sendCondition)) 
[16:20:44.434]                       return(sendCondition)
[16:20:44.434]                     ns <- getNamespace("parallel")
[16:20:44.434]                     if (exists("sendData", mode = "function", 
[16:20:44.434]                       envir = ns)) {
[16:20:44.434]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.434]                         envir = ns)
[16:20:44.434]                       envir <- sys.frame(frame)
[16:20:44.434]                       master <- NULL
[16:20:44.434]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.434]                         !identical(envir, emptyenv())) {
[16:20:44.434]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.434]                           inherits = FALSE)) {
[16:20:44.434]                           master <- get("master", mode = "list", 
[16:20:44.434]                             envir = envir, inherits = FALSE)
[16:20:44.434]                           if (inherits(master, c("SOCKnode", 
[16:20:44.434]                             "SOCK0node"))) {
[16:20:44.434]                             sendCondition <<- function(cond) {
[16:20:44.434]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.434]                                 success = TRUE)
[16:20:44.434]                               parallel_sendData(master, data)
[16:20:44.434]                             }
[16:20:44.434]                             return(sendCondition)
[16:20:44.434]                           }
[16:20:44.434]                         }
[16:20:44.434]                         frame <- frame + 1L
[16:20:44.434]                         envir <- sys.frame(frame)
[16:20:44.434]                       }
[16:20:44.434]                     }
[16:20:44.434]                     sendCondition <<- function(cond) NULL
[16:20:44.434]                   }
[16:20:44.434]                 })
[16:20:44.434]                 withCallingHandlers({
[16:20:44.434]                   NULL
[16:20:44.434]                 }, immediateCondition = function(cond) {
[16:20:44.434]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.434]                   sendCondition(cond)
[16:20:44.434]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.434]                   {
[16:20:44.434]                     inherits <- base::inherits
[16:20:44.434]                     invokeRestart <- base::invokeRestart
[16:20:44.434]                     is.null <- base::is.null
[16:20:44.434]                     muffled <- FALSE
[16:20:44.434]                     if (inherits(cond, "message")) {
[16:20:44.434]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.434]                       if (muffled) 
[16:20:44.434]                         invokeRestart("muffleMessage")
[16:20:44.434]                     }
[16:20:44.434]                     else if (inherits(cond, "warning")) {
[16:20:44.434]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.434]                       if (muffled) 
[16:20:44.434]                         invokeRestart("muffleWarning")
[16:20:44.434]                     }
[16:20:44.434]                     else if (inherits(cond, "condition")) {
[16:20:44.434]                       if (!is.null(pattern)) {
[16:20:44.434]                         computeRestarts <- base::computeRestarts
[16:20:44.434]                         grepl <- base::grepl
[16:20:44.434]                         restarts <- computeRestarts(cond)
[16:20:44.434]                         for (restart in restarts) {
[16:20:44.434]                           name <- restart$name
[16:20:44.434]                           if (is.null(name)) 
[16:20:44.434]                             next
[16:20:44.434]                           if (!grepl(pattern, name)) 
[16:20:44.434]                             next
[16:20:44.434]                           invokeRestart(restart)
[16:20:44.434]                           muffled <- TRUE
[16:20:44.434]                           break
[16:20:44.434]                         }
[16:20:44.434]                       }
[16:20:44.434]                     }
[16:20:44.434]                     invisible(muffled)
[16:20:44.434]                   }
[16:20:44.434]                   muffleCondition(cond)
[16:20:44.434]                 })
[16:20:44.434]             }))
[16:20:44.434]             future::FutureResult(value = ...future.value$value, 
[16:20:44.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.434]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.434]                     ...future.globalenv.names))
[16:20:44.434]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.434]         }, condition = base::local({
[16:20:44.434]             c <- base::c
[16:20:44.434]             inherits <- base::inherits
[16:20:44.434]             invokeRestart <- base::invokeRestart
[16:20:44.434]             length <- base::length
[16:20:44.434]             list <- base::list
[16:20:44.434]             seq.int <- base::seq.int
[16:20:44.434]             signalCondition <- base::signalCondition
[16:20:44.434]             sys.calls <- base::sys.calls
[16:20:44.434]             `[[` <- base::`[[`
[16:20:44.434]             `+` <- base::`+`
[16:20:44.434]             `<<-` <- base::`<<-`
[16:20:44.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.434]                   3L)]
[16:20:44.434]             }
[16:20:44.434]             function(cond) {
[16:20:44.434]                 is_error <- inherits(cond, "error")
[16:20:44.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.434]                   NULL)
[16:20:44.434]                 if (is_error) {
[16:20:44.434]                   sessionInformation <- function() {
[16:20:44.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.434]                       search = base::search(), system = base::Sys.info())
[16:20:44.434]                   }
[16:20:44.434]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.434]                     cond$call), session = sessionInformation(), 
[16:20:44.434]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.434]                   signalCondition(cond)
[16:20:44.434]                 }
[16:20:44.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.434]                 "immediateCondition"))) {
[16:20:44.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.434]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.434]                   if (TRUE && !signal) {
[16:20:44.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.434]                     {
[16:20:44.434]                       inherits <- base::inherits
[16:20:44.434]                       invokeRestart <- base::invokeRestart
[16:20:44.434]                       is.null <- base::is.null
[16:20:44.434]                       muffled <- FALSE
[16:20:44.434]                       if (inherits(cond, "message")) {
[16:20:44.434]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.434]                         if (muffled) 
[16:20:44.434]                           invokeRestart("muffleMessage")
[16:20:44.434]                       }
[16:20:44.434]                       else if (inherits(cond, "warning")) {
[16:20:44.434]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.434]                         if (muffled) 
[16:20:44.434]                           invokeRestart("muffleWarning")
[16:20:44.434]                       }
[16:20:44.434]                       else if (inherits(cond, "condition")) {
[16:20:44.434]                         if (!is.null(pattern)) {
[16:20:44.434]                           computeRestarts <- base::computeRestarts
[16:20:44.434]                           grepl <- base::grepl
[16:20:44.434]                           restarts <- computeRestarts(cond)
[16:20:44.434]                           for (restart in restarts) {
[16:20:44.434]                             name <- restart$name
[16:20:44.434]                             if (is.null(name)) 
[16:20:44.434]                               next
[16:20:44.434]                             if (!grepl(pattern, name)) 
[16:20:44.434]                               next
[16:20:44.434]                             invokeRestart(restart)
[16:20:44.434]                             muffled <- TRUE
[16:20:44.434]                             break
[16:20:44.434]                           }
[16:20:44.434]                         }
[16:20:44.434]                       }
[16:20:44.434]                       invisible(muffled)
[16:20:44.434]                     }
[16:20:44.434]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.434]                   }
[16:20:44.434]                 }
[16:20:44.434]                 else {
[16:20:44.434]                   if (TRUE) {
[16:20:44.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.434]                     {
[16:20:44.434]                       inherits <- base::inherits
[16:20:44.434]                       invokeRestart <- base::invokeRestart
[16:20:44.434]                       is.null <- base::is.null
[16:20:44.434]                       muffled <- FALSE
[16:20:44.434]                       if (inherits(cond, "message")) {
[16:20:44.434]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.434]                         if (muffled) 
[16:20:44.434]                           invokeRestart("muffleMessage")
[16:20:44.434]                       }
[16:20:44.434]                       else if (inherits(cond, "warning")) {
[16:20:44.434]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.434]                         if (muffled) 
[16:20:44.434]                           invokeRestart("muffleWarning")
[16:20:44.434]                       }
[16:20:44.434]                       else if (inherits(cond, "condition")) {
[16:20:44.434]                         if (!is.null(pattern)) {
[16:20:44.434]                           computeRestarts <- base::computeRestarts
[16:20:44.434]                           grepl <- base::grepl
[16:20:44.434]                           restarts <- computeRestarts(cond)
[16:20:44.434]                           for (restart in restarts) {
[16:20:44.434]                             name <- restart$name
[16:20:44.434]                             if (is.null(name)) 
[16:20:44.434]                               next
[16:20:44.434]                             if (!grepl(pattern, name)) 
[16:20:44.434]                               next
[16:20:44.434]                             invokeRestart(restart)
[16:20:44.434]                             muffled <- TRUE
[16:20:44.434]                             break
[16:20:44.434]                           }
[16:20:44.434]                         }
[16:20:44.434]                       }
[16:20:44.434]                       invisible(muffled)
[16:20:44.434]                     }
[16:20:44.434]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.434]                   }
[16:20:44.434]                 }
[16:20:44.434]             }
[16:20:44.434]         }))
[16:20:44.434]     }, error = function(ex) {
[16:20:44.434]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.434]                 ...future.rng), started = ...future.startTime, 
[16:20:44.434]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.434]             version = "1.8"), class = "FutureResult")
[16:20:44.434]     }, finally = {
[16:20:44.434]         if (!identical(...future.workdir, getwd())) 
[16:20:44.434]             setwd(...future.workdir)
[16:20:44.434]         {
[16:20:44.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.434]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.434]             }
[16:20:44.434]             base::options(...future.oldOptions)
[16:20:44.434]             if (.Platform$OS.type == "windows") {
[16:20:44.434]                 old_names <- names(...future.oldEnvVars)
[16:20:44.434]                 envs <- base::Sys.getenv()
[16:20:44.434]                 names <- names(envs)
[16:20:44.434]                 common <- intersect(names, old_names)
[16:20:44.434]                 added <- setdiff(names, old_names)
[16:20:44.434]                 removed <- setdiff(old_names, names)
[16:20:44.434]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.434]                   envs[common]]
[16:20:44.434]                 NAMES <- toupper(changed)
[16:20:44.434]                 args <- list()
[16:20:44.434]                 for (kk in seq_along(NAMES)) {
[16:20:44.434]                   name <- changed[[kk]]
[16:20:44.434]                   NAME <- NAMES[[kk]]
[16:20:44.434]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.434]                     next
[16:20:44.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.434]                 }
[16:20:44.434]                 NAMES <- toupper(added)
[16:20:44.434]                 for (kk in seq_along(NAMES)) {
[16:20:44.434]                   name <- added[[kk]]
[16:20:44.434]                   NAME <- NAMES[[kk]]
[16:20:44.434]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.434]                     next
[16:20:44.434]                   args[[name]] <- ""
[16:20:44.434]                 }
[16:20:44.434]                 NAMES <- toupper(removed)
[16:20:44.434]                 for (kk in seq_along(NAMES)) {
[16:20:44.434]                   name <- removed[[kk]]
[16:20:44.434]                   NAME <- NAMES[[kk]]
[16:20:44.434]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.434]                     next
[16:20:44.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.434]                 }
[16:20:44.434]                 if (length(args) > 0) 
[16:20:44.434]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.434]             }
[16:20:44.434]             else {
[16:20:44.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.434]             }
[16:20:44.434]             {
[16:20:44.434]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.434]                   0L) {
[16:20:44.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.434]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.434]                   base::options(opts)
[16:20:44.434]                 }
[16:20:44.434]                 {
[16:20:44.434]                   {
[16:20:44.434]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.434]                     NULL
[16:20:44.434]                   }
[16:20:44.434]                   options(future.plan = NULL)
[16:20:44.434]                   if (is.na(NA_character_)) 
[16:20:44.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.434]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.434]                     .init = FALSE)
[16:20:44.434]                 }
[16:20:44.434]             }
[16:20:44.434]         }
[16:20:44.434]     })
[16:20:44.434]     if (TRUE) {
[16:20:44.434]         base::sink(type = "output", split = FALSE)
[16:20:44.434]         if (TRUE) {
[16:20:44.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.434]         }
[16:20:44.434]         else {
[16:20:44.434]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.434]         }
[16:20:44.434]         base::close(...future.stdout)
[16:20:44.434]         ...future.stdout <- NULL
[16:20:44.434]     }
[16:20:44.434]     ...future.result$conditions <- ...future.conditions
[16:20:44.434]     ...future.result$finished <- base::Sys.time()
[16:20:44.434]     ...future.result
[16:20:44.434] }
[16:20:44.437] MultisessionFuture started
[16:20:44.437] - Launch lazy future ... done
[16:20:44.437] run() for ‘MultisessionFuture’ ... done
[16:20:44.437] getGlobalsAndPackages() ...
[16:20:44.437] Searching for globals...
[16:20:44.438] - globals found: [1] ‘{’
[16:20:44.438] Searching for globals ... DONE
[16:20:44.438] Resolving globals: FALSE
[16:20:44.438] 
[16:20:44.438] 
[16:20:44.439] getGlobalsAndPackages() ... DONE
[16:20:44.439] run() for ‘Future’ ...
[16:20:44.439] - state: ‘created’
[16:20:44.439] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.453]   - Field: ‘node’
[16:20:44.453]   - Field: ‘label’
[16:20:44.453]   - Field: ‘local’
[16:20:44.453]   - Field: ‘owner’
[16:20:44.453]   - Field: ‘envir’
[16:20:44.453]   - Field: ‘workers’
[16:20:44.453]   - Field: ‘packages’
[16:20:44.453]   - Field: ‘gc’
[16:20:44.454]   - Field: ‘conditions’
[16:20:44.454]   - Field: ‘persistent’
[16:20:44.454]   - Field: ‘expr’
[16:20:44.454]   - Field: ‘uuid’
[16:20:44.454]   - Field: ‘seed’
[16:20:44.454]   - Field: ‘version’
[16:20:44.454]   - Field: ‘result’
[16:20:44.454]   - Field: ‘asynchronous’
[16:20:44.454]   - Field: ‘calls’
[16:20:44.454]   - Field: ‘globals’
[16:20:44.454]   - Field: ‘stdout’
[16:20:44.455]   - Field: ‘earlySignal’
[16:20:44.455]   - Field: ‘lazy’
[16:20:44.455]   - Field: ‘state’
[16:20:44.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.455] - Launch lazy future ...
[16:20:44.455] Packages needed by the future expression (n = 0): <none>
[16:20:44.455] Packages needed by future strategies (n = 0): <none>
[16:20:44.456] {
[16:20:44.456]     {
[16:20:44.456]         {
[16:20:44.456]             ...future.startTime <- base::Sys.time()
[16:20:44.456]             {
[16:20:44.456]                 {
[16:20:44.456]                   {
[16:20:44.456]                     {
[16:20:44.456]                       base::local({
[16:20:44.456]                         has_future <- base::requireNamespace("future", 
[16:20:44.456]                           quietly = TRUE)
[16:20:44.456]                         if (has_future) {
[16:20:44.456]                           ns <- base::getNamespace("future")
[16:20:44.456]                           version <- ns[[".package"]][["version"]]
[16:20:44.456]                           if (is.null(version)) 
[16:20:44.456]                             version <- utils::packageVersion("future")
[16:20:44.456]                         }
[16:20:44.456]                         else {
[16:20:44.456]                           version <- NULL
[16:20:44.456]                         }
[16:20:44.456]                         if (!has_future || version < "1.8.0") {
[16:20:44.456]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.456]                             "", base::R.version$version.string), 
[16:20:44.456]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.456]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.456]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.456]                               "release", "version")], collapse = " "), 
[16:20:44.456]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.456]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.456]                             info)
[16:20:44.456]                           info <- base::paste(info, collapse = "; ")
[16:20:44.456]                           if (!has_future) {
[16:20:44.456]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.456]                               info)
[16:20:44.456]                           }
[16:20:44.456]                           else {
[16:20:44.456]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.456]                               info, version)
[16:20:44.456]                           }
[16:20:44.456]                           base::stop(msg)
[16:20:44.456]                         }
[16:20:44.456]                       })
[16:20:44.456]                     }
[16:20:44.456]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.456]                     base::options(mc.cores = 1L)
[16:20:44.456]                   }
[16:20:44.456]                   ...future.strategy.old <- future::plan("list")
[16:20:44.456]                   options(future.plan = NULL)
[16:20:44.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.456]                 }
[16:20:44.456]                 ...future.workdir <- getwd()
[16:20:44.456]             }
[16:20:44.456]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.456]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.456]         }
[16:20:44.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.456]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.456]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.456]             base::names(...future.oldOptions))
[16:20:44.456]     }
[16:20:44.456]     if (FALSE) {
[16:20:44.456]     }
[16:20:44.456]     else {
[16:20:44.456]         if (TRUE) {
[16:20:44.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.456]                 open = "w")
[16:20:44.456]         }
[16:20:44.456]         else {
[16:20:44.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.456]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.456]         }
[16:20:44.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.456]             base::sink(type = "output", split = FALSE)
[16:20:44.456]             base::close(...future.stdout)
[16:20:44.456]         }, add = TRUE)
[16:20:44.456]     }
[16:20:44.456]     ...future.frame <- base::sys.nframe()
[16:20:44.456]     ...future.conditions <- base::list()
[16:20:44.456]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.456]     if (FALSE) {
[16:20:44.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.456]     }
[16:20:44.456]     ...future.result <- base::tryCatch({
[16:20:44.456]         base::withCallingHandlers({
[16:20:44.456]             ...future.value <- base::withVisible(base::local({
[16:20:44.456]                 ...future.makeSendCondition <- base::local({
[16:20:44.456]                   sendCondition <- NULL
[16:20:44.456]                   function(frame = 1L) {
[16:20:44.456]                     if (is.function(sendCondition)) 
[16:20:44.456]                       return(sendCondition)
[16:20:44.456]                     ns <- getNamespace("parallel")
[16:20:44.456]                     if (exists("sendData", mode = "function", 
[16:20:44.456]                       envir = ns)) {
[16:20:44.456]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.456]                         envir = ns)
[16:20:44.456]                       envir <- sys.frame(frame)
[16:20:44.456]                       master <- NULL
[16:20:44.456]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.456]                         !identical(envir, emptyenv())) {
[16:20:44.456]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.456]                           inherits = FALSE)) {
[16:20:44.456]                           master <- get("master", mode = "list", 
[16:20:44.456]                             envir = envir, inherits = FALSE)
[16:20:44.456]                           if (inherits(master, c("SOCKnode", 
[16:20:44.456]                             "SOCK0node"))) {
[16:20:44.456]                             sendCondition <<- function(cond) {
[16:20:44.456]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.456]                                 success = TRUE)
[16:20:44.456]                               parallel_sendData(master, data)
[16:20:44.456]                             }
[16:20:44.456]                             return(sendCondition)
[16:20:44.456]                           }
[16:20:44.456]                         }
[16:20:44.456]                         frame <- frame + 1L
[16:20:44.456]                         envir <- sys.frame(frame)
[16:20:44.456]                       }
[16:20:44.456]                     }
[16:20:44.456]                     sendCondition <<- function(cond) NULL
[16:20:44.456]                   }
[16:20:44.456]                 })
[16:20:44.456]                 withCallingHandlers({
[16:20:44.456]                   {
[16:20:44.456]                     4
[16:20:44.456]                   }
[16:20:44.456]                 }, immediateCondition = function(cond) {
[16:20:44.456]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.456]                   sendCondition(cond)
[16:20:44.456]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.456]                   {
[16:20:44.456]                     inherits <- base::inherits
[16:20:44.456]                     invokeRestart <- base::invokeRestart
[16:20:44.456]                     is.null <- base::is.null
[16:20:44.456]                     muffled <- FALSE
[16:20:44.456]                     if (inherits(cond, "message")) {
[16:20:44.456]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.456]                       if (muffled) 
[16:20:44.456]                         invokeRestart("muffleMessage")
[16:20:44.456]                     }
[16:20:44.456]                     else if (inherits(cond, "warning")) {
[16:20:44.456]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.456]                       if (muffled) 
[16:20:44.456]                         invokeRestart("muffleWarning")
[16:20:44.456]                     }
[16:20:44.456]                     else if (inherits(cond, "condition")) {
[16:20:44.456]                       if (!is.null(pattern)) {
[16:20:44.456]                         computeRestarts <- base::computeRestarts
[16:20:44.456]                         grepl <- base::grepl
[16:20:44.456]                         restarts <- computeRestarts(cond)
[16:20:44.456]                         for (restart in restarts) {
[16:20:44.456]                           name <- restart$name
[16:20:44.456]                           if (is.null(name)) 
[16:20:44.456]                             next
[16:20:44.456]                           if (!grepl(pattern, name)) 
[16:20:44.456]                             next
[16:20:44.456]                           invokeRestart(restart)
[16:20:44.456]                           muffled <- TRUE
[16:20:44.456]                           break
[16:20:44.456]                         }
[16:20:44.456]                       }
[16:20:44.456]                     }
[16:20:44.456]                     invisible(muffled)
[16:20:44.456]                   }
[16:20:44.456]                   muffleCondition(cond)
[16:20:44.456]                 })
[16:20:44.456]             }))
[16:20:44.456]             future::FutureResult(value = ...future.value$value, 
[16:20:44.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.456]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.456]                     ...future.globalenv.names))
[16:20:44.456]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.456]         }, condition = base::local({
[16:20:44.456]             c <- base::c
[16:20:44.456]             inherits <- base::inherits
[16:20:44.456]             invokeRestart <- base::invokeRestart
[16:20:44.456]             length <- base::length
[16:20:44.456]             list <- base::list
[16:20:44.456]             seq.int <- base::seq.int
[16:20:44.456]             signalCondition <- base::signalCondition
[16:20:44.456]             sys.calls <- base::sys.calls
[16:20:44.456]             `[[` <- base::`[[`
[16:20:44.456]             `+` <- base::`+`
[16:20:44.456]             `<<-` <- base::`<<-`
[16:20:44.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.456]                   3L)]
[16:20:44.456]             }
[16:20:44.456]             function(cond) {
[16:20:44.456]                 is_error <- inherits(cond, "error")
[16:20:44.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.456]                   NULL)
[16:20:44.456]                 if (is_error) {
[16:20:44.456]                   sessionInformation <- function() {
[16:20:44.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.456]                       search = base::search(), system = base::Sys.info())
[16:20:44.456]                   }
[16:20:44.456]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.456]                     cond$call), session = sessionInformation(), 
[16:20:44.456]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.456]                   signalCondition(cond)
[16:20:44.456]                 }
[16:20:44.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.456]                 "immediateCondition"))) {
[16:20:44.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.456]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.456]                   if (TRUE && !signal) {
[16:20:44.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.456]                     {
[16:20:44.456]                       inherits <- base::inherits
[16:20:44.456]                       invokeRestart <- base::invokeRestart
[16:20:44.456]                       is.null <- base::is.null
[16:20:44.456]                       muffled <- FALSE
[16:20:44.456]                       if (inherits(cond, "message")) {
[16:20:44.456]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.456]                         if (muffled) 
[16:20:44.456]                           invokeRestart("muffleMessage")
[16:20:44.456]                       }
[16:20:44.456]                       else if (inherits(cond, "warning")) {
[16:20:44.456]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.456]                         if (muffled) 
[16:20:44.456]                           invokeRestart("muffleWarning")
[16:20:44.456]                       }
[16:20:44.456]                       else if (inherits(cond, "condition")) {
[16:20:44.456]                         if (!is.null(pattern)) {
[16:20:44.456]                           computeRestarts <- base::computeRestarts
[16:20:44.456]                           grepl <- base::grepl
[16:20:44.456]                           restarts <- computeRestarts(cond)
[16:20:44.456]                           for (restart in restarts) {
[16:20:44.456]                             name <- restart$name
[16:20:44.456]                             if (is.null(name)) 
[16:20:44.456]                               next
[16:20:44.456]                             if (!grepl(pattern, name)) 
[16:20:44.456]                               next
[16:20:44.456]                             invokeRestart(restart)
[16:20:44.456]                             muffled <- TRUE
[16:20:44.456]                             break
[16:20:44.456]                           }
[16:20:44.456]                         }
[16:20:44.456]                       }
[16:20:44.456]                       invisible(muffled)
[16:20:44.456]                     }
[16:20:44.456]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.456]                   }
[16:20:44.456]                 }
[16:20:44.456]                 else {
[16:20:44.456]                   if (TRUE) {
[16:20:44.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.456]                     {
[16:20:44.456]                       inherits <- base::inherits
[16:20:44.456]                       invokeRestart <- base::invokeRestart
[16:20:44.456]                       is.null <- base::is.null
[16:20:44.456]                       muffled <- FALSE
[16:20:44.456]                       if (inherits(cond, "message")) {
[16:20:44.456]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.456]                         if (muffled) 
[16:20:44.456]                           invokeRestart("muffleMessage")
[16:20:44.456]                       }
[16:20:44.456]                       else if (inherits(cond, "warning")) {
[16:20:44.456]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.456]                         if (muffled) 
[16:20:44.456]                           invokeRestart("muffleWarning")
[16:20:44.456]                       }
[16:20:44.456]                       else if (inherits(cond, "condition")) {
[16:20:44.456]                         if (!is.null(pattern)) {
[16:20:44.456]                           computeRestarts <- base::computeRestarts
[16:20:44.456]                           grepl <- base::grepl
[16:20:44.456]                           restarts <- computeRestarts(cond)
[16:20:44.456]                           for (restart in restarts) {
[16:20:44.456]                             name <- restart$name
[16:20:44.456]                             if (is.null(name)) 
[16:20:44.456]                               next
[16:20:44.456]                             if (!grepl(pattern, name)) 
[16:20:44.456]                               next
[16:20:44.456]                             invokeRestart(restart)
[16:20:44.456]                             muffled <- TRUE
[16:20:44.456]                             break
[16:20:44.456]                           }
[16:20:44.456]                         }
[16:20:44.456]                       }
[16:20:44.456]                       invisible(muffled)
[16:20:44.456]                     }
[16:20:44.456]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.456]                   }
[16:20:44.456]                 }
[16:20:44.456]             }
[16:20:44.456]         }))
[16:20:44.456]     }, error = function(ex) {
[16:20:44.456]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.456]                 ...future.rng), started = ...future.startTime, 
[16:20:44.456]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.456]             version = "1.8"), class = "FutureResult")
[16:20:44.456]     }, finally = {
[16:20:44.456]         if (!identical(...future.workdir, getwd())) 
[16:20:44.456]             setwd(...future.workdir)
[16:20:44.456]         {
[16:20:44.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.456]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.456]             }
[16:20:44.456]             base::options(...future.oldOptions)
[16:20:44.456]             if (.Platform$OS.type == "windows") {
[16:20:44.456]                 old_names <- names(...future.oldEnvVars)
[16:20:44.456]                 envs <- base::Sys.getenv()
[16:20:44.456]                 names <- names(envs)
[16:20:44.456]                 common <- intersect(names, old_names)
[16:20:44.456]                 added <- setdiff(names, old_names)
[16:20:44.456]                 removed <- setdiff(old_names, names)
[16:20:44.456]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.456]                   envs[common]]
[16:20:44.456]                 NAMES <- toupper(changed)
[16:20:44.456]                 args <- list()
[16:20:44.456]                 for (kk in seq_along(NAMES)) {
[16:20:44.456]                   name <- changed[[kk]]
[16:20:44.456]                   NAME <- NAMES[[kk]]
[16:20:44.456]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.456]                     next
[16:20:44.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.456]                 }
[16:20:44.456]                 NAMES <- toupper(added)
[16:20:44.456]                 for (kk in seq_along(NAMES)) {
[16:20:44.456]                   name <- added[[kk]]
[16:20:44.456]                   NAME <- NAMES[[kk]]
[16:20:44.456]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.456]                     next
[16:20:44.456]                   args[[name]] <- ""
[16:20:44.456]                 }
[16:20:44.456]                 NAMES <- toupper(removed)
[16:20:44.456]                 for (kk in seq_along(NAMES)) {
[16:20:44.456]                   name <- removed[[kk]]
[16:20:44.456]                   NAME <- NAMES[[kk]]
[16:20:44.456]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.456]                     next
[16:20:44.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.456]                 }
[16:20:44.456]                 if (length(args) > 0) 
[16:20:44.456]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.456]             }
[16:20:44.456]             else {
[16:20:44.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.456]             }
[16:20:44.456]             {
[16:20:44.456]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.456]                   0L) {
[16:20:44.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.456]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.456]                   base::options(opts)
[16:20:44.456]                 }
[16:20:44.456]                 {
[16:20:44.456]                   {
[16:20:44.456]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.456]                     NULL
[16:20:44.456]                   }
[16:20:44.456]                   options(future.plan = NULL)
[16:20:44.456]                   if (is.na(NA_character_)) 
[16:20:44.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.456]                     .init = FALSE)
[16:20:44.456]                 }
[16:20:44.456]             }
[16:20:44.456]         }
[16:20:44.456]     })
[16:20:44.456]     if (TRUE) {
[16:20:44.456]         base::sink(type = "output", split = FALSE)
[16:20:44.456]         if (TRUE) {
[16:20:44.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.456]         }
[16:20:44.456]         else {
[16:20:44.456]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.456]         }
[16:20:44.456]         base::close(...future.stdout)
[16:20:44.456]         ...future.stdout <- NULL
[16:20:44.456]     }
[16:20:44.456]     ...future.result$conditions <- ...future.conditions
[16:20:44.456]     ...future.result$finished <- base::Sys.time()
[16:20:44.456]     ...future.result
[16:20:44.456] }
[16:20:44.458] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:44.469] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.469] - Validating connection of MultisessionFuture
[16:20:44.469] - received message: FutureResult
[16:20:44.469] - Received FutureResult
[16:20:44.469] - Erased future from FutureRegistry
[16:20:44.469] result() for ClusterFuture ...
[16:20:44.469] - result already collected: FutureResult
[16:20:44.469] result() for ClusterFuture ... done
[16:20:44.470] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.470] result() for ClusterFuture ...
[16:20:44.470] - result already collected: FutureResult
[16:20:44.470] result() for ClusterFuture ... done
[16:20:44.470] result() for ClusterFuture ...
[16:20:44.470] - result already collected: FutureResult
[16:20:44.470] result() for ClusterFuture ... done
[16:20:44.471] MultisessionFuture started
[16:20:44.471] - Launch lazy future ... done
[16:20:44.471] run() for ‘MultisessionFuture’ ... done
<environment: 0x55ed0d20e158> 
<environment: 0x55ed0dfe1860> 
[16:20:44.473] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.473] - Validating connection of MultisessionFuture
[16:20:44.473] - received message: FutureResult
[16:20:44.473] - Received FutureResult
[16:20:44.473] - Erased future from FutureRegistry
[16:20:44.473] result() for ClusterFuture ...
[16:20:44.473] - result already collected: FutureResult
[16:20:44.474] result() for ClusterFuture ... done
[16:20:44.474] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.474] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.474] - Validating connection of MultisessionFuture
[16:20:44.474] - received message: FutureResult
[16:20:44.474] - Received FutureResult
[16:20:44.475] - Erased future from FutureRegistry
[16:20:44.475] result() for ClusterFuture ...
[16:20:44.475] - result already collected: FutureResult
[16:20:44.475] result() for ClusterFuture ... done
[16:20:44.475] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:44.478] resolve() on environment ...
[16:20:44.478]  recursive: 0
[16:20:44.479]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:44.479] signalConditionsASAP(numeric, pos=1) ...
[16:20:44.479] - nx: 4
[16:20:44.479] - relay: TRUE
[16:20:44.479] - stdout: TRUE
[16:20:44.480] - signal: TRUE
[16:20:44.480] - resignal: FALSE
[16:20:44.480] - force: TRUE
[16:20:44.480] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.480] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.480]  - until=2
[16:20:44.480]  - relaying element #2
[16:20:44.480] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.480] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.480] signalConditionsASAP(NULL, pos=1) ... done
[16:20:44.481]  length: 3 (resolved future 1)
[16:20:44.481] Future #2
[16:20:44.481] result() for ClusterFuture ...
[16:20:44.481] - result already collected: FutureResult
[16:20:44.481] result() for ClusterFuture ... done
[16:20:44.481] result() for ClusterFuture ...
[16:20:44.481] - result already collected: FutureResult
[16:20:44.481] result() for ClusterFuture ... done
[16:20:44.481] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:44.481] - nx: 4
[16:20:44.481] - relay: TRUE
[16:20:44.481] - stdout: TRUE
[16:20:44.482] - signal: TRUE
[16:20:44.482] - resignal: FALSE
[16:20:44.482] - force: TRUE
[16:20:44.482] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.482] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.482]  - until=2
[16:20:44.482]  - relaying element #2
[16:20:44.482] result() for ClusterFuture ...
[16:20:44.482] - result already collected: FutureResult
[16:20:44.482] result() for ClusterFuture ... done
[16:20:44.482] result() for ClusterFuture ...
[16:20:44.483] - result already collected: FutureResult
[16:20:44.483] result() for ClusterFuture ... done
[16:20:44.483] result() for ClusterFuture ...
[16:20:44.483] - result already collected: FutureResult
[16:20:44.483] result() for ClusterFuture ... done
[16:20:44.483] result() for ClusterFuture ...
[16:20:44.483] - result already collected: FutureResult
[16:20:44.483] result() for ClusterFuture ... done
[16:20:44.483] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.483] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.483] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:44.483]  length: 2 (resolved future 2)
[16:20:44.484] Future #3
[16:20:44.484] result() for ClusterFuture ...
[16:20:44.484] - result already collected: FutureResult
[16:20:44.484] result() for ClusterFuture ... done
[16:20:44.484] result() for ClusterFuture ...
[16:20:44.484] - result already collected: FutureResult
[16:20:44.484] result() for ClusterFuture ... done
[16:20:44.484] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:44.484] - nx: 4
[16:20:44.484] - relay: TRUE
[16:20:44.484] - stdout: TRUE
[16:20:44.485] - signal: TRUE
[16:20:44.485] - resignal: FALSE
[16:20:44.485] - force: TRUE
[16:20:44.485] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.485] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.485]  - until=3
[16:20:44.485]  - relaying element #3
[16:20:44.485] result() for ClusterFuture ...
[16:20:44.485] - result already collected: FutureResult
[16:20:44.485] result() for ClusterFuture ... done
[16:20:44.485] result() for ClusterFuture ...
[16:20:44.485] - result already collected: FutureResult
[16:20:44.486] result() for ClusterFuture ... done
[16:20:44.486] result() for ClusterFuture ...
[16:20:44.486] - result already collected: FutureResult
[16:20:44.486] result() for ClusterFuture ... done
[16:20:44.486] result() for ClusterFuture ...
[16:20:44.486] - result already collected: FutureResult
[16:20:44.486] result() for ClusterFuture ... done
[16:20:44.486] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.486] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.486] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:44.486]  length: 1 (resolved future 3)
[16:20:44.487] Future #4
[16:20:44.487] result() for ClusterFuture ...
[16:20:44.487] - result already collected: FutureResult
[16:20:44.487] result() for ClusterFuture ... done
[16:20:44.487] result() for ClusterFuture ...
[16:20:44.487] - result already collected: FutureResult
[16:20:44.487] result() for ClusterFuture ... done
[16:20:44.487] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:44.487] - nx: 4
[16:20:44.487] - relay: TRUE
[16:20:44.487] - stdout: TRUE
[16:20:44.487] - signal: TRUE
[16:20:44.488] - resignal: FALSE
[16:20:44.488] - force: TRUE
[16:20:44.488] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.488] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.488]  - until=4
[16:20:44.488]  - relaying element #4
[16:20:44.488] result() for ClusterFuture ...
[16:20:44.488] - result already collected: FutureResult
[16:20:44.488] result() for ClusterFuture ... done
[16:20:44.488] result() for ClusterFuture ...
[16:20:44.488] - result already collected: FutureResult
[16:20:44.488] result() for ClusterFuture ... done
[16:20:44.489] result() for ClusterFuture ...
[16:20:44.489] - result already collected: FutureResult
[16:20:44.489] result() for ClusterFuture ... done
[16:20:44.489] result() for ClusterFuture ...
[16:20:44.489] - result already collected: FutureResult
[16:20:44.489] result() for ClusterFuture ... done
[16:20:44.489] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.489] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.489] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:44.489]  length: 0 (resolved future 4)
[16:20:44.489] Relaying remaining futures
[16:20:44.490] signalConditionsASAP(NULL, pos=0) ...
[16:20:44.490] - nx: 4
[16:20:44.490] - relay: TRUE
[16:20:44.490] - stdout: TRUE
[16:20:44.490] - signal: TRUE
[16:20:44.490] - resignal: FALSE
[16:20:44.490] - force: TRUE
[16:20:44.490] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.490] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:44.490] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.490] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.490] signalConditionsASAP(NULL, pos=0) ... done
[16:20:44.491] resolve() on environment ... DONE
[16:20:44.491] result() for ClusterFuture ...
[16:20:44.491] - result already collected: FutureResult
[16:20:44.491] result() for ClusterFuture ... done
[16:20:44.491] result() for ClusterFuture ...
[16:20:44.491] - result already collected: FutureResult
[16:20:44.491] result() for ClusterFuture ... done
[16:20:44.491] result() for ClusterFuture ...
[16:20:44.491] - result already collected: FutureResult
[16:20:44.491] result() for ClusterFuture ... done
[16:20:44.491] result() for ClusterFuture ...
[16:20:44.492] - result already collected: FutureResult
[16:20:44.492] result() for ClusterFuture ... done
[16:20:44.492] result() for ClusterFuture ...
[16:20:44.492] - result already collected: FutureResult
[16:20:44.492] result() for ClusterFuture ... done
[16:20:44.492] result() for ClusterFuture ...
[16:20:44.492] - result already collected: FutureResult
[16:20:44.492] result() for ClusterFuture ... done
<environment: 0x55ed0e191f28> 
Dimensions: c(2, 3, 1)
[16:20:44.493] getGlobalsAndPackages() ...
[16:20:44.493] Searching for globals...
[16:20:44.493] 
[16:20:44.493] Searching for globals ... DONE
[16:20:44.493] - globals: [0] <none>
[16:20:44.493] getGlobalsAndPackages() ... DONE
[16:20:44.493] run() for ‘Future’ ...
[16:20:44.494] - state: ‘created’
[16:20:44.494] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.507] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.508] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.508]   - Field: ‘node’
[16:20:44.508]   - Field: ‘label’
[16:20:44.508]   - Field: ‘local’
[16:20:44.508]   - Field: ‘owner’
[16:20:44.508]   - Field: ‘envir’
[16:20:44.508]   - Field: ‘workers’
[16:20:44.508]   - Field: ‘packages’
[16:20:44.508]   - Field: ‘gc’
[16:20:44.509]   - Field: ‘conditions’
[16:20:44.509]   - Field: ‘persistent’
[16:20:44.509]   - Field: ‘expr’
[16:20:44.509]   - Field: ‘uuid’
[16:20:44.509]   - Field: ‘seed’
[16:20:44.509]   - Field: ‘version’
[16:20:44.509]   - Field: ‘result’
[16:20:44.509]   - Field: ‘asynchronous’
[16:20:44.509]   - Field: ‘calls’
[16:20:44.509]   - Field: ‘globals’
[16:20:44.509]   - Field: ‘stdout’
[16:20:44.510]   - Field: ‘earlySignal’
[16:20:44.510]   - Field: ‘lazy’
[16:20:44.510]   - Field: ‘state’
[16:20:44.510] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.510] - Launch lazy future ...
[16:20:44.510] Packages needed by the future expression (n = 0): <none>
[16:20:44.510] Packages needed by future strategies (n = 0): <none>
[16:20:44.511] {
[16:20:44.511]     {
[16:20:44.511]         {
[16:20:44.511]             ...future.startTime <- base::Sys.time()
[16:20:44.511]             {
[16:20:44.511]                 {
[16:20:44.511]                   {
[16:20:44.511]                     {
[16:20:44.511]                       base::local({
[16:20:44.511]                         has_future <- base::requireNamespace("future", 
[16:20:44.511]                           quietly = TRUE)
[16:20:44.511]                         if (has_future) {
[16:20:44.511]                           ns <- base::getNamespace("future")
[16:20:44.511]                           version <- ns[[".package"]][["version"]]
[16:20:44.511]                           if (is.null(version)) 
[16:20:44.511]                             version <- utils::packageVersion("future")
[16:20:44.511]                         }
[16:20:44.511]                         else {
[16:20:44.511]                           version <- NULL
[16:20:44.511]                         }
[16:20:44.511]                         if (!has_future || version < "1.8.0") {
[16:20:44.511]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.511]                             "", base::R.version$version.string), 
[16:20:44.511]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.511]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.511]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.511]                               "release", "version")], collapse = " "), 
[16:20:44.511]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.511]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.511]                             info)
[16:20:44.511]                           info <- base::paste(info, collapse = "; ")
[16:20:44.511]                           if (!has_future) {
[16:20:44.511]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.511]                               info)
[16:20:44.511]                           }
[16:20:44.511]                           else {
[16:20:44.511]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.511]                               info, version)
[16:20:44.511]                           }
[16:20:44.511]                           base::stop(msg)
[16:20:44.511]                         }
[16:20:44.511]                       })
[16:20:44.511]                     }
[16:20:44.511]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.511]                     base::options(mc.cores = 1L)
[16:20:44.511]                   }
[16:20:44.511]                   ...future.strategy.old <- future::plan("list")
[16:20:44.511]                   options(future.plan = NULL)
[16:20:44.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.511]                 }
[16:20:44.511]                 ...future.workdir <- getwd()
[16:20:44.511]             }
[16:20:44.511]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.511]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.511]         }
[16:20:44.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.511]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.511]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.511]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.511]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.511]             base::names(...future.oldOptions))
[16:20:44.511]     }
[16:20:44.511]     if (FALSE) {
[16:20:44.511]     }
[16:20:44.511]     else {
[16:20:44.511]         if (TRUE) {
[16:20:44.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.511]                 open = "w")
[16:20:44.511]         }
[16:20:44.511]         else {
[16:20:44.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.511]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.511]         }
[16:20:44.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.511]             base::sink(type = "output", split = FALSE)
[16:20:44.511]             base::close(...future.stdout)
[16:20:44.511]         }, add = TRUE)
[16:20:44.511]     }
[16:20:44.511]     ...future.frame <- base::sys.nframe()
[16:20:44.511]     ...future.conditions <- base::list()
[16:20:44.511]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.511]     if (FALSE) {
[16:20:44.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.511]     }
[16:20:44.511]     ...future.result <- base::tryCatch({
[16:20:44.511]         base::withCallingHandlers({
[16:20:44.511]             ...future.value <- base::withVisible(base::local({
[16:20:44.511]                 ...future.makeSendCondition <- base::local({
[16:20:44.511]                   sendCondition <- NULL
[16:20:44.511]                   function(frame = 1L) {
[16:20:44.511]                     if (is.function(sendCondition)) 
[16:20:44.511]                       return(sendCondition)
[16:20:44.511]                     ns <- getNamespace("parallel")
[16:20:44.511]                     if (exists("sendData", mode = "function", 
[16:20:44.511]                       envir = ns)) {
[16:20:44.511]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.511]                         envir = ns)
[16:20:44.511]                       envir <- sys.frame(frame)
[16:20:44.511]                       master <- NULL
[16:20:44.511]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.511]                         !identical(envir, emptyenv())) {
[16:20:44.511]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.511]                           inherits = FALSE)) {
[16:20:44.511]                           master <- get("master", mode = "list", 
[16:20:44.511]                             envir = envir, inherits = FALSE)
[16:20:44.511]                           if (inherits(master, c("SOCKnode", 
[16:20:44.511]                             "SOCK0node"))) {
[16:20:44.511]                             sendCondition <<- function(cond) {
[16:20:44.511]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.511]                                 success = TRUE)
[16:20:44.511]                               parallel_sendData(master, data)
[16:20:44.511]                             }
[16:20:44.511]                             return(sendCondition)
[16:20:44.511]                           }
[16:20:44.511]                         }
[16:20:44.511]                         frame <- frame + 1L
[16:20:44.511]                         envir <- sys.frame(frame)
[16:20:44.511]                       }
[16:20:44.511]                     }
[16:20:44.511]                     sendCondition <<- function(cond) NULL
[16:20:44.511]                   }
[16:20:44.511]                 })
[16:20:44.511]                 withCallingHandlers({
[16:20:44.511]                   2
[16:20:44.511]                 }, immediateCondition = function(cond) {
[16:20:44.511]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.511]                   sendCondition(cond)
[16:20:44.511]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.511]                   {
[16:20:44.511]                     inherits <- base::inherits
[16:20:44.511]                     invokeRestart <- base::invokeRestart
[16:20:44.511]                     is.null <- base::is.null
[16:20:44.511]                     muffled <- FALSE
[16:20:44.511]                     if (inherits(cond, "message")) {
[16:20:44.511]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.511]                       if (muffled) 
[16:20:44.511]                         invokeRestart("muffleMessage")
[16:20:44.511]                     }
[16:20:44.511]                     else if (inherits(cond, "warning")) {
[16:20:44.511]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.511]                       if (muffled) 
[16:20:44.511]                         invokeRestart("muffleWarning")
[16:20:44.511]                     }
[16:20:44.511]                     else if (inherits(cond, "condition")) {
[16:20:44.511]                       if (!is.null(pattern)) {
[16:20:44.511]                         computeRestarts <- base::computeRestarts
[16:20:44.511]                         grepl <- base::grepl
[16:20:44.511]                         restarts <- computeRestarts(cond)
[16:20:44.511]                         for (restart in restarts) {
[16:20:44.511]                           name <- restart$name
[16:20:44.511]                           if (is.null(name)) 
[16:20:44.511]                             next
[16:20:44.511]                           if (!grepl(pattern, name)) 
[16:20:44.511]                             next
[16:20:44.511]                           invokeRestart(restart)
[16:20:44.511]                           muffled <- TRUE
[16:20:44.511]                           break
[16:20:44.511]                         }
[16:20:44.511]                       }
[16:20:44.511]                     }
[16:20:44.511]                     invisible(muffled)
[16:20:44.511]                   }
[16:20:44.511]                   muffleCondition(cond)
[16:20:44.511]                 })
[16:20:44.511]             }))
[16:20:44.511]             future::FutureResult(value = ...future.value$value, 
[16:20:44.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.511]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.511]                     ...future.globalenv.names))
[16:20:44.511]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.511]         }, condition = base::local({
[16:20:44.511]             c <- base::c
[16:20:44.511]             inherits <- base::inherits
[16:20:44.511]             invokeRestart <- base::invokeRestart
[16:20:44.511]             length <- base::length
[16:20:44.511]             list <- base::list
[16:20:44.511]             seq.int <- base::seq.int
[16:20:44.511]             signalCondition <- base::signalCondition
[16:20:44.511]             sys.calls <- base::sys.calls
[16:20:44.511]             `[[` <- base::`[[`
[16:20:44.511]             `+` <- base::`+`
[16:20:44.511]             `<<-` <- base::`<<-`
[16:20:44.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.511]                   3L)]
[16:20:44.511]             }
[16:20:44.511]             function(cond) {
[16:20:44.511]                 is_error <- inherits(cond, "error")
[16:20:44.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.511]                   NULL)
[16:20:44.511]                 if (is_error) {
[16:20:44.511]                   sessionInformation <- function() {
[16:20:44.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.511]                       search = base::search(), system = base::Sys.info())
[16:20:44.511]                   }
[16:20:44.511]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.511]                     cond$call), session = sessionInformation(), 
[16:20:44.511]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.511]                   signalCondition(cond)
[16:20:44.511]                 }
[16:20:44.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.511]                 "immediateCondition"))) {
[16:20:44.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.511]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.511]                   if (TRUE && !signal) {
[16:20:44.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.511]                     {
[16:20:44.511]                       inherits <- base::inherits
[16:20:44.511]                       invokeRestart <- base::invokeRestart
[16:20:44.511]                       is.null <- base::is.null
[16:20:44.511]                       muffled <- FALSE
[16:20:44.511]                       if (inherits(cond, "message")) {
[16:20:44.511]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.511]                         if (muffled) 
[16:20:44.511]                           invokeRestart("muffleMessage")
[16:20:44.511]                       }
[16:20:44.511]                       else if (inherits(cond, "warning")) {
[16:20:44.511]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.511]                         if (muffled) 
[16:20:44.511]                           invokeRestart("muffleWarning")
[16:20:44.511]                       }
[16:20:44.511]                       else if (inherits(cond, "condition")) {
[16:20:44.511]                         if (!is.null(pattern)) {
[16:20:44.511]                           computeRestarts <- base::computeRestarts
[16:20:44.511]                           grepl <- base::grepl
[16:20:44.511]                           restarts <- computeRestarts(cond)
[16:20:44.511]                           for (restart in restarts) {
[16:20:44.511]                             name <- restart$name
[16:20:44.511]                             if (is.null(name)) 
[16:20:44.511]                               next
[16:20:44.511]                             if (!grepl(pattern, name)) 
[16:20:44.511]                               next
[16:20:44.511]                             invokeRestart(restart)
[16:20:44.511]                             muffled <- TRUE
[16:20:44.511]                             break
[16:20:44.511]                           }
[16:20:44.511]                         }
[16:20:44.511]                       }
[16:20:44.511]                       invisible(muffled)
[16:20:44.511]                     }
[16:20:44.511]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.511]                   }
[16:20:44.511]                 }
[16:20:44.511]                 else {
[16:20:44.511]                   if (TRUE) {
[16:20:44.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.511]                     {
[16:20:44.511]                       inherits <- base::inherits
[16:20:44.511]                       invokeRestart <- base::invokeRestart
[16:20:44.511]                       is.null <- base::is.null
[16:20:44.511]                       muffled <- FALSE
[16:20:44.511]                       if (inherits(cond, "message")) {
[16:20:44.511]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.511]                         if (muffled) 
[16:20:44.511]                           invokeRestart("muffleMessage")
[16:20:44.511]                       }
[16:20:44.511]                       else if (inherits(cond, "warning")) {
[16:20:44.511]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.511]                         if (muffled) 
[16:20:44.511]                           invokeRestart("muffleWarning")
[16:20:44.511]                       }
[16:20:44.511]                       else if (inherits(cond, "condition")) {
[16:20:44.511]                         if (!is.null(pattern)) {
[16:20:44.511]                           computeRestarts <- base::computeRestarts
[16:20:44.511]                           grepl <- base::grepl
[16:20:44.511]                           restarts <- computeRestarts(cond)
[16:20:44.511]                           for (restart in restarts) {
[16:20:44.511]                             name <- restart$name
[16:20:44.511]                             if (is.null(name)) 
[16:20:44.511]                               next
[16:20:44.511]                             if (!grepl(pattern, name)) 
[16:20:44.511]                               next
[16:20:44.511]                             invokeRestart(restart)
[16:20:44.511]                             muffled <- TRUE
[16:20:44.511]                             break
[16:20:44.511]                           }
[16:20:44.511]                         }
[16:20:44.511]                       }
[16:20:44.511]                       invisible(muffled)
[16:20:44.511]                     }
[16:20:44.511]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.511]                   }
[16:20:44.511]                 }
[16:20:44.511]             }
[16:20:44.511]         }))
[16:20:44.511]     }, error = function(ex) {
[16:20:44.511]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.511]                 ...future.rng), started = ...future.startTime, 
[16:20:44.511]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.511]             version = "1.8"), class = "FutureResult")
[16:20:44.511]     }, finally = {
[16:20:44.511]         if (!identical(...future.workdir, getwd())) 
[16:20:44.511]             setwd(...future.workdir)
[16:20:44.511]         {
[16:20:44.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.511]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.511]             }
[16:20:44.511]             base::options(...future.oldOptions)
[16:20:44.511]             if (.Platform$OS.type == "windows") {
[16:20:44.511]                 old_names <- names(...future.oldEnvVars)
[16:20:44.511]                 envs <- base::Sys.getenv()
[16:20:44.511]                 names <- names(envs)
[16:20:44.511]                 common <- intersect(names, old_names)
[16:20:44.511]                 added <- setdiff(names, old_names)
[16:20:44.511]                 removed <- setdiff(old_names, names)
[16:20:44.511]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.511]                   envs[common]]
[16:20:44.511]                 NAMES <- toupper(changed)
[16:20:44.511]                 args <- list()
[16:20:44.511]                 for (kk in seq_along(NAMES)) {
[16:20:44.511]                   name <- changed[[kk]]
[16:20:44.511]                   NAME <- NAMES[[kk]]
[16:20:44.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.511]                     next
[16:20:44.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.511]                 }
[16:20:44.511]                 NAMES <- toupper(added)
[16:20:44.511]                 for (kk in seq_along(NAMES)) {
[16:20:44.511]                   name <- added[[kk]]
[16:20:44.511]                   NAME <- NAMES[[kk]]
[16:20:44.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.511]                     next
[16:20:44.511]                   args[[name]] <- ""
[16:20:44.511]                 }
[16:20:44.511]                 NAMES <- toupper(removed)
[16:20:44.511]                 for (kk in seq_along(NAMES)) {
[16:20:44.511]                   name <- removed[[kk]]
[16:20:44.511]                   NAME <- NAMES[[kk]]
[16:20:44.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.511]                     next
[16:20:44.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.511]                 }
[16:20:44.511]                 if (length(args) > 0) 
[16:20:44.511]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.511]             }
[16:20:44.511]             else {
[16:20:44.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.511]             }
[16:20:44.511]             {
[16:20:44.511]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.511]                   0L) {
[16:20:44.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.511]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.511]                   base::options(opts)
[16:20:44.511]                 }
[16:20:44.511]                 {
[16:20:44.511]                   {
[16:20:44.511]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.511]                     NULL
[16:20:44.511]                   }
[16:20:44.511]                   options(future.plan = NULL)
[16:20:44.511]                   if (is.na(NA_character_)) 
[16:20:44.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.511]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.511]                     .init = FALSE)
[16:20:44.511]                 }
[16:20:44.511]             }
[16:20:44.511]         }
[16:20:44.511]     })
[16:20:44.511]     if (TRUE) {
[16:20:44.511]         base::sink(type = "output", split = FALSE)
[16:20:44.511]         if (TRUE) {
[16:20:44.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.511]         }
[16:20:44.511]         else {
[16:20:44.511]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.511]         }
[16:20:44.511]         base::close(...future.stdout)
[16:20:44.511]         ...future.stdout <- NULL
[16:20:44.511]     }
[16:20:44.511]     ...future.result$conditions <- ...future.conditions
[16:20:44.511]     ...future.result$finished <- base::Sys.time()
[16:20:44.511]     ...future.result
[16:20:44.511] }
[16:20:44.513] MultisessionFuture started
[16:20:44.514] - Launch lazy future ... done
[16:20:44.514] run() for ‘MultisessionFuture’ ... done
[16:20:44.514] getGlobalsAndPackages() ...
[16:20:44.514] Searching for globals...
[16:20:44.514] 
[16:20:44.514] Searching for globals ... DONE
[16:20:44.514] - globals: [0] <none>
[16:20:44.515] getGlobalsAndPackages() ... DONE
[16:20:44.515] run() for ‘Future’ ...
[16:20:44.515] - state: ‘created’
[16:20:44.515] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.528] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.529]   - Field: ‘node’
[16:20:44.529]   - Field: ‘label’
[16:20:44.529]   - Field: ‘local’
[16:20:44.529]   - Field: ‘owner’
[16:20:44.529]   - Field: ‘envir’
[16:20:44.529]   - Field: ‘workers’
[16:20:44.529]   - Field: ‘packages’
[16:20:44.529]   - Field: ‘gc’
[16:20:44.529]   - Field: ‘conditions’
[16:20:44.529]   - Field: ‘persistent’
[16:20:44.530]   - Field: ‘expr’
[16:20:44.530]   - Field: ‘uuid’
[16:20:44.530]   - Field: ‘seed’
[16:20:44.530]   - Field: ‘version’
[16:20:44.530]   - Field: ‘result’
[16:20:44.530]   - Field: ‘asynchronous’
[16:20:44.530]   - Field: ‘calls’
[16:20:44.530]   - Field: ‘globals’
[16:20:44.530]   - Field: ‘stdout’
[16:20:44.530]   - Field: ‘earlySignal’
[16:20:44.530]   - Field: ‘lazy’
[16:20:44.531]   - Field: ‘state’
[16:20:44.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.531] - Launch lazy future ...
[16:20:44.531] Packages needed by the future expression (n = 0): <none>
[16:20:44.531] Packages needed by future strategies (n = 0): <none>
[16:20:44.531] {
[16:20:44.531]     {
[16:20:44.531]         {
[16:20:44.531]             ...future.startTime <- base::Sys.time()
[16:20:44.531]             {
[16:20:44.531]                 {
[16:20:44.531]                   {
[16:20:44.531]                     {
[16:20:44.531]                       base::local({
[16:20:44.531]                         has_future <- base::requireNamespace("future", 
[16:20:44.531]                           quietly = TRUE)
[16:20:44.531]                         if (has_future) {
[16:20:44.531]                           ns <- base::getNamespace("future")
[16:20:44.531]                           version <- ns[[".package"]][["version"]]
[16:20:44.531]                           if (is.null(version)) 
[16:20:44.531]                             version <- utils::packageVersion("future")
[16:20:44.531]                         }
[16:20:44.531]                         else {
[16:20:44.531]                           version <- NULL
[16:20:44.531]                         }
[16:20:44.531]                         if (!has_future || version < "1.8.0") {
[16:20:44.531]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.531]                             "", base::R.version$version.string), 
[16:20:44.531]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.531]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.531]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.531]                               "release", "version")], collapse = " "), 
[16:20:44.531]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.531]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.531]                             info)
[16:20:44.531]                           info <- base::paste(info, collapse = "; ")
[16:20:44.531]                           if (!has_future) {
[16:20:44.531]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.531]                               info)
[16:20:44.531]                           }
[16:20:44.531]                           else {
[16:20:44.531]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.531]                               info, version)
[16:20:44.531]                           }
[16:20:44.531]                           base::stop(msg)
[16:20:44.531]                         }
[16:20:44.531]                       })
[16:20:44.531]                     }
[16:20:44.531]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.531]                     base::options(mc.cores = 1L)
[16:20:44.531]                   }
[16:20:44.531]                   ...future.strategy.old <- future::plan("list")
[16:20:44.531]                   options(future.plan = NULL)
[16:20:44.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.531]                 }
[16:20:44.531]                 ...future.workdir <- getwd()
[16:20:44.531]             }
[16:20:44.531]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.531]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.531]         }
[16:20:44.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.531]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.531]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.531]             base::names(...future.oldOptions))
[16:20:44.531]     }
[16:20:44.531]     if (FALSE) {
[16:20:44.531]     }
[16:20:44.531]     else {
[16:20:44.531]         if (TRUE) {
[16:20:44.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.531]                 open = "w")
[16:20:44.531]         }
[16:20:44.531]         else {
[16:20:44.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.531]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.531]         }
[16:20:44.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.531]             base::sink(type = "output", split = FALSE)
[16:20:44.531]             base::close(...future.stdout)
[16:20:44.531]         }, add = TRUE)
[16:20:44.531]     }
[16:20:44.531]     ...future.frame <- base::sys.nframe()
[16:20:44.531]     ...future.conditions <- base::list()
[16:20:44.531]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.531]     if (FALSE) {
[16:20:44.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.531]     }
[16:20:44.531]     ...future.result <- base::tryCatch({
[16:20:44.531]         base::withCallingHandlers({
[16:20:44.531]             ...future.value <- base::withVisible(base::local({
[16:20:44.531]                 ...future.makeSendCondition <- base::local({
[16:20:44.531]                   sendCondition <- NULL
[16:20:44.531]                   function(frame = 1L) {
[16:20:44.531]                     if (is.function(sendCondition)) 
[16:20:44.531]                       return(sendCondition)
[16:20:44.531]                     ns <- getNamespace("parallel")
[16:20:44.531]                     if (exists("sendData", mode = "function", 
[16:20:44.531]                       envir = ns)) {
[16:20:44.531]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.531]                         envir = ns)
[16:20:44.531]                       envir <- sys.frame(frame)
[16:20:44.531]                       master <- NULL
[16:20:44.531]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.531]                         !identical(envir, emptyenv())) {
[16:20:44.531]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.531]                           inherits = FALSE)) {
[16:20:44.531]                           master <- get("master", mode = "list", 
[16:20:44.531]                             envir = envir, inherits = FALSE)
[16:20:44.531]                           if (inherits(master, c("SOCKnode", 
[16:20:44.531]                             "SOCK0node"))) {
[16:20:44.531]                             sendCondition <<- function(cond) {
[16:20:44.531]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.531]                                 success = TRUE)
[16:20:44.531]                               parallel_sendData(master, data)
[16:20:44.531]                             }
[16:20:44.531]                             return(sendCondition)
[16:20:44.531]                           }
[16:20:44.531]                         }
[16:20:44.531]                         frame <- frame + 1L
[16:20:44.531]                         envir <- sys.frame(frame)
[16:20:44.531]                       }
[16:20:44.531]                     }
[16:20:44.531]                     sendCondition <<- function(cond) NULL
[16:20:44.531]                   }
[16:20:44.531]                 })
[16:20:44.531]                 withCallingHandlers({
[16:20:44.531]                   NULL
[16:20:44.531]                 }, immediateCondition = function(cond) {
[16:20:44.531]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.531]                   sendCondition(cond)
[16:20:44.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.531]                   {
[16:20:44.531]                     inherits <- base::inherits
[16:20:44.531]                     invokeRestart <- base::invokeRestart
[16:20:44.531]                     is.null <- base::is.null
[16:20:44.531]                     muffled <- FALSE
[16:20:44.531]                     if (inherits(cond, "message")) {
[16:20:44.531]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.531]                       if (muffled) 
[16:20:44.531]                         invokeRestart("muffleMessage")
[16:20:44.531]                     }
[16:20:44.531]                     else if (inherits(cond, "warning")) {
[16:20:44.531]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.531]                       if (muffled) 
[16:20:44.531]                         invokeRestart("muffleWarning")
[16:20:44.531]                     }
[16:20:44.531]                     else if (inherits(cond, "condition")) {
[16:20:44.531]                       if (!is.null(pattern)) {
[16:20:44.531]                         computeRestarts <- base::computeRestarts
[16:20:44.531]                         grepl <- base::grepl
[16:20:44.531]                         restarts <- computeRestarts(cond)
[16:20:44.531]                         for (restart in restarts) {
[16:20:44.531]                           name <- restart$name
[16:20:44.531]                           if (is.null(name)) 
[16:20:44.531]                             next
[16:20:44.531]                           if (!grepl(pattern, name)) 
[16:20:44.531]                             next
[16:20:44.531]                           invokeRestart(restart)
[16:20:44.531]                           muffled <- TRUE
[16:20:44.531]                           break
[16:20:44.531]                         }
[16:20:44.531]                       }
[16:20:44.531]                     }
[16:20:44.531]                     invisible(muffled)
[16:20:44.531]                   }
[16:20:44.531]                   muffleCondition(cond)
[16:20:44.531]                 })
[16:20:44.531]             }))
[16:20:44.531]             future::FutureResult(value = ...future.value$value, 
[16:20:44.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.531]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.531]                     ...future.globalenv.names))
[16:20:44.531]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.531]         }, condition = base::local({
[16:20:44.531]             c <- base::c
[16:20:44.531]             inherits <- base::inherits
[16:20:44.531]             invokeRestart <- base::invokeRestart
[16:20:44.531]             length <- base::length
[16:20:44.531]             list <- base::list
[16:20:44.531]             seq.int <- base::seq.int
[16:20:44.531]             signalCondition <- base::signalCondition
[16:20:44.531]             sys.calls <- base::sys.calls
[16:20:44.531]             `[[` <- base::`[[`
[16:20:44.531]             `+` <- base::`+`
[16:20:44.531]             `<<-` <- base::`<<-`
[16:20:44.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.531]                   3L)]
[16:20:44.531]             }
[16:20:44.531]             function(cond) {
[16:20:44.531]                 is_error <- inherits(cond, "error")
[16:20:44.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.531]                   NULL)
[16:20:44.531]                 if (is_error) {
[16:20:44.531]                   sessionInformation <- function() {
[16:20:44.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.531]                       search = base::search(), system = base::Sys.info())
[16:20:44.531]                   }
[16:20:44.531]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.531]                     cond$call), session = sessionInformation(), 
[16:20:44.531]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.531]                   signalCondition(cond)
[16:20:44.531]                 }
[16:20:44.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.531]                 "immediateCondition"))) {
[16:20:44.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.531]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.531]                   if (TRUE && !signal) {
[16:20:44.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.531]                     {
[16:20:44.531]                       inherits <- base::inherits
[16:20:44.531]                       invokeRestart <- base::invokeRestart
[16:20:44.531]                       is.null <- base::is.null
[16:20:44.531]                       muffled <- FALSE
[16:20:44.531]                       if (inherits(cond, "message")) {
[16:20:44.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.531]                         if (muffled) 
[16:20:44.531]                           invokeRestart("muffleMessage")
[16:20:44.531]                       }
[16:20:44.531]                       else if (inherits(cond, "warning")) {
[16:20:44.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.531]                         if (muffled) 
[16:20:44.531]                           invokeRestart("muffleWarning")
[16:20:44.531]                       }
[16:20:44.531]                       else if (inherits(cond, "condition")) {
[16:20:44.531]                         if (!is.null(pattern)) {
[16:20:44.531]                           computeRestarts <- base::computeRestarts
[16:20:44.531]                           grepl <- base::grepl
[16:20:44.531]                           restarts <- computeRestarts(cond)
[16:20:44.531]                           for (restart in restarts) {
[16:20:44.531]                             name <- restart$name
[16:20:44.531]                             if (is.null(name)) 
[16:20:44.531]                               next
[16:20:44.531]                             if (!grepl(pattern, name)) 
[16:20:44.531]                               next
[16:20:44.531]                             invokeRestart(restart)
[16:20:44.531]                             muffled <- TRUE
[16:20:44.531]                             break
[16:20:44.531]                           }
[16:20:44.531]                         }
[16:20:44.531]                       }
[16:20:44.531]                       invisible(muffled)
[16:20:44.531]                     }
[16:20:44.531]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.531]                   }
[16:20:44.531]                 }
[16:20:44.531]                 else {
[16:20:44.531]                   if (TRUE) {
[16:20:44.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.531]                     {
[16:20:44.531]                       inherits <- base::inherits
[16:20:44.531]                       invokeRestart <- base::invokeRestart
[16:20:44.531]                       is.null <- base::is.null
[16:20:44.531]                       muffled <- FALSE
[16:20:44.531]                       if (inherits(cond, "message")) {
[16:20:44.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.531]                         if (muffled) 
[16:20:44.531]                           invokeRestart("muffleMessage")
[16:20:44.531]                       }
[16:20:44.531]                       else if (inherits(cond, "warning")) {
[16:20:44.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.531]                         if (muffled) 
[16:20:44.531]                           invokeRestart("muffleWarning")
[16:20:44.531]                       }
[16:20:44.531]                       else if (inherits(cond, "condition")) {
[16:20:44.531]                         if (!is.null(pattern)) {
[16:20:44.531]                           computeRestarts <- base::computeRestarts
[16:20:44.531]                           grepl <- base::grepl
[16:20:44.531]                           restarts <- computeRestarts(cond)
[16:20:44.531]                           for (restart in restarts) {
[16:20:44.531]                             name <- restart$name
[16:20:44.531]                             if (is.null(name)) 
[16:20:44.531]                               next
[16:20:44.531]                             if (!grepl(pattern, name)) 
[16:20:44.531]                               next
[16:20:44.531]                             invokeRestart(restart)
[16:20:44.531]                             muffled <- TRUE
[16:20:44.531]                             break
[16:20:44.531]                           }
[16:20:44.531]                         }
[16:20:44.531]                       }
[16:20:44.531]                       invisible(muffled)
[16:20:44.531]                     }
[16:20:44.531]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.531]                   }
[16:20:44.531]                 }
[16:20:44.531]             }
[16:20:44.531]         }))
[16:20:44.531]     }, error = function(ex) {
[16:20:44.531]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.531]                 ...future.rng), started = ...future.startTime, 
[16:20:44.531]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.531]             version = "1.8"), class = "FutureResult")
[16:20:44.531]     }, finally = {
[16:20:44.531]         if (!identical(...future.workdir, getwd())) 
[16:20:44.531]             setwd(...future.workdir)
[16:20:44.531]         {
[16:20:44.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.531]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.531]             }
[16:20:44.531]             base::options(...future.oldOptions)
[16:20:44.531]             if (.Platform$OS.type == "windows") {
[16:20:44.531]                 old_names <- names(...future.oldEnvVars)
[16:20:44.531]                 envs <- base::Sys.getenv()
[16:20:44.531]                 names <- names(envs)
[16:20:44.531]                 common <- intersect(names, old_names)
[16:20:44.531]                 added <- setdiff(names, old_names)
[16:20:44.531]                 removed <- setdiff(old_names, names)
[16:20:44.531]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.531]                   envs[common]]
[16:20:44.531]                 NAMES <- toupper(changed)
[16:20:44.531]                 args <- list()
[16:20:44.531]                 for (kk in seq_along(NAMES)) {
[16:20:44.531]                   name <- changed[[kk]]
[16:20:44.531]                   NAME <- NAMES[[kk]]
[16:20:44.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.531]                     next
[16:20:44.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.531]                 }
[16:20:44.531]                 NAMES <- toupper(added)
[16:20:44.531]                 for (kk in seq_along(NAMES)) {
[16:20:44.531]                   name <- added[[kk]]
[16:20:44.531]                   NAME <- NAMES[[kk]]
[16:20:44.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.531]                     next
[16:20:44.531]                   args[[name]] <- ""
[16:20:44.531]                 }
[16:20:44.531]                 NAMES <- toupper(removed)
[16:20:44.531]                 for (kk in seq_along(NAMES)) {
[16:20:44.531]                   name <- removed[[kk]]
[16:20:44.531]                   NAME <- NAMES[[kk]]
[16:20:44.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.531]                     next
[16:20:44.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.531]                 }
[16:20:44.531]                 if (length(args) > 0) 
[16:20:44.531]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.531]             }
[16:20:44.531]             else {
[16:20:44.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.531]             }
[16:20:44.531]             {
[16:20:44.531]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.531]                   0L) {
[16:20:44.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.531]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.531]                   base::options(opts)
[16:20:44.531]                 }
[16:20:44.531]                 {
[16:20:44.531]                   {
[16:20:44.531]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.531]                     NULL
[16:20:44.531]                   }
[16:20:44.531]                   options(future.plan = NULL)
[16:20:44.531]                   if (is.na(NA_character_)) 
[16:20:44.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.531]                     .init = FALSE)
[16:20:44.531]                 }
[16:20:44.531]             }
[16:20:44.531]         }
[16:20:44.531]     })
[16:20:44.531]     if (TRUE) {
[16:20:44.531]         base::sink(type = "output", split = FALSE)
[16:20:44.531]         if (TRUE) {
[16:20:44.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.531]         }
[16:20:44.531]         else {
[16:20:44.531]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.531]         }
[16:20:44.531]         base::close(...future.stdout)
[16:20:44.531]         ...future.stdout <- NULL
[16:20:44.531]     }
[16:20:44.531]     ...future.result$conditions <- ...future.conditions
[16:20:44.531]     ...future.result$finished <- base::Sys.time()
[16:20:44.531]     ...future.result
[16:20:44.531] }
[16:20:44.534] MultisessionFuture started
[16:20:44.535] - Launch lazy future ... done
[16:20:44.535] run() for ‘MultisessionFuture’ ... done
[16:20:44.535] getGlobalsAndPackages() ...
[16:20:44.535] Searching for globals...
[16:20:44.536] - globals found: [1] ‘{’
[16:20:44.536] Searching for globals ... DONE
[16:20:44.537] Resolving globals: FALSE
[16:20:44.537] 
[16:20:44.537] 
[16:20:44.537] getGlobalsAndPackages() ... DONE
[16:20:44.537] run() for ‘Future’ ...
[16:20:44.538] - state: ‘created’
[16:20:44.538] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.551] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.551]   - Field: ‘node’
[16:20:44.551]   - Field: ‘label’
[16:20:44.552]   - Field: ‘local’
[16:20:44.552]   - Field: ‘owner’
[16:20:44.552]   - Field: ‘envir’
[16:20:44.552]   - Field: ‘workers’
[16:20:44.552]   - Field: ‘packages’
[16:20:44.552]   - Field: ‘gc’
[16:20:44.552]   - Field: ‘conditions’
[16:20:44.552]   - Field: ‘persistent’
[16:20:44.552]   - Field: ‘expr’
[16:20:44.552]   - Field: ‘uuid’
[16:20:44.553]   - Field: ‘seed’
[16:20:44.553]   - Field: ‘version’
[16:20:44.553]   - Field: ‘result’
[16:20:44.553]   - Field: ‘asynchronous’
[16:20:44.553]   - Field: ‘calls’
[16:20:44.553]   - Field: ‘globals’
[16:20:44.553]   - Field: ‘stdout’
[16:20:44.553]   - Field: ‘earlySignal’
[16:20:44.553]   - Field: ‘lazy’
[16:20:44.553]   - Field: ‘state’
[16:20:44.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.554] - Launch lazy future ...
[16:20:44.554] Packages needed by the future expression (n = 0): <none>
[16:20:44.554] Packages needed by future strategies (n = 0): <none>
[16:20:44.554] {
[16:20:44.554]     {
[16:20:44.554]         {
[16:20:44.554]             ...future.startTime <- base::Sys.time()
[16:20:44.554]             {
[16:20:44.554]                 {
[16:20:44.554]                   {
[16:20:44.554]                     {
[16:20:44.554]                       base::local({
[16:20:44.554]                         has_future <- base::requireNamespace("future", 
[16:20:44.554]                           quietly = TRUE)
[16:20:44.554]                         if (has_future) {
[16:20:44.554]                           ns <- base::getNamespace("future")
[16:20:44.554]                           version <- ns[[".package"]][["version"]]
[16:20:44.554]                           if (is.null(version)) 
[16:20:44.554]                             version <- utils::packageVersion("future")
[16:20:44.554]                         }
[16:20:44.554]                         else {
[16:20:44.554]                           version <- NULL
[16:20:44.554]                         }
[16:20:44.554]                         if (!has_future || version < "1.8.0") {
[16:20:44.554]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.554]                             "", base::R.version$version.string), 
[16:20:44.554]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.554]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.554]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.554]                               "release", "version")], collapse = " "), 
[16:20:44.554]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.554]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.554]                             info)
[16:20:44.554]                           info <- base::paste(info, collapse = "; ")
[16:20:44.554]                           if (!has_future) {
[16:20:44.554]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.554]                               info)
[16:20:44.554]                           }
[16:20:44.554]                           else {
[16:20:44.554]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.554]                               info, version)
[16:20:44.554]                           }
[16:20:44.554]                           base::stop(msg)
[16:20:44.554]                         }
[16:20:44.554]                       })
[16:20:44.554]                     }
[16:20:44.554]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.554]                     base::options(mc.cores = 1L)
[16:20:44.554]                   }
[16:20:44.554]                   ...future.strategy.old <- future::plan("list")
[16:20:44.554]                   options(future.plan = NULL)
[16:20:44.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.554]                 }
[16:20:44.554]                 ...future.workdir <- getwd()
[16:20:44.554]             }
[16:20:44.554]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.554]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.554]         }
[16:20:44.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.554]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.554]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.554]             base::names(...future.oldOptions))
[16:20:44.554]     }
[16:20:44.554]     if (FALSE) {
[16:20:44.554]     }
[16:20:44.554]     else {
[16:20:44.554]         if (TRUE) {
[16:20:44.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.554]                 open = "w")
[16:20:44.554]         }
[16:20:44.554]         else {
[16:20:44.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.554]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.554]         }
[16:20:44.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.554]             base::sink(type = "output", split = FALSE)
[16:20:44.554]             base::close(...future.stdout)
[16:20:44.554]         }, add = TRUE)
[16:20:44.554]     }
[16:20:44.554]     ...future.frame <- base::sys.nframe()
[16:20:44.554]     ...future.conditions <- base::list()
[16:20:44.554]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.554]     if (FALSE) {
[16:20:44.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.554]     }
[16:20:44.554]     ...future.result <- base::tryCatch({
[16:20:44.554]         base::withCallingHandlers({
[16:20:44.554]             ...future.value <- base::withVisible(base::local({
[16:20:44.554]                 ...future.makeSendCondition <- base::local({
[16:20:44.554]                   sendCondition <- NULL
[16:20:44.554]                   function(frame = 1L) {
[16:20:44.554]                     if (is.function(sendCondition)) 
[16:20:44.554]                       return(sendCondition)
[16:20:44.554]                     ns <- getNamespace("parallel")
[16:20:44.554]                     if (exists("sendData", mode = "function", 
[16:20:44.554]                       envir = ns)) {
[16:20:44.554]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.554]                         envir = ns)
[16:20:44.554]                       envir <- sys.frame(frame)
[16:20:44.554]                       master <- NULL
[16:20:44.554]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.554]                         !identical(envir, emptyenv())) {
[16:20:44.554]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.554]                           inherits = FALSE)) {
[16:20:44.554]                           master <- get("master", mode = "list", 
[16:20:44.554]                             envir = envir, inherits = FALSE)
[16:20:44.554]                           if (inherits(master, c("SOCKnode", 
[16:20:44.554]                             "SOCK0node"))) {
[16:20:44.554]                             sendCondition <<- function(cond) {
[16:20:44.554]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.554]                                 success = TRUE)
[16:20:44.554]                               parallel_sendData(master, data)
[16:20:44.554]                             }
[16:20:44.554]                             return(sendCondition)
[16:20:44.554]                           }
[16:20:44.554]                         }
[16:20:44.554]                         frame <- frame + 1L
[16:20:44.554]                         envir <- sys.frame(frame)
[16:20:44.554]                       }
[16:20:44.554]                     }
[16:20:44.554]                     sendCondition <<- function(cond) NULL
[16:20:44.554]                   }
[16:20:44.554]                 })
[16:20:44.554]                 withCallingHandlers({
[16:20:44.554]                   {
[16:20:44.554]                     4
[16:20:44.554]                   }
[16:20:44.554]                 }, immediateCondition = function(cond) {
[16:20:44.554]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.554]                   sendCondition(cond)
[16:20:44.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.554]                   {
[16:20:44.554]                     inherits <- base::inherits
[16:20:44.554]                     invokeRestart <- base::invokeRestart
[16:20:44.554]                     is.null <- base::is.null
[16:20:44.554]                     muffled <- FALSE
[16:20:44.554]                     if (inherits(cond, "message")) {
[16:20:44.554]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.554]                       if (muffled) 
[16:20:44.554]                         invokeRestart("muffleMessage")
[16:20:44.554]                     }
[16:20:44.554]                     else if (inherits(cond, "warning")) {
[16:20:44.554]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.554]                       if (muffled) 
[16:20:44.554]                         invokeRestart("muffleWarning")
[16:20:44.554]                     }
[16:20:44.554]                     else if (inherits(cond, "condition")) {
[16:20:44.554]                       if (!is.null(pattern)) {
[16:20:44.554]                         computeRestarts <- base::computeRestarts
[16:20:44.554]                         grepl <- base::grepl
[16:20:44.554]                         restarts <- computeRestarts(cond)
[16:20:44.554]                         for (restart in restarts) {
[16:20:44.554]                           name <- restart$name
[16:20:44.554]                           if (is.null(name)) 
[16:20:44.554]                             next
[16:20:44.554]                           if (!grepl(pattern, name)) 
[16:20:44.554]                             next
[16:20:44.554]                           invokeRestart(restart)
[16:20:44.554]                           muffled <- TRUE
[16:20:44.554]                           break
[16:20:44.554]                         }
[16:20:44.554]                       }
[16:20:44.554]                     }
[16:20:44.554]                     invisible(muffled)
[16:20:44.554]                   }
[16:20:44.554]                   muffleCondition(cond)
[16:20:44.554]                 })
[16:20:44.554]             }))
[16:20:44.554]             future::FutureResult(value = ...future.value$value, 
[16:20:44.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.554]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.554]                     ...future.globalenv.names))
[16:20:44.554]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.554]         }, condition = base::local({
[16:20:44.554]             c <- base::c
[16:20:44.554]             inherits <- base::inherits
[16:20:44.554]             invokeRestart <- base::invokeRestart
[16:20:44.554]             length <- base::length
[16:20:44.554]             list <- base::list
[16:20:44.554]             seq.int <- base::seq.int
[16:20:44.554]             signalCondition <- base::signalCondition
[16:20:44.554]             sys.calls <- base::sys.calls
[16:20:44.554]             `[[` <- base::`[[`
[16:20:44.554]             `+` <- base::`+`
[16:20:44.554]             `<<-` <- base::`<<-`
[16:20:44.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.554]                   3L)]
[16:20:44.554]             }
[16:20:44.554]             function(cond) {
[16:20:44.554]                 is_error <- inherits(cond, "error")
[16:20:44.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.554]                   NULL)
[16:20:44.554]                 if (is_error) {
[16:20:44.554]                   sessionInformation <- function() {
[16:20:44.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.554]                       search = base::search(), system = base::Sys.info())
[16:20:44.554]                   }
[16:20:44.554]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.554]                     cond$call), session = sessionInformation(), 
[16:20:44.554]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.554]                   signalCondition(cond)
[16:20:44.554]                 }
[16:20:44.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.554]                 "immediateCondition"))) {
[16:20:44.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.554]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.554]                   if (TRUE && !signal) {
[16:20:44.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.554]                     {
[16:20:44.554]                       inherits <- base::inherits
[16:20:44.554]                       invokeRestart <- base::invokeRestart
[16:20:44.554]                       is.null <- base::is.null
[16:20:44.554]                       muffled <- FALSE
[16:20:44.554]                       if (inherits(cond, "message")) {
[16:20:44.554]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.554]                         if (muffled) 
[16:20:44.554]                           invokeRestart("muffleMessage")
[16:20:44.554]                       }
[16:20:44.554]                       else if (inherits(cond, "warning")) {
[16:20:44.554]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.554]                         if (muffled) 
[16:20:44.554]                           invokeRestart("muffleWarning")
[16:20:44.554]                       }
[16:20:44.554]                       else if (inherits(cond, "condition")) {
[16:20:44.554]                         if (!is.null(pattern)) {
[16:20:44.554]                           computeRestarts <- base::computeRestarts
[16:20:44.554]                           grepl <- base::grepl
[16:20:44.554]                           restarts <- computeRestarts(cond)
[16:20:44.554]                           for (restart in restarts) {
[16:20:44.554]                             name <- restart$name
[16:20:44.554]                             if (is.null(name)) 
[16:20:44.554]                               next
[16:20:44.554]                             if (!grepl(pattern, name)) 
[16:20:44.554]                               next
[16:20:44.554]                             invokeRestart(restart)
[16:20:44.554]                             muffled <- TRUE
[16:20:44.554]                             break
[16:20:44.554]                           }
[16:20:44.554]                         }
[16:20:44.554]                       }
[16:20:44.554]                       invisible(muffled)
[16:20:44.554]                     }
[16:20:44.554]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.554]                   }
[16:20:44.554]                 }
[16:20:44.554]                 else {
[16:20:44.554]                   if (TRUE) {
[16:20:44.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.554]                     {
[16:20:44.554]                       inherits <- base::inherits
[16:20:44.554]                       invokeRestart <- base::invokeRestart
[16:20:44.554]                       is.null <- base::is.null
[16:20:44.554]                       muffled <- FALSE
[16:20:44.554]                       if (inherits(cond, "message")) {
[16:20:44.554]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.554]                         if (muffled) 
[16:20:44.554]                           invokeRestart("muffleMessage")
[16:20:44.554]                       }
[16:20:44.554]                       else if (inherits(cond, "warning")) {
[16:20:44.554]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.554]                         if (muffled) 
[16:20:44.554]                           invokeRestart("muffleWarning")
[16:20:44.554]                       }
[16:20:44.554]                       else if (inherits(cond, "condition")) {
[16:20:44.554]                         if (!is.null(pattern)) {
[16:20:44.554]                           computeRestarts <- base::computeRestarts
[16:20:44.554]                           grepl <- base::grepl
[16:20:44.554]                           restarts <- computeRestarts(cond)
[16:20:44.554]                           for (restart in restarts) {
[16:20:44.554]                             name <- restart$name
[16:20:44.554]                             if (is.null(name)) 
[16:20:44.554]                               next
[16:20:44.554]                             if (!grepl(pattern, name)) 
[16:20:44.554]                               next
[16:20:44.554]                             invokeRestart(restart)
[16:20:44.554]                             muffled <- TRUE
[16:20:44.554]                             break
[16:20:44.554]                           }
[16:20:44.554]                         }
[16:20:44.554]                       }
[16:20:44.554]                       invisible(muffled)
[16:20:44.554]                     }
[16:20:44.554]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.554]                   }
[16:20:44.554]                 }
[16:20:44.554]             }
[16:20:44.554]         }))
[16:20:44.554]     }, error = function(ex) {
[16:20:44.554]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.554]                 ...future.rng), started = ...future.startTime, 
[16:20:44.554]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.554]             version = "1.8"), class = "FutureResult")
[16:20:44.554]     }, finally = {
[16:20:44.554]         if (!identical(...future.workdir, getwd())) 
[16:20:44.554]             setwd(...future.workdir)
[16:20:44.554]         {
[16:20:44.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.554]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.554]             }
[16:20:44.554]             base::options(...future.oldOptions)
[16:20:44.554]             if (.Platform$OS.type == "windows") {
[16:20:44.554]                 old_names <- names(...future.oldEnvVars)
[16:20:44.554]                 envs <- base::Sys.getenv()
[16:20:44.554]                 names <- names(envs)
[16:20:44.554]                 common <- intersect(names, old_names)
[16:20:44.554]                 added <- setdiff(names, old_names)
[16:20:44.554]                 removed <- setdiff(old_names, names)
[16:20:44.554]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.554]                   envs[common]]
[16:20:44.554]                 NAMES <- toupper(changed)
[16:20:44.554]                 args <- list()
[16:20:44.554]                 for (kk in seq_along(NAMES)) {
[16:20:44.554]                   name <- changed[[kk]]
[16:20:44.554]                   NAME <- NAMES[[kk]]
[16:20:44.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.554]                     next
[16:20:44.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.554]                 }
[16:20:44.554]                 NAMES <- toupper(added)
[16:20:44.554]                 for (kk in seq_along(NAMES)) {
[16:20:44.554]                   name <- added[[kk]]
[16:20:44.554]                   NAME <- NAMES[[kk]]
[16:20:44.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.554]                     next
[16:20:44.554]                   args[[name]] <- ""
[16:20:44.554]                 }
[16:20:44.554]                 NAMES <- toupper(removed)
[16:20:44.554]                 for (kk in seq_along(NAMES)) {
[16:20:44.554]                   name <- removed[[kk]]
[16:20:44.554]                   NAME <- NAMES[[kk]]
[16:20:44.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.554]                     next
[16:20:44.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.554]                 }
[16:20:44.554]                 if (length(args) > 0) 
[16:20:44.554]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.554]             }
[16:20:44.554]             else {
[16:20:44.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.554]             }
[16:20:44.554]             {
[16:20:44.554]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.554]                   0L) {
[16:20:44.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.554]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.554]                   base::options(opts)
[16:20:44.554]                 }
[16:20:44.554]                 {
[16:20:44.554]                   {
[16:20:44.554]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.554]                     NULL
[16:20:44.554]                   }
[16:20:44.554]                   options(future.plan = NULL)
[16:20:44.554]                   if (is.na(NA_character_)) 
[16:20:44.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.554]                     .init = FALSE)
[16:20:44.554]                 }
[16:20:44.554]             }
[16:20:44.554]         }
[16:20:44.554]     })
[16:20:44.554]     if (TRUE) {
[16:20:44.554]         base::sink(type = "output", split = FALSE)
[16:20:44.554]         if (TRUE) {
[16:20:44.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.554]         }
[16:20:44.554]         else {
[16:20:44.554]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.554]         }
[16:20:44.554]         base::close(...future.stdout)
[16:20:44.554]         ...future.stdout <- NULL
[16:20:44.554]     }
[16:20:44.554]     ...future.result$conditions <- ...future.conditions
[16:20:44.554]     ...future.result$finished <- base::Sys.time()
[16:20:44.554]     ...future.result
[16:20:44.554] }
[16:20:44.556] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:44.567] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.567] - Validating connection of MultisessionFuture
[16:20:44.567] - received message: FutureResult
[16:20:44.568] - Received FutureResult
[16:20:44.568] - Erased future from FutureRegistry
[16:20:44.568] result() for ClusterFuture ...
[16:20:44.568] - result already collected: FutureResult
[16:20:44.568] result() for ClusterFuture ... done
[16:20:44.568] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.568] result() for ClusterFuture ...
[16:20:44.568] - result already collected: FutureResult
[16:20:44.568] result() for ClusterFuture ... done
[16:20:44.568] result() for ClusterFuture ...
[16:20:44.569] - result already collected: FutureResult
[16:20:44.569] result() for ClusterFuture ... done
[16:20:44.570] MultisessionFuture started
[16:20:44.570] - Launch lazy future ... done
[16:20:44.570] run() for ‘MultisessionFuture’ ... done
<environment: 0x55ed0bed6160> 
<environment: 0x55ed0d6516c8> 
[16:20:44.571] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.572] - Validating connection of MultisessionFuture
[16:20:44.572] - received message: FutureResult
[16:20:44.572] - Received FutureResult
[16:20:44.572] - Erased future from FutureRegistry
[16:20:44.572] result() for ClusterFuture ...
[16:20:44.572] - result already collected: FutureResult
[16:20:44.572] result() for ClusterFuture ... done
[16:20:44.572] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.573] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.573] - Validating connection of MultisessionFuture
[16:20:44.573] - received message: FutureResult
[16:20:44.573] - Received FutureResult
[16:20:44.573] - Erased future from FutureRegistry
[16:20:44.573] result() for ClusterFuture ...
[16:20:44.573] - result already collected: FutureResult
[16:20:44.573] result() for ClusterFuture ... done
[16:20:44.574] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:44.575] resolve() on environment ...
[16:20:44.575]  recursive: 0
[16:20:44.575]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:44.575] signalConditionsASAP(numeric, pos=1) ...
[16:20:44.575] - nx: 4
[16:20:44.576] - relay: TRUE
[16:20:44.576] - stdout: TRUE
[16:20:44.576] - signal: TRUE
[16:20:44.576] - resignal: FALSE
[16:20:44.576] - force: TRUE
[16:20:44.576] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.576] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.576]  - until=2
[16:20:44.576]  - relaying element #2
[16:20:44.576] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.576] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.577] signalConditionsASAP(NULL, pos=1) ... done
[16:20:44.577]  length: 3 (resolved future 1)
[16:20:44.577] Future #2
[16:20:44.577] result() for ClusterFuture ...
[16:20:44.577] - result already collected: FutureResult
[16:20:44.577] result() for ClusterFuture ... done
[16:20:44.577] result() for ClusterFuture ...
[16:20:44.577] - result already collected: FutureResult
[16:20:44.577] result() for ClusterFuture ... done
[16:20:44.577] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:44.577] - nx: 4
[16:20:44.578] - relay: TRUE
[16:20:44.578] - stdout: TRUE
[16:20:44.578] - signal: TRUE
[16:20:44.578] - resignal: FALSE
[16:20:44.578] - force: TRUE
[16:20:44.578] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.578] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.578]  - until=2
[16:20:44.578]  - relaying element #2
[16:20:44.578] result() for ClusterFuture ...
[16:20:44.578] - result already collected: FutureResult
[16:20:44.578] result() for ClusterFuture ... done
[16:20:44.579] result() for ClusterFuture ...
[16:20:44.579] - result already collected: FutureResult
[16:20:44.579] result() for ClusterFuture ... done
[16:20:44.579] result() for ClusterFuture ...
[16:20:44.579] - result already collected: FutureResult
[16:20:44.579] result() for ClusterFuture ... done
[16:20:44.579] result() for ClusterFuture ...
[16:20:44.579] - result already collected: FutureResult
[16:20:44.579] result() for ClusterFuture ... done
[16:20:44.579] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.579] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.580] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:44.580]  length: 2 (resolved future 2)
[16:20:44.580] Future #3
[16:20:44.580] result() for ClusterFuture ...
[16:20:44.580] - result already collected: FutureResult
[16:20:44.580] result() for ClusterFuture ... done
[16:20:44.580] result() for ClusterFuture ...
[16:20:44.580] - result already collected: FutureResult
[16:20:44.580] result() for ClusterFuture ... done
[16:20:44.580] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:44.581] - nx: 4
[16:20:44.581] - relay: TRUE
[16:20:44.581] - stdout: TRUE
[16:20:44.581] - signal: TRUE
[16:20:44.581] - resignal: FALSE
[16:20:44.581] - force: TRUE
[16:20:44.581] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.581] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.581]  - until=3
[16:20:44.581]  - relaying element #3
[16:20:44.581] result() for ClusterFuture ...
[16:20:44.581] - result already collected: FutureResult
[16:20:44.582] result() for ClusterFuture ... done
[16:20:44.582] result() for ClusterFuture ...
[16:20:44.582] - result already collected: FutureResult
[16:20:44.582] result() for ClusterFuture ... done
[16:20:44.582] result() for ClusterFuture ...
[16:20:44.582] - result already collected: FutureResult
[16:20:44.582] result() for ClusterFuture ... done
[16:20:44.582] result() for ClusterFuture ...
[16:20:44.582] - result already collected: FutureResult
[16:20:44.582] result() for ClusterFuture ... done
[16:20:44.582] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.583] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.583] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:44.583]  length: 1 (resolved future 3)
[16:20:44.583] Future #4
[16:20:44.583] result() for ClusterFuture ...
[16:20:44.583] - result already collected: FutureResult
[16:20:44.583] result() for ClusterFuture ... done
[16:20:44.583] result() for ClusterFuture ...
[16:20:44.583] - result already collected: FutureResult
[16:20:44.583] result() for ClusterFuture ... done
[16:20:44.583] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:44.584] - nx: 4
[16:20:44.584] - relay: TRUE
[16:20:44.584] - stdout: TRUE
[16:20:44.584] - signal: TRUE
[16:20:44.584] - resignal: FALSE
[16:20:44.584] - force: TRUE
[16:20:44.584] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.584] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.584]  - until=4
[16:20:44.584]  - relaying element #4
[16:20:44.584] result() for ClusterFuture ...
[16:20:44.585] - result already collected: FutureResult
[16:20:44.585] result() for ClusterFuture ... done
[16:20:44.585] result() for ClusterFuture ...
[16:20:44.585] - result already collected: FutureResult
[16:20:44.585] result() for ClusterFuture ... done
[16:20:44.585] result() for ClusterFuture ...
[16:20:44.585] - result already collected: FutureResult
[16:20:44.585] result() for ClusterFuture ... done
[16:20:44.585] result() for ClusterFuture ...
[16:20:44.585] - result already collected: FutureResult
[16:20:44.585] result() for ClusterFuture ... done
[16:20:44.586] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.586] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.586] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:44.586]  length: 0 (resolved future 4)
[16:20:44.586] Relaying remaining futures
[16:20:44.586] signalConditionsASAP(NULL, pos=0) ...
[16:20:44.586] - nx: 4
[16:20:44.586] - relay: TRUE
[16:20:44.586] - stdout: TRUE
[16:20:44.586] - signal: TRUE
[16:20:44.586] - resignal: FALSE
[16:20:44.586] - force: TRUE
[16:20:44.586] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.587] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:44.587] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.587] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.587] signalConditionsASAP(NULL, pos=0) ... done
[16:20:44.587] resolve() on environment ... DONE
[16:20:44.587] result() for ClusterFuture ...
[16:20:44.587] - result already collected: FutureResult
[16:20:44.587] result() for ClusterFuture ... done
[16:20:44.587] result() for ClusterFuture ...
[16:20:44.587] - result already collected: FutureResult
[16:20:44.588] result() for ClusterFuture ... done
[16:20:44.588] result() for ClusterFuture ...
[16:20:44.588] - result already collected: FutureResult
[16:20:44.588] result() for ClusterFuture ... done
[16:20:44.588] result() for ClusterFuture ...
[16:20:44.588] - result already collected: FutureResult
[16:20:44.588] result() for ClusterFuture ... done
[16:20:44.588] result() for ClusterFuture ...
[16:20:44.588] - result already collected: FutureResult
[16:20:44.588] result() for ClusterFuture ... done
[16:20:44.588] result() for ClusterFuture ...
[16:20:44.589] - result already collected: FutureResult
[16:20:44.589] result() for ClusterFuture ... done
<environment: 0x55ed0d83f278> 
Dimensions: c(2, 1, 3, 1)
[16:20:44.589] getGlobalsAndPackages() ...
[16:20:44.589] Searching for globals...
[16:20:44.589] 
[16:20:44.589] Searching for globals ... DONE
[16:20:44.590] - globals: [0] <none>
[16:20:44.590] getGlobalsAndPackages() ... DONE
[16:20:44.590] run() for ‘Future’ ...
[16:20:44.590] - state: ‘created’
[16:20:44.590] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.604] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.604] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.606]   - Field: ‘node’
[16:20:44.606]   - Field: ‘label’
[16:20:44.606]   - Field: ‘local’
[16:20:44.607]   - Field: ‘owner’
[16:20:44.607]   - Field: ‘envir’
[16:20:44.607]   - Field: ‘workers’
[16:20:44.607]   - Field: ‘packages’
[16:20:44.607]   - Field: ‘gc’
[16:20:44.607]   - Field: ‘conditions’
[16:20:44.607]   - Field: ‘persistent’
[16:20:44.607]   - Field: ‘expr’
[16:20:44.607]   - Field: ‘uuid’
[16:20:44.608]   - Field: ‘seed’
[16:20:44.608]   - Field: ‘version’
[16:20:44.608]   - Field: ‘result’
[16:20:44.608]   - Field: ‘asynchronous’
[16:20:44.608]   - Field: ‘calls’
[16:20:44.608]   - Field: ‘globals’
[16:20:44.608]   - Field: ‘stdout’
[16:20:44.608]   - Field: ‘earlySignal’
[16:20:44.608]   - Field: ‘lazy’
[16:20:44.608]   - Field: ‘state’
[16:20:44.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.609] - Launch lazy future ...
[16:20:44.609] Packages needed by the future expression (n = 0): <none>
[16:20:44.609] Packages needed by future strategies (n = 0): <none>
[16:20:44.609] {
[16:20:44.609]     {
[16:20:44.609]         {
[16:20:44.609]             ...future.startTime <- base::Sys.time()
[16:20:44.609]             {
[16:20:44.609]                 {
[16:20:44.609]                   {
[16:20:44.609]                     {
[16:20:44.609]                       base::local({
[16:20:44.609]                         has_future <- base::requireNamespace("future", 
[16:20:44.609]                           quietly = TRUE)
[16:20:44.609]                         if (has_future) {
[16:20:44.609]                           ns <- base::getNamespace("future")
[16:20:44.609]                           version <- ns[[".package"]][["version"]]
[16:20:44.609]                           if (is.null(version)) 
[16:20:44.609]                             version <- utils::packageVersion("future")
[16:20:44.609]                         }
[16:20:44.609]                         else {
[16:20:44.609]                           version <- NULL
[16:20:44.609]                         }
[16:20:44.609]                         if (!has_future || version < "1.8.0") {
[16:20:44.609]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.609]                             "", base::R.version$version.string), 
[16:20:44.609]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.609]                               "release", "version")], collapse = " "), 
[16:20:44.609]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.609]                             info)
[16:20:44.609]                           info <- base::paste(info, collapse = "; ")
[16:20:44.609]                           if (!has_future) {
[16:20:44.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.609]                               info)
[16:20:44.609]                           }
[16:20:44.609]                           else {
[16:20:44.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.609]                               info, version)
[16:20:44.609]                           }
[16:20:44.609]                           base::stop(msg)
[16:20:44.609]                         }
[16:20:44.609]                       })
[16:20:44.609]                     }
[16:20:44.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.609]                     base::options(mc.cores = 1L)
[16:20:44.609]                   }
[16:20:44.609]                   ...future.strategy.old <- future::plan("list")
[16:20:44.609]                   options(future.plan = NULL)
[16:20:44.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.609]                 }
[16:20:44.609]                 ...future.workdir <- getwd()
[16:20:44.609]             }
[16:20:44.609]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.609]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.609]         }
[16:20:44.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.609]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.609]             base::names(...future.oldOptions))
[16:20:44.609]     }
[16:20:44.609]     if (FALSE) {
[16:20:44.609]     }
[16:20:44.609]     else {
[16:20:44.609]         if (TRUE) {
[16:20:44.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.609]                 open = "w")
[16:20:44.609]         }
[16:20:44.609]         else {
[16:20:44.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.609]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.609]         }
[16:20:44.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.609]             base::sink(type = "output", split = FALSE)
[16:20:44.609]             base::close(...future.stdout)
[16:20:44.609]         }, add = TRUE)
[16:20:44.609]     }
[16:20:44.609]     ...future.frame <- base::sys.nframe()
[16:20:44.609]     ...future.conditions <- base::list()
[16:20:44.609]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.609]     if (FALSE) {
[16:20:44.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.609]     }
[16:20:44.609]     ...future.result <- base::tryCatch({
[16:20:44.609]         base::withCallingHandlers({
[16:20:44.609]             ...future.value <- base::withVisible(base::local({
[16:20:44.609]                 ...future.makeSendCondition <- base::local({
[16:20:44.609]                   sendCondition <- NULL
[16:20:44.609]                   function(frame = 1L) {
[16:20:44.609]                     if (is.function(sendCondition)) 
[16:20:44.609]                       return(sendCondition)
[16:20:44.609]                     ns <- getNamespace("parallel")
[16:20:44.609]                     if (exists("sendData", mode = "function", 
[16:20:44.609]                       envir = ns)) {
[16:20:44.609]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.609]                         envir = ns)
[16:20:44.609]                       envir <- sys.frame(frame)
[16:20:44.609]                       master <- NULL
[16:20:44.609]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.609]                         !identical(envir, emptyenv())) {
[16:20:44.609]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.609]                           inherits = FALSE)) {
[16:20:44.609]                           master <- get("master", mode = "list", 
[16:20:44.609]                             envir = envir, inherits = FALSE)
[16:20:44.609]                           if (inherits(master, c("SOCKnode", 
[16:20:44.609]                             "SOCK0node"))) {
[16:20:44.609]                             sendCondition <<- function(cond) {
[16:20:44.609]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.609]                                 success = TRUE)
[16:20:44.609]                               parallel_sendData(master, data)
[16:20:44.609]                             }
[16:20:44.609]                             return(sendCondition)
[16:20:44.609]                           }
[16:20:44.609]                         }
[16:20:44.609]                         frame <- frame + 1L
[16:20:44.609]                         envir <- sys.frame(frame)
[16:20:44.609]                       }
[16:20:44.609]                     }
[16:20:44.609]                     sendCondition <<- function(cond) NULL
[16:20:44.609]                   }
[16:20:44.609]                 })
[16:20:44.609]                 withCallingHandlers({
[16:20:44.609]                   2
[16:20:44.609]                 }, immediateCondition = function(cond) {
[16:20:44.609]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.609]                   sendCondition(cond)
[16:20:44.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.609]                   {
[16:20:44.609]                     inherits <- base::inherits
[16:20:44.609]                     invokeRestart <- base::invokeRestart
[16:20:44.609]                     is.null <- base::is.null
[16:20:44.609]                     muffled <- FALSE
[16:20:44.609]                     if (inherits(cond, "message")) {
[16:20:44.609]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.609]                       if (muffled) 
[16:20:44.609]                         invokeRestart("muffleMessage")
[16:20:44.609]                     }
[16:20:44.609]                     else if (inherits(cond, "warning")) {
[16:20:44.609]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.609]                       if (muffled) 
[16:20:44.609]                         invokeRestart("muffleWarning")
[16:20:44.609]                     }
[16:20:44.609]                     else if (inherits(cond, "condition")) {
[16:20:44.609]                       if (!is.null(pattern)) {
[16:20:44.609]                         computeRestarts <- base::computeRestarts
[16:20:44.609]                         grepl <- base::grepl
[16:20:44.609]                         restarts <- computeRestarts(cond)
[16:20:44.609]                         for (restart in restarts) {
[16:20:44.609]                           name <- restart$name
[16:20:44.609]                           if (is.null(name)) 
[16:20:44.609]                             next
[16:20:44.609]                           if (!grepl(pattern, name)) 
[16:20:44.609]                             next
[16:20:44.609]                           invokeRestart(restart)
[16:20:44.609]                           muffled <- TRUE
[16:20:44.609]                           break
[16:20:44.609]                         }
[16:20:44.609]                       }
[16:20:44.609]                     }
[16:20:44.609]                     invisible(muffled)
[16:20:44.609]                   }
[16:20:44.609]                   muffleCondition(cond)
[16:20:44.609]                 })
[16:20:44.609]             }))
[16:20:44.609]             future::FutureResult(value = ...future.value$value, 
[16:20:44.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.609]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.609]                     ...future.globalenv.names))
[16:20:44.609]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.609]         }, condition = base::local({
[16:20:44.609]             c <- base::c
[16:20:44.609]             inherits <- base::inherits
[16:20:44.609]             invokeRestart <- base::invokeRestart
[16:20:44.609]             length <- base::length
[16:20:44.609]             list <- base::list
[16:20:44.609]             seq.int <- base::seq.int
[16:20:44.609]             signalCondition <- base::signalCondition
[16:20:44.609]             sys.calls <- base::sys.calls
[16:20:44.609]             `[[` <- base::`[[`
[16:20:44.609]             `+` <- base::`+`
[16:20:44.609]             `<<-` <- base::`<<-`
[16:20:44.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.609]                   3L)]
[16:20:44.609]             }
[16:20:44.609]             function(cond) {
[16:20:44.609]                 is_error <- inherits(cond, "error")
[16:20:44.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.609]                   NULL)
[16:20:44.609]                 if (is_error) {
[16:20:44.609]                   sessionInformation <- function() {
[16:20:44.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.609]                       search = base::search(), system = base::Sys.info())
[16:20:44.609]                   }
[16:20:44.609]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.609]                     cond$call), session = sessionInformation(), 
[16:20:44.609]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.609]                   signalCondition(cond)
[16:20:44.609]                 }
[16:20:44.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.609]                 "immediateCondition"))) {
[16:20:44.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.609]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.609]                   if (TRUE && !signal) {
[16:20:44.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.609]                     {
[16:20:44.609]                       inherits <- base::inherits
[16:20:44.609]                       invokeRestart <- base::invokeRestart
[16:20:44.609]                       is.null <- base::is.null
[16:20:44.609]                       muffled <- FALSE
[16:20:44.609]                       if (inherits(cond, "message")) {
[16:20:44.609]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.609]                         if (muffled) 
[16:20:44.609]                           invokeRestart("muffleMessage")
[16:20:44.609]                       }
[16:20:44.609]                       else if (inherits(cond, "warning")) {
[16:20:44.609]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.609]                         if (muffled) 
[16:20:44.609]                           invokeRestart("muffleWarning")
[16:20:44.609]                       }
[16:20:44.609]                       else if (inherits(cond, "condition")) {
[16:20:44.609]                         if (!is.null(pattern)) {
[16:20:44.609]                           computeRestarts <- base::computeRestarts
[16:20:44.609]                           grepl <- base::grepl
[16:20:44.609]                           restarts <- computeRestarts(cond)
[16:20:44.609]                           for (restart in restarts) {
[16:20:44.609]                             name <- restart$name
[16:20:44.609]                             if (is.null(name)) 
[16:20:44.609]                               next
[16:20:44.609]                             if (!grepl(pattern, name)) 
[16:20:44.609]                               next
[16:20:44.609]                             invokeRestart(restart)
[16:20:44.609]                             muffled <- TRUE
[16:20:44.609]                             break
[16:20:44.609]                           }
[16:20:44.609]                         }
[16:20:44.609]                       }
[16:20:44.609]                       invisible(muffled)
[16:20:44.609]                     }
[16:20:44.609]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.609]                   }
[16:20:44.609]                 }
[16:20:44.609]                 else {
[16:20:44.609]                   if (TRUE) {
[16:20:44.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.609]                     {
[16:20:44.609]                       inherits <- base::inherits
[16:20:44.609]                       invokeRestart <- base::invokeRestart
[16:20:44.609]                       is.null <- base::is.null
[16:20:44.609]                       muffled <- FALSE
[16:20:44.609]                       if (inherits(cond, "message")) {
[16:20:44.609]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.609]                         if (muffled) 
[16:20:44.609]                           invokeRestart("muffleMessage")
[16:20:44.609]                       }
[16:20:44.609]                       else if (inherits(cond, "warning")) {
[16:20:44.609]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.609]                         if (muffled) 
[16:20:44.609]                           invokeRestart("muffleWarning")
[16:20:44.609]                       }
[16:20:44.609]                       else if (inherits(cond, "condition")) {
[16:20:44.609]                         if (!is.null(pattern)) {
[16:20:44.609]                           computeRestarts <- base::computeRestarts
[16:20:44.609]                           grepl <- base::grepl
[16:20:44.609]                           restarts <- computeRestarts(cond)
[16:20:44.609]                           for (restart in restarts) {
[16:20:44.609]                             name <- restart$name
[16:20:44.609]                             if (is.null(name)) 
[16:20:44.609]                               next
[16:20:44.609]                             if (!grepl(pattern, name)) 
[16:20:44.609]                               next
[16:20:44.609]                             invokeRestart(restart)
[16:20:44.609]                             muffled <- TRUE
[16:20:44.609]                             break
[16:20:44.609]                           }
[16:20:44.609]                         }
[16:20:44.609]                       }
[16:20:44.609]                       invisible(muffled)
[16:20:44.609]                     }
[16:20:44.609]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.609]                   }
[16:20:44.609]                 }
[16:20:44.609]             }
[16:20:44.609]         }))
[16:20:44.609]     }, error = function(ex) {
[16:20:44.609]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.609]                 ...future.rng), started = ...future.startTime, 
[16:20:44.609]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.609]             version = "1.8"), class = "FutureResult")
[16:20:44.609]     }, finally = {
[16:20:44.609]         if (!identical(...future.workdir, getwd())) 
[16:20:44.609]             setwd(...future.workdir)
[16:20:44.609]         {
[16:20:44.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.609]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.609]             }
[16:20:44.609]             base::options(...future.oldOptions)
[16:20:44.609]             if (.Platform$OS.type == "windows") {
[16:20:44.609]                 old_names <- names(...future.oldEnvVars)
[16:20:44.609]                 envs <- base::Sys.getenv()
[16:20:44.609]                 names <- names(envs)
[16:20:44.609]                 common <- intersect(names, old_names)
[16:20:44.609]                 added <- setdiff(names, old_names)
[16:20:44.609]                 removed <- setdiff(old_names, names)
[16:20:44.609]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.609]                   envs[common]]
[16:20:44.609]                 NAMES <- toupper(changed)
[16:20:44.609]                 args <- list()
[16:20:44.609]                 for (kk in seq_along(NAMES)) {
[16:20:44.609]                   name <- changed[[kk]]
[16:20:44.609]                   NAME <- NAMES[[kk]]
[16:20:44.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.609]                     next
[16:20:44.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.609]                 }
[16:20:44.609]                 NAMES <- toupper(added)
[16:20:44.609]                 for (kk in seq_along(NAMES)) {
[16:20:44.609]                   name <- added[[kk]]
[16:20:44.609]                   NAME <- NAMES[[kk]]
[16:20:44.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.609]                     next
[16:20:44.609]                   args[[name]] <- ""
[16:20:44.609]                 }
[16:20:44.609]                 NAMES <- toupper(removed)
[16:20:44.609]                 for (kk in seq_along(NAMES)) {
[16:20:44.609]                   name <- removed[[kk]]
[16:20:44.609]                   NAME <- NAMES[[kk]]
[16:20:44.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.609]                     next
[16:20:44.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.609]                 }
[16:20:44.609]                 if (length(args) > 0) 
[16:20:44.609]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.609]             }
[16:20:44.609]             else {
[16:20:44.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.609]             }
[16:20:44.609]             {
[16:20:44.609]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.609]                   0L) {
[16:20:44.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.609]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.609]                   base::options(opts)
[16:20:44.609]                 }
[16:20:44.609]                 {
[16:20:44.609]                   {
[16:20:44.609]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.609]                     NULL
[16:20:44.609]                   }
[16:20:44.609]                   options(future.plan = NULL)
[16:20:44.609]                   if (is.na(NA_character_)) 
[16:20:44.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.609]                     .init = FALSE)
[16:20:44.609]                 }
[16:20:44.609]             }
[16:20:44.609]         }
[16:20:44.609]     })
[16:20:44.609]     if (TRUE) {
[16:20:44.609]         base::sink(type = "output", split = FALSE)
[16:20:44.609]         if (TRUE) {
[16:20:44.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.609]         }
[16:20:44.609]         else {
[16:20:44.609]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.609]         }
[16:20:44.609]         base::close(...future.stdout)
[16:20:44.609]         ...future.stdout <- NULL
[16:20:44.609]     }
[16:20:44.609]     ...future.result$conditions <- ...future.conditions
[16:20:44.609]     ...future.result$finished <- base::Sys.time()
[16:20:44.609]     ...future.result
[16:20:44.609] }
[16:20:44.612] MultisessionFuture started
[16:20:44.612] - Launch lazy future ... done
[16:20:44.613] run() for ‘MultisessionFuture’ ... done
[16:20:44.613] getGlobalsAndPackages() ...
[16:20:44.613] Searching for globals...
[16:20:44.613] 
[16:20:44.613] Searching for globals ... DONE
[16:20:44.614] - globals: [0] <none>
[16:20:44.614] getGlobalsAndPackages() ... DONE
[16:20:44.614] run() for ‘Future’ ...
[16:20:44.614] - state: ‘created’
[16:20:44.614] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.628] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.628] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.629]   - Field: ‘node’
[16:20:44.629]   - Field: ‘label’
[16:20:44.629]   - Field: ‘local’
[16:20:44.629]   - Field: ‘owner’
[16:20:44.629]   - Field: ‘envir’
[16:20:44.629]   - Field: ‘workers’
[16:20:44.629]   - Field: ‘packages’
[16:20:44.629]   - Field: ‘gc’
[16:20:44.629]   - Field: ‘conditions’
[16:20:44.629]   - Field: ‘persistent’
[16:20:44.629]   - Field: ‘expr’
[16:20:44.630]   - Field: ‘uuid’
[16:20:44.630]   - Field: ‘seed’
[16:20:44.630]   - Field: ‘version’
[16:20:44.630]   - Field: ‘result’
[16:20:44.630]   - Field: ‘asynchronous’
[16:20:44.630]   - Field: ‘calls’
[16:20:44.630]   - Field: ‘globals’
[16:20:44.630]   - Field: ‘stdout’
[16:20:44.630]   - Field: ‘earlySignal’
[16:20:44.630]   - Field: ‘lazy’
[16:20:44.630]   - Field: ‘state’
[16:20:44.630] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.631] - Launch lazy future ...
[16:20:44.631] Packages needed by the future expression (n = 0): <none>
[16:20:44.631] Packages needed by future strategies (n = 0): <none>
[16:20:44.631] {
[16:20:44.631]     {
[16:20:44.631]         {
[16:20:44.631]             ...future.startTime <- base::Sys.time()
[16:20:44.631]             {
[16:20:44.631]                 {
[16:20:44.631]                   {
[16:20:44.631]                     {
[16:20:44.631]                       base::local({
[16:20:44.631]                         has_future <- base::requireNamespace("future", 
[16:20:44.631]                           quietly = TRUE)
[16:20:44.631]                         if (has_future) {
[16:20:44.631]                           ns <- base::getNamespace("future")
[16:20:44.631]                           version <- ns[[".package"]][["version"]]
[16:20:44.631]                           if (is.null(version)) 
[16:20:44.631]                             version <- utils::packageVersion("future")
[16:20:44.631]                         }
[16:20:44.631]                         else {
[16:20:44.631]                           version <- NULL
[16:20:44.631]                         }
[16:20:44.631]                         if (!has_future || version < "1.8.0") {
[16:20:44.631]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.631]                             "", base::R.version$version.string), 
[16:20:44.631]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.631]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.631]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.631]                               "release", "version")], collapse = " "), 
[16:20:44.631]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.631]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.631]                             info)
[16:20:44.631]                           info <- base::paste(info, collapse = "; ")
[16:20:44.631]                           if (!has_future) {
[16:20:44.631]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.631]                               info)
[16:20:44.631]                           }
[16:20:44.631]                           else {
[16:20:44.631]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.631]                               info, version)
[16:20:44.631]                           }
[16:20:44.631]                           base::stop(msg)
[16:20:44.631]                         }
[16:20:44.631]                       })
[16:20:44.631]                     }
[16:20:44.631]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.631]                     base::options(mc.cores = 1L)
[16:20:44.631]                   }
[16:20:44.631]                   ...future.strategy.old <- future::plan("list")
[16:20:44.631]                   options(future.plan = NULL)
[16:20:44.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.631]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.631]                 }
[16:20:44.631]                 ...future.workdir <- getwd()
[16:20:44.631]             }
[16:20:44.631]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.631]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.631]         }
[16:20:44.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.631]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.631]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.631]             base::names(...future.oldOptions))
[16:20:44.631]     }
[16:20:44.631]     if (FALSE) {
[16:20:44.631]     }
[16:20:44.631]     else {
[16:20:44.631]         if (TRUE) {
[16:20:44.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.631]                 open = "w")
[16:20:44.631]         }
[16:20:44.631]         else {
[16:20:44.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.631]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.631]         }
[16:20:44.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.631]             base::sink(type = "output", split = FALSE)
[16:20:44.631]             base::close(...future.stdout)
[16:20:44.631]         }, add = TRUE)
[16:20:44.631]     }
[16:20:44.631]     ...future.frame <- base::sys.nframe()
[16:20:44.631]     ...future.conditions <- base::list()
[16:20:44.631]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.631]     if (FALSE) {
[16:20:44.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.631]     }
[16:20:44.631]     ...future.result <- base::tryCatch({
[16:20:44.631]         base::withCallingHandlers({
[16:20:44.631]             ...future.value <- base::withVisible(base::local({
[16:20:44.631]                 ...future.makeSendCondition <- base::local({
[16:20:44.631]                   sendCondition <- NULL
[16:20:44.631]                   function(frame = 1L) {
[16:20:44.631]                     if (is.function(sendCondition)) 
[16:20:44.631]                       return(sendCondition)
[16:20:44.631]                     ns <- getNamespace("parallel")
[16:20:44.631]                     if (exists("sendData", mode = "function", 
[16:20:44.631]                       envir = ns)) {
[16:20:44.631]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.631]                         envir = ns)
[16:20:44.631]                       envir <- sys.frame(frame)
[16:20:44.631]                       master <- NULL
[16:20:44.631]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.631]                         !identical(envir, emptyenv())) {
[16:20:44.631]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.631]                           inherits = FALSE)) {
[16:20:44.631]                           master <- get("master", mode = "list", 
[16:20:44.631]                             envir = envir, inherits = FALSE)
[16:20:44.631]                           if (inherits(master, c("SOCKnode", 
[16:20:44.631]                             "SOCK0node"))) {
[16:20:44.631]                             sendCondition <<- function(cond) {
[16:20:44.631]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.631]                                 success = TRUE)
[16:20:44.631]                               parallel_sendData(master, data)
[16:20:44.631]                             }
[16:20:44.631]                             return(sendCondition)
[16:20:44.631]                           }
[16:20:44.631]                         }
[16:20:44.631]                         frame <- frame + 1L
[16:20:44.631]                         envir <- sys.frame(frame)
[16:20:44.631]                       }
[16:20:44.631]                     }
[16:20:44.631]                     sendCondition <<- function(cond) NULL
[16:20:44.631]                   }
[16:20:44.631]                 })
[16:20:44.631]                 withCallingHandlers({
[16:20:44.631]                   NULL
[16:20:44.631]                 }, immediateCondition = function(cond) {
[16:20:44.631]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.631]                   sendCondition(cond)
[16:20:44.631]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.631]                   {
[16:20:44.631]                     inherits <- base::inherits
[16:20:44.631]                     invokeRestart <- base::invokeRestart
[16:20:44.631]                     is.null <- base::is.null
[16:20:44.631]                     muffled <- FALSE
[16:20:44.631]                     if (inherits(cond, "message")) {
[16:20:44.631]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.631]                       if (muffled) 
[16:20:44.631]                         invokeRestart("muffleMessage")
[16:20:44.631]                     }
[16:20:44.631]                     else if (inherits(cond, "warning")) {
[16:20:44.631]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.631]                       if (muffled) 
[16:20:44.631]                         invokeRestart("muffleWarning")
[16:20:44.631]                     }
[16:20:44.631]                     else if (inherits(cond, "condition")) {
[16:20:44.631]                       if (!is.null(pattern)) {
[16:20:44.631]                         computeRestarts <- base::computeRestarts
[16:20:44.631]                         grepl <- base::grepl
[16:20:44.631]                         restarts <- computeRestarts(cond)
[16:20:44.631]                         for (restart in restarts) {
[16:20:44.631]                           name <- restart$name
[16:20:44.631]                           if (is.null(name)) 
[16:20:44.631]                             next
[16:20:44.631]                           if (!grepl(pattern, name)) 
[16:20:44.631]                             next
[16:20:44.631]                           invokeRestart(restart)
[16:20:44.631]                           muffled <- TRUE
[16:20:44.631]                           break
[16:20:44.631]                         }
[16:20:44.631]                       }
[16:20:44.631]                     }
[16:20:44.631]                     invisible(muffled)
[16:20:44.631]                   }
[16:20:44.631]                   muffleCondition(cond)
[16:20:44.631]                 })
[16:20:44.631]             }))
[16:20:44.631]             future::FutureResult(value = ...future.value$value, 
[16:20:44.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.631]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.631]                     ...future.globalenv.names))
[16:20:44.631]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.631]         }, condition = base::local({
[16:20:44.631]             c <- base::c
[16:20:44.631]             inherits <- base::inherits
[16:20:44.631]             invokeRestart <- base::invokeRestart
[16:20:44.631]             length <- base::length
[16:20:44.631]             list <- base::list
[16:20:44.631]             seq.int <- base::seq.int
[16:20:44.631]             signalCondition <- base::signalCondition
[16:20:44.631]             sys.calls <- base::sys.calls
[16:20:44.631]             `[[` <- base::`[[`
[16:20:44.631]             `+` <- base::`+`
[16:20:44.631]             `<<-` <- base::`<<-`
[16:20:44.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.631]                   3L)]
[16:20:44.631]             }
[16:20:44.631]             function(cond) {
[16:20:44.631]                 is_error <- inherits(cond, "error")
[16:20:44.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.631]                   NULL)
[16:20:44.631]                 if (is_error) {
[16:20:44.631]                   sessionInformation <- function() {
[16:20:44.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.631]                       search = base::search(), system = base::Sys.info())
[16:20:44.631]                   }
[16:20:44.631]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.631]                     cond$call), session = sessionInformation(), 
[16:20:44.631]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.631]                   signalCondition(cond)
[16:20:44.631]                 }
[16:20:44.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.631]                 "immediateCondition"))) {
[16:20:44.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.631]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.631]                   if (TRUE && !signal) {
[16:20:44.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.631]                     {
[16:20:44.631]                       inherits <- base::inherits
[16:20:44.631]                       invokeRestart <- base::invokeRestart
[16:20:44.631]                       is.null <- base::is.null
[16:20:44.631]                       muffled <- FALSE
[16:20:44.631]                       if (inherits(cond, "message")) {
[16:20:44.631]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.631]                         if (muffled) 
[16:20:44.631]                           invokeRestart("muffleMessage")
[16:20:44.631]                       }
[16:20:44.631]                       else if (inherits(cond, "warning")) {
[16:20:44.631]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.631]                         if (muffled) 
[16:20:44.631]                           invokeRestart("muffleWarning")
[16:20:44.631]                       }
[16:20:44.631]                       else if (inherits(cond, "condition")) {
[16:20:44.631]                         if (!is.null(pattern)) {
[16:20:44.631]                           computeRestarts <- base::computeRestarts
[16:20:44.631]                           grepl <- base::grepl
[16:20:44.631]                           restarts <- computeRestarts(cond)
[16:20:44.631]                           for (restart in restarts) {
[16:20:44.631]                             name <- restart$name
[16:20:44.631]                             if (is.null(name)) 
[16:20:44.631]                               next
[16:20:44.631]                             if (!grepl(pattern, name)) 
[16:20:44.631]                               next
[16:20:44.631]                             invokeRestart(restart)
[16:20:44.631]                             muffled <- TRUE
[16:20:44.631]                             break
[16:20:44.631]                           }
[16:20:44.631]                         }
[16:20:44.631]                       }
[16:20:44.631]                       invisible(muffled)
[16:20:44.631]                     }
[16:20:44.631]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.631]                   }
[16:20:44.631]                 }
[16:20:44.631]                 else {
[16:20:44.631]                   if (TRUE) {
[16:20:44.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.631]                     {
[16:20:44.631]                       inherits <- base::inherits
[16:20:44.631]                       invokeRestart <- base::invokeRestart
[16:20:44.631]                       is.null <- base::is.null
[16:20:44.631]                       muffled <- FALSE
[16:20:44.631]                       if (inherits(cond, "message")) {
[16:20:44.631]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.631]                         if (muffled) 
[16:20:44.631]                           invokeRestart("muffleMessage")
[16:20:44.631]                       }
[16:20:44.631]                       else if (inherits(cond, "warning")) {
[16:20:44.631]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.631]                         if (muffled) 
[16:20:44.631]                           invokeRestart("muffleWarning")
[16:20:44.631]                       }
[16:20:44.631]                       else if (inherits(cond, "condition")) {
[16:20:44.631]                         if (!is.null(pattern)) {
[16:20:44.631]                           computeRestarts <- base::computeRestarts
[16:20:44.631]                           grepl <- base::grepl
[16:20:44.631]                           restarts <- computeRestarts(cond)
[16:20:44.631]                           for (restart in restarts) {
[16:20:44.631]                             name <- restart$name
[16:20:44.631]                             if (is.null(name)) 
[16:20:44.631]                               next
[16:20:44.631]                             if (!grepl(pattern, name)) 
[16:20:44.631]                               next
[16:20:44.631]                             invokeRestart(restart)
[16:20:44.631]                             muffled <- TRUE
[16:20:44.631]                             break
[16:20:44.631]                           }
[16:20:44.631]                         }
[16:20:44.631]                       }
[16:20:44.631]                       invisible(muffled)
[16:20:44.631]                     }
[16:20:44.631]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.631]                   }
[16:20:44.631]                 }
[16:20:44.631]             }
[16:20:44.631]         }))
[16:20:44.631]     }, error = function(ex) {
[16:20:44.631]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.631]                 ...future.rng), started = ...future.startTime, 
[16:20:44.631]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.631]             version = "1.8"), class = "FutureResult")
[16:20:44.631]     }, finally = {
[16:20:44.631]         if (!identical(...future.workdir, getwd())) 
[16:20:44.631]             setwd(...future.workdir)
[16:20:44.631]         {
[16:20:44.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.631]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.631]             }
[16:20:44.631]             base::options(...future.oldOptions)
[16:20:44.631]             if (.Platform$OS.type == "windows") {
[16:20:44.631]                 old_names <- names(...future.oldEnvVars)
[16:20:44.631]                 envs <- base::Sys.getenv()
[16:20:44.631]                 names <- names(envs)
[16:20:44.631]                 common <- intersect(names, old_names)
[16:20:44.631]                 added <- setdiff(names, old_names)
[16:20:44.631]                 removed <- setdiff(old_names, names)
[16:20:44.631]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.631]                   envs[common]]
[16:20:44.631]                 NAMES <- toupper(changed)
[16:20:44.631]                 args <- list()
[16:20:44.631]                 for (kk in seq_along(NAMES)) {
[16:20:44.631]                   name <- changed[[kk]]
[16:20:44.631]                   NAME <- NAMES[[kk]]
[16:20:44.631]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.631]                     next
[16:20:44.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.631]                 }
[16:20:44.631]                 NAMES <- toupper(added)
[16:20:44.631]                 for (kk in seq_along(NAMES)) {
[16:20:44.631]                   name <- added[[kk]]
[16:20:44.631]                   NAME <- NAMES[[kk]]
[16:20:44.631]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.631]                     next
[16:20:44.631]                   args[[name]] <- ""
[16:20:44.631]                 }
[16:20:44.631]                 NAMES <- toupper(removed)
[16:20:44.631]                 for (kk in seq_along(NAMES)) {
[16:20:44.631]                   name <- removed[[kk]]
[16:20:44.631]                   NAME <- NAMES[[kk]]
[16:20:44.631]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.631]                     next
[16:20:44.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.631]                 }
[16:20:44.631]                 if (length(args) > 0) 
[16:20:44.631]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.631]             }
[16:20:44.631]             else {
[16:20:44.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.631]             }
[16:20:44.631]             {
[16:20:44.631]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.631]                   0L) {
[16:20:44.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.631]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.631]                   base::options(opts)
[16:20:44.631]                 }
[16:20:44.631]                 {
[16:20:44.631]                   {
[16:20:44.631]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.631]                     NULL
[16:20:44.631]                   }
[16:20:44.631]                   options(future.plan = NULL)
[16:20:44.631]                   if (is.na(NA_character_)) 
[16:20:44.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.631]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.631]                     .init = FALSE)
[16:20:44.631]                 }
[16:20:44.631]             }
[16:20:44.631]         }
[16:20:44.631]     })
[16:20:44.631]     if (TRUE) {
[16:20:44.631]         base::sink(type = "output", split = FALSE)
[16:20:44.631]         if (TRUE) {
[16:20:44.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.631]         }
[16:20:44.631]         else {
[16:20:44.631]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.631]         }
[16:20:44.631]         base::close(...future.stdout)
[16:20:44.631]         ...future.stdout <- NULL
[16:20:44.631]     }
[16:20:44.631]     ...future.result$conditions <- ...future.conditions
[16:20:44.631]     ...future.result$finished <- base::Sys.time()
[16:20:44.631]     ...future.result
[16:20:44.631] }
[16:20:44.634] MultisessionFuture started
[16:20:44.634] - Launch lazy future ... done
[16:20:44.634] run() for ‘MultisessionFuture’ ... done
[16:20:44.635] getGlobalsAndPackages() ...
[16:20:44.635] Searching for globals...
[16:20:44.635] - globals found: [1] ‘{’
[16:20:44.635] Searching for globals ... DONE
[16:20:44.635] Resolving globals: FALSE
[16:20:44.636] 
[16:20:44.636] 
[16:20:44.636] getGlobalsAndPackages() ... DONE
[16:20:44.636] run() for ‘Future’ ...
[16:20:44.636] - state: ‘created’
[16:20:44.636] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.649] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:44.650]   - Field: ‘node’
[16:20:44.650]   - Field: ‘label’
[16:20:44.650]   - Field: ‘local’
[16:20:44.650]   - Field: ‘owner’
[16:20:44.650]   - Field: ‘envir’
[16:20:44.650]   - Field: ‘workers’
[16:20:44.650]   - Field: ‘packages’
[16:20:44.650]   - Field: ‘gc’
[16:20:44.651]   - Field: ‘conditions’
[16:20:44.651]   - Field: ‘persistent’
[16:20:44.651]   - Field: ‘expr’
[16:20:44.651]   - Field: ‘uuid’
[16:20:44.651]   - Field: ‘seed’
[16:20:44.651]   - Field: ‘version’
[16:20:44.651]   - Field: ‘result’
[16:20:44.651]   - Field: ‘asynchronous’
[16:20:44.651]   - Field: ‘calls’
[16:20:44.651]   - Field: ‘globals’
[16:20:44.651]   - Field: ‘stdout’
[16:20:44.652]   - Field: ‘earlySignal’
[16:20:44.652]   - Field: ‘lazy’
[16:20:44.652]   - Field: ‘state’
[16:20:44.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:44.652] - Launch lazy future ...
[16:20:44.652] Packages needed by the future expression (n = 0): <none>
[16:20:44.652] Packages needed by future strategies (n = 0): <none>
[16:20:44.653] {
[16:20:44.653]     {
[16:20:44.653]         {
[16:20:44.653]             ...future.startTime <- base::Sys.time()
[16:20:44.653]             {
[16:20:44.653]                 {
[16:20:44.653]                   {
[16:20:44.653]                     {
[16:20:44.653]                       base::local({
[16:20:44.653]                         has_future <- base::requireNamespace("future", 
[16:20:44.653]                           quietly = TRUE)
[16:20:44.653]                         if (has_future) {
[16:20:44.653]                           ns <- base::getNamespace("future")
[16:20:44.653]                           version <- ns[[".package"]][["version"]]
[16:20:44.653]                           if (is.null(version)) 
[16:20:44.653]                             version <- utils::packageVersion("future")
[16:20:44.653]                         }
[16:20:44.653]                         else {
[16:20:44.653]                           version <- NULL
[16:20:44.653]                         }
[16:20:44.653]                         if (!has_future || version < "1.8.0") {
[16:20:44.653]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.653]                             "", base::R.version$version.string), 
[16:20:44.653]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.653]                               "release", "version")], collapse = " "), 
[16:20:44.653]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.653]                             info)
[16:20:44.653]                           info <- base::paste(info, collapse = "; ")
[16:20:44.653]                           if (!has_future) {
[16:20:44.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.653]                               info)
[16:20:44.653]                           }
[16:20:44.653]                           else {
[16:20:44.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.653]                               info, version)
[16:20:44.653]                           }
[16:20:44.653]                           base::stop(msg)
[16:20:44.653]                         }
[16:20:44.653]                       })
[16:20:44.653]                     }
[16:20:44.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.653]                     base::options(mc.cores = 1L)
[16:20:44.653]                   }
[16:20:44.653]                   ...future.strategy.old <- future::plan("list")
[16:20:44.653]                   options(future.plan = NULL)
[16:20:44.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.653]                 }
[16:20:44.653]                 ...future.workdir <- getwd()
[16:20:44.653]             }
[16:20:44.653]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.653]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.653]         }
[16:20:44.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.653]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.653]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.653]             base::names(...future.oldOptions))
[16:20:44.653]     }
[16:20:44.653]     if (FALSE) {
[16:20:44.653]     }
[16:20:44.653]     else {
[16:20:44.653]         if (TRUE) {
[16:20:44.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.653]                 open = "w")
[16:20:44.653]         }
[16:20:44.653]         else {
[16:20:44.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.653]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.653]         }
[16:20:44.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.653]             base::sink(type = "output", split = FALSE)
[16:20:44.653]             base::close(...future.stdout)
[16:20:44.653]         }, add = TRUE)
[16:20:44.653]     }
[16:20:44.653]     ...future.frame <- base::sys.nframe()
[16:20:44.653]     ...future.conditions <- base::list()
[16:20:44.653]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.653]     if (FALSE) {
[16:20:44.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.653]     }
[16:20:44.653]     ...future.result <- base::tryCatch({
[16:20:44.653]         base::withCallingHandlers({
[16:20:44.653]             ...future.value <- base::withVisible(base::local({
[16:20:44.653]                 ...future.makeSendCondition <- base::local({
[16:20:44.653]                   sendCondition <- NULL
[16:20:44.653]                   function(frame = 1L) {
[16:20:44.653]                     if (is.function(sendCondition)) 
[16:20:44.653]                       return(sendCondition)
[16:20:44.653]                     ns <- getNamespace("parallel")
[16:20:44.653]                     if (exists("sendData", mode = "function", 
[16:20:44.653]                       envir = ns)) {
[16:20:44.653]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:44.653]                         envir = ns)
[16:20:44.653]                       envir <- sys.frame(frame)
[16:20:44.653]                       master <- NULL
[16:20:44.653]                       while (!identical(envir, .GlobalEnv) && 
[16:20:44.653]                         !identical(envir, emptyenv())) {
[16:20:44.653]                         if (exists("master", mode = "list", envir = envir, 
[16:20:44.653]                           inherits = FALSE)) {
[16:20:44.653]                           master <- get("master", mode = "list", 
[16:20:44.653]                             envir = envir, inherits = FALSE)
[16:20:44.653]                           if (inherits(master, c("SOCKnode", 
[16:20:44.653]                             "SOCK0node"))) {
[16:20:44.653]                             sendCondition <<- function(cond) {
[16:20:44.653]                               data <- list(type = "VALUE", value = cond, 
[16:20:44.653]                                 success = TRUE)
[16:20:44.653]                               parallel_sendData(master, data)
[16:20:44.653]                             }
[16:20:44.653]                             return(sendCondition)
[16:20:44.653]                           }
[16:20:44.653]                         }
[16:20:44.653]                         frame <- frame + 1L
[16:20:44.653]                         envir <- sys.frame(frame)
[16:20:44.653]                       }
[16:20:44.653]                     }
[16:20:44.653]                     sendCondition <<- function(cond) NULL
[16:20:44.653]                   }
[16:20:44.653]                 })
[16:20:44.653]                 withCallingHandlers({
[16:20:44.653]                   {
[16:20:44.653]                     4
[16:20:44.653]                   }
[16:20:44.653]                 }, immediateCondition = function(cond) {
[16:20:44.653]                   sendCondition <- ...future.makeSendCondition()
[16:20:44.653]                   sendCondition(cond)
[16:20:44.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.653]                   {
[16:20:44.653]                     inherits <- base::inherits
[16:20:44.653]                     invokeRestart <- base::invokeRestart
[16:20:44.653]                     is.null <- base::is.null
[16:20:44.653]                     muffled <- FALSE
[16:20:44.653]                     if (inherits(cond, "message")) {
[16:20:44.653]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.653]                       if (muffled) 
[16:20:44.653]                         invokeRestart("muffleMessage")
[16:20:44.653]                     }
[16:20:44.653]                     else if (inherits(cond, "warning")) {
[16:20:44.653]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.653]                       if (muffled) 
[16:20:44.653]                         invokeRestart("muffleWarning")
[16:20:44.653]                     }
[16:20:44.653]                     else if (inherits(cond, "condition")) {
[16:20:44.653]                       if (!is.null(pattern)) {
[16:20:44.653]                         computeRestarts <- base::computeRestarts
[16:20:44.653]                         grepl <- base::grepl
[16:20:44.653]                         restarts <- computeRestarts(cond)
[16:20:44.653]                         for (restart in restarts) {
[16:20:44.653]                           name <- restart$name
[16:20:44.653]                           if (is.null(name)) 
[16:20:44.653]                             next
[16:20:44.653]                           if (!grepl(pattern, name)) 
[16:20:44.653]                             next
[16:20:44.653]                           invokeRestart(restart)
[16:20:44.653]                           muffled <- TRUE
[16:20:44.653]                           break
[16:20:44.653]                         }
[16:20:44.653]                       }
[16:20:44.653]                     }
[16:20:44.653]                     invisible(muffled)
[16:20:44.653]                   }
[16:20:44.653]                   muffleCondition(cond)
[16:20:44.653]                 })
[16:20:44.653]             }))
[16:20:44.653]             future::FutureResult(value = ...future.value$value, 
[16:20:44.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.653]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.653]                     ...future.globalenv.names))
[16:20:44.653]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.653]         }, condition = base::local({
[16:20:44.653]             c <- base::c
[16:20:44.653]             inherits <- base::inherits
[16:20:44.653]             invokeRestart <- base::invokeRestart
[16:20:44.653]             length <- base::length
[16:20:44.653]             list <- base::list
[16:20:44.653]             seq.int <- base::seq.int
[16:20:44.653]             signalCondition <- base::signalCondition
[16:20:44.653]             sys.calls <- base::sys.calls
[16:20:44.653]             `[[` <- base::`[[`
[16:20:44.653]             `+` <- base::`+`
[16:20:44.653]             `<<-` <- base::`<<-`
[16:20:44.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.653]                   3L)]
[16:20:44.653]             }
[16:20:44.653]             function(cond) {
[16:20:44.653]                 is_error <- inherits(cond, "error")
[16:20:44.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.653]                   NULL)
[16:20:44.653]                 if (is_error) {
[16:20:44.653]                   sessionInformation <- function() {
[16:20:44.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.653]                       search = base::search(), system = base::Sys.info())
[16:20:44.653]                   }
[16:20:44.653]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.653]                     cond$call), session = sessionInformation(), 
[16:20:44.653]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.653]                   signalCondition(cond)
[16:20:44.653]                 }
[16:20:44.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.653]                 "immediateCondition"))) {
[16:20:44.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.653]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.653]                   if (TRUE && !signal) {
[16:20:44.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.653]                     {
[16:20:44.653]                       inherits <- base::inherits
[16:20:44.653]                       invokeRestart <- base::invokeRestart
[16:20:44.653]                       is.null <- base::is.null
[16:20:44.653]                       muffled <- FALSE
[16:20:44.653]                       if (inherits(cond, "message")) {
[16:20:44.653]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.653]                         if (muffled) 
[16:20:44.653]                           invokeRestart("muffleMessage")
[16:20:44.653]                       }
[16:20:44.653]                       else if (inherits(cond, "warning")) {
[16:20:44.653]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.653]                         if (muffled) 
[16:20:44.653]                           invokeRestart("muffleWarning")
[16:20:44.653]                       }
[16:20:44.653]                       else if (inherits(cond, "condition")) {
[16:20:44.653]                         if (!is.null(pattern)) {
[16:20:44.653]                           computeRestarts <- base::computeRestarts
[16:20:44.653]                           grepl <- base::grepl
[16:20:44.653]                           restarts <- computeRestarts(cond)
[16:20:44.653]                           for (restart in restarts) {
[16:20:44.653]                             name <- restart$name
[16:20:44.653]                             if (is.null(name)) 
[16:20:44.653]                               next
[16:20:44.653]                             if (!grepl(pattern, name)) 
[16:20:44.653]                               next
[16:20:44.653]                             invokeRestart(restart)
[16:20:44.653]                             muffled <- TRUE
[16:20:44.653]                             break
[16:20:44.653]                           }
[16:20:44.653]                         }
[16:20:44.653]                       }
[16:20:44.653]                       invisible(muffled)
[16:20:44.653]                     }
[16:20:44.653]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.653]                   }
[16:20:44.653]                 }
[16:20:44.653]                 else {
[16:20:44.653]                   if (TRUE) {
[16:20:44.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.653]                     {
[16:20:44.653]                       inherits <- base::inherits
[16:20:44.653]                       invokeRestart <- base::invokeRestart
[16:20:44.653]                       is.null <- base::is.null
[16:20:44.653]                       muffled <- FALSE
[16:20:44.653]                       if (inherits(cond, "message")) {
[16:20:44.653]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.653]                         if (muffled) 
[16:20:44.653]                           invokeRestart("muffleMessage")
[16:20:44.653]                       }
[16:20:44.653]                       else if (inherits(cond, "warning")) {
[16:20:44.653]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.653]                         if (muffled) 
[16:20:44.653]                           invokeRestart("muffleWarning")
[16:20:44.653]                       }
[16:20:44.653]                       else if (inherits(cond, "condition")) {
[16:20:44.653]                         if (!is.null(pattern)) {
[16:20:44.653]                           computeRestarts <- base::computeRestarts
[16:20:44.653]                           grepl <- base::grepl
[16:20:44.653]                           restarts <- computeRestarts(cond)
[16:20:44.653]                           for (restart in restarts) {
[16:20:44.653]                             name <- restart$name
[16:20:44.653]                             if (is.null(name)) 
[16:20:44.653]                               next
[16:20:44.653]                             if (!grepl(pattern, name)) 
[16:20:44.653]                               next
[16:20:44.653]                             invokeRestart(restart)
[16:20:44.653]                             muffled <- TRUE
[16:20:44.653]                             break
[16:20:44.653]                           }
[16:20:44.653]                         }
[16:20:44.653]                       }
[16:20:44.653]                       invisible(muffled)
[16:20:44.653]                     }
[16:20:44.653]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.653]                   }
[16:20:44.653]                 }
[16:20:44.653]             }
[16:20:44.653]         }))
[16:20:44.653]     }, error = function(ex) {
[16:20:44.653]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.653]                 ...future.rng), started = ...future.startTime, 
[16:20:44.653]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.653]             version = "1.8"), class = "FutureResult")
[16:20:44.653]     }, finally = {
[16:20:44.653]         if (!identical(...future.workdir, getwd())) 
[16:20:44.653]             setwd(...future.workdir)
[16:20:44.653]         {
[16:20:44.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.653]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.653]             }
[16:20:44.653]             base::options(...future.oldOptions)
[16:20:44.653]             if (.Platform$OS.type == "windows") {
[16:20:44.653]                 old_names <- names(...future.oldEnvVars)
[16:20:44.653]                 envs <- base::Sys.getenv()
[16:20:44.653]                 names <- names(envs)
[16:20:44.653]                 common <- intersect(names, old_names)
[16:20:44.653]                 added <- setdiff(names, old_names)
[16:20:44.653]                 removed <- setdiff(old_names, names)
[16:20:44.653]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.653]                   envs[common]]
[16:20:44.653]                 NAMES <- toupper(changed)
[16:20:44.653]                 args <- list()
[16:20:44.653]                 for (kk in seq_along(NAMES)) {
[16:20:44.653]                   name <- changed[[kk]]
[16:20:44.653]                   NAME <- NAMES[[kk]]
[16:20:44.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.653]                     next
[16:20:44.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.653]                 }
[16:20:44.653]                 NAMES <- toupper(added)
[16:20:44.653]                 for (kk in seq_along(NAMES)) {
[16:20:44.653]                   name <- added[[kk]]
[16:20:44.653]                   NAME <- NAMES[[kk]]
[16:20:44.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.653]                     next
[16:20:44.653]                   args[[name]] <- ""
[16:20:44.653]                 }
[16:20:44.653]                 NAMES <- toupper(removed)
[16:20:44.653]                 for (kk in seq_along(NAMES)) {
[16:20:44.653]                   name <- removed[[kk]]
[16:20:44.653]                   NAME <- NAMES[[kk]]
[16:20:44.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.653]                     next
[16:20:44.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.653]                 }
[16:20:44.653]                 if (length(args) > 0) 
[16:20:44.653]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.653]             }
[16:20:44.653]             else {
[16:20:44.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.653]             }
[16:20:44.653]             {
[16:20:44.653]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.653]                   0L) {
[16:20:44.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.653]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.653]                   base::options(opts)
[16:20:44.653]                 }
[16:20:44.653]                 {
[16:20:44.653]                   {
[16:20:44.653]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.653]                     NULL
[16:20:44.653]                   }
[16:20:44.653]                   options(future.plan = NULL)
[16:20:44.653]                   if (is.na(NA_character_)) 
[16:20:44.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.653]                     .init = FALSE)
[16:20:44.653]                 }
[16:20:44.653]             }
[16:20:44.653]         }
[16:20:44.653]     })
[16:20:44.653]     if (TRUE) {
[16:20:44.653]         base::sink(type = "output", split = FALSE)
[16:20:44.653]         if (TRUE) {
[16:20:44.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.653]         }
[16:20:44.653]         else {
[16:20:44.653]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.653]         }
[16:20:44.653]         base::close(...future.stdout)
[16:20:44.653]         ...future.stdout <- NULL
[16:20:44.653]     }
[16:20:44.653]     ...future.result$conditions <- ...future.conditions
[16:20:44.653]     ...future.result$finished <- base::Sys.time()
[16:20:44.653]     ...future.result
[16:20:44.653] }
[16:20:44.655] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:44.665] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.666] - Validating connection of MultisessionFuture
[16:20:44.666] - received message: FutureResult
[16:20:44.666] - Received FutureResult
[16:20:44.666] - Erased future from FutureRegistry
[16:20:44.666] result() for ClusterFuture ...
[16:20:44.666] - result already collected: FutureResult
[16:20:44.666] result() for ClusterFuture ... done
[16:20:44.666] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.667] result() for ClusterFuture ...
[16:20:44.667] - result already collected: FutureResult
[16:20:44.667] result() for ClusterFuture ... done
[16:20:44.667] result() for ClusterFuture ...
[16:20:44.667] - result already collected: FutureResult
[16:20:44.667] result() for ClusterFuture ... done
[16:20:44.668] MultisessionFuture started
[16:20:44.668] - Launch lazy future ... done
[16:20:44.668] run() for ‘MultisessionFuture’ ... done
<environment: 0x55ed0dfe8590> 
<environment: 0x55ed0b4839d8> 
[16:20:44.670] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.670] - Validating connection of MultisessionFuture
[16:20:44.670] - received message: FutureResult
[16:20:44.670] - Received FutureResult
[16:20:44.670] - Erased future from FutureRegistry
[16:20:44.670] result() for ClusterFuture ...
[16:20:44.671] - result already collected: FutureResult
[16:20:44.671] result() for ClusterFuture ... done
[16:20:44.671] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:44.671] receiveMessageFromWorker() for ClusterFuture ...
[16:20:44.671] - Validating connection of MultisessionFuture
[16:20:44.671] - received message: FutureResult
[16:20:44.672] - Received FutureResult
[16:20:44.672] - Erased future from FutureRegistry
[16:20:44.672] result() for ClusterFuture ...
[16:20:44.672] - result already collected: FutureResult
[16:20:44.672] result() for ClusterFuture ... done
[16:20:44.672] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:20:44.673] resolve() on environment ...
[16:20:44.673]  recursive: 0
[16:20:44.674]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:20:44.674] signalConditionsASAP(numeric, pos=1) ...
[16:20:44.674] - nx: 4
[16:20:44.674] - relay: TRUE
[16:20:44.674] - stdout: TRUE
[16:20:44.674] - signal: TRUE
[16:20:44.674] - resignal: FALSE
[16:20:44.674] - force: TRUE
[16:20:44.674] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.675] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.675]  - until=2
[16:20:44.675]  - relaying element #2
[16:20:44.675] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.675] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.675] signalConditionsASAP(NULL, pos=1) ... done
[16:20:44.675]  length: 3 (resolved future 1)
[16:20:44.675] Future #2
[16:20:44.675] result() for ClusterFuture ...
[16:20:44.675] - result already collected: FutureResult
[16:20:44.676] result() for ClusterFuture ... done
[16:20:44.676] result() for ClusterFuture ...
[16:20:44.676] - result already collected: FutureResult
[16:20:44.676] result() for ClusterFuture ... done
[16:20:44.676] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:44.676] - nx: 4
[16:20:44.676] - relay: TRUE
[16:20:44.676] - stdout: TRUE
[16:20:44.676] - signal: TRUE
[16:20:44.676] - resignal: FALSE
[16:20:44.676] - force: TRUE
[16:20:44.676] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:20:44.677] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:20:44.677]  - until=2
[16:20:44.677]  - relaying element #2
[16:20:44.677] result() for ClusterFuture ...
[16:20:44.677] - result already collected: FutureResult
[16:20:44.677] result() for ClusterFuture ... done
[16:20:44.677] result() for ClusterFuture ...
[16:20:44.677] - result already collected: FutureResult
[16:20:44.677] result() for ClusterFuture ... done
[16:20:44.677] result() for ClusterFuture ...
[16:20:44.677] - result already collected: FutureResult
[16:20:44.678] result() for ClusterFuture ... done
[16:20:44.678] result() for ClusterFuture ...
[16:20:44.678] - result already collected: FutureResult
[16:20:44.678] result() for ClusterFuture ... done
[16:20:44.678] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.678] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.678] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:44.678]  length: 2 (resolved future 2)
[16:20:44.678] Future #3
[16:20:44.678] result() for ClusterFuture ...
[16:20:44.678] - result already collected: FutureResult
[16:20:44.679] result() for ClusterFuture ... done
[16:20:44.679] result() for ClusterFuture ...
[16:20:44.679] - result already collected: FutureResult
[16:20:44.679] result() for ClusterFuture ... done
[16:20:44.679] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:44.679] - nx: 4
[16:20:44.679] - relay: TRUE
[16:20:44.679] - stdout: TRUE
[16:20:44.679] - signal: TRUE
[16:20:44.679] - resignal: FALSE
[16:20:44.679] - force: TRUE
[16:20:44.680] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:20:44.680] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:20:44.680]  - until=3
[16:20:44.680]  - relaying element #3
[16:20:44.680] result() for ClusterFuture ...
[16:20:44.680] - result already collected: FutureResult
[16:20:44.680] result() for ClusterFuture ... done
[16:20:44.680] result() for ClusterFuture ...
[16:20:44.680] - result already collected: FutureResult
[16:20:44.680] result() for ClusterFuture ... done
[16:20:44.680] result() for ClusterFuture ...
[16:20:44.681] - result already collected: FutureResult
[16:20:44.681] result() for ClusterFuture ... done
[16:20:44.681] result() for ClusterFuture ...
[16:20:44.681] - result already collected: FutureResult
[16:20:44.681] result() for ClusterFuture ... done
[16:20:44.681] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.681] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.681] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:44.681]  length: 1 (resolved future 3)
[16:20:44.681] Future #4
[16:20:44.681] result() for ClusterFuture ...
[16:20:44.682] - result already collected: FutureResult
[16:20:44.682] result() for ClusterFuture ... done
[16:20:44.682] result() for ClusterFuture ...
[16:20:44.682] - result already collected: FutureResult
[16:20:44.682] result() for ClusterFuture ... done
[16:20:44.682] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:44.682] - nx: 4
[16:20:44.682] - relay: TRUE
[16:20:44.682] - stdout: TRUE
[16:20:44.682] - signal: TRUE
[16:20:44.682] - resignal: FALSE
[16:20:44.683] - force: TRUE
[16:20:44.683] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:20:44.683] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:20:44.683]  - until=4
[16:20:44.683]  - relaying element #4
[16:20:44.683] result() for ClusterFuture ...
[16:20:44.683] - result already collected: FutureResult
[16:20:44.683] result() for ClusterFuture ... done
[16:20:44.683] result() for ClusterFuture ...
[16:20:44.683] - result already collected: FutureResult
[16:20:44.683] result() for ClusterFuture ... done
[16:20:44.683] result() for ClusterFuture ...
[16:20:44.684] - result already collected: FutureResult
[16:20:44.684] result() for ClusterFuture ... done
[16:20:44.684] result() for ClusterFuture ...
[16:20:44.684] - result already collected: FutureResult
[16:20:44.684] result() for ClusterFuture ... done
[16:20:44.684] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.684] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.684] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:44.684]  length: 0 (resolved future 4)
[16:20:44.684] Relaying remaining futures
[16:20:44.684] signalConditionsASAP(NULL, pos=0) ...
[16:20:44.685] - nx: 4
[16:20:44.685] - relay: TRUE
[16:20:44.685] - stdout: TRUE
[16:20:44.685] - signal: TRUE
[16:20:44.685] - resignal: FALSE
[16:20:44.685] - force: TRUE
[16:20:44.685] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.685] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:20:44.685] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:20:44.685] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:20:44.685] signalConditionsASAP(NULL, pos=0) ... done
[16:20:44.686] resolve() on environment ... DONE
[16:20:44.686] result() for ClusterFuture ...
[16:20:44.686] - result already collected: FutureResult
[16:20:44.686] result() for ClusterFuture ... done
[16:20:44.686] result() for ClusterFuture ...
[16:20:44.686] - result already collected: FutureResult
[16:20:44.686] result() for ClusterFuture ... done
[16:20:44.686] result() for ClusterFuture ...
[16:20:44.686] - result already collected: FutureResult
[16:20:44.686] result() for ClusterFuture ... done
[16:20:44.686] result() for ClusterFuture ...
[16:20:44.687] - result already collected: FutureResult
[16:20:44.687] result() for ClusterFuture ... done
[16:20:44.687] result() for ClusterFuture ...
[16:20:44.687] - result already collected: FutureResult
[16:20:44.687] result() for ClusterFuture ... done
[16:20:44.687] result() for ClusterFuture ...
[16:20:44.687] - result already collected: FutureResult
[16:20:44.687] result() for ClusterFuture ... done
<environment: 0x55ed0cacd948> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[16:20:44.688] plan(): Setting new future strategy stack:
[16:20:44.688] List of future strategies:
[16:20:44.688] 1. multicore:
[16:20:44.688]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.688]    - tweaked: FALSE
[16:20:44.688]    - call: plan(strategy)
[16:20:44.693] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:20:44.693] getGlobalsAndPackages() ...
[16:20:44.693] Searching for globals...
[16:20:44.694] 
[16:20:44.694] Searching for globals ... DONE
[16:20:44.694] - globals: [0] <none>
[16:20:44.694] getGlobalsAndPackages() ... DONE
[16:20:44.694] run() for ‘Future’ ...
[16:20:44.695] - state: ‘created’
[16:20:44.695] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.699] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:44.700]   - Field: ‘label’
[16:20:44.700]   - Field: ‘local’
[16:20:44.700]   - Field: ‘owner’
[16:20:44.700]   - Field: ‘envir’
[16:20:44.700]   - Field: ‘workers’
[16:20:44.700]   - Field: ‘packages’
[16:20:44.700]   - Field: ‘gc’
[16:20:44.700]   - Field: ‘job’
[16:20:44.700]   - Field: ‘conditions’
[16:20:44.700]   - Field: ‘expr’
[16:20:44.701]   - Field: ‘uuid’
[16:20:44.701]   - Field: ‘seed’
[16:20:44.701]   - Field: ‘version’
[16:20:44.701]   - Field: ‘result’
[16:20:44.701]   - Field: ‘asynchronous’
[16:20:44.701]   - Field: ‘calls’
[16:20:44.701]   - Field: ‘globals’
[16:20:44.701]   - Field: ‘stdout’
[16:20:44.701]   - Field: ‘earlySignal’
[16:20:44.701]   - Field: ‘lazy’
[16:20:44.701]   - Field: ‘state’
[16:20:44.702] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:44.702] - Launch lazy future ...
[16:20:44.702] Packages needed by the future expression (n = 0): <none>
[16:20:44.702] Packages needed by future strategies (n = 0): <none>
[16:20:44.702] {
[16:20:44.702]     {
[16:20:44.702]         {
[16:20:44.702]             ...future.startTime <- base::Sys.time()
[16:20:44.702]             {
[16:20:44.702]                 {
[16:20:44.702]                   {
[16:20:44.702]                     {
[16:20:44.702]                       base::local({
[16:20:44.702]                         has_future <- base::requireNamespace("future", 
[16:20:44.702]                           quietly = TRUE)
[16:20:44.702]                         if (has_future) {
[16:20:44.702]                           ns <- base::getNamespace("future")
[16:20:44.702]                           version <- ns[[".package"]][["version"]]
[16:20:44.702]                           if (is.null(version)) 
[16:20:44.702]                             version <- utils::packageVersion("future")
[16:20:44.702]                         }
[16:20:44.702]                         else {
[16:20:44.702]                           version <- NULL
[16:20:44.702]                         }
[16:20:44.702]                         if (!has_future || version < "1.8.0") {
[16:20:44.702]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.702]                             "", base::R.version$version.string), 
[16:20:44.702]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.702]                               "release", "version")], collapse = " "), 
[16:20:44.702]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.702]                             info)
[16:20:44.702]                           info <- base::paste(info, collapse = "; ")
[16:20:44.702]                           if (!has_future) {
[16:20:44.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.702]                               info)
[16:20:44.702]                           }
[16:20:44.702]                           else {
[16:20:44.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.702]                               info, version)
[16:20:44.702]                           }
[16:20:44.702]                           base::stop(msg)
[16:20:44.702]                         }
[16:20:44.702]                       })
[16:20:44.702]                     }
[16:20:44.702]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.702]                     base::options(mc.cores = 1L)
[16:20:44.702]                   }
[16:20:44.702]                   ...future.strategy.old <- future::plan("list")
[16:20:44.702]                   options(future.plan = NULL)
[16:20:44.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.702]                 }
[16:20:44.702]                 ...future.workdir <- getwd()
[16:20:44.702]             }
[16:20:44.702]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.702]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.702]         }
[16:20:44.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.702]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.702]             base::names(...future.oldOptions))
[16:20:44.702]     }
[16:20:44.702]     if (FALSE) {
[16:20:44.702]     }
[16:20:44.702]     else {
[16:20:44.702]         if (TRUE) {
[16:20:44.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.702]                 open = "w")
[16:20:44.702]         }
[16:20:44.702]         else {
[16:20:44.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.702]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.702]         }
[16:20:44.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.702]             base::sink(type = "output", split = FALSE)
[16:20:44.702]             base::close(...future.stdout)
[16:20:44.702]         }, add = TRUE)
[16:20:44.702]     }
[16:20:44.702]     ...future.frame <- base::sys.nframe()
[16:20:44.702]     ...future.conditions <- base::list()
[16:20:44.702]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.702]     if (FALSE) {
[16:20:44.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.702]     }
[16:20:44.702]     ...future.result <- base::tryCatch({
[16:20:44.702]         base::withCallingHandlers({
[16:20:44.702]             ...future.value <- base::withVisible(base::local({
[16:20:44.702]                 withCallingHandlers({
[16:20:44.702]                   2
[16:20:44.702]                 }, immediateCondition = function(cond) {
[16:20:44.702]                   save_rds <- function (object, pathname, ...) 
[16:20:44.702]                   {
[16:20:44.702]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:44.702]                     if (file_test("-f", pathname_tmp)) {
[16:20:44.702]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.702]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:44.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.702]                         fi_tmp[["mtime"]])
[16:20:44.702]                     }
[16:20:44.702]                     tryCatch({
[16:20:44.702]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:44.702]                     }, error = function(ex) {
[16:20:44.702]                       msg <- conditionMessage(ex)
[16:20:44.702]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.702]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:44.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.702]                         fi_tmp[["mtime"]], msg)
[16:20:44.702]                       ex$message <- msg
[16:20:44.702]                       stop(ex)
[16:20:44.702]                     })
[16:20:44.702]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:44.702]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:44.702]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:44.702]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.702]                       fi <- file.info(pathname)
[16:20:44.702]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:44.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.702]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:44.702]                         fi[["size"]], fi[["mtime"]])
[16:20:44.702]                       stop(msg)
[16:20:44.702]                     }
[16:20:44.702]                     invisible(pathname)
[16:20:44.702]                   }
[16:20:44.702]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:44.702]                     rootPath = tempdir()) 
[16:20:44.702]                   {
[16:20:44.702]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:44.702]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:44.702]                       tmpdir = path, fileext = ".rds")
[16:20:44.702]                     save_rds(obj, file)
[16:20:44.702]                   }
[16:20:44.702]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:44.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.702]                   {
[16:20:44.702]                     inherits <- base::inherits
[16:20:44.702]                     invokeRestart <- base::invokeRestart
[16:20:44.702]                     is.null <- base::is.null
[16:20:44.702]                     muffled <- FALSE
[16:20:44.702]                     if (inherits(cond, "message")) {
[16:20:44.702]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.702]                       if (muffled) 
[16:20:44.702]                         invokeRestart("muffleMessage")
[16:20:44.702]                     }
[16:20:44.702]                     else if (inherits(cond, "warning")) {
[16:20:44.702]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.702]                       if (muffled) 
[16:20:44.702]                         invokeRestart("muffleWarning")
[16:20:44.702]                     }
[16:20:44.702]                     else if (inherits(cond, "condition")) {
[16:20:44.702]                       if (!is.null(pattern)) {
[16:20:44.702]                         computeRestarts <- base::computeRestarts
[16:20:44.702]                         grepl <- base::grepl
[16:20:44.702]                         restarts <- computeRestarts(cond)
[16:20:44.702]                         for (restart in restarts) {
[16:20:44.702]                           name <- restart$name
[16:20:44.702]                           if (is.null(name)) 
[16:20:44.702]                             next
[16:20:44.702]                           if (!grepl(pattern, name)) 
[16:20:44.702]                             next
[16:20:44.702]                           invokeRestart(restart)
[16:20:44.702]                           muffled <- TRUE
[16:20:44.702]                           break
[16:20:44.702]                         }
[16:20:44.702]                       }
[16:20:44.702]                     }
[16:20:44.702]                     invisible(muffled)
[16:20:44.702]                   }
[16:20:44.702]                   muffleCondition(cond)
[16:20:44.702]                 })
[16:20:44.702]             }))
[16:20:44.702]             future::FutureResult(value = ...future.value$value, 
[16:20:44.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.702]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.702]                     ...future.globalenv.names))
[16:20:44.702]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.702]         }, condition = base::local({
[16:20:44.702]             c <- base::c
[16:20:44.702]             inherits <- base::inherits
[16:20:44.702]             invokeRestart <- base::invokeRestart
[16:20:44.702]             length <- base::length
[16:20:44.702]             list <- base::list
[16:20:44.702]             seq.int <- base::seq.int
[16:20:44.702]             signalCondition <- base::signalCondition
[16:20:44.702]             sys.calls <- base::sys.calls
[16:20:44.702]             `[[` <- base::`[[`
[16:20:44.702]             `+` <- base::`+`
[16:20:44.702]             `<<-` <- base::`<<-`
[16:20:44.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.702]                   3L)]
[16:20:44.702]             }
[16:20:44.702]             function(cond) {
[16:20:44.702]                 is_error <- inherits(cond, "error")
[16:20:44.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.702]                   NULL)
[16:20:44.702]                 if (is_error) {
[16:20:44.702]                   sessionInformation <- function() {
[16:20:44.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.702]                       search = base::search(), system = base::Sys.info())
[16:20:44.702]                   }
[16:20:44.702]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.702]                     cond$call), session = sessionInformation(), 
[16:20:44.702]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.702]                   signalCondition(cond)
[16:20:44.702]                 }
[16:20:44.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.702]                 "immediateCondition"))) {
[16:20:44.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.702]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.702]                   if (TRUE && !signal) {
[16:20:44.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.702]                     {
[16:20:44.702]                       inherits <- base::inherits
[16:20:44.702]                       invokeRestart <- base::invokeRestart
[16:20:44.702]                       is.null <- base::is.null
[16:20:44.702]                       muffled <- FALSE
[16:20:44.702]                       if (inherits(cond, "message")) {
[16:20:44.702]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.702]                         if (muffled) 
[16:20:44.702]                           invokeRestart("muffleMessage")
[16:20:44.702]                       }
[16:20:44.702]                       else if (inherits(cond, "warning")) {
[16:20:44.702]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.702]                         if (muffled) 
[16:20:44.702]                           invokeRestart("muffleWarning")
[16:20:44.702]                       }
[16:20:44.702]                       else if (inherits(cond, "condition")) {
[16:20:44.702]                         if (!is.null(pattern)) {
[16:20:44.702]                           computeRestarts <- base::computeRestarts
[16:20:44.702]                           grepl <- base::grepl
[16:20:44.702]                           restarts <- computeRestarts(cond)
[16:20:44.702]                           for (restart in restarts) {
[16:20:44.702]                             name <- restart$name
[16:20:44.702]                             if (is.null(name)) 
[16:20:44.702]                               next
[16:20:44.702]                             if (!grepl(pattern, name)) 
[16:20:44.702]                               next
[16:20:44.702]                             invokeRestart(restart)
[16:20:44.702]                             muffled <- TRUE
[16:20:44.702]                             break
[16:20:44.702]                           }
[16:20:44.702]                         }
[16:20:44.702]                       }
[16:20:44.702]                       invisible(muffled)
[16:20:44.702]                     }
[16:20:44.702]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.702]                   }
[16:20:44.702]                 }
[16:20:44.702]                 else {
[16:20:44.702]                   if (TRUE) {
[16:20:44.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.702]                     {
[16:20:44.702]                       inherits <- base::inherits
[16:20:44.702]                       invokeRestart <- base::invokeRestart
[16:20:44.702]                       is.null <- base::is.null
[16:20:44.702]                       muffled <- FALSE
[16:20:44.702]                       if (inherits(cond, "message")) {
[16:20:44.702]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.702]                         if (muffled) 
[16:20:44.702]                           invokeRestart("muffleMessage")
[16:20:44.702]                       }
[16:20:44.702]                       else if (inherits(cond, "warning")) {
[16:20:44.702]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.702]                         if (muffled) 
[16:20:44.702]                           invokeRestart("muffleWarning")
[16:20:44.702]                       }
[16:20:44.702]                       else if (inherits(cond, "condition")) {
[16:20:44.702]                         if (!is.null(pattern)) {
[16:20:44.702]                           computeRestarts <- base::computeRestarts
[16:20:44.702]                           grepl <- base::grepl
[16:20:44.702]                           restarts <- computeRestarts(cond)
[16:20:44.702]                           for (restart in restarts) {
[16:20:44.702]                             name <- restart$name
[16:20:44.702]                             if (is.null(name)) 
[16:20:44.702]                               next
[16:20:44.702]                             if (!grepl(pattern, name)) 
[16:20:44.702]                               next
[16:20:44.702]                             invokeRestart(restart)
[16:20:44.702]                             muffled <- TRUE
[16:20:44.702]                             break
[16:20:44.702]                           }
[16:20:44.702]                         }
[16:20:44.702]                       }
[16:20:44.702]                       invisible(muffled)
[16:20:44.702]                     }
[16:20:44.702]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.702]                   }
[16:20:44.702]                 }
[16:20:44.702]             }
[16:20:44.702]         }))
[16:20:44.702]     }, error = function(ex) {
[16:20:44.702]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.702]                 ...future.rng), started = ...future.startTime, 
[16:20:44.702]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.702]             version = "1.8"), class = "FutureResult")
[16:20:44.702]     }, finally = {
[16:20:44.702]         if (!identical(...future.workdir, getwd())) 
[16:20:44.702]             setwd(...future.workdir)
[16:20:44.702]         {
[16:20:44.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.702]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.702]             }
[16:20:44.702]             base::options(...future.oldOptions)
[16:20:44.702]             if (.Platform$OS.type == "windows") {
[16:20:44.702]                 old_names <- names(...future.oldEnvVars)
[16:20:44.702]                 envs <- base::Sys.getenv()
[16:20:44.702]                 names <- names(envs)
[16:20:44.702]                 common <- intersect(names, old_names)
[16:20:44.702]                 added <- setdiff(names, old_names)
[16:20:44.702]                 removed <- setdiff(old_names, names)
[16:20:44.702]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.702]                   envs[common]]
[16:20:44.702]                 NAMES <- toupper(changed)
[16:20:44.702]                 args <- list()
[16:20:44.702]                 for (kk in seq_along(NAMES)) {
[16:20:44.702]                   name <- changed[[kk]]
[16:20:44.702]                   NAME <- NAMES[[kk]]
[16:20:44.702]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.702]                     next
[16:20:44.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.702]                 }
[16:20:44.702]                 NAMES <- toupper(added)
[16:20:44.702]                 for (kk in seq_along(NAMES)) {
[16:20:44.702]                   name <- added[[kk]]
[16:20:44.702]                   NAME <- NAMES[[kk]]
[16:20:44.702]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.702]                     next
[16:20:44.702]                   args[[name]] <- ""
[16:20:44.702]                 }
[16:20:44.702]                 NAMES <- toupper(removed)
[16:20:44.702]                 for (kk in seq_along(NAMES)) {
[16:20:44.702]                   name <- removed[[kk]]
[16:20:44.702]                   NAME <- NAMES[[kk]]
[16:20:44.702]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.702]                     next
[16:20:44.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.702]                 }
[16:20:44.702]                 if (length(args) > 0) 
[16:20:44.702]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.702]             }
[16:20:44.702]             else {
[16:20:44.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.702]             }
[16:20:44.702]             {
[16:20:44.702]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.702]                   0L) {
[16:20:44.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.702]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.702]                   base::options(opts)
[16:20:44.702]                 }
[16:20:44.702]                 {
[16:20:44.702]                   {
[16:20:44.702]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.702]                     NULL
[16:20:44.702]                   }
[16:20:44.702]                   options(future.plan = NULL)
[16:20:44.702]                   if (is.na(NA_character_)) 
[16:20:44.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.702]                     .init = FALSE)
[16:20:44.702]                 }
[16:20:44.702]             }
[16:20:44.702]         }
[16:20:44.702]     })
[16:20:44.702]     if (TRUE) {
[16:20:44.702]         base::sink(type = "output", split = FALSE)
[16:20:44.702]         if (TRUE) {
[16:20:44.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.702]         }
[16:20:44.702]         else {
[16:20:44.702]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.702]         }
[16:20:44.702]         base::close(...future.stdout)
[16:20:44.702]         ...future.stdout <- NULL
[16:20:44.702]     }
[16:20:44.702]     ...future.result$conditions <- ...future.conditions
[16:20:44.702]     ...future.result$finished <- base::Sys.time()
[16:20:44.702]     ...future.result
[16:20:44.702] }
[16:20:44.705] requestCore(): workers = 2
[16:20:44.707] MulticoreFuture started
[16:20:44.708] - Launch lazy future ... done
[16:20:44.708] run() for ‘MulticoreFuture’ ... done
[16:20:44.708] getGlobalsAndPackages() ...
[16:20:44.709] Searching for globals...
[16:20:44.709] plan(): Setting new future strategy stack:
[16:20:44.709] 
[16:20:44.710] Searching for globals ... DONE
[16:20:44.709] List of future strategies:
[16:20:44.709] 1. sequential:
[16:20:44.709]    - args: function (..., envir = parent.frame())
[16:20:44.709]    - tweaked: FALSE
[16:20:44.709]    - call: NULL
[16:20:44.710] - globals: [0] <none>
[16:20:44.710] plan(): nbrOfWorkers() = 1
[16:20:44.710] getGlobalsAndPackages() ... DONE
[16:20:44.710] run() for ‘Future’ ...
[16:20:44.711] - state: ‘created’
[16:20:44.711] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.712] plan(): Setting new future strategy stack:
[16:20:44.712] List of future strategies:
[16:20:44.712] 1. multicore:
[16:20:44.712]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.712]    - tweaked: FALSE
[16:20:44.712]    - call: plan(strategy)
[16:20:44.716] plan(): nbrOfWorkers() = 2
[16:20:44.716] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:44.717]   - Field: ‘label’
[16:20:44.717]   - Field: ‘local’
[16:20:44.717]   - Field: ‘owner’
[16:20:44.717]   - Field: ‘envir’
[16:20:44.717]   - Field: ‘workers’
[16:20:44.718]   - Field: ‘packages’
[16:20:44.718]   - Field: ‘gc’
[16:20:44.718]   - Field: ‘job’
[16:20:44.718]   - Field: ‘conditions’
[16:20:44.718]   - Field: ‘expr’
[16:20:44.718]   - Field: ‘uuid’
[16:20:44.718]   - Field: ‘seed’
[16:20:44.718]   - Field: ‘version’
[16:20:44.719]   - Field: ‘result’
[16:20:44.719]   - Field: ‘asynchronous’
[16:20:44.719]   - Field: ‘calls’
[16:20:44.719]   - Field: ‘globals’
[16:20:44.719]   - Field: ‘stdout’
[16:20:44.719]   - Field: ‘earlySignal’
[16:20:44.719]   - Field: ‘lazy’
[16:20:44.720]   - Field: ‘state’
[16:20:44.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:44.720] - Launch lazy future ...
[16:20:44.720] Packages needed by the future expression (n = 0): <none>
[16:20:44.721] Packages needed by future strategies (n = 0): <none>
[16:20:44.721] {
[16:20:44.721]     {
[16:20:44.721]         {
[16:20:44.721]             ...future.startTime <- base::Sys.time()
[16:20:44.721]             {
[16:20:44.721]                 {
[16:20:44.721]                   {
[16:20:44.721]                     {
[16:20:44.721]                       base::local({
[16:20:44.721]                         has_future <- base::requireNamespace("future", 
[16:20:44.721]                           quietly = TRUE)
[16:20:44.721]                         if (has_future) {
[16:20:44.721]                           ns <- base::getNamespace("future")
[16:20:44.721]                           version <- ns[[".package"]][["version"]]
[16:20:44.721]                           if (is.null(version)) 
[16:20:44.721]                             version <- utils::packageVersion("future")
[16:20:44.721]                         }
[16:20:44.721]                         else {
[16:20:44.721]                           version <- NULL
[16:20:44.721]                         }
[16:20:44.721]                         if (!has_future || version < "1.8.0") {
[16:20:44.721]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.721]                             "", base::R.version$version.string), 
[16:20:44.721]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.721]                               "release", "version")], collapse = " "), 
[16:20:44.721]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.721]                             info)
[16:20:44.721]                           info <- base::paste(info, collapse = "; ")
[16:20:44.721]                           if (!has_future) {
[16:20:44.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.721]                               info)
[16:20:44.721]                           }
[16:20:44.721]                           else {
[16:20:44.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.721]                               info, version)
[16:20:44.721]                           }
[16:20:44.721]                           base::stop(msg)
[16:20:44.721]                         }
[16:20:44.721]                       })
[16:20:44.721]                     }
[16:20:44.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.721]                     base::options(mc.cores = 1L)
[16:20:44.721]                   }
[16:20:44.721]                   ...future.strategy.old <- future::plan("list")
[16:20:44.721]                   options(future.plan = NULL)
[16:20:44.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.721]                 }
[16:20:44.721]                 ...future.workdir <- getwd()
[16:20:44.721]             }
[16:20:44.721]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.721]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.721]         }
[16:20:44.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.721]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.721]             base::names(...future.oldOptions))
[16:20:44.721]     }
[16:20:44.721]     if (FALSE) {
[16:20:44.721]     }
[16:20:44.721]     else {
[16:20:44.721]         if (TRUE) {
[16:20:44.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.721]                 open = "w")
[16:20:44.721]         }
[16:20:44.721]         else {
[16:20:44.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.721]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.721]         }
[16:20:44.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.721]             base::sink(type = "output", split = FALSE)
[16:20:44.721]             base::close(...future.stdout)
[16:20:44.721]         }, add = TRUE)
[16:20:44.721]     }
[16:20:44.721]     ...future.frame <- base::sys.nframe()
[16:20:44.721]     ...future.conditions <- base::list()
[16:20:44.721]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.721]     if (FALSE) {
[16:20:44.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.721]     }
[16:20:44.721]     ...future.result <- base::tryCatch({
[16:20:44.721]         base::withCallingHandlers({
[16:20:44.721]             ...future.value <- base::withVisible(base::local({
[16:20:44.721]                 withCallingHandlers({
[16:20:44.721]                   NULL
[16:20:44.721]                 }, immediateCondition = function(cond) {
[16:20:44.721]                   save_rds <- function (object, pathname, ...) 
[16:20:44.721]                   {
[16:20:44.721]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:44.721]                     if (file_test("-f", pathname_tmp)) {
[16:20:44.721]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.721]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:44.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.721]                         fi_tmp[["mtime"]])
[16:20:44.721]                     }
[16:20:44.721]                     tryCatch({
[16:20:44.721]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:44.721]                     }, error = function(ex) {
[16:20:44.721]                       msg <- conditionMessage(ex)
[16:20:44.721]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.721]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:44.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.721]                         fi_tmp[["mtime"]], msg)
[16:20:44.721]                       ex$message <- msg
[16:20:44.721]                       stop(ex)
[16:20:44.721]                     })
[16:20:44.721]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:44.721]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:44.721]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:44.721]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.721]                       fi <- file.info(pathname)
[16:20:44.721]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:44.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.721]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:44.721]                         fi[["size"]], fi[["mtime"]])
[16:20:44.721]                       stop(msg)
[16:20:44.721]                     }
[16:20:44.721]                     invisible(pathname)
[16:20:44.721]                   }
[16:20:44.721]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:44.721]                     rootPath = tempdir()) 
[16:20:44.721]                   {
[16:20:44.721]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:44.721]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:44.721]                       tmpdir = path, fileext = ".rds")
[16:20:44.721]                     save_rds(obj, file)
[16:20:44.721]                   }
[16:20:44.721]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:44.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.721]                   {
[16:20:44.721]                     inherits <- base::inherits
[16:20:44.721]                     invokeRestart <- base::invokeRestart
[16:20:44.721]                     is.null <- base::is.null
[16:20:44.721]                     muffled <- FALSE
[16:20:44.721]                     if (inherits(cond, "message")) {
[16:20:44.721]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.721]                       if (muffled) 
[16:20:44.721]                         invokeRestart("muffleMessage")
[16:20:44.721]                     }
[16:20:44.721]                     else if (inherits(cond, "warning")) {
[16:20:44.721]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.721]                       if (muffled) 
[16:20:44.721]                         invokeRestart("muffleWarning")
[16:20:44.721]                     }
[16:20:44.721]                     else if (inherits(cond, "condition")) {
[16:20:44.721]                       if (!is.null(pattern)) {
[16:20:44.721]                         computeRestarts <- base::computeRestarts
[16:20:44.721]                         grepl <- base::grepl
[16:20:44.721]                         restarts <- computeRestarts(cond)
[16:20:44.721]                         for (restart in restarts) {
[16:20:44.721]                           name <- restart$name
[16:20:44.721]                           if (is.null(name)) 
[16:20:44.721]                             next
[16:20:44.721]                           if (!grepl(pattern, name)) 
[16:20:44.721]                             next
[16:20:44.721]                           invokeRestart(restart)
[16:20:44.721]                           muffled <- TRUE
[16:20:44.721]                           break
[16:20:44.721]                         }
[16:20:44.721]                       }
[16:20:44.721]                     }
[16:20:44.721]                     invisible(muffled)
[16:20:44.721]                   }
[16:20:44.721]                   muffleCondition(cond)
[16:20:44.721]                 })
[16:20:44.721]             }))
[16:20:44.721]             future::FutureResult(value = ...future.value$value, 
[16:20:44.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.721]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.721]                     ...future.globalenv.names))
[16:20:44.721]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.721]         }, condition = base::local({
[16:20:44.721]             c <- base::c
[16:20:44.721]             inherits <- base::inherits
[16:20:44.721]             invokeRestart <- base::invokeRestart
[16:20:44.721]             length <- base::length
[16:20:44.721]             list <- base::list
[16:20:44.721]             seq.int <- base::seq.int
[16:20:44.721]             signalCondition <- base::signalCondition
[16:20:44.721]             sys.calls <- base::sys.calls
[16:20:44.721]             `[[` <- base::`[[`
[16:20:44.721]             `+` <- base::`+`
[16:20:44.721]             `<<-` <- base::`<<-`
[16:20:44.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.721]                   3L)]
[16:20:44.721]             }
[16:20:44.721]             function(cond) {
[16:20:44.721]                 is_error <- inherits(cond, "error")
[16:20:44.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.721]                   NULL)
[16:20:44.721]                 if (is_error) {
[16:20:44.721]                   sessionInformation <- function() {
[16:20:44.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.721]                       search = base::search(), system = base::Sys.info())
[16:20:44.721]                   }
[16:20:44.721]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.721]                     cond$call), session = sessionInformation(), 
[16:20:44.721]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.721]                   signalCondition(cond)
[16:20:44.721]                 }
[16:20:44.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.721]                 "immediateCondition"))) {
[16:20:44.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.721]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.721]                   if (TRUE && !signal) {
[16:20:44.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.721]                     {
[16:20:44.721]                       inherits <- base::inherits
[16:20:44.721]                       invokeRestart <- base::invokeRestart
[16:20:44.721]                       is.null <- base::is.null
[16:20:44.721]                       muffled <- FALSE
[16:20:44.721]                       if (inherits(cond, "message")) {
[16:20:44.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.721]                         if (muffled) 
[16:20:44.721]                           invokeRestart("muffleMessage")
[16:20:44.721]                       }
[16:20:44.721]                       else if (inherits(cond, "warning")) {
[16:20:44.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.721]                         if (muffled) 
[16:20:44.721]                           invokeRestart("muffleWarning")
[16:20:44.721]                       }
[16:20:44.721]                       else if (inherits(cond, "condition")) {
[16:20:44.721]                         if (!is.null(pattern)) {
[16:20:44.721]                           computeRestarts <- base::computeRestarts
[16:20:44.721]                           grepl <- base::grepl
[16:20:44.721]                           restarts <- computeRestarts(cond)
[16:20:44.721]                           for (restart in restarts) {
[16:20:44.721]                             name <- restart$name
[16:20:44.721]                             if (is.null(name)) 
[16:20:44.721]                               next
[16:20:44.721]                             if (!grepl(pattern, name)) 
[16:20:44.721]                               next
[16:20:44.721]                             invokeRestart(restart)
[16:20:44.721]                             muffled <- TRUE
[16:20:44.721]                             break
[16:20:44.721]                           }
[16:20:44.721]                         }
[16:20:44.721]                       }
[16:20:44.721]                       invisible(muffled)
[16:20:44.721]                     }
[16:20:44.721]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.721]                   }
[16:20:44.721]                 }
[16:20:44.721]                 else {
[16:20:44.721]                   if (TRUE) {
[16:20:44.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.721]                     {
[16:20:44.721]                       inherits <- base::inherits
[16:20:44.721]                       invokeRestart <- base::invokeRestart
[16:20:44.721]                       is.null <- base::is.null
[16:20:44.721]                       muffled <- FALSE
[16:20:44.721]                       if (inherits(cond, "message")) {
[16:20:44.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.721]                         if (muffled) 
[16:20:44.721]                           invokeRestart("muffleMessage")
[16:20:44.721]                       }
[16:20:44.721]                       else if (inherits(cond, "warning")) {
[16:20:44.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.721]                         if (muffled) 
[16:20:44.721]                           invokeRestart("muffleWarning")
[16:20:44.721]                       }
[16:20:44.721]                       else if (inherits(cond, "condition")) {
[16:20:44.721]                         if (!is.null(pattern)) {
[16:20:44.721]                           computeRestarts <- base::computeRestarts
[16:20:44.721]                           grepl <- base::grepl
[16:20:44.721]                           restarts <- computeRestarts(cond)
[16:20:44.721]                           for (restart in restarts) {
[16:20:44.721]                             name <- restart$name
[16:20:44.721]                             if (is.null(name)) 
[16:20:44.721]                               next
[16:20:44.721]                             if (!grepl(pattern, name)) 
[16:20:44.721]                               next
[16:20:44.721]                             invokeRestart(restart)
[16:20:44.721]                             muffled <- TRUE
[16:20:44.721]                             break
[16:20:44.721]                           }
[16:20:44.721]                         }
[16:20:44.721]                       }
[16:20:44.721]                       invisible(muffled)
[16:20:44.721]                     }
[16:20:44.721]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.721]                   }
[16:20:44.721]                 }
[16:20:44.721]             }
[16:20:44.721]         }))
[16:20:44.721]     }, error = function(ex) {
[16:20:44.721]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.721]                 ...future.rng), started = ...future.startTime, 
[16:20:44.721]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.721]             version = "1.8"), class = "FutureResult")
[16:20:44.721]     }, finally = {
[16:20:44.721]         if (!identical(...future.workdir, getwd())) 
[16:20:44.721]             setwd(...future.workdir)
[16:20:44.721]         {
[16:20:44.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.721]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.721]             }
[16:20:44.721]             base::options(...future.oldOptions)
[16:20:44.721]             if (.Platform$OS.type == "windows") {
[16:20:44.721]                 old_names <- names(...future.oldEnvVars)
[16:20:44.721]                 envs <- base::Sys.getenv()
[16:20:44.721]                 names <- names(envs)
[16:20:44.721]                 common <- intersect(names, old_names)
[16:20:44.721]                 added <- setdiff(names, old_names)
[16:20:44.721]                 removed <- setdiff(old_names, names)
[16:20:44.721]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.721]                   envs[common]]
[16:20:44.721]                 NAMES <- toupper(changed)
[16:20:44.721]                 args <- list()
[16:20:44.721]                 for (kk in seq_along(NAMES)) {
[16:20:44.721]                   name <- changed[[kk]]
[16:20:44.721]                   NAME <- NAMES[[kk]]
[16:20:44.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.721]                     next
[16:20:44.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.721]                 }
[16:20:44.721]                 NAMES <- toupper(added)
[16:20:44.721]                 for (kk in seq_along(NAMES)) {
[16:20:44.721]                   name <- added[[kk]]
[16:20:44.721]                   NAME <- NAMES[[kk]]
[16:20:44.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.721]                     next
[16:20:44.721]                   args[[name]] <- ""
[16:20:44.721]                 }
[16:20:44.721]                 NAMES <- toupper(removed)
[16:20:44.721]                 for (kk in seq_along(NAMES)) {
[16:20:44.721]                   name <- removed[[kk]]
[16:20:44.721]                   NAME <- NAMES[[kk]]
[16:20:44.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.721]                     next
[16:20:44.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.721]                 }
[16:20:44.721]                 if (length(args) > 0) 
[16:20:44.721]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.721]             }
[16:20:44.721]             else {
[16:20:44.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.721]             }
[16:20:44.721]             {
[16:20:44.721]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.721]                   0L) {
[16:20:44.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.721]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.721]                   base::options(opts)
[16:20:44.721]                 }
[16:20:44.721]                 {
[16:20:44.721]                   {
[16:20:44.721]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.721]                     NULL
[16:20:44.721]                   }
[16:20:44.721]                   options(future.plan = NULL)
[16:20:44.721]                   if (is.na(NA_character_)) 
[16:20:44.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.721]                     .init = FALSE)
[16:20:44.721]                 }
[16:20:44.721]             }
[16:20:44.721]         }
[16:20:44.721]     })
[16:20:44.721]     if (TRUE) {
[16:20:44.721]         base::sink(type = "output", split = FALSE)
[16:20:44.721]         if (TRUE) {
[16:20:44.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.721]         }
[16:20:44.721]         else {
[16:20:44.721]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.721]         }
[16:20:44.721]         base::close(...future.stdout)
[16:20:44.721]         ...future.stdout <- NULL
[16:20:44.721]     }
[16:20:44.721]     ...future.result$conditions <- ...future.conditions
[16:20:44.721]     ...future.result$finished <- base::Sys.time()
[16:20:44.721]     ...future.result
[16:20:44.721] }
[16:20:44.725] requestCore(): workers = 2
[16:20:44.728] MulticoreFuture started
[16:20:44.728] - Launch lazy future ... done
[16:20:44.728] run() for ‘MulticoreFuture’ ... done
[16:20:44.729] plan(): Setting new future strategy stack:
[16:20:44.729] getGlobalsAndPackages() ...
[16:20:44.729] Searching for globals...
[16:20:44.729] List of future strategies:
[16:20:44.729] 1. sequential:
[16:20:44.729]    - args: function (..., envir = parent.frame())
[16:20:44.729]    - tweaked: FALSE
[16:20:44.729]    - call: NULL
[16:20:44.730] plan(): nbrOfWorkers() = 1
[16:20:44.731] - globals found: [1] ‘{’
[16:20:44.731] Searching for globals ... DONE
[16:20:44.731] Resolving globals: FALSE
[16:20:44.731] 
[16:20:44.732] 
[16:20:44.732] getGlobalsAndPackages() ... DONE
[16:20:44.732] plan(): Setting new future strategy stack:
[16:20:44.732] run() for ‘Future’ ...
[16:20:44.732] - state: ‘created’
[16:20:44.732] List of future strategies:
[16:20:44.732] 1. multicore:
[16:20:44.732]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.732]    - tweaked: FALSE
[16:20:44.732]    - call: plan(strategy)
[16:20:44.733] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.737] plan(): nbrOfWorkers() = 2
[16:20:44.738] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.738] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:44.738]   - Field: ‘label’
[16:20:44.738]   - Field: ‘local’
[16:20:44.738]   - Field: ‘owner’
[16:20:44.738]   - Field: ‘envir’
[16:20:44.739]   - Field: ‘workers’
[16:20:44.739]   - Field: ‘packages’
[16:20:44.739]   - Field: ‘gc’
[16:20:44.739]   - Field: ‘job’
[16:20:44.739]   - Field: ‘conditions’
[16:20:44.739]   - Field: ‘expr’
[16:20:44.739]   - Field: ‘uuid’
[16:20:44.739]   - Field: ‘seed’
[16:20:44.740]   - Field: ‘version’
[16:20:44.740]   - Field: ‘result’
[16:20:44.740]   - Field: ‘asynchronous’
[16:20:44.740]   - Field: ‘calls’
[16:20:44.740]   - Field: ‘globals’
[16:20:44.740]   - Field: ‘stdout’
[16:20:44.740]   - Field: ‘earlySignal’
[16:20:44.741]   - Field: ‘lazy’
[16:20:44.741]   - Field: ‘state’
[16:20:44.741] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:44.741] - Launch lazy future ...
[16:20:44.741] Packages needed by the future expression (n = 0): <none>
[16:20:44.742] Packages needed by future strategies (n = 0): <none>
[16:20:44.742] {
[16:20:44.742]     {
[16:20:44.742]         {
[16:20:44.742]             ...future.startTime <- base::Sys.time()
[16:20:44.742]             {
[16:20:44.742]                 {
[16:20:44.742]                   {
[16:20:44.742]                     {
[16:20:44.742]                       base::local({
[16:20:44.742]                         has_future <- base::requireNamespace("future", 
[16:20:44.742]                           quietly = TRUE)
[16:20:44.742]                         if (has_future) {
[16:20:44.742]                           ns <- base::getNamespace("future")
[16:20:44.742]                           version <- ns[[".package"]][["version"]]
[16:20:44.742]                           if (is.null(version)) 
[16:20:44.742]                             version <- utils::packageVersion("future")
[16:20:44.742]                         }
[16:20:44.742]                         else {
[16:20:44.742]                           version <- NULL
[16:20:44.742]                         }
[16:20:44.742]                         if (!has_future || version < "1.8.0") {
[16:20:44.742]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.742]                             "", base::R.version$version.string), 
[16:20:44.742]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.742]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.742]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.742]                               "release", "version")], collapse = " "), 
[16:20:44.742]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.742]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.742]                             info)
[16:20:44.742]                           info <- base::paste(info, collapse = "; ")
[16:20:44.742]                           if (!has_future) {
[16:20:44.742]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.742]                               info)
[16:20:44.742]                           }
[16:20:44.742]                           else {
[16:20:44.742]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.742]                               info, version)
[16:20:44.742]                           }
[16:20:44.742]                           base::stop(msg)
[16:20:44.742]                         }
[16:20:44.742]                       })
[16:20:44.742]                     }
[16:20:44.742]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.742]                     base::options(mc.cores = 1L)
[16:20:44.742]                   }
[16:20:44.742]                   ...future.strategy.old <- future::plan("list")
[16:20:44.742]                   options(future.plan = NULL)
[16:20:44.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.742]                 }
[16:20:44.742]                 ...future.workdir <- getwd()
[16:20:44.742]             }
[16:20:44.742]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.742]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.742]         }
[16:20:44.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.742]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.742]             base::names(...future.oldOptions))
[16:20:44.742]     }
[16:20:44.742]     if (FALSE) {
[16:20:44.742]     }
[16:20:44.742]     else {
[16:20:44.742]         if (TRUE) {
[16:20:44.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.742]                 open = "w")
[16:20:44.742]         }
[16:20:44.742]         else {
[16:20:44.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.742]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.742]         }
[16:20:44.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.742]             base::sink(type = "output", split = FALSE)
[16:20:44.742]             base::close(...future.stdout)
[16:20:44.742]         }, add = TRUE)
[16:20:44.742]     }
[16:20:44.742]     ...future.frame <- base::sys.nframe()
[16:20:44.742]     ...future.conditions <- base::list()
[16:20:44.742]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.742]     if (FALSE) {
[16:20:44.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.742]     }
[16:20:44.742]     ...future.result <- base::tryCatch({
[16:20:44.742]         base::withCallingHandlers({
[16:20:44.742]             ...future.value <- base::withVisible(base::local({
[16:20:44.742]                 withCallingHandlers({
[16:20:44.742]                   {
[16:20:44.742]                     4
[16:20:44.742]                   }
[16:20:44.742]                 }, immediateCondition = function(cond) {
[16:20:44.742]                   save_rds <- function (object, pathname, ...) 
[16:20:44.742]                   {
[16:20:44.742]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:44.742]                     if (file_test("-f", pathname_tmp)) {
[16:20:44.742]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.742]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:44.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.742]                         fi_tmp[["mtime"]])
[16:20:44.742]                     }
[16:20:44.742]                     tryCatch({
[16:20:44.742]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:44.742]                     }, error = function(ex) {
[16:20:44.742]                       msg <- conditionMessage(ex)
[16:20:44.742]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.742]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:44.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.742]                         fi_tmp[["mtime"]], msg)
[16:20:44.742]                       ex$message <- msg
[16:20:44.742]                       stop(ex)
[16:20:44.742]                     })
[16:20:44.742]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:44.742]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:44.742]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:44.742]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.742]                       fi <- file.info(pathname)
[16:20:44.742]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:44.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.742]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:44.742]                         fi[["size"]], fi[["mtime"]])
[16:20:44.742]                       stop(msg)
[16:20:44.742]                     }
[16:20:44.742]                     invisible(pathname)
[16:20:44.742]                   }
[16:20:44.742]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:44.742]                     rootPath = tempdir()) 
[16:20:44.742]                   {
[16:20:44.742]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:44.742]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:44.742]                       tmpdir = path, fileext = ".rds")
[16:20:44.742]                     save_rds(obj, file)
[16:20:44.742]                   }
[16:20:44.742]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:44.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.742]                   {
[16:20:44.742]                     inherits <- base::inherits
[16:20:44.742]                     invokeRestart <- base::invokeRestart
[16:20:44.742]                     is.null <- base::is.null
[16:20:44.742]                     muffled <- FALSE
[16:20:44.742]                     if (inherits(cond, "message")) {
[16:20:44.742]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.742]                       if (muffled) 
[16:20:44.742]                         invokeRestart("muffleMessage")
[16:20:44.742]                     }
[16:20:44.742]                     else if (inherits(cond, "warning")) {
[16:20:44.742]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.742]                       if (muffled) 
[16:20:44.742]                         invokeRestart("muffleWarning")
[16:20:44.742]                     }
[16:20:44.742]                     else if (inherits(cond, "condition")) {
[16:20:44.742]                       if (!is.null(pattern)) {
[16:20:44.742]                         computeRestarts <- base::computeRestarts
[16:20:44.742]                         grepl <- base::grepl
[16:20:44.742]                         restarts <- computeRestarts(cond)
[16:20:44.742]                         for (restart in restarts) {
[16:20:44.742]                           name <- restart$name
[16:20:44.742]                           if (is.null(name)) 
[16:20:44.742]                             next
[16:20:44.742]                           if (!grepl(pattern, name)) 
[16:20:44.742]                             next
[16:20:44.742]                           invokeRestart(restart)
[16:20:44.742]                           muffled <- TRUE
[16:20:44.742]                           break
[16:20:44.742]                         }
[16:20:44.742]                       }
[16:20:44.742]                     }
[16:20:44.742]                     invisible(muffled)
[16:20:44.742]                   }
[16:20:44.742]                   muffleCondition(cond)
[16:20:44.742]                 })
[16:20:44.742]             }))
[16:20:44.742]             future::FutureResult(value = ...future.value$value, 
[16:20:44.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.742]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.742]                     ...future.globalenv.names))
[16:20:44.742]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.742]         }, condition = base::local({
[16:20:44.742]             c <- base::c
[16:20:44.742]             inherits <- base::inherits
[16:20:44.742]             invokeRestart <- base::invokeRestart
[16:20:44.742]             length <- base::length
[16:20:44.742]             list <- base::list
[16:20:44.742]             seq.int <- base::seq.int
[16:20:44.742]             signalCondition <- base::signalCondition
[16:20:44.742]             sys.calls <- base::sys.calls
[16:20:44.742]             `[[` <- base::`[[`
[16:20:44.742]             `+` <- base::`+`
[16:20:44.742]             `<<-` <- base::`<<-`
[16:20:44.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.742]                   3L)]
[16:20:44.742]             }
[16:20:44.742]             function(cond) {
[16:20:44.742]                 is_error <- inherits(cond, "error")
[16:20:44.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.742]                   NULL)
[16:20:44.742]                 if (is_error) {
[16:20:44.742]                   sessionInformation <- function() {
[16:20:44.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.742]                       search = base::search(), system = base::Sys.info())
[16:20:44.742]                   }
[16:20:44.742]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.742]                     cond$call), session = sessionInformation(), 
[16:20:44.742]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.742]                   signalCondition(cond)
[16:20:44.742]                 }
[16:20:44.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.742]                 "immediateCondition"))) {
[16:20:44.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.742]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.742]                   if (TRUE && !signal) {
[16:20:44.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.742]                     {
[16:20:44.742]                       inherits <- base::inherits
[16:20:44.742]                       invokeRestart <- base::invokeRestart
[16:20:44.742]                       is.null <- base::is.null
[16:20:44.742]                       muffled <- FALSE
[16:20:44.742]                       if (inherits(cond, "message")) {
[16:20:44.742]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.742]                         if (muffled) 
[16:20:44.742]                           invokeRestart("muffleMessage")
[16:20:44.742]                       }
[16:20:44.742]                       else if (inherits(cond, "warning")) {
[16:20:44.742]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.742]                         if (muffled) 
[16:20:44.742]                           invokeRestart("muffleWarning")
[16:20:44.742]                       }
[16:20:44.742]                       else if (inherits(cond, "condition")) {
[16:20:44.742]                         if (!is.null(pattern)) {
[16:20:44.742]                           computeRestarts <- base::computeRestarts
[16:20:44.742]                           grepl <- base::grepl
[16:20:44.742]                           restarts <- computeRestarts(cond)
[16:20:44.742]                           for (restart in restarts) {
[16:20:44.742]                             name <- restart$name
[16:20:44.742]                             if (is.null(name)) 
[16:20:44.742]                               next
[16:20:44.742]                             if (!grepl(pattern, name)) 
[16:20:44.742]                               next
[16:20:44.742]                             invokeRestart(restart)
[16:20:44.742]                             muffled <- TRUE
[16:20:44.742]                             break
[16:20:44.742]                           }
[16:20:44.742]                         }
[16:20:44.742]                       }
[16:20:44.742]                       invisible(muffled)
[16:20:44.742]                     }
[16:20:44.742]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.742]                   }
[16:20:44.742]                 }
[16:20:44.742]                 else {
[16:20:44.742]                   if (TRUE) {
[16:20:44.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.742]                     {
[16:20:44.742]                       inherits <- base::inherits
[16:20:44.742]                       invokeRestart <- base::invokeRestart
[16:20:44.742]                       is.null <- base::is.null
[16:20:44.742]                       muffled <- FALSE
[16:20:44.742]                       if (inherits(cond, "message")) {
[16:20:44.742]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.742]                         if (muffled) 
[16:20:44.742]                           invokeRestart("muffleMessage")
[16:20:44.742]                       }
[16:20:44.742]                       else if (inherits(cond, "warning")) {
[16:20:44.742]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.742]                         if (muffled) 
[16:20:44.742]                           invokeRestart("muffleWarning")
[16:20:44.742]                       }
[16:20:44.742]                       else if (inherits(cond, "condition")) {
[16:20:44.742]                         if (!is.null(pattern)) {
[16:20:44.742]                           computeRestarts <- base::computeRestarts
[16:20:44.742]                           grepl <- base::grepl
[16:20:44.742]                           restarts <- computeRestarts(cond)
[16:20:44.742]                           for (restart in restarts) {
[16:20:44.742]                             name <- restart$name
[16:20:44.742]                             if (is.null(name)) 
[16:20:44.742]                               next
[16:20:44.742]                             if (!grepl(pattern, name)) 
[16:20:44.742]                               next
[16:20:44.742]                             invokeRestart(restart)
[16:20:44.742]                             muffled <- TRUE
[16:20:44.742]                             break
[16:20:44.742]                           }
[16:20:44.742]                         }
[16:20:44.742]                       }
[16:20:44.742]                       invisible(muffled)
[16:20:44.742]                     }
[16:20:44.742]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.742]                   }
[16:20:44.742]                 }
[16:20:44.742]             }
[16:20:44.742]         }))
[16:20:44.742]     }, error = function(ex) {
[16:20:44.742]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.742]                 ...future.rng), started = ...future.startTime, 
[16:20:44.742]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.742]             version = "1.8"), class = "FutureResult")
[16:20:44.742]     }, finally = {
[16:20:44.742]         if (!identical(...future.workdir, getwd())) 
[16:20:44.742]             setwd(...future.workdir)
[16:20:44.742]         {
[16:20:44.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.742]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.742]             }
[16:20:44.742]             base::options(...future.oldOptions)
[16:20:44.742]             if (.Platform$OS.type == "windows") {
[16:20:44.742]                 old_names <- names(...future.oldEnvVars)
[16:20:44.742]                 envs <- base::Sys.getenv()
[16:20:44.742]                 names <- names(envs)
[16:20:44.742]                 common <- intersect(names, old_names)
[16:20:44.742]                 added <- setdiff(names, old_names)
[16:20:44.742]                 removed <- setdiff(old_names, names)
[16:20:44.742]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.742]                   envs[common]]
[16:20:44.742]                 NAMES <- toupper(changed)
[16:20:44.742]                 args <- list()
[16:20:44.742]                 for (kk in seq_along(NAMES)) {
[16:20:44.742]                   name <- changed[[kk]]
[16:20:44.742]                   NAME <- NAMES[[kk]]
[16:20:44.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.742]                     next
[16:20:44.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.742]                 }
[16:20:44.742]                 NAMES <- toupper(added)
[16:20:44.742]                 for (kk in seq_along(NAMES)) {
[16:20:44.742]                   name <- added[[kk]]
[16:20:44.742]                   NAME <- NAMES[[kk]]
[16:20:44.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.742]                     next
[16:20:44.742]                   args[[name]] <- ""
[16:20:44.742]                 }
[16:20:44.742]                 NAMES <- toupper(removed)
[16:20:44.742]                 for (kk in seq_along(NAMES)) {
[16:20:44.742]                   name <- removed[[kk]]
[16:20:44.742]                   NAME <- NAMES[[kk]]
[16:20:44.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.742]                     next
[16:20:44.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.742]                 }
[16:20:44.742]                 if (length(args) > 0) 
[16:20:44.742]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.742]             }
[16:20:44.742]             else {
[16:20:44.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.742]             }
[16:20:44.742]             {
[16:20:44.742]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.742]                   0L) {
[16:20:44.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.742]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.742]                   base::options(opts)
[16:20:44.742]                 }
[16:20:44.742]                 {
[16:20:44.742]                   {
[16:20:44.742]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.742]                     NULL
[16:20:44.742]                   }
[16:20:44.742]                   options(future.plan = NULL)
[16:20:44.742]                   if (is.na(NA_character_)) 
[16:20:44.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.742]                     .init = FALSE)
[16:20:44.742]                 }
[16:20:44.742]             }
[16:20:44.742]         }
[16:20:44.742]     })
[16:20:44.742]     if (TRUE) {
[16:20:44.742]         base::sink(type = "output", split = FALSE)
[16:20:44.742]         if (TRUE) {
[16:20:44.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.742]         }
[16:20:44.742]         else {
[16:20:44.742]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.742]         }
[16:20:44.742]         base::close(...future.stdout)
[16:20:44.742]         ...future.stdout <- NULL
[16:20:44.742]     }
[16:20:44.742]     ...future.result$conditions <- ...future.conditions
[16:20:44.742]     ...future.result$finished <- base::Sys.time()
[16:20:44.742]     ...future.result
[16:20:44.742] }
[16:20:44.746] requestCore(): workers = 2
[16:20:44.746] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:44.757] result() for MulticoreFuture ...
[16:20:44.758] result() for MulticoreFuture ...
[16:20:44.758] result() for MulticoreFuture ... done
[16:20:44.758] result() for MulticoreFuture ... done
[16:20:44.765] result() for MulticoreFuture ...
[16:20:44.765] result() for MulticoreFuture ... done
[16:20:44.769] MulticoreFuture started
[16:20:44.769] - Launch lazy future ... done
[16:20:44.769] run() for ‘MulticoreFuture’ ... done
[16:20:44.770] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55ed0d73f260> 
[16:20:44.770] List of future strategies:
[16:20:44.770] 1. sequential:
[16:20:44.770]    - args: function (..., envir = parent.frame())
[16:20:44.770]    - tweaked: FALSE
[16:20:44.770]    - call: NULL
[16:20:44.772] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55ed0ca30cb8> 
[16:20:44.774] plan(): Setting new future strategy stack:
[16:20:44.774] List of future strategies:
[16:20:44.774] 1. multicore:
[16:20:44.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.774]    - tweaked: FALSE
[16:20:44.774]    - call: plan(strategy)
[16:20:44.780] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:44.783] resolve() on list environment ...
[16:20:44.783]  recursive: 0
[16:20:44.784]  length: 6
[16:20:44.784]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:44.785] signalConditionsASAP(numeric, pos=1) ...
[16:20:44.785] - nx: 6
[16:20:44.785] - relay: TRUE
[16:20:44.785] - stdout: TRUE
[16:20:44.785] - signal: TRUE
[16:20:44.785] - resignal: FALSE
[16:20:44.786] - force: TRUE
[16:20:44.786] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.786] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.786]  - until=2
[16:20:44.786]  - relaying element #2
[16:20:44.786] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.786] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.787] signalConditionsASAP(NULL, pos=1) ... done
[16:20:44.787]  length: 5 (resolved future 1)
[16:20:44.787] Future #2
[16:20:44.787] result() for MulticoreFuture ...
[16:20:44.787] result() for MulticoreFuture ... done
[16:20:44.788] result() for MulticoreFuture ...
[16:20:44.788] result() for MulticoreFuture ... done
[16:20:44.788] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:44.788] - nx: 6
[16:20:44.788] - relay: TRUE
[16:20:44.788] - stdout: TRUE
[16:20:44.788] - signal: TRUE
[16:20:44.789] - resignal: FALSE
[16:20:44.789] - force: TRUE
[16:20:44.789] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.789] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.789]  - until=2
[16:20:44.789]  - relaying element #2
[16:20:44.789] result() for MulticoreFuture ...
[16:20:44.789] result() for MulticoreFuture ... done
[16:20:44.790] result() for MulticoreFuture ...
[16:20:44.790] result() for MulticoreFuture ... done
[16:20:44.790] result() for MulticoreFuture ...
[16:20:44.790] result() for MulticoreFuture ... done
[16:20:44.790] result() for MulticoreFuture ...
[16:20:44.790] result() for MulticoreFuture ... done
[16:20:44.790] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:44.791] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:44.791] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:44.791]  length: 4 (resolved future 2)
[16:20:44.791] Future #3
[16:20:44.791] result() for MulticoreFuture ...
[16:20:44.792] result() for MulticoreFuture ...
[16:20:44.793] result() for MulticoreFuture ... done
[16:20:44.793] result() for MulticoreFuture ... done
[16:20:44.793] result() for MulticoreFuture ...
[16:20:44.793] result() for MulticoreFuture ... done
[16:20:44.793] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:44.793] - nx: 6
[16:20:44.793] - relay: TRUE
[16:20:44.793] - stdout: TRUE
[16:20:44.794] - signal: TRUE
[16:20:44.794] - resignal: FALSE
[16:20:44.794] - force: TRUE
[16:20:44.794] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:44.794] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:44.794]  - until=3
[16:20:44.794]  - relaying element #3
[16:20:44.794] result() for MulticoreFuture ...
[16:20:44.795] result() for MulticoreFuture ... done
[16:20:44.795] result() for MulticoreFuture ...
[16:20:44.795] result() for MulticoreFuture ... done
[16:20:44.795] result() for MulticoreFuture ...
[16:20:44.795] result() for MulticoreFuture ... done
[16:20:44.795] result() for MulticoreFuture ...
[16:20:44.795] result() for MulticoreFuture ... done
[16:20:44.796] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:44.796] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:44.796] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:44.796]  length: 3 (resolved future 3)
[16:20:44.796] Future #4
[16:20:44.797] result() for MulticoreFuture ...
[16:20:44.797] result() for MulticoreFuture ...
[16:20:44.797] result() for MulticoreFuture ... done
[16:20:44.797] result() for MulticoreFuture ... done
[16:20:44.798] result() for MulticoreFuture ...
[16:20:44.798] result() for MulticoreFuture ... done
[16:20:44.798] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:44.798] - nx: 6
[16:20:44.798] - relay: TRUE
[16:20:44.798] - stdout: TRUE
[16:20:44.798] - signal: TRUE
[16:20:44.798] - resignal: FALSE
[16:20:44.799] - force: TRUE
[16:20:44.799] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:44.799] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:44.799]  - until=4
[16:20:44.799]  - relaying element #4
[16:20:44.799] result() for MulticoreFuture ...
[16:20:44.799] result() for MulticoreFuture ... done
[16:20:44.799] result() for MulticoreFuture ...
[16:20:44.799] result() for MulticoreFuture ... done
[16:20:44.800] result() for MulticoreFuture ...
[16:20:44.800] result() for MulticoreFuture ... done
[16:20:44.800] result() for MulticoreFuture ...
[16:20:44.800] result() for MulticoreFuture ... done
[16:20:44.800] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.800] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.800] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:44.800]  length: 2 (resolved future 4)
[16:20:44.801] signalConditionsASAP(NULL, pos=5) ...
[16:20:44.801] - nx: 6
[16:20:44.801] - relay: TRUE
[16:20:44.801] - stdout: TRUE
[16:20:44.801] - signal: TRUE
[16:20:44.801] - resignal: FALSE
[16:20:44.801] - force: TRUE
[16:20:44.801] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.801] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.802]  - until=6
[16:20:44.802]  - relaying element #6
[16:20:44.802] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:44.802] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.802] signalConditionsASAP(NULL, pos=5) ... done
[16:20:44.802]  length: 1 (resolved future 5)
[16:20:44.802] signalConditionsASAP(numeric, pos=6) ...
[16:20:44.802] - nx: 6
[16:20:44.802] - relay: TRUE
[16:20:44.803] - stdout: TRUE
[16:20:44.803] - signal: TRUE
[16:20:44.803] - resignal: FALSE
[16:20:44.803] - force: TRUE
[16:20:44.803] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:44.803] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.803]  - until=6
[16:20:44.803] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:44.803] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.804] signalConditionsASAP(numeric, pos=6) ... done
[16:20:44.804]  length: 0 (resolved future 6)
[16:20:44.804] Relaying remaining futures
[16:20:44.804] signalConditionsASAP(NULL, pos=0) ...
[16:20:44.804] - nx: 6
[16:20:44.804] - relay: TRUE
[16:20:44.804] - stdout: TRUE
[16:20:44.804] - signal: TRUE
[16:20:44.804] - resignal: FALSE
[16:20:44.805] - force: TRUE
[16:20:44.805] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:44.805] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:44.805] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:44.805] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.805] signalConditionsASAP(NULL, pos=0) ... done
[16:20:44.805] resolve() on list environment ... DONE
[16:20:44.806] result() for MulticoreFuture ...
[16:20:44.806] result() for MulticoreFuture ... done
[16:20:44.806] result() for MulticoreFuture ...
[16:20:44.806] result() for MulticoreFuture ... done
[16:20:44.806] result() for MulticoreFuture ...
[16:20:44.806] result() for MulticoreFuture ... done
[16:20:44.806] result() for MulticoreFuture ...
[16:20:44.806] result() for MulticoreFuture ... done
[16:20:44.807] result() for MulticoreFuture ...
[16:20:44.807] result() for MulticoreFuture ... done
[16:20:44.807] result() for MulticoreFuture ...
[16:20:44.807] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0c733ce8> 
Dimensions: c(1, 6)
[16:20:44.808] getGlobalsAndPackages() ...
[16:20:44.808] Searching for globals...
[16:20:44.808] 
[16:20:44.809] Searching for globals ... DONE
[16:20:44.809] - globals: [0] <none>
[16:20:44.809] getGlobalsAndPackages() ... DONE
[16:20:44.809] run() for ‘Future’ ...
[16:20:44.809] - state: ‘created’
[16:20:44.809] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.814] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.814] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:44.814]   - Field: ‘label’
[16:20:44.815]   - Field: ‘local’
[16:20:44.815]   - Field: ‘owner’
[16:20:44.815]   - Field: ‘envir’
[16:20:44.815]   - Field: ‘workers’
[16:20:44.815]   - Field: ‘packages’
[16:20:44.815]   - Field: ‘gc’
[16:20:44.815]   - Field: ‘job’
[16:20:44.815]   - Field: ‘conditions’
[16:20:44.815]   - Field: ‘expr’
[16:20:44.816]   - Field: ‘uuid’
[16:20:44.816]   - Field: ‘seed’
[16:20:44.816]   - Field: ‘version’
[16:20:44.816]   - Field: ‘result’
[16:20:44.816]   - Field: ‘asynchronous’
[16:20:44.816]   - Field: ‘calls’
[16:20:44.816]   - Field: ‘globals’
[16:20:44.816]   - Field: ‘stdout’
[16:20:44.817]   - Field: ‘earlySignal’
[16:20:44.817]   - Field: ‘lazy’
[16:20:44.817]   - Field: ‘state’
[16:20:44.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:44.817] - Launch lazy future ...
[16:20:44.817] Packages needed by the future expression (n = 0): <none>
[16:20:44.817] Packages needed by future strategies (n = 0): <none>
[16:20:44.818] {
[16:20:44.818]     {
[16:20:44.818]         {
[16:20:44.818]             ...future.startTime <- base::Sys.time()
[16:20:44.818]             {
[16:20:44.818]                 {
[16:20:44.818]                   {
[16:20:44.818]                     {
[16:20:44.818]                       base::local({
[16:20:44.818]                         has_future <- base::requireNamespace("future", 
[16:20:44.818]                           quietly = TRUE)
[16:20:44.818]                         if (has_future) {
[16:20:44.818]                           ns <- base::getNamespace("future")
[16:20:44.818]                           version <- ns[[".package"]][["version"]]
[16:20:44.818]                           if (is.null(version)) 
[16:20:44.818]                             version <- utils::packageVersion("future")
[16:20:44.818]                         }
[16:20:44.818]                         else {
[16:20:44.818]                           version <- NULL
[16:20:44.818]                         }
[16:20:44.818]                         if (!has_future || version < "1.8.0") {
[16:20:44.818]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.818]                             "", base::R.version$version.string), 
[16:20:44.818]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.818]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.818]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.818]                               "release", "version")], collapse = " "), 
[16:20:44.818]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.818]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.818]                             info)
[16:20:44.818]                           info <- base::paste(info, collapse = "; ")
[16:20:44.818]                           if (!has_future) {
[16:20:44.818]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.818]                               info)
[16:20:44.818]                           }
[16:20:44.818]                           else {
[16:20:44.818]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.818]                               info, version)
[16:20:44.818]                           }
[16:20:44.818]                           base::stop(msg)
[16:20:44.818]                         }
[16:20:44.818]                       })
[16:20:44.818]                     }
[16:20:44.818]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.818]                     base::options(mc.cores = 1L)
[16:20:44.818]                   }
[16:20:44.818]                   ...future.strategy.old <- future::plan("list")
[16:20:44.818]                   options(future.plan = NULL)
[16:20:44.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.818]                 }
[16:20:44.818]                 ...future.workdir <- getwd()
[16:20:44.818]             }
[16:20:44.818]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.818]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.818]         }
[16:20:44.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.818]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.818]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.818]             base::names(...future.oldOptions))
[16:20:44.818]     }
[16:20:44.818]     if (FALSE) {
[16:20:44.818]     }
[16:20:44.818]     else {
[16:20:44.818]         if (TRUE) {
[16:20:44.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.818]                 open = "w")
[16:20:44.818]         }
[16:20:44.818]         else {
[16:20:44.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.818]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.818]         }
[16:20:44.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.818]             base::sink(type = "output", split = FALSE)
[16:20:44.818]             base::close(...future.stdout)
[16:20:44.818]         }, add = TRUE)
[16:20:44.818]     }
[16:20:44.818]     ...future.frame <- base::sys.nframe()
[16:20:44.818]     ...future.conditions <- base::list()
[16:20:44.818]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.818]     if (FALSE) {
[16:20:44.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.818]     }
[16:20:44.818]     ...future.result <- base::tryCatch({
[16:20:44.818]         base::withCallingHandlers({
[16:20:44.818]             ...future.value <- base::withVisible(base::local({
[16:20:44.818]                 withCallingHandlers({
[16:20:44.818]                   2
[16:20:44.818]                 }, immediateCondition = function(cond) {
[16:20:44.818]                   save_rds <- function (object, pathname, ...) 
[16:20:44.818]                   {
[16:20:44.818]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:44.818]                     if (file_test("-f", pathname_tmp)) {
[16:20:44.818]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.818]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:44.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.818]                         fi_tmp[["mtime"]])
[16:20:44.818]                     }
[16:20:44.818]                     tryCatch({
[16:20:44.818]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:44.818]                     }, error = function(ex) {
[16:20:44.818]                       msg <- conditionMessage(ex)
[16:20:44.818]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.818]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:44.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.818]                         fi_tmp[["mtime"]], msg)
[16:20:44.818]                       ex$message <- msg
[16:20:44.818]                       stop(ex)
[16:20:44.818]                     })
[16:20:44.818]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:44.818]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:44.818]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:44.818]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.818]                       fi <- file.info(pathname)
[16:20:44.818]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:44.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.818]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:44.818]                         fi[["size"]], fi[["mtime"]])
[16:20:44.818]                       stop(msg)
[16:20:44.818]                     }
[16:20:44.818]                     invisible(pathname)
[16:20:44.818]                   }
[16:20:44.818]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:44.818]                     rootPath = tempdir()) 
[16:20:44.818]                   {
[16:20:44.818]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:44.818]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:44.818]                       tmpdir = path, fileext = ".rds")
[16:20:44.818]                     save_rds(obj, file)
[16:20:44.818]                   }
[16:20:44.818]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:44.818]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.818]                   {
[16:20:44.818]                     inherits <- base::inherits
[16:20:44.818]                     invokeRestart <- base::invokeRestart
[16:20:44.818]                     is.null <- base::is.null
[16:20:44.818]                     muffled <- FALSE
[16:20:44.818]                     if (inherits(cond, "message")) {
[16:20:44.818]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.818]                       if (muffled) 
[16:20:44.818]                         invokeRestart("muffleMessage")
[16:20:44.818]                     }
[16:20:44.818]                     else if (inherits(cond, "warning")) {
[16:20:44.818]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.818]                       if (muffled) 
[16:20:44.818]                         invokeRestart("muffleWarning")
[16:20:44.818]                     }
[16:20:44.818]                     else if (inherits(cond, "condition")) {
[16:20:44.818]                       if (!is.null(pattern)) {
[16:20:44.818]                         computeRestarts <- base::computeRestarts
[16:20:44.818]                         grepl <- base::grepl
[16:20:44.818]                         restarts <- computeRestarts(cond)
[16:20:44.818]                         for (restart in restarts) {
[16:20:44.818]                           name <- restart$name
[16:20:44.818]                           if (is.null(name)) 
[16:20:44.818]                             next
[16:20:44.818]                           if (!grepl(pattern, name)) 
[16:20:44.818]                             next
[16:20:44.818]                           invokeRestart(restart)
[16:20:44.818]                           muffled <- TRUE
[16:20:44.818]                           break
[16:20:44.818]                         }
[16:20:44.818]                       }
[16:20:44.818]                     }
[16:20:44.818]                     invisible(muffled)
[16:20:44.818]                   }
[16:20:44.818]                   muffleCondition(cond)
[16:20:44.818]                 })
[16:20:44.818]             }))
[16:20:44.818]             future::FutureResult(value = ...future.value$value, 
[16:20:44.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.818]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.818]                     ...future.globalenv.names))
[16:20:44.818]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.818]         }, condition = base::local({
[16:20:44.818]             c <- base::c
[16:20:44.818]             inherits <- base::inherits
[16:20:44.818]             invokeRestart <- base::invokeRestart
[16:20:44.818]             length <- base::length
[16:20:44.818]             list <- base::list
[16:20:44.818]             seq.int <- base::seq.int
[16:20:44.818]             signalCondition <- base::signalCondition
[16:20:44.818]             sys.calls <- base::sys.calls
[16:20:44.818]             `[[` <- base::`[[`
[16:20:44.818]             `+` <- base::`+`
[16:20:44.818]             `<<-` <- base::`<<-`
[16:20:44.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.818]                   3L)]
[16:20:44.818]             }
[16:20:44.818]             function(cond) {
[16:20:44.818]                 is_error <- inherits(cond, "error")
[16:20:44.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.818]                   NULL)
[16:20:44.818]                 if (is_error) {
[16:20:44.818]                   sessionInformation <- function() {
[16:20:44.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.818]                       search = base::search(), system = base::Sys.info())
[16:20:44.818]                   }
[16:20:44.818]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.818]                     cond$call), session = sessionInformation(), 
[16:20:44.818]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.818]                   signalCondition(cond)
[16:20:44.818]                 }
[16:20:44.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.818]                 "immediateCondition"))) {
[16:20:44.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.818]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.818]                   if (TRUE && !signal) {
[16:20:44.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.818]                     {
[16:20:44.818]                       inherits <- base::inherits
[16:20:44.818]                       invokeRestart <- base::invokeRestart
[16:20:44.818]                       is.null <- base::is.null
[16:20:44.818]                       muffled <- FALSE
[16:20:44.818]                       if (inherits(cond, "message")) {
[16:20:44.818]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.818]                         if (muffled) 
[16:20:44.818]                           invokeRestart("muffleMessage")
[16:20:44.818]                       }
[16:20:44.818]                       else if (inherits(cond, "warning")) {
[16:20:44.818]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.818]                         if (muffled) 
[16:20:44.818]                           invokeRestart("muffleWarning")
[16:20:44.818]                       }
[16:20:44.818]                       else if (inherits(cond, "condition")) {
[16:20:44.818]                         if (!is.null(pattern)) {
[16:20:44.818]                           computeRestarts <- base::computeRestarts
[16:20:44.818]                           grepl <- base::grepl
[16:20:44.818]                           restarts <- computeRestarts(cond)
[16:20:44.818]                           for (restart in restarts) {
[16:20:44.818]                             name <- restart$name
[16:20:44.818]                             if (is.null(name)) 
[16:20:44.818]                               next
[16:20:44.818]                             if (!grepl(pattern, name)) 
[16:20:44.818]                               next
[16:20:44.818]                             invokeRestart(restart)
[16:20:44.818]                             muffled <- TRUE
[16:20:44.818]                             break
[16:20:44.818]                           }
[16:20:44.818]                         }
[16:20:44.818]                       }
[16:20:44.818]                       invisible(muffled)
[16:20:44.818]                     }
[16:20:44.818]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.818]                   }
[16:20:44.818]                 }
[16:20:44.818]                 else {
[16:20:44.818]                   if (TRUE) {
[16:20:44.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.818]                     {
[16:20:44.818]                       inherits <- base::inherits
[16:20:44.818]                       invokeRestart <- base::invokeRestart
[16:20:44.818]                       is.null <- base::is.null
[16:20:44.818]                       muffled <- FALSE
[16:20:44.818]                       if (inherits(cond, "message")) {
[16:20:44.818]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.818]                         if (muffled) 
[16:20:44.818]                           invokeRestart("muffleMessage")
[16:20:44.818]                       }
[16:20:44.818]                       else if (inherits(cond, "warning")) {
[16:20:44.818]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.818]                         if (muffled) 
[16:20:44.818]                           invokeRestart("muffleWarning")
[16:20:44.818]                       }
[16:20:44.818]                       else if (inherits(cond, "condition")) {
[16:20:44.818]                         if (!is.null(pattern)) {
[16:20:44.818]                           computeRestarts <- base::computeRestarts
[16:20:44.818]                           grepl <- base::grepl
[16:20:44.818]                           restarts <- computeRestarts(cond)
[16:20:44.818]                           for (restart in restarts) {
[16:20:44.818]                             name <- restart$name
[16:20:44.818]                             if (is.null(name)) 
[16:20:44.818]                               next
[16:20:44.818]                             if (!grepl(pattern, name)) 
[16:20:44.818]                               next
[16:20:44.818]                             invokeRestart(restart)
[16:20:44.818]                             muffled <- TRUE
[16:20:44.818]                             break
[16:20:44.818]                           }
[16:20:44.818]                         }
[16:20:44.818]                       }
[16:20:44.818]                       invisible(muffled)
[16:20:44.818]                     }
[16:20:44.818]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.818]                   }
[16:20:44.818]                 }
[16:20:44.818]             }
[16:20:44.818]         }))
[16:20:44.818]     }, error = function(ex) {
[16:20:44.818]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.818]                 ...future.rng), started = ...future.startTime, 
[16:20:44.818]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.818]             version = "1.8"), class = "FutureResult")
[16:20:44.818]     }, finally = {
[16:20:44.818]         if (!identical(...future.workdir, getwd())) 
[16:20:44.818]             setwd(...future.workdir)
[16:20:44.818]         {
[16:20:44.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.818]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.818]             }
[16:20:44.818]             base::options(...future.oldOptions)
[16:20:44.818]             if (.Platform$OS.type == "windows") {
[16:20:44.818]                 old_names <- names(...future.oldEnvVars)
[16:20:44.818]                 envs <- base::Sys.getenv()
[16:20:44.818]                 names <- names(envs)
[16:20:44.818]                 common <- intersect(names, old_names)
[16:20:44.818]                 added <- setdiff(names, old_names)
[16:20:44.818]                 removed <- setdiff(old_names, names)
[16:20:44.818]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.818]                   envs[common]]
[16:20:44.818]                 NAMES <- toupper(changed)
[16:20:44.818]                 args <- list()
[16:20:44.818]                 for (kk in seq_along(NAMES)) {
[16:20:44.818]                   name <- changed[[kk]]
[16:20:44.818]                   NAME <- NAMES[[kk]]
[16:20:44.818]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.818]                     next
[16:20:44.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.818]                 }
[16:20:44.818]                 NAMES <- toupper(added)
[16:20:44.818]                 for (kk in seq_along(NAMES)) {
[16:20:44.818]                   name <- added[[kk]]
[16:20:44.818]                   NAME <- NAMES[[kk]]
[16:20:44.818]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.818]                     next
[16:20:44.818]                   args[[name]] <- ""
[16:20:44.818]                 }
[16:20:44.818]                 NAMES <- toupper(removed)
[16:20:44.818]                 for (kk in seq_along(NAMES)) {
[16:20:44.818]                   name <- removed[[kk]]
[16:20:44.818]                   NAME <- NAMES[[kk]]
[16:20:44.818]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.818]                     next
[16:20:44.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.818]                 }
[16:20:44.818]                 if (length(args) > 0) 
[16:20:44.818]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.818]             }
[16:20:44.818]             else {
[16:20:44.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.818]             }
[16:20:44.818]             {
[16:20:44.818]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.818]                   0L) {
[16:20:44.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.818]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.818]                   base::options(opts)
[16:20:44.818]                 }
[16:20:44.818]                 {
[16:20:44.818]                   {
[16:20:44.818]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.818]                     NULL
[16:20:44.818]                   }
[16:20:44.818]                   options(future.plan = NULL)
[16:20:44.818]                   if (is.na(NA_character_)) 
[16:20:44.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.818]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.818]                     .init = FALSE)
[16:20:44.818]                 }
[16:20:44.818]             }
[16:20:44.818]         }
[16:20:44.818]     })
[16:20:44.818]     if (TRUE) {
[16:20:44.818]         base::sink(type = "output", split = FALSE)
[16:20:44.818]         if (TRUE) {
[16:20:44.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.818]         }
[16:20:44.818]         else {
[16:20:44.818]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.818]         }
[16:20:44.818]         base::close(...future.stdout)
[16:20:44.818]         ...future.stdout <- NULL
[16:20:44.818]     }
[16:20:44.818]     ...future.result$conditions <- ...future.conditions
[16:20:44.818]     ...future.result$finished <- base::Sys.time()
[16:20:44.818]     ...future.result
[16:20:44.818] }
[16:20:44.821] requestCore(): workers = 2
[16:20:44.823] MulticoreFuture started
[16:20:44.823] - Launch lazy future ... done
[16:20:44.824] run() for ‘MulticoreFuture’ ... done
[16:20:44.824] getGlobalsAndPackages() ...
[16:20:44.824] Searching for globals...
[16:20:44.824] plan(): Setting new future strategy stack:
[16:20:44.825] 
[16:20:44.825] Searching for globals ... DONE
[16:20:44.825] List of future strategies:
[16:20:44.825] 1. sequential:
[16:20:44.825]    - args: function (..., envir = parent.frame())
[16:20:44.825]    - tweaked: FALSE
[16:20:44.825]    - call: NULL
[16:20:44.825] - globals: [0] <none>
[16:20:44.825] plan(): nbrOfWorkers() = 1
[16:20:44.825] getGlobalsAndPackages() ... DONE
[16:20:44.826] run() for ‘Future’ ...
[16:20:44.826] - state: ‘created’
[16:20:44.826] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.827] plan(): Setting new future strategy stack:
[16:20:44.827] List of future strategies:
[16:20:44.827] 1. multicore:
[16:20:44.827]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.827]    - tweaked: FALSE
[16:20:44.827]    - call: plan(strategy)
[16:20:44.832] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.832] plan(): nbrOfWorkers() = 2
[16:20:44.832] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:44.832]   - Field: ‘label’
[16:20:44.832]   - Field: ‘local’
[16:20:44.832]   - Field: ‘owner’
[16:20:44.832]   - Field: ‘envir’
[16:20:44.833]   - Field: ‘workers’
[16:20:44.833]   - Field: ‘packages’
[16:20:44.833]   - Field: ‘gc’
[16:20:44.833]   - Field: ‘job’
[16:20:44.833]   - Field: ‘conditions’
[16:20:44.833]   - Field: ‘expr’
[16:20:44.833]   - Field: ‘uuid’
[16:20:44.834]   - Field: ‘seed’
[16:20:44.834]   - Field: ‘version’
[16:20:44.834]   - Field: ‘result’
[16:20:44.834]   - Field: ‘asynchronous’
[16:20:44.834]   - Field: ‘calls’
[16:20:44.834]   - Field: ‘globals’
[16:20:44.834]   - Field: ‘stdout’
[16:20:44.835]   - Field: ‘earlySignal’
[16:20:44.835]   - Field: ‘lazy’
[16:20:44.835]   - Field: ‘state’
[16:20:44.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:44.835] - Launch lazy future ...
[16:20:44.836] Packages needed by the future expression (n = 0): <none>
[16:20:44.836] Packages needed by future strategies (n = 0): <none>
[16:20:44.836] {
[16:20:44.836]     {
[16:20:44.836]         {
[16:20:44.836]             ...future.startTime <- base::Sys.time()
[16:20:44.836]             {
[16:20:44.836]                 {
[16:20:44.836]                   {
[16:20:44.836]                     {
[16:20:44.836]                       base::local({
[16:20:44.836]                         has_future <- base::requireNamespace("future", 
[16:20:44.836]                           quietly = TRUE)
[16:20:44.836]                         if (has_future) {
[16:20:44.836]                           ns <- base::getNamespace("future")
[16:20:44.836]                           version <- ns[[".package"]][["version"]]
[16:20:44.836]                           if (is.null(version)) 
[16:20:44.836]                             version <- utils::packageVersion("future")
[16:20:44.836]                         }
[16:20:44.836]                         else {
[16:20:44.836]                           version <- NULL
[16:20:44.836]                         }
[16:20:44.836]                         if (!has_future || version < "1.8.0") {
[16:20:44.836]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.836]                             "", base::R.version$version.string), 
[16:20:44.836]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.836]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.836]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.836]                               "release", "version")], collapse = " "), 
[16:20:44.836]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.836]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.836]                             info)
[16:20:44.836]                           info <- base::paste(info, collapse = "; ")
[16:20:44.836]                           if (!has_future) {
[16:20:44.836]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.836]                               info)
[16:20:44.836]                           }
[16:20:44.836]                           else {
[16:20:44.836]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.836]                               info, version)
[16:20:44.836]                           }
[16:20:44.836]                           base::stop(msg)
[16:20:44.836]                         }
[16:20:44.836]                       })
[16:20:44.836]                     }
[16:20:44.836]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.836]                     base::options(mc.cores = 1L)
[16:20:44.836]                   }
[16:20:44.836]                   ...future.strategy.old <- future::plan("list")
[16:20:44.836]                   options(future.plan = NULL)
[16:20:44.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.836]                 }
[16:20:44.836]                 ...future.workdir <- getwd()
[16:20:44.836]             }
[16:20:44.836]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.836]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.836]         }
[16:20:44.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.836]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.836]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.836]             base::names(...future.oldOptions))
[16:20:44.836]     }
[16:20:44.836]     if (FALSE) {
[16:20:44.836]     }
[16:20:44.836]     else {
[16:20:44.836]         if (TRUE) {
[16:20:44.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.836]                 open = "w")
[16:20:44.836]         }
[16:20:44.836]         else {
[16:20:44.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.836]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.836]         }
[16:20:44.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.836]             base::sink(type = "output", split = FALSE)
[16:20:44.836]             base::close(...future.stdout)
[16:20:44.836]         }, add = TRUE)
[16:20:44.836]     }
[16:20:44.836]     ...future.frame <- base::sys.nframe()
[16:20:44.836]     ...future.conditions <- base::list()
[16:20:44.836]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.836]     if (FALSE) {
[16:20:44.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.836]     }
[16:20:44.836]     ...future.result <- base::tryCatch({
[16:20:44.836]         base::withCallingHandlers({
[16:20:44.836]             ...future.value <- base::withVisible(base::local({
[16:20:44.836]                 withCallingHandlers({
[16:20:44.836]                   NULL
[16:20:44.836]                 }, immediateCondition = function(cond) {
[16:20:44.836]                   save_rds <- function (object, pathname, ...) 
[16:20:44.836]                   {
[16:20:44.836]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:44.836]                     if (file_test("-f", pathname_tmp)) {
[16:20:44.836]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.836]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:44.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.836]                         fi_tmp[["mtime"]])
[16:20:44.836]                     }
[16:20:44.836]                     tryCatch({
[16:20:44.836]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:44.836]                     }, error = function(ex) {
[16:20:44.836]                       msg <- conditionMessage(ex)
[16:20:44.836]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.836]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:44.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.836]                         fi_tmp[["mtime"]], msg)
[16:20:44.836]                       ex$message <- msg
[16:20:44.836]                       stop(ex)
[16:20:44.836]                     })
[16:20:44.836]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:44.836]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:44.836]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:44.836]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.836]                       fi <- file.info(pathname)
[16:20:44.836]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:44.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.836]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:44.836]                         fi[["size"]], fi[["mtime"]])
[16:20:44.836]                       stop(msg)
[16:20:44.836]                     }
[16:20:44.836]                     invisible(pathname)
[16:20:44.836]                   }
[16:20:44.836]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:44.836]                     rootPath = tempdir()) 
[16:20:44.836]                   {
[16:20:44.836]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:44.836]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:44.836]                       tmpdir = path, fileext = ".rds")
[16:20:44.836]                     save_rds(obj, file)
[16:20:44.836]                   }
[16:20:44.836]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:44.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.836]                   {
[16:20:44.836]                     inherits <- base::inherits
[16:20:44.836]                     invokeRestart <- base::invokeRestart
[16:20:44.836]                     is.null <- base::is.null
[16:20:44.836]                     muffled <- FALSE
[16:20:44.836]                     if (inherits(cond, "message")) {
[16:20:44.836]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.836]                       if (muffled) 
[16:20:44.836]                         invokeRestart("muffleMessage")
[16:20:44.836]                     }
[16:20:44.836]                     else if (inherits(cond, "warning")) {
[16:20:44.836]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.836]                       if (muffled) 
[16:20:44.836]                         invokeRestart("muffleWarning")
[16:20:44.836]                     }
[16:20:44.836]                     else if (inherits(cond, "condition")) {
[16:20:44.836]                       if (!is.null(pattern)) {
[16:20:44.836]                         computeRestarts <- base::computeRestarts
[16:20:44.836]                         grepl <- base::grepl
[16:20:44.836]                         restarts <- computeRestarts(cond)
[16:20:44.836]                         for (restart in restarts) {
[16:20:44.836]                           name <- restart$name
[16:20:44.836]                           if (is.null(name)) 
[16:20:44.836]                             next
[16:20:44.836]                           if (!grepl(pattern, name)) 
[16:20:44.836]                             next
[16:20:44.836]                           invokeRestart(restart)
[16:20:44.836]                           muffled <- TRUE
[16:20:44.836]                           break
[16:20:44.836]                         }
[16:20:44.836]                       }
[16:20:44.836]                     }
[16:20:44.836]                     invisible(muffled)
[16:20:44.836]                   }
[16:20:44.836]                   muffleCondition(cond)
[16:20:44.836]                 })
[16:20:44.836]             }))
[16:20:44.836]             future::FutureResult(value = ...future.value$value, 
[16:20:44.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.836]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.836]                     ...future.globalenv.names))
[16:20:44.836]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.836]         }, condition = base::local({
[16:20:44.836]             c <- base::c
[16:20:44.836]             inherits <- base::inherits
[16:20:44.836]             invokeRestart <- base::invokeRestart
[16:20:44.836]             length <- base::length
[16:20:44.836]             list <- base::list
[16:20:44.836]             seq.int <- base::seq.int
[16:20:44.836]             signalCondition <- base::signalCondition
[16:20:44.836]             sys.calls <- base::sys.calls
[16:20:44.836]             `[[` <- base::`[[`
[16:20:44.836]             `+` <- base::`+`
[16:20:44.836]             `<<-` <- base::`<<-`
[16:20:44.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.836]                   3L)]
[16:20:44.836]             }
[16:20:44.836]             function(cond) {
[16:20:44.836]                 is_error <- inherits(cond, "error")
[16:20:44.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.836]                   NULL)
[16:20:44.836]                 if (is_error) {
[16:20:44.836]                   sessionInformation <- function() {
[16:20:44.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.836]                       search = base::search(), system = base::Sys.info())
[16:20:44.836]                   }
[16:20:44.836]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.836]                     cond$call), session = sessionInformation(), 
[16:20:44.836]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.836]                   signalCondition(cond)
[16:20:44.836]                 }
[16:20:44.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.836]                 "immediateCondition"))) {
[16:20:44.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.836]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.836]                   if (TRUE && !signal) {
[16:20:44.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.836]                     {
[16:20:44.836]                       inherits <- base::inherits
[16:20:44.836]                       invokeRestart <- base::invokeRestart
[16:20:44.836]                       is.null <- base::is.null
[16:20:44.836]                       muffled <- FALSE
[16:20:44.836]                       if (inherits(cond, "message")) {
[16:20:44.836]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.836]                         if (muffled) 
[16:20:44.836]                           invokeRestart("muffleMessage")
[16:20:44.836]                       }
[16:20:44.836]                       else if (inherits(cond, "warning")) {
[16:20:44.836]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.836]                         if (muffled) 
[16:20:44.836]                           invokeRestart("muffleWarning")
[16:20:44.836]                       }
[16:20:44.836]                       else if (inherits(cond, "condition")) {
[16:20:44.836]                         if (!is.null(pattern)) {
[16:20:44.836]                           computeRestarts <- base::computeRestarts
[16:20:44.836]                           grepl <- base::grepl
[16:20:44.836]                           restarts <- computeRestarts(cond)
[16:20:44.836]                           for (restart in restarts) {
[16:20:44.836]                             name <- restart$name
[16:20:44.836]                             if (is.null(name)) 
[16:20:44.836]                               next
[16:20:44.836]                             if (!grepl(pattern, name)) 
[16:20:44.836]                               next
[16:20:44.836]                             invokeRestart(restart)
[16:20:44.836]                             muffled <- TRUE
[16:20:44.836]                             break
[16:20:44.836]                           }
[16:20:44.836]                         }
[16:20:44.836]                       }
[16:20:44.836]                       invisible(muffled)
[16:20:44.836]                     }
[16:20:44.836]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.836]                   }
[16:20:44.836]                 }
[16:20:44.836]                 else {
[16:20:44.836]                   if (TRUE) {
[16:20:44.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.836]                     {
[16:20:44.836]                       inherits <- base::inherits
[16:20:44.836]                       invokeRestart <- base::invokeRestart
[16:20:44.836]                       is.null <- base::is.null
[16:20:44.836]                       muffled <- FALSE
[16:20:44.836]                       if (inherits(cond, "message")) {
[16:20:44.836]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.836]                         if (muffled) 
[16:20:44.836]                           invokeRestart("muffleMessage")
[16:20:44.836]                       }
[16:20:44.836]                       else if (inherits(cond, "warning")) {
[16:20:44.836]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.836]                         if (muffled) 
[16:20:44.836]                           invokeRestart("muffleWarning")
[16:20:44.836]                       }
[16:20:44.836]                       else if (inherits(cond, "condition")) {
[16:20:44.836]                         if (!is.null(pattern)) {
[16:20:44.836]                           computeRestarts <- base::computeRestarts
[16:20:44.836]                           grepl <- base::grepl
[16:20:44.836]                           restarts <- computeRestarts(cond)
[16:20:44.836]                           for (restart in restarts) {
[16:20:44.836]                             name <- restart$name
[16:20:44.836]                             if (is.null(name)) 
[16:20:44.836]                               next
[16:20:44.836]                             if (!grepl(pattern, name)) 
[16:20:44.836]                               next
[16:20:44.836]                             invokeRestart(restart)
[16:20:44.836]                             muffled <- TRUE
[16:20:44.836]                             break
[16:20:44.836]                           }
[16:20:44.836]                         }
[16:20:44.836]                       }
[16:20:44.836]                       invisible(muffled)
[16:20:44.836]                     }
[16:20:44.836]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.836]                   }
[16:20:44.836]                 }
[16:20:44.836]             }
[16:20:44.836]         }))
[16:20:44.836]     }, error = function(ex) {
[16:20:44.836]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.836]                 ...future.rng), started = ...future.startTime, 
[16:20:44.836]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.836]             version = "1.8"), class = "FutureResult")
[16:20:44.836]     }, finally = {
[16:20:44.836]         if (!identical(...future.workdir, getwd())) 
[16:20:44.836]             setwd(...future.workdir)
[16:20:44.836]         {
[16:20:44.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.836]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.836]             }
[16:20:44.836]             base::options(...future.oldOptions)
[16:20:44.836]             if (.Platform$OS.type == "windows") {
[16:20:44.836]                 old_names <- names(...future.oldEnvVars)
[16:20:44.836]                 envs <- base::Sys.getenv()
[16:20:44.836]                 names <- names(envs)
[16:20:44.836]                 common <- intersect(names, old_names)
[16:20:44.836]                 added <- setdiff(names, old_names)
[16:20:44.836]                 removed <- setdiff(old_names, names)
[16:20:44.836]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.836]                   envs[common]]
[16:20:44.836]                 NAMES <- toupper(changed)
[16:20:44.836]                 args <- list()
[16:20:44.836]                 for (kk in seq_along(NAMES)) {
[16:20:44.836]                   name <- changed[[kk]]
[16:20:44.836]                   NAME <- NAMES[[kk]]
[16:20:44.836]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.836]                     next
[16:20:44.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.836]                 }
[16:20:44.836]                 NAMES <- toupper(added)
[16:20:44.836]                 for (kk in seq_along(NAMES)) {
[16:20:44.836]                   name <- added[[kk]]
[16:20:44.836]                   NAME <- NAMES[[kk]]
[16:20:44.836]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.836]                     next
[16:20:44.836]                   args[[name]] <- ""
[16:20:44.836]                 }
[16:20:44.836]                 NAMES <- toupper(removed)
[16:20:44.836]                 for (kk in seq_along(NAMES)) {
[16:20:44.836]                   name <- removed[[kk]]
[16:20:44.836]                   NAME <- NAMES[[kk]]
[16:20:44.836]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.836]                     next
[16:20:44.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.836]                 }
[16:20:44.836]                 if (length(args) > 0) 
[16:20:44.836]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.836]             }
[16:20:44.836]             else {
[16:20:44.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.836]             }
[16:20:44.836]             {
[16:20:44.836]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.836]                   0L) {
[16:20:44.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.836]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.836]                   base::options(opts)
[16:20:44.836]                 }
[16:20:44.836]                 {
[16:20:44.836]                   {
[16:20:44.836]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.836]                     NULL
[16:20:44.836]                   }
[16:20:44.836]                   options(future.plan = NULL)
[16:20:44.836]                   if (is.na(NA_character_)) 
[16:20:44.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.836]                     .init = FALSE)
[16:20:44.836]                 }
[16:20:44.836]             }
[16:20:44.836]         }
[16:20:44.836]     })
[16:20:44.836]     if (TRUE) {
[16:20:44.836]         base::sink(type = "output", split = FALSE)
[16:20:44.836]         if (TRUE) {
[16:20:44.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.836]         }
[16:20:44.836]         else {
[16:20:44.836]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.836]         }
[16:20:44.836]         base::close(...future.stdout)
[16:20:44.836]         ...future.stdout <- NULL
[16:20:44.836]     }
[16:20:44.836]     ...future.result$conditions <- ...future.conditions
[16:20:44.836]     ...future.result$finished <- base::Sys.time()
[16:20:44.836]     ...future.result
[16:20:44.836] }
[16:20:44.840] requestCore(): workers = 2
[16:20:44.843] MulticoreFuture started
[16:20:44.843] - Launch lazy future ... done
[16:20:44.843] run() for ‘MulticoreFuture’ ... done
[16:20:44.844] plan(): Setting new future strategy stack:
[16:20:44.844] getGlobalsAndPackages() ...
[16:20:44.845] Searching for globals...
[16:20:44.844] List of future strategies:
[16:20:44.844] 1. sequential:
[16:20:44.844]    - args: function (..., envir = parent.frame())
[16:20:44.844]    - tweaked: FALSE
[16:20:44.844]    - call: NULL
[16:20:44.845] plan(): nbrOfWorkers() = 1
[16:20:44.846] - globals found: [1] ‘{’
[16:20:44.846] Searching for globals ... DONE
[16:20:44.846] Resolving globals: FALSE
[16:20:44.847] 
[16:20:44.847] 
[16:20:44.847] getGlobalsAndPackages() ... DONE
[16:20:44.847] plan(): Setting new future strategy stack:
[16:20:44.848] run() for ‘Future’ ...
[16:20:44.848] - state: ‘created’
[16:20:44.847] List of future strategies:
[16:20:44.847] 1. multicore:
[16:20:44.847]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.847]    - tweaked: FALSE
[16:20:44.847]    - call: plan(strategy)
[16:20:44.848] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.853] plan(): nbrOfWorkers() = 2
[16:20:44.853] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.853] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:44.853]   - Field: ‘label’
[16:20:44.853]   - Field: ‘local’
[16:20:44.854]   - Field: ‘owner’
[16:20:44.854]   - Field: ‘envir’
[16:20:44.854]   - Field: ‘workers’
[16:20:44.854]   - Field: ‘packages’
[16:20:44.854]   - Field: ‘gc’
[16:20:44.854]   - Field: ‘job’
[16:20:44.854]   - Field: ‘conditions’
[16:20:44.855]   - Field: ‘expr’
[16:20:44.855]   - Field: ‘uuid’
[16:20:44.855]   - Field: ‘seed’
[16:20:44.855]   - Field: ‘version’
[16:20:44.855]   - Field: ‘result’
[16:20:44.855]   - Field: ‘asynchronous’
[16:20:44.855]   - Field: ‘calls’
[16:20:44.855]   - Field: ‘globals’
[16:20:44.856]   - Field: ‘stdout’
[16:20:44.856]   - Field: ‘earlySignal’
[16:20:44.856]   - Field: ‘lazy’
[16:20:44.856]   - Field: ‘state’
[16:20:44.856] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:44.856] - Launch lazy future ...
[16:20:44.857] Packages needed by the future expression (n = 0): <none>
[16:20:44.857] Packages needed by future strategies (n = 0): <none>
[16:20:44.858] {
[16:20:44.858]     {
[16:20:44.858]         {
[16:20:44.858]             ...future.startTime <- base::Sys.time()
[16:20:44.858]             {
[16:20:44.858]                 {
[16:20:44.858]                   {
[16:20:44.858]                     {
[16:20:44.858]                       base::local({
[16:20:44.858]                         has_future <- base::requireNamespace("future", 
[16:20:44.858]                           quietly = TRUE)
[16:20:44.858]                         if (has_future) {
[16:20:44.858]                           ns <- base::getNamespace("future")
[16:20:44.858]                           version <- ns[[".package"]][["version"]]
[16:20:44.858]                           if (is.null(version)) 
[16:20:44.858]                             version <- utils::packageVersion("future")
[16:20:44.858]                         }
[16:20:44.858]                         else {
[16:20:44.858]                           version <- NULL
[16:20:44.858]                         }
[16:20:44.858]                         if (!has_future || version < "1.8.0") {
[16:20:44.858]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.858]                             "", base::R.version$version.string), 
[16:20:44.858]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.858]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.858]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.858]                               "release", "version")], collapse = " "), 
[16:20:44.858]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.858]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.858]                             info)
[16:20:44.858]                           info <- base::paste(info, collapse = "; ")
[16:20:44.858]                           if (!has_future) {
[16:20:44.858]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.858]                               info)
[16:20:44.858]                           }
[16:20:44.858]                           else {
[16:20:44.858]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.858]                               info, version)
[16:20:44.858]                           }
[16:20:44.858]                           base::stop(msg)
[16:20:44.858]                         }
[16:20:44.858]                       })
[16:20:44.858]                     }
[16:20:44.858]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.858]                     base::options(mc.cores = 1L)
[16:20:44.858]                   }
[16:20:44.858]                   ...future.strategy.old <- future::plan("list")
[16:20:44.858]                   options(future.plan = NULL)
[16:20:44.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.858]                 }
[16:20:44.858]                 ...future.workdir <- getwd()
[16:20:44.858]             }
[16:20:44.858]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.858]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.858]         }
[16:20:44.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.858]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.858]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.858]             base::names(...future.oldOptions))
[16:20:44.858]     }
[16:20:44.858]     if (FALSE) {
[16:20:44.858]     }
[16:20:44.858]     else {
[16:20:44.858]         if (TRUE) {
[16:20:44.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.858]                 open = "w")
[16:20:44.858]         }
[16:20:44.858]         else {
[16:20:44.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.858]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.858]         }
[16:20:44.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.858]             base::sink(type = "output", split = FALSE)
[16:20:44.858]             base::close(...future.stdout)
[16:20:44.858]         }, add = TRUE)
[16:20:44.858]     }
[16:20:44.858]     ...future.frame <- base::sys.nframe()
[16:20:44.858]     ...future.conditions <- base::list()
[16:20:44.858]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.858]     if (FALSE) {
[16:20:44.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.858]     }
[16:20:44.858]     ...future.result <- base::tryCatch({
[16:20:44.858]         base::withCallingHandlers({
[16:20:44.858]             ...future.value <- base::withVisible(base::local({
[16:20:44.858]                 withCallingHandlers({
[16:20:44.858]                   {
[16:20:44.858]                     4
[16:20:44.858]                   }
[16:20:44.858]                 }, immediateCondition = function(cond) {
[16:20:44.858]                   save_rds <- function (object, pathname, ...) 
[16:20:44.858]                   {
[16:20:44.858]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:44.858]                     if (file_test("-f", pathname_tmp)) {
[16:20:44.858]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.858]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:44.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.858]                         fi_tmp[["mtime"]])
[16:20:44.858]                     }
[16:20:44.858]                     tryCatch({
[16:20:44.858]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:44.858]                     }, error = function(ex) {
[16:20:44.858]                       msg <- conditionMessage(ex)
[16:20:44.858]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.858]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:44.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.858]                         fi_tmp[["mtime"]], msg)
[16:20:44.858]                       ex$message <- msg
[16:20:44.858]                       stop(ex)
[16:20:44.858]                     })
[16:20:44.858]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:44.858]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:44.858]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:44.858]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.858]                       fi <- file.info(pathname)
[16:20:44.858]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:44.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.858]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:44.858]                         fi[["size"]], fi[["mtime"]])
[16:20:44.858]                       stop(msg)
[16:20:44.858]                     }
[16:20:44.858]                     invisible(pathname)
[16:20:44.858]                   }
[16:20:44.858]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:44.858]                     rootPath = tempdir()) 
[16:20:44.858]                   {
[16:20:44.858]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:44.858]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:44.858]                       tmpdir = path, fileext = ".rds")
[16:20:44.858]                     save_rds(obj, file)
[16:20:44.858]                   }
[16:20:44.858]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:44.858]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.858]                   {
[16:20:44.858]                     inherits <- base::inherits
[16:20:44.858]                     invokeRestart <- base::invokeRestart
[16:20:44.858]                     is.null <- base::is.null
[16:20:44.858]                     muffled <- FALSE
[16:20:44.858]                     if (inherits(cond, "message")) {
[16:20:44.858]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.858]                       if (muffled) 
[16:20:44.858]                         invokeRestart("muffleMessage")
[16:20:44.858]                     }
[16:20:44.858]                     else if (inherits(cond, "warning")) {
[16:20:44.858]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.858]                       if (muffled) 
[16:20:44.858]                         invokeRestart("muffleWarning")
[16:20:44.858]                     }
[16:20:44.858]                     else if (inherits(cond, "condition")) {
[16:20:44.858]                       if (!is.null(pattern)) {
[16:20:44.858]                         computeRestarts <- base::computeRestarts
[16:20:44.858]                         grepl <- base::grepl
[16:20:44.858]                         restarts <- computeRestarts(cond)
[16:20:44.858]                         for (restart in restarts) {
[16:20:44.858]                           name <- restart$name
[16:20:44.858]                           if (is.null(name)) 
[16:20:44.858]                             next
[16:20:44.858]                           if (!grepl(pattern, name)) 
[16:20:44.858]                             next
[16:20:44.858]                           invokeRestart(restart)
[16:20:44.858]                           muffled <- TRUE
[16:20:44.858]                           break
[16:20:44.858]                         }
[16:20:44.858]                       }
[16:20:44.858]                     }
[16:20:44.858]                     invisible(muffled)
[16:20:44.858]                   }
[16:20:44.858]                   muffleCondition(cond)
[16:20:44.858]                 })
[16:20:44.858]             }))
[16:20:44.858]             future::FutureResult(value = ...future.value$value, 
[16:20:44.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.858]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.858]                     ...future.globalenv.names))
[16:20:44.858]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.858]         }, condition = base::local({
[16:20:44.858]             c <- base::c
[16:20:44.858]             inherits <- base::inherits
[16:20:44.858]             invokeRestart <- base::invokeRestart
[16:20:44.858]             length <- base::length
[16:20:44.858]             list <- base::list
[16:20:44.858]             seq.int <- base::seq.int
[16:20:44.858]             signalCondition <- base::signalCondition
[16:20:44.858]             sys.calls <- base::sys.calls
[16:20:44.858]             `[[` <- base::`[[`
[16:20:44.858]             `+` <- base::`+`
[16:20:44.858]             `<<-` <- base::`<<-`
[16:20:44.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.858]                   3L)]
[16:20:44.858]             }
[16:20:44.858]             function(cond) {
[16:20:44.858]                 is_error <- inherits(cond, "error")
[16:20:44.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.858]                   NULL)
[16:20:44.858]                 if (is_error) {
[16:20:44.858]                   sessionInformation <- function() {
[16:20:44.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.858]                       search = base::search(), system = base::Sys.info())
[16:20:44.858]                   }
[16:20:44.858]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.858]                     cond$call), session = sessionInformation(), 
[16:20:44.858]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.858]                   signalCondition(cond)
[16:20:44.858]                 }
[16:20:44.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.858]                 "immediateCondition"))) {
[16:20:44.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.858]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.858]                   if (TRUE && !signal) {
[16:20:44.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.858]                     {
[16:20:44.858]                       inherits <- base::inherits
[16:20:44.858]                       invokeRestart <- base::invokeRestart
[16:20:44.858]                       is.null <- base::is.null
[16:20:44.858]                       muffled <- FALSE
[16:20:44.858]                       if (inherits(cond, "message")) {
[16:20:44.858]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.858]                         if (muffled) 
[16:20:44.858]                           invokeRestart("muffleMessage")
[16:20:44.858]                       }
[16:20:44.858]                       else if (inherits(cond, "warning")) {
[16:20:44.858]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.858]                         if (muffled) 
[16:20:44.858]                           invokeRestart("muffleWarning")
[16:20:44.858]                       }
[16:20:44.858]                       else if (inherits(cond, "condition")) {
[16:20:44.858]                         if (!is.null(pattern)) {
[16:20:44.858]                           computeRestarts <- base::computeRestarts
[16:20:44.858]                           grepl <- base::grepl
[16:20:44.858]                           restarts <- computeRestarts(cond)
[16:20:44.858]                           for (restart in restarts) {
[16:20:44.858]                             name <- restart$name
[16:20:44.858]                             if (is.null(name)) 
[16:20:44.858]                               next
[16:20:44.858]                             if (!grepl(pattern, name)) 
[16:20:44.858]                               next
[16:20:44.858]                             invokeRestart(restart)
[16:20:44.858]                             muffled <- TRUE
[16:20:44.858]                             break
[16:20:44.858]                           }
[16:20:44.858]                         }
[16:20:44.858]                       }
[16:20:44.858]                       invisible(muffled)
[16:20:44.858]                     }
[16:20:44.858]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.858]                   }
[16:20:44.858]                 }
[16:20:44.858]                 else {
[16:20:44.858]                   if (TRUE) {
[16:20:44.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.858]                     {
[16:20:44.858]                       inherits <- base::inherits
[16:20:44.858]                       invokeRestart <- base::invokeRestart
[16:20:44.858]                       is.null <- base::is.null
[16:20:44.858]                       muffled <- FALSE
[16:20:44.858]                       if (inherits(cond, "message")) {
[16:20:44.858]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.858]                         if (muffled) 
[16:20:44.858]                           invokeRestart("muffleMessage")
[16:20:44.858]                       }
[16:20:44.858]                       else if (inherits(cond, "warning")) {
[16:20:44.858]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.858]                         if (muffled) 
[16:20:44.858]                           invokeRestart("muffleWarning")
[16:20:44.858]                       }
[16:20:44.858]                       else if (inherits(cond, "condition")) {
[16:20:44.858]                         if (!is.null(pattern)) {
[16:20:44.858]                           computeRestarts <- base::computeRestarts
[16:20:44.858]                           grepl <- base::grepl
[16:20:44.858]                           restarts <- computeRestarts(cond)
[16:20:44.858]                           for (restart in restarts) {
[16:20:44.858]                             name <- restart$name
[16:20:44.858]                             if (is.null(name)) 
[16:20:44.858]                               next
[16:20:44.858]                             if (!grepl(pattern, name)) 
[16:20:44.858]                               next
[16:20:44.858]                             invokeRestart(restart)
[16:20:44.858]                             muffled <- TRUE
[16:20:44.858]                             break
[16:20:44.858]                           }
[16:20:44.858]                         }
[16:20:44.858]                       }
[16:20:44.858]                       invisible(muffled)
[16:20:44.858]                     }
[16:20:44.858]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.858]                   }
[16:20:44.858]                 }
[16:20:44.858]             }
[16:20:44.858]         }))
[16:20:44.858]     }, error = function(ex) {
[16:20:44.858]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.858]                 ...future.rng), started = ...future.startTime, 
[16:20:44.858]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.858]             version = "1.8"), class = "FutureResult")
[16:20:44.858]     }, finally = {
[16:20:44.858]         if (!identical(...future.workdir, getwd())) 
[16:20:44.858]             setwd(...future.workdir)
[16:20:44.858]         {
[16:20:44.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.858]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.858]             }
[16:20:44.858]             base::options(...future.oldOptions)
[16:20:44.858]             if (.Platform$OS.type == "windows") {
[16:20:44.858]                 old_names <- names(...future.oldEnvVars)
[16:20:44.858]                 envs <- base::Sys.getenv()
[16:20:44.858]                 names <- names(envs)
[16:20:44.858]                 common <- intersect(names, old_names)
[16:20:44.858]                 added <- setdiff(names, old_names)
[16:20:44.858]                 removed <- setdiff(old_names, names)
[16:20:44.858]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.858]                   envs[common]]
[16:20:44.858]                 NAMES <- toupper(changed)
[16:20:44.858]                 args <- list()
[16:20:44.858]                 for (kk in seq_along(NAMES)) {
[16:20:44.858]                   name <- changed[[kk]]
[16:20:44.858]                   NAME <- NAMES[[kk]]
[16:20:44.858]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.858]                     next
[16:20:44.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.858]                 }
[16:20:44.858]                 NAMES <- toupper(added)
[16:20:44.858]                 for (kk in seq_along(NAMES)) {
[16:20:44.858]                   name <- added[[kk]]
[16:20:44.858]                   NAME <- NAMES[[kk]]
[16:20:44.858]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.858]                     next
[16:20:44.858]                   args[[name]] <- ""
[16:20:44.858]                 }
[16:20:44.858]                 NAMES <- toupper(removed)
[16:20:44.858]                 for (kk in seq_along(NAMES)) {
[16:20:44.858]                   name <- removed[[kk]]
[16:20:44.858]                   NAME <- NAMES[[kk]]
[16:20:44.858]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.858]                     next
[16:20:44.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.858]                 }
[16:20:44.858]                 if (length(args) > 0) 
[16:20:44.858]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.858]             }
[16:20:44.858]             else {
[16:20:44.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.858]             }
[16:20:44.858]             {
[16:20:44.858]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.858]                   0L) {
[16:20:44.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.858]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.858]                   base::options(opts)
[16:20:44.858]                 }
[16:20:44.858]                 {
[16:20:44.858]                   {
[16:20:44.858]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.858]                     NULL
[16:20:44.858]                   }
[16:20:44.858]                   options(future.plan = NULL)
[16:20:44.858]                   if (is.na(NA_character_)) 
[16:20:44.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.858]                     .init = FALSE)
[16:20:44.858]                 }
[16:20:44.858]             }
[16:20:44.858]         }
[16:20:44.858]     })
[16:20:44.858]     if (TRUE) {
[16:20:44.858]         base::sink(type = "output", split = FALSE)
[16:20:44.858]         if (TRUE) {
[16:20:44.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.858]         }
[16:20:44.858]         else {
[16:20:44.858]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.858]         }
[16:20:44.858]         base::close(...future.stdout)
[16:20:44.858]         ...future.stdout <- NULL
[16:20:44.858]     }
[16:20:44.858]     ...future.result$conditions <- ...future.conditions
[16:20:44.858]     ...future.result$finished <- base::Sys.time()
[16:20:44.858]     ...future.result
[16:20:44.858] }
[16:20:44.861] requestCore(): workers = 2
[16:20:44.862] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:44.872] result() for MulticoreFuture ...
[16:20:44.873] result() for MulticoreFuture ...
[16:20:44.873] result() for MulticoreFuture ... done
[16:20:44.874] result() for MulticoreFuture ... done
[16:20:44.874] result() for MulticoreFuture ...
[16:20:44.874] result() for MulticoreFuture ... done
[16:20:44.877] MulticoreFuture started
[16:20:44.877] - Launch lazy future ... done
[16:20:44.877] run() for ‘MulticoreFuture’ ... done
[16:20:44.878] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55ed0adbcad0> 
[16:20:44.878] List of future strategies:
[16:20:44.878] 1. sequential:
[16:20:44.878]    - args: function (..., envir = parent.frame())
[16:20:44.878]    - tweaked: FALSE
[16:20:44.878]    - call: NULL
[16:20:44.879] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55ed0d820938> 
 - attr(*, "dim.")=[16:20:44.882] plan(): Setting new future strategy stack:
 int [1:2] 1 6
 - attr(*, "dimnames.")=[16:20:44.882] List of future strategies:
[16:20:44.882] 1. multicore:
[16:20:44.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.882]    - tweaked: FALSE
[16:20:44.882]    - call: plan(strategy)
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:20:44.888] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:44.892] resolve() on list environment ...
[16:20:44.892]  recursive: 0
[16:20:44.893]  length: 6
[16:20:44.893]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:44.894] signalConditionsASAP(numeric, pos=1) ...
[16:20:44.894] - nx: 6
[16:20:44.894] - relay: TRUE
[16:20:44.894] - stdout: TRUE
[16:20:44.894] - signal: TRUE
[16:20:44.894] - resignal: FALSE
[16:20:44.894] - force: TRUE
[16:20:44.895] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.895] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.895]  - until=2
[16:20:44.895]  - relaying element #2
[16:20:44.895] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.895] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.895] signalConditionsASAP(NULL, pos=1) ... done
[16:20:44.896]  length: 5 (resolved future 1)
[16:20:44.896] Future #2
[16:20:44.896] result() for MulticoreFuture ...
[16:20:44.896] result() for MulticoreFuture ... done
[16:20:44.896] result() for MulticoreFuture ...
[16:20:44.896] result() for MulticoreFuture ... done
[16:20:44.896] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:44.897] - nx: 6
[16:20:44.897] - relay: TRUE
[16:20:44.897] - stdout: TRUE
[16:20:44.897] - signal: TRUE
[16:20:44.897] - resignal: FALSE
[16:20:44.897] - force: TRUE
[16:20:44.897] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.897] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:44.898]  - until=2
[16:20:44.898]  - relaying element #2
[16:20:44.898] result() for MulticoreFuture ...
[16:20:44.898] result() for MulticoreFuture ... done
[16:20:44.898] result() for MulticoreFuture ...
[16:20:44.898] result() for MulticoreFuture ... done
[16:20:44.898] result() for MulticoreFuture ...
[16:20:44.898] result() for MulticoreFuture ... done
[16:20:44.899] result() for MulticoreFuture ...
[16:20:44.899] result() for MulticoreFuture ... done
[16:20:44.899] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:44.899] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:44.899] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:44.899]  length: 4 (resolved future 2)
[16:20:44.900] Future #3
[16:20:44.900] result() for MulticoreFuture ...
[16:20:44.901] result() for MulticoreFuture ...
[16:20:44.901] result() for MulticoreFuture ... done
[16:20:44.901] result() for MulticoreFuture ... done
[16:20:44.901] result() for MulticoreFuture ...
[16:20:44.901] result() for MulticoreFuture ... done
[16:20:44.901] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:44.901] - nx: 6
[16:20:44.902] - relay: TRUE
[16:20:44.902] - stdout: TRUE
[16:20:44.902] - signal: TRUE
[16:20:44.902] - resignal: FALSE
[16:20:44.902] - force: TRUE
[16:20:44.902] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:44.902] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:44.902]  - until=3
[16:20:44.902]  - relaying element #3
[16:20:44.903] result() for MulticoreFuture ...
[16:20:44.903] result() for MulticoreFuture ... done
[16:20:44.903] result() for MulticoreFuture ...
[16:20:44.903] result() for MulticoreFuture ... done
[16:20:44.903] result() for MulticoreFuture ...
[16:20:44.903] result() for MulticoreFuture ... done
[16:20:44.903] result() for MulticoreFuture ...
[16:20:44.904] result() for MulticoreFuture ... done
[16:20:44.904] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:44.904] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:44.904] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:44.904]  length: 3 (resolved future 3)
[16:20:44.904] Future #4
[16:20:44.905] result() for MulticoreFuture ...
[16:20:44.905] result() for MulticoreFuture ...
[16:20:44.905] result() for MulticoreFuture ... done
[16:20:44.906] result() for MulticoreFuture ... done
[16:20:44.906] result() for MulticoreFuture ...
[16:20:44.906] result() for MulticoreFuture ... done
[16:20:44.906] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:44.906] - nx: 6
[16:20:44.907] - relay: TRUE
[16:20:44.907] - stdout: TRUE
[16:20:44.907] - signal: TRUE
[16:20:44.907] - resignal: FALSE
[16:20:44.907] - force: TRUE
[16:20:44.907] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:44.907] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:44.908]  - until=4
[16:20:44.908]  - relaying element #4
[16:20:44.908] result() for MulticoreFuture ...
[16:20:44.908] result() for MulticoreFuture ... done
[16:20:44.908] result() for MulticoreFuture ...
[16:20:44.908] result() for MulticoreFuture ... done
[16:20:44.909] result() for MulticoreFuture ...
[16:20:44.909] result() for MulticoreFuture ... done
[16:20:44.909] result() for MulticoreFuture ...
[16:20:44.909] result() for MulticoreFuture ... done
[16:20:44.909] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.909] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.909] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:44.910]  length: 2 (resolved future 4)
[16:20:44.910] signalConditionsASAP(NULL, pos=5) ...
[16:20:44.910] - nx: 6
[16:20:44.910] - relay: TRUE
[16:20:44.910] - stdout: TRUE
[16:20:44.910] - signal: TRUE
[16:20:44.910] - resignal: FALSE
[16:20:44.910] - force: TRUE
[16:20:44.910] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.910] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.911]  - until=6
[16:20:44.911]  - relaying element #6
[16:20:44.911] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:44.911] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.911] signalConditionsASAP(NULL, pos=5) ... done
[16:20:44.911]  length: 1 (resolved future 5)
[16:20:44.911] signalConditionsASAP(numeric, pos=6) ...
[16:20:44.915] - nx: 6
[16:20:44.916] - relay: TRUE
[16:20:44.916] - stdout: TRUE
[16:20:44.916] - signal: TRUE
[16:20:44.916] - resignal: FALSE
[16:20:44.916] - force: TRUE
[16:20:44.916] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:44.917] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.917]  - until=6
[16:20:44.917] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:44.917] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.917] signalConditionsASAP(numeric, pos=6) ... done
[16:20:44.917]  length: 0 (resolved future 6)
[16:20:44.917] Relaying remaining futures
[16:20:44.917] signalConditionsASAP(NULL, pos=0) ...
[16:20:44.918] - nx: 6
[16:20:44.918] - relay: TRUE
[16:20:44.918] - stdout: TRUE
[16:20:44.918] - signal: TRUE
[16:20:44.918] - resignal: FALSE
[16:20:44.918] - force: TRUE
[16:20:44.918] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:44.918] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:44.918] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:44.919] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:44.919] signalConditionsASAP(NULL, pos=0) ... done
[16:20:44.919] resolve() on list environment ... DONE
[16:20:44.919] result() for MulticoreFuture ...
[16:20:44.919] result() for MulticoreFuture ... done
[16:20:44.919] result() for MulticoreFuture ...
[16:20:44.919] result() for MulticoreFuture ... done
[16:20:44.919] result() for MulticoreFuture ...
[16:20:44.920] result() for MulticoreFuture ... done
[16:20:44.920] result() for MulticoreFuture ...
[16:20:44.920] result() for MulticoreFuture ... done
[16:20:44.920] result() for MulticoreFuture ...
[16:20:44.920] result() for MulticoreFuture ... done
[16:20:44.920] result() for MulticoreFuture ...
[16:20:44.920] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0db51d40> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:20:44.922] getGlobalsAndPackages() ...
[16:20:44.923] Searching for globals...
[16:20:44.923] 
[16:20:44.923] Searching for globals ... DONE
[16:20:44.923] - globals: [0] <none>
[16:20:44.923] getGlobalsAndPackages() ... DONE
[16:20:44.924] run() for ‘Future’ ...
[16:20:44.924] - state: ‘created’
[16:20:44.924] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.928] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.928] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:44.928]   - Field: ‘label’
[16:20:44.929]   - Field: ‘local’
[16:20:44.929]   - Field: ‘owner’
[16:20:44.929]   - Field: ‘envir’
[16:20:44.929]   - Field: ‘workers’
[16:20:44.929]   - Field: ‘packages’
[16:20:44.929]   - Field: ‘gc’
[16:20:44.929]   - Field: ‘job’
[16:20:44.929]   - Field: ‘conditions’
[16:20:44.929]   - Field: ‘expr’
[16:20:44.930]   - Field: ‘uuid’
[16:20:44.930]   - Field: ‘seed’
[16:20:44.930]   - Field: ‘version’
[16:20:44.930]   - Field: ‘result’
[16:20:44.930]   - Field: ‘asynchronous’
[16:20:44.930]   - Field: ‘calls’
[16:20:44.930]   - Field: ‘globals’
[16:20:44.930]   - Field: ‘stdout’
[16:20:44.930]   - Field: ‘earlySignal’
[16:20:44.931]   - Field: ‘lazy’
[16:20:44.931]   - Field: ‘state’
[16:20:44.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:44.931] - Launch lazy future ...
[16:20:44.931] Packages needed by the future expression (n = 0): <none>
[16:20:44.931] Packages needed by future strategies (n = 0): <none>
[16:20:44.932] {
[16:20:44.932]     {
[16:20:44.932]         {
[16:20:44.932]             ...future.startTime <- base::Sys.time()
[16:20:44.932]             {
[16:20:44.932]                 {
[16:20:44.932]                   {
[16:20:44.932]                     {
[16:20:44.932]                       base::local({
[16:20:44.932]                         has_future <- base::requireNamespace("future", 
[16:20:44.932]                           quietly = TRUE)
[16:20:44.932]                         if (has_future) {
[16:20:44.932]                           ns <- base::getNamespace("future")
[16:20:44.932]                           version <- ns[[".package"]][["version"]]
[16:20:44.932]                           if (is.null(version)) 
[16:20:44.932]                             version <- utils::packageVersion("future")
[16:20:44.932]                         }
[16:20:44.932]                         else {
[16:20:44.932]                           version <- NULL
[16:20:44.932]                         }
[16:20:44.932]                         if (!has_future || version < "1.8.0") {
[16:20:44.932]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.932]                             "", base::R.version$version.string), 
[16:20:44.932]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.932]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.932]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.932]                               "release", "version")], collapse = " "), 
[16:20:44.932]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.932]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.932]                             info)
[16:20:44.932]                           info <- base::paste(info, collapse = "; ")
[16:20:44.932]                           if (!has_future) {
[16:20:44.932]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.932]                               info)
[16:20:44.932]                           }
[16:20:44.932]                           else {
[16:20:44.932]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.932]                               info, version)
[16:20:44.932]                           }
[16:20:44.932]                           base::stop(msg)
[16:20:44.932]                         }
[16:20:44.932]                       })
[16:20:44.932]                     }
[16:20:44.932]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.932]                     base::options(mc.cores = 1L)
[16:20:44.932]                   }
[16:20:44.932]                   ...future.strategy.old <- future::plan("list")
[16:20:44.932]                   options(future.plan = NULL)
[16:20:44.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.932]                 }
[16:20:44.932]                 ...future.workdir <- getwd()
[16:20:44.932]             }
[16:20:44.932]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.932]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.932]         }
[16:20:44.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.932]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.932]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.932]             base::names(...future.oldOptions))
[16:20:44.932]     }
[16:20:44.932]     if (FALSE) {
[16:20:44.932]     }
[16:20:44.932]     else {
[16:20:44.932]         if (TRUE) {
[16:20:44.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.932]                 open = "w")
[16:20:44.932]         }
[16:20:44.932]         else {
[16:20:44.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.932]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.932]         }
[16:20:44.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.932]             base::sink(type = "output", split = FALSE)
[16:20:44.932]             base::close(...future.stdout)
[16:20:44.932]         }, add = TRUE)
[16:20:44.932]     }
[16:20:44.932]     ...future.frame <- base::sys.nframe()
[16:20:44.932]     ...future.conditions <- base::list()
[16:20:44.932]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.932]     if (FALSE) {
[16:20:44.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.932]     }
[16:20:44.932]     ...future.result <- base::tryCatch({
[16:20:44.932]         base::withCallingHandlers({
[16:20:44.932]             ...future.value <- base::withVisible(base::local({
[16:20:44.932]                 withCallingHandlers({
[16:20:44.932]                   2
[16:20:44.932]                 }, immediateCondition = function(cond) {
[16:20:44.932]                   save_rds <- function (object, pathname, ...) 
[16:20:44.932]                   {
[16:20:44.932]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:44.932]                     if (file_test("-f", pathname_tmp)) {
[16:20:44.932]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.932]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:44.932]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.932]                         fi_tmp[["mtime"]])
[16:20:44.932]                     }
[16:20:44.932]                     tryCatch({
[16:20:44.932]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:44.932]                     }, error = function(ex) {
[16:20:44.932]                       msg <- conditionMessage(ex)
[16:20:44.932]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.932]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:44.932]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.932]                         fi_tmp[["mtime"]], msg)
[16:20:44.932]                       ex$message <- msg
[16:20:44.932]                       stop(ex)
[16:20:44.932]                     })
[16:20:44.932]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:44.932]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:44.932]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:44.932]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.932]                       fi <- file.info(pathname)
[16:20:44.932]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:44.932]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.932]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:44.932]                         fi[["size"]], fi[["mtime"]])
[16:20:44.932]                       stop(msg)
[16:20:44.932]                     }
[16:20:44.932]                     invisible(pathname)
[16:20:44.932]                   }
[16:20:44.932]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:44.932]                     rootPath = tempdir()) 
[16:20:44.932]                   {
[16:20:44.932]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:44.932]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:44.932]                       tmpdir = path, fileext = ".rds")
[16:20:44.932]                     save_rds(obj, file)
[16:20:44.932]                   }
[16:20:44.932]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:44.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.932]                   {
[16:20:44.932]                     inherits <- base::inherits
[16:20:44.932]                     invokeRestart <- base::invokeRestart
[16:20:44.932]                     is.null <- base::is.null
[16:20:44.932]                     muffled <- FALSE
[16:20:44.932]                     if (inherits(cond, "message")) {
[16:20:44.932]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.932]                       if (muffled) 
[16:20:44.932]                         invokeRestart("muffleMessage")
[16:20:44.932]                     }
[16:20:44.932]                     else if (inherits(cond, "warning")) {
[16:20:44.932]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.932]                       if (muffled) 
[16:20:44.932]                         invokeRestart("muffleWarning")
[16:20:44.932]                     }
[16:20:44.932]                     else if (inherits(cond, "condition")) {
[16:20:44.932]                       if (!is.null(pattern)) {
[16:20:44.932]                         computeRestarts <- base::computeRestarts
[16:20:44.932]                         grepl <- base::grepl
[16:20:44.932]                         restarts <- computeRestarts(cond)
[16:20:44.932]                         for (restart in restarts) {
[16:20:44.932]                           name <- restart$name
[16:20:44.932]                           if (is.null(name)) 
[16:20:44.932]                             next
[16:20:44.932]                           if (!grepl(pattern, name)) 
[16:20:44.932]                             next
[16:20:44.932]                           invokeRestart(restart)
[16:20:44.932]                           muffled <- TRUE
[16:20:44.932]                           break
[16:20:44.932]                         }
[16:20:44.932]                       }
[16:20:44.932]                     }
[16:20:44.932]                     invisible(muffled)
[16:20:44.932]                   }
[16:20:44.932]                   muffleCondition(cond)
[16:20:44.932]                 })
[16:20:44.932]             }))
[16:20:44.932]             future::FutureResult(value = ...future.value$value, 
[16:20:44.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.932]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.932]                     ...future.globalenv.names))
[16:20:44.932]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.932]         }, condition = base::local({
[16:20:44.932]             c <- base::c
[16:20:44.932]             inherits <- base::inherits
[16:20:44.932]             invokeRestart <- base::invokeRestart
[16:20:44.932]             length <- base::length
[16:20:44.932]             list <- base::list
[16:20:44.932]             seq.int <- base::seq.int
[16:20:44.932]             signalCondition <- base::signalCondition
[16:20:44.932]             sys.calls <- base::sys.calls
[16:20:44.932]             `[[` <- base::`[[`
[16:20:44.932]             `+` <- base::`+`
[16:20:44.932]             `<<-` <- base::`<<-`
[16:20:44.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.932]                   3L)]
[16:20:44.932]             }
[16:20:44.932]             function(cond) {
[16:20:44.932]                 is_error <- inherits(cond, "error")
[16:20:44.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.932]                   NULL)
[16:20:44.932]                 if (is_error) {
[16:20:44.932]                   sessionInformation <- function() {
[16:20:44.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.932]                       search = base::search(), system = base::Sys.info())
[16:20:44.932]                   }
[16:20:44.932]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.932]                     cond$call), session = sessionInformation(), 
[16:20:44.932]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.932]                   signalCondition(cond)
[16:20:44.932]                 }
[16:20:44.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.932]                 "immediateCondition"))) {
[16:20:44.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.932]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.932]                   if (TRUE && !signal) {
[16:20:44.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.932]                     {
[16:20:44.932]                       inherits <- base::inherits
[16:20:44.932]                       invokeRestart <- base::invokeRestart
[16:20:44.932]                       is.null <- base::is.null
[16:20:44.932]                       muffled <- FALSE
[16:20:44.932]                       if (inherits(cond, "message")) {
[16:20:44.932]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.932]                         if (muffled) 
[16:20:44.932]                           invokeRestart("muffleMessage")
[16:20:44.932]                       }
[16:20:44.932]                       else if (inherits(cond, "warning")) {
[16:20:44.932]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.932]                         if (muffled) 
[16:20:44.932]                           invokeRestart("muffleWarning")
[16:20:44.932]                       }
[16:20:44.932]                       else if (inherits(cond, "condition")) {
[16:20:44.932]                         if (!is.null(pattern)) {
[16:20:44.932]                           computeRestarts <- base::computeRestarts
[16:20:44.932]                           grepl <- base::grepl
[16:20:44.932]                           restarts <- computeRestarts(cond)
[16:20:44.932]                           for (restart in restarts) {
[16:20:44.932]                             name <- restart$name
[16:20:44.932]                             if (is.null(name)) 
[16:20:44.932]                               next
[16:20:44.932]                             if (!grepl(pattern, name)) 
[16:20:44.932]                               next
[16:20:44.932]                             invokeRestart(restart)
[16:20:44.932]                             muffled <- TRUE
[16:20:44.932]                             break
[16:20:44.932]                           }
[16:20:44.932]                         }
[16:20:44.932]                       }
[16:20:44.932]                       invisible(muffled)
[16:20:44.932]                     }
[16:20:44.932]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.932]                   }
[16:20:44.932]                 }
[16:20:44.932]                 else {
[16:20:44.932]                   if (TRUE) {
[16:20:44.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.932]                     {
[16:20:44.932]                       inherits <- base::inherits
[16:20:44.932]                       invokeRestart <- base::invokeRestart
[16:20:44.932]                       is.null <- base::is.null
[16:20:44.932]                       muffled <- FALSE
[16:20:44.932]                       if (inherits(cond, "message")) {
[16:20:44.932]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.932]                         if (muffled) 
[16:20:44.932]                           invokeRestart("muffleMessage")
[16:20:44.932]                       }
[16:20:44.932]                       else if (inherits(cond, "warning")) {
[16:20:44.932]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.932]                         if (muffled) 
[16:20:44.932]                           invokeRestart("muffleWarning")
[16:20:44.932]                       }
[16:20:44.932]                       else if (inherits(cond, "condition")) {
[16:20:44.932]                         if (!is.null(pattern)) {
[16:20:44.932]                           computeRestarts <- base::computeRestarts
[16:20:44.932]                           grepl <- base::grepl
[16:20:44.932]                           restarts <- computeRestarts(cond)
[16:20:44.932]                           for (restart in restarts) {
[16:20:44.932]                             name <- restart$name
[16:20:44.932]                             if (is.null(name)) 
[16:20:44.932]                               next
[16:20:44.932]                             if (!grepl(pattern, name)) 
[16:20:44.932]                               next
[16:20:44.932]                             invokeRestart(restart)
[16:20:44.932]                             muffled <- TRUE
[16:20:44.932]                             break
[16:20:44.932]                           }
[16:20:44.932]                         }
[16:20:44.932]                       }
[16:20:44.932]                       invisible(muffled)
[16:20:44.932]                     }
[16:20:44.932]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.932]                   }
[16:20:44.932]                 }
[16:20:44.932]             }
[16:20:44.932]         }))
[16:20:44.932]     }, error = function(ex) {
[16:20:44.932]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.932]                 ...future.rng), started = ...future.startTime, 
[16:20:44.932]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.932]             version = "1.8"), class = "FutureResult")
[16:20:44.932]     }, finally = {
[16:20:44.932]         if (!identical(...future.workdir, getwd())) 
[16:20:44.932]             setwd(...future.workdir)
[16:20:44.932]         {
[16:20:44.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.932]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.932]             }
[16:20:44.932]             base::options(...future.oldOptions)
[16:20:44.932]             if (.Platform$OS.type == "windows") {
[16:20:44.932]                 old_names <- names(...future.oldEnvVars)
[16:20:44.932]                 envs <- base::Sys.getenv()
[16:20:44.932]                 names <- names(envs)
[16:20:44.932]                 common <- intersect(names, old_names)
[16:20:44.932]                 added <- setdiff(names, old_names)
[16:20:44.932]                 removed <- setdiff(old_names, names)
[16:20:44.932]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.932]                   envs[common]]
[16:20:44.932]                 NAMES <- toupper(changed)
[16:20:44.932]                 args <- list()
[16:20:44.932]                 for (kk in seq_along(NAMES)) {
[16:20:44.932]                   name <- changed[[kk]]
[16:20:44.932]                   NAME <- NAMES[[kk]]
[16:20:44.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.932]                     next
[16:20:44.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.932]                 }
[16:20:44.932]                 NAMES <- toupper(added)
[16:20:44.932]                 for (kk in seq_along(NAMES)) {
[16:20:44.932]                   name <- added[[kk]]
[16:20:44.932]                   NAME <- NAMES[[kk]]
[16:20:44.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.932]                     next
[16:20:44.932]                   args[[name]] <- ""
[16:20:44.932]                 }
[16:20:44.932]                 NAMES <- toupper(removed)
[16:20:44.932]                 for (kk in seq_along(NAMES)) {
[16:20:44.932]                   name <- removed[[kk]]
[16:20:44.932]                   NAME <- NAMES[[kk]]
[16:20:44.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.932]                     next
[16:20:44.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.932]                 }
[16:20:44.932]                 if (length(args) > 0) 
[16:20:44.932]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.932]             }
[16:20:44.932]             else {
[16:20:44.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.932]             }
[16:20:44.932]             {
[16:20:44.932]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.932]                   0L) {
[16:20:44.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.932]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.932]                   base::options(opts)
[16:20:44.932]                 }
[16:20:44.932]                 {
[16:20:44.932]                   {
[16:20:44.932]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.932]                     NULL
[16:20:44.932]                   }
[16:20:44.932]                   options(future.plan = NULL)
[16:20:44.932]                   if (is.na(NA_character_)) 
[16:20:44.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.932]                     .init = FALSE)
[16:20:44.932]                 }
[16:20:44.932]             }
[16:20:44.932]         }
[16:20:44.932]     })
[16:20:44.932]     if (TRUE) {
[16:20:44.932]         base::sink(type = "output", split = FALSE)
[16:20:44.932]         if (TRUE) {
[16:20:44.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.932]         }
[16:20:44.932]         else {
[16:20:44.932]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.932]         }
[16:20:44.932]         base::close(...future.stdout)
[16:20:44.932]         ...future.stdout <- NULL
[16:20:44.932]     }
[16:20:44.932]     ...future.result$conditions <- ...future.conditions
[16:20:44.932]     ...future.result$finished <- base::Sys.time()
[16:20:44.932]     ...future.result
[16:20:44.932] }
[16:20:44.934] requestCore(): workers = 2
[16:20:44.937] MulticoreFuture started
[16:20:44.937] - Launch lazy future ... done
[16:20:44.938] run() for ‘MulticoreFuture’ ... done
[16:20:44.938] getGlobalsAndPackages() ...
[16:20:44.938] Searching for globals...
[16:20:44.938] plan(): Setting new future strategy stack:
[16:20:44.939] 
[16:20:44.939] Searching for globals ... DONE
[16:20:44.938] List of future strategies:
[16:20:44.938] 1. sequential:
[16:20:44.938]    - args: function (..., envir = parent.frame())
[16:20:44.938]    - tweaked: FALSE
[16:20:44.938]    - call: NULL
[16:20:44.939] - globals: [0] <none>
[16:20:44.939] plan(): nbrOfWorkers() = 1
[16:20:44.939] getGlobalsAndPackages() ... DONE
[16:20:44.940] run() for ‘Future’ ...
[16:20:44.940] - state: ‘created’
[16:20:44.940] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.941] plan(): Setting new future strategy stack:
[16:20:44.941] List of future strategies:
[16:20:44.941] 1. multicore:
[16:20:44.941]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.941]    - tweaked: FALSE
[16:20:44.941]    - call: plan(strategy)
[16:20:44.945] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.946] plan(): nbrOfWorkers() = 2
[16:20:44.946] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:44.946]   - Field: ‘label’
[16:20:44.946]   - Field: ‘local’
[16:20:44.946]   - Field: ‘owner’
[16:20:44.946]   - Field: ‘envir’
[16:20:44.946]   - Field: ‘workers’
[16:20:44.947]   - Field: ‘packages’
[16:20:44.947]   - Field: ‘gc’
[16:20:44.947]   - Field: ‘job’
[16:20:44.947]   - Field: ‘conditions’
[16:20:44.947]   - Field: ‘expr’
[16:20:44.947]   - Field: ‘uuid’
[16:20:44.947]   - Field: ‘seed’
[16:20:44.948]   - Field: ‘version’
[16:20:44.948]   - Field: ‘result’
[16:20:44.948]   - Field: ‘asynchronous’
[16:20:44.948]   - Field: ‘calls’
[16:20:44.948]   - Field: ‘globals’
[16:20:44.948]   - Field: ‘stdout’
[16:20:44.949]   - Field: ‘earlySignal’
[16:20:44.949]   - Field: ‘lazy’
[16:20:44.949]   - Field: ‘state’
[16:20:44.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:44.949] - Launch lazy future ...
[16:20:44.950] Packages needed by the future expression (n = 0): <none>
[16:20:44.950] Packages needed by future strategies (n = 0): <none>
[16:20:44.951] {
[16:20:44.951]     {
[16:20:44.951]         {
[16:20:44.951]             ...future.startTime <- base::Sys.time()
[16:20:44.951]             {
[16:20:44.951]                 {
[16:20:44.951]                   {
[16:20:44.951]                     {
[16:20:44.951]                       base::local({
[16:20:44.951]                         has_future <- base::requireNamespace("future", 
[16:20:44.951]                           quietly = TRUE)
[16:20:44.951]                         if (has_future) {
[16:20:44.951]                           ns <- base::getNamespace("future")
[16:20:44.951]                           version <- ns[[".package"]][["version"]]
[16:20:44.951]                           if (is.null(version)) 
[16:20:44.951]                             version <- utils::packageVersion("future")
[16:20:44.951]                         }
[16:20:44.951]                         else {
[16:20:44.951]                           version <- NULL
[16:20:44.951]                         }
[16:20:44.951]                         if (!has_future || version < "1.8.0") {
[16:20:44.951]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.951]                             "", base::R.version$version.string), 
[16:20:44.951]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.951]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.951]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.951]                               "release", "version")], collapse = " "), 
[16:20:44.951]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.951]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.951]                             info)
[16:20:44.951]                           info <- base::paste(info, collapse = "; ")
[16:20:44.951]                           if (!has_future) {
[16:20:44.951]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.951]                               info)
[16:20:44.951]                           }
[16:20:44.951]                           else {
[16:20:44.951]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.951]                               info, version)
[16:20:44.951]                           }
[16:20:44.951]                           base::stop(msg)
[16:20:44.951]                         }
[16:20:44.951]                       })
[16:20:44.951]                     }
[16:20:44.951]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.951]                     base::options(mc.cores = 1L)
[16:20:44.951]                   }
[16:20:44.951]                   ...future.strategy.old <- future::plan("list")
[16:20:44.951]                   options(future.plan = NULL)
[16:20:44.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.951]                 }
[16:20:44.951]                 ...future.workdir <- getwd()
[16:20:44.951]             }
[16:20:44.951]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.951]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.951]         }
[16:20:44.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.951]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.951]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.951]             base::names(...future.oldOptions))
[16:20:44.951]     }
[16:20:44.951]     if (FALSE) {
[16:20:44.951]     }
[16:20:44.951]     else {
[16:20:44.951]         if (TRUE) {
[16:20:44.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.951]                 open = "w")
[16:20:44.951]         }
[16:20:44.951]         else {
[16:20:44.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.951]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.951]         }
[16:20:44.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.951]             base::sink(type = "output", split = FALSE)
[16:20:44.951]             base::close(...future.stdout)
[16:20:44.951]         }, add = TRUE)
[16:20:44.951]     }
[16:20:44.951]     ...future.frame <- base::sys.nframe()
[16:20:44.951]     ...future.conditions <- base::list()
[16:20:44.951]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.951]     if (FALSE) {
[16:20:44.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.951]     }
[16:20:44.951]     ...future.result <- base::tryCatch({
[16:20:44.951]         base::withCallingHandlers({
[16:20:44.951]             ...future.value <- base::withVisible(base::local({
[16:20:44.951]                 withCallingHandlers({
[16:20:44.951]                   NULL
[16:20:44.951]                 }, immediateCondition = function(cond) {
[16:20:44.951]                   save_rds <- function (object, pathname, ...) 
[16:20:44.951]                   {
[16:20:44.951]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:44.951]                     if (file_test("-f", pathname_tmp)) {
[16:20:44.951]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.951]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:44.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.951]                         fi_tmp[["mtime"]])
[16:20:44.951]                     }
[16:20:44.951]                     tryCatch({
[16:20:44.951]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:44.951]                     }, error = function(ex) {
[16:20:44.951]                       msg <- conditionMessage(ex)
[16:20:44.951]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.951]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:44.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.951]                         fi_tmp[["mtime"]], msg)
[16:20:44.951]                       ex$message <- msg
[16:20:44.951]                       stop(ex)
[16:20:44.951]                     })
[16:20:44.951]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:44.951]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:44.951]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:44.951]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.951]                       fi <- file.info(pathname)
[16:20:44.951]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:44.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.951]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:44.951]                         fi[["size"]], fi[["mtime"]])
[16:20:44.951]                       stop(msg)
[16:20:44.951]                     }
[16:20:44.951]                     invisible(pathname)
[16:20:44.951]                   }
[16:20:44.951]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:44.951]                     rootPath = tempdir()) 
[16:20:44.951]                   {
[16:20:44.951]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:44.951]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:44.951]                       tmpdir = path, fileext = ".rds")
[16:20:44.951]                     save_rds(obj, file)
[16:20:44.951]                   }
[16:20:44.951]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:44.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.951]                   {
[16:20:44.951]                     inherits <- base::inherits
[16:20:44.951]                     invokeRestart <- base::invokeRestart
[16:20:44.951]                     is.null <- base::is.null
[16:20:44.951]                     muffled <- FALSE
[16:20:44.951]                     if (inherits(cond, "message")) {
[16:20:44.951]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.951]                       if (muffled) 
[16:20:44.951]                         invokeRestart("muffleMessage")
[16:20:44.951]                     }
[16:20:44.951]                     else if (inherits(cond, "warning")) {
[16:20:44.951]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.951]                       if (muffled) 
[16:20:44.951]                         invokeRestart("muffleWarning")
[16:20:44.951]                     }
[16:20:44.951]                     else if (inherits(cond, "condition")) {
[16:20:44.951]                       if (!is.null(pattern)) {
[16:20:44.951]                         computeRestarts <- base::computeRestarts
[16:20:44.951]                         grepl <- base::grepl
[16:20:44.951]                         restarts <- computeRestarts(cond)
[16:20:44.951]                         for (restart in restarts) {
[16:20:44.951]                           name <- restart$name
[16:20:44.951]                           if (is.null(name)) 
[16:20:44.951]                             next
[16:20:44.951]                           if (!grepl(pattern, name)) 
[16:20:44.951]                             next
[16:20:44.951]                           invokeRestart(restart)
[16:20:44.951]                           muffled <- TRUE
[16:20:44.951]                           break
[16:20:44.951]                         }
[16:20:44.951]                       }
[16:20:44.951]                     }
[16:20:44.951]                     invisible(muffled)
[16:20:44.951]                   }
[16:20:44.951]                   muffleCondition(cond)
[16:20:44.951]                 })
[16:20:44.951]             }))
[16:20:44.951]             future::FutureResult(value = ...future.value$value, 
[16:20:44.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.951]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.951]                     ...future.globalenv.names))
[16:20:44.951]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.951]         }, condition = base::local({
[16:20:44.951]             c <- base::c
[16:20:44.951]             inherits <- base::inherits
[16:20:44.951]             invokeRestart <- base::invokeRestart
[16:20:44.951]             length <- base::length
[16:20:44.951]             list <- base::list
[16:20:44.951]             seq.int <- base::seq.int
[16:20:44.951]             signalCondition <- base::signalCondition
[16:20:44.951]             sys.calls <- base::sys.calls
[16:20:44.951]             `[[` <- base::`[[`
[16:20:44.951]             `+` <- base::`+`
[16:20:44.951]             `<<-` <- base::`<<-`
[16:20:44.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.951]                   3L)]
[16:20:44.951]             }
[16:20:44.951]             function(cond) {
[16:20:44.951]                 is_error <- inherits(cond, "error")
[16:20:44.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.951]                   NULL)
[16:20:44.951]                 if (is_error) {
[16:20:44.951]                   sessionInformation <- function() {
[16:20:44.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.951]                       search = base::search(), system = base::Sys.info())
[16:20:44.951]                   }
[16:20:44.951]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.951]                     cond$call), session = sessionInformation(), 
[16:20:44.951]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.951]                   signalCondition(cond)
[16:20:44.951]                 }
[16:20:44.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.951]                 "immediateCondition"))) {
[16:20:44.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.951]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.951]                   if (TRUE && !signal) {
[16:20:44.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.951]                     {
[16:20:44.951]                       inherits <- base::inherits
[16:20:44.951]                       invokeRestart <- base::invokeRestart
[16:20:44.951]                       is.null <- base::is.null
[16:20:44.951]                       muffled <- FALSE
[16:20:44.951]                       if (inherits(cond, "message")) {
[16:20:44.951]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.951]                         if (muffled) 
[16:20:44.951]                           invokeRestart("muffleMessage")
[16:20:44.951]                       }
[16:20:44.951]                       else if (inherits(cond, "warning")) {
[16:20:44.951]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.951]                         if (muffled) 
[16:20:44.951]                           invokeRestart("muffleWarning")
[16:20:44.951]                       }
[16:20:44.951]                       else if (inherits(cond, "condition")) {
[16:20:44.951]                         if (!is.null(pattern)) {
[16:20:44.951]                           computeRestarts <- base::computeRestarts
[16:20:44.951]                           grepl <- base::grepl
[16:20:44.951]                           restarts <- computeRestarts(cond)
[16:20:44.951]                           for (restart in restarts) {
[16:20:44.951]                             name <- restart$name
[16:20:44.951]                             if (is.null(name)) 
[16:20:44.951]                               next
[16:20:44.951]                             if (!grepl(pattern, name)) 
[16:20:44.951]                               next
[16:20:44.951]                             invokeRestart(restart)
[16:20:44.951]                             muffled <- TRUE
[16:20:44.951]                             break
[16:20:44.951]                           }
[16:20:44.951]                         }
[16:20:44.951]                       }
[16:20:44.951]                       invisible(muffled)
[16:20:44.951]                     }
[16:20:44.951]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.951]                   }
[16:20:44.951]                 }
[16:20:44.951]                 else {
[16:20:44.951]                   if (TRUE) {
[16:20:44.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.951]                     {
[16:20:44.951]                       inherits <- base::inherits
[16:20:44.951]                       invokeRestart <- base::invokeRestart
[16:20:44.951]                       is.null <- base::is.null
[16:20:44.951]                       muffled <- FALSE
[16:20:44.951]                       if (inherits(cond, "message")) {
[16:20:44.951]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.951]                         if (muffled) 
[16:20:44.951]                           invokeRestart("muffleMessage")
[16:20:44.951]                       }
[16:20:44.951]                       else if (inherits(cond, "warning")) {
[16:20:44.951]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.951]                         if (muffled) 
[16:20:44.951]                           invokeRestart("muffleWarning")
[16:20:44.951]                       }
[16:20:44.951]                       else if (inherits(cond, "condition")) {
[16:20:44.951]                         if (!is.null(pattern)) {
[16:20:44.951]                           computeRestarts <- base::computeRestarts
[16:20:44.951]                           grepl <- base::grepl
[16:20:44.951]                           restarts <- computeRestarts(cond)
[16:20:44.951]                           for (restart in restarts) {
[16:20:44.951]                             name <- restart$name
[16:20:44.951]                             if (is.null(name)) 
[16:20:44.951]                               next
[16:20:44.951]                             if (!grepl(pattern, name)) 
[16:20:44.951]                               next
[16:20:44.951]                             invokeRestart(restart)
[16:20:44.951]                             muffled <- TRUE
[16:20:44.951]                             break
[16:20:44.951]                           }
[16:20:44.951]                         }
[16:20:44.951]                       }
[16:20:44.951]                       invisible(muffled)
[16:20:44.951]                     }
[16:20:44.951]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.951]                   }
[16:20:44.951]                 }
[16:20:44.951]             }
[16:20:44.951]         }))
[16:20:44.951]     }, error = function(ex) {
[16:20:44.951]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.951]                 ...future.rng), started = ...future.startTime, 
[16:20:44.951]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.951]             version = "1.8"), class = "FutureResult")
[16:20:44.951]     }, finally = {
[16:20:44.951]         if (!identical(...future.workdir, getwd())) 
[16:20:44.951]             setwd(...future.workdir)
[16:20:44.951]         {
[16:20:44.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.951]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.951]             }
[16:20:44.951]             base::options(...future.oldOptions)
[16:20:44.951]             if (.Platform$OS.type == "windows") {
[16:20:44.951]                 old_names <- names(...future.oldEnvVars)
[16:20:44.951]                 envs <- base::Sys.getenv()
[16:20:44.951]                 names <- names(envs)
[16:20:44.951]                 common <- intersect(names, old_names)
[16:20:44.951]                 added <- setdiff(names, old_names)
[16:20:44.951]                 removed <- setdiff(old_names, names)
[16:20:44.951]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.951]                   envs[common]]
[16:20:44.951]                 NAMES <- toupper(changed)
[16:20:44.951]                 args <- list()
[16:20:44.951]                 for (kk in seq_along(NAMES)) {
[16:20:44.951]                   name <- changed[[kk]]
[16:20:44.951]                   NAME <- NAMES[[kk]]
[16:20:44.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.951]                     next
[16:20:44.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.951]                 }
[16:20:44.951]                 NAMES <- toupper(added)
[16:20:44.951]                 for (kk in seq_along(NAMES)) {
[16:20:44.951]                   name <- added[[kk]]
[16:20:44.951]                   NAME <- NAMES[[kk]]
[16:20:44.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.951]                     next
[16:20:44.951]                   args[[name]] <- ""
[16:20:44.951]                 }
[16:20:44.951]                 NAMES <- toupper(removed)
[16:20:44.951]                 for (kk in seq_along(NAMES)) {
[16:20:44.951]                   name <- removed[[kk]]
[16:20:44.951]                   NAME <- NAMES[[kk]]
[16:20:44.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.951]                     next
[16:20:44.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.951]                 }
[16:20:44.951]                 if (length(args) > 0) 
[16:20:44.951]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.951]             }
[16:20:44.951]             else {
[16:20:44.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.951]             }
[16:20:44.951]             {
[16:20:44.951]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.951]                   0L) {
[16:20:44.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.951]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.951]                   base::options(opts)
[16:20:44.951]                 }
[16:20:44.951]                 {
[16:20:44.951]                   {
[16:20:44.951]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.951]                     NULL
[16:20:44.951]                   }
[16:20:44.951]                   options(future.plan = NULL)
[16:20:44.951]                   if (is.na(NA_character_)) 
[16:20:44.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.951]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.951]                     .init = FALSE)
[16:20:44.951]                 }
[16:20:44.951]             }
[16:20:44.951]         }
[16:20:44.951]     })
[16:20:44.951]     if (TRUE) {
[16:20:44.951]         base::sink(type = "output", split = FALSE)
[16:20:44.951]         if (TRUE) {
[16:20:44.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.951]         }
[16:20:44.951]         else {
[16:20:44.951]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.951]         }
[16:20:44.951]         base::close(...future.stdout)
[16:20:44.951]         ...future.stdout <- NULL
[16:20:44.951]     }
[16:20:44.951]     ...future.result$conditions <- ...future.conditions
[16:20:44.951]     ...future.result$finished <- base::Sys.time()
[16:20:44.951]     ...future.result
[16:20:44.951] }
[16:20:44.954] requestCore(): workers = 2
[16:20:44.957] MulticoreFuture started
[16:20:44.958] - Launch lazy future ... done
[16:20:44.958] run() for ‘MulticoreFuture’ ... done
[16:20:44.958] plan(): Setting new future strategy stack:
[16:20:44.959] getGlobalsAndPackages() ...
[16:20:44.959] Searching for globals...
[16:20:44.959] List of future strategies:
[16:20:44.959] 1. sequential:
[16:20:44.959]    - args: function (..., envir = parent.frame())
[16:20:44.959]    - tweaked: FALSE
[16:20:44.959]    - call: NULL
[16:20:44.960] plan(): nbrOfWorkers() = 1
[16:20:44.961] - globals found: [1] ‘{’
[16:20:44.961] Searching for globals ... DONE
[16:20:44.961] Resolving globals: FALSE
[16:20:44.961] 
[16:20:44.962] 
[16:20:44.962] getGlobalsAndPackages() ... DONE
[16:20:44.962] plan(): Setting new future strategy stack:
[16:20:44.962] run() for ‘Future’ ...
[16:20:44.962] List of future strategies:
[16:20:44.962] 1. multicore:
[16:20:44.962]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.962]    - tweaked: FALSE
[16:20:44.962]    - call: plan(strategy)
[16:20:44.962] - state: ‘created’
[16:20:44.963] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:44.967] plan(): nbrOfWorkers() = 2
[16:20:44.968] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:44.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:44.968]   - Field: ‘label’
[16:20:44.969]   - Field: ‘local’
[16:20:44.969]   - Field: ‘owner’
[16:20:44.969]   - Field: ‘envir’
[16:20:44.969]   - Field: ‘workers’
[16:20:44.970]   - Field: ‘packages’
[16:20:44.970]   - Field: ‘gc’
[16:20:44.970]   - Field: ‘job’
[16:20:44.970]   - Field: ‘conditions’
[16:20:44.970]   - Field: ‘expr’
[16:20:44.970]   - Field: ‘uuid’
[16:20:44.971]   - Field: ‘seed’
[16:20:44.971]   - Field: ‘version’
[16:20:44.971]   - Field: ‘result’
[16:20:44.971]   - Field: ‘asynchronous’
[16:20:44.971]   - Field: ‘calls’
[16:20:44.971]   - Field: ‘globals’
[16:20:44.972]   - Field: ‘stdout’
[16:20:44.972]   - Field: ‘earlySignal’
[16:20:44.972]   - Field: ‘lazy’
[16:20:44.972]   - Field: ‘state’
[16:20:44.972] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:44.972] - Launch lazy future ...
[16:20:44.973] Packages needed by the future expression (n = 0): <none>
[16:20:44.973] Packages needed by future strategies (n = 0): <none>
[16:20:44.974] {
[16:20:44.974]     {
[16:20:44.974]         {
[16:20:44.974]             ...future.startTime <- base::Sys.time()
[16:20:44.974]             {
[16:20:44.974]                 {
[16:20:44.974]                   {
[16:20:44.974]                     {
[16:20:44.974]                       base::local({
[16:20:44.974]                         has_future <- base::requireNamespace("future", 
[16:20:44.974]                           quietly = TRUE)
[16:20:44.974]                         if (has_future) {
[16:20:44.974]                           ns <- base::getNamespace("future")
[16:20:44.974]                           version <- ns[[".package"]][["version"]]
[16:20:44.974]                           if (is.null(version)) 
[16:20:44.974]                             version <- utils::packageVersion("future")
[16:20:44.974]                         }
[16:20:44.974]                         else {
[16:20:44.974]                           version <- NULL
[16:20:44.974]                         }
[16:20:44.974]                         if (!has_future || version < "1.8.0") {
[16:20:44.974]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:44.974]                             "", base::R.version$version.string), 
[16:20:44.974]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:44.974]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:44.974]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:44.974]                               "release", "version")], collapse = " "), 
[16:20:44.974]                             hostname = base::Sys.info()[["nodename"]])
[16:20:44.974]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:44.974]                             info)
[16:20:44.974]                           info <- base::paste(info, collapse = "; ")
[16:20:44.974]                           if (!has_future) {
[16:20:44.974]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:44.974]                               info)
[16:20:44.974]                           }
[16:20:44.974]                           else {
[16:20:44.974]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:44.974]                               info, version)
[16:20:44.974]                           }
[16:20:44.974]                           base::stop(msg)
[16:20:44.974]                         }
[16:20:44.974]                       })
[16:20:44.974]                     }
[16:20:44.974]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:44.974]                     base::options(mc.cores = 1L)
[16:20:44.974]                   }
[16:20:44.974]                   ...future.strategy.old <- future::plan("list")
[16:20:44.974]                   options(future.plan = NULL)
[16:20:44.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:44.974]                 }
[16:20:44.974]                 ...future.workdir <- getwd()
[16:20:44.974]             }
[16:20:44.974]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:44.974]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:44.974]         }
[16:20:44.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:44.974]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:44.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:44.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:44.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:44.974]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:44.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:44.974]             base::names(...future.oldOptions))
[16:20:44.974]     }
[16:20:44.974]     if (FALSE) {
[16:20:44.974]     }
[16:20:44.974]     else {
[16:20:44.974]         if (TRUE) {
[16:20:44.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:44.974]                 open = "w")
[16:20:44.974]         }
[16:20:44.974]         else {
[16:20:44.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:44.974]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:44.974]         }
[16:20:44.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:44.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:44.974]             base::sink(type = "output", split = FALSE)
[16:20:44.974]             base::close(...future.stdout)
[16:20:44.974]         }, add = TRUE)
[16:20:44.974]     }
[16:20:44.974]     ...future.frame <- base::sys.nframe()
[16:20:44.974]     ...future.conditions <- base::list()
[16:20:44.974]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:44.974]     if (FALSE) {
[16:20:44.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:44.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:44.974]     }
[16:20:44.974]     ...future.result <- base::tryCatch({
[16:20:44.974]         base::withCallingHandlers({
[16:20:44.974]             ...future.value <- base::withVisible(base::local({
[16:20:44.974]                 withCallingHandlers({
[16:20:44.974]                   {
[16:20:44.974]                     4
[16:20:44.974]                   }
[16:20:44.974]                 }, immediateCondition = function(cond) {
[16:20:44.974]                   save_rds <- function (object, pathname, ...) 
[16:20:44.974]                   {
[16:20:44.974]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:44.974]                     if (file_test("-f", pathname_tmp)) {
[16:20:44.974]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.974]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:44.974]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.974]                         fi_tmp[["mtime"]])
[16:20:44.974]                     }
[16:20:44.974]                     tryCatch({
[16:20:44.974]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:44.974]                     }, error = function(ex) {
[16:20:44.974]                       msg <- conditionMessage(ex)
[16:20:44.974]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.974]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:44.974]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.974]                         fi_tmp[["mtime"]], msg)
[16:20:44.974]                       ex$message <- msg
[16:20:44.974]                       stop(ex)
[16:20:44.974]                     })
[16:20:44.974]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:44.974]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:44.974]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:44.974]                       fi_tmp <- file.info(pathname_tmp)
[16:20:44.974]                       fi <- file.info(pathname)
[16:20:44.974]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:44.974]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:44.974]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:44.974]                         fi[["size"]], fi[["mtime"]])
[16:20:44.974]                       stop(msg)
[16:20:44.974]                     }
[16:20:44.974]                     invisible(pathname)
[16:20:44.974]                   }
[16:20:44.974]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:44.974]                     rootPath = tempdir()) 
[16:20:44.974]                   {
[16:20:44.974]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:44.974]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:44.974]                       tmpdir = path, fileext = ".rds")
[16:20:44.974]                     save_rds(obj, file)
[16:20:44.974]                   }
[16:20:44.974]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:44.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.974]                   {
[16:20:44.974]                     inherits <- base::inherits
[16:20:44.974]                     invokeRestart <- base::invokeRestart
[16:20:44.974]                     is.null <- base::is.null
[16:20:44.974]                     muffled <- FALSE
[16:20:44.974]                     if (inherits(cond, "message")) {
[16:20:44.974]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:44.974]                       if (muffled) 
[16:20:44.974]                         invokeRestart("muffleMessage")
[16:20:44.974]                     }
[16:20:44.974]                     else if (inherits(cond, "warning")) {
[16:20:44.974]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:44.974]                       if (muffled) 
[16:20:44.974]                         invokeRestart("muffleWarning")
[16:20:44.974]                     }
[16:20:44.974]                     else if (inherits(cond, "condition")) {
[16:20:44.974]                       if (!is.null(pattern)) {
[16:20:44.974]                         computeRestarts <- base::computeRestarts
[16:20:44.974]                         grepl <- base::grepl
[16:20:44.974]                         restarts <- computeRestarts(cond)
[16:20:44.974]                         for (restart in restarts) {
[16:20:44.974]                           name <- restart$name
[16:20:44.974]                           if (is.null(name)) 
[16:20:44.974]                             next
[16:20:44.974]                           if (!grepl(pattern, name)) 
[16:20:44.974]                             next
[16:20:44.974]                           invokeRestart(restart)
[16:20:44.974]                           muffled <- TRUE
[16:20:44.974]                           break
[16:20:44.974]                         }
[16:20:44.974]                       }
[16:20:44.974]                     }
[16:20:44.974]                     invisible(muffled)
[16:20:44.974]                   }
[16:20:44.974]                   muffleCondition(cond)
[16:20:44.974]                 })
[16:20:44.974]             }))
[16:20:44.974]             future::FutureResult(value = ...future.value$value, 
[16:20:44.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.974]                   ...future.rng), globalenv = if (FALSE) 
[16:20:44.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:44.974]                     ...future.globalenv.names))
[16:20:44.974]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:44.974]         }, condition = base::local({
[16:20:44.974]             c <- base::c
[16:20:44.974]             inherits <- base::inherits
[16:20:44.974]             invokeRestart <- base::invokeRestart
[16:20:44.974]             length <- base::length
[16:20:44.974]             list <- base::list
[16:20:44.974]             seq.int <- base::seq.int
[16:20:44.974]             signalCondition <- base::signalCondition
[16:20:44.974]             sys.calls <- base::sys.calls
[16:20:44.974]             `[[` <- base::`[[`
[16:20:44.974]             `+` <- base::`+`
[16:20:44.974]             `<<-` <- base::`<<-`
[16:20:44.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:44.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:44.974]                   3L)]
[16:20:44.974]             }
[16:20:44.974]             function(cond) {
[16:20:44.974]                 is_error <- inherits(cond, "error")
[16:20:44.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:44.974]                   NULL)
[16:20:44.974]                 if (is_error) {
[16:20:44.974]                   sessionInformation <- function() {
[16:20:44.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:44.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:44.974]                       search = base::search(), system = base::Sys.info())
[16:20:44.974]                   }
[16:20:44.974]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:44.974]                     cond$call), session = sessionInformation(), 
[16:20:44.974]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:44.974]                   signalCondition(cond)
[16:20:44.974]                 }
[16:20:44.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:44.974]                 "immediateCondition"))) {
[16:20:44.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:44.974]                   ...future.conditions[[length(...future.conditions) + 
[16:20:44.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:44.974]                   if (TRUE && !signal) {
[16:20:44.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.974]                     {
[16:20:44.974]                       inherits <- base::inherits
[16:20:44.974]                       invokeRestart <- base::invokeRestart
[16:20:44.974]                       is.null <- base::is.null
[16:20:44.974]                       muffled <- FALSE
[16:20:44.974]                       if (inherits(cond, "message")) {
[16:20:44.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.974]                         if (muffled) 
[16:20:44.974]                           invokeRestart("muffleMessage")
[16:20:44.974]                       }
[16:20:44.974]                       else if (inherits(cond, "warning")) {
[16:20:44.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.974]                         if (muffled) 
[16:20:44.974]                           invokeRestart("muffleWarning")
[16:20:44.974]                       }
[16:20:44.974]                       else if (inherits(cond, "condition")) {
[16:20:44.974]                         if (!is.null(pattern)) {
[16:20:44.974]                           computeRestarts <- base::computeRestarts
[16:20:44.974]                           grepl <- base::grepl
[16:20:44.974]                           restarts <- computeRestarts(cond)
[16:20:44.974]                           for (restart in restarts) {
[16:20:44.974]                             name <- restart$name
[16:20:44.974]                             if (is.null(name)) 
[16:20:44.974]                               next
[16:20:44.974]                             if (!grepl(pattern, name)) 
[16:20:44.974]                               next
[16:20:44.974]                             invokeRestart(restart)
[16:20:44.974]                             muffled <- TRUE
[16:20:44.974]                             break
[16:20:44.974]                           }
[16:20:44.974]                         }
[16:20:44.974]                       }
[16:20:44.974]                       invisible(muffled)
[16:20:44.974]                     }
[16:20:44.974]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.974]                   }
[16:20:44.974]                 }
[16:20:44.974]                 else {
[16:20:44.974]                   if (TRUE) {
[16:20:44.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:44.974]                     {
[16:20:44.974]                       inherits <- base::inherits
[16:20:44.974]                       invokeRestart <- base::invokeRestart
[16:20:44.974]                       is.null <- base::is.null
[16:20:44.974]                       muffled <- FALSE
[16:20:44.974]                       if (inherits(cond, "message")) {
[16:20:44.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:44.974]                         if (muffled) 
[16:20:44.974]                           invokeRestart("muffleMessage")
[16:20:44.974]                       }
[16:20:44.974]                       else if (inherits(cond, "warning")) {
[16:20:44.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:44.974]                         if (muffled) 
[16:20:44.974]                           invokeRestart("muffleWarning")
[16:20:44.974]                       }
[16:20:44.974]                       else if (inherits(cond, "condition")) {
[16:20:44.974]                         if (!is.null(pattern)) {
[16:20:44.974]                           computeRestarts <- base::computeRestarts
[16:20:44.974]                           grepl <- base::grepl
[16:20:44.974]                           restarts <- computeRestarts(cond)
[16:20:44.974]                           for (restart in restarts) {
[16:20:44.974]                             name <- restart$name
[16:20:44.974]                             if (is.null(name)) 
[16:20:44.974]                               next
[16:20:44.974]                             if (!grepl(pattern, name)) 
[16:20:44.974]                               next
[16:20:44.974]                             invokeRestart(restart)
[16:20:44.974]                             muffled <- TRUE
[16:20:44.974]                             break
[16:20:44.974]                           }
[16:20:44.974]                         }
[16:20:44.974]                       }
[16:20:44.974]                       invisible(muffled)
[16:20:44.974]                     }
[16:20:44.974]                     muffleCondition(cond, pattern = "^muffle")
[16:20:44.974]                   }
[16:20:44.974]                 }
[16:20:44.974]             }
[16:20:44.974]         }))
[16:20:44.974]     }, error = function(ex) {
[16:20:44.974]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:44.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:44.974]                 ...future.rng), started = ...future.startTime, 
[16:20:44.974]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:44.974]             version = "1.8"), class = "FutureResult")
[16:20:44.974]     }, finally = {
[16:20:44.974]         if (!identical(...future.workdir, getwd())) 
[16:20:44.974]             setwd(...future.workdir)
[16:20:44.974]         {
[16:20:44.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:44.974]                 ...future.oldOptions$nwarnings <- NULL
[16:20:44.974]             }
[16:20:44.974]             base::options(...future.oldOptions)
[16:20:44.974]             if (.Platform$OS.type == "windows") {
[16:20:44.974]                 old_names <- names(...future.oldEnvVars)
[16:20:44.974]                 envs <- base::Sys.getenv()
[16:20:44.974]                 names <- names(envs)
[16:20:44.974]                 common <- intersect(names, old_names)
[16:20:44.974]                 added <- setdiff(names, old_names)
[16:20:44.974]                 removed <- setdiff(old_names, names)
[16:20:44.974]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:44.974]                   envs[common]]
[16:20:44.974]                 NAMES <- toupper(changed)
[16:20:44.974]                 args <- list()
[16:20:44.974]                 for (kk in seq_along(NAMES)) {
[16:20:44.974]                   name <- changed[[kk]]
[16:20:44.974]                   NAME <- NAMES[[kk]]
[16:20:44.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.974]                     next
[16:20:44.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.974]                 }
[16:20:44.974]                 NAMES <- toupper(added)
[16:20:44.974]                 for (kk in seq_along(NAMES)) {
[16:20:44.974]                   name <- added[[kk]]
[16:20:44.974]                   NAME <- NAMES[[kk]]
[16:20:44.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.974]                     next
[16:20:44.974]                   args[[name]] <- ""
[16:20:44.974]                 }
[16:20:44.974]                 NAMES <- toupper(removed)
[16:20:44.974]                 for (kk in seq_along(NAMES)) {
[16:20:44.974]                   name <- removed[[kk]]
[16:20:44.974]                   NAME <- NAMES[[kk]]
[16:20:44.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:44.974]                     next
[16:20:44.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:44.974]                 }
[16:20:44.974]                 if (length(args) > 0) 
[16:20:44.974]                   base::do.call(base::Sys.setenv, args = args)
[16:20:44.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:44.974]             }
[16:20:44.974]             else {
[16:20:44.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:44.974]             }
[16:20:44.974]             {
[16:20:44.974]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:44.974]                   0L) {
[16:20:44.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:44.974]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:44.974]                   base::options(opts)
[16:20:44.974]                 }
[16:20:44.974]                 {
[16:20:44.974]                   {
[16:20:44.974]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:44.974]                     NULL
[16:20:44.974]                   }
[16:20:44.974]                   options(future.plan = NULL)
[16:20:44.974]                   if (is.na(NA_character_)) 
[16:20:44.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:44.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:44.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:44.974]                     .init = FALSE)
[16:20:44.974]                 }
[16:20:44.974]             }
[16:20:44.974]         }
[16:20:44.974]     })
[16:20:44.974]     if (TRUE) {
[16:20:44.974]         base::sink(type = "output", split = FALSE)
[16:20:44.974]         if (TRUE) {
[16:20:44.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:44.974]         }
[16:20:44.974]         else {
[16:20:44.974]             ...future.result["stdout"] <- base::list(NULL)
[16:20:44.974]         }
[16:20:44.974]         base::close(...future.stdout)
[16:20:44.974]         ...future.stdout <- NULL
[16:20:44.974]     }
[16:20:44.974]     ...future.result$conditions <- ...future.conditions
[16:20:44.974]     ...future.result$finished <- base::Sys.time()
[16:20:44.974]     ...future.result
[16:20:44.974] }
[16:20:44.978] requestCore(): workers = 2
[16:20:44.978] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:44.989] result() for MulticoreFuture ...
[16:20:44.990] result() for MulticoreFuture ...
[16:20:44.990] result() for MulticoreFuture ... done
[16:20:44.990] result() for MulticoreFuture ... done
[16:20:44.990] result() for MulticoreFuture ...
[16:20:44.990] result() for MulticoreFuture ... done
[16:20:44.993] MulticoreFuture started
[16:20:44.994] - Launch lazy future ... done
[16:20:44.994] run() for ‘MulticoreFuture’ ... done
[16:20:44.995] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55ed0c694b10> 
[16:20:44.995] List of future strategies:
[16:20:44.995] 1. sequential:
[16:20:44.995]    - args: function (..., envir = parent.frame())
[16:20:44.995]    - tweaked: FALSE
[16:20:44.995]    - call: NULL
[16:20:44.996] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55ed0cbab5a0> 
 - attr(*, "dim.")=[16:20:44.999] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
[16:20:44.999] List of future strategies:
[16:20:44.999] 1. multicore:
[16:20:44.999]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:44.999]    - tweaked: FALSE
[16:20:44.999]    - call: plan(strategy)
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:20:45.006] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:45.010] resolve() on list environment ...
[16:20:45.010]  recursive: 0
[16:20:45.011]  length: 6
[16:20:45.011]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:45.012] signalConditionsASAP(numeric, pos=1) ...
[16:20:45.012] - nx: 6
[16:20:45.012] - relay: TRUE
[16:20:45.012] - stdout: TRUE
[16:20:45.012] - signal: TRUE
[16:20:45.012] - resignal: FALSE
[16:20:45.012] - force: TRUE
[16:20:45.013] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.013] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.013]  - until=2
[16:20:45.013]  - relaying element #2
[16:20:45.013] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.013] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.013] signalConditionsASAP(NULL, pos=1) ... done
[16:20:45.014]  length: 5 (resolved future 1)
[16:20:45.014] Future #2
[16:20:45.014] result() for MulticoreFuture ...
[16:20:45.014] result() for MulticoreFuture ... done
[16:20:45.014] result() for MulticoreFuture ...
[16:20:45.014] result() for MulticoreFuture ... done
[16:20:45.015] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:45.015] - nx: 6
[16:20:45.015] - relay: TRUE
[16:20:45.015] - stdout: TRUE
[16:20:45.015] - signal: TRUE
[16:20:45.015] - resignal: FALSE
[16:20:45.015] - force: TRUE
[16:20:45.015] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.015] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.016]  - until=2
[16:20:45.016]  - relaying element #2
[16:20:45.016] result() for MulticoreFuture ...
[16:20:45.016] result() for MulticoreFuture ... done
[16:20:45.016] result() for MulticoreFuture ...
[16:20:45.016] result() for MulticoreFuture ... done
[16:20:45.016] result() for MulticoreFuture ...
[16:20:45.017] result() for MulticoreFuture ... done
[16:20:45.017] result() for MulticoreFuture ...
[16:20:45.017] result() for MulticoreFuture ... done
[16:20:45.017] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.017] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.017] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:45.017]  length: 4 (resolved future 2)
[16:20:45.018] Future #3
[16:20:45.018] result() for MulticoreFuture ...
[16:20:45.019] result() for MulticoreFuture ...
[16:20:45.019] result() for MulticoreFuture ... done
[16:20:45.019] result() for MulticoreFuture ... done
[16:20:45.019] result() for MulticoreFuture ...
[16:20:45.019] result() for MulticoreFuture ... done
[16:20:45.019] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:45.020] - nx: 6
[16:20:45.020] - relay: TRUE
[16:20:45.020] - stdout: TRUE
[16:20:45.020] - signal: TRUE
[16:20:45.020] - resignal: FALSE
[16:20:45.020] - force: TRUE
[16:20:45.020] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.020] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.021]  - until=3
[16:20:45.021]  - relaying element #3
[16:20:45.021] result() for MulticoreFuture ...
[16:20:45.021] result() for MulticoreFuture ... done
[16:20:45.021] result() for MulticoreFuture ...
[16:20:45.021] result() for MulticoreFuture ... done
[16:20:45.021] result() for MulticoreFuture ...
[16:20:45.021] result() for MulticoreFuture ... done
[16:20:45.022] result() for MulticoreFuture ...
[16:20:45.022] result() for MulticoreFuture ... done
[16:20:45.022] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.022] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.022] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:45.022]  length: 3 (resolved future 3)
[16:20:45.023] Future #4
[16:20:45.023] result() for MulticoreFuture ...
[16:20:45.023] result() for MulticoreFuture ...
[16:20:45.024] result() for MulticoreFuture ... done
[16:20:45.024] result() for MulticoreFuture ... done
[16:20:45.024] result() for MulticoreFuture ...
[16:20:45.024] result() for MulticoreFuture ... done
[16:20:45.024] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:45.025] - nx: 6
[16:20:45.025] - relay: TRUE
[16:20:45.025] - stdout: TRUE
[16:20:45.025] - signal: TRUE
[16:20:45.025] - resignal: FALSE
[16:20:45.025] - force: TRUE
[16:20:45.025] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.026] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.026]  - until=4
[16:20:45.026]  - relaying element #4
[16:20:45.026] result() for MulticoreFuture ...
[16:20:45.026] result() for MulticoreFuture ... done
[16:20:45.026] result() for MulticoreFuture ...
[16:20:45.027] result() for MulticoreFuture ... done
[16:20:45.027] result() for MulticoreFuture ...
[16:20:45.027] result() for MulticoreFuture ... done
[16:20:45.027] result() for MulticoreFuture ...
[16:20:45.027] result() for MulticoreFuture ... done
[16:20:45.027] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.028] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.028] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:45.028]  length: 2 (resolved future 4)
[16:20:45.028] signalConditionsASAP(NULL, pos=5) ...
[16:20:45.028] - nx: 6
[16:20:45.028] - relay: TRUE
[16:20:45.028] - stdout: TRUE
[16:20:45.028] - signal: TRUE
[16:20:45.028] - resignal: FALSE
[16:20:45.029] - force: TRUE
[16:20:45.029] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.029] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.029]  - until=6
[16:20:45.029]  - relaying element #6
[16:20:45.029] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.029] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.029] signalConditionsASAP(NULL, pos=5) ... done
[16:20:45.029]  length: 1 (resolved future 5)
[16:20:45.030] signalConditionsASAP(numeric, pos=6) ...
[16:20:45.030] - nx: 6
[16:20:45.030] - relay: TRUE
[16:20:45.030] - stdout: TRUE
[16:20:45.030] - signal: TRUE
[16:20:45.030] - resignal: FALSE
[16:20:45.030] - force: TRUE
[16:20:45.030] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.030] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.030]  - until=6
[16:20:45.031] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.031] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.031] signalConditionsASAP(numeric, pos=6) ... done
[16:20:45.031]  length: 0 (resolved future 6)
[16:20:45.031] Relaying remaining futures
[16:20:45.031] signalConditionsASAP(NULL, pos=0) ...
[16:20:45.031] - nx: 6
[16:20:45.031] - relay: TRUE
[16:20:45.031] - stdout: TRUE
[16:20:45.031] - signal: TRUE
[16:20:45.032] - resignal: FALSE
[16:20:45.032] - force: TRUE
[16:20:45.032] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.032] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:45.032] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.032] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.032] signalConditionsASAP(NULL, pos=0) ... done
[16:20:45.032] resolve() on list environment ... DONE
[16:20:45.032] result() for MulticoreFuture ...
[16:20:45.033] result() for MulticoreFuture ... done
[16:20:45.033] result() for MulticoreFuture ...
[16:20:45.033] result() for MulticoreFuture ... done
[16:20:45.033] result() for MulticoreFuture ...
[16:20:45.033] result() for MulticoreFuture ... done
[16:20:45.033] result() for MulticoreFuture ...
[16:20:45.033] result() for MulticoreFuture ... done
[16:20:45.034] result() for MulticoreFuture ...
[16:20:45.034] result() for MulticoreFuture ... done
[16:20:45.034] result() for MulticoreFuture ...
[16:20:45.034] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0d17f590> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:20:45.036] getGlobalsAndPackages() ...
[16:20:45.036] Searching for globals...
[16:20:45.036] 
[16:20:45.037] Searching for globals ... DONE
[16:20:45.037] - globals: [0] <none>
[16:20:45.037] getGlobalsAndPackages() ... DONE
[16:20:45.037] run() for ‘Future’ ...
[16:20:45.037] - state: ‘created’
[16:20:45.037] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.042] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:45.043]   - Field: ‘label’
[16:20:45.043]   - Field: ‘local’
[16:20:45.043]   - Field: ‘owner’
[16:20:45.043]   - Field: ‘envir’
[16:20:45.043]   - Field: ‘workers’
[16:20:45.043]   - Field: ‘packages’
[16:20:45.043]   - Field: ‘gc’
[16:20:45.043]   - Field: ‘job’
[16:20:45.043]   - Field: ‘conditions’
[16:20:45.044]   - Field: ‘expr’
[16:20:45.044]   - Field: ‘uuid’
[16:20:45.044]   - Field: ‘seed’
[16:20:45.044]   - Field: ‘version’
[16:20:45.044]   - Field: ‘result’
[16:20:45.044]   - Field: ‘asynchronous’
[16:20:45.044]   - Field: ‘calls’
[16:20:45.044]   - Field: ‘globals’
[16:20:45.045]   - Field: ‘stdout’
[16:20:45.045]   - Field: ‘earlySignal’
[16:20:45.045]   - Field: ‘lazy’
[16:20:45.045]   - Field: ‘state’
[16:20:45.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:45.045] - Launch lazy future ...
[16:20:45.045] Packages needed by the future expression (n = 0): <none>
[16:20:45.046] Packages needed by future strategies (n = 0): <none>
[16:20:45.046] {
[16:20:45.046]     {
[16:20:45.046]         {
[16:20:45.046]             ...future.startTime <- base::Sys.time()
[16:20:45.046]             {
[16:20:45.046]                 {
[16:20:45.046]                   {
[16:20:45.046]                     {
[16:20:45.046]                       base::local({
[16:20:45.046]                         has_future <- base::requireNamespace("future", 
[16:20:45.046]                           quietly = TRUE)
[16:20:45.046]                         if (has_future) {
[16:20:45.046]                           ns <- base::getNamespace("future")
[16:20:45.046]                           version <- ns[[".package"]][["version"]]
[16:20:45.046]                           if (is.null(version)) 
[16:20:45.046]                             version <- utils::packageVersion("future")
[16:20:45.046]                         }
[16:20:45.046]                         else {
[16:20:45.046]                           version <- NULL
[16:20:45.046]                         }
[16:20:45.046]                         if (!has_future || version < "1.8.0") {
[16:20:45.046]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.046]                             "", base::R.version$version.string), 
[16:20:45.046]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.046]                               "release", "version")], collapse = " "), 
[16:20:45.046]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.046]                             info)
[16:20:45.046]                           info <- base::paste(info, collapse = "; ")
[16:20:45.046]                           if (!has_future) {
[16:20:45.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.046]                               info)
[16:20:45.046]                           }
[16:20:45.046]                           else {
[16:20:45.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.046]                               info, version)
[16:20:45.046]                           }
[16:20:45.046]                           base::stop(msg)
[16:20:45.046]                         }
[16:20:45.046]                       })
[16:20:45.046]                     }
[16:20:45.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.046]                     base::options(mc.cores = 1L)
[16:20:45.046]                   }
[16:20:45.046]                   ...future.strategy.old <- future::plan("list")
[16:20:45.046]                   options(future.plan = NULL)
[16:20:45.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.046]                 }
[16:20:45.046]                 ...future.workdir <- getwd()
[16:20:45.046]             }
[16:20:45.046]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.046]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.046]         }
[16:20:45.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.046]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.046]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.046]             base::names(...future.oldOptions))
[16:20:45.046]     }
[16:20:45.046]     if (FALSE) {
[16:20:45.046]     }
[16:20:45.046]     else {
[16:20:45.046]         if (TRUE) {
[16:20:45.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.046]                 open = "w")
[16:20:45.046]         }
[16:20:45.046]         else {
[16:20:45.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.046]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.046]         }
[16:20:45.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.046]             base::sink(type = "output", split = FALSE)
[16:20:45.046]             base::close(...future.stdout)
[16:20:45.046]         }, add = TRUE)
[16:20:45.046]     }
[16:20:45.046]     ...future.frame <- base::sys.nframe()
[16:20:45.046]     ...future.conditions <- base::list()
[16:20:45.046]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.046]     if (FALSE) {
[16:20:45.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.046]     }
[16:20:45.046]     ...future.result <- base::tryCatch({
[16:20:45.046]         base::withCallingHandlers({
[16:20:45.046]             ...future.value <- base::withVisible(base::local({
[16:20:45.046]                 withCallingHandlers({
[16:20:45.046]                   2
[16:20:45.046]                 }, immediateCondition = function(cond) {
[16:20:45.046]                   save_rds <- function (object, pathname, ...) 
[16:20:45.046]                   {
[16:20:45.046]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:45.046]                     if (file_test("-f", pathname_tmp)) {
[16:20:45.046]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.046]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:45.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.046]                         fi_tmp[["mtime"]])
[16:20:45.046]                     }
[16:20:45.046]                     tryCatch({
[16:20:45.046]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:45.046]                     }, error = function(ex) {
[16:20:45.046]                       msg <- conditionMessage(ex)
[16:20:45.046]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.046]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:45.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.046]                         fi_tmp[["mtime"]], msg)
[16:20:45.046]                       ex$message <- msg
[16:20:45.046]                       stop(ex)
[16:20:45.046]                     })
[16:20:45.046]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:45.046]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:45.046]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:45.046]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.046]                       fi <- file.info(pathname)
[16:20:45.046]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:45.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.046]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:45.046]                         fi[["size"]], fi[["mtime"]])
[16:20:45.046]                       stop(msg)
[16:20:45.046]                     }
[16:20:45.046]                     invisible(pathname)
[16:20:45.046]                   }
[16:20:45.046]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:45.046]                     rootPath = tempdir()) 
[16:20:45.046]                   {
[16:20:45.046]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:45.046]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:45.046]                       tmpdir = path, fileext = ".rds")
[16:20:45.046]                     save_rds(obj, file)
[16:20:45.046]                   }
[16:20:45.046]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:45.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.046]                   {
[16:20:45.046]                     inherits <- base::inherits
[16:20:45.046]                     invokeRestart <- base::invokeRestart
[16:20:45.046]                     is.null <- base::is.null
[16:20:45.046]                     muffled <- FALSE
[16:20:45.046]                     if (inherits(cond, "message")) {
[16:20:45.046]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.046]                       if (muffled) 
[16:20:45.046]                         invokeRestart("muffleMessage")
[16:20:45.046]                     }
[16:20:45.046]                     else if (inherits(cond, "warning")) {
[16:20:45.046]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.046]                       if (muffled) 
[16:20:45.046]                         invokeRestart("muffleWarning")
[16:20:45.046]                     }
[16:20:45.046]                     else if (inherits(cond, "condition")) {
[16:20:45.046]                       if (!is.null(pattern)) {
[16:20:45.046]                         computeRestarts <- base::computeRestarts
[16:20:45.046]                         grepl <- base::grepl
[16:20:45.046]                         restarts <- computeRestarts(cond)
[16:20:45.046]                         for (restart in restarts) {
[16:20:45.046]                           name <- restart$name
[16:20:45.046]                           if (is.null(name)) 
[16:20:45.046]                             next
[16:20:45.046]                           if (!grepl(pattern, name)) 
[16:20:45.046]                             next
[16:20:45.046]                           invokeRestart(restart)
[16:20:45.046]                           muffled <- TRUE
[16:20:45.046]                           break
[16:20:45.046]                         }
[16:20:45.046]                       }
[16:20:45.046]                     }
[16:20:45.046]                     invisible(muffled)
[16:20:45.046]                   }
[16:20:45.046]                   muffleCondition(cond)
[16:20:45.046]                 })
[16:20:45.046]             }))
[16:20:45.046]             future::FutureResult(value = ...future.value$value, 
[16:20:45.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.046]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.046]                     ...future.globalenv.names))
[16:20:45.046]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.046]         }, condition = base::local({
[16:20:45.046]             c <- base::c
[16:20:45.046]             inherits <- base::inherits
[16:20:45.046]             invokeRestart <- base::invokeRestart
[16:20:45.046]             length <- base::length
[16:20:45.046]             list <- base::list
[16:20:45.046]             seq.int <- base::seq.int
[16:20:45.046]             signalCondition <- base::signalCondition
[16:20:45.046]             sys.calls <- base::sys.calls
[16:20:45.046]             `[[` <- base::`[[`
[16:20:45.046]             `+` <- base::`+`
[16:20:45.046]             `<<-` <- base::`<<-`
[16:20:45.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.046]                   3L)]
[16:20:45.046]             }
[16:20:45.046]             function(cond) {
[16:20:45.046]                 is_error <- inherits(cond, "error")
[16:20:45.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.046]                   NULL)
[16:20:45.046]                 if (is_error) {
[16:20:45.046]                   sessionInformation <- function() {
[16:20:45.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.046]                       search = base::search(), system = base::Sys.info())
[16:20:45.046]                   }
[16:20:45.046]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.046]                     cond$call), session = sessionInformation(), 
[16:20:45.046]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.046]                   signalCondition(cond)
[16:20:45.046]                 }
[16:20:45.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.046]                 "immediateCondition"))) {
[16:20:45.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.046]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.046]                   if (TRUE && !signal) {
[16:20:45.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.046]                     {
[16:20:45.046]                       inherits <- base::inherits
[16:20:45.046]                       invokeRestart <- base::invokeRestart
[16:20:45.046]                       is.null <- base::is.null
[16:20:45.046]                       muffled <- FALSE
[16:20:45.046]                       if (inherits(cond, "message")) {
[16:20:45.046]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.046]                         if (muffled) 
[16:20:45.046]                           invokeRestart("muffleMessage")
[16:20:45.046]                       }
[16:20:45.046]                       else if (inherits(cond, "warning")) {
[16:20:45.046]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.046]                         if (muffled) 
[16:20:45.046]                           invokeRestart("muffleWarning")
[16:20:45.046]                       }
[16:20:45.046]                       else if (inherits(cond, "condition")) {
[16:20:45.046]                         if (!is.null(pattern)) {
[16:20:45.046]                           computeRestarts <- base::computeRestarts
[16:20:45.046]                           grepl <- base::grepl
[16:20:45.046]                           restarts <- computeRestarts(cond)
[16:20:45.046]                           for (restart in restarts) {
[16:20:45.046]                             name <- restart$name
[16:20:45.046]                             if (is.null(name)) 
[16:20:45.046]                               next
[16:20:45.046]                             if (!grepl(pattern, name)) 
[16:20:45.046]                               next
[16:20:45.046]                             invokeRestart(restart)
[16:20:45.046]                             muffled <- TRUE
[16:20:45.046]                             break
[16:20:45.046]                           }
[16:20:45.046]                         }
[16:20:45.046]                       }
[16:20:45.046]                       invisible(muffled)
[16:20:45.046]                     }
[16:20:45.046]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.046]                   }
[16:20:45.046]                 }
[16:20:45.046]                 else {
[16:20:45.046]                   if (TRUE) {
[16:20:45.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.046]                     {
[16:20:45.046]                       inherits <- base::inherits
[16:20:45.046]                       invokeRestart <- base::invokeRestart
[16:20:45.046]                       is.null <- base::is.null
[16:20:45.046]                       muffled <- FALSE
[16:20:45.046]                       if (inherits(cond, "message")) {
[16:20:45.046]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.046]                         if (muffled) 
[16:20:45.046]                           invokeRestart("muffleMessage")
[16:20:45.046]                       }
[16:20:45.046]                       else if (inherits(cond, "warning")) {
[16:20:45.046]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.046]                         if (muffled) 
[16:20:45.046]                           invokeRestart("muffleWarning")
[16:20:45.046]                       }
[16:20:45.046]                       else if (inherits(cond, "condition")) {
[16:20:45.046]                         if (!is.null(pattern)) {
[16:20:45.046]                           computeRestarts <- base::computeRestarts
[16:20:45.046]                           grepl <- base::grepl
[16:20:45.046]                           restarts <- computeRestarts(cond)
[16:20:45.046]                           for (restart in restarts) {
[16:20:45.046]                             name <- restart$name
[16:20:45.046]                             if (is.null(name)) 
[16:20:45.046]                               next
[16:20:45.046]                             if (!grepl(pattern, name)) 
[16:20:45.046]                               next
[16:20:45.046]                             invokeRestart(restart)
[16:20:45.046]                             muffled <- TRUE
[16:20:45.046]                             break
[16:20:45.046]                           }
[16:20:45.046]                         }
[16:20:45.046]                       }
[16:20:45.046]                       invisible(muffled)
[16:20:45.046]                     }
[16:20:45.046]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.046]                   }
[16:20:45.046]                 }
[16:20:45.046]             }
[16:20:45.046]         }))
[16:20:45.046]     }, error = function(ex) {
[16:20:45.046]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.046]                 ...future.rng), started = ...future.startTime, 
[16:20:45.046]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.046]             version = "1.8"), class = "FutureResult")
[16:20:45.046]     }, finally = {
[16:20:45.046]         if (!identical(...future.workdir, getwd())) 
[16:20:45.046]             setwd(...future.workdir)
[16:20:45.046]         {
[16:20:45.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.046]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.046]             }
[16:20:45.046]             base::options(...future.oldOptions)
[16:20:45.046]             if (.Platform$OS.type == "windows") {
[16:20:45.046]                 old_names <- names(...future.oldEnvVars)
[16:20:45.046]                 envs <- base::Sys.getenv()
[16:20:45.046]                 names <- names(envs)
[16:20:45.046]                 common <- intersect(names, old_names)
[16:20:45.046]                 added <- setdiff(names, old_names)
[16:20:45.046]                 removed <- setdiff(old_names, names)
[16:20:45.046]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.046]                   envs[common]]
[16:20:45.046]                 NAMES <- toupper(changed)
[16:20:45.046]                 args <- list()
[16:20:45.046]                 for (kk in seq_along(NAMES)) {
[16:20:45.046]                   name <- changed[[kk]]
[16:20:45.046]                   NAME <- NAMES[[kk]]
[16:20:45.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.046]                     next
[16:20:45.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.046]                 }
[16:20:45.046]                 NAMES <- toupper(added)
[16:20:45.046]                 for (kk in seq_along(NAMES)) {
[16:20:45.046]                   name <- added[[kk]]
[16:20:45.046]                   NAME <- NAMES[[kk]]
[16:20:45.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.046]                     next
[16:20:45.046]                   args[[name]] <- ""
[16:20:45.046]                 }
[16:20:45.046]                 NAMES <- toupper(removed)
[16:20:45.046]                 for (kk in seq_along(NAMES)) {
[16:20:45.046]                   name <- removed[[kk]]
[16:20:45.046]                   NAME <- NAMES[[kk]]
[16:20:45.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.046]                     next
[16:20:45.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.046]                 }
[16:20:45.046]                 if (length(args) > 0) 
[16:20:45.046]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.046]             }
[16:20:45.046]             else {
[16:20:45.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.046]             }
[16:20:45.046]             {
[16:20:45.046]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.046]                   0L) {
[16:20:45.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.046]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.046]                   base::options(opts)
[16:20:45.046]                 }
[16:20:45.046]                 {
[16:20:45.046]                   {
[16:20:45.046]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.046]                     NULL
[16:20:45.046]                   }
[16:20:45.046]                   options(future.plan = NULL)
[16:20:45.046]                   if (is.na(NA_character_)) 
[16:20:45.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.046]                     .init = FALSE)
[16:20:45.046]                 }
[16:20:45.046]             }
[16:20:45.046]         }
[16:20:45.046]     })
[16:20:45.046]     if (TRUE) {
[16:20:45.046]         base::sink(type = "output", split = FALSE)
[16:20:45.046]         if (TRUE) {
[16:20:45.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.046]         }
[16:20:45.046]         else {
[16:20:45.046]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.046]         }
[16:20:45.046]         base::close(...future.stdout)
[16:20:45.046]         ...future.stdout <- NULL
[16:20:45.046]     }
[16:20:45.046]     ...future.result$conditions <- ...future.conditions
[16:20:45.046]     ...future.result$finished <- base::Sys.time()
[16:20:45.046]     ...future.result
[16:20:45.046] }
[16:20:45.049] requestCore(): workers = 2
[16:20:45.051] MulticoreFuture started
[16:20:45.051] - Launch lazy future ... done
[16:20:45.052] run() for ‘MulticoreFuture’ ... done
[16:20:45.052] getGlobalsAndPackages() ...
[16:20:45.052] Searching for globals...
[16:20:45.052] plan(): Setting new future strategy stack:
[16:20:45.053] 
[16:20:45.053] Searching for globals ... DONE
[16:20:45.053] List of future strategies:
[16:20:45.053] 1. sequential:
[16:20:45.053]    - args: function (..., envir = parent.frame())
[16:20:45.053]    - tweaked: FALSE
[16:20:45.053]    - call: NULL
[16:20:45.053] - globals: [0] <none>
[16:20:45.054] getGlobalsAndPackages() ... DONE
[16:20:45.054] plan(): nbrOfWorkers() = 1
[16:20:45.054] run() for ‘Future’ ...
[16:20:45.054] - state: ‘created’
[16:20:45.054] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.056] plan(): Setting new future strategy stack:
[16:20:45.056] List of future strategies:
[16:20:45.056] 1. multicore:
[16:20:45.056]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:45.056]    - tweaked: FALSE
[16:20:45.056]    - call: plan(strategy)
[16:20:45.060] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:45.061] plan(): nbrOfWorkers() = 2
[16:20:45.061]   - Field: ‘label’
[16:20:45.061]   - Field: ‘local’
[16:20:45.061]   - Field: ‘owner’
[16:20:45.061]   - Field: ‘envir’
[16:20:45.061]   - Field: ‘workers’
[16:20:45.061]   - Field: ‘packages’
[16:20:45.062]   - Field: ‘gc’
[16:20:45.062]   - Field: ‘job’
[16:20:45.062]   - Field: ‘conditions’
[16:20:45.062]   - Field: ‘expr’
[16:20:45.062]   - Field: ‘uuid’
[16:20:45.062]   - Field: ‘seed’
[16:20:45.062]   - Field: ‘version’
[16:20:45.063]   - Field: ‘result’
[16:20:45.063]   - Field: ‘asynchronous’
[16:20:45.063]   - Field: ‘calls’
[16:20:45.063]   - Field: ‘globals’
[16:20:45.063]   - Field: ‘stdout’
[16:20:45.063]   - Field: ‘earlySignal’
[16:20:45.063]   - Field: ‘lazy’
[16:20:45.064]   - Field: ‘state’
[16:20:45.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:45.064] - Launch lazy future ...
[16:20:45.064] Packages needed by the future expression (n = 0): <none>
[16:20:45.065] Packages needed by future strategies (n = 0): <none>
[16:20:45.074] {
[16:20:45.074]     {
[16:20:45.074]         {
[16:20:45.074]             ...future.startTime <- base::Sys.time()
[16:20:45.074]             {
[16:20:45.074]                 {
[16:20:45.074]                   {
[16:20:45.074]                     {
[16:20:45.074]                       base::local({
[16:20:45.074]                         has_future <- base::requireNamespace("future", 
[16:20:45.074]                           quietly = TRUE)
[16:20:45.074]                         if (has_future) {
[16:20:45.074]                           ns <- base::getNamespace("future")
[16:20:45.074]                           version <- ns[[".package"]][["version"]]
[16:20:45.074]                           if (is.null(version)) 
[16:20:45.074]                             version <- utils::packageVersion("future")
[16:20:45.074]                         }
[16:20:45.074]                         else {
[16:20:45.074]                           version <- NULL
[16:20:45.074]                         }
[16:20:45.074]                         if (!has_future || version < "1.8.0") {
[16:20:45.074]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.074]                             "", base::R.version$version.string), 
[16:20:45.074]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.074]                               "release", "version")], collapse = " "), 
[16:20:45.074]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.074]                             info)
[16:20:45.074]                           info <- base::paste(info, collapse = "; ")
[16:20:45.074]                           if (!has_future) {
[16:20:45.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.074]                               info)
[16:20:45.074]                           }
[16:20:45.074]                           else {
[16:20:45.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.074]                               info, version)
[16:20:45.074]                           }
[16:20:45.074]                           base::stop(msg)
[16:20:45.074]                         }
[16:20:45.074]                       })
[16:20:45.074]                     }
[16:20:45.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.074]                     base::options(mc.cores = 1L)
[16:20:45.074]                   }
[16:20:45.074]                   ...future.strategy.old <- future::plan("list")
[16:20:45.074]                   options(future.plan = NULL)
[16:20:45.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.074]                 }
[16:20:45.074]                 ...future.workdir <- getwd()
[16:20:45.074]             }
[16:20:45.074]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.074]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.074]         }
[16:20:45.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.074]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.074]             base::names(...future.oldOptions))
[16:20:45.074]     }
[16:20:45.074]     if (FALSE) {
[16:20:45.074]     }
[16:20:45.074]     else {
[16:20:45.074]         if (TRUE) {
[16:20:45.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.074]                 open = "w")
[16:20:45.074]         }
[16:20:45.074]         else {
[16:20:45.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.074]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.074]         }
[16:20:45.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.074]             base::sink(type = "output", split = FALSE)
[16:20:45.074]             base::close(...future.stdout)
[16:20:45.074]         }, add = TRUE)
[16:20:45.074]     }
[16:20:45.074]     ...future.frame <- base::sys.nframe()
[16:20:45.074]     ...future.conditions <- base::list()
[16:20:45.074]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.074]     if (FALSE) {
[16:20:45.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.074]     }
[16:20:45.074]     ...future.result <- base::tryCatch({
[16:20:45.074]         base::withCallingHandlers({
[16:20:45.074]             ...future.value <- base::withVisible(base::local({
[16:20:45.074]                 withCallingHandlers({
[16:20:45.074]                   NULL
[16:20:45.074]                 }, immediateCondition = function(cond) {
[16:20:45.074]                   save_rds <- function (object, pathname, ...) 
[16:20:45.074]                   {
[16:20:45.074]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:45.074]                     if (file_test("-f", pathname_tmp)) {
[16:20:45.074]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.074]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:45.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.074]                         fi_tmp[["mtime"]])
[16:20:45.074]                     }
[16:20:45.074]                     tryCatch({
[16:20:45.074]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:45.074]                     }, error = function(ex) {
[16:20:45.074]                       msg <- conditionMessage(ex)
[16:20:45.074]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.074]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:45.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.074]                         fi_tmp[["mtime"]], msg)
[16:20:45.074]                       ex$message <- msg
[16:20:45.074]                       stop(ex)
[16:20:45.074]                     })
[16:20:45.074]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:45.074]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:45.074]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:45.074]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.074]                       fi <- file.info(pathname)
[16:20:45.074]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:45.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.074]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:45.074]                         fi[["size"]], fi[["mtime"]])
[16:20:45.074]                       stop(msg)
[16:20:45.074]                     }
[16:20:45.074]                     invisible(pathname)
[16:20:45.074]                   }
[16:20:45.074]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:45.074]                     rootPath = tempdir()) 
[16:20:45.074]                   {
[16:20:45.074]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:45.074]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:45.074]                       tmpdir = path, fileext = ".rds")
[16:20:45.074]                     save_rds(obj, file)
[16:20:45.074]                   }
[16:20:45.074]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:45.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.074]                   {
[16:20:45.074]                     inherits <- base::inherits
[16:20:45.074]                     invokeRestart <- base::invokeRestart
[16:20:45.074]                     is.null <- base::is.null
[16:20:45.074]                     muffled <- FALSE
[16:20:45.074]                     if (inherits(cond, "message")) {
[16:20:45.074]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.074]                       if (muffled) 
[16:20:45.074]                         invokeRestart("muffleMessage")
[16:20:45.074]                     }
[16:20:45.074]                     else if (inherits(cond, "warning")) {
[16:20:45.074]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.074]                       if (muffled) 
[16:20:45.074]                         invokeRestart("muffleWarning")
[16:20:45.074]                     }
[16:20:45.074]                     else if (inherits(cond, "condition")) {
[16:20:45.074]                       if (!is.null(pattern)) {
[16:20:45.074]                         computeRestarts <- base::computeRestarts
[16:20:45.074]                         grepl <- base::grepl
[16:20:45.074]                         restarts <- computeRestarts(cond)
[16:20:45.074]                         for (restart in restarts) {
[16:20:45.074]                           name <- restart$name
[16:20:45.074]                           if (is.null(name)) 
[16:20:45.074]                             next
[16:20:45.074]                           if (!grepl(pattern, name)) 
[16:20:45.074]                             next
[16:20:45.074]                           invokeRestart(restart)
[16:20:45.074]                           muffled <- TRUE
[16:20:45.074]                           break
[16:20:45.074]                         }
[16:20:45.074]                       }
[16:20:45.074]                     }
[16:20:45.074]                     invisible(muffled)
[16:20:45.074]                   }
[16:20:45.074]                   muffleCondition(cond)
[16:20:45.074]                 })
[16:20:45.074]             }))
[16:20:45.074]             future::FutureResult(value = ...future.value$value, 
[16:20:45.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.074]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.074]                     ...future.globalenv.names))
[16:20:45.074]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.074]         }, condition = base::local({
[16:20:45.074]             c <- base::c
[16:20:45.074]             inherits <- base::inherits
[16:20:45.074]             invokeRestart <- base::invokeRestart
[16:20:45.074]             length <- base::length
[16:20:45.074]             list <- base::list
[16:20:45.074]             seq.int <- base::seq.int
[16:20:45.074]             signalCondition <- base::signalCondition
[16:20:45.074]             sys.calls <- base::sys.calls
[16:20:45.074]             `[[` <- base::`[[`
[16:20:45.074]             `+` <- base::`+`
[16:20:45.074]             `<<-` <- base::`<<-`
[16:20:45.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.074]                   3L)]
[16:20:45.074]             }
[16:20:45.074]             function(cond) {
[16:20:45.074]                 is_error <- inherits(cond, "error")
[16:20:45.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.074]                   NULL)
[16:20:45.074]                 if (is_error) {
[16:20:45.074]                   sessionInformation <- function() {
[16:20:45.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.074]                       search = base::search(), system = base::Sys.info())
[16:20:45.074]                   }
[16:20:45.074]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.074]                     cond$call), session = sessionInformation(), 
[16:20:45.074]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.074]                   signalCondition(cond)
[16:20:45.074]                 }
[16:20:45.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.074]                 "immediateCondition"))) {
[16:20:45.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.074]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.074]                   if (TRUE && !signal) {
[16:20:45.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.074]                     {
[16:20:45.074]                       inherits <- base::inherits
[16:20:45.074]                       invokeRestart <- base::invokeRestart
[16:20:45.074]                       is.null <- base::is.null
[16:20:45.074]                       muffled <- FALSE
[16:20:45.074]                       if (inherits(cond, "message")) {
[16:20:45.074]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.074]                         if (muffled) 
[16:20:45.074]                           invokeRestart("muffleMessage")
[16:20:45.074]                       }
[16:20:45.074]                       else if (inherits(cond, "warning")) {
[16:20:45.074]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.074]                         if (muffled) 
[16:20:45.074]                           invokeRestart("muffleWarning")
[16:20:45.074]                       }
[16:20:45.074]                       else if (inherits(cond, "condition")) {
[16:20:45.074]                         if (!is.null(pattern)) {
[16:20:45.074]                           computeRestarts <- base::computeRestarts
[16:20:45.074]                           grepl <- base::grepl
[16:20:45.074]                           restarts <- computeRestarts(cond)
[16:20:45.074]                           for (restart in restarts) {
[16:20:45.074]                             name <- restart$name
[16:20:45.074]                             if (is.null(name)) 
[16:20:45.074]                               next
[16:20:45.074]                             if (!grepl(pattern, name)) 
[16:20:45.074]                               next
[16:20:45.074]                             invokeRestart(restart)
[16:20:45.074]                             muffled <- TRUE
[16:20:45.074]                             break
[16:20:45.074]                           }
[16:20:45.074]                         }
[16:20:45.074]                       }
[16:20:45.074]                       invisible(muffled)
[16:20:45.074]                     }
[16:20:45.074]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.074]                   }
[16:20:45.074]                 }
[16:20:45.074]                 else {
[16:20:45.074]                   if (TRUE) {
[16:20:45.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.074]                     {
[16:20:45.074]                       inherits <- base::inherits
[16:20:45.074]                       invokeRestart <- base::invokeRestart
[16:20:45.074]                       is.null <- base::is.null
[16:20:45.074]                       muffled <- FALSE
[16:20:45.074]                       if (inherits(cond, "message")) {
[16:20:45.074]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.074]                         if (muffled) 
[16:20:45.074]                           invokeRestart("muffleMessage")
[16:20:45.074]                       }
[16:20:45.074]                       else if (inherits(cond, "warning")) {
[16:20:45.074]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.074]                         if (muffled) 
[16:20:45.074]                           invokeRestart("muffleWarning")
[16:20:45.074]                       }
[16:20:45.074]                       else if (inherits(cond, "condition")) {
[16:20:45.074]                         if (!is.null(pattern)) {
[16:20:45.074]                           computeRestarts <- base::computeRestarts
[16:20:45.074]                           grepl <- base::grepl
[16:20:45.074]                           restarts <- computeRestarts(cond)
[16:20:45.074]                           for (restart in restarts) {
[16:20:45.074]                             name <- restart$name
[16:20:45.074]                             if (is.null(name)) 
[16:20:45.074]                               next
[16:20:45.074]                             if (!grepl(pattern, name)) 
[16:20:45.074]                               next
[16:20:45.074]                             invokeRestart(restart)
[16:20:45.074]                             muffled <- TRUE
[16:20:45.074]                             break
[16:20:45.074]                           }
[16:20:45.074]                         }
[16:20:45.074]                       }
[16:20:45.074]                       invisible(muffled)
[16:20:45.074]                     }
[16:20:45.074]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.074]                   }
[16:20:45.074]                 }
[16:20:45.074]             }
[16:20:45.074]         }))
[16:20:45.074]     }, error = function(ex) {
[16:20:45.074]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.074]                 ...future.rng), started = ...future.startTime, 
[16:20:45.074]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.074]             version = "1.8"), class = "FutureResult")
[16:20:45.074]     }, finally = {
[16:20:45.074]         if (!identical(...future.workdir, getwd())) 
[16:20:45.074]             setwd(...future.workdir)
[16:20:45.074]         {
[16:20:45.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.074]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.074]             }
[16:20:45.074]             base::options(...future.oldOptions)
[16:20:45.074]             if (.Platform$OS.type == "windows") {
[16:20:45.074]                 old_names <- names(...future.oldEnvVars)
[16:20:45.074]                 envs <- base::Sys.getenv()
[16:20:45.074]                 names <- names(envs)
[16:20:45.074]                 common <- intersect(names, old_names)
[16:20:45.074]                 added <- setdiff(names, old_names)
[16:20:45.074]                 removed <- setdiff(old_names, names)
[16:20:45.074]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.074]                   envs[common]]
[16:20:45.074]                 NAMES <- toupper(changed)
[16:20:45.074]                 args <- list()
[16:20:45.074]                 for (kk in seq_along(NAMES)) {
[16:20:45.074]                   name <- changed[[kk]]
[16:20:45.074]                   NAME <- NAMES[[kk]]
[16:20:45.074]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.074]                     next
[16:20:45.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.074]                 }
[16:20:45.074]                 NAMES <- toupper(added)
[16:20:45.074]                 for (kk in seq_along(NAMES)) {
[16:20:45.074]                   name <- added[[kk]]
[16:20:45.074]                   NAME <- NAMES[[kk]]
[16:20:45.074]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.074]                     next
[16:20:45.074]                   args[[name]] <- ""
[16:20:45.074]                 }
[16:20:45.074]                 NAMES <- toupper(removed)
[16:20:45.074]                 for (kk in seq_along(NAMES)) {
[16:20:45.074]                   name <- removed[[kk]]
[16:20:45.074]                   NAME <- NAMES[[kk]]
[16:20:45.074]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.074]                     next
[16:20:45.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.074]                 }
[16:20:45.074]                 if (length(args) > 0) 
[16:20:45.074]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.074]             }
[16:20:45.074]             else {
[16:20:45.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.074]             }
[16:20:45.074]             {
[16:20:45.074]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.074]                   0L) {
[16:20:45.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.074]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.074]                   base::options(opts)
[16:20:45.074]                 }
[16:20:45.074]                 {
[16:20:45.074]                   {
[16:20:45.074]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.074]                     NULL
[16:20:45.074]                   }
[16:20:45.074]                   options(future.plan = NULL)
[16:20:45.074]                   if (is.na(NA_character_)) 
[16:20:45.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.074]                     .init = FALSE)
[16:20:45.074]                 }
[16:20:45.074]             }
[16:20:45.074]         }
[16:20:45.074]     })
[16:20:45.074]     if (TRUE) {
[16:20:45.074]         base::sink(type = "output", split = FALSE)
[16:20:45.074]         if (TRUE) {
[16:20:45.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.074]         }
[16:20:45.074]         else {
[16:20:45.074]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.074]         }
[16:20:45.074]         base::close(...future.stdout)
[16:20:45.074]         ...future.stdout <- NULL
[16:20:45.074]     }
[16:20:45.074]     ...future.result$conditions <- ...future.conditions
[16:20:45.074]     ...future.result$finished <- base::Sys.time()
[16:20:45.074]     ...future.result
[16:20:45.074] }
[16:20:45.077] requestCore(): workers = 2
[16:20:45.081] MulticoreFuture started
[16:20:45.081] - Launch lazy future ... done
[16:20:45.082] run() for ‘MulticoreFuture’ ... done
[16:20:45.082] plan(): Setting new future strategy stack:
[16:20:45.083] getGlobalsAndPackages() ...
[16:20:45.083] Searching for globals...
[16:20:45.083] List of future strategies:
[16:20:45.083] 1. sequential:
[16:20:45.083]    - args: function (..., envir = parent.frame())
[16:20:45.083]    - tweaked: FALSE
[16:20:45.083]    - call: NULL
[16:20:45.084] plan(): nbrOfWorkers() = 1
[16:20:45.085] - globals found: [1] ‘{’
[16:20:45.085] Searching for globals ... DONE
[16:20:45.085] Resolving globals: FALSE
[16:20:45.086] 
[16:20:45.086] 
[16:20:45.086] getGlobalsAndPackages() ... DONE
[16:20:45.086] plan(): Setting new future strategy stack:
[16:20:45.086] run() for ‘Future’ ...
[16:20:45.087] - state: ‘created’
[16:20:45.086] List of future strategies:
[16:20:45.086] 1. multicore:
[16:20:45.086]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:45.086]    - tweaked: FALSE
[16:20:45.086]    - call: plan(strategy)
[16:20:45.087] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.092] plan(): nbrOfWorkers() = 2
[16:20:45.092] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:45.093]   - Field: ‘label’
[16:20:45.093]   - Field: ‘local’
[16:20:45.093]   - Field: ‘owner’
[16:20:45.093]   - Field: ‘envir’
[16:20:45.094]   - Field: ‘workers’
[16:20:45.094]   - Field: ‘packages’
[16:20:45.094]   - Field: ‘gc’
[16:20:45.094]   - Field: ‘job’
[16:20:45.094]   - Field: ‘conditions’
[16:20:45.094]   - Field: ‘expr’
[16:20:45.095]   - Field: ‘uuid’
[16:20:45.095]   - Field: ‘seed’
[16:20:45.095]   - Field: ‘version’
[16:20:45.095]   - Field: ‘result’
[16:20:45.095]   - Field: ‘asynchronous’
[16:20:45.095]   - Field: ‘calls’
[16:20:45.095]   - Field: ‘globals’
[16:20:45.096]   - Field: ‘stdout’
[16:20:45.096]   - Field: ‘earlySignal’
[16:20:45.096]   - Field: ‘lazy’
[16:20:45.096]   - Field: ‘state’
[16:20:45.096] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:45.096] - Launch lazy future ...
[16:20:45.097] Packages needed by the future expression (n = 0): <none>
[16:20:45.097] Packages needed by future strategies (n = 0): <none>
[16:20:45.098] {
[16:20:45.098]     {
[16:20:45.098]         {
[16:20:45.098]             ...future.startTime <- base::Sys.time()
[16:20:45.098]             {
[16:20:45.098]                 {
[16:20:45.098]                   {
[16:20:45.098]                     {
[16:20:45.098]                       base::local({
[16:20:45.098]                         has_future <- base::requireNamespace("future", 
[16:20:45.098]                           quietly = TRUE)
[16:20:45.098]                         if (has_future) {
[16:20:45.098]                           ns <- base::getNamespace("future")
[16:20:45.098]                           version <- ns[[".package"]][["version"]]
[16:20:45.098]                           if (is.null(version)) 
[16:20:45.098]                             version <- utils::packageVersion("future")
[16:20:45.098]                         }
[16:20:45.098]                         else {
[16:20:45.098]                           version <- NULL
[16:20:45.098]                         }
[16:20:45.098]                         if (!has_future || version < "1.8.0") {
[16:20:45.098]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.098]                             "", base::R.version$version.string), 
[16:20:45.098]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.098]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.098]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.098]                               "release", "version")], collapse = " "), 
[16:20:45.098]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.098]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.098]                             info)
[16:20:45.098]                           info <- base::paste(info, collapse = "; ")
[16:20:45.098]                           if (!has_future) {
[16:20:45.098]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.098]                               info)
[16:20:45.098]                           }
[16:20:45.098]                           else {
[16:20:45.098]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.098]                               info, version)
[16:20:45.098]                           }
[16:20:45.098]                           base::stop(msg)
[16:20:45.098]                         }
[16:20:45.098]                       })
[16:20:45.098]                     }
[16:20:45.098]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.098]                     base::options(mc.cores = 1L)
[16:20:45.098]                   }
[16:20:45.098]                   ...future.strategy.old <- future::plan("list")
[16:20:45.098]                   options(future.plan = NULL)
[16:20:45.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.098]                 }
[16:20:45.098]                 ...future.workdir <- getwd()
[16:20:45.098]             }
[16:20:45.098]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.098]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.098]         }
[16:20:45.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.098]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.098]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.098]             base::names(...future.oldOptions))
[16:20:45.098]     }
[16:20:45.098]     if (FALSE) {
[16:20:45.098]     }
[16:20:45.098]     else {
[16:20:45.098]         if (TRUE) {
[16:20:45.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.098]                 open = "w")
[16:20:45.098]         }
[16:20:45.098]         else {
[16:20:45.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.098]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.098]         }
[16:20:45.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.098]             base::sink(type = "output", split = FALSE)
[16:20:45.098]             base::close(...future.stdout)
[16:20:45.098]         }, add = TRUE)
[16:20:45.098]     }
[16:20:45.098]     ...future.frame <- base::sys.nframe()
[16:20:45.098]     ...future.conditions <- base::list()
[16:20:45.098]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.098]     if (FALSE) {
[16:20:45.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.098]     }
[16:20:45.098]     ...future.result <- base::tryCatch({
[16:20:45.098]         base::withCallingHandlers({
[16:20:45.098]             ...future.value <- base::withVisible(base::local({
[16:20:45.098]                 withCallingHandlers({
[16:20:45.098]                   {
[16:20:45.098]                     4
[16:20:45.098]                   }
[16:20:45.098]                 }, immediateCondition = function(cond) {
[16:20:45.098]                   save_rds <- function (object, pathname, ...) 
[16:20:45.098]                   {
[16:20:45.098]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:45.098]                     if (file_test("-f", pathname_tmp)) {
[16:20:45.098]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.098]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:45.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.098]                         fi_tmp[["mtime"]])
[16:20:45.098]                     }
[16:20:45.098]                     tryCatch({
[16:20:45.098]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:45.098]                     }, error = function(ex) {
[16:20:45.098]                       msg <- conditionMessage(ex)
[16:20:45.098]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.098]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:45.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.098]                         fi_tmp[["mtime"]], msg)
[16:20:45.098]                       ex$message <- msg
[16:20:45.098]                       stop(ex)
[16:20:45.098]                     })
[16:20:45.098]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:45.098]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:45.098]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:45.098]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.098]                       fi <- file.info(pathname)
[16:20:45.098]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:45.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.098]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:45.098]                         fi[["size"]], fi[["mtime"]])
[16:20:45.098]                       stop(msg)
[16:20:45.098]                     }
[16:20:45.098]                     invisible(pathname)
[16:20:45.098]                   }
[16:20:45.098]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:45.098]                     rootPath = tempdir()) 
[16:20:45.098]                   {
[16:20:45.098]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:45.098]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:45.098]                       tmpdir = path, fileext = ".rds")
[16:20:45.098]                     save_rds(obj, file)
[16:20:45.098]                   }
[16:20:45.098]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:45.098]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.098]                   {
[16:20:45.098]                     inherits <- base::inherits
[16:20:45.098]                     invokeRestart <- base::invokeRestart
[16:20:45.098]                     is.null <- base::is.null
[16:20:45.098]                     muffled <- FALSE
[16:20:45.098]                     if (inherits(cond, "message")) {
[16:20:45.098]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.098]                       if (muffled) 
[16:20:45.098]                         invokeRestart("muffleMessage")
[16:20:45.098]                     }
[16:20:45.098]                     else if (inherits(cond, "warning")) {
[16:20:45.098]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.098]                       if (muffled) 
[16:20:45.098]                         invokeRestart("muffleWarning")
[16:20:45.098]                     }
[16:20:45.098]                     else if (inherits(cond, "condition")) {
[16:20:45.098]                       if (!is.null(pattern)) {
[16:20:45.098]                         computeRestarts <- base::computeRestarts
[16:20:45.098]                         grepl <- base::grepl
[16:20:45.098]                         restarts <- computeRestarts(cond)
[16:20:45.098]                         for (restart in restarts) {
[16:20:45.098]                           name <- restart$name
[16:20:45.098]                           if (is.null(name)) 
[16:20:45.098]                             next
[16:20:45.098]                           if (!grepl(pattern, name)) 
[16:20:45.098]                             next
[16:20:45.098]                           invokeRestart(restart)
[16:20:45.098]                           muffled <- TRUE
[16:20:45.098]                           break
[16:20:45.098]                         }
[16:20:45.098]                       }
[16:20:45.098]                     }
[16:20:45.098]                     invisible(muffled)
[16:20:45.098]                   }
[16:20:45.098]                   muffleCondition(cond)
[16:20:45.098]                 })
[16:20:45.098]             }))
[16:20:45.098]             future::FutureResult(value = ...future.value$value, 
[16:20:45.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.098]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.098]                     ...future.globalenv.names))
[16:20:45.098]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.098]         }, condition = base::local({
[16:20:45.098]             c <- base::c
[16:20:45.098]             inherits <- base::inherits
[16:20:45.098]             invokeRestart <- base::invokeRestart
[16:20:45.098]             length <- base::length
[16:20:45.098]             list <- base::list
[16:20:45.098]             seq.int <- base::seq.int
[16:20:45.098]             signalCondition <- base::signalCondition
[16:20:45.098]             sys.calls <- base::sys.calls
[16:20:45.098]             `[[` <- base::`[[`
[16:20:45.098]             `+` <- base::`+`
[16:20:45.098]             `<<-` <- base::`<<-`
[16:20:45.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.098]                   3L)]
[16:20:45.098]             }
[16:20:45.098]             function(cond) {
[16:20:45.098]                 is_error <- inherits(cond, "error")
[16:20:45.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.098]                   NULL)
[16:20:45.098]                 if (is_error) {
[16:20:45.098]                   sessionInformation <- function() {
[16:20:45.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.098]                       search = base::search(), system = base::Sys.info())
[16:20:45.098]                   }
[16:20:45.098]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.098]                     cond$call), session = sessionInformation(), 
[16:20:45.098]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.098]                   signalCondition(cond)
[16:20:45.098]                 }
[16:20:45.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.098]                 "immediateCondition"))) {
[16:20:45.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.098]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.098]                   if (TRUE && !signal) {
[16:20:45.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.098]                     {
[16:20:45.098]                       inherits <- base::inherits
[16:20:45.098]                       invokeRestart <- base::invokeRestart
[16:20:45.098]                       is.null <- base::is.null
[16:20:45.098]                       muffled <- FALSE
[16:20:45.098]                       if (inherits(cond, "message")) {
[16:20:45.098]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.098]                         if (muffled) 
[16:20:45.098]                           invokeRestart("muffleMessage")
[16:20:45.098]                       }
[16:20:45.098]                       else if (inherits(cond, "warning")) {
[16:20:45.098]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.098]                         if (muffled) 
[16:20:45.098]                           invokeRestart("muffleWarning")
[16:20:45.098]                       }
[16:20:45.098]                       else if (inherits(cond, "condition")) {
[16:20:45.098]                         if (!is.null(pattern)) {
[16:20:45.098]                           computeRestarts <- base::computeRestarts
[16:20:45.098]                           grepl <- base::grepl
[16:20:45.098]                           restarts <- computeRestarts(cond)
[16:20:45.098]                           for (restart in restarts) {
[16:20:45.098]                             name <- restart$name
[16:20:45.098]                             if (is.null(name)) 
[16:20:45.098]                               next
[16:20:45.098]                             if (!grepl(pattern, name)) 
[16:20:45.098]                               next
[16:20:45.098]                             invokeRestart(restart)
[16:20:45.098]                             muffled <- TRUE
[16:20:45.098]                             break
[16:20:45.098]                           }
[16:20:45.098]                         }
[16:20:45.098]                       }
[16:20:45.098]                       invisible(muffled)
[16:20:45.098]                     }
[16:20:45.098]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.098]                   }
[16:20:45.098]                 }
[16:20:45.098]                 else {
[16:20:45.098]                   if (TRUE) {
[16:20:45.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.098]                     {
[16:20:45.098]                       inherits <- base::inherits
[16:20:45.098]                       invokeRestart <- base::invokeRestart
[16:20:45.098]                       is.null <- base::is.null
[16:20:45.098]                       muffled <- FALSE
[16:20:45.098]                       if (inherits(cond, "message")) {
[16:20:45.098]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.098]                         if (muffled) 
[16:20:45.098]                           invokeRestart("muffleMessage")
[16:20:45.098]                       }
[16:20:45.098]                       else if (inherits(cond, "warning")) {
[16:20:45.098]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.098]                         if (muffled) 
[16:20:45.098]                           invokeRestart("muffleWarning")
[16:20:45.098]                       }
[16:20:45.098]                       else if (inherits(cond, "condition")) {
[16:20:45.098]                         if (!is.null(pattern)) {
[16:20:45.098]                           computeRestarts <- base::computeRestarts
[16:20:45.098]                           grepl <- base::grepl
[16:20:45.098]                           restarts <- computeRestarts(cond)
[16:20:45.098]                           for (restart in restarts) {
[16:20:45.098]                             name <- restart$name
[16:20:45.098]                             if (is.null(name)) 
[16:20:45.098]                               next
[16:20:45.098]                             if (!grepl(pattern, name)) 
[16:20:45.098]                               next
[16:20:45.098]                             invokeRestart(restart)
[16:20:45.098]                             muffled <- TRUE
[16:20:45.098]                             break
[16:20:45.098]                           }
[16:20:45.098]                         }
[16:20:45.098]                       }
[16:20:45.098]                       invisible(muffled)
[16:20:45.098]                     }
[16:20:45.098]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.098]                   }
[16:20:45.098]                 }
[16:20:45.098]             }
[16:20:45.098]         }))
[16:20:45.098]     }, error = function(ex) {
[16:20:45.098]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.098]                 ...future.rng), started = ...future.startTime, 
[16:20:45.098]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.098]             version = "1.8"), class = "FutureResult")
[16:20:45.098]     }, finally = {
[16:20:45.098]         if (!identical(...future.workdir, getwd())) 
[16:20:45.098]             setwd(...future.workdir)
[16:20:45.098]         {
[16:20:45.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.098]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.098]             }
[16:20:45.098]             base::options(...future.oldOptions)
[16:20:45.098]             if (.Platform$OS.type == "windows") {
[16:20:45.098]                 old_names <- names(...future.oldEnvVars)
[16:20:45.098]                 envs <- base::Sys.getenv()
[16:20:45.098]                 names <- names(envs)
[16:20:45.098]                 common <- intersect(names, old_names)
[16:20:45.098]                 added <- setdiff(names, old_names)
[16:20:45.098]                 removed <- setdiff(old_names, names)
[16:20:45.098]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.098]                   envs[common]]
[16:20:45.098]                 NAMES <- toupper(changed)
[16:20:45.098]                 args <- list()
[16:20:45.098]                 for (kk in seq_along(NAMES)) {
[16:20:45.098]                   name <- changed[[kk]]
[16:20:45.098]                   NAME <- NAMES[[kk]]
[16:20:45.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.098]                     next
[16:20:45.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.098]                 }
[16:20:45.098]                 NAMES <- toupper(added)
[16:20:45.098]                 for (kk in seq_along(NAMES)) {
[16:20:45.098]                   name <- added[[kk]]
[16:20:45.098]                   NAME <- NAMES[[kk]]
[16:20:45.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.098]                     next
[16:20:45.098]                   args[[name]] <- ""
[16:20:45.098]                 }
[16:20:45.098]                 NAMES <- toupper(removed)
[16:20:45.098]                 for (kk in seq_along(NAMES)) {
[16:20:45.098]                   name <- removed[[kk]]
[16:20:45.098]                   NAME <- NAMES[[kk]]
[16:20:45.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.098]                     next
[16:20:45.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.098]                 }
[16:20:45.098]                 if (length(args) > 0) 
[16:20:45.098]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.098]             }
[16:20:45.098]             else {
[16:20:45.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.098]             }
[16:20:45.098]             {
[16:20:45.098]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.098]                   0L) {
[16:20:45.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.098]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.098]                   base::options(opts)
[16:20:45.098]                 }
[16:20:45.098]                 {
[16:20:45.098]                   {
[16:20:45.098]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.098]                     NULL
[16:20:45.098]                   }
[16:20:45.098]                   options(future.plan = NULL)
[16:20:45.098]                   if (is.na(NA_character_)) 
[16:20:45.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.098]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.098]                     .init = FALSE)
[16:20:45.098]                 }
[16:20:45.098]             }
[16:20:45.098]         }
[16:20:45.098]     })
[16:20:45.098]     if (TRUE) {
[16:20:45.098]         base::sink(type = "output", split = FALSE)
[16:20:45.098]         if (TRUE) {
[16:20:45.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.098]         }
[16:20:45.098]         else {
[16:20:45.098]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.098]         }
[16:20:45.098]         base::close(...future.stdout)
[16:20:45.098]         ...future.stdout <- NULL
[16:20:45.098]     }
[16:20:45.098]     ...future.result$conditions <- ...future.conditions
[16:20:45.098]     ...future.result$finished <- base::Sys.time()
[16:20:45.098]     ...future.result
[16:20:45.098] }
[16:20:45.102] requestCore(): workers = 2
[16:20:45.102] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:45.113] result() for MulticoreFuture ...
[16:20:45.114] result() for MulticoreFuture ...
[16:20:45.114] result() for MulticoreFuture ... done
[16:20:45.114] result() for MulticoreFuture ... done
[16:20:45.115] result() for MulticoreFuture ...
[16:20:45.115] result() for MulticoreFuture ... done
[16:20:45.118] MulticoreFuture started
[16:20:45.118] - Launch lazy future ... done
[16:20:45.119] run() for ‘MulticoreFuture’ ... done
[16:20:45.119] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55ed0dc6ca40> 
[16:20:45.120] List of future strategies:
[16:20:45.120] 1. sequential:
[16:20:45.120]    - args: function (..., envir = parent.frame())
[16:20:45.120]    - tweaked: FALSE
[16:20:45.120]    - call: NULL
[16:20:45.121] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55ed0c20c9a8> 
 - attr(*, "dim.")=[16:20:45.124] plan(): Setting new future strategy stack:
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ :[16:20:45.124] List of future strategies:
[16:20:45.124] 1. multicore:
[16:20:45.124]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:45.124]    - tweaked: FALSE
[16:20:45.124]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:45.130] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:45.135] resolve() on list environment ...
[16:20:45.135]  recursive: 0
[16:20:45.136]  length: 6
[16:20:45.137]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:45.137] signalConditionsASAP(numeric, pos=1) ...
[16:20:45.137] - nx: 6
[16:20:45.137] - relay: TRUE
[16:20:45.137] - stdout: TRUE
[16:20:45.137] - signal: TRUE
[16:20:45.138] - resignal: FALSE
[16:20:45.138] - force: TRUE
[16:20:45.138] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.138] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.138]  - until=2
[16:20:45.138]  - relaying element #2
[16:20:45.139] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.139] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.139] signalConditionsASAP(NULL, pos=1) ... done
[16:20:45.139]  length: 5 (resolved future 1)
[16:20:45.139] Future #2
[16:20:45.139] result() for MulticoreFuture ...
[16:20:45.140] result() for MulticoreFuture ... done
[16:20:45.140] result() for MulticoreFuture ...
[16:20:45.140] result() for MulticoreFuture ... done
[16:20:45.140] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:45.140] - nx: 6
[16:20:45.140] - relay: TRUE
[16:20:45.140] - stdout: TRUE
[16:20:45.141] - signal: TRUE
[16:20:45.141] - resignal: FALSE
[16:20:45.141] - force: TRUE
[16:20:45.141] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.141] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.141]  - until=2
[16:20:45.141]  - relaying element #2
[16:20:45.142] result() for MulticoreFuture ...
[16:20:45.142] result() for MulticoreFuture ... done
[16:20:45.142] result() for MulticoreFuture ...
[16:20:45.142] result() for MulticoreFuture ... done
[16:20:45.142] result() for MulticoreFuture ...
[16:20:45.142] result() for MulticoreFuture ... done
[16:20:45.143] result() for MulticoreFuture ...
[16:20:45.143] result() for MulticoreFuture ... done
[16:20:45.143] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.143] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.144] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:45.144]  length: 4 (resolved future 2)
[16:20:45.144] Future #3
[16:20:45.145] result() for MulticoreFuture ...
[16:20:45.146] result() for MulticoreFuture ...
[16:20:45.146] result() for MulticoreFuture ... done
[16:20:45.146] result() for MulticoreFuture ... done
[16:20:45.146] result() for MulticoreFuture ...
[16:20:45.146] result() for MulticoreFuture ... done
[16:20:45.146] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:45.147] - nx: 6
[16:20:45.147] - relay: TRUE
[16:20:45.147] - stdout: TRUE
[16:20:45.147] - signal: TRUE
[16:20:45.147] - resignal: FALSE
[16:20:45.147] - force: TRUE
[16:20:45.147] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.148] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.148]  - until=3
[16:20:45.148]  - relaying element #3
[16:20:45.148] result() for MulticoreFuture ...
[16:20:45.148] result() for MulticoreFuture ... done
[16:20:45.149] result() for MulticoreFuture ...
[16:20:45.149] result() for MulticoreFuture ... done
[16:20:45.149] result() for MulticoreFuture ...
[16:20:45.149] result() for MulticoreFuture ... done
[16:20:45.149] result() for MulticoreFuture ...
[16:20:45.149] result() for MulticoreFuture ... done
[16:20:45.150] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.150] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.150] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:45.150]  length: 3 (resolved future 3)
[16:20:45.150] Future #4
[16:20:45.151] result() for MulticoreFuture ...
[16:20:45.151] result() for MulticoreFuture ...
[16:20:45.152] result() for MulticoreFuture ... done
[16:20:45.152] result() for MulticoreFuture ... done
[16:20:45.152] result() for MulticoreFuture ...
[16:20:45.152] result() for MulticoreFuture ... done
[16:20:45.152] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:45.153] - nx: 6
[16:20:45.153] - relay: TRUE
[16:20:45.153] - stdout: TRUE
[16:20:45.153] - signal: TRUE
[16:20:45.153] - resignal: FALSE
[16:20:45.153] - force: TRUE
[16:20:45.154] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.154] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.154]  - until=4
[16:20:45.154]  - relaying element #4
[16:20:45.154] result() for MulticoreFuture ...
[16:20:45.154] result() for MulticoreFuture ... done
[16:20:45.155] result() for MulticoreFuture ...
[16:20:45.155] result() for MulticoreFuture ... done
[16:20:45.155] result() for MulticoreFuture ...
[16:20:45.155] result() for MulticoreFuture ... done
[16:20:45.155] result() for MulticoreFuture ...
[16:20:45.155] result() for MulticoreFuture ... done
[16:20:45.156] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.156] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.156] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:45.156]  length: 2 (resolved future 4)
[16:20:45.156] signalConditionsASAP(NULL, pos=5) ...
[16:20:45.156] - nx: 6
[16:20:45.156] - relay: TRUE
[16:20:45.157] - stdout: TRUE
[16:20:45.157] - signal: TRUE
[16:20:45.157] - resignal: FALSE
[16:20:45.157] - force: TRUE
[16:20:45.157] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.157] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.157]  - until=6
[16:20:45.157]  - relaying element #6
[16:20:45.157] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.157] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.158] signalConditionsASAP(NULL, pos=5) ... done
[16:20:45.158]  length: 1 (resolved future 5)
[16:20:45.158] signalConditionsASAP(numeric, pos=6) ...
[16:20:45.158] - nx: 6
[16:20:45.158] - relay: TRUE
[16:20:45.158] - stdout: TRUE
[16:20:45.158] - signal: TRUE
[16:20:45.158] - resignal: FALSE
[16:20:45.158] - force: TRUE
[16:20:45.159] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.159] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.159]  - until=6
[16:20:45.159] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.159] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.159] signalConditionsASAP(numeric, pos=6) ... done
[16:20:45.159]  length: 0 (resolved future 6)
[16:20:45.159] Relaying remaining futures
[16:20:45.159] signalConditionsASAP(NULL, pos=0) ...
[16:20:45.159] - nx: 6
[16:20:45.160] - relay: TRUE
[16:20:45.160] - stdout: TRUE
[16:20:45.160] - signal: TRUE
[16:20:45.160] - resignal: FALSE
[16:20:45.160] - force: TRUE
[16:20:45.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.160] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:45.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.160] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.161] signalConditionsASAP(NULL, pos=0) ... done
[16:20:45.161] resolve() on list environment ... DONE
[16:20:45.161] result() for MulticoreFuture ...
[16:20:45.161] result() for MulticoreFuture ... done
[16:20:45.161] result() for MulticoreFuture ...
[16:20:45.161] result() for MulticoreFuture ... done
[16:20:45.161] result() for MulticoreFuture ...
[16:20:45.161] result() for MulticoreFuture ... done
[16:20:45.162] result() for MulticoreFuture ...
[16:20:45.162] result() for MulticoreFuture ... done
[16:20:45.162] result() for MulticoreFuture ...
[16:20:45.162] result() for MulticoreFuture ... done
[16:20:45.162] result() for MulticoreFuture ...
[16:20:45.162] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0bde1168> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:20:45.165] getGlobalsAndPackages() ...
[16:20:45.165] Searching for globals...
[16:20:45.165] 
[16:20:45.165] Searching for globals ... DONE
[16:20:45.165] - globals: [0] <none>
[16:20:45.166] getGlobalsAndPackages() ... DONE
[16:20:45.166] run() for ‘Future’ ...
[16:20:45.166] - state: ‘created’
[16:20:45.166] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.171] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:45.172]   - Field: ‘label’
[16:20:45.172]   - Field: ‘local’
[16:20:45.172]   - Field: ‘owner’
[16:20:45.172]   - Field: ‘envir’
[16:20:45.172]   - Field: ‘workers’
[16:20:45.172]   - Field: ‘packages’
[16:20:45.172]   - Field: ‘gc’
[16:20:45.172]   - Field: ‘job’
[16:20:45.172]   - Field: ‘conditions’
[16:20:45.173]   - Field: ‘expr’
[16:20:45.173]   - Field: ‘uuid’
[16:20:45.173]   - Field: ‘seed’
[16:20:45.173]   - Field: ‘version’
[16:20:45.173]   - Field: ‘result’
[16:20:45.173]   - Field: ‘asynchronous’
[16:20:45.173]   - Field: ‘calls’
[16:20:45.173]   - Field: ‘globals’
[16:20:45.173]   - Field: ‘stdout’
[16:20:45.174]   - Field: ‘earlySignal’
[16:20:45.174]   - Field: ‘lazy’
[16:20:45.174]   - Field: ‘state’
[16:20:45.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:45.174] - Launch lazy future ...
[16:20:45.174] Packages needed by the future expression (n = 0): <none>
[16:20:45.174] Packages needed by future strategies (n = 0): <none>
[16:20:45.175] {
[16:20:45.175]     {
[16:20:45.175]         {
[16:20:45.175]             ...future.startTime <- base::Sys.time()
[16:20:45.175]             {
[16:20:45.175]                 {
[16:20:45.175]                   {
[16:20:45.175]                     {
[16:20:45.175]                       base::local({
[16:20:45.175]                         has_future <- base::requireNamespace("future", 
[16:20:45.175]                           quietly = TRUE)
[16:20:45.175]                         if (has_future) {
[16:20:45.175]                           ns <- base::getNamespace("future")
[16:20:45.175]                           version <- ns[[".package"]][["version"]]
[16:20:45.175]                           if (is.null(version)) 
[16:20:45.175]                             version <- utils::packageVersion("future")
[16:20:45.175]                         }
[16:20:45.175]                         else {
[16:20:45.175]                           version <- NULL
[16:20:45.175]                         }
[16:20:45.175]                         if (!has_future || version < "1.8.0") {
[16:20:45.175]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.175]                             "", base::R.version$version.string), 
[16:20:45.175]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.175]                               "release", "version")], collapse = " "), 
[16:20:45.175]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.175]                             info)
[16:20:45.175]                           info <- base::paste(info, collapse = "; ")
[16:20:45.175]                           if (!has_future) {
[16:20:45.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.175]                               info)
[16:20:45.175]                           }
[16:20:45.175]                           else {
[16:20:45.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.175]                               info, version)
[16:20:45.175]                           }
[16:20:45.175]                           base::stop(msg)
[16:20:45.175]                         }
[16:20:45.175]                       })
[16:20:45.175]                     }
[16:20:45.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.175]                     base::options(mc.cores = 1L)
[16:20:45.175]                   }
[16:20:45.175]                   ...future.strategy.old <- future::plan("list")
[16:20:45.175]                   options(future.plan = NULL)
[16:20:45.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.175]                 }
[16:20:45.175]                 ...future.workdir <- getwd()
[16:20:45.175]             }
[16:20:45.175]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.175]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.175]         }
[16:20:45.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.175]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.175]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.175]             base::names(...future.oldOptions))
[16:20:45.175]     }
[16:20:45.175]     if (FALSE) {
[16:20:45.175]     }
[16:20:45.175]     else {
[16:20:45.175]         if (TRUE) {
[16:20:45.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.175]                 open = "w")
[16:20:45.175]         }
[16:20:45.175]         else {
[16:20:45.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.175]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.175]         }
[16:20:45.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.175]             base::sink(type = "output", split = FALSE)
[16:20:45.175]             base::close(...future.stdout)
[16:20:45.175]         }, add = TRUE)
[16:20:45.175]     }
[16:20:45.175]     ...future.frame <- base::sys.nframe()
[16:20:45.175]     ...future.conditions <- base::list()
[16:20:45.175]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.175]     if (FALSE) {
[16:20:45.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.175]     }
[16:20:45.175]     ...future.result <- base::tryCatch({
[16:20:45.175]         base::withCallingHandlers({
[16:20:45.175]             ...future.value <- base::withVisible(base::local({
[16:20:45.175]                 withCallingHandlers({
[16:20:45.175]                   2
[16:20:45.175]                 }, immediateCondition = function(cond) {
[16:20:45.175]                   save_rds <- function (object, pathname, ...) 
[16:20:45.175]                   {
[16:20:45.175]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:45.175]                     if (file_test("-f", pathname_tmp)) {
[16:20:45.175]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.175]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:45.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.175]                         fi_tmp[["mtime"]])
[16:20:45.175]                     }
[16:20:45.175]                     tryCatch({
[16:20:45.175]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:45.175]                     }, error = function(ex) {
[16:20:45.175]                       msg <- conditionMessage(ex)
[16:20:45.175]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.175]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:45.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.175]                         fi_tmp[["mtime"]], msg)
[16:20:45.175]                       ex$message <- msg
[16:20:45.175]                       stop(ex)
[16:20:45.175]                     })
[16:20:45.175]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:45.175]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:45.175]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:45.175]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.175]                       fi <- file.info(pathname)
[16:20:45.175]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:45.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.175]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:45.175]                         fi[["size"]], fi[["mtime"]])
[16:20:45.175]                       stop(msg)
[16:20:45.175]                     }
[16:20:45.175]                     invisible(pathname)
[16:20:45.175]                   }
[16:20:45.175]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:45.175]                     rootPath = tempdir()) 
[16:20:45.175]                   {
[16:20:45.175]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:45.175]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:45.175]                       tmpdir = path, fileext = ".rds")
[16:20:45.175]                     save_rds(obj, file)
[16:20:45.175]                   }
[16:20:45.175]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:45.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.175]                   {
[16:20:45.175]                     inherits <- base::inherits
[16:20:45.175]                     invokeRestart <- base::invokeRestart
[16:20:45.175]                     is.null <- base::is.null
[16:20:45.175]                     muffled <- FALSE
[16:20:45.175]                     if (inherits(cond, "message")) {
[16:20:45.175]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.175]                       if (muffled) 
[16:20:45.175]                         invokeRestart("muffleMessage")
[16:20:45.175]                     }
[16:20:45.175]                     else if (inherits(cond, "warning")) {
[16:20:45.175]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.175]                       if (muffled) 
[16:20:45.175]                         invokeRestart("muffleWarning")
[16:20:45.175]                     }
[16:20:45.175]                     else if (inherits(cond, "condition")) {
[16:20:45.175]                       if (!is.null(pattern)) {
[16:20:45.175]                         computeRestarts <- base::computeRestarts
[16:20:45.175]                         grepl <- base::grepl
[16:20:45.175]                         restarts <- computeRestarts(cond)
[16:20:45.175]                         for (restart in restarts) {
[16:20:45.175]                           name <- restart$name
[16:20:45.175]                           if (is.null(name)) 
[16:20:45.175]                             next
[16:20:45.175]                           if (!grepl(pattern, name)) 
[16:20:45.175]                             next
[16:20:45.175]                           invokeRestart(restart)
[16:20:45.175]                           muffled <- TRUE
[16:20:45.175]                           break
[16:20:45.175]                         }
[16:20:45.175]                       }
[16:20:45.175]                     }
[16:20:45.175]                     invisible(muffled)
[16:20:45.175]                   }
[16:20:45.175]                   muffleCondition(cond)
[16:20:45.175]                 })
[16:20:45.175]             }))
[16:20:45.175]             future::FutureResult(value = ...future.value$value, 
[16:20:45.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.175]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.175]                     ...future.globalenv.names))
[16:20:45.175]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.175]         }, condition = base::local({
[16:20:45.175]             c <- base::c
[16:20:45.175]             inherits <- base::inherits
[16:20:45.175]             invokeRestart <- base::invokeRestart
[16:20:45.175]             length <- base::length
[16:20:45.175]             list <- base::list
[16:20:45.175]             seq.int <- base::seq.int
[16:20:45.175]             signalCondition <- base::signalCondition
[16:20:45.175]             sys.calls <- base::sys.calls
[16:20:45.175]             `[[` <- base::`[[`
[16:20:45.175]             `+` <- base::`+`
[16:20:45.175]             `<<-` <- base::`<<-`
[16:20:45.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.175]                   3L)]
[16:20:45.175]             }
[16:20:45.175]             function(cond) {
[16:20:45.175]                 is_error <- inherits(cond, "error")
[16:20:45.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.175]                   NULL)
[16:20:45.175]                 if (is_error) {
[16:20:45.175]                   sessionInformation <- function() {
[16:20:45.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.175]                       search = base::search(), system = base::Sys.info())
[16:20:45.175]                   }
[16:20:45.175]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.175]                     cond$call), session = sessionInformation(), 
[16:20:45.175]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.175]                   signalCondition(cond)
[16:20:45.175]                 }
[16:20:45.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.175]                 "immediateCondition"))) {
[16:20:45.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.175]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.175]                   if (TRUE && !signal) {
[16:20:45.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.175]                     {
[16:20:45.175]                       inherits <- base::inherits
[16:20:45.175]                       invokeRestart <- base::invokeRestart
[16:20:45.175]                       is.null <- base::is.null
[16:20:45.175]                       muffled <- FALSE
[16:20:45.175]                       if (inherits(cond, "message")) {
[16:20:45.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.175]                         if (muffled) 
[16:20:45.175]                           invokeRestart("muffleMessage")
[16:20:45.175]                       }
[16:20:45.175]                       else if (inherits(cond, "warning")) {
[16:20:45.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.175]                         if (muffled) 
[16:20:45.175]                           invokeRestart("muffleWarning")
[16:20:45.175]                       }
[16:20:45.175]                       else if (inherits(cond, "condition")) {
[16:20:45.175]                         if (!is.null(pattern)) {
[16:20:45.175]                           computeRestarts <- base::computeRestarts
[16:20:45.175]                           grepl <- base::grepl
[16:20:45.175]                           restarts <- computeRestarts(cond)
[16:20:45.175]                           for (restart in restarts) {
[16:20:45.175]                             name <- restart$name
[16:20:45.175]                             if (is.null(name)) 
[16:20:45.175]                               next
[16:20:45.175]                             if (!grepl(pattern, name)) 
[16:20:45.175]                               next
[16:20:45.175]                             invokeRestart(restart)
[16:20:45.175]                             muffled <- TRUE
[16:20:45.175]                             break
[16:20:45.175]                           }
[16:20:45.175]                         }
[16:20:45.175]                       }
[16:20:45.175]                       invisible(muffled)
[16:20:45.175]                     }
[16:20:45.175]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.175]                   }
[16:20:45.175]                 }
[16:20:45.175]                 else {
[16:20:45.175]                   if (TRUE) {
[16:20:45.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.175]                     {
[16:20:45.175]                       inherits <- base::inherits
[16:20:45.175]                       invokeRestart <- base::invokeRestart
[16:20:45.175]                       is.null <- base::is.null
[16:20:45.175]                       muffled <- FALSE
[16:20:45.175]                       if (inherits(cond, "message")) {
[16:20:45.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.175]                         if (muffled) 
[16:20:45.175]                           invokeRestart("muffleMessage")
[16:20:45.175]                       }
[16:20:45.175]                       else if (inherits(cond, "warning")) {
[16:20:45.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.175]                         if (muffled) 
[16:20:45.175]                           invokeRestart("muffleWarning")
[16:20:45.175]                       }
[16:20:45.175]                       else if (inherits(cond, "condition")) {
[16:20:45.175]                         if (!is.null(pattern)) {
[16:20:45.175]                           computeRestarts <- base::computeRestarts
[16:20:45.175]                           grepl <- base::grepl
[16:20:45.175]                           restarts <- computeRestarts(cond)
[16:20:45.175]                           for (restart in restarts) {
[16:20:45.175]                             name <- restart$name
[16:20:45.175]                             if (is.null(name)) 
[16:20:45.175]                               next
[16:20:45.175]                             if (!grepl(pattern, name)) 
[16:20:45.175]                               next
[16:20:45.175]                             invokeRestart(restart)
[16:20:45.175]                             muffled <- TRUE
[16:20:45.175]                             break
[16:20:45.175]                           }
[16:20:45.175]                         }
[16:20:45.175]                       }
[16:20:45.175]                       invisible(muffled)
[16:20:45.175]                     }
[16:20:45.175]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.175]                   }
[16:20:45.175]                 }
[16:20:45.175]             }
[16:20:45.175]         }))
[16:20:45.175]     }, error = function(ex) {
[16:20:45.175]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.175]                 ...future.rng), started = ...future.startTime, 
[16:20:45.175]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.175]             version = "1.8"), class = "FutureResult")
[16:20:45.175]     }, finally = {
[16:20:45.175]         if (!identical(...future.workdir, getwd())) 
[16:20:45.175]             setwd(...future.workdir)
[16:20:45.175]         {
[16:20:45.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.175]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.175]             }
[16:20:45.175]             base::options(...future.oldOptions)
[16:20:45.175]             if (.Platform$OS.type == "windows") {
[16:20:45.175]                 old_names <- names(...future.oldEnvVars)
[16:20:45.175]                 envs <- base::Sys.getenv()
[16:20:45.175]                 names <- names(envs)
[16:20:45.175]                 common <- intersect(names, old_names)
[16:20:45.175]                 added <- setdiff(names, old_names)
[16:20:45.175]                 removed <- setdiff(old_names, names)
[16:20:45.175]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.175]                   envs[common]]
[16:20:45.175]                 NAMES <- toupper(changed)
[16:20:45.175]                 args <- list()
[16:20:45.175]                 for (kk in seq_along(NAMES)) {
[16:20:45.175]                   name <- changed[[kk]]
[16:20:45.175]                   NAME <- NAMES[[kk]]
[16:20:45.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.175]                     next
[16:20:45.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.175]                 }
[16:20:45.175]                 NAMES <- toupper(added)
[16:20:45.175]                 for (kk in seq_along(NAMES)) {
[16:20:45.175]                   name <- added[[kk]]
[16:20:45.175]                   NAME <- NAMES[[kk]]
[16:20:45.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.175]                     next
[16:20:45.175]                   args[[name]] <- ""
[16:20:45.175]                 }
[16:20:45.175]                 NAMES <- toupper(removed)
[16:20:45.175]                 for (kk in seq_along(NAMES)) {
[16:20:45.175]                   name <- removed[[kk]]
[16:20:45.175]                   NAME <- NAMES[[kk]]
[16:20:45.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.175]                     next
[16:20:45.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.175]                 }
[16:20:45.175]                 if (length(args) > 0) 
[16:20:45.175]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.175]             }
[16:20:45.175]             else {
[16:20:45.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.175]             }
[16:20:45.175]             {
[16:20:45.175]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.175]                   0L) {
[16:20:45.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.175]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.175]                   base::options(opts)
[16:20:45.175]                 }
[16:20:45.175]                 {
[16:20:45.175]                   {
[16:20:45.175]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.175]                     NULL
[16:20:45.175]                   }
[16:20:45.175]                   options(future.plan = NULL)
[16:20:45.175]                   if (is.na(NA_character_)) 
[16:20:45.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.175]                     .init = FALSE)
[16:20:45.175]                 }
[16:20:45.175]             }
[16:20:45.175]         }
[16:20:45.175]     })
[16:20:45.175]     if (TRUE) {
[16:20:45.175]         base::sink(type = "output", split = FALSE)
[16:20:45.175]         if (TRUE) {
[16:20:45.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.175]         }
[16:20:45.175]         else {
[16:20:45.175]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.175]         }
[16:20:45.175]         base::close(...future.stdout)
[16:20:45.175]         ...future.stdout <- NULL
[16:20:45.175]     }
[16:20:45.175]     ...future.result$conditions <- ...future.conditions
[16:20:45.175]     ...future.result$finished <- base::Sys.time()
[16:20:45.175]     ...future.result
[16:20:45.175] }
[16:20:45.178] requestCore(): workers = 2
[16:20:45.181] MulticoreFuture started
[16:20:45.181] - Launch lazy future ... done
[16:20:45.181] run() for ‘MulticoreFuture’ ... done
[16:20:45.182] getGlobalsAndPackages() ...
[16:20:45.182] Searching for globals...
[16:20:45.182] plan(): Setting new future strategy stack:
[16:20:45.183] 
[16:20:45.183] Searching for globals ... DONE
[16:20:45.182] List of future strategies:
[16:20:45.182] 1. sequential:
[16:20:45.182]    - args: function (..., envir = parent.frame())
[16:20:45.182]    - tweaked: FALSE
[16:20:45.182]    - call: NULL
[16:20:45.183] - globals: [0] <none>
[16:20:45.183] getGlobalsAndPackages() ... DONE
[16:20:45.183] plan(): nbrOfWorkers() = 1
[16:20:45.184] run() for ‘Future’ ...
[16:20:45.184] - state: ‘created’
[16:20:45.184] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.185] plan(): Setting new future strategy stack:
[16:20:45.185] List of future strategies:
[16:20:45.185] 1. multicore:
[16:20:45.185]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:45.185]    - tweaked: FALSE
[16:20:45.185]    - call: plan(strategy)
[16:20:45.190] plan(): nbrOfWorkers() = 2
[16:20:45.190] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.190] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:45.190]   - Field: ‘label’
[16:20:45.191]   - Field: ‘local’
[16:20:45.191]   - Field: ‘owner’
[16:20:45.191]   - Field: ‘envir’
[16:20:45.191]   - Field: ‘workers’
[16:20:45.191]   - Field: ‘packages’
[16:20:45.191]   - Field: ‘gc’
[16:20:45.191]   - Field: ‘job’
[16:20:45.192]   - Field: ‘conditions’
[16:20:45.192]   - Field: ‘expr’
[16:20:45.192]   - Field: ‘uuid’
[16:20:45.192]   - Field: ‘seed’
[16:20:45.192]   - Field: ‘version’
[16:20:45.192]   - Field: ‘result’
[16:20:45.192]   - Field: ‘asynchronous’
[16:20:45.193]   - Field: ‘calls’
[16:20:45.193]   - Field: ‘globals’
[16:20:45.193]   - Field: ‘stdout’
[16:20:45.193]   - Field: ‘earlySignal’
[16:20:45.193]   - Field: ‘lazy’
[16:20:45.193]   - Field: ‘state’
[16:20:45.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:45.194] - Launch lazy future ...
[16:20:45.194] Packages needed by the future expression (n = 0): <none>
[16:20:45.194] Packages needed by future strategies (n = 0): <none>
[16:20:45.195] {
[16:20:45.195]     {
[16:20:45.195]         {
[16:20:45.195]             ...future.startTime <- base::Sys.time()
[16:20:45.195]             {
[16:20:45.195]                 {
[16:20:45.195]                   {
[16:20:45.195]                     {
[16:20:45.195]                       base::local({
[16:20:45.195]                         has_future <- base::requireNamespace("future", 
[16:20:45.195]                           quietly = TRUE)
[16:20:45.195]                         if (has_future) {
[16:20:45.195]                           ns <- base::getNamespace("future")
[16:20:45.195]                           version <- ns[[".package"]][["version"]]
[16:20:45.195]                           if (is.null(version)) 
[16:20:45.195]                             version <- utils::packageVersion("future")
[16:20:45.195]                         }
[16:20:45.195]                         else {
[16:20:45.195]                           version <- NULL
[16:20:45.195]                         }
[16:20:45.195]                         if (!has_future || version < "1.8.0") {
[16:20:45.195]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.195]                             "", base::R.version$version.string), 
[16:20:45.195]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.195]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.195]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.195]                               "release", "version")], collapse = " "), 
[16:20:45.195]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.195]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.195]                             info)
[16:20:45.195]                           info <- base::paste(info, collapse = "; ")
[16:20:45.195]                           if (!has_future) {
[16:20:45.195]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.195]                               info)
[16:20:45.195]                           }
[16:20:45.195]                           else {
[16:20:45.195]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.195]                               info, version)
[16:20:45.195]                           }
[16:20:45.195]                           base::stop(msg)
[16:20:45.195]                         }
[16:20:45.195]                       })
[16:20:45.195]                     }
[16:20:45.195]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.195]                     base::options(mc.cores = 1L)
[16:20:45.195]                   }
[16:20:45.195]                   ...future.strategy.old <- future::plan("list")
[16:20:45.195]                   options(future.plan = NULL)
[16:20:45.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.195]                 }
[16:20:45.195]                 ...future.workdir <- getwd()
[16:20:45.195]             }
[16:20:45.195]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.195]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.195]         }
[16:20:45.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.195]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.195]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.195]             base::names(...future.oldOptions))
[16:20:45.195]     }
[16:20:45.195]     if (FALSE) {
[16:20:45.195]     }
[16:20:45.195]     else {
[16:20:45.195]         if (TRUE) {
[16:20:45.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.195]                 open = "w")
[16:20:45.195]         }
[16:20:45.195]         else {
[16:20:45.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.195]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.195]         }
[16:20:45.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.195]             base::sink(type = "output", split = FALSE)
[16:20:45.195]             base::close(...future.stdout)
[16:20:45.195]         }, add = TRUE)
[16:20:45.195]     }
[16:20:45.195]     ...future.frame <- base::sys.nframe()
[16:20:45.195]     ...future.conditions <- base::list()
[16:20:45.195]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.195]     if (FALSE) {
[16:20:45.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.195]     }
[16:20:45.195]     ...future.result <- base::tryCatch({
[16:20:45.195]         base::withCallingHandlers({
[16:20:45.195]             ...future.value <- base::withVisible(base::local({
[16:20:45.195]                 withCallingHandlers({
[16:20:45.195]                   NULL
[16:20:45.195]                 }, immediateCondition = function(cond) {
[16:20:45.195]                   save_rds <- function (object, pathname, ...) 
[16:20:45.195]                   {
[16:20:45.195]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:45.195]                     if (file_test("-f", pathname_tmp)) {
[16:20:45.195]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.195]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:45.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.195]                         fi_tmp[["mtime"]])
[16:20:45.195]                     }
[16:20:45.195]                     tryCatch({
[16:20:45.195]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:45.195]                     }, error = function(ex) {
[16:20:45.195]                       msg <- conditionMessage(ex)
[16:20:45.195]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.195]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:45.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.195]                         fi_tmp[["mtime"]], msg)
[16:20:45.195]                       ex$message <- msg
[16:20:45.195]                       stop(ex)
[16:20:45.195]                     })
[16:20:45.195]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:45.195]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:45.195]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:45.195]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.195]                       fi <- file.info(pathname)
[16:20:45.195]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:45.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.195]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:45.195]                         fi[["size"]], fi[["mtime"]])
[16:20:45.195]                       stop(msg)
[16:20:45.195]                     }
[16:20:45.195]                     invisible(pathname)
[16:20:45.195]                   }
[16:20:45.195]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:45.195]                     rootPath = tempdir()) 
[16:20:45.195]                   {
[16:20:45.195]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:45.195]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:45.195]                       tmpdir = path, fileext = ".rds")
[16:20:45.195]                     save_rds(obj, file)
[16:20:45.195]                   }
[16:20:45.195]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:45.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.195]                   {
[16:20:45.195]                     inherits <- base::inherits
[16:20:45.195]                     invokeRestart <- base::invokeRestart
[16:20:45.195]                     is.null <- base::is.null
[16:20:45.195]                     muffled <- FALSE
[16:20:45.195]                     if (inherits(cond, "message")) {
[16:20:45.195]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.195]                       if (muffled) 
[16:20:45.195]                         invokeRestart("muffleMessage")
[16:20:45.195]                     }
[16:20:45.195]                     else if (inherits(cond, "warning")) {
[16:20:45.195]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.195]                       if (muffled) 
[16:20:45.195]                         invokeRestart("muffleWarning")
[16:20:45.195]                     }
[16:20:45.195]                     else if (inherits(cond, "condition")) {
[16:20:45.195]                       if (!is.null(pattern)) {
[16:20:45.195]                         computeRestarts <- base::computeRestarts
[16:20:45.195]                         grepl <- base::grepl
[16:20:45.195]                         restarts <- computeRestarts(cond)
[16:20:45.195]                         for (restart in restarts) {
[16:20:45.195]                           name <- restart$name
[16:20:45.195]                           if (is.null(name)) 
[16:20:45.195]                             next
[16:20:45.195]                           if (!grepl(pattern, name)) 
[16:20:45.195]                             next
[16:20:45.195]                           invokeRestart(restart)
[16:20:45.195]                           muffled <- TRUE
[16:20:45.195]                           break
[16:20:45.195]                         }
[16:20:45.195]                       }
[16:20:45.195]                     }
[16:20:45.195]                     invisible(muffled)
[16:20:45.195]                   }
[16:20:45.195]                   muffleCondition(cond)
[16:20:45.195]                 })
[16:20:45.195]             }))
[16:20:45.195]             future::FutureResult(value = ...future.value$value, 
[16:20:45.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.195]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.195]                     ...future.globalenv.names))
[16:20:45.195]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.195]         }, condition = base::local({
[16:20:45.195]             c <- base::c
[16:20:45.195]             inherits <- base::inherits
[16:20:45.195]             invokeRestart <- base::invokeRestart
[16:20:45.195]             length <- base::length
[16:20:45.195]             list <- base::list
[16:20:45.195]             seq.int <- base::seq.int
[16:20:45.195]             signalCondition <- base::signalCondition
[16:20:45.195]             sys.calls <- base::sys.calls
[16:20:45.195]             `[[` <- base::`[[`
[16:20:45.195]             `+` <- base::`+`
[16:20:45.195]             `<<-` <- base::`<<-`
[16:20:45.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.195]                   3L)]
[16:20:45.195]             }
[16:20:45.195]             function(cond) {
[16:20:45.195]                 is_error <- inherits(cond, "error")
[16:20:45.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.195]                   NULL)
[16:20:45.195]                 if (is_error) {
[16:20:45.195]                   sessionInformation <- function() {
[16:20:45.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.195]                       search = base::search(), system = base::Sys.info())
[16:20:45.195]                   }
[16:20:45.195]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.195]                     cond$call), session = sessionInformation(), 
[16:20:45.195]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.195]                   signalCondition(cond)
[16:20:45.195]                 }
[16:20:45.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.195]                 "immediateCondition"))) {
[16:20:45.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.195]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.195]                   if (TRUE && !signal) {
[16:20:45.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.195]                     {
[16:20:45.195]                       inherits <- base::inherits
[16:20:45.195]                       invokeRestart <- base::invokeRestart
[16:20:45.195]                       is.null <- base::is.null
[16:20:45.195]                       muffled <- FALSE
[16:20:45.195]                       if (inherits(cond, "message")) {
[16:20:45.195]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.195]                         if (muffled) 
[16:20:45.195]                           invokeRestart("muffleMessage")
[16:20:45.195]                       }
[16:20:45.195]                       else if (inherits(cond, "warning")) {
[16:20:45.195]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.195]                         if (muffled) 
[16:20:45.195]                           invokeRestart("muffleWarning")
[16:20:45.195]                       }
[16:20:45.195]                       else if (inherits(cond, "condition")) {
[16:20:45.195]                         if (!is.null(pattern)) {
[16:20:45.195]                           computeRestarts <- base::computeRestarts
[16:20:45.195]                           grepl <- base::grepl
[16:20:45.195]                           restarts <- computeRestarts(cond)
[16:20:45.195]                           for (restart in restarts) {
[16:20:45.195]                             name <- restart$name
[16:20:45.195]                             if (is.null(name)) 
[16:20:45.195]                               next
[16:20:45.195]                             if (!grepl(pattern, name)) 
[16:20:45.195]                               next
[16:20:45.195]                             invokeRestart(restart)
[16:20:45.195]                             muffled <- TRUE
[16:20:45.195]                             break
[16:20:45.195]                           }
[16:20:45.195]                         }
[16:20:45.195]                       }
[16:20:45.195]                       invisible(muffled)
[16:20:45.195]                     }
[16:20:45.195]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.195]                   }
[16:20:45.195]                 }
[16:20:45.195]                 else {
[16:20:45.195]                   if (TRUE) {
[16:20:45.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.195]                     {
[16:20:45.195]                       inherits <- base::inherits
[16:20:45.195]                       invokeRestart <- base::invokeRestart
[16:20:45.195]                       is.null <- base::is.null
[16:20:45.195]                       muffled <- FALSE
[16:20:45.195]                       if (inherits(cond, "message")) {
[16:20:45.195]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.195]                         if (muffled) 
[16:20:45.195]                           invokeRestart("muffleMessage")
[16:20:45.195]                       }
[16:20:45.195]                       else if (inherits(cond, "warning")) {
[16:20:45.195]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.195]                         if (muffled) 
[16:20:45.195]                           invokeRestart("muffleWarning")
[16:20:45.195]                       }
[16:20:45.195]                       else if (inherits(cond, "condition")) {
[16:20:45.195]                         if (!is.null(pattern)) {
[16:20:45.195]                           computeRestarts <- base::computeRestarts
[16:20:45.195]                           grepl <- base::grepl
[16:20:45.195]                           restarts <- computeRestarts(cond)
[16:20:45.195]                           for (restart in restarts) {
[16:20:45.195]                             name <- restart$name
[16:20:45.195]                             if (is.null(name)) 
[16:20:45.195]                               next
[16:20:45.195]                             if (!grepl(pattern, name)) 
[16:20:45.195]                               next
[16:20:45.195]                             invokeRestart(restart)
[16:20:45.195]                             muffled <- TRUE
[16:20:45.195]                             break
[16:20:45.195]                           }
[16:20:45.195]                         }
[16:20:45.195]                       }
[16:20:45.195]                       invisible(muffled)
[16:20:45.195]                     }
[16:20:45.195]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.195]                   }
[16:20:45.195]                 }
[16:20:45.195]             }
[16:20:45.195]         }))
[16:20:45.195]     }, error = function(ex) {
[16:20:45.195]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.195]                 ...future.rng), started = ...future.startTime, 
[16:20:45.195]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.195]             version = "1.8"), class = "FutureResult")
[16:20:45.195]     }, finally = {
[16:20:45.195]         if (!identical(...future.workdir, getwd())) 
[16:20:45.195]             setwd(...future.workdir)
[16:20:45.195]         {
[16:20:45.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.195]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.195]             }
[16:20:45.195]             base::options(...future.oldOptions)
[16:20:45.195]             if (.Platform$OS.type == "windows") {
[16:20:45.195]                 old_names <- names(...future.oldEnvVars)
[16:20:45.195]                 envs <- base::Sys.getenv()
[16:20:45.195]                 names <- names(envs)
[16:20:45.195]                 common <- intersect(names, old_names)
[16:20:45.195]                 added <- setdiff(names, old_names)
[16:20:45.195]                 removed <- setdiff(old_names, names)
[16:20:45.195]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.195]                   envs[common]]
[16:20:45.195]                 NAMES <- toupper(changed)
[16:20:45.195]                 args <- list()
[16:20:45.195]                 for (kk in seq_along(NAMES)) {
[16:20:45.195]                   name <- changed[[kk]]
[16:20:45.195]                   NAME <- NAMES[[kk]]
[16:20:45.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.195]                     next
[16:20:45.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.195]                 }
[16:20:45.195]                 NAMES <- toupper(added)
[16:20:45.195]                 for (kk in seq_along(NAMES)) {
[16:20:45.195]                   name <- added[[kk]]
[16:20:45.195]                   NAME <- NAMES[[kk]]
[16:20:45.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.195]                     next
[16:20:45.195]                   args[[name]] <- ""
[16:20:45.195]                 }
[16:20:45.195]                 NAMES <- toupper(removed)
[16:20:45.195]                 for (kk in seq_along(NAMES)) {
[16:20:45.195]                   name <- removed[[kk]]
[16:20:45.195]                   NAME <- NAMES[[kk]]
[16:20:45.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.195]                     next
[16:20:45.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.195]                 }
[16:20:45.195]                 if (length(args) > 0) 
[16:20:45.195]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.195]             }
[16:20:45.195]             else {
[16:20:45.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.195]             }
[16:20:45.195]             {
[16:20:45.195]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.195]                   0L) {
[16:20:45.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.195]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.195]                   base::options(opts)
[16:20:45.195]                 }
[16:20:45.195]                 {
[16:20:45.195]                   {
[16:20:45.195]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.195]                     NULL
[16:20:45.195]                   }
[16:20:45.195]                   options(future.plan = NULL)
[16:20:45.195]                   if (is.na(NA_character_)) 
[16:20:45.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.195]                     .init = FALSE)
[16:20:45.195]                 }
[16:20:45.195]             }
[16:20:45.195]         }
[16:20:45.195]     })
[16:20:45.195]     if (TRUE) {
[16:20:45.195]         base::sink(type = "output", split = FALSE)
[16:20:45.195]         if (TRUE) {
[16:20:45.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.195]         }
[16:20:45.195]         else {
[16:20:45.195]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.195]         }
[16:20:45.195]         base::close(...future.stdout)
[16:20:45.195]         ...future.stdout <- NULL
[16:20:45.195]     }
[16:20:45.195]     ...future.result$conditions <- ...future.conditions
[16:20:45.195]     ...future.result$finished <- base::Sys.time()
[16:20:45.195]     ...future.result
[16:20:45.195] }
[16:20:45.199] requestCore(): workers = 2
[16:20:45.202] MulticoreFuture started
[16:20:45.202] - Launch lazy future ... done
[16:20:45.202] run() for ‘MulticoreFuture’ ... done
[16:20:45.203] plan(): Setting new future strategy stack:
[16:20:45.203] getGlobalsAndPackages() ...
[16:20:45.203] Searching for globals...
[16:20:45.203] List of future strategies:
[16:20:45.203] 1. sequential:
[16:20:45.203]    - args: function (..., envir = parent.frame())
[16:20:45.203]    - tweaked: FALSE
[16:20:45.203]    - call: NULL
[16:20:45.204] plan(): nbrOfWorkers() = 1
[16:20:45.205] - globals found: [1] ‘{’
[16:20:45.205] Searching for globals ... DONE
[16:20:45.205] Resolving globals: FALSE
[16:20:45.206] 
[16:20:45.206] 
[16:20:45.206] getGlobalsAndPackages() ... DONE
[16:20:45.206] plan(): Setting new future strategy stack:
[16:20:45.206] run() for ‘Future’ ...
[16:20:45.206] List of future strategies:
[16:20:45.206] 1. multicore:
[16:20:45.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:45.206]    - tweaked: FALSE
[16:20:45.206]    - call: plan(strategy)
[16:20:45.206] - state: ‘created’
[16:20:45.207] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.211] plan(): nbrOfWorkers() = 2
[16:20:45.212] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.212] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:45.212]   - Field: ‘label’
[16:20:45.212]   - Field: ‘local’
[16:20:45.213]   - Field: ‘owner’
[16:20:45.213]   - Field: ‘envir’
[16:20:45.213]   - Field: ‘workers’
[16:20:45.213]   - Field: ‘packages’
[16:20:45.213]   - Field: ‘gc’
[16:20:45.213]   - Field: ‘job’
[16:20:45.213]   - Field: ‘conditions’
[16:20:45.214]   - Field: ‘expr’
[16:20:45.214]   - Field: ‘uuid’
[16:20:45.214]   - Field: ‘seed’
[16:20:45.214]   - Field: ‘version’
[16:20:45.214]   - Field: ‘result’
[16:20:45.214]   - Field: ‘asynchronous’
[16:20:45.214]   - Field: ‘calls’
[16:20:45.215]   - Field: ‘globals’
[16:20:45.215]   - Field: ‘stdout’
[16:20:45.215]   - Field: ‘earlySignal’
[16:20:45.215]   - Field: ‘lazy’
[16:20:45.215]   - Field: ‘state’
[16:20:45.215] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:45.215] - Launch lazy future ...
[16:20:45.216] Packages needed by the future expression (n = 0): <none>
[16:20:45.216] Packages needed by future strategies (n = 0): <none>
[16:20:45.217] {
[16:20:45.217]     {
[16:20:45.217]         {
[16:20:45.217]             ...future.startTime <- base::Sys.time()
[16:20:45.217]             {
[16:20:45.217]                 {
[16:20:45.217]                   {
[16:20:45.217]                     {
[16:20:45.217]                       base::local({
[16:20:45.217]                         has_future <- base::requireNamespace("future", 
[16:20:45.217]                           quietly = TRUE)
[16:20:45.217]                         if (has_future) {
[16:20:45.217]                           ns <- base::getNamespace("future")
[16:20:45.217]                           version <- ns[[".package"]][["version"]]
[16:20:45.217]                           if (is.null(version)) 
[16:20:45.217]                             version <- utils::packageVersion("future")
[16:20:45.217]                         }
[16:20:45.217]                         else {
[16:20:45.217]                           version <- NULL
[16:20:45.217]                         }
[16:20:45.217]                         if (!has_future || version < "1.8.0") {
[16:20:45.217]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.217]                             "", base::R.version$version.string), 
[16:20:45.217]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.217]                               "release", "version")], collapse = " "), 
[16:20:45.217]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.217]                             info)
[16:20:45.217]                           info <- base::paste(info, collapse = "; ")
[16:20:45.217]                           if (!has_future) {
[16:20:45.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.217]                               info)
[16:20:45.217]                           }
[16:20:45.217]                           else {
[16:20:45.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.217]                               info, version)
[16:20:45.217]                           }
[16:20:45.217]                           base::stop(msg)
[16:20:45.217]                         }
[16:20:45.217]                       })
[16:20:45.217]                     }
[16:20:45.217]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.217]                     base::options(mc.cores = 1L)
[16:20:45.217]                   }
[16:20:45.217]                   ...future.strategy.old <- future::plan("list")
[16:20:45.217]                   options(future.plan = NULL)
[16:20:45.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.217]                 }
[16:20:45.217]                 ...future.workdir <- getwd()
[16:20:45.217]             }
[16:20:45.217]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.217]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.217]         }
[16:20:45.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.217]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.217]             base::names(...future.oldOptions))
[16:20:45.217]     }
[16:20:45.217]     if (FALSE) {
[16:20:45.217]     }
[16:20:45.217]     else {
[16:20:45.217]         if (TRUE) {
[16:20:45.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.217]                 open = "w")
[16:20:45.217]         }
[16:20:45.217]         else {
[16:20:45.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.217]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.217]         }
[16:20:45.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.217]             base::sink(type = "output", split = FALSE)
[16:20:45.217]             base::close(...future.stdout)
[16:20:45.217]         }, add = TRUE)
[16:20:45.217]     }
[16:20:45.217]     ...future.frame <- base::sys.nframe()
[16:20:45.217]     ...future.conditions <- base::list()
[16:20:45.217]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.217]     if (FALSE) {
[16:20:45.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.217]     }
[16:20:45.217]     ...future.result <- base::tryCatch({
[16:20:45.217]         base::withCallingHandlers({
[16:20:45.217]             ...future.value <- base::withVisible(base::local({
[16:20:45.217]                 withCallingHandlers({
[16:20:45.217]                   {
[16:20:45.217]                     4
[16:20:45.217]                   }
[16:20:45.217]                 }, immediateCondition = function(cond) {
[16:20:45.217]                   save_rds <- function (object, pathname, ...) 
[16:20:45.217]                   {
[16:20:45.217]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:45.217]                     if (file_test("-f", pathname_tmp)) {
[16:20:45.217]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.217]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:45.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.217]                         fi_tmp[["mtime"]])
[16:20:45.217]                     }
[16:20:45.217]                     tryCatch({
[16:20:45.217]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:45.217]                     }, error = function(ex) {
[16:20:45.217]                       msg <- conditionMessage(ex)
[16:20:45.217]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.217]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:45.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.217]                         fi_tmp[["mtime"]], msg)
[16:20:45.217]                       ex$message <- msg
[16:20:45.217]                       stop(ex)
[16:20:45.217]                     })
[16:20:45.217]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:45.217]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:45.217]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:45.217]                       fi_tmp <- file.info(pathname_tmp)
[16:20:45.217]                       fi <- file.info(pathname)
[16:20:45.217]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:45.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:45.217]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:45.217]                         fi[["size"]], fi[["mtime"]])
[16:20:45.217]                       stop(msg)
[16:20:45.217]                     }
[16:20:45.217]                     invisible(pathname)
[16:20:45.217]                   }
[16:20:45.217]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:45.217]                     rootPath = tempdir()) 
[16:20:45.217]                   {
[16:20:45.217]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:45.217]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:45.217]                       tmpdir = path, fileext = ".rds")
[16:20:45.217]                     save_rds(obj, file)
[16:20:45.217]                   }
[16:20:45.217]                   saveImmediateCondition(cond, path = "/tmp/RtmpZGO0ru/.future/immediateConditions")
[16:20:45.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.217]                   {
[16:20:45.217]                     inherits <- base::inherits
[16:20:45.217]                     invokeRestart <- base::invokeRestart
[16:20:45.217]                     is.null <- base::is.null
[16:20:45.217]                     muffled <- FALSE
[16:20:45.217]                     if (inherits(cond, "message")) {
[16:20:45.217]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.217]                       if (muffled) 
[16:20:45.217]                         invokeRestart("muffleMessage")
[16:20:45.217]                     }
[16:20:45.217]                     else if (inherits(cond, "warning")) {
[16:20:45.217]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.217]                       if (muffled) 
[16:20:45.217]                         invokeRestart("muffleWarning")
[16:20:45.217]                     }
[16:20:45.217]                     else if (inherits(cond, "condition")) {
[16:20:45.217]                       if (!is.null(pattern)) {
[16:20:45.217]                         computeRestarts <- base::computeRestarts
[16:20:45.217]                         grepl <- base::grepl
[16:20:45.217]                         restarts <- computeRestarts(cond)
[16:20:45.217]                         for (restart in restarts) {
[16:20:45.217]                           name <- restart$name
[16:20:45.217]                           if (is.null(name)) 
[16:20:45.217]                             next
[16:20:45.217]                           if (!grepl(pattern, name)) 
[16:20:45.217]                             next
[16:20:45.217]                           invokeRestart(restart)
[16:20:45.217]                           muffled <- TRUE
[16:20:45.217]                           break
[16:20:45.217]                         }
[16:20:45.217]                       }
[16:20:45.217]                     }
[16:20:45.217]                     invisible(muffled)
[16:20:45.217]                   }
[16:20:45.217]                   muffleCondition(cond)
[16:20:45.217]                 })
[16:20:45.217]             }))
[16:20:45.217]             future::FutureResult(value = ...future.value$value, 
[16:20:45.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.217]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.217]                     ...future.globalenv.names))
[16:20:45.217]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.217]         }, condition = base::local({
[16:20:45.217]             c <- base::c
[16:20:45.217]             inherits <- base::inherits
[16:20:45.217]             invokeRestart <- base::invokeRestart
[16:20:45.217]             length <- base::length
[16:20:45.217]             list <- base::list
[16:20:45.217]             seq.int <- base::seq.int
[16:20:45.217]             signalCondition <- base::signalCondition
[16:20:45.217]             sys.calls <- base::sys.calls
[16:20:45.217]             `[[` <- base::`[[`
[16:20:45.217]             `+` <- base::`+`
[16:20:45.217]             `<<-` <- base::`<<-`
[16:20:45.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.217]                   3L)]
[16:20:45.217]             }
[16:20:45.217]             function(cond) {
[16:20:45.217]                 is_error <- inherits(cond, "error")
[16:20:45.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.217]                   NULL)
[16:20:45.217]                 if (is_error) {
[16:20:45.217]                   sessionInformation <- function() {
[16:20:45.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.217]                       search = base::search(), system = base::Sys.info())
[16:20:45.217]                   }
[16:20:45.217]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.217]                     cond$call), session = sessionInformation(), 
[16:20:45.217]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.217]                   signalCondition(cond)
[16:20:45.217]                 }
[16:20:45.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.217]                 "immediateCondition"))) {
[16:20:45.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.217]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.217]                   if (TRUE && !signal) {
[16:20:45.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.217]                     {
[16:20:45.217]                       inherits <- base::inherits
[16:20:45.217]                       invokeRestart <- base::invokeRestart
[16:20:45.217]                       is.null <- base::is.null
[16:20:45.217]                       muffled <- FALSE
[16:20:45.217]                       if (inherits(cond, "message")) {
[16:20:45.217]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.217]                         if (muffled) 
[16:20:45.217]                           invokeRestart("muffleMessage")
[16:20:45.217]                       }
[16:20:45.217]                       else if (inherits(cond, "warning")) {
[16:20:45.217]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.217]                         if (muffled) 
[16:20:45.217]                           invokeRestart("muffleWarning")
[16:20:45.217]                       }
[16:20:45.217]                       else if (inherits(cond, "condition")) {
[16:20:45.217]                         if (!is.null(pattern)) {
[16:20:45.217]                           computeRestarts <- base::computeRestarts
[16:20:45.217]                           grepl <- base::grepl
[16:20:45.217]                           restarts <- computeRestarts(cond)
[16:20:45.217]                           for (restart in restarts) {
[16:20:45.217]                             name <- restart$name
[16:20:45.217]                             if (is.null(name)) 
[16:20:45.217]                               next
[16:20:45.217]                             if (!grepl(pattern, name)) 
[16:20:45.217]                               next
[16:20:45.217]                             invokeRestart(restart)
[16:20:45.217]                             muffled <- TRUE
[16:20:45.217]                             break
[16:20:45.217]                           }
[16:20:45.217]                         }
[16:20:45.217]                       }
[16:20:45.217]                       invisible(muffled)
[16:20:45.217]                     }
[16:20:45.217]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.217]                   }
[16:20:45.217]                 }
[16:20:45.217]                 else {
[16:20:45.217]                   if (TRUE) {
[16:20:45.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.217]                     {
[16:20:45.217]                       inherits <- base::inherits
[16:20:45.217]                       invokeRestart <- base::invokeRestart
[16:20:45.217]                       is.null <- base::is.null
[16:20:45.217]                       muffled <- FALSE
[16:20:45.217]                       if (inherits(cond, "message")) {
[16:20:45.217]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.217]                         if (muffled) 
[16:20:45.217]                           invokeRestart("muffleMessage")
[16:20:45.217]                       }
[16:20:45.217]                       else if (inherits(cond, "warning")) {
[16:20:45.217]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.217]                         if (muffled) 
[16:20:45.217]                           invokeRestart("muffleWarning")
[16:20:45.217]                       }
[16:20:45.217]                       else if (inherits(cond, "condition")) {
[16:20:45.217]                         if (!is.null(pattern)) {
[16:20:45.217]                           computeRestarts <- base::computeRestarts
[16:20:45.217]                           grepl <- base::grepl
[16:20:45.217]                           restarts <- computeRestarts(cond)
[16:20:45.217]                           for (restart in restarts) {
[16:20:45.217]                             name <- restart$name
[16:20:45.217]                             if (is.null(name)) 
[16:20:45.217]                               next
[16:20:45.217]                             if (!grepl(pattern, name)) 
[16:20:45.217]                               next
[16:20:45.217]                             invokeRestart(restart)
[16:20:45.217]                             muffled <- TRUE
[16:20:45.217]                             break
[16:20:45.217]                           }
[16:20:45.217]                         }
[16:20:45.217]                       }
[16:20:45.217]                       invisible(muffled)
[16:20:45.217]                     }
[16:20:45.217]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.217]                   }
[16:20:45.217]                 }
[16:20:45.217]             }
[16:20:45.217]         }))
[16:20:45.217]     }, error = function(ex) {
[16:20:45.217]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.217]                 ...future.rng), started = ...future.startTime, 
[16:20:45.217]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.217]             version = "1.8"), class = "FutureResult")
[16:20:45.217]     }, finally = {
[16:20:45.217]         if (!identical(...future.workdir, getwd())) 
[16:20:45.217]             setwd(...future.workdir)
[16:20:45.217]         {
[16:20:45.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.217]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.217]             }
[16:20:45.217]             base::options(...future.oldOptions)
[16:20:45.217]             if (.Platform$OS.type == "windows") {
[16:20:45.217]                 old_names <- names(...future.oldEnvVars)
[16:20:45.217]                 envs <- base::Sys.getenv()
[16:20:45.217]                 names <- names(envs)
[16:20:45.217]                 common <- intersect(names, old_names)
[16:20:45.217]                 added <- setdiff(names, old_names)
[16:20:45.217]                 removed <- setdiff(old_names, names)
[16:20:45.217]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.217]                   envs[common]]
[16:20:45.217]                 NAMES <- toupper(changed)
[16:20:45.217]                 args <- list()
[16:20:45.217]                 for (kk in seq_along(NAMES)) {
[16:20:45.217]                   name <- changed[[kk]]
[16:20:45.217]                   NAME <- NAMES[[kk]]
[16:20:45.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.217]                     next
[16:20:45.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.217]                 }
[16:20:45.217]                 NAMES <- toupper(added)
[16:20:45.217]                 for (kk in seq_along(NAMES)) {
[16:20:45.217]                   name <- added[[kk]]
[16:20:45.217]                   NAME <- NAMES[[kk]]
[16:20:45.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.217]                     next
[16:20:45.217]                   args[[name]] <- ""
[16:20:45.217]                 }
[16:20:45.217]                 NAMES <- toupper(removed)
[16:20:45.217]                 for (kk in seq_along(NAMES)) {
[16:20:45.217]                   name <- removed[[kk]]
[16:20:45.217]                   NAME <- NAMES[[kk]]
[16:20:45.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.217]                     next
[16:20:45.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.217]                 }
[16:20:45.217]                 if (length(args) > 0) 
[16:20:45.217]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.217]             }
[16:20:45.217]             else {
[16:20:45.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.217]             }
[16:20:45.217]             {
[16:20:45.217]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.217]                   0L) {
[16:20:45.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.217]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.217]                   base::options(opts)
[16:20:45.217]                 }
[16:20:45.217]                 {
[16:20:45.217]                   {
[16:20:45.217]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.217]                     NULL
[16:20:45.217]                   }
[16:20:45.217]                   options(future.plan = NULL)
[16:20:45.217]                   if (is.na(NA_character_)) 
[16:20:45.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.217]                     .init = FALSE)
[16:20:45.217]                 }
[16:20:45.217]             }
[16:20:45.217]         }
[16:20:45.217]     })
[16:20:45.217]     if (TRUE) {
[16:20:45.217]         base::sink(type = "output", split = FALSE)
[16:20:45.217]         if (TRUE) {
[16:20:45.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.217]         }
[16:20:45.217]         else {
[16:20:45.217]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.217]         }
[16:20:45.217]         base::close(...future.stdout)
[16:20:45.217]         ...future.stdout <- NULL
[16:20:45.217]     }
[16:20:45.217]     ...future.result$conditions <- ...future.conditions
[16:20:45.217]     ...future.result$finished <- base::Sys.time()
[16:20:45.217]     ...future.result
[16:20:45.217] }
[16:20:45.220] requestCore(): workers = 2
[16:20:45.221] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:45.231] result() for MulticoreFuture ...
[16:20:45.232] result() for MulticoreFuture ...
[16:20:45.232] result() for MulticoreFuture ... done
[16:20:45.233] result() for MulticoreFuture ... done
[16:20:45.233] result() for MulticoreFuture ...
[16:20:45.233] result() for MulticoreFuture ... done
[16:20:45.236] MulticoreFuture started
[16:20:45.236] - Launch lazy future ... done
[16:20:45.237] run() for ‘MulticoreFuture’ ... done
[16:20:45.237] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55ed0d31cfb8> 
[16:20:45.238] List of future strategies:
[16:20:45.238] 1. sequential:
[16:20:45.238]    - args: function (..., envir = parent.frame())
[16:20:45.238]    - tweaked: FALSE
[16:20:45.238]    - call: NULL
[16:20:45.239] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55ed0df08628> 
 - attr(*, "dim.")=[16:20:45.241] plan(): Setting new future strategy stack:
 int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[16:20:45.242] List of future strategies:
[16:20:45.242] 1. multicore:
[16:20:45.242]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:45.242]    - tweaked: FALSE
[16:20:45.242]    - call: plan(strategy)
List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:45.248] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:45.262] resolve() on list environment ...
[16:20:45.263]  recursive: 0
[16:20:45.264]  length: 6
[16:20:45.264]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:45.264] signalConditionsASAP(numeric, pos=1) ...
[16:20:45.265] - nx: 6
[16:20:45.265] - relay: TRUE
[16:20:45.265] - stdout: TRUE
[16:20:45.265] - signal: TRUE
[16:20:45.265] - resignal: FALSE
[16:20:45.265] - force: TRUE
[16:20:45.265] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.266] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.266]  - until=2
[16:20:45.266]  - relaying element #2
[16:20:45.266] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.266] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.266] signalConditionsASAP(NULL, pos=1) ... done
[16:20:45.266]  length: 5 (resolved future 1)
[16:20:45.267] Future #2
[16:20:45.267] result() for MulticoreFuture ...
[16:20:45.267] result() for MulticoreFuture ... done
[16:20:45.267] result() for MulticoreFuture ...
[16:20:45.267] result() for MulticoreFuture ... done
[16:20:45.267] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:20:45.267] - nx: 6
[16:20:45.268] - relay: TRUE
[16:20:45.268] - stdout: TRUE
[16:20:45.268] - signal: TRUE
[16:20:45.268] - resignal: FALSE
[16:20:45.268] - force: TRUE
[16:20:45.268] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.268] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.268]  - until=2
[16:20:45.269]  - relaying element #2
[16:20:45.269] result() for MulticoreFuture ...
[16:20:45.269] result() for MulticoreFuture ... done
[16:20:45.269] result() for MulticoreFuture ...
[16:20:45.269] result() for MulticoreFuture ... done
[16:20:45.269] result() for MulticoreFuture ...
[16:20:45.269] result() for MulticoreFuture ... done
[16:20:45.270] result() for MulticoreFuture ...
[16:20:45.270] result() for MulticoreFuture ... done
[16:20:45.270] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.270] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.270] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:20:45.270]  length: 4 (resolved future 2)
[16:20:45.271] Future #3
[16:20:45.271] result() for MulticoreFuture ...
[16:20:45.272] result() for MulticoreFuture ...
[16:20:45.272] result() for MulticoreFuture ... done
[16:20:45.272] result() for MulticoreFuture ... done
[16:20:45.272] result() for MulticoreFuture ...
[16:20:45.273] result() for MulticoreFuture ... done
[16:20:45.273] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:20:45.273] - nx: 6
[16:20:45.273] - relay: TRUE
[16:20:45.273] - stdout: TRUE
[16:20:45.273] - signal: TRUE
[16:20:45.273] - resignal: FALSE
[16:20:45.273] - force: TRUE
[16:20:45.273] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.274] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.274]  - until=3
[16:20:45.274]  - relaying element #3
[16:20:45.274] result() for MulticoreFuture ...
[16:20:45.274] result() for MulticoreFuture ... done
[16:20:45.274] result() for MulticoreFuture ...
[16:20:45.274] result() for MulticoreFuture ... done
[16:20:45.275] result() for MulticoreFuture ...
[16:20:45.275] result() for MulticoreFuture ... done
[16:20:45.275] result() for MulticoreFuture ...
[16:20:45.275] result() for MulticoreFuture ... done
[16:20:45.275] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.275] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.275] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:20:45.275]  length: 3 (resolved future 3)
[16:20:45.276] Future #4
[16:20:45.276] result() for MulticoreFuture ...
[16:20:45.277] result() for MulticoreFuture ...
[16:20:45.277] result() for MulticoreFuture ... done
[16:20:45.277] result() for MulticoreFuture ... done
[16:20:45.277] result() for MulticoreFuture ...
[16:20:45.277] result() for MulticoreFuture ... done
[16:20:45.277] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:20:45.277] - nx: 6
[16:20:45.278] - relay: TRUE
[16:20:45.278] - stdout: TRUE
[16:20:45.278] - signal: TRUE
[16:20:45.278] - resignal: FALSE
[16:20:45.278] - force: TRUE
[16:20:45.278] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.278] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.278]  - until=4
[16:20:45.278]  - relaying element #4
[16:20:45.279] result() for MulticoreFuture ...
[16:20:45.279] result() for MulticoreFuture ... done
[16:20:45.279] result() for MulticoreFuture ...
[16:20:45.279] result() for MulticoreFuture ... done
[16:20:45.279] result() for MulticoreFuture ...
[16:20:45.279] result() for MulticoreFuture ... done
[16:20:45.279] result() for MulticoreFuture ...
[16:20:45.279] result() for MulticoreFuture ... done
[16:20:45.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.280] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.280] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:20:45.280]  length: 2 (resolved future 4)
[16:20:45.280] signalConditionsASAP(NULL, pos=5) ...
[16:20:45.280] - nx: 6
[16:20:45.280] - relay: TRUE
[16:20:45.280] - stdout: TRUE
[16:20:45.280] - signal: TRUE
[16:20:45.281] - resignal: FALSE
[16:20:45.281] - force: TRUE
[16:20:45.281] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.281] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.281]  - until=6
[16:20:45.281]  - relaying element #6
[16:20:45.281] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.281] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.281] signalConditionsASAP(NULL, pos=5) ... done
[16:20:45.282]  length: 1 (resolved future 5)
[16:20:45.282] signalConditionsASAP(numeric, pos=6) ...
[16:20:45.282] - nx: 6
[16:20:45.282] - relay: TRUE
[16:20:45.282] - stdout: TRUE
[16:20:45.282] - signal: TRUE
[16:20:45.282] - resignal: FALSE
[16:20:45.282] - force: TRUE
[16:20:45.282] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.282] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.283]  - until=6
[16:20:45.283] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.283] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.283] signalConditionsASAP(numeric, pos=6) ... done
[16:20:45.283]  length: 0 (resolved future 6)
[16:20:45.283] Relaying remaining futures
[16:20:45.283] signalConditionsASAP(NULL, pos=0) ...
[16:20:45.283] - nx: 6
[16:20:45.283] - relay: TRUE
[16:20:45.283] - stdout: TRUE
[16:20:45.284] - signal: TRUE
[16:20:45.284] - resignal: FALSE
[16:20:45.284] - force: TRUE
[16:20:45.284] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.284] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:45.284] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.284] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.284] signalConditionsASAP(NULL, pos=0) ... done
[16:20:45.284] resolve() on list environment ... DONE
[16:20:45.285] result() for MulticoreFuture ...
[16:20:45.285] result() for MulticoreFuture ... done
[16:20:45.285] result() for MulticoreFuture ...
[16:20:45.285] result() for MulticoreFuture ... done
[16:20:45.285] result() for MulticoreFuture ...
[16:20:45.285] result() for MulticoreFuture ... done
[16:20:45.285] result() for MulticoreFuture ...
[16:20:45.285] result() for MulticoreFuture ... done
[16:20:45.286] result() for MulticoreFuture ...
[16:20:45.286] result() for MulticoreFuture ... done
[16:20:45.286] result() for MulticoreFuture ...
[16:20:45.286] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0caa4cc0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[16:20:45.289] plan(): Setting new future strategy stack:
[16:20:45.289] List of future strategies:
[16:20:45.289] 1. multisession:
[16:20:45.289]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:45.289]    - tweaked: FALSE
[16:20:45.289]    - call: plan(strategy)
[16:20:45.289] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:20:45.290] multisession:
[16:20:45.290] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:45.290] - tweaked: FALSE
[16:20:45.290] - call: plan(strategy)
[16:20:45.294] getGlobalsAndPackages() ...
[16:20:45.294] Not searching for globals
[16:20:45.294] - globals: [0] <none>
[16:20:45.295] getGlobalsAndPackages() ... DONE
[16:20:45.295] [local output] makeClusterPSOCK() ...
[16:20:45.299] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:20:45.299] [local output] Base port: 11425
[16:20:45.299] [local output] Getting setup options for 2 cluster nodes ...
[16:20:45.300] [local output]  - Node 1 of 2 ...
[16:20:45.300] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:45.301] [local output] Rscript port: 11425

[16:20:45.301] [local output]  - Node 2 of 2 ...
[16:20:45.301] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:45.302] [local output] Rscript port: 11425

[16:20:45.302] [local output] Getting setup options for 2 cluster nodes ... done
[16:20:45.302] [local output]  - Parallel setup requested for some PSOCK nodes
[16:20:45.303] [local output] Setting up PSOCK nodes in parallel
[16:20:45.303] List of 36
[16:20:45.303]  $ worker          : chr "localhost"
[16:20:45.303]   ..- attr(*, "localhost")= logi TRUE
[16:20:45.303]  $ master          : chr "localhost"
[16:20:45.303]  $ port            : int 11425
[16:20:45.303]  $ connectTimeout  : num 120
[16:20:45.303]  $ timeout         : num 2592000
[16:20:45.303]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:20:45.303]  $ homogeneous     : logi TRUE
[16:20:45.303]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:20:45.303]  $ rscript_envs    : NULL
[16:20:45.303]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:45.303]  $ rscript_startup : NULL
[16:20:45.303]  $ rscript_sh      : chr "sh"
[16:20:45.303]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:45.303]  $ methods         : logi TRUE
[16:20:45.303]  $ socketOptions   : chr "no-delay"
[16:20:45.303]  $ useXDR          : logi FALSE
[16:20:45.303]  $ outfile         : chr "/dev/null"
[16:20:45.303]  $ renice          : int NA
[16:20:45.303]  $ rshcmd          : NULL
[16:20:45.303]  $ user            : chr(0) 
[16:20:45.303]  $ revtunnel       : logi FALSE
[16:20:45.303]  $ rshlogfile      : NULL
[16:20:45.303]  $ rshopts         : chr(0) 
[16:20:45.303]  $ rank            : int 1
[16:20:45.303]  $ manual          : logi FALSE
[16:20:45.303]  $ dryrun          : logi FALSE
[16:20:45.303]  $ quiet           : logi FALSE
[16:20:45.303]  $ setup_strategy  : chr "parallel"
[16:20:45.303]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:45.303]  $ pidfile         : chr "/tmp/RtmpZGO0ru/worker.rank=1.parallelly.parent=81506.13e6257e007ee.pid"
[16:20:45.303]  $ rshcmd_label    : NULL
[16:20:45.303]  $ rsh_call        : NULL
[16:20:45.303]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:45.303]  $ localMachine    : logi TRUE
[16:20:45.303]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:20:45.303]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:20:45.303]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:20:45.303]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:20:45.303]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:20:45.303]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:20:45.303]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:20:45.303]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:20:45.303]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:20:45.303]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:20:45.303]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:20:45.303]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:20:45.303]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:20:45.303]  $ arguments       :List of 28
[16:20:45.303]   ..$ worker          : chr "localhost"
[16:20:45.303]   ..$ master          : NULL
[16:20:45.303]   ..$ port            : int 11425
[16:20:45.303]   ..$ connectTimeout  : num 120
[16:20:45.303]   ..$ timeout         : num 2592000
[16:20:45.303]   ..$ rscript         : NULL
[16:20:45.303]   ..$ homogeneous     : NULL
[16:20:45.303]   ..$ rscript_args    : NULL
[16:20:45.303]   ..$ rscript_envs    : NULL
[16:20:45.303]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:45.303]   ..$ rscript_startup : NULL
[16:20:45.303]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:20:45.303]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:45.303]   ..$ methods         : logi TRUE
[16:20:45.303]   ..$ socketOptions   : chr "no-delay"
[16:20:45.303]   ..$ useXDR          : logi FALSE
[16:20:45.303]   ..$ outfile         : chr "/dev/null"
[16:20:45.303]   ..$ renice          : int NA
[16:20:45.303]   ..$ rshcmd          : NULL
[16:20:45.303]   ..$ user            : NULL
[16:20:45.303]   ..$ revtunnel       : logi NA
[16:20:45.303]   ..$ rshlogfile      : NULL
[16:20:45.303]   ..$ rshopts         : NULL
[16:20:45.303]   ..$ rank            : int 1
[16:20:45.303]   ..$ manual          : logi FALSE
[16:20:45.303]   ..$ dryrun          : logi FALSE
[16:20:45.303]   ..$ quiet           : logi FALSE
[16:20:45.303]   ..$ setup_strategy  : chr "parallel"
[16:20:45.303]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:20:45.322] [local output] System call to launch all workers:
[16:20:45.322] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZGO0ru/worker.rank=1.parallelly.parent=81506.13e6257e007ee.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11425 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:20:45.323] [local output] Starting PSOCK main server
[16:20:45.324] [local output] Workers launched
[16:20:45.324] [local output] Waiting for workers to connect back
[16:20:45.325]  - [local output] 0 workers out of 2 ready
[16:20:45.608]  - [local output] 0 workers out of 2 ready
[16:20:45.608]  - [local output] 1 workers out of 2 ready
[16:20:45.614]  - [local output] 1 workers out of 2 ready
[16:20:45.614]  - [local output] 2 workers out of 2 ready
[16:20:45.614] [local output] Launching of workers completed
[16:20:45.614] [local output] Collecting session information from workers
[16:20:45.615] [local output]  - Worker #1 of 2
[16:20:45.615] [local output]  - Worker #2 of 2
[16:20:45.616] [local output] makeClusterPSOCK() ... done
[16:20:45.627] Packages needed by the future expression (n = 0): <none>
[16:20:45.627] Packages needed by future strategies (n = 0): <none>
[16:20:45.627] {
[16:20:45.627]     {
[16:20:45.627]         {
[16:20:45.627]             ...future.startTime <- base::Sys.time()
[16:20:45.627]             {
[16:20:45.627]                 {
[16:20:45.627]                   {
[16:20:45.627]                     {
[16:20:45.627]                       base::local({
[16:20:45.627]                         has_future <- base::requireNamespace("future", 
[16:20:45.627]                           quietly = TRUE)
[16:20:45.627]                         if (has_future) {
[16:20:45.627]                           ns <- base::getNamespace("future")
[16:20:45.627]                           version <- ns[[".package"]][["version"]]
[16:20:45.627]                           if (is.null(version)) 
[16:20:45.627]                             version <- utils::packageVersion("future")
[16:20:45.627]                         }
[16:20:45.627]                         else {
[16:20:45.627]                           version <- NULL
[16:20:45.627]                         }
[16:20:45.627]                         if (!has_future || version < "1.8.0") {
[16:20:45.627]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.627]                             "", base::R.version$version.string), 
[16:20:45.627]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.627]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.627]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.627]                               "release", "version")], collapse = " "), 
[16:20:45.627]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.627]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.627]                             info)
[16:20:45.627]                           info <- base::paste(info, collapse = "; ")
[16:20:45.627]                           if (!has_future) {
[16:20:45.627]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.627]                               info)
[16:20:45.627]                           }
[16:20:45.627]                           else {
[16:20:45.627]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.627]                               info, version)
[16:20:45.627]                           }
[16:20:45.627]                           base::stop(msg)
[16:20:45.627]                         }
[16:20:45.627]                       })
[16:20:45.627]                     }
[16:20:45.627]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.627]                     base::options(mc.cores = 1L)
[16:20:45.627]                   }
[16:20:45.627]                   ...future.strategy.old <- future::plan("list")
[16:20:45.627]                   options(future.plan = NULL)
[16:20:45.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.627]                 }
[16:20:45.627]                 ...future.workdir <- getwd()
[16:20:45.627]             }
[16:20:45.627]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.627]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.627]         }
[16:20:45.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.627]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.627]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.627]             base::names(...future.oldOptions))
[16:20:45.627]     }
[16:20:45.627]     if (FALSE) {
[16:20:45.627]     }
[16:20:45.627]     else {
[16:20:45.627]         if (TRUE) {
[16:20:45.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.627]                 open = "w")
[16:20:45.627]         }
[16:20:45.627]         else {
[16:20:45.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.627]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.627]         }
[16:20:45.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.627]             base::sink(type = "output", split = FALSE)
[16:20:45.627]             base::close(...future.stdout)
[16:20:45.627]         }, add = TRUE)
[16:20:45.627]     }
[16:20:45.627]     ...future.frame <- base::sys.nframe()
[16:20:45.627]     ...future.conditions <- base::list()
[16:20:45.627]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.627]     if (FALSE) {
[16:20:45.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.627]     }
[16:20:45.627]     ...future.result <- base::tryCatch({
[16:20:45.627]         base::withCallingHandlers({
[16:20:45.627]             ...future.value <- base::withVisible(base::local({
[16:20:45.627]                 ...future.makeSendCondition <- base::local({
[16:20:45.627]                   sendCondition <- NULL
[16:20:45.627]                   function(frame = 1L) {
[16:20:45.627]                     if (is.function(sendCondition)) 
[16:20:45.627]                       return(sendCondition)
[16:20:45.627]                     ns <- getNamespace("parallel")
[16:20:45.627]                     if (exists("sendData", mode = "function", 
[16:20:45.627]                       envir = ns)) {
[16:20:45.627]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:45.627]                         envir = ns)
[16:20:45.627]                       envir <- sys.frame(frame)
[16:20:45.627]                       master <- NULL
[16:20:45.627]                       while (!identical(envir, .GlobalEnv) && 
[16:20:45.627]                         !identical(envir, emptyenv())) {
[16:20:45.627]                         if (exists("master", mode = "list", envir = envir, 
[16:20:45.627]                           inherits = FALSE)) {
[16:20:45.627]                           master <- get("master", mode = "list", 
[16:20:45.627]                             envir = envir, inherits = FALSE)
[16:20:45.627]                           if (inherits(master, c("SOCKnode", 
[16:20:45.627]                             "SOCK0node"))) {
[16:20:45.627]                             sendCondition <<- function(cond) {
[16:20:45.627]                               data <- list(type = "VALUE", value = cond, 
[16:20:45.627]                                 success = TRUE)
[16:20:45.627]                               parallel_sendData(master, data)
[16:20:45.627]                             }
[16:20:45.627]                             return(sendCondition)
[16:20:45.627]                           }
[16:20:45.627]                         }
[16:20:45.627]                         frame <- frame + 1L
[16:20:45.627]                         envir <- sys.frame(frame)
[16:20:45.627]                       }
[16:20:45.627]                     }
[16:20:45.627]                     sendCondition <<- function(cond) NULL
[16:20:45.627]                   }
[16:20:45.627]                 })
[16:20:45.627]                 withCallingHandlers({
[16:20:45.627]                   NA
[16:20:45.627]                 }, immediateCondition = function(cond) {
[16:20:45.627]                   sendCondition <- ...future.makeSendCondition()
[16:20:45.627]                   sendCondition(cond)
[16:20:45.627]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.627]                   {
[16:20:45.627]                     inherits <- base::inherits
[16:20:45.627]                     invokeRestart <- base::invokeRestart
[16:20:45.627]                     is.null <- base::is.null
[16:20:45.627]                     muffled <- FALSE
[16:20:45.627]                     if (inherits(cond, "message")) {
[16:20:45.627]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.627]                       if (muffled) 
[16:20:45.627]                         invokeRestart("muffleMessage")
[16:20:45.627]                     }
[16:20:45.627]                     else if (inherits(cond, "warning")) {
[16:20:45.627]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.627]                       if (muffled) 
[16:20:45.627]                         invokeRestart("muffleWarning")
[16:20:45.627]                     }
[16:20:45.627]                     else if (inherits(cond, "condition")) {
[16:20:45.627]                       if (!is.null(pattern)) {
[16:20:45.627]                         computeRestarts <- base::computeRestarts
[16:20:45.627]                         grepl <- base::grepl
[16:20:45.627]                         restarts <- computeRestarts(cond)
[16:20:45.627]                         for (restart in restarts) {
[16:20:45.627]                           name <- restart$name
[16:20:45.627]                           if (is.null(name)) 
[16:20:45.627]                             next
[16:20:45.627]                           if (!grepl(pattern, name)) 
[16:20:45.627]                             next
[16:20:45.627]                           invokeRestart(restart)
[16:20:45.627]                           muffled <- TRUE
[16:20:45.627]                           break
[16:20:45.627]                         }
[16:20:45.627]                       }
[16:20:45.627]                     }
[16:20:45.627]                     invisible(muffled)
[16:20:45.627]                   }
[16:20:45.627]                   muffleCondition(cond)
[16:20:45.627]                 })
[16:20:45.627]             }))
[16:20:45.627]             future::FutureResult(value = ...future.value$value, 
[16:20:45.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.627]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.627]                     ...future.globalenv.names))
[16:20:45.627]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.627]         }, condition = base::local({
[16:20:45.627]             c <- base::c
[16:20:45.627]             inherits <- base::inherits
[16:20:45.627]             invokeRestart <- base::invokeRestart
[16:20:45.627]             length <- base::length
[16:20:45.627]             list <- base::list
[16:20:45.627]             seq.int <- base::seq.int
[16:20:45.627]             signalCondition <- base::signalCondition
[16:20:45.627]             sys.calls <- base::sys.calls
[16:20:45.627]             `[[` <- base::`[[`
[16:20:45.627]             `+` <- base::`+`
[16:20:45.627]             `<<-` <- base::`<<-`
[16:20:45.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.627]                   3L)]
[16:20:45.627]             }
[16:20:45.627]             function(cond) {
[16:20:45.627]                 is_error <- inherits(cond, "error")
[16:20:45.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.627]                   NULL)
[16:20:45.627]                 if (is_error) {
[16:20:45.627]                   sessionInformation <- function() {
[16:20:45.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.627]                       search = base::search(), system = base::Sys.info())
[16:20:45.627]                   }
[16:20:45.627]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.627]                     cond$call), session = sessionInformation(), 
[16:20:45.627]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.627]                   signalCondition(cond)
[16:20:45.627]                 }
[16:20:45.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.627]                 "immediateCondition"))) {
[16:20:45.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.627]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.627]                   if (TRUE && !signal) {
[16:20:45.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.627]                     {
[16:20:45.627]                       inherits <- base::inherits
[16:20:45.627]                       invokeRestart <- base::invokeRestart
[16:20:45.627]                       is.null <- base::is.null
[16:20:45.627]                       muffled <- FALSE
[16:20:45.627]                       if (inherits(cond, "message")) {
[16:20:45.627]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.627]                         if (muffled) 
[16:20:45.627]                           invokeRestart("muffleMessage")
[16:20:45.627]                       }
[16:20:45.627]                       else if (inherits(cond, "warning")) {
[16:20:45.627]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.627]                         if (muffled) 
[16:20:45.627]                           invokeRestart("muffleWarning")
[16:20:45.627]                       }
[16:20:45.627]                       else if (inherits(cond, "condition")) {
[16:20:45.627]                         if (!is.null(pattern)) {
[16:20:45.627]                           computeRestarts <- base::computeRestarts
[16:20:45.627]                           grepl <- base::grepl
[16:20:45.627]                           restarts <- computeRestarts(cond)
[16:20:45.627]                           for (restart in restarts) {
[16:20:45.627]                             name <- restart$name
[16:20:45.627]                             if (is.null(name)) 
[16:20:45.627]                               next
[16:20:45.627]                             if (!grepl(pattern, name)) 
[16:20:45.627]                               next
[16:20:45.627]                             invokeRestart(restart)
[16:20:45.627]                             muffled <- TRUE
[16:20:45.627]                             break
[16:20:45.627]                           }
[16:20:45.627]                         }
[16:20:45.627]                       }
[16:20:45.627]                       invisible(muffled)
[16:20:45.627]                     }
[16:20:45.627]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.627]                   }
[16:20:45.627]                 }
[16:20:45.627]                 else {
[16:20:45.627]                   if (TRUE) {
[16:20:45.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.627]                     {
[16:20:45.627]                       inherits <- base::inherits
[16:20:45.627]                       invokeRestart <- base::invokeRestart
[16:20:45.627]                       is.null <- base::is.null
[16:20:45.627]                       muffled <- FALSE
[16:20:45.627]                       if (inherits(cond, "message")) {
[16:20:45.627]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.627]                         if (muffled) 
[16:20:45.627]                           invokeRestart("muffleMessage")
[16:20:45.627]                       }
[16:20:45.627]                       else if (inherits(cond, "warning")) {
[16:20:45.627]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.627]                         if (muffled) 
[16:20:45.627]                           invokeRestart("muffleWarning")
[16:20:45.627]                       }
[16:20:45.627]                       else if (inherits(cond, "condition")) {
[16:20:45.627]                         if (!is.null(pattern)) {
[16:20:45.627]                           computeRestarts <- base::computeRestarts
[16:20:45.627]                           grepl <- base::grepl
[16:20:45.627]                           restarts <- computeRestarts(cond)
[16:20:45.627]                           for (restart in restarts) {
[16:20:45.627]                             name <- restart$name
[16:20:45.627]                             if (is.null(name)) 
[16:20:45.627]                               next
[16:20:45.627]                             if (!grepl(pattern, name)) 
[16:20:45.627]                               next
[16:20:45.627]                             invokeRestart(restart)
[16:20:45.627]                             muffled <- TRUE
[16:20:45.627]                             break
[16:20:45.627]                           }
[16:20:45.627]                         }
[16:20:45.627]                       }
[16:20:45.627]                       invisible(muffled)
[16:20:45.627]                     }
[16:20:45.627]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.627]                   }
[16:20:45.627]                 }
[16:20:45.627]             }
[16:20:45.627]         }))
[16:20:45.627]     }, error = function(ex) {
[16:20:45.627]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.627]                 ...future.rng), started = ...future.startTime, 
[16:20:45.627]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.627]             version = "1.8"), class = "FutureResult")
[16:20:45.627]     }, finally = {
[16:20:45.627]         if (!identical(...future.workdir, getwd())) 
[16:20:45.627]             setwd(...future.workdir)
[16:20:45.627]         {
[16:20:45.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.627]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.627]             }
[16:20:45.627]             base::options(...future.oldOptions)
[16:20:45.627]             if (.Platform$OS.type == "windows") {
[16:20:45.627]                 old_names <- names(...future.oldEnvVars)
[16:20:45.627]                 envs <- base::Sys.getenv()
[16:20:45.627]                 names <- names(envs)
[16:20:45.627]                 common <- intersect(names, old_names)
[16:20:45.627]                 added <- setdiff(names, old_names)
[16:20:45.627]                 removed <- setdiff(old_names, names)
[16:20:45.627]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.627]                   envs[common]]
[16:20:45.627]                 NAMES <- toupper(changed)
[16:20:45.627]                 args <- list()
[16:20:45.627]                 for (kk in seq_along(NAMES)) {
[16:20:45.627]                   name <- changed[[kk]]
[16:20:45.627]                   NAME <- NAMES[[kk]]
[16:20:45.627]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.627]                     next
[16:20:45.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.627]                 }
[16:20:45.627]                 NAMES <- toupper(added)
[16:20:45.627]                 for (kk in seq_along(NAMES)) {
[16:20:45.627]                   name <- added[[kk]]
[16:20:45.627]                   NAME <- NAMES[[kk]]
[16:20:45.627]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.627]                     next
[16:20:45.627]                   args[[name]] <- ""
[16:20:45.627]                 }
[16:20:45.627]                 NAMES <- toupper(removed)
[16:20:45.627]                 for (kk in seq_along(NAMES)) {
[16:20:45.627]                   name <- removed[[kk]]
[16:20:45.627]                   NAME <- NAMES[[kk]]
[16:20:45.627]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.627]                     next
[16:20:45.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.627]                 }
[16:20:45.627]                 if (length(args) > 0) 
[16:20:45.627]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.627]             }
[16:20:45.627]             else {
[16:20:45.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.627]             }
[16:20:45.627]             {
[16:20:45.627]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.627]                   0L) {
[16:20:45.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.627]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.627]                   base::options(opts)
[16:20:45.627]                 }
[16:20:45.627]                 {
[16:20:45.627]                   {
[16:20:45.627]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.627]                     NULL
[16:20:45.627]                   }
[16:20:45.627]                   options(future.plan = NULL)
[16:20:45.627]                   if (is.na(NA_character_)) 
[16:20:45.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.627]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.627]                     .init = FALSE)
[16:20:45.627]                 }
[16:20:45.627]             }
[16:20:45.627]         }
[16:20:45.627]     })
[16:20:45.627]     if (TRUE) {
[16:20:45.627]         base::sink(type = "output", split = FALSE)
[16:20:45.627]         if (TRUE) {
[16:20:45.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.627]         }
[16:20:45.627]         else {
[16:20:45.627]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.627]         }
[16:20:45.627]         base::close(...future.stdout)
[16:20:45.627]         ...future.stdout <- NULL
[16:20:45.627]     }
[16:20:45.627]     ...future.result$conditions <- ...future.conditions
[16:20:45.627]     ...future.result$finished <- base::Sys.time()
[16:20:45.627]     ...future.result
[16:20:45.627] }
[16:20:45.680] MultisessionFuture started
[16:20:45.681] result() for ClusterFuture ...
[16:20:45.681] receiveMessageFromWorker() for ClusterFuture ...
[16:20:45.681] - Validating connection of MultisessionFuture
[16:20:45.714] - received message: FutureResult
[16:20:45.714] - Received FutureResult
[16:20:45.714] - Erased future from FutureRegistry
[16:20:45.714] result() for ClusterFuture ...
[16:20:45.714] - result already collected: FutureResult
[16:20:45.714] result() for ClusterFuture ... done
[16:20:45.714] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:45.714] result() for ClusterFuture ... done
[16:20:45.715] result() for ClusterFuture ...
[16:20:45.715] - result already collected: FutureResult
[16:20:45.715] result() for ClusterFuture ... done
[16:20:45.715] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:20:45.719] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:20:45.719] getGlobalsAndPackages() ...
[16:20:45.719] Searching for globals...
[16:20:45.720] 
[16:20:45.720] Searching for globals ... DONE
[16:20:45.720] - globals: [0] <none>
[16:20:45.720] getGlobalsAndPackages() ... DONE
[16:20:45.720] run() for ‘Future’ ...
[16:20:45.720] - state: ‘created’
[16:20:45.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.734] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:45.735]   - Field: ‘node’
[16:20:45.735]   - Field: ‘label’
[16:20:45.735]   - Field: ‘local’
[16:20:45.735]   - Field: ‘owner’
[16:20:45.735]   - Field: ‘envir’
[16:20:45.735]   - Field: ‘workers’
[16:20:45.735]   - Field: ‘packages’
[16:20:45.735]   - Field: ‘gc’
[16:20:45.735]   - Field: ‘conditions’
[16:20:45.735]   - Field: ‘persistent’
[16:20:45.736]   - Field: ‘expr’
[16:20:45.736]   - Field: ‘uuid’
[16:20:45.736]   - Field: ‘seed’
[16:20:45.736]   - Field: ‘version’
[16:20:45.736]   - Field: ‘result’
[16:20:45.736]   - Field: ‘asynchronous’
[16:20:45.736]   - Field: ‘calls’
[16:20:45.736]   - Field: ‘globals’
[16:20:45.736]   - Field: ‘stdout’
[16:20:45.736]   - Field: ‘earlySignal’
[16:20:45.737]   - Field: ‘lazy’
[16:20:45.737]   - Field: ‘state’
[16:20:45.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:45.737] - Launch lazy future ...
[16:20:45.737] Packages needed by the future expression (n = 0): <none>
[16:20:45.737] Packages needed by future strategies (n = 0): <none>
[16:20:45.738] {
[16:20:45.738]     {
[16:20:45.738]         {
[16:20:45.738]             ...future.startTime <- base::Sys.time()
[16:20:45.738]             {
[16:20:45.738]                 {
[16:20:45.738]                   {
[16:20:45.738]                     {
[16:20:45.738]                       base::local({
[16:20:45.738]                         has_future <- base::requireNamespace("future", 
[16:20:45.738]                           quietly = TRUE)
[16:20:45.738]                         if (has_future) {
[16:20:45.738]                           ns <- base::getNamespace("future")
[16:20:45.738]                           version <- ns[[".package"]][["version"]]
[16:20:45.738]                           if (is.null(version)) 
[16:20:45.738]                             version <- utils::packageVersion("future")
[16:20:45.738]                         }
[16:20:45.738]                         else {
[16:20:45.738]                           version <- NULL
[16:20:45.738]                         }
[16:20:45.738]                         if (!has_future || version < "1.8.0") {
[16:20:45.738]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.738]                             "", base::R.version$version.string), 
[16:20:45.738]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.738]                               "release", "version")], collapse = " "), 
[16:20:45.738]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.738]                             info)
[16:20:45.738]                           info <- base::paste(info, collapse = "; ")
[16:20:45.738]                           if (!has_future) {
[16:20:45.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.738]                               info)
[16:20:45.738]                           }
[16:20:45.738]                           else {
[16:20:45.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.738]                               info, version)
[16:20:45.738]                           }
[16:20:45.738]                           base::stop(msg)
[16:20:45.738]                         }
[16:20:45.738]                       })
[16:20:45.738]                     }
[16:20:45.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.738]                     base::options(mc.cores = 1L)
[16:20:45.738]                   }
[16:20:45.738]                   ...future.strategy.old <- future::plan("list")
[16:20:45.738]                   options(future.plan = NULL)
[16:20:45.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.738]                 }
[16:20:45.738]                 ...future.workdir <- getwd()
[16:20:45.738]             }
[16:20:45.738]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.738]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.738]         }
[16:20:45.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.738]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.738]             base::names(...future.oldOptions))
[16:20:45.738]     }
[16:20:45.738]     if (FALSE) {
[16:20:45.738]     }
[16:20:45.738]     else {
[16:20:45.738]         if (TRUE) {
[16:20:45.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.738]                 open = "w")
[16:20:45.738]         }
[16:20:45.738]         else {
[16:20:45.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.738]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.738]         }
[16:20:45.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.738]             base::sink(type = "output", split = FALSE)
[16:20:45.738]             base::close(...future.stdout)
[16:20:45.738]         }, add = TRUE)
[16:20:45.738]     }
[16:20:45.738]     ...future.frame <- base::sys.nframe()
[16:20:45.738]     ...future.conditions <- base::list()
[16:20:45.738]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.738]     if (FALSE) {
[16:20:45.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.738]     }
[16:20:45.738]     ...future.result <- base::tryCatch({
[16:20:45.738]         base::withCallingHandlers({
[16:20:45.738]             ...future.value <- base::withVisible(base::local({
[16:20:45.738]                 ...future.makeSendCondition <- base::local({
[16:20:45.738]                   sendCondition <- NULL
[16:20:45.738]                   function(frame = 1L) {
[16:20:45.738]                     if (is.function(sendCondition)) 
[16:20:45.738]                       return(sendCondition)
[16:20:45.738]                     ns <- getNamespace("parallel")
[16:20:45.738]                     if (exists("sendData", mode = "function", 
[16:20:45.738]                       envir = ns)) {
[16:20:45.738]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:45.738]                         envir = ns)
[16:20:45.738]                       envir <- sys.frame(frame)
[16:20:45.738]                       master <- NULL
[16:20:45.738]                       while (!identical(envir, .GlobalEnv) && 
[16:20:45.738]                         !identical(envir, emptyenv())) {
[16:20:45.738]                         if (exists("master", mode = "list", envir = envir, 
[16:20:45.738]                           inherits = FALSE)) {
[16:20:45.738]                           master <- get("master", mode = "list", 
[16:20:45.738]                             envir = envir, inherits = FALSE)
[16:20:45.738]                           if (inherits(master, c("SOCKnode", 
[16:20:45.738]                             "SOCK0node"))) {
[16:20:45.738]                             sendCondition <<- function(cond) {
[16:20:45.738]                               data <- list(type = "VALUE", value = cond, 
[16:20:45.738]                                 success = TRUE)
[16:20:45.738]                               parallel_sendData(master, data)
[16:20:45.738]                             }
[16:20:45.738]                             return(sendCondition)
[16:20:45.738]                           }
[16:20:45.738]                         }
[16:20:45.738]                         frame <- frame + 1L
[16:20:45.738]                         envir <- sys.frame(frame)
[16:20:45.738]                       }
[16:20:45.738]                     }
[16:20:45.738]                     sendCondition <<- function(cond) NULL
[16:20:45.738]                   }
[16:20:45.738]                 })
[16:20:45.738]                 withCallingHandlers({
[16:20:45.738]                   2
[16:20:45.738]                 }, immediateCondition = function(cond) {
[16:20:45.738]                   sendCondition <- ...future.makeSendCondition()
[16:20:45.738]                   sendCondition(cond)
[16:20:45.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.738]                   {
[16:20:45.738]                     inherits <- base::inherits
[16:20:45.738]                     invokeRestart <- base::invokeRestart
[16:20:45.738]                     is.null <- base::is.null
[16:20:45.738]                     muffled <- FALSE
[16:20:45.738]                     if (inherits(cond, "message")) {
[16:20:45.738]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.738]                       if (muffled) 
[16:20:45.738]                         invokeRestart("muffleMessage")
[16:20:45.738]                     }
[16:20:45.738]                     else if (inherits(cond, "warning")) {
[16:20:45.738]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.738]                       if (muffled) 
[16:20:45.738]                         invokeRestart("muffleWarning")
[16:20:45.738]                     }
[16:20:45.738]                     else if (inherits(cond, "condition")) {
[16:20:45.738]                       if (!is.null(pattern)) {
[16:20:45.738]                         computeRestarts <- base::computeRestarts
[16:20:45.738]                         grepl <- base::grepl
[16:20:45.738]                         restarts <- computeRestarts(cond)
[16:20:45.738]                         for (restart in restarts) {
[16:20:45.738]                           name <- restart$name
[16:20:45.738]                           if (is.null(name)) 
[16:20:45.738]                             next
[16:20:45.738]                           if (!grepl(pattern, name)) 
[16:20:45.738]                             next
[16:20:45.738]                           invokeRestart(restart)
[16:20:45.738]                           muffled <- TRUE
[16:20:45.738]                           break
[16:20:45.738]                         }
[16:20:45.738]                       }
[16:20:45.738]                     }
[16:20:45.738]                     invisible(muffled)
[16:20:45.738]                   }
[16:20:45.738]                   muffleCondition(cond)
[16:20:45.738]                 })
[16:20:45.738]             }))
[16:20:45.738]             future::FutureResult(value = ...future.value$value, 
[16:20:45.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.738]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.738]                     ...future.globalenv.names))
[16:20:45.738]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.738]         }, condition = base::local({
[16:20:45.738]             c <- base::c
[16:20:45.738]             inherits <- base::inherits
[16:20:45.738]             invokeRestart <- base::invokeRestart
[16:20:45.738]             length <- base::length
[16:20:45.738]             list <- base::list
[16:20:45.738]             seq.int <- base::seq.int
[16:20:45.738]             signalCondition <- base::signalCondition
[16:20:45.738]             sys.calls <- base::sys.calls
[16:20:45.738]             `[[` <- base::`[[`
[16:20:45.738]             `+` <- base::`+`
[16:20:45.738]             `<<-` <- base::`<<-`
[16:20:45.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.738]                   3L)]
[16:20:45.738]             }
[16:20:45.738]             function(cond) {
[16:20:45.738]                 is_error <- inherits(cond, "error")
[16:20:45.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.738]                   NULL)
[16:20:45.738]                 if (is_error) {
[16:20:45.738]                   sessionInformation <- function() {
[16:20:45.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.738]                       search = base::search(), system = base::Sys.info())
[16:20:45.738]                   }
[16:20:45.738]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.738]                     cond$call), session = sessionInformation(), 
[16:20:45.738]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.738]                   signalCondition(cond)
[16:20:45.738]                 }
[16:20:45.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.738]                 "immediateCondition"))) {
[16:20:45.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.738]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.738]                   if (TRUE && !signal) {
[16:20:45.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.738]                     {
[16:20:45.738]                       inherits <- base::inherits
[16:20:45.738]                       invokeRestart <- base::invokeRestart
[16:20:45.738]                       is.null <- base::is.null
[16:20:45.738]                       muffled <- FALSE
[16:20:45.738]                       if (inherits(cond, "message")) {
[16:20:45.738]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.738]                         if (muffled) 
[16:20:45.738]                           invokeRestart("muffleMessage")
[16:20:45.738]                       }
[16:20:45.738]                       else if (inherits(cond, "warning")) {
[16:20:45.738]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.738]                         if (muffled) 
[16:20:45.738]                           invokeRestart("muffleWarning")
[16:20:45.738]                       }
[16:20:45.738]                       else if (inherits(cond, "condition")) {
[16:20:45.738]                         if (!is.null(pattern)) {
[16:20:45.738]                           computeRestarts <- base::computeRestarts
[16:20:45.738]                           grepl <- base::grepl
[16:20:45.738]                           restarts <- computeRestarts(cond)
[16:20:45.738]                           for (restart in restarts) {
[16:20:45.738]                             name <- restart$name
[16:20:45.738]                             if (is.null(name)) 
[16:20:45.738]                               next
[16:20:45.738]                             if (!grepl(pattern, name)) 
[16:20:45.738]                               next
[16:20:45.738]                             invokeRestart(restart)
[16:20:45.738]                             muffled <- TRUE
[16:20:45.738]                             break
[16:20:45.738]                           }
[16:20:45.738]                         }
[16:20:45.738]                       }
[16:20:45.738]                       invisible(muffled)
[16:20:45.738]                     }
[16:20:45.738]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.738]                   }
[16:20:45.738]                 }
[16:20:45.738]                 else {
[16:20:45.738]                   if (TRUE) {
[16:20:45.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.738]                     {
[16:20:45.738]                       inherits <- base::inherits
[16:20:45.738]                       invokeRestart <- base::invokeRestart
[16:20:45.738]                       is.null <- base::is.null
[16:20:45.738]                       muffled <- FALSE
[16:20:45.738]                       if (inherits(cond, "message")) {
[16:20:45.738]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.738]                         if (muffled) 
[16:20:45.738]                           invokeRestart("muffleMessage")
[16:20:45.738]                       }
[16:20:45.738]                       else if (inherits(cond, "warning")) {
[16:20:45.738]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.738]                         if (muffled) 
[16:20:45.738]                           invokeRestart("muffleWarning")
[16:20:45.738]                       }
[16:20:45.738]                       else if (inherits(cond, "condition")) {
[16:20:45.738]                         if (!is.null(pattern)) {
[16:20:45.738]                           computeRestarts <- base::computeRestarts
[16:20:45.738]                           grepl <- base::grepl
[16:20:45.738]                           restarts <- computeRestarts(cond)
[16:20:45.738]                           for (restart in restarts) {
[16:20:45.738]                             name <- restart$name
[16:20:45.738]                             if (is.null(name)) 
[16:20:45.738]                               next
[16:20:45.738]                             if (!grepl(pattern, name)) 
[16:20:45.738]                               next
[16:20:45.738]                             invokeRestart(restart)
[16:20:45.738]                             muffled <- TRUE
[16:20:45.738]                             break
[16:20:45.738]                           }
[16:20:45.738]                         }
[16:20:45.738]                       }
[16:20:45.738]                       invisible(muffled)
[16:20:45.738]                     }
[16:20:45.738]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.738]                   }
[16:20:45.738]                 }
[16:20:45.738]             }
[16:20:45.738]         }))
[16:20:45.738]     }, error = function(ex) {
[16:20:45.738]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.738]                 ...future.rng), started = ...future.startTime, 
[16:20:45.738]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.738]             version = "1.8"), class = "FutureResult")
[16:20:45.738]     }, finally = {
[16:20:45.738]         if (!identical(...future.workdir, getwd())) 
[16:20:45.738]             setwd(...future.workdir)
[16:20:45.738]         {
[16:20:45.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.738]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.738]             }
[16:20:45.738]             base::options(...future.oldOptions)
[16:20:45.738]             if (.Platform$OS.type == "windows") {
[16:20:45.738]                 old_names <- names(...future.oldEnvVars)
[16:20:45.738]                 envs <- base::Sys.getenv()
[16:20:45.738]                 names <- names(envs)
[16:20:45.738]                 common <- intersect(names, old_names)
[16:20:45.738]                 added <- setdiff(names, old_names)
[16:20:45.738]                 removed <- setdiff(old_names, names)
[16:20:45.738]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.738]                   envs[common]]
[16:20:45.738]                 NAMES <- toupper(changed)
[16:20:45.738]                 args <- list()
[16:20:45.738]                 for (kk in seq_along(NAMES)) {
[16:20:45.738]                   name <- changed[[kk]]
[16:20:45.738]                   NAME <- NAMES[[kk]]
[16:20:45.738]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.738]                     next
[16:20:45.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.738]                 }
[16:20:45.738]                 NAMES <- toupper(added)
[16:20:45.738]                 for (kk in seq_along(NAMES)) {
[16:20:45.738]                   name <- added[[kk]]
[16:20:45.738]                   NAME <- NAMES[[kk]]
[16:20:45.738]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.738]                     next
[16:20:45.738]                   args[[name]] <- ""
[16:20:45.738]                 }
[16:20:45.738]                 NAMES <- toupper(removed)
[16:20:45.738]                 for (kk in seq_along(NAMES)) {
[16:20:45.738]                   name <- removed[[kk]]
[16:20:45.738]                   NAME <- NAMES[[kk]]
[16:20:45.738]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.738]                     next
[16:20:45.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.738]                 }
[16:20:45.738]                 if (length(args) > 0) 
[16:20:45.738]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.738]             }
[16:20:45.738]             else {
[16:20:45.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.738]             }
[16:20:45.738]             {
[16:20:45.738]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.738]                   0L) {
[16:20:45.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.738]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.738]                   base::options(opts)
[16:20:45.738]                 }
[16:20:45.738]                 {
[16:20:45.738]                   {
[16:20:45.738]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.738]                     NULL
[16:20:45.738]                   }
[16:20:45.738]                   options(future.plan = NULL)
[16:20:45.738]                   if (is.na(NA_character_)) 
[16:20:45.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.738]                     .init = FALSE)
[16:20:45.738]                 }
[16:20:45.738]             }
[16:20:45.738]         }
[16:20:45.738]     })
[16:20:45.738]     if (TRUE) {
[16:20:45.738]         base::sink(type = "output", split = FALSE)
[16:20:45.738]         if (TRUE) {
[16:20:45.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.738]         }
[16:20:45.738]         else {
[16:20:45.738]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.738]         }
[16:20:45.738]         base::close(...future.stdout)
[16:20:45.738]         ...future.stdout <- NULL
[16:20:45.738]     }
[16:20:45.738]     ...future.result$conditions <- ...future.conditions
[16:20:45.738]     ...future.result$finished <- base::Sys.time()
[16:20:45.738]     ...future.result
[16:20:45.738] }
[16:20:45.741] MultisessionFuture started
[16:20:45.741] - Launch lazy future ... done
[16:20:45.741] run() for ‘MultisessionFuture’ ... done
[16:20:45.741] getGlobalsAndPackages() ...
[16:20:45.741] Searching for globals...
[16:20:45.742] 
[16:20:45.742] Searching for globals ... DONE
[16:20:45.742] - globals: [0] <none>
[16:20:45.742] getGlobalsAndPackages() ... DONE
[16:20:45.743] run() for ‘Future’ ...
[16:20:45.743] - state: ‘created’
[16:20:45.747] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.761] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:45.762]   - Field: ‘node’
[16:20:45.762]   - Field: ‘label’
[16:20:45.762]   - Field: ‘local’
[16:20:45.762]   - Field: ‘owner’
[16:20:45.762]   - Field: ‘envir’
[16:20:45.762]   - Field: ‘workers’
[16:20:45.762]   - Field: ‘packages’
[16:20:45.762]   - Field: ‘gc’
[16:20:45.762]   - Field: ‘conditions’
[16:20:45.762]   - Field: ‘persistent’
[16:20:45.762]   - Field: ‘expr’
[16:20:45.763]   - Field: ‘uuid’
[16:20:45.763]   - Field: ‘seed’
[16:20:45.763]   - Field: ‘version’
[16:20:45.763]   - Field: ‘result’
[16:20:45.763]   - Field: ‘asynchronous’
[16:20:45.763]   - Field: ‘calls’
[16:20:45.763]   - Field: ‘globals’
[16:20:45.763]   - Field: ‘stdout’
[16:20:45.763]   - Field: ‘earlySignal’
[16:20:45.763]   - Field: ‘lazy’
[16:20:45.763]   - Field: ‘state’
[16:20:45.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:45.764] - Launch lazy future ...
[16:20:45.764] Packages needed by the future expression (n = 0): <none>
[16:20:45.764] Packages needed by future strategies (n = 0): <none>
[16:20:45.764] {
[16:20:45.764]     {
[16:20:45.764]         {
[16:20:45.764]             ...future.startTime <- base::Sys.time()
[16:20:45.764]             {
[16:20:45.764]                 {
[16:20:45.764]                   {
[16:20:45.764]                     {
[16:20:45.764]                       base::local({
[16:20:45.764]                         has_future <- base::requireNamespace("future", 
[16:20:45.764]                           quietly = TRUE)
[16:20:45.764]                         if (has_future) {
[16:20:45.764]                           ns <- base::getNamespace("future")
[16:20:45.764]                           version <- ns[[".package"]][["version"]]
[16:20:45.764]                           if (is.null(version)) 
[16:20:45.764]                             version <- utils::packageVersion("future")
[16:20:45.764]                         }
[16:20:45.764]                         else {
[16:20:45.764]                           version <- NULL
[16:20:45.764]                         }
[16:20:45.764]                         if (!has_future || version < "1.8.0") {
[16:20:45.764]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.764]                             "", base::R.version$version.string), 
[16:20:45.764]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.764]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.764]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.764]                               "release", "version")], collapse = " "), 
[16:20:45.764]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.764]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.764]                             info)
[16:20:45.764]                           info <- base::paste(info, collapse = "; ")
[16:20:45.764]                           if (!has_future) {
[16:20:45.764]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.764]                               info)
[16:20:45.764]                           }
[16:20:45.764]                           else {
[16:20:45.764]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.764]                               info, version)
[16:20:45.764]                           }
[16:20:45.764]                           base::stop(msg)
[16:20:45.764]                         }
[16:20:45.764]                       })
[16:20:45.764]                     }
[16:20:45.764]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.764]                     base::options(mc.cores = 1L)
[16:20:45.764]                   }
[16:20:45.764]                   ...future.strategy.old <- future::plan("list")
[16:20:45.764]                   options(future.plan = NULL)
[16:20:45.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.764]                 }
[16:20:45.764]                 ...future.workdir <- getwd()
[16:20:45.764]             }
[16:20:45.764]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.764]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.764]         }
[16:20:45.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.764]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.764]             base::names(...future.oldOptions))
[16:20:45.764]     }
[16:20:45.764]     if (FALSE) {
[16:20:45.764]     }
[16:20:45.764]     else {
[16:20:45.764]         if (TRUE) {
[16:20:45.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.764]                 open = "w")
[16:20:45.764]         }
[16:20:45.764]         else {
[16:20:45.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.764]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.764]         }
[16:20:45.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.764]             base::sink(type = "output", split = FALSE)
[16:20:45.764]             base::close(...future.stdout)
[16:20:45.764]         }, add = TRUE)
[16:20:45.764]     }
[16:20:45.764]     ...future.frame <- base::sys.nframe()
[16:20:45.764]     ...future.conditions <- base::list()
[16:20:45.764]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.764]     if (FALSE) {
[16:20:45.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.764]     }
[16:20:45.764]     ...future.result <- base::tryCatch({
[16:20:45.764]         base::withCallingHandlers({
[16:20:45.764]             ...future.value <- base::withVisible(base::local({
[16:20:45.764]                 ...future.makeSendCondition <- base::local({
[16:20:45.764]                   sendCondition <- NULL
[16:20:45.764]                   function(frame = 1L) {
[16:20:45.764]                     if (is.function(sendCondition)) 
[16:20:45.764]                       return(sendCondition)
[16:20:45.764]                     ns <- getNamespace("parallel")
[16:20:45.764]                     if (exists("sendData", mode = "function", 
[16:20:45.764]                       envir = ns)) {
[16:20:45.764]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:45.764]                         envir = ns)
[16:20:45.764]                       envir <- sys.frame(frame)
[16:20:45.764]                       master <- NULL
[16:20:45.764]                       while (!identical(envir, .GlobalEnv) && 
[16:20:45.764]                         !identical(envir, emptyenv())) {
[16:20:45.764]                         if (exists("master", mode = "list", envir = envir, 
[16:20:45.764]                           inherits = FALSE)) {
[16:20:45.764]                           master <- get("master", mode = "list", 
[16:20:45.764]                             envir = envir, inherits = FALSE)
[16:20:45.764]                           if (inherits(master, c("SOCKnode", 
[16:20:45.764]                             "SOCK0node"))) {
[16:20:45.764]                             sendCondition <<- function(cond) {
[16:20:45.764]                               data <- list(type = "VALUE", value = cond, 
[16:20:45.764]                                 success = TRUE)
[16:20:45.764]                               parallel_sendData(master, data)
[16:20:45.764]                             }
[16:20:45.764]                             return(sendCondition)
[16:20:45.764]                           }
[16:20:45.764]                         }
[16:20:45.764]                         frame <- frame + 1L
[16:20:45.764]                         envir <- sys.frame(frame)
[16:20:45.764]                       }
[16:20:45.764]                     }
[16:20:45.764]                     sendCondition <<- function(cond) NULL
[16:20:45.764]                   }
[16:20:45.764]                 })
[16:20:45.764]                 withCallingHandlers({
[16:20:45.764]                   NULL
[16:20:45.764]                 }, immediateCondition = function(cond) {
[16:20:45.764]                   sendCondition <- ...future.makeSendCondition()
[16:20:45.764]                   sendCondition(cond)
[16:20:45.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.764]                   {
[16:20:45.764]                     inherits <- base::inherits
[16:20:45.764]                     invokeRestart <- base::invokeRestart
[16:20:45.764]                     is.null <- base::is.null
[16:20:45.764]                     muffled <- FALSE
[16:20:45.764]                     if (inherits(cond, "message")) {
[16:20:45.764]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.764]                       if (muffled) 
[16:20:45.764]                         invokeRestart("muffleMessage")
[16:20:45.764]                     }
[16:20:45.764]                     else if (inherits(cond, "warning")) {
[16:20:45.764]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.764]                       if (muffled) 
[16:20:45.764]                         invokeRestart("muffleWarning")
[16:20:45.764]                     }
[16:20:45.764]                     else if (inherits(cond, "condition")) {
[16:20:45.764]                       if (!is.null(pattern)) {
[16:20:45.764]                         computeRestarts <- base::computeRestarts
[16:20:45.764]                         grepl <- base::grepl
[16:20:45.764]                         restarts <- computeRestarts(cond)
[16:20:45.764]                         for (restart in restarts) {
[16:20:45.764]                           name <- restart$name
[16:20:45.764]                           if (is.null(name)) 
[16:20:45.764]                             next
[16:20:45.764]                           if (!grepl(pattern, name)) 
[16:20:45.764]                             next
[16:20:45.764]                           invokeRestart(restart)
[16:20:45.764]                           muffled <- TRUE
[16:20:45.764]                           break
[16:20:45.764]                         }
[16:20:45.764]                       }
[16:20:45.764]                     }
[16:20:45.764]                     invisible(muffled)
[16:20:45.764]                   }
[16:20:45.764]                   muffleCondition(cond)
[16:20:45.764]                 })
[16:20:45.764]             }))
[16:20:45.764]             future::FutureResult(value = ...future.value$value, 
[16:20:45.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.764]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.764]                     ...future.globalenv.names))
[16:20:45.764]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.764]         }, condition = base::local({
[16:20:45.764]             c <- base::c
[16:20:45.764]             inherits <- base::inherits
[16:20:45.764]             invokeRestart <- base::invokeRestart
[16:20:45.764]             length <- base::length
[16:20:45.764]             list <- base::list
[16:20:45.764]             seq.int <- base::seq.int
[16:20:45.764]             signalCondition <- base::signalCondition
[16:20:45.764]             sys.calls <- base::sys.calls
[16:20:45.764]             `[[` <- base::`[[`
[16:20:45.764]             `+` <- base::`+`
[16:20:45.764]             `<<-` <- base::`<<-`
[16:20:45.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.764]                   3L)]
[16:20:45.764]             }
[16:20:45.764]             function(cond) {
[16:20:45.764]                 is_error <- inherits(cond, "error")
[16:20:45.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.764]                   NULL)
[16:20:45.764]                 if (is_error) {
[16:20:45.764]                   sessionInformation <- function() {
[16:20:45.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.764]                       search = base::search(), system = base::Sys.info())
[16:20:45.764]                   }
[16:20:45.764]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.764]                     cond$call), session = sessionInformation(), 
[16:20:45.764]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.764]                   signalCondition(cond)
[16:20:45.764]                 }
[16:20:45.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.764]                 "immediateCondition"))) {
[16:20:45.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.764]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.764]                   if (TRUE && !signal) {
[16:20:45.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.764]                     {
[16:20:45.764]                       inherits <- base::inherits
[16:20:45.764]                       invokeRestart <- base::invokeRestart
[16:20:45.764]                       is.null <- base::is.null
[16:20:45.764]                       muffled <- FALSE
[16:20:45.764]                       if (inherits(cond, "message")) {
[16:20:45.764]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.764]                         if (muffled) 
[16:20:45.764]                           invokeRestart("muffleMessage")
[16:20:45.764]                       }
[16:20:45.764]                       else if (inherits(cond, "warning")) {
[16:20:45.764]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.764]                         if (muffled) 
[16:20:45.764]                           invokeRestart("muffleWarning")
[16:20:45.764]                       }
[16:20:45.764]                       else if (inherits(cond, "condition")) {
[16:20:45.764]                         if (!is.null(pattern)) {
[16:20:45.764]                           computeRestarts <- base::computeRestarts
[16:20:45.764]                           grepl <- base::grepl
[16:20:45.764]                           restarts <- computeRestarts(cond)
[16:20:45.764]                           for (restart in restarts) {
[16:20:45.764]                             name <- restart$name
[16:20:45.764]                             if (is.null(name)) 
[16:20:45.764]                               next
[16:20:45.764]                             if (!grepl(pattern, name)) 
[16:20:45.764]                               next
[16:20:45.764]                             invokeRestart(restart)
[16:20:45.764]                             muffled <- TRUE
[16:20:45.764]                             break
[16:20:45.764]                           }
[16:20:45.764]                         }
[16:20:45.764]                       }
[16:20:45.764]                       invisible(muffled)
[16:20:45.764]                     }
[16:20:45.764]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.764]                   }
[16:20:45.764]                 }
[16:20:45.764]                 else {
[16:20:45.764]                   if (TRUE) {
[16:20:45.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.764]                     {
[16:20:45.764]                       inherits <- base::inherits
[16:20:45.764]                       invokeRestart <- base::invokeRestart
[16:20:45.764]                       is.null <- base::is.null
[16:20:45.764]                       muffled <- FALSE
[16:20:45.764]                       if (inherits(cond, "message")) {
[16:20:45.764]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.764]                         if (muffled) 
[16:20:45.764]                           invokeRestart("muffleMessage")
[16:20:45.764]                       }
[16:20:45.764]                       else if (inherits(cond, "warning")) {
[16:20:45.764]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.764]                         if (muffled) 
[16:20:45.764]                           invokeRestart("muffleWarning")
[16:20:45.764]                       }
[16:20:45.764]                       else if (inherits(cond, "condition")) {
[16:20:45.764]                         if (!is.null(pattern)) {
[16:20:45.764]                           computeRestarts <- base::computeRestarts
[16:20:45.764]                           grepl <- base::grepl
[16:20:45.764]                           restarts <- computeRestarts(cond)
[16:20:45.764]                           for (restart in restarts) {
[16:20:45.764]                             name <- restart$name
[16:20:45.764]                             if (is.null(name)) 
[16:20:45.764]                               next
[16:20:45.764]                             if (!grepl(pattern, name)) 
[16:20:45.764]                               next
[16:20:45.764]                             invokeRestart(restart)
[16:20:45.764]                             muffled <- TRUE
[16:20:45.764]                             break
[16:20:45.764]                           }
[16:20:45.764]                         }
[16:20:45.764]                       }
[16:20:45.764]                       invisible(muffled)
[16:20:45.764]                     }
[16:20:45.764]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.764]                   }
[16:20:45.764]                 }
[16:20:45.764]             }
[16:20:45.764]         }))
[16:20:45.764]     }, error = function(ex) {
[16:20:45.764]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.764]                 ...future.rng), started = ...future.startTime, 
[16:20:45.764]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.764]             version = "1.8"), class = "FutureResult")
[16:20:45.764]     }, finally = {
[16:20:45.764]         if (!identical(...future.workdir, getwd())) 
[16:20:45.764]             setwd(...future.workdir)
[16:20:45.764]         {
[16:20:45.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.764]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.764]             }
[16:20:45.764]             base::options(...future.oldOptions)
[16:20:45.764]             if (.Platform$OS.type == "windows") {
[16:20:45.764]                 old_names <- names(...future.oldEnvVars)
[16:20:45.764]                 envs <- base::Sys.getenv()
[16:20:45.764]                 names <- names(envs)
[16:20:45.764]                 common <- intersect(names, old_names)
[16:20:45.764]                 added <- setdiff(names, old_names)
[16:20:45.764]                 removed <- setdiff(old_names, names)
[16:20:45.764]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.764]                   envs[common]]
[16:20:45.764]                 NAMES <- toupper(changed)
[16:20:45.764]                 args <- list()
[16:20:45.764]                 for (kk in seq_along(NAMES)) {
[16:20:45.764]                   name <- changed[[kk]]
[16:20:45.764]                   NAME <- NAMES[[kk]]
[16:20:45.764]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.764]                     next
[16:20:45.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.764]                 }
[16:20:45.764]                 NAMES <- toupper(added)
[16:20:45.764]                 for (kk in seq_along(NAMES)) {
[16:20:45.764]                   name <- added[[kk]]
[16:20:45.764]                   NAME <- NAMES[[kk]]
[16:20:45.764]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.764]                     next
[16:20:45.764]                   args[[name]] <- ""
[16:20:45.764]                 }
[16:20:45.764]                 NAMES <- toupper(removed)
[16:20:45.764]                 for (kk in seq_along(NAMES)) {
[16:20:45.764]                   name <- removed[[kk]]
[16:20:45.764]                   NAME <- NAMES[[kk]]
[16:20:45.764]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.764]                     next
[16:20:45.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.764]                 }
[16:20:45.764]                 if (length(args) > 0) 
[16:20:45.764]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.764]             }
[16:20:45.764]             else {
[16:20:45.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.764]             }
[16:20:45.764]             {
[16:20:45.764]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.764]                   0L) {
[16:20:45.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.764]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.764]                   base::options(opts)
[16:20:45.764]                 }
[16:20:45.764]                 {
[16:20:45.764]                   {
[16:20:45.764]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.764]                     NULL
[16:20:45.764]                   }
[16:20:45.764]                   options(future.plan = NULL)
[16:20:45.764]                   if (is.na(NA_character_)) 
[16:20:45.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.764]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.764]                     .init = FALSE)
[16:20:45.764]                 }
[16:20:45.764]             }
[16:20:45.764]         }
[16:20:45.764]     })
[16:20:45.764]     if (TRUE) {
[16:20:45.764]         base::sink(type = "output", split = FALSE)
[16:20:45.764]         if (TRUE) {
[16:20:45.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.764]         }
[16:20:45.764]         else {
[16:20:45.764]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.764]         }
[16:20:45.764]         base::close(...future.stdout)
[16:20:45.764]         ...future.stdout <- NULL
[16:20:45.764]     }
[16:20:45.764]     ...future.result$conditions <- ...future.conditions
[16:20:45.764]     ...future.result$finished <- base::Sys.time()
[16:20:45.764]     ...future.result
[16:20:45.764] }
[16:20:45.818] MultisessionFuture started
[16:20:45.818] - Launch lazy future ... done
[16:20:45.818] run() for ‘MultisessionFuture’ ... done
[16:20:45.819] getGlobalsAndPackages() ...
[16:20:45.819] Searching for globals...
[16:20:45.819] - globals found: [1] ‘{’
[16:20:45.820] Searching for globals ... DONE
[16:20:45.820] Resolving globals: FALSE
[16:20:45.820] 
[16:20:45.820] 
[16:20:45.820] getGlobalsAndPackages() ... DONE
[16:20:45.820] run() for ‘Future’ ...
[16:20:45.821] - state: ‘created’
[16:20:45.821] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.835] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:45.835]   - Field: ‘node’
[16:20:45.835]   - Field: ‘label’
[16:20:45.835]   - Field: ‘local’
[16:20:45.835]   - Field: ‘owner’
[16:20:45.835]   - Field: ‘envir’
[16:20:45.835]   - Field: ‘workers’
[16:20:45.836]   - Field: ‘packages’
[16:20:45.836]   - Field: ‘gc’
[16:20:45.836]   - Field: ‘conditions’
[16:20:45.836]   - Field: ‘persistent’
[16:20:45.836]   - Field: ‘expr’
[16:20:45.836]   - Field: ‘uuid’
[16:20:45.836]   - Field: ‘seed’
[16:20:45.836]   - Field: ‘version’
[16:20:45.836]   - Field: ‘result’
[16:20:45.836]   - Field: ‘asynchronous’
[16:20:45.837]   - Field: ‘calls’
[16:20:45.837]   - Field: ‘globals’
[16:20:45.837]   - Field: ‘stdout’
[16:20:45.837]   - Field: ‘earlySignal’
[16:20:45.837]   - Field: ‘lazy’
[16:20:45.837]   - Field: ‘state’
[16:20:45.837] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:45.837] - Launch lazy future ...
[16:20:45.837] Packages needed by the future expression (n = 0): <none>
[16:20:45.838] Packages needed by future strategies (n = 0): <none>
[16:20:45.838] {
[16:20:45.838]     {
[16:20:45.838]         {
[16:20:45.838]             ...future.startTime <- base::Sys.time()
[16:20:45.838]             {
[16:20:45.838]                 {
[16:20:45.838]                   {
[16:20:45.838]                     {
[16:20:45.838]                       base::local({
[16:20:45.838]                         has_future <- base::requireNamespace("future", 
[16:20:45.838]                           quietly = TRUE)
[16:20:45.838]                         if (has_future) {
[16:20:45.838]                           ns <- base::getNamespace("future")
[16:20:45.838]                           version <- ns[[".package"]][["version"]]
[16:20:45.838]                           if (is.null(version)) 
[16:20:45.838]                             version <- utils::packageVersion("future")
[16:20:45.838]                         }
[16:20:45.838]                         else {
[16:20:45.838]                           version <- NULL
[16:20:45.838]                         }
[16:20:45.838]                         if (!has_future || version < "1.8.0") {
[16:20:45.838]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.838]                             "", base::R.version$version.string), 
[16:20:45.838]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.838]                               "release", "version")], collapse = " "), 
[16:20:45.838]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.838]                             info)
[16:20:45.838]                           info <- base::paste(info, collapse = "; ")
[16:20:45.838]                           if (!has_future) {
[16:20:45.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.838]                               info)
[16:20:45.838]                           }
[16:20:45.838]                           else {
[16:20:45.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.838]                               info, version)
[16:20:45.838]                           }
[16:20:45.838]                           base::stop(msg)
[16:20:45.838]                         }
[16:20:45.838]                       })
[16:20:45.838]                     }
[16:20:45.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.838]                     base::options(mc.cores = 1L)
[16:20:45.838]                   }
[16:20:45.838]                   ...future.strategy.old <- future::plan("list")
[16:20:45.838]                   options(future.plan = NULL)
[16:20:45.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.838]                 }
[16:20:45.838]                 ...future.workdir <- getwd()
[16:20:45.838]             }
[16:20:45.838]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.838]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.838]         }
[16:20:45.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.838]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.838]             base::names(...future.oldOptions))
[16:20:45.838]     }
[16:20:45.838]     if (FALSE) {
[16:20:45.838]     }
[16:20:45.838]     else {
[16:20:45.838]         if (TRUE) {
[16:20:45.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.838]                 open = "w")
[16:20:45.838]         }
[16:20:45.838]         else {
[16:20:45.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.838]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.838]         }
[16:20:45.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.838]             base::sink(type = "output", split = FALSE)
[16:20:45.838]             base::close(...future.stdout)
[16:20:45.838]         }, add = TRUE)
[16:20:45.838]     }
[16:20:45.838]     ...future.frame <- base::sys.nframe()
[16:20:45.838]     ...future.conditions <- base::list()
[16:20:45.838]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.838]     if (FALSE) {
[16:20:45.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.838]     }
[16:20:45.838]     ...future.result <- base::tryCatch({
[16:20:45.838]         base::withCallingHandlers({
[16:20:45.838]             ...future.value <- base::withVisible(base::local({
[16:20:45.838]                 ...future.makeSendCondition <- base::local({
[16:20:45.838]                   sendCondition <- NULL
[16:20:45.838]                   function(frame = 1L) {
[16:20:45.838]                     if (is.function(sendCondition)) 
[16:20:45.838]                       return(sendCondition)
[16:20:45.838]                     ns <- getNamespace("parallel")
[16:20:45.838]                     if (exists("sendData", mode = "function", 
[16:20:45.838]                       envir = ns)) {
[16:20:45.838]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:45.838]                         envir = ns)
[16:20:45.838]                       envir <- sys.frame(frame)
[16:20:45.838]                       master <- NULL
[16:20:45.838]                       while (!identical(envir, .GlobalEnv) && 
[16:20:45.838]                         !identical(envir, emptyenv())) {
[16:20:45.838]                         if (exists("master", mode = "list", envir = envir, 
[16:20:45.838]                           inherits = FALSE)) {
[16:20:45.838]                           master <- get("master", mode = "list", 
[16:20:45.838]                             envir = envir, inherits = FALSE)
[16:20:45.838]                           if (inherits(master, c("SOCKnode", 
[16:20:45.838]                             "SOCK0node"))) {
[16:20:45.838]                             sendCondition <<- function(cond) {
[16:20:45.838]                               data <- list(type = "VALUE", value = cond, 
[16:20:45.838]                                 success = TRUE)
[16:20:45.838]                               parallel_sendData(master, data)
[16:20:45.838]                             }
[16:20:45.838]                             return(sendCondition)
[16:20:45.838]                           }
[16:20:45.838]                         }
[16:20:45.838]                         frame <- frame + 1L
[16:20:45.838]                         envir <- sys.frame(frame)
[16:20:45.838]                       }
[16:20:45.838]                     }
[16:20:45.838]                     sendCondition <<- function(cond) NULL
[16:20:45.838]                   }
[16:20:45.838]                 })
[16:20:45.838]                 withCallingHandlers({
[16:20:45.838]                   {
[16:20:45.838]                     4
[16:20:45.838]                   }
[16:20:45.838]                 }, immediateCondition = function(cond) {
[16:20:45.838]                   sendCondition <- ...future.makeSendCondition()
[16:20:45.838]                   sendCondition(cond)
[16:20:45.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.838]                   {
[16:20:45.838]                     inherits <- base::inherits
[16:20:45.838]                     invokeRestart <- base::invokeRestart
[16:20:45.838]                     is.null <- base::is.null
[16:20:45.838]                     muffled <- FALSE
[16:20:45.838]                     if (inherits(cond, "message")) {
[16:20:45.838]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.838]                       if (muffled) 
[16:20:45.838]                         invokeRestart("muffleMessage")
[16:20:45.838]                     }
[16:20:45.838]                     else if (inherits(cond, "warning")) {
[16:20:45.838]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.838]                       if (muffled) 
[16:20:45.838]                         invokeRestart("muffleWarning")
[16:20:45.838]                     }
[16:20:45.838]                     else if (inherits(cond, "condition")) {
[16:20:45.838]                       if (!is.null(pattern)) {
[16:20:45.838]                         computeRestarts <- base::computeRestarts
[16:20:45.838]                         grepl <- base::grepl
[16:20:45.838]                         restarts <- computeRestarts(cond)
[16:20:45.838]                         for (restart in restarts) {
[16:20:45.838]                           name <- restart$name
[16:20:45.838]                           if (is.null(name)) 
[16:20:45.838]                             next
[16:20:45.838]                           if (!grepl(pattern, name)) 
[16:20:45.838]                             next
[16:20:45.838]                           invokeRestart(restart)
[16:20:45.838]                           muffled <- TRUE
[16:20:45.838]                           break
[16:20:45.838]                         }
[16:20:45.838]                       }
[16:20:45.838]                     }
[16:20:45.838]                     invisible(muffled)
[16:20:45.838]                   }
[16:20:45.838]                   muffleCondition(cond)
[16:20:45.838]                 })
[16:20:45.838]             }))
[16:20:45.838]             future::FutureResult(value = ...future.value$value, 
[16:20:45.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.838]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.838]                     ...future.globalenv.names))
[16:20:45.838]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.838]         }, condition = base::local({
[16:20:45.838]             c <- base::c
[16:20:45.838]             inherits <- base::inherits
[16:20:45.838]             invokeRestart <- base::invokeRestart
[16:20:45.838]             length <- base::length
[16:20:45.838]             list <- base::list
[16:20:45.838]             seq.int <- base::seq.int
[16:20:45.838]             signalCondition <- base::signalCondition
[16:20:45.838]             sys.calls <- base::sys.calls
[16:20:45.838]             `[[` <- base::`[[`
[16:20:45.838]             `+` <- base::`+`
[16:20:45.838]             `<<-` <- base::`<<-`
[16:20:45.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.838]                   3L)]
[16:20:45.838]             }
[16:20:45.838]             function(cond) {
[16:20:45.838]                 is_error <- inherits(cond, "error")
[16:20:45.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.838]                   NULL)
[16:20:45.838]                 if (is_error) {
[16:20:45.838]                   sessionInformation <- function() {
[16:20:45.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.838]                       search = base::search(), system = base::Sys.info())
[16:20:45.838]                   }
[16:20:45.838]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.838]                     cond$call), session = sessionInformation(), 
[16:20:45.838]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.838]                   signalCondition(cond)
[16:20:45.838]                 }
[16:20:45.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.838]                 "immediateCondition"))) {
[16:20:45.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.838]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.838]                   if (TRUE && !signal) {
[16:20:45.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.838]                     {
[16:20:45.838]                       inherits <- base::inherits
[16:20:45.838]                       invokeRestart <- base::invokeRestart
[16:20:45.838]                       is.null <- base::is.null
[16:20:45.838]                       muffled <- FALSE
[16:20:45.838]                       if (inherits(cond, "message")) {
[16:20:45.838]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.838]                         if (muffled) 
[16:20:45.838]                           invokeRestart("muffleMessage")
[16:20:45.838]                       }
[16:20:45.838]                       else if (inherits(cond, "warning")) {
[16:20:45.838]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.838]                         if (muffled) 
[16:20:45.838]                           invokeRestart("muffleWarning")
[16:20:45.838]                       }
[16:20:45.838]                       else if (inherits(cond, "condition")) {
[16:20:45.838]                         if (!is.null(pattern)) {
[16:20:45.838]                           computeRestarts <- base::computeRestarts
[16:20:45.838]                           grepl <- base::grepl
[16:20:45.838]                           restarts <- computeRestarts(cond)
[16:20:45.838]                           for (restart in restarts) {
[16:20:45.838]                             name <- restart$name
[16:20:45.838]                             if (is.null(name)) 
[16:20:45.838]                               next
[16:20:45.838]                             if (!grepl(pattern, name)) 
[16:20:45.838]                               next
[16:20:45.838]                             invokeRestart(restart)
[16:20:45.838]                             muffled <- TRUE
[16:20:45.838]                             break
[16:20:45.838]                           }
[16:20:45.838]                         }
[16:20:45.838]                       }
[16:20:45.838]                       invisible(muffled)
[16:20:45.838]                     }
[16:20:45.838]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.838]                   }
[16:20:45.838]                 }
[16:20:45.838]                 else {
[16:20:45.838]                   if (TRUE) {
[16:20:45.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.838]                     {
[16:20:45.838]                       inherits <- base::inherits
[16:20:45.838]                       invokeRestart <- base::invokeRestart
[16:20:45.838]                       is.null <- base::is.null
[16:20:45.838]                       muffled <- FALSE
[16:20:45.838]                       if (inherits(cond, "message")) {
[16:20:45.838]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.838]                         if (muffled) 
[16:20:45.838]                           invokeRestart("muffleMessage")
[16:20:45.838]                       }
[16:20:45.838]                       else if (inherits(cond, "warning")) {
[16:20:45.838]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.838]                         if (muffled) 
[16:20:45.838]                           invokeRestart("muffleWarning")
[16:20:45.838]                       }
[16:20:45.838]                       else if (inherits(cond, "condition")) {
[16:20:45.838]                         if (!is.null(pattern)) {
[16:20:45.838]                           computeRestarts <- base::computeRestarts
[16:20:45.838]                           grepl <- base::grepl
[16:20:45.838]                           restarts <- computeRestarts(cond)
[16:20:45.838]                           for (restart in restarts) {
[16:20:45.838]                             name <- restart$name
[16:20:45.838]                             if (is.null(name)) 
[16:20:45.838]                               next
[16:20:45.838]                             if (!grepl(pattern, name)) 
[16:20:45.838]                               next
[16:20:45.838]                             invokeRestart(restart)
[16:20:45.838]                             muffled <- TRUE
[16:20:45.838]                             break
[16:20:45.838]                           }
[16:20:45.838]                         }
[16:20:45.838]                       }
[16:20:45.838]                       invisible(muffled)
[16:20:45.838]                     }
[16:20:45.838]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.838]                   }
[16:20:45.838]                 }
[16:20:45.838]             }
[16:20:45.838]         }))
[16:20:45.838]     }, error = function(ex) {
[16:20:45.838]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.838]                 ...future.rng), started = ...future.startTime, 
[16:20:45.838]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.838]             version = "1.8"), class = "FutureResult")
[16:20:45.838]     }, finally = {
[16:20:45.838]         if (!identical(...future.workdir, getwd())) 
[16:20:45.838]             setwd(...future.workdir)
[16:20:45.838]         {
[16:20:45.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.838]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.838]             }
[16:20:45.838]             base::options(...future.oldOptions)
[16:20:45.838]             if (.Platform$OS.type == "windows") {
[16:20:45.838]                 old_names <- names(...future.oldEnvVars)
[16:20:45.838]                 envs <- base::Sys.getenv()
[16:20:45.838]                 names <- names(envs)
[16:20:45.838]                 common <- intersect(names, old_names)
[16:20:45.838]                 added <- setdiff(names, old_names)
[16:20:45.838]                 removed <- setdiff(old_names, names)
[16:20:45.838]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.838]                   envs[common]]
[16:20:45.838]                 NAMES <- toupper(changed)
[16:20:45.838]                 args <- list()
[16:20:45.838]                 for (kk in seq_along(NAMES)) {
[16:20:45.838]                   name <- changed[[kk]]
[16:20:45.838]                   NAME <- NAMES[[kk]]
[16:20:45.838]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.838]                     next
[16:20:45.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.838]                 }
[16:20:45.838]                 NAMES <- toupper(added)
[16:20:45.838]                 for (kk in seq_along(NAMES)) {
[16:20:45.838]                   name <- added[[kk]]
[16:20:45.838]                   NAME <- NAMES[[kk]]
[16:20:45.838]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.838]                     next
[16:20:45.838]                   args[[name]] <- ""
[16:20:45.838]                 }
[16:20:45.838]                 NAMES <- toupper(removed)
[16:20:45.838]                 for (kk in seq_along(NAMES)) {
[16:20:45.838]                   name <- removed[[kk]]
[16:20:45.838]                   NAME <- NAMES[[kk]]
[16:20:45.838]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.838]                     next
[16:20:45.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.838]                 }
[16:20:45.838]                 if (length(args) > 0) 
[16:20:45.838]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.838]             }
[16:20:45.838]             else {
[16:20:45.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.838]             }
[16:20:45.838]             {
[16:20:45.838]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.838]                   0L) {
[16:20:45.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.838]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.838]                   base::options(opts)
[16:20:45.838]                 }
[16:20:45.838]                 {
[16:20:45.838]                   {
[16:20:45.838]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.838]                     NULL
[16:20:45.838]                   }
[16:20:45.838]                   options(future.plan = NULL)
[16:20:45.838]                   if (is.na(NA_character_)) 
[16:20:45.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.838]                     .init = FALSE)
[16:20:45.838]                 }
[16:20:45.838]             }
[16:20:45.838]         }
[16:20:45.838]     })
[16:20:45.838]     if (TRUE) {
[16:20:45.838]         base::sink(type = "output", split = FALSE)
[16:20:45.838]         if (TRUE) {
[16:20:45.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.838]         }
[16:20:45.838]         else {
[16:20:45.838]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.838]         }
[16:20:45.838]         base::close(...future.stdout)
[16:20:45.838]         ...future.stdout <- NULL
[16:20:45.838]     }
[16:20:45.838]     ...future.result$conditions <- ...future.conditions
[16:20:45.838]     ...future.result$finished <- base::Sys.time()
[16:20:45.838]     ...future.result
[16:20:45.838] }
[16:20:45.840] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:45.851] receiveMessageFromWorker() for ClusterFuture ...
[16:20:45.851] - Validating connection of MultisessionFuture
[16:20:45.851] - received message: FutureResult
[16:20:45.852] - Received FutureResult
[16:20:45.852] - Erased future from FutureRegistry
[16:20:45.852] result() for ClusterFuture ...
[16:20:45.852] - result already collected: FutureResult
[16:20:45.852] result() for ClusterFuture ... done
[16:20:45.852] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:45.852] result() for ClusterFuture ...
[16:20:45.852] - result already collected: FutureResult
[16:20:45.852] result() for ClusterFuture ... done
[16:20:45.853] result() for ClusterFuture ...
[16:20:45.853] - result already collected: FutureResult
[16:20:45.853] result() for ClusterFuture ... done
[16:20:45.854] MultisessionFuture started
[16:20:45.854] - Launch lazy future ... done
[16:20:45.854] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0dd8bbb8> 
Classes 'listenv', 'environment' <environment: 0x55ed0bbdfc60> 
[16:20:45.857] receiveMessageFromWorker() for ClusterFuture ...
[16:20:45.857] - Validating connection of MultisessionFuture
[16:20:45.857] - received message: FutureResult
[16:20:45.857] - Received FutureResult
[16:20:45.857] - Erased future from FutureRegistry
[16:20:45.857] result() for ClusterFuture ...
[16:20:45.857] - result already collected: FutureResult
[16:20:45.857] result() for ClusterFuture ... done
[16:20:45.858] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:45.858] receiveMessageFromWorker() for ClusterFuture ...
[16:20:45.858] - Validating connection of MultisessionFuture
[16:20:45.858] - received message: FutureResult
[16:20:45.858] - Received FutureResult
[16:20:45.858] - Erased future from FutureRegistry
[16:20:45.859] result() for ClusterFuture ...
[16:20:45.859] - result already collected: FutureResult
[16:20:45.859] result() for ClusterFuture ... done
[16:20:45.859] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:45.860] resolve() on list environment ...
[16:20:45.860]  recursive: 0
[16:20:45.861]  length: 6
[16:20:45.861]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:45.862] signalConditionsASAP(numeric, pos=1) ...
[16:20:45.862] - nx: 6
[16:20:45.862] - relay: TRUE
[16:20:45.862] - stdout: TRUE
[16:20:45.862] - signal: TRUE
[16:20:45.862] - resignal: FALSE
[16:20:45.862] - force: TRUE
[16:20:45.862] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.862] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.862]  - until=2
[16:20:45.862]  - relaying element #2
[16:20:45.863] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.863] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.863] signalConditionsASAP(NULL, pos=1) ... done
[16:20:45.863]  length: 5 (resolved future 1)
[16:20:45.863] Future #2
[16:20:45.863] result() for ClusterFuture ...
[16:20:45.863] - result already collected: FutureResult
[16:20:45.863] result() for ClusterFuture ... done
[16:20:45.863] result() for ClusterFuture ...
[16:20:45.863] - result already collected: FutureResult
[16:20:45.864] result() for ClusterFuture ... done
[16:20:45.864] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:45.864] - nx: 6
[16:20:45.864] - relay: TRUE
[16:20:45.864] - stdout: TRUE
[16:20:45.864] - signal: TRUE
[16:20:45.864] - resignal: FALSE
[16:20:45.864] - force: TRUE
[16:20:45.864] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.864] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.864]  - until=2
[16:20:45.865]  - relaying element #2
[16:20:45.865] result() for ClusterFuture ...
[16:20:45.865] - result already collected: FutureResult
[16:20:45.865] result() for ClusterFuture ... done
[16:20:45.865] result() for ClusterFuture ...
[16:20:45.865] - result already collected: FutureResult
[16:20:45.865] result() for ClusterFuture ... done
[16:20:45.865] result() for ClusterFuture ...
[16:20:45.865] - result already collected: FutureResult
[16:20:45.865] result() for ClusterFuture ... done
[16:20:45.866] result() for ClusterFuture ...
[16:20:45.866] - result already collected: FutureResult
[16:20:45.866] result() for ClusterFuture ... done
[16:20:45.866] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.866] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.866] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:45.866]  length: 4 (resolved future 2)
[16:20:45.866] Future #3
[16:20:45.866] result() for ClusterFuture ...
[16:20:45.866] - result already collected: FutureResult
[16:20:45.866] result() for ClusterFuture ... done
[16:20:45.867] result() for ClusterFuture ...
[16:20:45.867] - result already collected: FutureResult
[16:20:45.867] result() for ClusterFuture ... done
[16:20:45.867] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:45.867] - nx: 6
[16:20:45.867] - relay: TRUE
[16:20:45.867] - stdout: TRUE
[16:20:45.867] - signal: TRUE
[16:20:45.867] - resignal: FALSE
[16:20:45.867] - force: TRUE
[16:20:45.867] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.867] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.868]  - until=3
[16:20:45.868]  - relaying element #3
[16:20:45.868] result() for ClusterFuture ...
[16:20:45.868] - result already collected: FutureResult
[16:20:45.868] result() for ClusterFuture ... done
[16:20:45.868] result() for ClusterFuture ...
[16:20:45.868] - result already collected: FutureResult
[16:20:45.868] result() for ClusterFuture ... done
[16:20:45.868] result() for ClusterFuture ...
[16:20:45.868] - result already collected: FutureResult
[16:20:45.868] result() for ClusterFuture ... done
[16:20:45.869] result() for ClusterFuture ...
[16:20:45.869] - result already collected: FutureResult
[16:20:45.869] result() for ClusterFuture ... done
[16:20:45.869] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.869] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.869] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:45.869]  length: 3 (resolved future 3)
[16:20:45.869] Future #4
[16:20:45.869] result() for ClusterFuture ...
[16:20:45.869] - result already collected: FutureResult
[16:20:45.869] result() for ClusterFuture ... done
[16:20:45.870] result() for ClusterFuture ...
[16:20:45.870] - result already collected: FutureResult
[16:20:45.870] result() for ClusterFuture ... done
[16:20:45.870] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:45.870] - nx: 6
[16:20:45.870] - relay: TRUE
[16:20:45.870] - stdout: TRUE
[16:20:45.870] - signal: TRUE
[16:20:45.870] - resignal: FALSE
[16:20:45.870] - force: TRUE
[16:20:45.870] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.871] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.871]  - until=4
[16:20:45.871]  - relaying element #4
[16:20:45.871] result() for ClusterFuture ...
[16:20:45.871] - result already collected: FutureResult
[16:20:45.871] result() for ClusterFuture ... done
[16:20:45.871] result() for ClusterFuture ...
[16:20:45.871] - result already collected: FutureResult
[16:20:45.871] result() for ClusterFuture ... done
[16:20:45.871] result() for ClusterFuture ...
[16:20:45.871] - result already collected: FutureResult
[16:20:45.872] result() for ClusterFuture ... done
[16:20:45.872] result() for ClusterFuture ...
[16:20:45.872] - result already collected: FutureResult
[16:20:45.872] result() for ClusterFuture ... done
[16:20:45.872] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.872] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.872] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:45.872]  length: 2 (resolved future 4)
[16:20:45.872] signalConditionsASAP(NULL, pos=5) ...
[16:20:45.872] - nx: 6
[16:20:45.872] - relay: TRUE
[16:20:45.873] - stdout: TRUE
[16:20:45.873] - signal: TRUE
[16:20:45.873] - resignal: FALSE
[16:20:45.873] - force: TRUE
[16:20:45.873] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.873] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.873]  - until=6
[16:20:45.873]  - relaying element #6
[16:20:45.873] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.873] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.873] signalConditionsASAP(NULL, pos=5) ... done
[16:20:45.873]  length: 1 (resolved future 5)
[16:20:45.874] signalConditionsASAP(numeric, pos=6) ...
[16:20:45.874] - nx: 6
[16:20:45.874] - relay: TRUE
[16:20:45.874] - stdout: TRUE
[16:20:45.874] - signal: TRUE
[16:20:45.874] - resignal: FALSE
[16:20:45.874] - force: TRUE
[16:20:45.874] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.874] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.874]  - until=6
[16:20:45.874] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.874] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.875] signalConditionsASAP(numeric, pos=6) ... done
[16:20:45.875]  length: 0 (resolved future 6)
[16:20:45.875] Relaying remaining futures
[16:20:45.875] signalConditionsASAP(NULL, pos=0) ...
[16:20:45.875] - nx: 6
[16:20:45.875] - relay: TRUE
[16:20:45.875] - stdout: TRUE
[16:20:45.875] - signal: TRUE
[16:20:45.875] - resignal: FALSE
[16:20:45.875] - force: TRUE
[16:20:45.875] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.875] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:45.876] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.876] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.876] signalConditionsASAP(NULL, pos=0) ... done
[16:20:45.876] resolve() on list environment ... DONE
[16:20:45.876] result() for ClusterFuture ...
[16:20:45.876] - result already collected: FutureResult
[16:20:45.876] result() for ClusterFuture ... done
[16:20:45.876] result() for ClusterFuture ...
[16:20:45.876] - result already collected: FutureResult
[16:20:45.876] result() for ClusterFuture ... done
[16:20:45.877] result() for ClusterFuture ...
[16:20:45.877] - result already collected: FutureResult
[16:20:45.877] result() for ClusterFuture ... done
[16:20:45.877] result() for ClusterFuture ...
[16:20:45.877] - result already collected: FutureResult
[16:20:45.877] result() for ClusterFuture ... done
[16:20:45.877] result() for ClusterFuture ...
[16:20:45.877] - result already collected: FutureResult
[16:20:45.877] result() for ClusterFuture ... done
[16:20:45.878] result() for ClusterFuture ...
[16:20:45.878] - result already collected: FutureResult
[16:20:45.878] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0ac11660> 
Dimensions: c(1, 6)
[16:20:45.878] getGlobalsAndPackages() ...
[16:20:45.878] Searching for globals...
[16:20:45.879] 
[16:20:45.879] Searching for globals ... DONE
[16:20:45.879] - globals: [0] <none>
[16:20:45.879] getGlobalsAndPackages() ... DONE
[16:20:45.879] run() for ‘Future’ ...
[16:20:45.879] - state: ‘created’
[16:20:45.879] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.893] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:45.894]   - Field: ‘node’
[16:20:45.894]   - Field: ‘label’
[16:20:45.894]   - Field: ‘local’
[16:20:45.894]   - Field: ‘owner’
[16:20:45.894]   - Field: ‘envir’
[16:20:45.894]   - Field: ‘workers’
[16:20:45.894]   - Field: ‘packages’
[16:20:45.894]   - Field: ‘gc’
[16:20:45.894]   - Field: ‘conditions’
[16:20:45.895]   - Field: ‘persistent’
[16:20:45.895]   - Field: ‘expr’
[16:20:45.895]   - Field: ‘uuid’
[16:20:45.895]   - Field: ‘seed’
[16:20:45.895]   - Field: ‘version’
[16:20:45.895]   - Field: ‘result’
[16:20:45.895]   - Field: ‘asynchronous’
[16:20:45.895]   - Field: ‘calls’
[16:20:45.895]   - Field: ‘globals’
[16:20:45.895]   - Field: ‘stdout’
[16:20:45.895]   - Field: ‘earlySignal’
[16:20:45.896]   - Field: ‘lazy’
[16:20:45.896]   - Field: ‘state’
[16:20:45.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:45.896] - Launch lazy future ...
[16:20:45.896] Packages needed by the future expression (n = 0): <none>
[16:20:45.896] Packages needed by future strategies (n = 0): <none>
[16:20:45.897] {
[16:20:45.897]     {
[16:20:45.897]         {
[16:20:45.897]             ...future.startTime <- base::Sys.time()
[16:20:45.897]             {
[16:20:45.897]                 {
[16:20:45.897]                   {
[16:20:45.897]                     {
[16:20:45.897]                       base::local({
[16:20:45.897]                         has_future <- base::requireNamespace("future", 
[16:20:45.897]                           quietly = TRUE)
[16:20:45.897]                         if (has_future) {
[16:20:45.897]                           ns <- base::getNamespace("future")
[16:20:45.897]                           version <- ns[[".package"]][["version"]]
[16:20:45.897]                           if (is.null(version)) 
[16:20:45.897]                             version <- utils::packageVersion("future")
[16:20:45.897]                         }
[16:20:45.897]                         else {
[16:20:45.897]                           version <- NULL
[16:20:45.897]                         }
[16:20:45.897]                         if (!has_future || version < "1.8.0") {
[16:20:45.897]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.897]                             "", base::R.version$version.string), 
[16:20:45.897]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.897]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.897]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.897]                               "release", "version")], collapse = " "), 
[16:20:45.897]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.897]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.897]                             info)
[16:20:45.897]                           info <- base::paste(info, collapse = "; ")
[16:20:45.897]                           if (!has_future) {
[16:20:45.897]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.897]                               info)
[16:20:45.897]                           }
[16:20:45.897]                           else {
[16:20:45.897]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.897]                               info, version)
[16:20:45.897]                           }
[16:20:45.897]                           base::stop(msg)
[16:20:45.897]                         }
[16:20:45.897]                       })
[16:20:45.897]                     }
[16:20:45.897]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.897]                     base::options(mc.cores = 1L)
[16:20:45.897]                   }
[16:20:45.897]                   ...future.strategy.old <- future::plan("list")
[16:20:45.897]                   options(future.plan = NULL)
[16:20:45.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.897]                 }
[16:20:45.897]                 ...future.workdir <- getwd()
[16:20:45.897]             }
[16:20:45.897]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.897]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.897]         }
[16:20:45.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.897]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.897]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.897]             base::names(...future.oldOptions))
[16:20:45.897]     }
[16:20:45.897]     if (FALSE) {
[16:20:45.897]     }
[16:20:45.897]     else {
[16:20:45.897]         if (TRUE) {
[16:20:45.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.897]                 open = "w")
[16:20:45.897]         }
[16:20:45.897]         else {
[16:20:45.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.897]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.897]         }
[16:20:45.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.897]             base::sink(type = "output", split = FALSE)
[16:20:45.897]             base::close(...future.stdout)
[16:20:45.897]         }, add = TRUE)
[16:20:45.897]     }
[16:20:45.897]     ...future.frame <- base::sys.nframe()
[16:20:45.897]     ...future.conditions <- base::list()
[16:20:45.897]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.897]     if (FALSE) {
[16:20:45.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.897]     }
[16:20:45.897]     ...future.result <- base::tryCatch({
[16:20:45.897]         base::withCallingHandlers({
[16:20:45.897]             ...future.value <- base::withVisible(base::local({
[16:20:45.897]                 ...future.makeSendCondition <- base::local({
[16:20:45.897]                   sendCondition <- NULL
[16:20:45.897]                   function(frame = 1L) {
[16:20:45.897]                     if (is.function(sendCondition)) 
[16:20:45.897]                       return(sendCondition)
[16:20:45.897]                     ns <- getNamespace("parallel")
[16:20:45.897]                     if (exists("sendData", mode = "function", 
[16:20:45.897]                       envir = ns)) {
[16:20:45.897]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:45.897]                         envir = ns)
[16:20:45.897]                       envir <- sys.frame(frame)
[16:20:45.897]                       master <- NULL
[16:20:45.897]                       while (!identical(envir, .GlobalEnv) && 
[16:20:45.897]                         !identical(envir, emptyenv())) {
[16:20:45.897]                         if (exists("master", mode = "list", envir = envir, 
[16:20:45.897]                           inherits = FALSE)) {
[16:20:45.897]                           master <- get("master", mode = "list", 
[16:20:45.897]                             envir = envir, inherits = FALSE)
[16:20:45.897]                           if (inherits(master, c("SOCKnode", 
[16:20:45.897]                             "SOCK0node"))) {
[16:20:45.897]                             sendCondition <<- function(cond) {
[16:20:45.897]                               data <- list(type = "VALUE", value = cond, 
[16:20:45.897]                                 success = TRUE)
[16:20:45.897]                               parallel_sendData(master, data)
[16:20:45.897]                             }
[16:20:45.897]                             return(sendCondition)
[16:20:45.897]                           }
[16:20:45.897]                         }
[16:20:45.897]                         frame <- frame + 1L
[16:20:45.897]                         envir <- sys.frame(frame)
[16:20:45.897]                       }
[16:20:45.897]                     }
[16:20:45.897]                     sendCondition <<- function(cond) NULL
[16:20:45.897]                   }
[16:20:45.897]                 })
[16:20:45.897]                 withCallingHandlers({
[16:20:45.897]                   2
[16:20:45.897]                 }, immediateCondition = function(cond) {
[16:20:45.897]                   sendCondition <- ...future.makeSendCondition()
[16:20:45.897]                   sendCondition(cond)
[16:20:45.897]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.897]                   {
[16:20:45.897]                     inherits <- base::inherits
[16:20:45.897]                     invokeRestart <- base::invokeRestart
[16:20:45.897]                     is.null <- base::is.null
[16:20:45.897]                     muffled <- FALSE
[16:20:45.897]                     if (inherits(cond, "message")) {
[16:20:45.897]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.897]                       if (muffled) 
[16:20:45.897]                         invokeRestart("muffleMessage")
[16:20:45.897]                     }
[16:20:45.897]                     else if (inherits(cond, "warning")) {
[16:20:45.897]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.897]                       if (muffled) 
[16:20:45.897]                         invokeRestart("muffleWarning")
[16:20:45.897]                     }
[16:20:45.897]                     else if (inherits(cond, "condition")) {
[16:20:45.897]                       if (!is.null(pattern)) {
[16:20:45.897]                         computeRestarts <- base::computeRestarts
[16:20:45.897]                         grepl <- base::grepl
[16:20:45.897]                         restarts <- computeRestarts(cond)
[16:20:45.897]                         for (restart in restarts) {
[16:20:45.897]                           name <- restart$name
[16:20:45.897]                           if (is.null(name)) 
[16:20:45.897]                             next
[16:20:45.897]                           if (!grepl(pattern, name)) 
[16:20:45.897]                             next
[16:20:45.897]                           invokeRestart(restart)
[16:20:45.897]                           muffled <- TRUE
[16:20:45.897]                           break
[16:20:45.897]                         }
[16:20:45.897]                       }
[16:20:45.897]                     }
[16:20:45.897]                     invisible(muffled)
[16:20:45.897]                   }
[16:20:45.897]                   muffleCondition(cond)
[16:20:45.897]                 })
[16:20:45.897]             }))
[16:20:45.897]             future::FutureResult(value = ...future.value$value, 
[16:20:45.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.897]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.897]                     ...future.globalenv.names))
[16:20:45.897]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.897]         }, condition = base::local({
[16:20:45.897]             c <- base::c
[16:20:45.897]             inherits <- base::inherits
[16:20:45.897]             invokeRestart <- base::invokeRestart
[16:20:45.897]             length <- base::length
[16:20:45.897]             list <- base::list
[16:20:45.897]             seq.int <- base::seq.int
[16:20:45.897]             signalCondition <- base::signalCondition
[16:20:45.897]             sys.calls <- base::sys.calls
[16:20:45.897]             `[[` <- base::`[[`
[16:20:45.897]             `+` <- base::`+`
[16:20:45.897]             `<<-` <- base::`<<-`
[16:20:45.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.897]                   3L)]
[16:20:45.897]             }
[16:20:45.897]             function(cond) {
[16:20:45.897]                 is_error <- inherits(cond, "error")
[16:20:45.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.897]                   NULL)
[16:20:45.897]                 if (is_error) {
[16:20:45.897]                   sessionInformation <- function() {
[16:20:45.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.897]                       search = base::search(), system = base::Sys.info())
[16:20:45.897]                   }
[16:20:45.897]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.897]                     cond$call), session = sessionInformation(), 
[16:20:45.897]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.897]                   signalCondition(cond)
[16:20:45.897]                 }
[16:20:45.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.897]                 "immediateCondition"))) {
[16:20:45.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.897]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.897]                   if (TRUE && !signal) {
[16:20:45.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.897]                     {
[16:20:45.897]                       inherits <- base::inherits
[16:20:45.897]                       invokeRestart <- base::invokeRestart
[16:20:45.897]                       is.null <- base::is.null
[16:20:45.897]                       muffled <- FALSE
[16:20:45.897]                       if (inherits(cond, "message")) {
[16:20:45.897]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.897]                         if (muffled) 
[16:20:45.897]                           invokeRestart("muffleMessage")
[16:20:45.897]                       }
[16:20:45.897]                       else if (inherits(cond, "warning")) {
[16:20:45.897]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.897]                         if (muffled) 
[16:20:45.897]                           invokeRestart("muffleWarning")
[16:20:45.897]                       }
[16:20:45.897]                       else if (inherits(cond, "condition")) {
[16:20:45.897]                         if (!is.null(pattern)) {
[16:20:45.897]                           computeRestarts <- base::computeRestarts
[16:20:45.897]                           grepl <- base::grepl
[16:20:45.897]                           restarts <- computeRestarts(cond)
[16:20:45.897]                           for (restart in restarts) {
[16:20:45.897]                             name <- restart$name
[16:20:45.897]                             if (is.null(name)) 
[16:20:45.897]                               next
[16:20:45.897]                             if (!grepl(pattern, name)) 
[16:20:45.897]                               next
[16:20:45.897]                             invokeRestart(restart)
[16:20:45.897]                             muffled <- TRUE
[16:20:45.897]                             break
[16:20:45.897]                           }
[16:20:45.897]                         }
[16:20:45.897]                       }
[16:20:45.897]                       invisible(muffled)
[16:20:45.897]                     }
[16:20:45.897]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.897]                   }
[16:20:45.897]                 }
[16:20:45.897]                 else {
[16:20:45.897]                   if (TRUE) {
[16:20:45.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.897]                     {
[16:20:45.897]                       inherits <- base::inherits
[16:20:45.897]                       invokeRestart <- base::invokeRestart
[16:20:45.897]                       is.null <- base::is.null
[16:20:45.897]                       muffled <- FALSE
[16:20:45.897]                       if (inherits(cond, "message")) {
[16:20:45.897]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.897]                         if (muffled) 
[16:20:45.897]                           invokeRestart("muffleMessage")
[16:20:45.897]                       }
[16:20:45.897]                       else if (inherits(cond, "warning")) {
[16:20:45.897]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.897]                         if (muffled) 
[16:20:45.897]                           invokeRestart("muffleWarning")
[16:20:45.897]                       }
[16:20:45.897]                       else if (inherits(cond, "condition")) {
[16:20:45.897]                         if (!is.null(pattern)) {
[16:20:45.897]                           computeRestarts <- base::computeRestarts
[16:20:45.897]                           grepl <- base::grepl
[16:20:45.897]                           restarts <- computeRestarts(cond)
[16:20:45.897]                           for (restart in restarts) {
[16:20:45.897]                             name <- restart$name
[16:20:45.897]                             if (is.null(name)) 
[16:20:45.897]                               next
[16:20:45.897]                             if (!grepl(pattern, name)) 
[16:20:45.897]                               next
[16:20:45.897]                             invokeRestart(restart)
[16:20:45.897]                             muffled <- TRUE
[16:20:45.897]                             break
[16:20:45.897]                           }
[16:20:45.897]                         }
[16:20:45.897]                       }
[16:20:45.897]                       invisible(muffled)
[16:20:45.897]                     }
[16:20:45.897]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.897]                   }
[16:20:45.897]                 }
[16:20:45.897]             }
[16:20:45.897]         }))
[16:20:45.897]     }, error = function(ex) {
[16:20:45.897]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.897]                 ...future.rng), started = ...future.startTime, 
[16:20:45.897]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.897]             version = "1.8"), class = "FutureResult")
[16:20:45.897]     }, finally = {
[16:20:45.897]         if (!identical(...future.workdir, getwd())) 
[16:20:45.897]             setwd(...future.workdir)
[16:20:45.897]         {
[16:20:45.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.897]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.897]             }
[16:20:45.897]             base::options(...future.oldOptions)
[16:20:45.897]             if (.Platform$OS.type == "windows") {
[16:20:45.897]                 old_names <- names(...future.oldEnvVars)
[16:20:45.897]                 envs <- base::Sys.getenv()
[16:20:45.897]                 names <- names(envs)
[16:20:45.897]                 common <- intersect(names, old_names)
[16:20:45.897]                 added <- setdiff(names, old_names)
[16:20:45.897]                 removed <- setdiff(old_names, names)
[16:20:45.897]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.897]                   envs[common]]
[16:20:45.897]                 NAMES <- toupper(changed)
[16:20:45.897]                 args <- list()
[16:20:45.897]                 for (kk in seq_along(NAMES)) {
[16:20:45.897]                   name <- changed[[kk]]
[16:20:45.897]                   NAME <- NAMES[[kk]]
[16:20:45.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.897]                     next
[16:20:45.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.897]                 }
[16:20:45.897]                 NAMES <- toupper(added)
[16:20:45.897]                 for (kk in seq_along(NAMES)) {
[16:20:45.897]                   name <- added[[kk]]
[16:20:45.897]                   NAME <- NAMES[[kk]]
[16:20:45.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.897]                     next
[16:20:45.897]                   args[[name]] <- ""
[16:20:45.897]                 }
[16:20:45.897]                 NAMES <- toupper(removed)
[16:20:45.897]                 for (kk in seq_along(NAMES)) {
[16:20:45.897]                   name <- removed[[kk]]
[16:20:45.897]                   NAME <- NAMES[[kk]]
[16:20:45.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.897]                     next
[16:20:45.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.897]                 }
[16:20:45.897]                 if (length(args) > 0) 
[16:20:45.897]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.897]             }
[16:20:45.897]             else {
[16:20:45.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.897]             }
[16:20:45.897]             {
[16:20:45.897]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.897]                   0L) {
[16:20:45.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.897]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.897]                   base::options(opts)
[16:20:45.897]                 }
[16:20:45.897]                 {
[16:20:45.897]                   {
[16:20:45.897]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.897]                     NULL
[16:20:45.897]                   }
[16:20:45.897]                   options(future.plan = NULL)
[16:20:45.897]                   if (is.na(NA_character_)) 
[16:20:45.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.897]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.897]                     .init = FALSE)
[16:20:45.897]                 }
[16:20:45.897]             }
[16:20:45.897]         }
[16:20:45.897]     })
[16:20:45.897]     if (TRUE) {
[16:20:45.897]         base::sink(type = "output", split = FALSE)
[16:20:45.897]         if (TRUE) {
[16:20:45.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.897]         }
[16:20:45.897]         else {
[16:20:45.897]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.897]         }
[16:20:45.897]         base::close(...future.stdout)
[16:20:45.897]         ...future.stdout <- NULL
[16:20:45.897]     }
[16:20:45.897]     ...future.result$conditions <- ...future.conditions
[16:20:45.897]     ...future.result$finished <- base::Sys.time()
[16:20:45.897]     ...future.result
[16:20:45.897] }
[16:20:45.900] MultisessionFuture started
[16:20:45.900] - Launch lazy future ... done
[16:20:45.900] run() for ‘MultisessionFuture’ ... done
[16:20:45.900] getGlobalsAndPackages() ...
[16:20:45.900] Searching for globals...
[16:20:45.900] 
[16:20:45.900] Searching for globals ... DONE
[16:20:45.901] - globals: [0] <none>
[16:20:45.901] getGlobalsAndPackages() ... DONE
[16:20:45.901] run() for ‘Future’ ...
[16:20:45.901] - state: ‘created’
[16:20:45.901] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.915] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:45.915]   - Field: ‘node’
[16:20:45.915]   - Field: ‘label’
[16:20:45.915]   - Field: ‘local’
[16:20:45.915]   - Field: ‘owner’
[16:20:45.915]   - Field: ‘envir’
[16:20:45.916]   - Field: ‘workers’
[16:20:45.916]   - Field: ‘packages’
[16:20:45.916]   - Field: ‘gc’
[16:20:45.916]   - Field: ‘conditions’
[16:20:45.916]   - Field: ‘persistent’
[16:20:45.916]   - Field: ‘expr’
[16:20:45.916]   - Field: ‘uuid’
[16:20:45.916]   - Field: ‘seed’
[16:20:45.916]   - Field: ‘version’
[16:20:45.916]   - Field: ‘result’
[16:20:45.917]   - Field: ‘asynchronous’
[16:20:45.917]   - Field: ‘calls’
[16:20:45.917]   - Field: ‘globals’
[16:20:45.917]   - Field: ‘stdout’
[16:20:45.917]   - Field: ‘earlySignal’
[16:20:45.917]   - Field: ‘lazy’
[16:20:45.917]   - Field: ‘state’
[16:20:45.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:45.917] - Launch lazy future ...
[16:20:45.918] Packages needed by the future expression (n = 0): <none>
[16:20:45.918] Packages needed by future strategies (n = 0): <none>
[16:20:45.918] {
[16:20:45.918]     {
[16:20:45.918]         {
[16:20:45.918]             ...future.startTime <- base::Sys.time()
[16:20:45.918]             {
[16:20:45.918]                 {
[16:20:45.918]                   {
[16:20:45.918]                     {
[16:20:45.918]                       base::local({
[16:20:45.918]                         has_future <- base::requireNamespace("future", 
[16:20:45.918]                           quietly = TRUE)
[16:20:45.918]                         if (has_future) {
[16:20:45.918]                           ns <- base::getNamespace("future")
[16:20:45.918]                           version <- ns[[".package"]][["version"]]
[16:20:45.918]                           if (is.null(version)) 
[16:20:45.918]                             version <- utils::packageVersion("future")
[16:20:45.918]                         }
[16:20:45.918]                         else {
[16:20:45.918]                           version <- NULL
[16:20:45.918]                         }
[16:20:45.918]                         if (!has_future || version < "1.8.0") {
[16:20:45.918]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.918]                             "", base::R.version$version.string), 
[16:20:45.918]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.918]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.918]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.918]                               "release", "version")], collapse = " "), 
[16:20:45.918]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.918]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.918]                             info)
[16:20:45.918]                           info <- base::paste(info, collapse = "; ")
[16:20:45.918]                           if (!has_future) {
[16:20:45.918]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.918]                               info)
[16:20:45.918]                           }
[16:20:45.918]                           else {
[16:20:45.918]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.918]                               info, version)
[16:20:45.918]                           }
[16:20:45.918]                           base::stop(msg)
[16:20:45.918]                         }
[16:20:45.918]                       })
[16:20:45.918]                     }
[16:20:45.918]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.918]                     base::options(mc.cores = 1L)
[16:20:45.918]                   }
[16:20:45.918]                   ...future.strategy.old <- future::plan("list")
[16:20:45.918]                   options(future.plan = NULL)
[16:20:45.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.918]                 }
[16:20:45.918]                 ...future.workdir <- getwd()
[16:20:45.918]             }
[16:20:45.918]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.918]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.918]         }
[16:20:45.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.918]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.918]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.918]             base::names(...future.oldOptions))
[16:20:45.918]     }
[16:20:45.918]     if (FALSE) {
[16:20:45.918]     }
[16:20:45.918]     else {
[16:20:45.918]         if (TRUE) {
[16:20:45.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.918]                 open = "w")
[16:20:45.918]         }
[16:20:45.918]         else {
[16:20:45.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.918]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.918]         }
[16:20:45.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.918]             base::sink(type = "output", split = FALSE)
[16:20:45.918]             base::close(...future.stdout)
[16:20:45.918]         }, add = TRUE)
[16:20:45.918]     }
[16:20:45.918]     ...future.frame <- base::sys.nframe()
[16:20:45.918]     ...future.conditions <- base::list()
[16:20:45.918]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.918]     if (FALSE) {
[16:20:45.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.918]     }
[16:20:45.918]     ...future.result <- base::tryCatch({
[16:20:45.918]         base::withCallingHandlers({
[16:20:45.918]             ...future.value <- base::withVisible(base::local({
[16:20:45.918]                 ...future.makeSendCondition <- base::local({
[16:20:45.918]                   sendCondition <- NULL
[16:20:45.918]                   function(frame = 1L) {
[16:20:45.918]                     if (is.function(sendCondition)) 
[16:20:45.918]                       return(sendCondition)
[16:20:45.918]                     ns <- getNamespace("parallel")
[16:20:45.918]                     if (exists("sendData", mode = "function", 
[16:20:45.918]                       envir = ns)) {
[16:20:45.918]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:45.918]                         envir = ns)
[16:20:45.918]                       envir <- sys.frame(frame)
[16:20:45.918]                       master <- NULL
[16:20:45.918]                       while (!identical(envir, .GlobalEnv) && 
[16:20:45.918]                         !identical(envir, emptyenv())) {
[16:20:45.918]                         if (exists("master", mode = "list", envir = envir, 
[16:20:45.918]                           inherits = FALSE)) {
[16:20:45.918]                           master <- get("master", mode = "list", 
[16:20:45.918]                             envir = envir, inherits = FALSE)
[16:20:45.918]                           if (inherits(master, c("SOCKnode", 
[16:20:45.918]                             "SOCK0node"))) {
[16:20:45.918]                             sendCondition <<- function(cond) {
[16:20:45.918]                               data <- list(type = "VALUE", value = cond, 
[16:20:45.918]                                 success = TRUE)
[16:20:45.918]                               parallel_sendData(master, data)
[16:20:45.918]                             }
[16:20:45.918]                             return(sendCondition)
[16:20:45.918]                           }
[16:20:45.918]                         }
[16:20:45.918]                         frame <- frame + 1L
[16:20:45.918]                         envir <- sys.frame(frame)
[16:20:45.918]                       }
[16:20:45.918]                     }
[16:20:45.918]                     sendCondition <<- function(cond) NULL
[16:20:45.918]                   }
[16:20:45.918]                 })
[16:20:45.918]                 withCallingHandlers({
[16:20:45.918]                   NULL
[16:20:45.918]                 }, immediateCondition = function(cond) {
[16:20:45.918]                   sendCondition <- ...future.makeSendCondition()
[16:20:45.918]                   sendCondition(cond)
[16:20:45.918]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.918]                   {
[16:20:45.918]                     inherits <- base::inherits
[16:20:45.918]                     invokeRestart <- base::invokeRestart
[16:20:45.918]                     is.null <- base::is.null
[16:20:45.918]                     muffled <- FALSE
[16:20:45.918]                     if (inherits(cond, "message")) {
[16:20:45.918]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.918]                       if (muffled) 
[16:20:45.918]                         invokeRestart("muffleMessage")
[16:20:45.918]                     }
[16:20:45.918]                     else if (inherits(cond, "warning")) {
[16:20:45.918]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.918]                       if (muffled) 
[16:20:45.918]                         invokeRestart("muffleWarning")
[16:20:45.918]                     }
[16:20:45.918]                     else if (inherits(cond, "condition")) {
[16:20:45.918]                       if (!is.null(pattern)) {
[16:20:45.918]                         computeRestarts <- base::computeRestarts
[16:20:45.918]                         grepl <- base::grepl
[16:20:45.918]                         restarts <- computeRestarts(cond)
[16:20:45.918]                         for (restart in restarts) {
[16:20:45.918]                           name <- restart$name
[16:20:45.918]                           if (is.null(name)) 
[16:20:45.918]                             next
[16:20:45.918]                           if (!grepl(pattern, name)) 
[16:20:45.918]                             next
[16:20:45.918]                           invokeRestart(restart)
[16:20:45.918]                           muffled <- TRUE
[16:20:45.918]                           break
[16:20:45.918]                         }
[16:20:45.918]                       }
[16:20:45.918]                     }
[16:20:45.918]                     invisible(muffled)
[16:20:45.918]                   }
[16:20:45.918]                   muffleCondition(cond)
[16:20:45.918]                 })
[16:20:45.918]             }))
[16:20:45.918]             future::FutureResult(value = ...future.value$value, 
[16:20:45.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.918]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.918]                     ...future.globalenv.names))
[16:20:45.918]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.918]         }, condition = base::local({
[16:20:45.918]             c <- base::c
[16:20:45.918]             inherits <- base::inherits
[16:20:45.918]             invokeRestart <- base::invokeRestart
[16:20:45.918]             length <- base::length
[16:20:45.918]             list <- base::list
[16:20:45.918]             seq.int <- base::seq.int
[16:20:45.918]             signalCondition <- base::signalCondition
[16:20:45.918]             sys.calls <- base::sys.calls
[16:20:45.918]             `[[` <- base::`[[`
[16:20:45.918]             `+` <- base::`+`
[16:20:45.918]             `<<-` <- base::`<<-`
[16:20:45.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.918]                   3L)]
[16:20:45.918]             }
[16:20:45.918]             function(cond) {
[16:20:45.918]                 is_error <- inherits(cond, "error")
[16:20:45.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.918]                   NULL)
[16:20:45.918]                 if (is_error) {
[16:20:45.918]                   sessionInformation <- function() {
[16:20:45.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.918]                       search = base::search(), system = base::Sys.info())
[16:20:45.918]                   }
[16:20:45.918]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.918]                     cond$call), session = sessionInformation(), 
[16:20:45.918]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.918]                   signalCondition(cond)
[16:20:45.918]                 }
[16:20:45.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.918]                 "immediateCondition"))) {
[16:20:45.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.918]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.918]                   if (TRUE && !signal) {
[16:20:45.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.918]                     {
[16:20:45.918]                       inherits <- base::inherits
[16:20:45.918]                       invokeRestart <- base::invokeRestart
[16:20:45.918]                       is.null <- base::is.null
[16:20:45.918]                       muffled <- FALSE
[16:20:45.918]                       if (inherits(cond, "message")) {
[16:20:45.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.918]                         if (muffled) 
[16:20:45.918]                           invokeRestart("muffleMessage")
[16:20:45.918]                       }
[16:20:45.918]                       else if (inherits(cond, "warning")) {
[16:20:45.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.918]                         if (muffled) 
[16:20:45.918]                           invokeRestart("muffleWarning")
[16:20:45.918]                       }
[16:20:45.918]                       else if (inherits(cond, "condition")) {
[16:20:45.918]                         if (!is.null(pattern)) {
[16:20:45.918]                           computeRestarts <- base::computeRestarts
[16:20:45.918]                           grepl <- base::grepl
[16:20:45.918]                           restarts <- computeRestarts(cond)
[16:20:45.918]                           for (restart in restarts) {
[16:20:45.918]                             name <- restart$name
[16:20:45.918]                             if (is.null(name)) 
[16:20:45.918]                               next
[16:20:45.918]                             if (!grepl(pattern, name)) 
[16:20:45.918]                               next
[16:20:45.918]                             invokeRestart(restart)
[16:20:45.918]                             muffled <- TRUE
[16:20:45.918]                             break
[16:20:45.918]                           }
[16:20:45.918]                         }
[16:20:45.918]                       }
[16:20:45.918]                       invisible(muffled)
[16:20:45.918]                     }
[16:20:45.918]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.918]                   }
[16:20:45.918]                 }
[16:20:45.918]                 else {
[16:20:45.918]                   if (TRUE) {
[16:20:45.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.918]                     {
[16:20:45.918]                       inherits <- base::inherits
[16:20:45.918]                       invokeRestart <- base::invokeRestart
[16:20:45.918]                       is.null <- base::is.null
[16:20:45.918]                       muffled <- FALSE
[16:20:45.918]                       if (inherits(cond, "message")) {
[16:20:45.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.918]                         if (muffled) 
[16:20:45.918]                           invokeRestart("muffleMessage")
[16:20:45.918]                       }
[16:20:45.918]                       else if (inherits(cond, "warning")) {
[16:20:45.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.918]                         if (muffled) 
[16:20:45.918]                           invokeRestart("muffleWarning")
[16:20:45.918]                       }
[16:20:45.918]                       else if (inherits(cond, "condition")) {
[16:20:45.918]                         if (!is.null(pattern)) {
[16:20:45.918]                           computeRestarts <- base::computeRestarts
[16:20:45.918]                           grepl <- base::grepl
[16:20:45.918]                           restarts <- computeRestarts(cond)
[16:20:45.918]                           for (restart in restarts) {
[16:20:45.918]                             name <- restart$name
[16:20:45.918]                             if (is.null(name)) 
[16:20:45.918]                               next
[16:20:45.918]                             if (!grepl(pattern, name)) 
[16:20:45.918]                               next
[16:20:45.918]                             invokeRestart(restart)
[16:20:45.918]                             muffled <- TRUE
[16:20:45.918]                             break
[16:20:45.918]                           }
[16:20:45.918]                         }
[16:20:45.918]                       }
[16:20:45.918]                       invisible(muffled)
[16:20:45.918]                     }
[16:20:45.918]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.918]                   }
[16:20:45.918]                 }
[16:20:45.918]             }
[16:20:45.918]         }))
[16:20:45.918]     }, error = function(ex) {
[16:20:45.918]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.918]                 ...future.rng), started = ...future.startTime, 
[16:20:45.918]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.918]             version = "1.8"), class = "FutureResult")
[16:20:45.918]     }, finally = {
[16:20:45.918]         if (!identical(...future.workdir, getwd())) 
[16:20:45.918]             setwd(...future.workdir)
[16:20:45.918]         {
[16:20:45.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.918]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.918]             }
[16:20:45.918]             base::options(...future.oldOptions)
[16:20:45.918]             if (.Platform$OS.type == "windows") {
[16:20:45.918]                 old_names <- names(...future.oldEnvVars)
[16:20:45.918]                 envs <- base::Sys.getenv()
[16:20:45.918]                 names <- names(envs)
[16:20:45.918]                 common <- intersect(names, old_names)
[16:20:45.918]                 added <- setdiff(names, old_names)
[16:20:45.918]                 removed <- setdiff(old_names, names)
[16:20:45.918]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.918]                   envs[common]]
[16:20:45.918]                 NAMES <- toupper(changed)
[16:20:45.918]                 args <- list()
[16:20:45.918]                 for (kk in seq_along(NAMES)) {
[16:20:45.918]                   name <- changed[[kk]]
[16:20:45.918]                   NAME <- NAMES[[kk]]
[16:20:45.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.918]                     next
[16:20:45.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.918]                 }
[16:20:45.918]                 NAMES <- toupper(added)
[16:20:45.918]                 for (kk in seq_along(NAMES)) {
[16:20:45.918]                   name <- added[[kk]]
[16:20:45.918]                   NAME <- NAMES[[kk]]
[16:20:45.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.918]                     next
[16:20:45.918]                   args[[name]] <- ""
[16:20:45.918]                 }
[16:20:45.918]                 NAMES <- toupper(removed)
[16:20:45.918]                 for (kk in seq_along(NAMES)) {
[16:20:45.918]                   name <- removed[[kk]]
[16:20:45.918]                   NAME <- NAMES[[kk]]
[16:20:45.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.918]                     next
[16:20:45.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.918]                 }
[16:20:45.918]                 if (length(args) > 0) 
[16:20:45.918]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.918]             }
[16:20:45.918]             else {
[16:20:45.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.918]             }
[16:20:45.918]             {
[16:20:45.918]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.918]                   0L) {
[16:20:45.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.918]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.918]                   base::options(opts)
[16:20:45.918]                 }
[16:20:45.918]                 {
[16:20:45.918]                   {
[16:20:45.918]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.918]                     NULL
[16:20:45.918]                   }
[16:20:45.918]                   options(future.plan = NULL)
[16:20:45.918]                   if (is.na(NA_character_)) 
[16:20:45.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.918]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.918]                     .init = FALSE)
[16:20:45.918]                 }
[16:20:45.918]             }
[16:20:45.918]         }
[16:20:45.918]     })
[16:20:45.918]     if (TRUE) {
[16:20:45.918]         base::sink(type = "output", split = FALSE)
[16:20:45.918]         if (TRUE) {
[16:20:45.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.918]         }
[16:20:45.918]         else {
[16:20:45.918]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.918]         }
[16:20:45.918]         base::close(...future.stdout)
[16:20:45.918]         ...future.stdout <- NULL
[16:20:45.918]     }
[16:20:45.918]     ...future.result$conditions <- ...future.conditions
[16:20:45.918]     ...future.result$finished <- base::Sys.time()
[16:20:45.918]     ...future.result
[16:20:45.918] }
[16:20:45.921] MultisessionFuture started
[16:20:45.921] - Launch lazy future ... done
[16:20:45.921] run() for ‘MultisessionFuture’ ... done
[16:20:45.922] getGlobalsAndPackages() ...
[16:20:45.922] Searching for globals...
[16:20:45.922] - globals found: [1] ‘{’
[16:20:45.923] Searching for globals ... DONE
[16:20:45.923] Resolving globals: FALSE
[16:20:45.923] 
[16:20:45.923] 
[16:20:45.923] getGlobalsAndPackages() ... DONE
[16:20:45.923] run() for ‘Future’ ...
[16:20:45.923] - state: ‘created’
[16:20:45.924] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:45.946] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:45.946] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:45.946]   - Field: ‘node’
[16:20:45.946]   - Field: ‘label’
[16:20:45.946]   - Field: ‘local’
[16:20:45.946]   - Field: ‘owner’
[16:20:45.947]   - Field: ‘envir’
[16:20:45.947]   - Field: ‘workers’
[16:20:45.947]   - Field: ‘packages’
[16:20:45.947]   - Field: ‘gc’
[16:20:45.947]   - Field: ‘conditions’
[16:20:45.947]   - Field: ‘persistent’
[16:20:45.947]   - Field: ‘expr’
[16:20:45.947]   - Field: ‘uuid’
[16:20:45.947]   - Field: ‘seed’
[16:20:45.947]   - Field: ‘version’
[16:20:45.947]   - Field: ‘result’
[16:20:45.948]   - Field: ‘asynchronous’
[16:20:45.948]   - Field: ‘calls’
[16:20:45.948]   - Field: ‘globals’
[16:20:45.948]   - Field: ‘stdout’
[16:20:45.948]   - Field: ‘earlySignal’
[16:20:45.948]   - Field: ‘lazy’
[16:20:45.948]   - Field: ‘state’
[16:20:45.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:45.948] - Launch lazy future ...
[16:20:45.949] Packages needed by the future expression (n = 0): <none>
[16:20:45.949] Packages needed by future strategies (n = 0): <none>
[16:20:45.949] {
[16:20:45.949]     {
[16:20:45.949]         {
[16:20:45.949]             ...future.startTime <- base::Sys.time()
[16:20:45.949]             {
[16:20:45.949]                 {
[16:20:45.949]                   {
[16:20:45.949]                     {
[16:20:45.949]                       base::local({
[16:20:45.949]                         has_future <- base::requireNamespace("future", 
[16:20:45.949]                           quietly = TRUE)
[16:20:45.949]                         if (has_future) {
[16:20:45.949]                           ns <- base::getNamespace("future")
[16:20:45.949]                           version <- ns[[".package"]][["version"]]
[16:20:45.949]                           if (is.null(version)) 
[16:20:45.949]                             version <- utils::packageVersion("future")
[16:20:45.949]                         }
[16:20:45.949]                         else {
[16:20:45.949]                           version <- NULL
[16:20:45.949]                         }
[16:20:45.949]                         if (!has_future || version < "1.8.0") {
[16:20:45.949]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:45.949]                             "", base::R.version$version.string), 
[16:20:45.949]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:45.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:45.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:45.949]                               "release", "version")], collapse = " "), 
[16:20:45.949]                             hostname = base::Sys.info()[["nodename"]])
[16:20:45.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:45.949]                             info)
[16:20:45.949]                           info <- base::paste(info, collapse = "; ")
[16:20:45.949]                           if (!has_future) {
[16:20:45.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:45.949]                               info)
[16:20:45.949]                           }
[16:20:45.949]                           else {
[16:20:45.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:45.949]                               info, version)
[16:20:45.949]                           }
[16:20:45.949]                           base::stop(msg)
[16:20:45.949]                         }
[16:20:45.949]                       })
[16:20:45.949]                     }
[16:20:45.949]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:45.949]                     base::options(mc.cores = 1L)
[16:20:45.949]                   }
[16:20:45.949]                   ...future.strategy.old <- future::plan("list")
[16:20:45.949]                   options(future.plan = NULL)
[16:20:45.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:45.949]                 }
[16:20:45.949]                 ...future.workdir <- getwd()
[16:20:45.949]             }
[16:20:45.949]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:45.949]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:45.949]         }
[16:20:45.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:45.949]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:45.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:45.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:45.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:45.949]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:45.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:45.949]             base::names(...future.oldOptions))
[16:20:45.949]     }
[16:20:45.949]     if (FALSE) {
[16:20:45.949]     }
[16:20:45.949]     else {
[16:20:45.949]         if (TRUE) {
[16:20:45.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:45.949]                 open = "w")
[16:20:45.949]         }
[16:20:45.949]         else {
[16:20:45.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:45.949]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:45.949]         }
[16:20:45.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:45.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:45.949]             base::sink(type = "output", split = FALSE)
[16:20:45.949]             base::close(...future.stdout)
[16:20:45.949]         }, add = TRUE)
[16:20:45.949]     }
[16:20:45.949]     ...future.frame <- base::sys.nframe()
[16:20:45.949]     ...future.conditions <- base::list()
[16:20:45.949]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:45.949]     if (FALSE) {
[16:20:45.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:45.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:45.949]     }
[16:20:45.949]     ...future.result <- base::tryCatch({
[16:20:45.949]         base::withCallingHandlers({
[16:20:45.949]             ...future.value <- base::withVisible(base::local({
[16:20:45.949]                 ...future.makeSendCondition <- base::local({
[16:20:45.949]                   sendCondition <- NULL
[16:20:45.949]                   function(frame = 1L) {
[16:20:45.949]                     if (is.function(sendCondition)) 
[16:20:45.949]                       return(sendCondition)
[16:20:45.949]                     ns <- getNamespace("parallel")
[16:20:45.949]                     if (exists("sendData", mode = "function", 
[16:20:45.949]                       envir = ns)) {
[16:20:45.949]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:45.949]                         envir = ns)
[16:20:45.949]                       envir <- sys.frame(frame)
[16:20:45.949]                       master <- NULL
[16:20:45.949]                       while (!identical(envir, .GlobalEnv) && 
[16:20:45.949]                         !identical(envir, emptyenv())) {
[16:20:45.949]                         if (exists("master", mode = "list", envir = envir, 
[16:20:45.949]                           inherits = FALSE)) {
[16:20:45.949]                           master <- get("master", mode = "list", 
[16:20:45.949]                             envir = envir, inherits = FALSE)
[16:20:45.949]                           if (inherits(master, c("SOCKnode", 
[16:20:45.949]                             "SOCK0node"))) {
[16:20:45.949]                             sendCondition <<- function(cond) {
[16:20:45.949]                               data <- list(type = "VALUE", value = cond, 
[16:20:45.949]                                 success = TRUE)
[16:20:45.949]                               parallel_sendData(master, data)
[16:20:45.949]                             }
[16:20:45.949]                             return(sendCondition)
[16:20:45.949]                           }
[16:20:45.949]                         }
[16:20:45.949]                         frame <- frame + 1L
[16:20:45.949]                         envir <- sys.frame(frame)
[16:20:45.949]                       }
[16:20:45.949]                     }
[16:20:45.949]                     sendCondition <<- function(cond) NULL
[16:20:45.949]                   }
[16:20:45.949]                 })
[16:20:45.949]                 withCallingHandlers({
[16:20:45.949]                   {
[16:20:45.949]                     4
[16:20:45.949]                   }
[16:20:45.949]                 }, immediateCondition = function(cond) {
[16:20:45.949]                   sendCondition <- ...future.makeSendCondition()
[16:20:45.949]                   sendCondition(cond)
[16:20:45.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.949]                   {
[16:20:45.949]                     inherits <- base::inherits
[16:20:45.949]                     invokeRestart <- base::invokeRestart
[16:20:45.949]                     is.null <- base::is.null
[16:20:45.949]                     muffled <- FALSE
[16:20:45.949]                     if (inherits(cond, "message")) {
[16:20:45.949]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:45.949]                       if (muffled) 
[16:20:45.949]                         invokeRestart("muffleMessage")
[16:20:45.949]                     }
[16:20:45.949]                     else if (inherits(cond, "warning")) {
[16:20:45.949]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:45.949]                       if (muffled) 
[16:20:45.949]                         invokeRestart("muffleWarning")
[16:20:45.949]                     }
[16:20:45.949]                     else if (inherits(cond, "condition")) {
[16:20:45.949]                       if (!is.null(pattern)) {
[16:20:45.949]                         computeRestarts <- base::computeRestarts
[16:20:45.949]                         grepl <- base::grepl
[16:20:45.949]                         restarts <- computeRestarts(cond)
[16:20:45.949]                         for (restart in restarts) {
[16:20:45.949]                           name <- restart$name
[16:20:45.949]                           if (is.null(name)) 
[16:20:45.949]                             next
[16:20:45.949]                           if (!grepl(pattern, name)) 
[16:20:45.949]                             next
[16:20:45.949]                           invokeRestart(restart)
[16:20:45.949]                           muffled <- TRUE
[16:20:45.949]                           break
[16:20:45.949]                         }
[16:20:45.949]                       }
[16:20:45.949]                     }
[16:20:45.949]                     invisible(muffled)
[16:20:45.949]                   }
[16:20:45.949]                   muffleCondition(cond)
[16:20:45.949]                 })
[16:20:45.949]             }))
[16:20:45.949]             future::FutureResult(value = ...future.value$value, 
[16:20:45.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.949]                   ...future.rng), globalenv = if (FALSE) 
[16:20:45.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:45.949]                     ...future.globalenv.names))
[16:20:45.949]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:45.949]         }, condition = base::local({
[16:20:45.949]             c <- base::c
[16:20:45.949]             inherits <- base::inherits
[16:20:45.949]             invokeRestart <- base::invokeRestart
[16:20:45.949]             length <- base::length
[16:20:45.949]             list <- base::list
[16:20:45.949]             seq.int <- base::seq.int
[16:20:45.949]             signalCondition <- base::signalCondition
[16:20:45.949]             sys.calls <- base::sys.calls
[16:20:45.949]             `[[` <- base::`[[`
[16:20:45.949]             `+` <- base::`+`
[16:20:45.949]             `<<-` <- base::`<<-`
[16:20:45.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:45.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:45.949]                   3L)]
[16:20:45.949]             }
[16:20:45.949]             function(cond) {
[16:20:45.949]                 is_error <- inherits(cond, "error")
[16:20:45.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:45.949]                   NULL)
[16:20:45.949]                 if (is_error) {
[16:20:45.949]                   sessionInformation <- function() {
[16:20:45.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:45.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:45.949]                       search = base::search(), system = base::Sys.info())
[16:20:45.949]                   }
[16:20:45.949]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:45.949]                     cond$call), session = sessionInformation(), 
[16:20:45.949]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:45.949]                   signalCondition(cond)
[16:20:45.949]                 }
[16:20:45.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:45.949]                 "immediateCondition"))) {
[16:20:45.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:45.949]                   ...future.conditions[[length(...future.conditions) + 
[16:20:45.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:45.949]                   if (TRUE && !signal) {
[16:20:45.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.949]                     {
[16:20:45.949]                       inherits <- base::inherits
[16:20:45.949]                       invokeRestart <- base::invokeRestart
[16:20:45.949]                       is.null <- base::is.null
[16:20:45.949]                       muffled <- FALSE
[16:20:45.949]                       if (inherits(cond, "message")) {
[16:20:45.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.949]                         if (muffled) 
[16:20:45.949]                           invokeRestart("muffleMessage")
[16:20:45.949]                       }
[16:20:45.949]                       else if (inherits(cond, "warning")) {
[16:20:45.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.949]                         if (muffled) 
[16:20:45.949]                           invokeRestart("muffleWarning")
[16:20:45.949]                       }
[16:20:45.949]                       else if (inherits(cond, "condition")) {
[16:20:45.949]                         if (!is.null(pattern)) {
[16:20:45.949]                           computeRestarts <- base::computeRestarts
[16:20:45.949]                           grepl <- base::grepl
[16:20:45.949]                           restarts <- computeRestarts(cond)
[16:20:45.949]                           for (restart in restarts) {
[16:20:45.949]                             name <- restart$name
[16:20:45.949]                             if (is.null(name)) 
[16:20:45.949]                               next
[16:20:45.949]                             if (!grepl(pattern, name)) 
[16:20:45.949]                               next
[16:20:45.949]                             invokeRestart(restart)
[16:20:45.949]                             muffled <- TRUE
[16:20:45.949]                             break
[16:20:45.949]                           }
[16:20:45.949]                         }
[16:20:45.949]                       }
[16:20:45.949]                       invisible(muffled)
[16:20:45.949]                     }
[16:20:45.949]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.949]                   }
[16:20:45.949]                 }
[16:20:45.949]                 else {
[16:20:45.949]                   if (TRUE) {
[16:20:45.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:45.949]                     {
[16:20:45.949]                       inherits <- base::inherits
[16:20:45.949]                       invokeRestart <- base::invokeRestart
[16:20:45.949]                       is.null <- base::is.null
[16:20:45.949]                       muffled <- FALSE
[16:20:45.949]                       if (inherits(cond, "message")) {
[16:20:45.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:45.949]                         if (muffled) 
[16:20:45.949]                           invokeRestart("muffleMessage")
[16:20:45.949]                       }
[16:20:45.949]                       else if (inherits(cond, "warning")) {
[16:20:45.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:45.949]                         if (muffled) 
[16:20:45.949]                           invokeRestart("muffleWarning")
[16:20:45.949]                       }
[16:20:45.949]                       else if (inherits(cond, "condition")) {
[16:20:45.949]                         if (!is.null(pattern)) {
[16:20:45.949]                           computeRestarts <- base::computeRestarts
[16:20:45.949]                           grepl <- base::grepl
[16:20:45.949]                           restarts <- computeRestarts(cond)
[16:20:45.949]                           for (restart in restarts) {
[16:20:45.949]                             name <- restart$name
[16:20:45.949]                             if (is.null(name)) 
[16:20:45.949]                               next
[16:20:45.949]                             if (!grepl(pattern, name)) 
[16:20:45.949]                               next
[16:20:45.949]                             invokeRestart(restart)
[16:20:45.949]                             muffled <- TRUE
[16:20:45.949]                             break
[16:20:45.949]                           }
[16:20:45.949]                         }
[16:20:45.949]                       }
[16:20:45.949]                       invisible(muffled)
[16:20:45.949]                     }
[16:20:45.949]                     muffleCondition(cond, pattern = "^muffle")
[16:20:45.949]                   }
[16:20:45.949]                 }
[16:20:45.949]             }
[16:20:45.949]         }))
[16:20:45.949]     }, error = function(ex) {
[16:20:45.949]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:45.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:45.949]                 ...future.rng), started = ...future.startTime, 
[16:20:45.949]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:45.949]             version = "1.8"), class = "FutureResult")
[16:20:45.949]     }, finally = {
[16:20:45.949]         if (!identical(...future.workdir, getwd())) 
[16:20:45.949]             setwd(...future.workdir)
[16:20:45.949]         {
[16:20:45.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:45.949]                 ...future.oldOptions$nwarnings <- NULL
[16:20:45.949]             }
[16:20:45.949]             base::options(...future.oldOptions)
[16:20:45.949]             if (.Platform$OS.type == "windows") {
[16:20:45.949]                 old_names <- names(...future.oldEnvVars)
[16:20:45.949]                 envs <- base::Sys.getenv()
[16:20:45.949]                 names <- names(envs)
[16:20:45.949]                 common <- intersect(names, old_names)
[16:20:45.949]                 added <- setdiff(names, old_names)
[16:20:45.949]                 removed <- setdiff(old_names, names)
[16:20:45.949]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:45.949]                   envs[common]]
[16:20:45.949]                 NAMES <- toupper(changed)
[16:20:45.949]                 args <- list()
[16:20:45.949]                 for (kk in seq_along(NAMES)) {
[16:20:45.949]                   name <- changed[[kk]]
[16:20:45.949]                   NAME <- NAMES[[kk]]
[16:20:45.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.949]                     next
[16:20:45.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.949]                 }
[16:20:45.949]                 NAMES <- toupper(added)
[16:20:45.949]                 for (kk in seq_along(NAMES)) {
[16:20:45.949]                   name <- added[[kk]]
[16:20:45.949]                   NAME <- NAMES[[kk]]
[16:20:45.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.949]                     next
[16:20:45.949]                   args[[name]] <- ""
[16:20:45.949]                 }
[16:20:45.949]                 NAMES <- toupper(removed)
[16:20:45.949]                 for (kk in seq_along(NAMES)) {
[16:20:45.949]                   name <- removed[[kk]]
[16:20:45.949]                   NAME <- NAMES[[kk]]
[16:20:45.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:45.949]                     next
[16:20:45.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:45.949]                 }
[16:20:45.949]                 if (length(args) > 0) 
[16:20:45.949]                   base::do.call(base::Sys.setenv, args = args)
[16:20:45.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:45.949]             }
[16:20:45.949]             else {
[16:20:45.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:45.949]             }
[16:20:45.949]             {
[16:20:45.949]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:45.949]                   0L) {
[16:20:45.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:45.949]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:45.949]                   base::options(opts)
[16:20:45.949]                 }
[16:20:45.949]                 {
[16:20:45.949]                   {
[16:20:45.949]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:45.949]                     NULL
[16:20:45.949]                   }
[16:20:45.949]                   options(future.plan = NULL)
[16:20:45.949]                   if (is.na(NA_character_)) 
[16:20:45.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:45.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:45.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:45.949]                     .init = FALSE)
[16:20:45.949]                 }
[16:20:45.949]             }
[16:20:45.949]         }
[16:20:45.949]     })
[16:20:45.949]     if (TRUE) {
[16:20:45.949]         base::sink(type = "output", split = FALSE)
[16:20:45.949]         if (TRUE) {
[16:20:45.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:45.949]         }
[16:20:45.949]         else {
[16:20:45.949]             ...future.result["stdout"] <- base::list(NULL)
[16:20:45.949]         }
[16:20:45.949]         base::close(...future.stdout)
[16:20:45.949]         ...future.stdout <- NULL
[16:20:45.949]     }
[16:20:45.949]     ...future.result$conditions <- ...future.conditions
[16:20:45.949]     ...future.result$finished <- base::Sys.time()
[16:20:45.949]     ...future.result
[16:20:45.949] }
[16:20:45.951] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:45.962] receiveMessageFromWorker() for ClusterFuture ...
[16:20:45.962] - Validating connection of MultisessionFuture
[16:20:45.962] - received message: FutureResult
[16:20:45.963] - Received FutureResult
[16:20:45.963] - Erased future from FutureRegistry
[16:20:45.963] result() for ClusterFuture ...
[16:20:45.963] - result already collected: FutureResult
[16:20:45.963] result() for ClusterFuture ... done
[16:20:45.963] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:45.963] result() for ClusterFuture ...
[16:20:45.963] - result already collected: FutureResult
[16:20:45.963] result() for ClusterFuture ... done
[16:20:45.963] result() for ClusterFuture ...
[16:20:45.964] - result already collected: FutureResult
[16:20:45.964] result() for ClusterFuture ... done
[16:20:45.965] MultisessionFuture started
[16:20:45.965] - Launch lazy future ... done
[16:20:45.965] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0d6e8d00> 
Classes 'listenv', 'environment' <environment: 0x55ed0c4610a0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:20:45.969] receiveMessageFromWorker() for ClusterFuture ...
[16:20:45.969] - Validating connection of MultisessionFuture
[16:20:45.969] - received message: FutureResult
[16:20:45.969] - Received FutureResult
[16:20:45.969] - Erased future from FutureRegistry
[16:20:45.969] result() for ClusterFuture ...
[16:20:45.969] - result already collected: FutureResult
[16:20:45.969] result() for ClusterFuture ... done
[16:20:45.969] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:45.970] receiveMessageFromWorker() for ClusterFuture ...
[16:20:45.970] - Validating connection of MultisessionFuture
[16:20:45.970] - received message: FutureResult
[16:20:45.970] - Received FutureResult
[16:20:45.970] - Erased future from FutureRegistry
[16:20:45.970] result() for ClusterFuture ...
[16:20:45.971] - result already collected: FutureResult
[16:20:45.971] result() for ClusterFuture ... done
[16:20:45.971] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:45.973] resolve() on list environment ...
[16:20:45.973]  recursive: 0
[16:20:45.974]  length: 6
[16:20:45.974]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:45.974] signalConditionsASAP(numeric, pos=1) ...
[16:20:45.974] - nx: 6
[16:20:45.974] - relay: TRUE
[16:20:45.974] - stdout: TRUE
[16:20:45.974] - signal: TRUE
[16:20:45.975] - resignal: FALSE
[16:20:45.975] - force: TRUE
[16:20:45.975] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.975] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.975]  - until=2
[16:20:45.975]  - relaying element #2
[16:20:45.975] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.975] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.975] signalConditionsASAP(NULL, pos=1) ... done
[16:20:45.975]  length: 5 (resolved future 1)
[16:20:45.975] Future #2
[16:20:45.976] result() for ClusterFuture ...
[16:20:45.976] - result already collected: FutureResult
[16:20:45.976] result() for ClusterFuture ... done
[16:20:45.976] result() for ClusterFuture ...
[16:20:45.976] - result already collected: FutureResult
[16:20:45.976] result() for ClusterFuture ... done
[16:20:45.976] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:45.976] - nx: 6
[16:20:45.976] - relay: TRUE
[16:20:45.976] - stdout: TRUE
[16:20:45.976] - signal: TRUE
[16:20:45.977] - resignal: FALSE
[16:20:45.977] - force: TRUE
[16:20:45.977] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.977] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:45.977]  - until=2
[16:20:45.977]  - relaying element #2
[16:20:45.977] result() for ClusterFuture ...
[16:20:45.977] - result already collected: FutureResult
[16:20:45.977] result() for ClusterFuture ... done
[16:20:45.977] result() for ClusterFuture ...
[16:20:45.977] - result already collected: FutureResult
[16:20:45.977] result() for ClusterFuture ... done
[16:20:45.978] result() for ClusterFuture ...
[16:20:45.978] - result already collected: FutureResult
[16:20:45.978] result() for ClusterFuture ... done
[16:20:45.978] result() for ClusterFuture ...
[16:20:45.978] - result already collected: FutureResult
[16:20:45.978] result() for ClusterFuture ... done
[16:20:45.978] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.978] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.978] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:45.978]  length: 4 (resolved future 2)
[16:20:45.979] Future #3
[16:20:45.979] result() for ClusterFuture ...
[16:20:45.979] - result already collected: FutureResult
[16:20:45.979] result() for ClusterFuture ... done
[16:20:45.979] result() for ClusterFuture ...
[16:20:45.979] - result already collected: FutureResult
[16:20:45.979] result() for ClusterFuture ... done
[16:20:45.979] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:45.979] - nx: 6
[16:20:45.979] - relay: TRUE
[16:20:45.979] - stdout: TRUE
[16:20:45.979] - signal: TRUE
[16:20:45.980] - resignal: FALSE
[16:20:45.980] - force: TRUE
[16:20:45.980] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.980] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:45.980]  - until=3
[16:20:45.980]  - relaying element #3
[16:20:45.980] result() for ClusterFuture ...
[16:20:45.980] - result already collected: FutureResult
[16:20:45.980] result() for ClusterFuture ... done
[16:20:45.980] result() for ClusterFuture ...
[16:20:45.980] - result already collected: FutureResult
[16:20:45.981] result() for ClusterFuture ... done
[16:20:45.981] result() for ClusterFuture ...
[16:20:45.981] - result already collected: FutureResult
[16:20:45.981] result() for ClusterFuture ... done
[16:20:45.981] result() for ClusterFuture ...
[16:20:45.981] - result already collected: FutureResult
[16:20:45.981] result() for ClusterFuture ... done
[16:20:45.981] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.981] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.981] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:45.981]  length: 3 (resolved future 3)
[16:20:45.982] Future #4
[16:20:45.982] result() for ClusterFuture ...
[16:20:45.982] - result already collected: FutureResult
[16:20:45.982] result() for ClusterFuture ... done
[16:20:45.982] result() for ClusterFuture ...
[16:20:45.982] - result already collected: FutureResult
[16:20:45.982] result() for ClusterFuture ... done
[16:20:45.982] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:45.982] - nx: 6
[16:20:45.982] - relay: TRUE
[16:20:45.983] - stdout: TRUE
[16:20:45.983] - signal: TRUE
[16:20:45.983] - resignal: FALSE
[16:20:45.983] - force: TRUE
[16:20:45.983] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.983] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:45.983]  - until=4
[16:20:45.983]  - relaying element #4
[16:20:45.983] result() for ClusterFuture ...
[16:20:45.983] - result already collected: FutureResult
[16:20:45.983] result() for ClusterFuture ... done
[16:20:45.983] result() for ClusterFuture ...
[16:20:45.984] - result already collected: FutureResult
[16:20:45.984] result() for ClusterFuture ... done
[16:20:45.984] result() for ClusterFuture ...
[16:20:45.984] - result already collected: FutureResult
[16:20:45.984] result() for ClusterFuture ... done
[16:20:45.984] result() for ClusterFuture ...
[16:20:45.984] - result already collected: FutureResult
[16:20:45.984] result() for ClusterFuture ... done
[16:20:45.984] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.984] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.984] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:45.985]  length: 2 (resolved future 4)
[16:20:45.985] signalConditionsASAP(NULL, pos=5) ...
[16:20:45.985] - nx: 6
[16:20:45.985] - relay: TRUE
[16:20:45.985] - stdout: TRUE
[16:20:45.985] - signal: TRUE
[16:20:45.985] - resignal: FALSE
[16:20:45.985] - force: TRUE
[16:20:45.985] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.985] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.985]  - until=6
[16:20:45.985]  - relaying element #6
[16:20:45.986] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.986] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.986] signalConditionsASAP(NULL, pos=5) ... done
[16:20:45.986]  length: 1 (resolved future 5)
[16:20:45.986] signalConditionsASAP(numeric, pos=6) ...
[16:20:45.986] - nx: 6
[16:20:45.986] - relay: TRUE
[16:20:45.986] - stdout: TRUE
[16:20:45.986] - signal: TRUE
[16:20:45.986] - resignal: FALSE
[16:20:45.986] - force: TRUE
[16:20:45.986] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:45.987] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.987]  - until=6
[16:20:45.987] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.987] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.987] signalConditionsASAP(numeric, pos=6) ... done
[16:20:45.987]  length: 0 (resolved future 6)
[16:20:45.987] Relaying remaining futures
[16:20:45.987] signalConditionsASAP(NULL, pos=0) ...
[16:20:45.987] - nx: 6
[16:20:45.987] - relay: TRUE
[16:20:45.987] - stdout: TRUE
[16:20:45.988] - signal: TRUE
[16:20:45.988] - resignal: FALSE
[16:20:45.988] - force: TRUE
[16:20:45.988] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.988] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:45.988] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:45.988] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:45.988] signalConditionsASAP(NULL, pos=0) ... done
[16:20:45.988] resolve() on list environment ... DONE
[16:20:45.988] result() for ClusterFuture ...
[16:20:45.988] - result already collected: FutureResult
[16:20:45.989] result() for ClusterFuture ... done
[16:20:45.989] result() for ClusterFuture ...
[16:20:45.989] - result already collected: FutureResult
[16:20:45.989] result() for ClusterFuture ... done
[16:20:45.989] result() for ClusterFuture ...
[16:20:45.989] - result already collected: FutureResult
[16:20:45.989] result() for ClusterFuture ... done
[16:20:45.989] result() for ClusterFuture ...
[16:20:45.989] - result already collected: FutureResult
[16:20:45.989] result() for ClusterFuture ... done
[16:20:45.990] result() for ClusterFuture ...
[16:20:45.990] - result already collected: FutureResult
[16:20:45.990] result() for ClusterFuture ... done
[16:20:45.990] result() for ClusterFuture ...
[16:20:45.990] - result already collected: FutureResult
[16:20:45.990] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0bf151b0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:20:45.992] getGlobalsAndPackages() ...
[16:20:45.992] Searching for globals...
[16:20:45.992] 
[16:20:45.992] Searching for globals ... DONE
[16:20:45.992] - globals: [0] <none>
[16:20:45.992] getGlobalsAndPackages() ... DONE
[16:20:45.993] run() for ‘Future’ ...
[16:20:45.993] - state: ‘created’
[16:20:45.993] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:46.007] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:46.007] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:46.007]   - Field: ‘node’
[16:20:46.007]   - Field: ‘label’
[16:20:46.007]   - Field: ‘local’
[16:20:46.007]   - Field: ‘owner’
[16:20:46.007]   - Field: ‘envir’
[16:20:46.007]   - Field: ‘workers’
[16:20:46.007]   - Field: ‘packages’
[16:20:46.008]   - Field: ‘gc’
[16:20:46.008]   - Field: ‘conditions’
[16:20:46.008]   - Field: ‘persistent’
[16:20:46.008]   - Field: ‘expr’
[16:20:46.008]   - Field: ‘uuid’
[16:20:46.008]   - Field: ‘seed’
[16:20:46.008]   - Field: ‘version’
[16:20:46.008]   - Field: ‘result’
[16:20:46.008]   - Field: ‘asynchronous’
[16:20:46.008]   - Field: ‘calls’
[16:20:46.009]   - Field: ‘globals’
[16:20:46.009]   - Field: ‘stdout’
[16:20:46.009]   - Field: ‘earlySignal’
[16:20:46.009]   - Field: ‘lazy’
[16:20:46.009]   - Field: ‘state’
[16:20:46.009] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:46.009] - Launch lazy future ...
[16:20:46.009] Packages needed by the future expression (n = 0): <none>
[16:20:46.009] Packages needed by future strategies (n = 0): <none>
[16:20:46.010] {
[16:20:46.010]     {
[16:20:46.010]         {
[16:20:46.010]             ...future.startTime <- base::Sys.time()
[16:20:46.010]             {
[16:20:46.010]                 {
[16:20:46.010]                   {
[16:20:46.010]                     {
[16:20:46.010]                       base::local({
[16:20:46.010]                         has_future <- base::requireNamespace("future", 
[16:20:46.010]                           quietly = TRUE)
[16:20:46.010]                         if (has_future) {
[16:20:46.010]                           ns <- base::getNamespace("future")
[16:20:46.010]                           version <- ns[[".package"]][["version"]]
[16:20:46.010]                           if (is.null(version)) 
[16:20:46.010]                             version <- utils::packageVersion("future")
[16:20:46.010]                         }
[16:20:46.010]                         else {
[16:20:46.010]                           version <- NULL
[16:20:46.010]                         }
[16:20:46.010]                         if (!has_future || version < "1.8.0") {
[16:20:46.010]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:46.010]                             "", base::R.version$version.string), 
[16:20:46.010]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:46.010]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:46.010]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:46.010]                               "release", "version")], collapse = " "), 
[16:20:46.010]                             hostname = base::Sys.info()[["nodename"]])
[16:20:46.010]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:46.010]                             info)
[16:20:46.010]                           info <- base::paste(info, collapse = "; ")
[16:20:46.010]                           if (!has_future) {
[16:20:46.010]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:46.010]                               info)
[16:20:46.010]                           }
[16:20:46.010]                           else {
[16:20:46.010]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:46.010]                               info, version)
[16:20:46.010]                           }
[16:20:46.010]                           base::stop(msg)
[16:20:46.010]                         }
[16:20:46.010]                       })
[16:20:46.010]                     }
[16:20:46.010]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:46.010]                     base::options(mc.cores = 1L)
[16:20:46.010]                   }
[16:20:46.010]                   ...future.strategy.old <- future::plan("list")
[16:20:46.010]                   options(future.plan = NULL)
[16:20:46.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:46.010]                 }
[16:20:46.010]                 ...future.workdir <- getwd()
[16:20:46.010]             }
[16:20:46.010]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:46.010]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:46.010]         }
[16:20:46.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:46.010]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:46.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:46.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:46.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:46.010]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:46.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:46.010]             base::names(...future.oldOptions))
[16:20:46.010]     }
[16:20:46.010]     if (FALSE) {
[16:20:46.010]     }
[16:20:46.010]     else {
[16:20:46.010]         if (TRUE) {
[16:20:46.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:46.010]                 open = "w")
[16:20:46.010]         }
[16:20:46.010]         else {
[16:20:46.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:46.010]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:46.010]         }
[16:20:46.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:46.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:46.010]             base::sink(type = "output", split = FALSE)
[16:20:46.010]             base::close(...future.stdout)
[16:20:46.010]         }, add = TRUE)
[16:20:46.010]     }
[16:20:46.010]     ...future.frame <- base::sys.nframe()
[16:20:46.010]     ...future.conditions <- base::list()
[16:20:46.010]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:46.010]     if (FALSE) {
[16:20:46.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:46.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:46.010]     }
[16:20:46.010]     ...future.result <- base::tryCatch({
[16:20:46.010]         base::withCallingHandlers({
[16:20:46.010]             ...future.value <- base::withVisible(base::local({
[16:20:46.010]                 ...future.makeSendCondition <- base::local({
[16:20:46.010]                   sendCondition <- NULL
[16:20:46.010]                   function(frame = 1L) {
[16:20:46.010]                     if (is.function(sendCondition)) 
[16:20:46.010]                       return(sendCondition)
[16:20:46.010]                     ns <- getNamespace("parallel")
[16:20:46.010]                     if (exists("sendData", mode = "function", 
[16:20:46.010]                       envir = ns)) {
[16:20:46.010]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:46.010]                         envir = ns)
[16:20:46.010]                       envir <- sys.frame(frame)
[16:20:46.010]                       master <- NULL
[16:20:46.010]                       while (!identical(envir, .GlobalEnv) && 
[16:20:46.010]                         !identical(envir, emptyenv())) {
[16:20:46.010]                         if (exists("master", mode = "list", envir = envir, 
[16:20:46.010]                           inherits = FALSE)) {
[16:20:46.010]                           master <- get("master", mode = "list", 
[16:20:46.010]                             envir = envir, inherits = FALSE)
[16:20:46.010]                           if (inherits(master, c("SOCKnode", 
[16:20:46.010]                             "SOCK0node"))) {
[16:20:46.010]                             sendCondition <<- function(cond) {
[16:20:46.010]                               data <- list(type = "VALUE", value = cond, 
[16:20:46.010]                                 success = TRUE)
[16:20:46.010]                               parallel_sendData(master, data)
[16:20:46.010]                             }
[16:20:46.010]                             return(sendCondition)
[16:20:46.010]                           }
[16:20:46.010]                         }
[16:20:46.010]                         frame <- frame + 1L
[16:20:46.010]                         envir <- sys.frame(frame)
[16:20:46.010]                       }
[16:20:46.010]                     }
[16:20:46.010]                     sendCondition <<- function(cond) NULL
[16:20:46.010]                   }
[16:20:46.010]                 })
[16:20:46.010]                 withCallingHandlers({
[16:20:46.010]                   2
[16:20:46.010]                 }, immediateCondition = function(cond) {
[16:20:46.010]                   sendCondition <- ...future.makeSendCondition()
[16:20:46.010]                   sendCondition(cond)
[16:20:46.010]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.010]                   {
[16:20:46.010]                     inherits <- base::inherits
[16:20:46.010]                     invokeRestart <- base::invokeRestart
[16:20:46.010]                     is.null <- base::is.null
[16:20:46.010]                     muffled <- FALSE
[16:20:46.010]                     if (inherits(cond, "message")) {
[16:20:46.010]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:46.010]                       if (muffled) 
[16:20:46.010]                         invokeRestart("muffleMessage")
[16:20:46.010]                     }
[16:20:46.010]                     else if (inherits(cond, "warning")) {
[16:20:46.010]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:46.010]                       if (muffled) 
[16:20:46.010]                         invokeRestart("muffleWarning")
[16:20:46.010]                     }
[16:20:46.010]                     else if (inherits(cond, "condition")) {
[16:20:46.010]                       if (!is.null(pattern)) {
[16:20:46.010]                         computeRestarts <- base::computeRestarts
[16:20:46.010]                         grepl <- base::grepl
[16:20:46.010]                         restarts <- computeRestarts(cond)
[16:20:46.010]                         for (restart in restarts) {
[16:20:46.010]                           name <- restart$name
[16:20:46.010]                           if (is.null(name)) 
[16:20:46.010]                             next
[16:20:46.010]                           if (!grepl(pattern, name)) 
[16:20:46.010]                             next
[16:20:46.010]                           invokeRestart(restart)
[16:20:46.010]                           muffled <- TRUE
[16:20:46.010]                           break
[16:20:46.010]                         }
[16:20:46.010]                       }
[16:20:46.010]                     }
[16:20:46.010]                     invisible(muffled)
[16:20:46.010]                   }
[16:20:46.010]                   muffleCondition(cond)
[16:20:46.010]                 })
[16:20:46.010]             }))
[16:20:46.010]             future::FutureResult(value = ...future.value$value, 
[16:20:46.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.010]                   ...future.rng), globalenv = if (FALSE) 
[16:20:46.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:46.010]                     ...future.globalenv.names))
[16:20:46.010]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:46.010]         }, condition = base::local({
[16:20:46.010]             c <- base::c
[16:20:46.010]             inherits <- base::inherits
[16:20:46.010]             invokeRestart <- base::invokeRestart
[16:20:46.010]             length <- base::length
[16:20:46.010]             list <- base::list
[16:20:46.010]             seq.int <- base::seq.int
[16:20:46.010]             signalCondition <- base::signalCondition
[16:20:46.010]             sys.calls <- base::sys.calls
[16:20:46.010]             `[[` <- base::`[[`
[16:20:46.010]             `+` <- base::`+`
[16:20:46.010]             `<<-` <- base::`<<-`
[16:20:46.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:46.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:46.010]                   3L)]
[16:20:46.010]             }
[16:20:46.010]             function(cond) {
[16:20:46.010]                 is_error <- inherits(cond, "error")
[16:20:46.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:46.010]                   NULL)
[16:20:46.010]                 if (is_error) {
[16:20:46.010]                   sessionInformation <- function() {
[16:20:46.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:46.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:46.010]                       search = base::search(), system = base::Sys.info())
[16:20:46.010]                   }
[16:20:46.010]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:46.010]                     cond$call), session = sessionInformation(), 
[16:20:46.010]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:46.010]                   signalCondition(cond)
[16:20:46.010]                 }
[16:20:46.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:46.010]                 "immediateCondition"))) {
[16:20:46.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:46.010]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:46.010]                   if (TRUE && !signal) {
[16:20:46.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.010]                     {
[16:20:46.010]                       inherits <- base::inherits
[16:20:46.010]                       invokeRestart <- base::invokeRestart
[16:20:46.010]                       is.null <- base::is.null
[16:20:46.010]                       muffled <- FALSE
[16:20:46.010]                       if (inherits(cond, "message")) {
[16:20:46.010]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.010]                         if (muffled) 
[16:20:46.010]                           invokeRestart("muffleMessage")
[16:20:46.010]                       }
[16:20:46.010]                       else if (inherits(cond, "warning")) {
[16:20:46.010]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.010]                         if (muffled) 
[16:20:46.010]                           invokeRestart("muffleWarning")
[16:20:46.010]                       }
[16:20:46.010]                       else if (inherits(cond, "condition")) {
[16:20:46.010]                         if (!is.null(pattern)) {
[16:20:46.010]                           computeRestarts <- base::computeRestarts
[16:20:46.010]                           grepl <- base::grepl
[16:20:46.010]                           restarts <- computeRestarts(cond)
[16:20:46.010]                           for (restart in restarts) {
[16:20:46.010]                             name <- restart$name
[16:20:46.010]                             if (is.null(name)) 
[16:20:46.010]                               next
[16:20:46.010]                             if (!grepl(pattern, name)) 
[16:20:46.010]                               next
[16:20:46.010]                             invokeRestart(restart)
[16:20:46.010]                             muffled <- TRUE
[16:20:46.010]                             break
[16:20:46.010]                           }
[16:20:46.010]                         }
[16:20:46.010]                       }
[16:20:46.010]                       invisible(muffled)
[16:20:46.010]                     }
[16:20:46.010]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.010]                   }
[16:20:46.010]                 }
[16:20:46.010]                 else {
[16:20:46.010]                   if (TRUE) {
[16:20:46.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.010]                     {
[16:20:46.010]                       inherits <- base::inherits
[16:20:46.010]                       invokeRestart <- base::invokeRestart
[16:20:46.010]                       is.null <- base::is.null
[16:20:46.010]                       muffled <- FALSE
[16:20:46.010]                       if (inherits(cond, "message")) {
[16:20:46.010]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.010]                         if (muffled) 
[16:20:46.010]                           invokeRestart("muffleMessage")
[16:20:46.010]                       }
[16:20:46.010]                       else if (inherits(cond, "warning")) {
[16:20:46.010]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.010]                         if (muffled) 
[16:20:46.010]                           invokeRestart("muffleWarning")
[16:20:46.010]                       }
[16:20:46.010]                       else if (inherits(cond, "condition")) {
[16:20:46.010]                         if (!is.null(pattern)) {
[16:20:46.010]                           computeRestarts <- base::computeRestarts
[16:20:46.010]                           grepl <- base::grepl
[16:20:46.010]                           restarts <- computeRestarts(cond)
[16:20:46.010]                           for (restart in restarts) {
[16:20:46.010]                             name <- restart$name
[16:20:46.010]                             if (is.null(name)) 
[16:20:46.010]                               next
[16:20:46.010]                             if (!grepl(pattern, name)) 
[16:20:46.010]                               next
[16:20:46.010]                             invokeRestart(restart)
[16:20:46.010]                             muffled <- TRUE
[16:20:46.010]                             break
[16:20:46.010]                           }
[16:20:46.010]                         }
[16:20:46.010]                       }
[16:20:46.010]                       invisible(muffled)
[16:20:46.010]                     }
[16:20:46.010]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.010]                   }
[16:20:46.010]                 }
[16:20:46.010]             }
[16:20:46.010]         }))
[16:20:46.010]     }, error = function(ex) {
[16:20:46.010]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:46.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.010]                 ...future.rng), started = ...future.startTime, 
[16:20:46.010]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:46.010]             version = "1.8"), class = "FutureResult")
[16:20:46.010]     }, finally = {
[16:20:46.010]         if (!identical(...future.workdir, getwd())) 
[16:20:46.010]             setwd(...future.workdir)
[16:20:46.010]         {
[16:20:46.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:46.010]                 ...future.oldOptions$nwarnings <- NULL
[16:20:46.010]             }
[16:20:46.010]             base::options(...future.oldOptions)
[16:20:46.010]             if (.Platform$OS.type == "windows") {
[16:20:46.010]                 old_names <- names(...future.oldEnvVars)
[16:20:46.010]                 envs <- base::Sys.getenv()
[16:20:46.010]                 names <- names(envs)
[16:20:46.010]                 common <- intersect(names, old_names)
[16:20:46.010]                 added <- setdiff(names, old_names)
[16:20:46.010]                 removed <- setdiff(old_names, names)
[16:20:46.010]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:46.010]                   envs[common]]
[16:20:46.010]                 NAMES <- toupper(changed)
[16:20:46.010]                 args <- list()
[16:20:46.010]                 for (kk in seq_along(NAMES)) {
[16:20:46.010]                   name <- changed[[kk]]
[16:20:46.010]                   NAME <- NAMES[[kk]]
[16:20:46.010]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.010]                     next
[16:20:46.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.010]                 }
[16:20:46.010]                 NAMES <- toupper(added)
[16:20:46.010]                 for (kk in seq_along(NAMES)) {
[16:20:46.010]                   name <- added[[kk]]
[16:20:46.010]                   NAME <- NAMES[[kk]]
[16:20:46.010]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.010]                     next
[16:20:46.010]                   args[[name]] <- ""
[16:20:46.010]                 }
[16:20:46.010]                 NAMES <- toupper(removed)
[16:20:46.010]                 for (kk in seq_along(NAMES)) {
[16:20:46.010]                   name <- removed[[kk]]
[16:20:46.010]                   NAME <- NAMES[[kk]]
[16:20:46.010]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.010]                     next
[16:20:46.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.010]                 }
[16:20:46.010]                 if (length(args) > 0) 
[16:20:46.010]                   base::do.call(base::Sys.setenv, args = args)
[16:20:46.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:46.010]             }
[16:20:46.010]             else {
[16:20:46.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:46.010]             }
[16:20:46.010]             {
[16:20:46.010]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:46.010]                   0L) {
[16:20:46.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:46.010]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:46.010]                   base::options(opts)
[16:20:46.010]                 }
[16:20:46.010]                 {
[16:20:46.010]                   {
[16:20:46.010]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:46.010]                     NULL
[16:20:46.010]                   }
[16:20:46.010]                   options(future.plan = NULL)
[16:20:46.010]                   if (is.na(NA_character_)) 
[16:20:46.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:46.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:46.010]                     .init = FALSE)
[16:20:46.010]                 }
[16:20:46.010]             }
[16:20:46.010]         }
[16:20:46.010]     })
[16:20:46.010]     if (TRUE) {
[16:20:46.010]         base::sink(type = "output", split = FALSE)
[16:20:46.010]         if (TRUE) {
[16:20:46.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:46.010]         }
[16:20:46.010]         else {
[16:20:46.010]             ...future.result["stdout"] <- base::list(NULL)
[16:20:46.010]         }
[16:20:46.010]         base::close(...future.stdout)
[16:20:46.010]         ...future.stdout <- NULL
[16:20:46.010]     }
[16:20:46.010]     ...future.result$conditions <- ...future.conditions
[16:20:46.010]     ...future.result$finished <- base::Sys.time()
[16:20:46.010]     ...future.result
[16:20:46.010] }
[16:20:46.013] MultisessionFuture started
[16:20:46.013] - Launch lazy future ... done
[16:20:46.013] run() for ‘MultisessionFuture’ ... done
[16:20:46.013] getGlobalsAndPackages() ...
[16:20:46.013] Searching for globals...
[16:20:46.014] 
[16:20:46.014] Searching for globals ... DONE
[16:20:46.014] - globals: [0] <none>
[16:20:46.014] getGlobalsAndPackages() ... DONE
[16:20:46.014] run() for ‘Future’ ...
[16:20:46.014] - state: ‘created’
[16:20:46.014] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:46.028] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:46.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:46.028]   - Field: ‘node’
[16:20:46.028]   - Field: ‘label’
[16:20:46.028]   - Field: ‘local’
[16:20:46.028]   - Field: ‘owner’
[16:20:46.028]   - Field: ‘envir’
[16:20:46.028]   - Field: ‘workers’
[16:20:46.028]   - Field: ‘packages’
[16:20:46.029]   - Field: ‘gc’
[16:20:46.029]   - Field: ‘conditions’
[16:20:46.029]   - Field: ‘persistent’
[16:20:46.029]   - Field: ‘expr’
[16:20:46.029]   - Field: ‘uuid’
[16:20:46.029]   - Field: ‘seed’
[16:20:46.029]   - Field: ‘version’
[16:20:46.029]   - Field: ‘result’
[16:20:46.029]   - Field: ‘asynchronous’
[16:20:46.029]   - Field: ‘calls’
[16:20:46.029]   - Field: ‘globals’
[16:20:46.030]   - Field: ‘stdout’
[16:20:46.030]   - Field: ‘earlySignal’
[16:20:46.030]   - Field: ‘lazy’
[16:20:46.030]   - Field: ‘state’
[16:20:46.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:46.030] - Launch lazy future ...
[16:20:46.030] Packages needed by the future expression (n = 0): <none>
[16:20:46.030] Packages needed by future strategies (n = 0): <none>
[16:20:46.031] {
[16:20:46.031]     {
[16:20:46.031]         {
[16:20:46.031]             ...future.startTime <- base::Sys.time()
[16:20:46.031]             {
[16:20:46.031]                 {
[16:20:46.031]                   {
[16:20:46.031]                     {
[16:20:46.031]                       base::local({
[16:20:46.031]                         has_future <- base::requireNamespace("future", 
[16:20:46.031]                           quietly = TRUE)
[16:20:46.031]                         if (has_future) {
[16:20:46.031]                           ns <- base::getNamespace("future")
[16:20:46.031]                           version <- ns[[".package"]][["version"]]
[16:20:46.031]                           if (is.null(version)) 
[16:20:46.031]                             version <- utils::packageVersion("future")
[16:20:46.031]                         }
[16:20:46.031]                         else {
[16:20:46.031]                           version <- NULL
[16:20:46.031]                         }
[16:20:46.031]                         if (!has_future || version < "1.8.0") {
[16:20:46.031]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:46.031]                             "", base::R.version$version.string), 
[16:20:46.031]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:46.031]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:46.031]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:46.031]                               "release", "version")], collapse = " "), 
[16:20:46.031]                             hostname = base::Sys.info()[["nodename"]])
[16:20:46.031]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:46.031]                             info)
[16:20:46.031]                           info <- base::paste(info, collapse = "; ")
[16:20:46.031]                           if (!has_future) {
[16:20:46.031]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:46.031]                               info)
[16:20:46.031]                           }
[16:20:46.031]                           else {
[16:20:46.031]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:46.031]                               info, version)
[16:20:46.031]                           }
[16:20:46.031]                           base::stop(msg)
[16:20:46.031]                         }
[16:20:46.031]                       })
[16:20:46.031]                     }
[16:20:46.031]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:46.031]                     base::options(mc.cores = 1L)
[16:20:46.031]                   }
[16:20:46.031]                   ...future.strategy.old <- future::plan("list")
[16:20:46.031]                   options(future.plan = NULL)
[16:20:46.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:46.031]                 }
[16:20:46.031]                 ...future.workdir <- getwd()
[16:20:46.031]             }
[16:20:46.031]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:46.031]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:46.031]         }
[16:20:46.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:46.031]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:46.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:46.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:46.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:46.031]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:46.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:46.031]             base::names(...future.oldOptions))
[16:20:46.031]     }
[16:20:46.031]     if (FALSE) {
[16:20:46.031]     }
[16:20:46.031]     else {
[16:20:46.031]         if (TRUE) {
[16:20:46.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:46.031]                 open = "w")
[16:20:46.031]         }
[16:20:46.031]         else {
[16:20:46.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:46.031]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:46.031]         }
[16:20:46.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:46.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:46.031]             base::sink(type = "output", split = FALSE)
[16:20:46.031]             base::close(...future.stdout)
[16:20:46.031]         }, add = TRUE)
[16:20:46.031]     }
[16:20:46.031]     ...future.frame <- base::sys.nframe()
[16:20:46.031]     ...future.conditions <- base::list()
[16:20:46.031]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:46.031]     if (FALSE) {
[16:20:46.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:46.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:46.031]     }
[16:20:46.031]     ...future.result <- base::tryCatch({
[16:20:46.031]         base::withCallingHandlers({
[16:20:46.031]             ...future.value <- base::withVisible(base::local({
[16:20:46.031]                 ...future.makeSendCondition <- base::local({
[16:20:46.031]                   sendCondition <- NULL
[16:20:46.031]                   function(frame = 1L) {
[16:20:46.031]                     if (is.function(sendCondition)) 
[16:20:46.031]                       return(sendCondition)
[16:20:46.031]                     ns <- getNamespace("parallel")
[16:20:46.031]                     if (exists("sendData", mode = "function", 
[16:20:46.031]                       envir = ns)) {
[16:20:46.031]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:46.031]                         envir = ns)
[16:20:46.031]                       envir <- sys.frame(frame)
[16:20:46.031]                       master <- NULL
[16:20:46.031]                       while (!identical(envir, .GlobalEnv) && 
[16:20:46.031]                         !identical(envir, emptyenv())) {
[16:20:46.031]                         if (exists("master", mode = "list", envir = envir, 
[16:20:46.031]                           inherits = FALSE)) {
[16:20:46.031]                           master <- get("master", mode = "list", 
[16:20:46.031]                             envir = envir, inherits = FALSE)
[16:20:46.031]                           if (inherits(master, c("SOCKnode", 
[16:20:46.031]                             "SOCK0node"))) {
[16:20:46.031]                             sendCondition <<- function(cond) {
[16:20:46.031]                               data <- list(type = "VALUE", value = cond, 
[16:20:46.031]                                 success = TRUE)
[16:20:46.031]                               parallel_sendData(master, data)
[16:20:46.031]                             }
[16:20:46.031]                             return(sendCondition)
[16:20:46.031]                           }
[16:20:46.031]                         }
[16:20:46.031]                         frame <- frame + 1L
[16:20:46.031]                         envir <- sys.frame(frame)
[16:20:46.031]                       }
[16:20:46.031]                     }
[16:20:46.031]                     sendCondition <<- function(cond) NULL
[16:20:46.031]                   }
[16:20:46.031]                 })
[16:20:46.031]                 withCallingHandlers({
[16:20:46.031]                   NULL
[16:20:46.031]                 }, immediateCondition = function(cond) {
[16:20:46.031]                   sendCondition <- ...future.makeSendCondition()
[16:20:46.031]                   sendCondition(cond)
[16:20:46.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.031]                   {
[16:20:46.031]                     inherits <- base::inherits
[16:20:46.031]                     invokeRestart <- base::invokeRestart
[16:20:46.031]                     is.null <- base::is.null
[16:20:46.031]                     muffled <- FALSE
[16:20:46.031]                     if (inherits(cond, "message")) {
[16:20:46.031]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:46.031]                       if (muffled) 
[16:20:46.031]                         invokeRestart("muffleMessage")
[16:20:46.031]                     }
[16:20:46.031]                     else if (inherits(cond, "warning")) {
[16:20:46.031]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:46.031]                       if (muffled) 
[16:20:46.031]                         invokeRestart("muffleWarning")
[16:20:46.031]                     }
[16:20:46.031]                     else if (inherits(cond, "condition")) {
[16:20:46.031]                       if (!is.null(pattern)) {
[16:20:46.031]                         computeRestarts <- base::computeRestarts
[16:20:46.031]                         grepl <- base::grepl
[16:20:46.031]                         restarts <- computeRestarts(cond)
[16:20:46.031]                         for (restart in restarts) {
[16:20:46.031]                           name <- restart$name
[16:20:46.031]                           if (is.null(name)) 
[16:20:46.031]                             next
[16:20:46.031]                           if (!grepl(pattern, name)) 
[16:20:46.031]                             next
[16:20:46.031]                           invokeRestart(restart)
[16:20:46.031]                           muffled <- TRUE
[16:20:46.031]                           break
[16:20:46.031]                         }
[16:20:46.031]                       }
[16:20:46.031]                     }
[16:20:46.031]                     invisible(muffled)
[16:20:46.031]                   }
[16:20:46.031]                   muffleCondition(cond)
[16:20:46.031]                 })
[16:20:46.031]             }))
[16:20:46.031]             future::FutureResult(value = ...future.value$value, 
[16:20:46.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.031]                   ...future.rng), globalenv = if (FALSE) 
[16:20:46.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:46.031]                     ...future.globalenv.names))
[16:20:46.031]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:46.031]         }, condition = base::local({
[16:20:46.031]             c <- base::c
[16:20:46.031]             inherits <- base::inherits
[16:20:46.031]             invokeRestart <- base::invokeRestart
[16:20:46.031]             length <- base::length
[16:20:46.031]             list <- base::list
[16:20:46.031]             seq.int <- base::seq.int
[16:20:46.031]             signalCondition <- base::signalCondition
[16:20:46.031]             sys.calls <- base::sys.calls
[16:20:46.031]             `[[` <- base::`[[`
[16:20:46.031]             `+` <- base::`+`
[16:20:46.031]             `<<-` <- base::`<<-`
[16:20:46.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:46.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:46.031]                   3L)]
[16:20:46.031]             }
[16:20:46.031]             function(cond) {
[16:20:46.031]                 is_error <- inherits(cond, "error")
[16:20:46.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:46.031]                   NULL)
[16:20:46.031]                 if (is_error) {
[16:20:46.031]                   sessionInformation <- function() {
[16:20:46.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:46.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:46.031]                       search = base::search(), system = base::Sys.info())
[16:20:46.031]                   }
[16:20:46.031]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:46.031]                     cond$call), session = sessionInformation(), 
[16:20:46.031]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:46.031]                   signalCondition(cond)
[16:20:46.031]                 }
[16:20:46.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:46.031]                 "immediateCondition"))) {
[16:20:46.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:46.031]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:46.031]                   if (TRUE && !signal) {
[16:20:46.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.031]                     {
[16:20:46.031]                       inherits <- base::inherits
[16:20:46.031]                       invokeRestart <- base::invokeRestart
[16:20:46.031]                       is.null <- base::is.null
[16:20:46.031]                       muffled <- FALSE
[16:20:46.031]                       if (inherits(cond, "message")) {
[16:20:46.031]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.031]                         if (muffled) 
[16:20:46.031]                           invokeRestart("muffleMessage")
[16:20:46.031]                       }
[16:20:46.031]                       else if (inherits(cond, "warning")) {
[16:20:46.031]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.031]                         if (muffled) 
[16:20:46.031]                           invokeRestart("muffleWarning")
[16:20:46.031]                       }
[16:20:46.031]                       else if (inherits(cond, "condition")) {
[16:20:46.031]                         if (!is.null(pattern)) {
[16:20:46.031]                           computeRestarts <- base::computeRestarts
[16:20:46.031]                           grepl <- base::grepl
[16:20:46.031]                           restarts <- computeRestarts(cond)
[16:20:46.031]                           for (restart in restarts) {
[16:20:46.031]                             name <- restart$name
[16:20:46.031]                             if (is.null(name)) 
[16:20:46.031]                               next
[16:20:46.031]                             if (!grepl(pattern, name)) 
[16:20:46.031]                               next
[16:20:46.031]                             invokeRestart(restart)
[16:20:46.031]                             muffled <- TRUE
[16:20:46.031]                             break
[16:20:46.031]                           }
[16:20:46.031]                         }
[16:20:46.031]                       }
[16:20:46.031]                       invisible(muffled)
[16:20:46.031]                     }
[16:20:46.031]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.031]                   }
[16:20:46.031]                 }
[16:20:46.031]                 else {
[16:20:46.031]                   if (TRUE) {
[16:20:46.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.031]                     {
[16:20:46.031]                       inherits <- base::inherits
[16:20:46.031]                       invokeRestart <- base::invokeRestart
[16:20:46.031]                       is.null <- base::is.null
[16:20:46.031]                       muffled <- FALSE
[16:20:46.031]                       if (inherits(cond, "message")) {
[16:20:46.031]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.031]                         if (muffled) 
[16:20:46.031]                           invokeRestart("muffleMessage")
[16:20:46.031]                       }
[16:20:46.031]                       else if (inherits(cond, "warning")) {
[16:20:46.031]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.031]                         if (muffled) 
[16:20:46.031]                           invokeRestart("muffleWarning")
[16:20:46.031]                       }
[16:20:46.031]                       else if (inherits(cond, "condition")) {
[16:20:46.031]                         if (!is.null(pattern)) {
[16:20:46.031]                           computeRestarts <- base::computeRestarts
[16:20:46.031]                           grepl <- base::grepl
[16:20:46.031]                           restarts <- computeRestarts(cond)
[16:20:46.031]                           for (restart in restarts) {
[16:20:46.031]                             name <- restart$name
[16:20:46.031]                             if (is.null(name)) 
[16:20:46.031]                               next
[16:20:46.031]                             if (!grepl(pattern, name)) 
[16:20:46.031]                               next
[16:20:46.031]                             invokeRestart(restart)
[16:20:46.031]                             muffled <- TRUE
[16:20:46.031]                             break
[16:20:46.031]                           }
[16:20:46.031]                         }
[16:20:46.031]                       }
[16:20:46.031]                       invisible(muffled)
[16:20:46.031]                     }
[16:20:46.031]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.031]                   }
[16:20:46.031]                 }
[16:20:46.031]             }
[16:20:46.031]         }))
[16:20:46.031]     }, error = function(ex) {
[16:20:46.031]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:46.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.031]                 ...future.rng), started = ...future.startTime, 
[16:20:46.031]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:46.031]             version = "1.8"), class = "FutureResult")
[16:20:46.031]     }, finally = {
[16:20:46.031]         if (!identical(...future.workdir, getwd())) 
[16:20:46.031]             setwd(...future.workdir)
[16:20:46.031]         {
[16:20:46.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:46.031]                 ...future.oldOptions$nwarnings <- NULL
[16:20:46.031]             }
[16:20:46.031]             base::options(...future.oldOptions)
[16:20:46.031]             if (.Platform$OS.type == "windows") {
[16:20:46.031]                 old_names <- names(...future.oldEnvVars)
[16:20:46.031]                 envs <- base::Sys.getenv()
[16:20:46.031]                 names <- names(envs)
[16:20:46.031]                 common <- intersect(names, old_names)
[16:20:46.031]                 added <- setdiff(names, old_names)
[16:20:46.031]                 removed <- setdiff(old_names, names)
[16:20:46.031]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:46.031]                   envs[common]]
[16:20:46.031]                 NAMES <- toupper(changed)
[16:20:46.031]                 args <- list()
[16:20:46.031]                 for (kk in seq_along(NAMES)) {
[16:20:46.031]                   name <- changed[[kk]]
[16:20:46.031]                   NAME <- NAMES[[kk]]
[16:20:46.031]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.031]                     next
[16:20:46.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.031]                 }
[16:20:46.031]                 NAMES <- toupper(added)
[16:20:46.031]                 for (kk in seq_along(NAMES)) {
[16:20:46.031]                   name <- added[[kk]]
[16:20:46.031]                   NAME <- NAMES[[kk]]
[16:20:46.031]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.031]                     next
[16:20:46.031]                   args[[name]] <- ""
[16:20:46.031]                 }
[16:20:46.031]                 NAMES <- toupper(removed)
[16:20:46.031]                 for (kk in seq_along(NAMES)) {
[16:20:46.031]                   name <- removed[[kk]]
[16:20:46.031]                   NAME <- NAMES[[kk]]
[16:20:46.031]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.031]                     next
[16:20:46.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.031]                 }
[16:20:46.031]                 if (length(args) > 0) 
[16:20:46.031]                   base::do.call(base::Sys.setenv, args = args)
[16:20:46.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:46.031]             }
[16:20:46.031]             else {
[16:20:46.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:46.031]             }
[16:20:46.031]             {
[16:20:46.031]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:46.031]                   0L) {
[16:20:46.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:46.031]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:46.031]                   base::options(opts)
[16:20:46.031]                 }
[16:20:46.031]                 {
[16:20:46.031]                   {
[16:20:46.031]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:46.031]                     NULL
[16:20:46.031]                   }
[16:20:46.031]                   options(future.plan = NULL)
[16:20:46.031]                   if (is.na(NA_character_)) 
[16:20:46.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:46.031]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:46.031]                     .init = FALSE)
[16:20:46.031]                 }
[16:20:46.031]             }
[16:20:46.031]         }
[16:20:46.031]     })
[16:20:46.031]     if (TRUE) {
[16:20:46.031]         base::sink(type = "output", split = FALSE)
[16:20:46.031]         if (TRUE) {
[16:20:46.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:46.031]         }
[16:20:46.031]         else {
[16:20:46.031]             ...future.result["stdout"] <- base::list(NULL)
[16:20:46.031]         }
[16:20:46.031]         base::close(...future.stdout)
[16:20:46.031]         ...future.stdout <- NULL
[16:20:46.031]     }
[16:20:46.031]     ...future.result$conditions <- ...future.conditions
[16:20:46.031]     ...future.result$finished <- base::Sys.time()
[16:20:46.031]     ...future.result
[16:20:46.031] }
[16:20:46.034] MultisessionFuture started
[16:20:46.034] - Launch lazy future ... done
[16:20:46.034] run() for ‘MultisessionFuture’ ... done
[16:20:46.034] getGlobalsAndPackages() ...
[16:20:46.034] Searching for globals...
[16:20:46.035] - globals found: [1] ‘{’
[16:20:46.035] Searching for globals ... DONE
[16:20:46.035] Resolving globals: FALSE
[16:20:46.035] 
[16:20:46.036] 
[16:20:46.036] getGlobalsAndPackages() ... DONE
[16:20:46.036] run() for ‘Future’ ...
[16:20:46.036] - state: ‘created’
[16:20:46.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:46.049] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:46.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:46.050]   - Field: ‘node’
[16:20:46.050]   - Field: ‘label’
[16:20:46.050]   - Field: ‘local’
[16:20:46.050]   - Field: ‘owner’
[16:20:46.050]   - Field: ‘envir’
[16:20:46.050]   - Field: ‘workers’
[16:20:46.050]   - Field: ‘packages’
[16:20:46.050]   - Field: ‘gc’
[16:20:46.050]   - Field: ‘conditions’
[16:20:46.050]   - Field: ‘persistent’
[16:20:46.051]   - Field: ‘expr’
[16:20:46.051]   - Field: ‘uuid’
[16:20:46.051]   - Field: ‘seed’
[16:20:46.051]   - Field: ‘version’
[16:20:46.051]   - Field: ‘result’
[16:20:46.051]   - Field: ‘asynchronous’
[16:20:46.051]   - Field: ‘calls’
[16:20:46.051]   - Field: ‘globals’
[16:20:46.051]   - Field: ‘stdout’
[16:20:46.051]   - Field: ‘earlySignal’
[16:20:46.051]   - Field: ‘lazy’
[16:20:46.052]   - Field: ‘state’
[16:20:46.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:46.052] - Launch lazy future ...
[16:20:46.052] Packages needed by the future expression (n = 0): <none>
[16:20:46.052] Packages needed by future strategies (n = 0): <none>
[16:20:46.053] {
[16:20:46.053]     {
[16:20:46.053]         {
[16:20:46.053]             ...future.startTime <- base::Sys.time()
[16:20:46.053]             {
[16:20:46.053]                 {
[16:20:46.053]                   {
[16:20:46.053]                     {
[16:20:46.053]                       base::local({
[16:20:46.053]                         has_future <- base::requireNamespace("future", 
[16:20:46.053]                           quietly = TRUE)
[16:20:46.053]                         if (has_future) {
[16:20:46.053]                           ns <- base::getNamespace("future")
[16:20:46.053]                           version <- ns[[".package"]][["version"]]
[16:20:46.053]                           if (is.null(version)) 
[16:20:46.053]                             version <- utils::packageVersion("future")
[16:20:46.053]                         }
[16:20:46.053]                         else {
[16:20:46.053]                           version <- NULL
[16:20:46.053]                         }
[16:20:46.053]                         if (!has_future || version < "1.8.0") {
[16:20:46.053]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:46.053]                             "", base::R.version$version.string), 
[16:20:46.053]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:46.053]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:46.053]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:46.053]                               "release", "version")], collapse = " "), 
[16:20:46.053]                             hostname = base::Sys.info()[["nodename"]])
[16:20:46.053]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:46.053]                             info)
[16:20:46.053]                           info <- base::paste(info, collapse = "; ")
[16:20:46.053]                           if (!has_future) {
[16:20:46.053]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:46.053]                               info)
[16:20:46.053]                           }
[16:20:46.053]                           else {
[16:20:46.053]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:46.053]                               info, version)
[16:20:46.053]                           }
[16:20:46.053]                           base::stop(msg)
[16:20:46.053]                         }
[16:20:46.053]                       })
[16:20:46.053]                     }
[16:20:46.053]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:46.053]                     base::options(mc.cores = 1L)
[16:20:46.053]                   }
[16:20:46.053]                   ...future.strategy.old <- future::plan("list")
[16:20:46.053]                   options(future.plan = NULL)
[16:20:46.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:46.053]                 }
[16:20:46.053]                 ...future.workdir <- getwd()
[16:20:46.053]             }
[16:20:46.053]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:46.053]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:46.053]         }
[16:20:46.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:46.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:46.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:46.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:46.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:46.053]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:46.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:46.053]             base::names(...future.oldOptions))
[16:20:46.053]     }
[16:20:46.053]     if (FALSE) {
[16:20:46.053]     }
[16:20:46.053]     else {
[16:20:46.053]         if (TRUE) {
[16:20:46.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:46.053]                 open = "w")
[16:20:46.053]         }
[16:20:46.053]         else {
[16:20:46.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:46.053]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:46.053]         }
[16:20:46.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:46.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:46.053]             base::sink(type = "output", split = FALSE)
[16:20:46.053]             base::close(...future.stdout)
[16:20:46.053]         }, add = TRUE)
[16:20:46.053]     }
[16:20:46.053]     ...future.frame <- base::sys.nframe()
[16:20:46.053]     ...future.conditions <- base::list()
[16:20:46.053]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:46.053]     if (FALSE) {
[16:20:46.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:46.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:46.053]     }
[16:20:46.053]     ...future.result <- base::tryCatch({
[16:20:46.053]         base::withCallingHandlers({
[16:20:46.053]             ...future.value <- base::withVisible(base::local({
[16:20:46.053]                 ...future.makeSendCondition <- base::local({
[16:20:46.053]                   sendCondition <- NULL
[16:20:46.053]                   function(frame = 1L) {
[16:20:46.053]                     if (is.function(sendCondition)) 
[16:20:46.053]                       return(sendCondition)
[16:20:46.053]                     ns <- getNamespace("parallel")
[16:20:46.053]                     if (exists("sendData", mode = "function", 
[16:20:46.053]                       envir = ns)) {
[16:20:46.053]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:46.053]                         envir = ns)
[16:20:46.053]                       envir <- sys.frame(frame)
[16:20:46.053]                       master <- NULL
[16:20:46.053]                       while (!identical(envir, .GlobalEnv) && 
[16:20:46.053]                         !identical(envir, emptyenv())) {
[16:20:46.053]                         if (exists("master", mode = "list", envir = envir, 
[16:20:46.053]                           inherits = FALSE)) {
[16:20:46.053]                           master <- get("master", mode = "list", 
[16:20:46.053]                             envir = envir, inherits = FALSE)
[16:20:46.053]                           if (inherits(master, c("SOCKnode", 
[16:20:46.053]                             "SOCK0node"))) {
[16:20:46.053]                             sendCondition <<- function(cond) {
[16:20:46.053]                               data <- list(type = "VALUE", value = cond, 
[16:20:46.053]                                 success = TRUE)
[16:20:46.053]                               parallel_sendData(master, data)
[16:20:46.053]                             }
[16:20:46.053]                             return(sendCondition)
[16:20:46.053]                           }
[16:20:46.053]                         }
[16:20:46.053]                         frame <- frame + 1L
[16:20:46.053]                         envir <- sys.frame(frame)
[16:20:46.053]                       }
[16:20:46.053]                     }
[16:20:46.053]                     sendCondition <<- function(cond) NULL
[16:20:46.053]                   }
[16:20:46.053]                 })
[16:20:46.053]                 withCallingHandlers({
[16:20:46.053]                   {
[16:20:46.053]                     4
[16:20:46.053]                   }
[16:20:46.053]                 }, immediateCondition = function(cond) {
[16:20:46.053]                   sendCondition <- ...future.makeSendCondition()
[16:20:46.053]                   sendCondition(cond)
[16:20:46.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.053]                   {
[16:20:46.053]                     inherits <- base::inherits
[16:20:46.053]                     invokeRestart <- base::invokeRestart
[16:20:46.053]                     is.null <- base::is.null
[16:20:46.053]                     muffled <- FALSE
[16:20:46.053]                     if (inherits(cond, "message")) {
[16:20:46.053]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:46.053]                       if (muffled) 
[16:20:46.053]                         invokeRestart("muffleMessage")
[16:20:46.053]                     }
[16:20:46.053]                     else if (inherits(cond, "warning")) {
[16:20:46.053]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:46.053]                       if (muffled) 
[16:20:46.053]                         invokeRestart("muffleWarning")
[16:20:46.053]                     }
[16:20:46.053]                     else if (inherits(cond, "condition")) {
[16:20:46.053]                       if (!is.null(pattern)) {
[16:20:46.053]                         computeRestarts <- base::computeRestarts
[16:20:46.053]                         grepl <- base::grepl
[16:20:46.053]                         restarts <- computeRestarts(cond)
[16:20:46.053]                         for (restart in restarts) {
[16:20:46.053]                           name <- restart$name
[16:20:46.053]                           if (is.null(name)) 
[16:20:46.053]                             next
[16:20:46.053]                           if (!grepl(pattern, name)) 
[16:20:46.053]                             next
[16:20:46.053]                           invokeRestart(restart)
[16:20:46.053]                           muffled <- TRUE
[16:20:46.053]                           break
[16:20:46.053]                         }
[16:20:46.053]                       }
[16:20:46.053]                     }
[16:20:46.053]                     invisible(muffled)
[16:20:46.053]                   }
[16:20:46.053]                   muffleCondition(cond)
[16:20:46.053]                 })
[16:20:46.053]             }))
[16:20:46.053]             future::FutureResult(value = ...future.value$value, 
[16:20:46.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.053]                   ...future.rng), globalenv = if (FALSE) 
[16:20:46.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:46.053]                     ...future.globalenv.names))
[16:20:46.053]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:46.053]         }, condition = base::local({
[16:20:46.053]             c <- base::c
[16:20:46.053]             inherits <- base::inherits
[16:20:46.053]             invokeRestart <- base::invokeRestart
[16:20:46.053]             length <- base::length
[16:20:46.053]             list <- base::list
[16:20:46.053]             seq.int <- base::seq.int
[16:20:46.053]             signalCondition <- base::signalCondition
[16:20:46.053]             sys.calls <- base::sys.calls
[16:20:46.053]             `[[` <- base::`[[`
[16:20:46.053]             `+` <- base::`+`
[16:20:46.053]             `<<-` <- base::`<<-`
[16:20:46.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:46.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:46.053]                   3L)]
[16:20:46.053]             }
[16:20:46.053]             function(cond) {
[16:20:46.053]                 is_error <- inherits(cond, "error")
[16:20:46.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:46.053]                   NULL)
[16:20:46.053]                 if (is_error) {
[16:20:46.053]                   sessionInformation <- function() {
[16:20:46.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:46.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:46.053]                       search = base::search(), system = base::Sys.info())
[16:20:46.053]                   }
[16:20:46.053]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:46.053]                     cond$call), session = sessionInformation(), 
[16:20:46.053]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:46.053]                   signalCondition(cond)
[16:20:46.053]                 }
[16:20:46.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:46.053]                 "immediateCondition"))) {
[16:20:46.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:46.053]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:46.053]                   if (TRUE && !signal) {
[16:20:46.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.053]                     {
[16:20:46.053]                       inherits <- base::inherits
[16:20:46.053]                       invokeRestart <- base::invokeRestart
[16:20:46.053]                       is.null <- base::is.null
[16:20:46.053]                       muffled <- FALSE
[16:20:46.053]                       if (inherits(cond, "message")) {
[16:20:46.053]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.053]                         if (muffled) 
[16:20:46.053]                           invokeRestart("muffleMessage")
[16:20:46.053]                       }
[16:20:46.053]                       else if (inherits(cond, "warning")) {
[16:20:46.053]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.053]                         if (muffled) 
[16:20:46.053]                           invokeRestart("muffleWarning")
[16:20:46.053]                       }
[16:20:46.053]                       else if (inherits(cond, "condition")) {
[16:20:46.053]                         if (!is.null(pattern)) {
[16:20:46.053]                           computeRestarts <- base::computeRestarts
[16:20:46.053]                           grepl <- base::grepl
[16:20:46.053]                           restarts <- computeRestarts(cond)
[16:20:46.053]                           for (restart in restarts) {
[16:20:46.053]                             name <- restart$name
[16:20:46.053]                             if (is.null(name)) 
[16:20:46.053]                               next
[16:20:46.053]                             if (!grepl(pattern, name)) 
[16:20:46.053]                               next
[16:20:46.053]                             invokeRestart(restart)
[16:20:46.053]                             muffled <- TRUE
[16:20:46.053]                             break
[16:20:46.053]                           }
[16:20:46.053]                         }
[16:20:46.053]                       }
[16:20:46.053]                       invisible(muffled)
[16:20:46.053]                     }
[16:20:46.053]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.053]                   }
[16:20:46.053]                 }
[16:20:46.053]                 else {
[16:20:46.053]                   if (TRUE) {
[16:20:46.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.053]                     {
[16:20:46.053]                       inherits <- base::inherits
[16:20:46.053]                       invokeRestart <- base::invokeRestart
[16:20:46.053]                       is.null <- base::is.null
[16:20:46.053]                       muffled <- FALSE
[16:20:46.053]                       if (inherits(cond, "message")) {
[16:20:46.053]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.053]                         if (muffled) 
[16:20:46.053]                           invokeRestart("muffleMessage")
[16:20:46.053]                       }
[16:20:46.053]                       else if (inherits(cond, "warning")) {
[16:20:46.053]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.053]                         if (muffled) 
[16:20:46.053]                           invokeRestart("muffleWarning")
[16:20:46.053]                       }
[16:20:46.053]                       else if (inherits(cond, "condition")) {
[16:20:46.053]                         if (!is.null(pattern)) {
[16:20:46.053]                           computeRestarts <- base::computeRestarts
[16:20:46.053]                           grepl <- base::grepl
[16:20:46.053]                           restarts <- computeRestarts(cond)
[16:20:46.053]                           for (restart in restarts) {
[16:20:46.053]                             name <- restart$name
[16:20:46.053]                             if (is.null(name)) 
[16:20:46.053]                               next
[16:20:46.053]                             if (!grepl(pattern, name)) 
[16:20:46.053]                               next
[16:20:46.053]                             invokeRestart(restart)
[16:20:46.053]                             muffled <- TRUE
[16:20:46.053]                             break
[16:20:46.053]                           }
[16:20:46.053]                         }
[16:20:46.053]                       }
[16:20:46.053]                       invisible(muffled)
[16:20:46.053]                     }
[16:20:46.053]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.053]                   }
[16:20:46.053]                 }
[16:20:46.053]             }
[16:20:46.053]         }))
[16:20:46.053]     }, error = function(ex) {
[16:20:46.053]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:46.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.053]                 ...future.rng), started = ...future.startTime, 
[16:20:46.053]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:46.053]             version = "1.8"), class = "FutureResult")
[16:20:46.053]     }, finally = {
[16:20:46.053]         if (!identical(...future.workdir, getwd())) 
[16:20:46.053]             setwd(...future.workdir)
[16:20:46.053]         {
[16:20:46.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:46.053]                 ...future.oldOptions$nwarnings <- NULL
[16:20:46.053]             }
[16:20:46.053]             base::options(...future.oldOptions)
[16:20:46.053]             if (.Platform$OS.type == "windows") {
[16:20:46.053]                 old_names <- names(...future.oldEnvVars)
[16:20:46.053]                 envs <- base::Sys.getenv()
[16:20:46.053]                 names <- names(envs)
[16:20:46.053]                 common <- intersect(names, old_names)
[16:20:46.053]                 added <- setdiff(names, old_names)
[16:20:46.053]                 removed <- setdiff(old_names, names)
[16:20:46.053]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:46.053]                   envs[common]]
[16:20:46.053]                 NAMES <- toupper(changed)
[16:20:46.053]                 args <- list()
[16:20:46.053]                 for (kk in seq_along(NAMES)) {
[16:20:46.053]                   name <- changed[[kk]]
[16:20:46.053]                   NAME <- NAMES[[kk]]
[16:20:46.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.053]                     next
[16:20:46.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.053]                 }
[16:20:46.053]                 NAMES <- toupper(added)
[16:20:46.053]                 for (kk in seq_along(NAMES)) {
[16:20:46.053]                   name <- added[[kk]]
[16:20:46.053]                   NAME <- NAMES[[kk]]
[16:20:46.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.053]                     next
[16:20:46.053]                   args[[name]] <- ""
[16:20:46.053]                 }
[16:20:46.053]                 NAMES <- toupper(removed)
[16:20:46.053]                 for (kk in seq_along(NAMES)) {
[16:20:46.053]                   name <- removed[[kk]]
[16:20:46.053]                   NAME <- NAMES[[kk]]
[16:20:46.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.053]                     next
[16:20:46.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.053]                 }
[16:20:46.053]                 if (length(args) > 0) 
[16:20:46.053]                   base::do.call(base::Sys.setenv, args = args)
[16:20:46.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:46.053]             }
[16:20:46.053]             else {
[16:20:46.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:46.053]             }
[16:20:46.053]             {
[16:20:46.053]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:46.053]                   0L) {
[16:20:46.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:46.053]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:46.053]                   base::options(opts)
[16:20:46.053]                 }
[16:20:46.053]                 {
[16:20:46.053]                   {
[16:20:46.053]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:46.053]                     NULL
[16:20:46.053]                   }
[16:20:46.053]                   options(future.plan = NULL)
[16:20:46.053]                   if (is.na(NA_character_)) 
[16:20:46.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:46.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:46.053]                     .init = FALSE)
[16:20:46.053]                 }
[16:20:46.053]             }
[16:20:46.053]         }
[16:20:46.053]     })
[16:20:46.053]     if (TRUE) {
[16:20:46.053]         base::sink(type = "output", split = FALSE)
[16:20:46.053]         if (TRUE) {
[16:20:46.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:46.053]         }
[16:20:46.053]         else {
[16:20:46.053]             ...future.result["stdout"] <- base::list(NULL)
[16:20:46.053]         }
[16:20:46.053]         base::close(...future.stdout)
[16:20:46.053]         ...future.stdout <- NULL
[16:20:46.053]     }
[16:20:46.053]     ...future.result$conditions <- ...future.conditions
[16:20:46.053]     ...future.result$finished <- base::Sys.time()
[16:20:46.053]     ...future.result
[16:20:46.053] }
[16:20:46.055] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:46.065] receiveMessageFromWorker() for ClusterFuture ...
[16:20:46.066] - Validating connection of MultisessionFuture
[16:20:46.066] - received message: FutureResult
[16:20:46.066] - Received FutureResult
[16:20:46.066] - Erased future from FutureRegistry
[16:20:46.066] result() for ClusterFuture ...
[16:20:46.066] - result already collected: FutureResult
[16:20:46.066] result() for ClusterFuture ... done
[16:20:46.066] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:46.066] result() for ClusterFuture ...
[16:20:46.067] - result already collected: FutureResult
[16:20:46.067] result() for ClusterFuture ... done
[16:20:46.067] result() for ClusterFuture ...
[16:20:46.067] - result already collected: FutureResult
[16:20:46.067] result() for ClusterFuture ... done
[16:20:46.068] MultisessionFuture started
[16:20:46.068] - Launch lazy future ... done
[16:20:46.068] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0d2ab6b8> 
Classes 'listenv', 'environment' <environment: 0x55ed0cae0e58> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:20:46.075] receiveMessageFromWorker() for ClusterFuture ...
[16:20:46.075] - Validating connection of MultisessionFuture
[16:20:46.075] - received message: FutureResult
[16:20:46.075] - Received FutureResult
[16:20:46.075] - Erased future from FutureRegistry
[16:20:46.076] result() for ClusterFuture ...
[16:20:46.076] - result already collected: FutureResult
[16:20:46.076] result() for ClusterFuture ... done
[16:20:46.076] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:46.076] receiveMessageFromWorker() for ClusterFuture ...
[16:20:46.076] - Validating connection of MultisessionFuture
[16:20:46.076] - received message: FutureResult
[16:20:46.077] - Received FutureResult
[16:20:46.077] - Erased future from FutureRegistry
[16:20:46.077] result() for ClusterFuture ...
[16:20:46.077] - result already collected: FutureResult
[16:20:46.077] result() for ClusterFuture ... done
[16:20:46.077] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:46.079] resolve() on list environment ...
[16:20:46.079]  recursive: 0
[16:20:46.080]  length: 6
[16:20:46.080]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:46.080] signalConditionsASAP(numeric, pos=1) ...
[16:20:46.081] - nx: 6
[16:20:46.081] - relay: TRUE
[16:20:46.081] - stdout: TRUE
[16:20:46.081] - signal: TRUE
[16:20:46.081] - resignal: FALSE
[16:20:46.081] - force: TRUE
[16:20:46.081] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.081] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.081]  - until=2
[16:20:46.081]  - relaying element #2
[16:20:46.081] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.081] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.082] signalConditionsASAP(NULL, pos=1) ... done
[16:20:46.082]  length: 5 (resolved future 1)
[16:20:46.082] Future #2
[16:20:46.082] result() for ClusterFuture ...
[16:20:46.082] - result already collected: FutureResult
[16:20:46.082] result() for ClusterFuture ... done
[16:20:46.082] result() for ClusterFuture ...
[16:20:46.082] - result already collected: FutureResult
[16:20:46.082] result() for ClusterFuture ... done
[16:20:46.083] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:46.083] - nx: 6
[16:20:46.083] - relay: TRUE
[16:20:46.083] - stdout: TRUE
[16:20:46.083] - signal: TRUE
[16:20:46.083] - resignal: FALSE
[16:20:46.083] - force: TRUE
[16:20:46.083] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.083] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.083]  - until=2
[16:20:46.083]  - relaying element #2
[16:20:46.083] result() for ClusterFuture ...
[16:20:46.083] - result already collected: FutureResult
[16:20:46.084] result() for ClusterFuture ... done
[16:20:46.084] result() for ClusterFuture ...
[16:20:46.084] - result already collected: FutureResult
[16:20:46.084] result() for ClusterFuture ... done
[16:20:46.084] result() for ClusterFuture ...
[16:20:46.084] - result already collected: FutureResult
[16:20:46.084] result() for ClusterFuture ... done
[16:20:46.084] result() for ClusterFuture ...
[16:20:46.084] - result already collected: FutureResult
[16:20:46.084] result() for ClusterFuture ... done
[16:20:46.084] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.085] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.085] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:46.085]  length: 4 (resolved future 2)
[16:20:46.085] Future #3
[16:20:46.085] result() for ClusterFuture ...
[16:20:46.085] - result already collected: FutureResult
[16:20:46.085] result() for ClusterFuture ... done
[16:20:46.085] result() for ClusterFuture ...
[16:20:46.085] - result already collected: FutureResult
[16:20:46.085] result() for ClusterFuture ... done
[16:20:46.085] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:46.086] - nx: 6
[16:20:46.086] - relay: TRUE
[16:20:46.086] - stdout: TRUE
[16:20:46.086] - signal: TRUE
[16:20:46.086] - resignal: FALSE
[16:20:46.086] - force: TRUE
[16:20:46.086] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.086] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.086]  - until=3
[16:20:46.086]  - relaying element #3
[16:20:46.086] result() for ClusterFuture ...
[16:20:46.086] - result already collected: FutureResult
[16:20:46.087] result() for ClusterFuture ... done
[16:20:46.087] result() for ClusterFuture ...
[16:20:46.087] - result already collected: FutureResult
[16:20:46.087] result() for ClusterFuture ... done
[16:20:46.087] result() for ClusterFuture ...
[16:20:46.087] - result already collected: FutureResult
[16:20:46.087] result() for ClusterFuture ... done
[16:20:46.087] result() for ClusterFuture ...
[16:20:46.087] - result already collected: FutureResult
[16:20:46.087] result() for ClusterFuture ... done
[16:20:46.087] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.087] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.088] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:46.088]  length: 3 (resolved future 3)
[16:20:46.088] Future #4
[16:20:46.088] result() for ClusterFuture ...
[16:20:46.088] - result already collected: FutureResult
[16:20:46.088] result() for ClusterFuture ... done
[16:20:46.088] result() for ClusterFuture ...
[16:20:46.088] - result already collected: FutureResult
[16:20:46.088] result() for ClusterFuture ... done
[16:20:46.088] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:46.089] - nx: 6
[16:20:46.089] - relay: TRUE
[16:20:46.089] - stdout: TRUE
[16:20:46.089] - signal: TRUE
[16:20:46.089] - resignal: FALSE
[16:20:46.089] - force: TRUE
[16:20:46.089] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.089] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.089]  - until=4
[16:20:46.089]  - relaying element #4
[16:20:46.089] result() for ClusterFuture ...
[16:20:46.089] - result already collected: FutureResult
[16:20:46.090] result() for ClusterFuture ... done
[16:20:46.090] result() for ClusterFuture ...
[16:20:46.090] - result already collected: FutureResult
[16:20:46.090] result() for ClusterFuture ... done
[16:20:46.090] result() for ClusterFuture ...
[16:20:46.090] - result already collected: FutureResult
[16:20:46.090] result() for ClusterFuture ... done
[16:20:46.090] result() for ClusterFuture ...
[16:20:46.090] - result already collected: FutureResult
[16:20:46.090] result() for ClusterFuture ... done
[16:20:46.090] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.090] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.091] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:46.091]  length: 2 (resolved future 4)
[16:20:46.091] signalConditionsASAP(NULL, pos=5) ...
[16:20:46.091] - nx: 6
[16:20:46.091] - relay: TRUE
[16:20:46.091] - stdout: TRUE
[16:20:46.091] - signal: TRUE
[16:20:46.091] - resignal: FALSE
[16:20:46.091] - force: TRUE
[16:20:46.091] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.091] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.092]  - until=6
[16:20:46.092]  - relaying element #6
[16:20:46.092] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:46.092] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.092] signalConditionsASAP(NULL, pos=5) ... done
[16:20:46.092]  length: 1 (resolved future 5)
[16:20:46.092] signalConditionsASAP(numeric, pos=6) ...
[16:20:46.092] - nx: 6
[16:20:46.092] - relay: TRUE
[16:20:46.092] - stdout: TRUE
[16:20:46.092] - signal: TRUE
[16:20:46.093] - resignal: FALSE
[16:20:46.093] - force: TRUE
[16:20:46.093] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:46.093] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.093]  - until=6
[16:20:46.093] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:46.093] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.093] signalConditionsASAP(numeric, pos=6) ... done
[16:20:46.093]  length: 0 (resolved future 6)
[16:20:46.093] Relaying remaining futures
[16:20:46.093] signalConditionsASAP(NULL, pos=0) ...
[16:20:46.093] - nx: 6
[16:20:46.094] - relay: TRUE
[16:20:46.094] - stdout: TRUE
[16:20:46.094] - signal: TRUE
[16:20:46.094] - resignal: FALSE
[16:20:46.094] - force: TRUE
[16:20:46.094] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:46.094] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:46.094] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:46.094] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.094] signalConditionsASAP(NULL, pos=0) ... done
[16:20:46.095] resolve() on list environment ... DONE
[16:20:46.095] result() for ClusterFuture ...
[16:20:46.095] - result already collected: FutureResult
[16:20:46.095] result() for ClusterFuture ... done
[16:20:46.095] result() for ClusterFuture ...
[16:20:46.095] - result already collected: FutureResult
[16:20:46.095] result() for ClusterFuture ... done
[16:20:46.095] result() for ClusterFuture ...
[16:20:46.095] - result already collected: FutureResult
[16:20:46.095] result() for ClusterFuture ... done
[16:20:46.095] result() for ClusterFuture ...
[16:20:46.096] - result already collected: FutureResult
[16:20:46.096] result() for ClusterFuture ... done
[16:20:46.096] result() for ClusterFuture ...
[16:20:46.096] - result already collected: FutureResult
[16:20:46.096] result() for ClusterFuture ... done
[16:20:46.096] result() for ClusterFuture ...
[16:20:46.096] - result already collected: FutureResult
[16:20:46.096] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0c3746e8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:20:46.098] getGlobalsAndPackages() ...
[16:20:46.098] Searching for globals...
[16:20:46.098] 
[16:20:46.098] Searching for globals ... DONE
[16:20:46.098] - globals: [0] <none>
[16:20:46.099] getGlobalsAndPackages() ... DONE
[16:20:46.099] run() for ‘Future’ ...
[16:20:46.099] - state: ‘created’
[16:20:46.099] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:46.113] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:46.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:46.113]   - Field: ‘node’
[16:20:46.113]   - Field: ‘label’
[16:20:46.113]   - Field: ‘local’
[16:20:46.113]   - Field: ‘owner’
[16:20:46.114]   - Field: ‘envir’
[16:20:46.114]   - Field: ‘workers’
[16:20:46.114]   - Field: ‘packages’
[16:20:46.114]   - Field: ‘gc’
[16:20:46.114]   - Field: ‘conditions’
[16:20:46.114]   - Field: ‘persistent’
[16:20:46.114]   - Field: ‘expr’
[16:20:46.114]   - Field: ‘uuid’
[16:20:46.114]   - Field: ‘seed’
[16:20:46.114]   - Field: ‘version’
[16:20:46.114]   - Field: ‘result’
[16:20:46.115]   - Field: ‘asynchronous’
[16:20:46.115]   - Field: ‘calls’
[16:20:46.115]   - Field: ‘globals’
[16:20:46.115]   - Field: ‘stdout’
[16:20:46.115]   - Field: ‘earlySignal’
[16:20:46.115]   - Field: ‘lazy’
[16:20:46.115]   - Field: ‘state’
[16:20:46.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:46.115] - Launch lazy future ...
[16:20:46.116] Packages needed by the future expression (n = 0): <none>
[16:20:46.116] Packages needed by future strategies (n = 0): <none>
[16:20:46.116] {
[16:20:46.116]     {
[16:20:46.116]         {
[16:20:46.116]             ...future.startTime <- base::Sys.time()
[16:20:46.116]             {
[16:20:46.116]                 {
[16:20:46.116]                   {
[16:20:46.116]                     {
[16:20:46.116]                       base::local({
[16:20:46.116]                         has_future <- base::requireNamespace("future", 
[16:20:46.116]                           quietly = TRUE)
[16:20:46.116]                         if (has_future) {
[16:20:46.116]                           ns <- base::getNamespace("future")
[16:20:46.116]                           version <- ns[[".package"]][["version"]]
[16:20:46.116]                           if (is.null(version)) 
[16:20:46.116]                             version <- utils::packageVersion("future")
[16:20:46.116]                         }
[16:20:46.116]                         else {
[16:20:46.116]                           version <- NULL
[16:20:46.116]                         }
[16:20:46.116]                         if (!has_future || version < "1.8.0") {
[16:20:46.116]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:46.116]                             "", base::R.version$version.string), 
[16:20:46.116]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:46.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:46.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:46.116]                               "release", "version")], collapse = " "), 
[16:20:46.116]                             hostname = base::Sys.info()[["nodename"]])
[16:20:46.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:46.116]                             info)
[16:20:46.116]                           info <- base::paste(info, collapse = "; ")
[16:20:46.116]                           if (!has_future) {
[16:20:46.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:46.116]                               info)
[16:20:46.116]                           }
[16:20:46.116]                           else {
[16:20:46.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:46.116]                               info, version)
[16:20:46.116]                           }
[16:20:46.116]                           base::stop(msg)
[16:20:46.116]                         }
[16:20:46.116]                       })
[16:20:46.116]                     }
[16:20:46.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:46.116]                     base::options(mc.cores = 1L)
[16:20:46.116]                   }
[16:20:46.116]                   ...future.strategy.old <- future::plan("list")
[16:20:46.116]                   options(future.plan = NULL)
[16:20:46.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:46.116]                 }
[16:20:46.116]                 ...future.workdir <- getwd()
[16:20:46.116]             }
[16:20:46.116]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:46.116]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:46.116]         }
[16:20:46.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:46.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:46.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:46.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:46.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:46.116]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:46.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:46.116]             base::names(...future.oldOptions))
[16:20:46.116]     }
[16:20:46.116]     if (FALSE) {
[16:20:46.116]     }
[16:20:46.116]     else {
[16:20:46.116]         if (TRUE) {
[16:20:46.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:46.116]                 open = "w")
[16:20:46.116]         }
[16:20:46.116]         else {
[16:20:46.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:46.116]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:46.116]         }
[16:20:46.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:46.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:46.116]             base::sink(type = "output", split = FALSE)
[16:20:46.116]             base::close(...future.stdout)
[16:20:46.116]         }, add = TRUE)
[16:20:46.116]     }
[16:20:46.116]     ...future.frame <- base::sys.nframe()
[16:20:46.116]     ...future.conditions <- base::list()
[16:20:46.116]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:46.116]     if (FALSE) {
[16:20:46.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:46.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:46.116]     }
[16:20:46.116]     ...future.result <- base::tryCatch({
[16:20:46.116]         base::withCallingHandlers({
[16:20:46.116]             ...future.value <- base::withVisible(base::local({
[16:20:46.116]                 ...future.makeSendCondition <- base::local({
[16:20:46.116]                   sendCondition <- NULL
[16:20:46.116]                   function(frame = 1L) {
[16:20:46.116]                     if (is.function(sendCondition)) 
[16:20:46.116]                       return(sendCondition)
[16:20:46.116]                     ns <- getNamespace("parallel")
[16:20:46.116]                     if (exists("sendData", mode = "function", 
[16:20:46.116]                       envir = ns)) {
[16:20:46.116]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:46.116]                         envir = ns)
[16:20:46.116]                       envir <- sys.frame(frame)
[16:20:46.116]                       master <- NULL
[16:20:46.116]                       while (!identical(envir, .GlobalEnv) && 
[16:20:46.116]                         !identical(envir, emptyenv())) {
[16:20:46.116]                         if (exists("master", mode = "list", envir = envir, 
[16:20:46.116]                           inherits = FALSE)) {
[16:20:46.116]                           master <- get("master", mode = "list", 
[16:20:46.116]                             envir = envir, inherits = FALSE)
[16:20:46.116]                           if (inherits(master, c("SOCKnode", 
[16:20:46.116]                             "SOCK0node"))) {
[16:20:46.116]                             sendCondition <<- function(cond) {
[16:20:46.116]                               data <- list(type = "VALUE", value = cond, 
[16:20:46.116]                                 success = TRUE)
[16:20:46.116]                               parallel_sendData(master, data)
[16:20:46.116]                             }
[16:20:46.116]                             return(sendCondition)
[16:20:46.116]                           }
[16:20:46.116]                         }
[16:20:46.116]                         frame <- frame + 1L
[16:20:46.116]                         envir <- sys.frame(frame)
[16:20:46.116]                       }
[16:20:46.116]                     }
[16:20:46.116]                     sendCondition <<- function(cond) NULL
[16:20:46.116]                   }
[16:20:46.116]                 })
[16:20:46.116]                 withCallingHandlers({
[16:20:46.116]                   2
[16:20:46.116]                 }, immediateCondition = function(cond) {
[16:20:46.116]                   sendCondition <- ...future.makeSendCondition()
[16:20:46.116]                   sendCondition(cond)
[16:20:46.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.116]                   {
[16:20:46.116]                     inherits <- base::inherits
[16:20:46.116]                     invokeRestart <- base::invokeRestart
[16:20:46.116]                     is.null <- base::is.null
[16:20:46.116]                     muffled <- FALSE
[16:20:46.116]                     if (inherits(cond, "message")) {
[16:20:46.116]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:46.116]                       if (muffled) 
[16:20:46.116]                         invokeRestart("muffleMessage")
[16:20:46.116]                     }
[16:20:46.116]                     else if (inherits(cond, "warning")) {
[16:20:46.116]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:46.116]                       if (muffled) 
[16:20:46.116]                         invokeRestart("muffleWarning")
[16:20:46.116]                     }
[16:20:46.116]                     else if (inherits(cond, "condition")) {
[16:20:46.116]                       if (!is.null(pattern)) {
[16:20:46.116]                         computeRestarts <- base::computeRestarts
[16:20:46.116]                         grepl <- base::grepl
[16:20:46.116]                         restarts <- computeRestarts(cond)
[16:20:46.116]                         for (restart in restarts) {
[16:20:46.116]                           name <- restart$name
[16:20:46.116]                           if (is.null(name)) 
[16:20:46.116]                             next
[16:20:46.116]                           if (!grepl(pattern, name)) 
[16:20:46.116]                             next
[16:20:46.116]                           invokeRestart(restart)
[16:20:46.116]                           muffled <- TRUE
[16:20:46.116]                           break
[16:20:46.116]                         }
[16:20:46.116]                       }
[16:20:46.116]                     }
[16:20:46.116]                     invisible(muffled)
[16:20:46.116]                   }
[16:20:46.116]                   muffleCondition(cond)
[16:20:46.116]                 })
[16:20:46.116]             }))
[16:20:46.116]             future::FutureResult(value = ...future.value$value, 
[16:20:46.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.116]                   ...future.rng), globalenv = if (FALSE) 
[16:20:46.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:46.116]                     ...future.globalenv.names))
[16:20:46.116]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:46.116]         }, condition = base::local({
[16:20:46.116]             c <- base::c
[16:20:46.116]             inherits <- base::inherits
[16:20:46.116]             invokeRestart <- base::invokeRestart
[16:20:46.116]             length <- base::length
[16:20:46.116]             list <- base::list
[16:20:46.116]             seq.int <- base::seq.int
[16:20:46.116]             signalCondition <- base::signalCondition
[16:20:46.116]             sys.calls <- base::sys.calls
[16:20:46.116]             `[[` <- base::`[[`
[16:20:46.116]             `+` <- base::`+`
[16:20:46.116]             `<<-` <- base::`<<-`
[16:20:46.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:46.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:46.116]                   3L)]
[16:20:46.116]             }
[16:20:46.116]             function(cond) {
[16:20:46.116]                 is_error <- inherits(cond, "error")
[16:20:46.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:46.116]                   NULL)
[16:20:46.116]                 if (is_error) {
[16:20:46.116]                   sessionInformation <- function() {
[16:20:46.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:46.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:46.116]                       search = base::search(), system = base::Sys.info())
[16:20:46.116]                   }
[16:20:46.116]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:46.116]                     cond$call), session = sessionInformation(), 
[16:20:46.116]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:46.116]                   signalCondition(cond)
[16:20:46.116]                 }
[16:20:46.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:46.116]                 "immediateCondition"))) {
[16:20:46.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:46.116]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:46.116]                   if (TRUE && !signal) {
[16:20:46.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.116]                     {
[16:20:46.116]                       inherits <- base::inherits
[16:20:46.116]                       invokeRestart <- base::invokeRestart
[16:20:46.116]                       is.null <- base::is.null
[16:20:46.116]                       muffled <- FALSE
[16:20:46.116]                       if (inherits(cond, "message")) {
[16:20:46.116]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.116]                         if (muffled) 
[16:20:46.116]                           invokeRestart("muffleMessage")
[16:20:46.116]                       }
[16:20:46.116]                       else if (inherits(cond, "warning")) {
[16:20:46.116]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.116]                         if (muffled) 
[16:20:46.116]                           invokeRestart("muffleWarning")
[16:20:46.116]                       }
[16:20:46.116]                       else if (inherits(cond, "condition")) {
[16:20:46.116]                         if (!is.null(pattern)) {
[16:20:46.116]                           computeRestarts <- base::computeRestarts
[16:20:46.116]                           grepl <- base::grepl
[16:20:46.116]                           restarts <- computeRestarts(cond)
[16:20:46.116]                           for (restart in restarts) {
[16:20:46.116]                             name <- restart$name
[16:20:46.116]                             if (is.null(name)) 
[16:20:46.116]                               next
[16:20:46.116]                             if (!grepl(pattern, name)) 
[16:20:46.116]                               next
[16:20:46.116]                             invokeRestart(restart)
[16:20:46.116]                             muffled <- TRUE
[16:20:46.116]                             break
[16:20:46.116]                           }
[16:20:46.116]                         }
[16:20:46.116]                       }
[16:20:46.116]                       invisible(muffled)
[16:20:46.116]                     }
[16:20:46.116]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.116]                   }
[16:20:46.116]                 }
[16:20:46.116]                 else {
[16:20:46.116]                   if (TRUE) {
[16:20:46.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.116]                     {
[16:20:46.116]                       inherits <- base::inherits
[16:20:46.116]                       invokeRestart <- base::invokeRestart
[16:20:46.116]                       is.null <- base::is.null
[16:20:46.116]                       muffled <- FALSE
[16:20:46.116]                       if (inherits(cond, "message")) {
[16:20:46.116]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.116]                         if (muffled) 
[16:20:46.116]                           invokeRestart("muffleMessage")
[16:20:46.116]                       }
[16:20:46.116]                       else if (inherits(cond, "warning")) {
[16:20:46.116]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.116]                         if (muffled) 
[16:20:46.116]                           invokeRestart("muffleWarning")
[16:20:46.116]                       }
[16:20:46.116]                       else if (inherits(cond, "condition")) {
[16:20:46.116]                         if (!is.null(pattern)) {
[16:20:46.116]                           computeRestarts <- base::computeRestarts
[16:20:46.116]                           grepl <- base::grepl
[16:20:46.116]                           restarts <- computeRestarts(cond)
[16:20:46.116]                           for (restart in restarts) {
[16:20:46.116]                             name <- restart$name
[16:20:46.116]                             if (is.null(name)) 
[16:20:46.116]                               next
[16:20:46.116]                             if (!grepl(pattern, name)) 
[16:20:46.116]                               next
[16:20:46.116]                             invokeRestart(restart)
[16:20:46.116]                             muffled <- TRUE
[16:20:46.116]                             break
[16:20:46.116]                           }
[16:20:46.116]                         }
[16:20:46.116]                       }
[16:20:46.116]                       invisible(muffled)
[16:20:46.116]                     }
[16:20:46.116]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.116]                   }
[16:20:46.116]                 }
[16:20:46.116]             }
[16:20:46.116]         }))
[16:20:46.116]     }, error = function(ex) {
[16:20:46.116]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:46.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.116]                 ...future.rng), started = ...future.startTime, 
[16:20:46.116]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:46.116]             version = "1.8"), class = "FutureResult")
[16:20:46.116]     }, finally = {
[16:20:46.116]         if (!identical(...future.workdir, getwd())) 
[16:20:46.116]             setwd(...future.workdir)
[16:20:46.116]         {
[16:20:46.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:46.116]                 ...future.oldOptions$nwarnings <- NULL
[16:20:46.116]             }
[16:20:46.116]             base::options(...future.oldOptions)
[16:20:46.116]             if (.Platform$OS.type == "windows") {
[16:20:46.116]                 old_names <- names(...future.oldEnvVars)
[16:20:46.116]                 envs <- base::Sys.getenv()
[16:20:46.116]                 names <- names(envs)
[16:20:46.116]                 common <- intersect(names, old_names)
[16:20:46.116]                 added <- setdiff(names, old_names)
[16:20:46.116]                 removed <- setdiff(old_names, names)
[16:20:46.116]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:46.116]                   envs[common]]
[16:20:46.116]                 NAMES <- toupper(changed)
[16:20:46.116]                 args <- list()
[16:20:46.116]                 for (kk in seq_along(NAMES)) {
[16:20:46.116]                   name <- changed[[kk]]
[16:20:46.116]                   NAME <- NAMES[[kk]]
[16:20:46.116]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.116]                     next
[16:20:46.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.116]                 }
[16:20:46.116]                 NAMES <- toupper(added)
[16:20:46.116]                 for (kk in seq_along(NAMES)) {
[16:20:46.116]                   name <- added[[kk]]
[16:20:46.116]                   NAME <- NAMES[[kk]]
[16:20:46.116]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.116]                     next
[16:20:46.116]                   args[[name]] <- ""
[16:20:46.116]                 }
[16:20:46.116]                 NAMES <- toupper(removed)
[16:20:46.116]                 for (kk in seq_along(NAMES)) {
[16:20:46.116]                   name <- removed[[kk]]
[16:20:46.116]                   NAME <- NAMES[[kk]]
[16:20:46.116]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.116]                     next
[16:20:46.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.116]                 }
[16:20:46.116]                 if (length(args) > 0) 
[16:20:46.116]                   base::do.call(base::Sys.setenv, args = args)
[16:20:46.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:46.116]             }
[16:20:46.116]             else {
[16:20:46.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:46.116]             }
[16:20:46.116]             {
[16:20:46.116]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:46.116]                   0L) {
[16:20:46.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:46.116]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:46.116]                   base::options(opts)
[16:20:46.116]                 }
[16:20:46.116]                 {
[16:20:46.116]                   {
[16:20:46.116]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:46.116]                     NULL
[16:20:46.116]                   }
[16:20:46.116]                   options(future.plan = NULL)
[16:20:46.116]                   if (is.na(NA_character_)) 
[16:20:46.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:46.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:46.116]                     .init = FALSE)
[16:20:46.116]                 }
[16:20:46.116]             }
[16:20:46.116]         }
[16:20:46.116]     })
[16:20:46.116]     if (TRUE) {
[16:20:46.116]         base::sink(type = "output", split = FALSE)
[16:20:46.116]         if (TRUE) {
[16:20:46.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:46.116]         }
[16:20:46.116]         else {
[16:20:46.116]             ...future.result["stdout"] <- base::list(NULL)
[16:20:46.116]         }
[16:20:46.116]         base::close(...future.stdout)
[16:20:46.116]         ...future.stdout <- NULL
[16:20:46.116]     }
[16:20:46.116]     ...future.result$conditions <- ...future.conditions
[16:20:46.116]     ...future.result$finished <- base::Sys.time()
[16:20:46.116]     ...future.result
[16:20:46.116] }
[16:20:46.119] MultisessionFuture started
[16:20:46.119] - Launch lazy future ... done
[16:20:46.119] run() for ‘MultisessionFuture’ ... done
[16:20:46.119] getGlobalsAndPackages() ...
[16:20:46.120] Searching for globals...
[16:20:46.120] 
[16:20:46.120] Searching for globals ... DONE
[16:20:46.120] - globals: [0] <none>
[16:20:46.120] getGlobalsAndPackages() ... DONE
[16:20:46.120] run() for ‘Future’ ...
[16:20:46.120] - state: ‘created’
[16:20:46.121] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:46.134] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:46.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:46.134]   - Field: ‘node’
[16:20:46.134]   - Field: ‘label’
[16:20:46.134]   - Field: ‘local’
[16:20:46.134]   - Field: ‘owner’
[16:20:46.134]   - Field: ‘envir’
[16:20:46.135]   - Field: ‘workers’
[16:20:46.135]   - Field: ‘packages’
[16:20:46.135]   - Field: ‘gc’
[16:20:46.135]   - Field: ‘conditions’
[16:20:46.135]   - Field: ‘persistent’
[16:20:46.135]   - Field: ‘expr’
[16:20:46.135]   - Field: ‘uuid’
[16:20:46.135]   - Field: ‘seed’
[16:20:46.135]   - Field: ‘version’
[16:20:46.135]   - Field: ‘result’
[16:20:46.135]   - Field: ‘asynchronous’
[16:20:46.136]   - Field: ‘calls’
[16:20:46.136]   - Field: ‘globals’
[16:20:46.136]   - Field: ‘stdout’
[16:20:46.136]   - Field: ‘earlySignal’
[16:20:46.136]   - Field: ‘lazy’
[16:20:46.136]   - Field: ‘state’
[16:20:46.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:46.136] - Launch lazy future ...
[16:20:46.136] Packages needed by the future expression (n = 0): <none>
[16:20:46.137] Packages needed by future strategies (n = 0): <none>
[16:20:46.137] {
[16:20:46.137]     {
[16:20:46.137]         {
[16:20:46.137]             ...future.startTime <- base::Sys.time()
[16:20:46.137]             {
[16:20:46.137]                 {
[16:20:46.137]                   {
[16:20:46.137]                     {
[16:20:46.137]                       base::local({
[16:20:46.137]                         has_future <- base::requireNamespace("future", 
[16:20:46.137]                           quietly = TRUE)
[16:20:46.137]                         if (has_future) {
[16:20:46.137]                           ns <- base::getNamespace("future")
[16:20:46.137]                           version <- ns[[".package"]][["version"]]
[16:20:46.137]                           if (is.null(version)) 
[16:20:46.137]                             version <- utils::packageVersion("future")
[16:20:46.137]                         }
[16:20:46.137]                         else {
[16:20:46.137]                           version <- NULL
[16:20:46.137]                         }
[16:20:46.137]                         if (!has_future || version < "1.8.0") {
[16:20:46.137]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:46.137]                             "", base::R.version$version.string), 
[16:20:46.137]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:46.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:46.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:46.137]                               "release", "version")], collapse = " "), 
[16:20:46.137]                             hostname = base::Sys.info()[["nodename"]])
[16:20:46.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:46.137]                             info)
[16:20:46.137]                           info <- base::paste(info, collapse = "; ")
[16:20:46.137]                           if (!has_future) {
[16:20:46.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:46.137]                               info)
[16:20:46.137]                           }
[16:20:46.137]                           else {
[16:20:46.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:46.137]                               info, version)
[16:20:46.137]                           }
[16:20:46.137]                           base::stop(msg)
[16:20:46.137]                         }
[16:20:46.137]                       })
[16:20:46.137]                     }
[16:20:46.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:46.137]                     base::options(mc.cores = 1L)
[16:20:46.137]                   }
[16:20:46.137]                   ...future.strategy.old <- future::plan("list")
[16:20:46.137]                   options(future.plan = NULL)
[16:20:46.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:46.137]                 }
[16:20:46.137]                 ...future.workdir <- getwd()
[16:20:46.137]             }
[16:20:46.137]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:46.137]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:46.137]         }
[16:20:46.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:46.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:46.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:46.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:46.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:46.137]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:46.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:46.137]             base::names(...future.oldOptions))
[16:20:46.137]     }
[16:20:46.137]     if (FALSE) {
[16:20:46.137]     }
[16:20:46.137]     else {
[16:20:46.137]         if (TRUE) {
[16:20:46.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:46.137]                 open = "w")
[16:20:46.137]         }
[16:20:46.137]         else {
[16:20:46.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:46.137]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:46.137]         }
[16:20:46.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:46.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:46.137]             base::sink(type = "output", split = FALSE)
[16:20:46.137]             base::close(...future.stdout)
[16:20:46.137]         }, add = TRUE)
[16:20:46.137]     }
[16:20:46.137]     ...future.frame <- base::sys.nframe()
[16:20:46.137]     ...future.conditions <- base::list()
[16:20:46.137]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:46.137]     if (FALSE) {
[16:20:46.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:46.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:46.137]     }
[16:20:46.137]     ...future.result <- base::tryCatch({
[16:20:46.137]         base::withCallingHandlers({
[16:20:46.137]             ...future.value <- base::withVisible(base::local({
[16:20:46.137]                 ...future.makeSendCondition <- base::local({
[16:20:46.137]                   sendCondition <- NULL
[16:20:46.137]                   function(frame = 1L) {
[16:20:46.137]                     if (is.function(sendCondition)) 
[16:20:46.137]                       return(sendCondition)
[16:20:46.137]                     ns <- getNamespace("parallel")
[16:20:46.137]                     if (exists("sendData", mode = "function", 
[16:20:46.137]                       envir = ns)) {
[16:20:46.137]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:46.137]                         envir = ns)
[16:20:46.137]                       envir <- sys.frame(frame)
[16:20:46.137]                       master <- NULL
[16:20:46.137]                       while (!identical(envir, .GlobalEnv) && 
[16:20:46.137]                         !identical(envir, emptyenv())) {
[16:20:46.137]                         if (exists("master", mode = "list", envir = envir, 
[16:20:46.137]                           inherits = FALSE)) {
[16:20:46.137]                           master <- get("master", mode = "list", 
[16:20:46.137]                             envir = envir, inherits = FALSE)
[16:20:46.137]                           if (inherits(master, c("SOCKnode", 
[16:20:46.137]                             "SOCK0node"))) {
[16:20:46.137]                             sendCondition <<- function(cond) {
[16:20:46.137]                               data <- list(type = "VALUE", value = cond, 
[16:20:46.137]                                 success = TRUE)
[16:20:46.137]                               parallel_sendData(master, data)
[16:20:46.137]                             }
[16:20:46.137]                             return(sendCondition)
[16:20:46.137]                           }
[16:20:46.137]                         }
[16:20:46.137]                         frame <- frame + 1L
[16:20:46.137]                         envir <- sys.frame(frame)
[16:20:46.137]                       }
[16:20:46.137]                     }
[16:20:46.137]                     sendCondition <<- function(cond) NULL
[16:20:46.137]                   }
[16:20:46.137]                 })
[16:20:46.137]                 withCallingHandlers({
[16:20:46.137]                   NULL
[16:20:46.137]                 }, immediateCondition = function(cond) {
[16:20:46.137]                   sendCondition <- ...future.makeSendCondition()
[16:20:46.137]                   sendCondition(cond)
[16:20:46.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.137]                   {
[16:20:46.137]                     inherits <- base::inherits
[16:20:46.137]                     invokeRestart <- base::invokeRestart
[16:20:46.137]                     is.null <- base::is.null
[16:20:46.137]                     muffled <- FALSE
[16:20:46.137]                     if (inherits(cond, "message")) {
[16:20:46.137]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:46.137]                       if (muffled) 
[16:20:46.137]                         invokeRestart("muffleMessage")
[16:20:46.137]                     }
[16:20:46.137]                     else if (inherits(cond, "warning")) {
[16:20:46.137]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:46.137]                       if (muffled) 
[16:20:46.137]                         invokeRestart("muffleWarning")
[16:20:46.137]                     }
[16:20:46.137]                     else if (inherits(cond, "condition")) {
[16:20:46.137]                       if (!is.null(pattern)) {
[16:20:46.137]                         computeRestarts <- base::computeRestarts
[16:20:46.137]                         grepl <- base::grepl
[16:20:46.137]                         restarts <- computeRestarts(cond)
[16:20:46.137]                         for (restart in restarts) {
[16:20:46.137]                           name <- restart$name
[16:20:46.137]                           if (is.null(name)) 
[16:20:46.137]                             next
[16:20:46.137]                           if (!grepl(pattern, name)) 
[16:20:46.137]                             next
[16:20:46.137]                           invokeRestart(restart)
[16:20:46.137]                           muffled <- TRUE
[16:20:46.137]                           break
[16:20:46.137]                         }
[16:20:46.137]                       }
[16:20:46.137]                     }
[16:20:46.137]                     invisible(muffled)
[16:20:46.137]                   }
[16:20:46.137]                   muffleCondition(cond)
[16:20:46.137]                 })
[16:20:46.137]             }))
[16:20:46.137]             future::FutureResult(value = ...future.value$value, 
[16:20:46.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.137]                   ...future.rng), globalenv = if (FALSE) 
[16:20:46.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:46.137]                     ...future.globalenv.names))
[16:20:46.137]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:46.137]         }, condition = base::local({
[16:20:46.137]             c <- base::c
[16:20:46.137]             inherits <- base::inherits
[16:20:46.137]             invokeRestart <- base::invokeRestart
[16:20:46.137]             length <- base::length
[16:20:46.137]             list <- base::list
[16:20:46.137]             seq.int <- base::seq.int
[16:20:46.137]             signalCondition <- base::signalCondition
[16:20:46.137]             sys.calls <- base::sys.calls
[16:20:46.137]             `[[` <- base::`[[`
[16:20:46.137]             `+` <- base::`+`
[16:20:46.137]             `<<-` <- base::`<<-`
[16:20:46.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:46.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:46.137]                   3L)]
[16:20:46.137]             }
[16:20:46.137]             function(cond) {
[16:20:46.137]                 is_error <- inherits(cond, "error")
[16:20:46.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:46.137]                   NULL)
[16:20:46.137]                 if (is_error) {
[16:20:46.137]                   sessionInformation <- function() {
[16:20:46.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:46.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:46.137]                       search = base::search(), system = base::Sys.info())
[16:20:46.137]                   }
[16:20:46.137]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:46.137]                     cond$call), session = sessionInformation(), 
[16:20:46.137]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:46.137]                   signalCondition(cond)
[16:20:46.137]                 }
[16:20:46.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:46.137]                 "immediateCondition"))) {
[16:20:46.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:46.137]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:46.137]                   if (TRUE && !signal) {
[16:20:46.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.137]                     {
[16:20:46.137]                       inherits <- base::inherits
[16:20:46.137]                       invokeRestart <- base::invokeRestart
[16:20:46.137]                       is.null <- base::is.null
[16:20:46.137]                       muffled <- FALSE
[16:20:46.137]                       if (inherits(cond, "message")) {
[16:20:46.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.137]                         if (muffled) 
[16:20:46.137]                           invokeRestart("muffleMessage")
[16:20:46.137]                       }
[16:20:46.137]                       else if (inherits(cond, "warning")) {
[16:20:46.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.137]                         if (muffled) 
[16:20:46.137]                           invokeRestart("muffleWarning")
[16:20:46.137]                       }
[16:20:46.137]                       else if (inherits(cond, "condition")) {
[16:20:46.137]                         if (!is.null(pattern)) {
[16:20:46.137]                           computeRestarts <- base::computeRestarts
[16:20:46.137]                           grepl <- base::grepl
[16:20:46.137]                           restarts <- computeRestarts(cond)
[16:20:46.137]                           for (restart in restarts) {
[16:20:46.137]                             name <- restart$name
[16:20:46.137]                             if (is.null(name)) 
[16:20:46.137]                               next
[16:20:46.137]                             if (!grepl(pattern, name)) 
[16:20:46.137]                               next
[16:20:46.137]                             invokeRestart(restart)
[16:20:46.137]                             muffled <- TRUE
[16:20:46.137]                             break
[16:20:46.137]                           }
[16:20:46.137]                         }
[16:20:46.137]                       }
[16:20:46.137]                       invisible(muffled)
[16:20:46.137]                     }
[16:20:46.137]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.137]                   }
[16:20:46.137]                 }
[16:20:46.137]                 else {
[16:20:46.137]                   if (TRUE) {
[16:20:46.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.137]                     {
[16:20:46.137]                       inherits <- base::inherits
[16:20:46.137]                       invokeRestart <- base::invokeRestart
[16:20:46.137]                       is.null <- base::is.null
[16:20:46.137]                       muffled <- FALSE
[16:20:46.137]                       if (inherits(cond, "message")) {
[16:20:46.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.137]                         if (muffled) 
[16:20:46.137]                           invokeRestart("muffleMessage")
[16:20:46.137]                       }
[16:20:46.137]                       else if (inherits(cond, "warning")) {
[16:20:46.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.137]                         if (muffled) 
[16:20:46.137]                           invokeRestart("muffleWarning")
[16:20:46.137]                       }
[16:20:46.137]                       else if (inherits(cond, "condition")) {
[16:20:46.137]                         if (!is.null(pattern)) {
[16:20:46.137]                           computeRestarts <- base::computeRestarts
[16:20:46.137]                           grepl <- base::grepl
[16:20:46.137]                           restarts <- computeRestarts(cond)
[16:20:46.137]                           for (restart in restarts) {
[16:20:46.137]                             name <- restart$name
[16:20:46.137]                             if (is.null(name)) 
[16:20:46.137]                               next
[16:20:46.137]                             if (!grepl(pattern, name)) 
[16:20:46.137]                               next
[16:20:46.137]                             invokeRestart(restart)
[16:20:46.137]                             muffled <- TRUE
[16:20:46.137]                             break
[16:20:46.137]                           }
[16:20:46.137]                         }
[16:20:46.137]                       }
[16:20:46.137]                       invisible(muffled)
[16:20:46.137]                     }
[16:20:46.137]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.137]                   }
[16:20:46.137]                 }
[16:20:46.137]             }
[16:20:46.137]         }))
[16:20:46.137]     }, error = function(ex) {
[16:20:46.137]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:46.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.137]                 ...future.rng), started = ...future.startTime, 
[16:20:46.137]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:46.137]             version = "1.8"), class = "FutureResult")
[16:20:46.137]     }, finally = {
[16:20:46.137]         if (!identical(...future.workdir, getwd())) 
[16:20:46.137]             setwd(...future.workdir)
[16:20:46.137]         {
[16:20:46.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:46.137]                 ...future.oldOptions$nwarnings <- NULL
[16:20:46.137]             }
[16:20:46.137]             base::options(...future.oldOptions)
[16:20:46.137]             if (.Platform$OS.type == "windows") {
[16:20:46.137]                 old_names <- names(...future.oldEnvVars)
[16:20:46.137]                 envs <- base::Sys.getenv()
[16:20:46.137]                 names <- names(envs)
[16:20:46.137]                 common <- intersect(names, old_names)
[16:20:46.137]                 added <- setdiff(names, old_names)
[16:20:46.137]                 removed <- setdiff(old_names, names)
[16:20:46.137]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:46.137]                   envs[common]]
[16:20:46.137]                 NAMES <- toupper(changed)
[16:20:46.137]                 args <- list()
[16:20:46.137]                 for (kk in seq_along(NAMES)) {
[16:20:46.137]                   name <- changed[[kk]]
[16:20:46.137]                   NAME <- NAMES[[kk]]
[16:20:46.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.137]                     next
[16:20:46.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.137]                 }
[16:20:46.137]                 NAMES <- toupper(added)
[16:20:46.137]                 for (kk in seq_along(NAMES)) {
[16:20:46.137]                   name <- added[[kk]]
[16:20:46.137]                   NAME <- NAMES[[kk]]
[16:20:46.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.137]                     next
[16:20:46.137]                   args[[name]] <- ""
[16:20:46.137]                 }
[16:20:46.137]                 NAMES <- toupper(removed)
[16:20:46.137]                 for (kk in seq_along(NAMES)) {
[16:20:46.137]                   name <- removed[[kk]]
[16:20:46.137]                   NAME <- NAMES[[kk]]
[16:20:46.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.137]                     next
[16:20:46.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.137]                 }
[16:20:46.137]                 if (length(args) > 0) 
[16:20:46.137]                   base::do.call(base::Sys.setenv, args = args)
[16:20:46.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:46.137]             }
[16:20:46.137]             else {
[16:20:46.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:46.137]             }
[16:20:46.137]             {
[16:20:46.137]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:46.137]                   0L) {
[16:20:46.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:46.137]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:46.137]                   base::options(opts)
[16:20:46.137]                 }
[16:20:46.137]                 {
[16:20:46.137]                   {
[16:20:46.137]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:46.137]                     NULL
[16:20:46.137]                   }
[16:20:46.137]                   options(future.plan = NULL)
[16:20:46.137]                   if (is.na(NA_character_)) 
[16:20:46.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:46.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:46.137]                     .init = FALSE)
[16:20:46.137]                 }
[16:20:46.137]             }
[16:20:46.137]         }
[16:20:46.137]     })
[16:20:46.137]     if (TRUE) {
[16:20:46.137]         base::sink(type = "output", split = FALSE)
[16:20:46.137]         if (TRUE) {
[16:20:46.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:46.137]         }
[16:20:46.137]         else {
[16:20:46.137]             ...future.result["stdout"] <- base::list(NULL)
[16:20:46.137]         }
[16:20:46.137]         base::close(...future.stdout)
[16:20:46.137]         ...future.stdout <- NULL
[16:20:46.137]     }
[16:20:46.137]     ...future.result$conditions <- ...future.conditions
[16:20:46.137]     ...future.result$finished <- base::Sys.time()
[16:20:46.137]     ...future.result
[16:20:46.137] }
[16:20:46.140] MultisessionFuture started
[16:20:46.140] - Launch lazy future ... done
[16:20:46.140] run() for ‘MultisessionFuture’ ... done
[16:20:46.140] getGlobalsAndPackages() ...
[16:20:46.141] Searching for globals...
[16:20:46.141] - globals found: [1] ‘{’
[16:20:46.141] Searching for globals ... DONE
[16:20:46.141] Resolving globals: FALSE
[16:20:46.142] 
[16:20:46.142] 
[16:20:46.142] getGlobalsAndPackages() ... DONE
[16:20:46.142] run() for ‘Future’ ...
[16:20:46.142] - state: ‘created’
[16:20:46.142] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:46.156] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:46.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:46.156]   - Field: ‘node’
[16:20:46.156]   - Field: ‘label’
[16:20:46.156]   - Field: ‘local’
[16:20:46.156]   - Field: ‘owner’
[16:20:46.156]   - Field: ‘envir’
[16:20:46.157]   - Field: ‘workers’
[16:20:46.157]   - Field: ‘packages’
[16:20:46.157]   - Field: ‘gc’
[16:20:46.157]   - Field: ‘conditions’
[16:20:46.157]   - Field: ‘persistent’
[16:20:46.157]   - Field: ‘expr’
[16:20:46.157]   - Field: ‘uuid’
[16:20:46.157]   - Field: ‘seed’
[16:20:46.157]   - Field: ‘version’
[16:20:46.157]   - Field: ‘result’
[16:20:46.157]   - Field: ‘asynchronous’
[16:20:46.158]   - Field: ‘calls’
[16:20:46.158]   - Field: ‘globals’
[16:20:46.158]   - Field: ‘stdout’
[16:20:46.158]   - Field: ‘earlySignal’
[16:20:46.158]   - Field: ‘lazy’
[16:20:46.158]   - Field: ‘state’
[16:20:46.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:46.158] - Launch lazy future ...
[16:20:46.158] Packages needed by the future expression (n = 0): <none>
[16:20:46.159] Packages needed by future strategies (n = 0): <none>
[16:20:46.159] {
[16:20:46.159]     {
[16:20:46.159]         {
[16:20:46.159]             ...future.startTime <- base::Sys.time()
[16:20:46.159]             {
[16:20:46.159]                 {
[16:20:46.159]                   {
[16:20:46.159]                     {
[16:20:46.159]                       base::local({
[16:20:46.159]                         has_future <- base::requireNamespace("future", 
[16:20:46.159]                           quietly = TRUE)
[16:20:46.159]                         if (has_future) {
[16:20:46.159]                           ns <- base::getNamespace("future")
[16:20:46.159]                           version <- ns[[".package"]][["version"]]
[16:20:46.159]                           if (is.null(version)) 
[16:20:46.159]                             version <- utils::packageVersion("future")
[16:20:46.159]                         }
[16:20:46.159]                         else {
[16:20:46.159]                           version <- NULL
[16:20:46.159]                         }
[16:20:46.159]                         if (!has_future || version < "1.8.0") {
[16:20:46.159]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:46.159]                             "", base::R.version$version.string), 
[16:20:46.159]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:46.159]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:46.159]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:46.159]                               "release", "version")], collapse = " "), 
[16:20:46.159]                             hostname = base::Sys.info()[["nodename"]])
[16:20:46.159]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:46.159]                             info)
[16:20:46.159]                           info <- base::paste(info, collapse = "; ")
[16:20:46.159]                           if (!has_future) {
[16:20:46.159]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:46.159]                               info)
[16:20:46.159]                           }
[16:20:46.159]                           else {
[16:20:46.159]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:46.159]                               info, version)
[16:20:46.159]                           }
[16:20:46.159]                           base::stop(msg)
[16:20:46.159]                         }
[16:20:46.159]                       })
[16:20:46.159]                     }
[16:20:46.159]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:46.159]                     base::options(mc.cores = 1L)
[16:20:46.159]                   }
[16:20:46.159]                   ...future.strategy.old <- future::plan("list")
[16:20:46.159]                   options(future.plan = NULL)
[16:20:46.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:46.159]                 }
[16:20:46.159]                 ...future.workdir <- getwd()
[16:20:46.159]             }
[16:20:46.159]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:46.159]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:46.159]         }
[16:20:46.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:46.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:46.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:46.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:46.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:46.159]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:46.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:46.159]             base::names(...future.oldOptions))
[16:20:46.159]     }
[16:20:46.159]     if (FALSE) {
[16:20:46.159]     }
[16:20:46.159]     else {
[16:20:46.159]         if (TRUE) {
[16:20:46.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:46.159]                 open = "w")
[16:20:46.159]         }
[16:20:46.159]         else {
[16:20:46.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:46.159]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:46.159]         }
[16:20:46.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:46.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:46.159]             base::sink(type = "output", split = FALSE)
[16:20:46.159]             base::close(...future.stdout)
[16:20:46.159]         }, add = TRUE)
[16:20:46.159]     }
[16:20:46.159]     ...future.frame <- base::sys.nframe()
[16:20:46.159]     ...future.conditions <- base::list()
[16:20:46.159]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:46.159]     if (FALSE) {
[16:20:46.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:46.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:46.159]     }
[16:20:46.159]     ...future.result <- base::tryCatch({
[16:20:46.159]         base::withCallingHandlers({
[16:20:46.159]             ...future.value <- base::withVisible(base::local({
[16:20:46.159]                 ...future.makeSendCondition <- base::local({
[16:20:46.159]                   sendCondition <- NULL
[16:20:46.159]                   function(frame = 1L) {
[16:20:46.159]                     if (is.function(sendCondition)) 
[16:20:46.159]                       return(sendCondition)
[16:20:46.159]                     ns <- getNamespace("parallel")
[16:20:46.159]                     if (exists("sendData", mode = "function", 
[16:20:46.159]                       envir = ns)) {
[16:20:46.159]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:46.159]                         envir = ns)
[16:20:46.159]                       envir <- sys.frame(frame)
[16:20:46.159]                       master <- NULL
[16:20:46.159]                       while (!identical(envir, .GlobalEnv) && 
[16:20:46.159]                         !identical(envir, emptyenv())) {
[16:20:46.159]                         if (exists("master", mode = "list", envir = envir, 
[16:20:46.159]                           inherits = FALSE)) {
[16:20:46.159]                           master <- get("master", mode = "list", 
[16:20:46.159]                             envir = envir, inherits = FALSE)
[16:20:46.159]                           if (inherits(master, c("SOCKnode", 
[16:20:46.159]                             "SOCK0node"))) {
[16:20:46.159]                             sendCondition <<- function(cond) {
[16:20:46.159]                               data <- list(type = "VALUE", value = cond, 
[16:20:46.159]                                 success = TRUE)
[16:20:46.159]                               parallel_sendData(master, data)
[16:20:46.159]                             }
[16:20:46.159]                             return(sendCondition)
[16:20:46.159]                           }
[16:20:46.159]                         }
[16:20:46.159]                         frame <- frame + 1L
[16:20:46.159]                         envir <- sys.frame(frame)
[16:20:46.159]                       }
[16:20:46.159]                     }
[16:20:46.159]                     sendCondition <<- function(cond) NULL
[16:20:46.159]                   }
[16:20:46.159]                 })
[16:20:46.159]                 withCallingHandlers({
[16:20:46.159]                   {
[16:20:46.159]                     4
[16:20:46.159]                   }
[16:20:46.159]                 }, immediateCondition = function(cond) {
[16:20:46.159]                   sendCondition <- ...future.makeSendCondition()
[16:20:46.159]                   sendCondition(cond)
[16:20:46.159]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.159]                   {
[16:20:46.159]                     inherits <- base::inherits
[16:20:46.159]                     invokeRestart <- base::invokeRestart
[16:20:46.159]                     is.null <- base::is.null
[16:20:46.159]                     muffled <- FALSE
[16:20:46.159]                     if (inherits(cond, "message")) {
[16:20:46.159]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:46.159]                       if (muffled) 
[16:20:46.159]                         invokeRestart("muffleMessage")
[16:20:46.159]                     }
[16:20:46.159]                     else if (inherits(cond, "warning")) {
[16:20:46.159]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:46.159]                       if (muffled) 
[16:20:46.159]                         invokeRestart("muffleWarning")
[16:20:46.159]                     }
[16:20:46.159]                     else if (inherits(cond, "condition")) {
[16:20:46.159]                       if (!is.null(pattern)) {
[16:20:46.159]                         computeRestarts <- base::computeRestarts
[16:20:46.159]                         grepl <- base::grepl
[16:20:46.159]                         restarts <- computeRestarts(cond)
[16:20:46.159]                         for (restart in restarts) {
[16:20:46.159]                           name <- restart$name
[16:20:46.159]                           if (is.null(name)) 
[16:20:46.159]                             next
[16:20:46.159]                           if (!grepl(pattern, name)) 
[16:20:46.159]                             next
[16:20:46.159]                           invokeRestart(restart)
[16:20:46.159]                           muffled <- TRUE
[16:20:46.159]                           break
[16:20:46.159]                         }
[16:20:46.159]                       }
[16:20:46.159]                     }
[16:20:46.159]                     invisible(muffled)
[16:20:46.159]                   }
[16:20:46.159]                   muffleCondition(cond)
[16:20:46.159]                 })
[16:20:46.159]             }))
[16:20:46.159]             future::FutureResult(value = ...future.value$value, 
[16:20:46.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.159]                   ...future.rng), globalenv = if (FALSE) 
[16:20:46.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:46.159]                     ...future.globalenv.names))
[16:20:46.159]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:46.159]         }, condition = base::local({
[16:20:46.159]             c <- base::c
[16:20:46.159]             inherits <- base::inherits
[16:20:46.159]             invokeRestart <- base::invokeRestart
[16:20:46.159]             length <- base::length
[16:20:46.159]             list <- base::list
[16:20:46.159]             seq.int <- base::seq.int
[16:20:46.159]             signalCondition <- base::signalCondition
[16:20:46.159]             sys.calls <- base::sys.calls
[16:20:46.159]             `[[` <- base::`[[`
[16:20:46.159]             `+` <- base::`+`
[16:20:46.159]             `<<-` <- base::`<<-`
[16:20:46.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:46.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:46.159]                   3L)]
[16:20:46.159]             }
[16:20:46.159]             function(cond) {
[16:20:46.159]                 is_error <- inherits(cond, "error")
[16:20:46.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:46.159]                   NULL)
[16:20:46.159]                 if (is_error) {
[16:20:46.159]                   sessionInformation <- function() {
[16:20:46.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:46.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:46.159]                       search = base::search(), system = base::Sys.info())
[16:20:46.159]                   }
[16:20:46.159]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:46.159]                     cond$call), session = sessionInformation(), 
[16:20:46.159]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:46.159]                   signalCondition(cond)
[16:20:46.159]                 }
[16:20:46.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:46.159]                 "immediateCondition"))) {
[16:20:46.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:46.159]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:46.159]                   if (TRUE && !signal) {
[16:20:46.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.159]                     {
[16:20:46.159]                       inherits <- base::inherits
[16:20:46.159]                       invokeRestart <- base::invokeRestart
[16:20:46.159]                       is.null <- base::is.null
[16:20:46.159]                       muffled <- FALSE
[16:20:46.159]                       if (inherits(cond, "message")) {
[16:20:46.159]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.159]                         if (muffled) 
[16:20:46.159]                           invokeRestart("muffleMessage")
[16:20:46.159]                       }
[16:20:46.159]                       else if (inherits(cond, "warning")) {
[16:20:46.159]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.159]                         if (muffled) 
[16:20:46.159]                           invokeRestart("muffleWarning")
[16:20:46.159]                       }
[16:20:46.159]                       else if (inherits(cond, "condition")) {
[16:20:46.159]                         if (!is.null(pattern)) {
[16:20:46.159]                           computeRestarts <- base::computeRestarts
[16:20:46.159]                           grepl <- base::grepl
[16:20:46.159]                           restarts <- computeRestarts(cond)
[16:20:46.159]                           for (restart in restarts) {
[16:20:46.159]                             name <- restart$name
[16:20:46.159]                             if (is.null(name)) 
[16:20:46.159]                               next
[16:20:46.159]                             if (!grepl(pattern, name)) 
[16:20:46.159]                               next
[16:20:46.159]                             invokeRestart(restart)
[16:20:46.159]                             muffled <- TRUE
[16:20:46.159]                             break
[16:20:46.159]                           }
[16:20:46.159]                         }
[16:20:46.159]                       }
[16:20:46.159]                       invisible(muffled)
[16:20:46.159]                     }
[16:20:46.159]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.159]                   }
[16:20:46.159]                 }
[16:20:46.159]                 else {
[16:20:46.159]                   if (TRUE) {
[16:20:46.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.159]                     {
[16:20:46.159]                       inherits <- base::inherits
[16:20:46.159]                       invokeRestart <- base::invokeRestart
[16:20:46.159]                       is.null <- base::is.null
[16:20:46.159]                       muffled <- FALSE
[16:20:46.159]                       if (inherits(cond, "message")) {
[16:20:46.159]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.159]                         if (muffled) 
[16:20:46.159]                           invokeRestart("muffleMessage")
[16:20:46.159]                       }
[16:20:46.159]                       else if (inherits(cond, "warning")) {
[16:20:46.159]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.159]                         if (muffled) 
[16:20:46.159]                           invokeRestart("muffleWarning")
[16:20:46.159]                       }
[16:20:46.159]                       else if (inherits(cond, "condition")) {
[16:20:46.159]                         if (!is.null(pattern)) {
[16:20:46.159]                           computeRestarts <- base::computeRestarts
[16:20:46.159]                           grepl <- base::grepl
[16:20:46.159]                           restarts <- computeRestarts(cond)
[16:20:46.159]                           for (restart in restarts) {
[16:20:46.159]                             name <- restart$name
[16:20:46.159]                             if (is.null(name)) 
[16:20:46.159]                               next
[16:20:46.159]                             if (!grepl(pattern, name)) 
[16:20:46.159]                               next
[16:20:46.159]                             invokeRestart(restart)
[16:20:46.159]                             muffled <- TRUE
[16:20:46.159]                             break
[16:20:46.159]                           }
[16:20:46.159]                         }
[16:20:46.159]                       }
[16:20:46.159]                       invisible(muffled)
[16:20:46.159]                     }
[16:20:46.159]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.159]                   }
[16:20:46.159]                 }
[16:20:46.159]             }
[16:20:46.159]         }))
[16:20:46.159]     }, error = function(ex) {
[16:20:46.159]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:46.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.159]                 ...future.rng), started = ...future.startTime, 
[16:20:46.159]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:46.159]             version = "1.8"), class = "FutureResult")
[16:20:46.159]     }, finally = {
[16:20:46.159]         if (!identical(...future.workdir, getwd())) 
[16:20:46.159]             setwd(...future.workdir)
[16:20:46.159]         {
[16:20:46.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:46.159]                 ...future.oldOptions$nwarnings <- NULL
[16:20:46.159]             }
[16:20:46.159]             base::options(...future.oldOptions)
[16:20:46.159]             if (.Platform$OS.type == "windows") {
[16:20:46.159]                 old_names <- names(...future.oldEnvVars)
[16:20:46.159]                 envs <- base::Sys.getenv()
[16:20:46.159]                 names <- names(envs)
[16:20:46.159]                 common <- intersect(names, old_names)
[16:20:46.159]                 added <- setdiff(names, old_names)
[16:20:46.159]                 removed <- setdiff(old_names, names)
[16:20:46.159]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:46.159]                   envs[common]]
[16:20:46.159]                 NAMES <- toupper(changed)
[16:20:46.159]                 args <- list()
[16:20:46.159]                 for (kk in seq_along(NAMES)) {
[16:20:46.159]                   name <- changed[[kk]]
[16:20:46.159]                   NAME <- NAMES[[kk]]
[16:20:46.159]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.159]                     next
[16:20:46.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.159]                 }
[16:20:46.159]                 NAMES <- toupper(added)
[16:20:46.159]                 for (kk in seq_along(NAMES)) {
[16:20:46.159]                   name <- added[[kk]]
[16:20:46.159]                   NAME <- NAMES[[kk]]
[16:20:46.159]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.159]                     next
[16:20:46.159]                   args[[name]] <- ""
[16:20:46.159]                 }
[16:20:46.159]                 NAMES <- toupper(removed)
[16:20:46.159]                 for (kk in seq_along(NAMES)) {
[16:20:46.159]                   name <- removed[[kk]]
[16:20:46.159]                   NAME <- NAMES[[kk]]
[16:20:46.159]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.159]                     next
[16:20:46.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.159]                 }
[16:20:46.159]                 if (length(args) > 0) 
[16:20:46.159]                   base::do.call(base::Sys.setenv, args = args)
[16:20:46.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:46.159]             }
[16:20:46.159]             else {
[16:20:46.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:46.159]             }
[16:20:46.159]             {
[16:20:46.159]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:46.159]                   0L) {
[16:20:46.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:46.159]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:46.159]                   base::options(opts)
[16:20:46.159]                 }
[16:20:46.159]                 {
[16:20:46.159]                   {
[16:20:46.159]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:46.159]                     NULL
[16:20:46.159]                   }
[16:20:46.159]                   options(future.plan = NULL)
[16:20:46.159]                   if (is.na(NA_character_)) 
[16:20:46.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:46.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:46.159]                     .init = FALSE)
[16:20:46.159]                 }
[16:20:46.159]             }
[16:20:46.159]         }
[16:20:46.159]     })
[16:20:46.159]     if (TRUE) {
[16:20:46.159]         base::sink(type = "output", split = FALSE)
[16:20:46.159]         if (TRUE) {
[16:20:46.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:46.159]         }
[16:20:46.159]         else {
[16:20:46.159]             ...future.result["stdout"] <- base::list(NULL)
[16:20:46.159]         }
[16:20:46.159]         base::close(...future.stdout)
[16:20:46.159]         ...future.stdout <- NULL
[16:20:46.159]     }
[16:20:46.159]     ...future.result$conditions <- ...future.conditions
[16:20:46.159]     ...future.result$finished <- base::Sys.time()
[16:20:46.159]     ...future.result
[16:20:46.159] }
[16:20:46.161] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:46.172] receiveMessageFromWorker() for ClusterFuture ...
[16:20:46.172] - Validating connection of MultisessionFuture
[16:20:46.172] - received message: FutureResult
[16:20:46.172] - Received FutureResult
[16:20:46.172] - Erased future from FutureRegistry
[16:20:46.173] result() for ClusterFuture ...
[16:20:46.173] - result already collected: FutureResult
[16:20:46.173] result() for ClusterFuture ... done
[16:20:46.173] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:46.173] result() for ClusterFuture ...
[16:20:46.173] - result already collected: FutureResult
[16:20:46.173] result() for ClusterFuture ... done
[16:20:46.173] result() for ClusterFuture ...
[16:20:46.173] - result already collected: FutureResult
[16:20:46.173] result() for ClusterFuture ... done
[16:20:46.174] MultisessionFuture started
[16:20:46.174] - Launch lazy future ... done
[16:20:46.174] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0cc08e40> 
Classes 'listenv', 'environment' <environment: 0x55ed0de04ab8> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:46.179] receiveMessageFromWorker() for ClusterFuture ...
[16:20:46.179] - Validating connection of MultisessionFuture
[16:20:46.179] - received message: FutureResult
[16:20:46.179] - Received FutureResult
[16:20:46.179] - Erased future from FutureRegistry
[16:20:46.179] result() for ClusterFuture ...
[16:20:46.179] - result already collected: FutureResult
[16:20:46.179] result() for ClusterFuture ... done
[16:20:46.179] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:46.180] receiveMessageFromWorker() for ClusterFuture ...
[16:20:46.180] - Validating connection of MultisessionFuture
[16:20:46.180] - received message: FutureResult
[16:20:46.180] - Received FutureResult
[16:20:46.180] - Erased future from FutureRegistry
[16:20:46.180] result() for ClusterFuture ...
[16:20:46.181] - result already collected: FutureResult
[16:20:46.181] result() for ClusterFuture ... done
[16:20:46.181] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:46.186] resolve() on list environment ...
[16:20:46.186]  recursive: 0
[16:20:46.187]  length: 6
[16:20:46.187]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:46.187] signalConditionsASAP(numeric, pos=1) ...
[16:20:46.187] - nx: 6
[16:20:46.187] - relay: TRUE
[16:20:46.188] - stdout: TRUE
[16:20:46.188] - signal: TRUE
[16:20:46.188] - resignal: FALSE
[16:20:46.188] - force: TRUE
[16:20:46.188] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.188] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.188]  - until=2
[16:20:46.188]  - relaying element #2
[16:20:46.188] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.188] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.188] signalConditionsASAP(NULL, pos=1) ... done
[16:20:46.189]  length: 5 (resolved future 1)
[16:20:46.189] Future #2
[16:20:46.189] result() for ClusterFuture ...
[16:20:46.189] - result already collected: FutureResult
[16:20:46.189] result() for ClusterFuture ... done
[16:20:46.189] result() for ClusterFuture ...
[16:20:46.189] - result already collected: FutureResult
[16:20:46.189] result() for ClusterFuture ... done
[16:20:46.189] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:46.189] - nx: 6
[16:20:46.189] - relay: TRUE
[16:20:46.190] - stdout: TRUE
[16:20:46.190] - signal: TRUE
[16:20:46.190] - resignal: FALSE
[16:20:46.190] - force: TRUE
[16:20:46.190] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.190] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.190]  - until=2
[16:20:46.190]  - relaying element #2
[16:20:46.190] result() for ClusterFuture ...
[16:20:46.190] - result already collected: FutureResult
[16:20:46.190] result() for ClusterFuture ... done
[16:20:46.190] result() for ClusterFuture ...
[16:20:46.191] - result already collected: FutureResult
[16:20:46.191] result() for ClusterFuture ... done
[16:20:46.191] result() for ClusterFuture ...
[16:20:46.191] - result already collected: FutureResult
[16:20:46.191] result() for ClusterFuture ... done
[16:20:46.191] result() for ClusterFuture ...
[16:20:46.191] - result already collected: FutureResult
[16:20:46.191] result() for ClusterFuture ... done
[16:20:46.191] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.191] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.191] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:46.192]  length: 4 (resolved future 2)
[16:20:46.192] Future #3
[16:20:46.192] result() for ClusterFuture ...
[16:20:46.192] - result already collected: FutureResult
[16:20:46.192] result() for ClusterFuture ... done
[16:20:46.192] result() for ClusterFuture ...
[16:20:46.192] - result already collected: FutureResult
[16:20:46.192] result() for ClusterFuture ... done
[16:20:46.192] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:46.192] - nx: 6
[16:20:46.192] - relay: TRUE
[16:20:46.193] - stdout: TRUE
[16:20:46.193] - signal: TRUE
[16:20:46.193] - resignal: FALSE
[16:20:46.193] - force: TRUE
[16:20:46.193] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.193] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.193]  - until=3
[16:20:46.193]  - relaying element #3
[16:20:46.193] result() for ClusterFuture ...
[16:20:46.193] - result already collected: FutureResult
[16:20:46.193] result() for ClusterFuture ... done
[16:20:46.193] result() for ClusterFuture ...
[16:20:46.194] - result already collected: FutureResult
[16:20:46.194] result() for ClusterFuture ... done
[16:20:46.194] result() for ClusterFuture ...
[16:20:46.194] - result already collected: FutureResult
[16:20:46.194] result() for ClusterFuture ... done
[16:20:46.194] result() for ClusterFuture ...
[16:20:46.194] - result already collected: FutureResult
[16:20:46.194] result() for ClusterFuture ... done
[16:20:46.194] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.194] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.194] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:46.194]  length: 3 (resolved future 3)
[16:20:46.195] Future #4
[16:20:46.195] result() for ClusterFuture ...
[16:20:46.195] - result already collected: FutureResult
[16:20:46.195] result() for ClusterFuture ... done
[16:20:46.195] result() for ClusterFuture ...
[16:20:46.195] - result already collected: FutureResult
[16:20:46.195] result() for ClusterFuture ... done
[16:20:46.195] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:46.195] - nx: 6
[16:20:46.195] - relay: TRUE
[16:20:46.195] - stdout: TRUE
[16:20:46.196] - signal: TRUE
[16:20:46.196] - resignal: FALSE
[16:20:46.196] - force: TRUE
[16:20:46.196] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.196] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.196]  - until=4
[16:20:46.196]  - relaying element #4
[16:20:46.196] result() for ClusterFuture ...
[16:20:46.196] - result already collected: FutureResult
[16:20:46.196] result() for ClusterFuture ... done
[16:20:46.196] result() for ClusterFuture ...
[16:20:46.197] - result already collected: FutureResult
[16:20:46.197] result() for ClusterFuture ... done
[16:20:46.197] result() for ClusterFuture ...
[16:20:46.197] - result already collected: FutureResult
[16:20:46.197] result() for ClusterFuture ... done
[16:20:46.197] result() for ClusterFuture ...
[16:20:46.197] - result already collected: FutureResult
[16:20:46.197] result() for ClusterFuture ... done
[16:20:46.197] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.197] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.197] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:46.198]  length: 2 (resolved future 4)
[16:20:46.198] signalConditionsASAP(NULL, pos=5) ...
[16:20:46.198] - nx: 6
[16:20:46.198] - relay: TRUE
[16:20:46.198] - stdout: TRUE
[16:20:46.198] - signal: TRUE
[16:20:46.198] - resignal: FALSE
[16:20:46.198] - force: TRUE
[16:20:46.198] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.198] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.198]  - until=6
[16:20:46.198]  - relaying element #6
[16:20:46.199] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:46.199] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.199] signalConditionsASAP(NULL, pos=5) ... done
[16:20:46.199]  length: 1 (resolved future 5)
[16:20:46.199] signalConditionsASAP(numeric, pos=6) ...
[16:20:46.199] - nx: 6
[16:20:46.199] - relay: TRUE
[16:20:46.199] - stdout: TRUE
[16:20:46.199] - signal: TRUE
[16:20:46.199] - resignal: FALSE
[16:20:46.199] - force: TRUE
[16:20:46.199] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:46.200] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.200]  - until=6
[16:20:46.200] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:46.200] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.200] signalConditionsASAP(numeric, pos=6) ... done
[16:20:46.200]  length: 0 (resolved future 6)
[16:20:46.200] Relaying remaining futures
[16:20:46.200] signalConditionsASAP(NULL, pos=0) ...
[16:20:46.200] - nx: 6
[16:20:46.200] - relay: TRUE
[16:20:46.200] - stdout: TRUE
[16:20:46.201] - signal: TRUE
[16:20:46.201] - resignal: FALSE
[16:20:46.201] - force: TRUE
[16:20:46.201] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:46.201] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:46.201] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:46.201] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.201] signalConditionsASAP(NULL, pos=0) ... done
[16:20:46.201] resolve() on list environment ... DONE
[16:20:46.201] result() for ClusterFuture ...
[16:20:46.201] - result already collected: FutureResult
[16:20:46.202] result() for ClusterFuture ... done
[16:20:46.202] result() for ClusterFuture ...
[16:20:46.202] - result already collected: FutureResult
[16:20:46.202] result() for ClusterFuture ... done
[16:20:46.202] result() for ClusterFuture ...
[16:20:46.202] - result already collected: FutureResult
[16:20:46.202] result() for ClusterFuture ... done
[16:20:46.202] result() for ClusterFuture ...
[16:20:46.202] - result already collected: FutureResult
[16:20:46.202] result() for ClusterFuture ... done
[16:20:46.203] result() for ClusterFuture ...
[16:20:46.203] - result already collected: FutureResult
[16:20:46.203] result() for ClusterFuture ... done
[16:20:46.203] result() for ClusterFuture ...
[16:20:46.203] - result already collected: FutureResult
[16:20:46.203] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0c8c3310> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:20:46.205] getGlobalsAndPackages() ...
[16:20:46.205] Searching for globals...
[16:20:46.205] 
[16:20:46.206] Searching for globals ... DONE
[16:20:46.206] - globals: [0] <none>
[16:20:46.206] getGlobalsAndPackages() ... DONE
[16:20:46.206] run() for ‘Future’ ...
[16:20:46.206] - state: ‘created’
[16:20:46.206] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:46.220] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:46.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:46.221]   - Field: ‘node’
[16:20:46.221]   - Field: ‘label’
[16:20:46.221]   - Field: ‘local’
[16:20:46.221]   - Field: ‘owner’
[16:20:46.221]   - Field: ‘envir’
[16:20:46.221]   - Field: ‘workers’
[16:20:46.221]   - Field: ‘packages’
[16:20:46.221]   - Field: ‘gc’
[16:20:46.221]   - Field: ‘conditions’
[16:20:46.222]   - Field: ‘persistent’
[16:20:46.222]   - Field: ‘expr’
[16:20:46.222]   - Field: ‘uuid’
[16:20:46.222]   - Field: ‘seed’
[16:20:46.222]   - Field: ‘version’
[16:20:46.222]   - Field: ‘result’
[16:20:46.222]   - Field: ‘asynchronous’
[16:20:46.222]   - Field: ‘calls’
[16:20:46.222]   - Field: ‘globals’
[16:20:46.222]   - Field: ‘stdout’
[16:20:46.223]   - Field: ‘earlySignal’
[16:20:46.223]   - Field: ‘lazy’
[16:20:46.223]   - Field: ‘state’
[16:20:46.223] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:46.223] - Launch lazy future ...
[16:20:46.223] Packages needed by the future expression (n = 0): <none>
[16:20:46.223] Packages needed by future strategies (n = 0): <none>
[16:20:46.224] {
[16:20:46.224]     {
[16:20:46.224]         {
[16:20:46.224]             ...future.startTime <- base::Sys.time()
[16:20:46.224]             {
[16:20:46.224]                 {
[16:20:46.224]                   {
[16:20:46.224]                     {
[16:20:46.224]                       base::local({
[16:20:46.224]                         has_future <- base::requireNamespace("future", 
[16:20:46.224]                           quietly = TRUE)
[16:20:46.224]                         if (has_future) {
[16:20:46.224]                           ns <- base::getNamespace("future")
[16:20:46.224]                           version <- ns[[".package"]][["version"]]
[16:20:46.224]                           if (is.null(version)) 
[16:20:46.224]                             version <- utils::packageVersion("future")
[16:20:46.224]                         }
[16:20:46.224]                         else {
[16:20:46.224]                           version <- NULL
[16:20:46.224]                         }
[16:20:46.224]                         if (!has_future || version < "1.8.0") {
[16:20:46.224]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:46.224]                             "", base::R.version$version.string), 
[16:20:46.224]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:46.224]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:46.224]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:46.224]                               "release", "version")], collapse = " "), 
[16:20:46.224]                             hostname = base::Sys.info()[["nodename"]])
[16:20:46.224]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:46.224]                             info)
[16:20:46.224]                           info <- base::paste(info, collapse = "; ")
[16:20:46.224]                           if (!has_future) {
[16:20:46.224]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:46.224]                               info)
[16:20:46.224]                           }
[16:20:46.224]                           else {
[16:20:46.224]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:46.224]                               info, version)
[16:20:46.224]                           }
[16:20:46.224]                           base::stop(msg)
[16:20:46.224]                         }
[16:20:46.224]                       })
[16:20:46.224]                     }
[16:20:46.224]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:46.224]                     base::options(mc.cores = 1L)
[16:20:46.224]                   }
[16:20:46.224]                   ...future.strategy.old <- future::plan("list")
[16:20:46.224]                   options(future.plan = NULL)
[16:20:46.224]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.224]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:46.224]                 }
[16:20:46.224]                 ...future.workdir <- getwd()
[16:20:46.224]             }
[16:20:46.224]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:46.224]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:46.224]         }
[16:20:46.224]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:46.224]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:46.224]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:46.224]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:46.224]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:46.224]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:46.224]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:46.224]             base::names(...future.oldOptions))
[16:20:46.224]     }
[16:20:46.224]     if (FALSE) {
[16:20:46.224]     }
[16:20:46.224]     else {
[16:20:46.224]         if (TRUE) {
[16:20:46.224]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:46.224]                 open = "w")
[16:20:46.224]         }
[16:20:46.224]         else {
[16:20:46.224]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:46.224]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:46.224]         }
[16:20:46.224]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:46.224]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:46.224]             base::sink(type = "output", split = FALSE)
[16:20:46.224]             base::close(...future.stdout)
[16:20:46.224]         }, add = TRUE)
[16:20:46.224]     }
[16:20:46.224]     ...future.frame <- base::sys.nframe()
[16:20:46.224]     ...future.conditions <- base::list()
[16:20:46.224]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:46.224]     if (FALSE) {
[16:20:46.224]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:46.224]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:46.224]     }
[16:20:46.224]     ...future.result <- base::tryCatch({
[16:20:46.224]         base::withCallingHandlers({
[16:20:46.224]             ...future.value <- base::withVisible(base::local({
[16:20:46.224]                 ...future.makeSendCondition <- base::local({
[16:20:46.224]                   sendCondition <- NULL
[16:20:46.224]                   function(frame = 1L) {
[16:20:46.224]                     if (is.function(sendCondition)) 
[16:20:46.224]                       return(sendCondition)
[16:20:46.224]                     ns <- getNamespace("parallel")
[16:20:46.224]                     if (exists("sendData", mode = "function", 
[16:20:46.224]                       envir = ns)) {
[16:20:46.224]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:46.224]                         envir = ns)
[16:20:46.224]                       envir <- sys.frame(frame)
[16:20:46.224]                       master <- NULL
[16:20:46.224]                       while (!identical(envir, .GlobalEnv) && 
[16:20:46.224]                         !identical(envir, emptyenv())) {
[16:20:46.224]                         if (exists("master", mode = "list", envir = envir, 
[16:20:46.224]                           inherits = FALSE)) {
[16:20:46.224]                           master <- get("master", mode = "list", 
[16:20:46.224]                             envir = envir, inherits = FALSE)
[16:20:46.224]                           if (inherits(master, c("SOCKnode", 
[16:20:46.224]                             "SOCK0node"))) {
[16:20:46.224]                             sendCondition <<- function(cond) {
[16:20:46.224]                               data <- list(type = "VALUE", value = cond, 
[16:20:46.224]                                 success = TRUE)
[16:20:46.224]                               parallel_sendData(master, data)
[16:20:46.224]                             }
[16:20:46.224]                             return(sendCondition)
[16:20:46.224]                           }
[16:20:46.224]                         }
[16:20:46.224]                         frame <- frame + 1L
[16:20:46.224]                         envir <- sys.frame(frame)
[16:20:46.224]                       }
[16:20:46.224]                     }
[16:20:46.224]                     sendCondition <<- function(cond) NULL
[16:20:46.224]                   }
[16:20:46.224]                 })
[16:20:46.224]                 withCallingHandlers({
[16:20:46.224]                   2
[16:20:46.224]                 }, immediateCondition = function(cond) {
[16:20:46.224]                   sendCondition <- ...future.makeSendCondition()
[16:20:46.224]                   sendCondition(cond)
[16:20:46.224]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.224]                   {
[16:20:46.224]                     inherits <- base::inherits
[16:20:46.224]                     invokeRestart <- base::invokeRestart
[16:20:46.224]                     is.null <- base::is.null
[16:20:46.224]                     muffled <- FALSE
[16:20:46.224]                     if (inherits(cond, "message")) {
[16:20:46.224]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:46.224]                       if (muffled) 
[16:20:46.224]                         invokeRestart("muffleMessage")
[16:20:46.224]                     }
[16:20:46.224]                     else if (inherits(cond, "warning")) {
[16:20:46.224]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:46.224]                       if (muffled) 
[16:20:46.224]                         invokeRestart("muffleWarning")
[16:20:46.224]                     }
[16:20:46.224]                     else if (inherits(cond, "condition")) {
[16:20:46.224]                       if (!is.null(pattern)) {
[16:20:46.224]                         computeRestarts <- base::computeRestarts
[16:20:46.224]                         grepl <- base::grepl
[16:20:46.224]                         restarts <- computeRestarts(cond)
[16:20:46.224]                         for (restart in restarts) {
[16:20:46.224]                           name <- restart$name
[16:20:46.224]                           if (is.null(name)) 
[16:20:46.224]                             next
[16:20:46.224]                           if (!grepl(pattern, name)) 
[16:20:46.224]                             next
[16:20:46.224]                           invokeRestart(restart)
[16:20:46.224]                           muffled <- TRUE
[16:20:46.224]                           break
[16:20:46.224]                         }
[16:20:46.224]                       }
[16:20:46.224]                     }
[16:20:46.224]                     invisible(muffled)
[16:20:46.224]                   }
[16:20:46.224]                   muffleCondition(cond)
[16:20:46.224]                 })
[16:20:46.224]             }))
[16:20:46.224]             future::FutureResult(value = ...future.value$value, 
[16:20:46.224]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.224]                   ...future.rng), globalenv = if (FALSE) 
[16:20:46.224]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:46.224]                     ...future.globalenv.names))
[16:20:46.224]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:46.224]         }, condition = base::local({
[16:20:46.224]             c <- base::c
[16:20:46.224]             inherits <- base::inherits
[16:20:46.224]             invokeRestart <- base::invokeRestart
[16:20:46.224]             length <- base::length
[16:20:46.224]             list <- base::list
[16:20:46.224]             seq.int <- base::seq.int
[16:20:46.224]             signalCondition <- base::signalCondition
[16:20:46.224]             sys.calls <- base::sys.calls
[16:20:46.224]             `[[` <- base::`[[`
[16:20:46.224]             `+` <- base::`+`
[16:20:46.224]             `<<-` <- base::`<<-`
[16:20:46.224]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:46.224]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:46.224]                   3L)]
[16:20:46.224]             }
[16:20:46.224]             function(cond) {
[16:20:46.224]                 is_error <- inherits(cond, "error")
[16:20:46.224]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:46.224]                   NULL)
[16:20:46.224]                 if (is_error) {
[16:20:46.224]                   sessionInformation <- function() {
[16:20:46.224]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:46.224]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:46.224]                       search = base::search(), system = base::Sys.info())
[16:20:46.224]                   }
[16:20:46.224]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.224]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:46.224]                     cond$call), session = sessionInformation(), 
[16:20:46.224]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:46.224]                   signalCondition(cond)
[16:20:46.224]                 }
[16:20:46.224]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:46.224]                 "immediateCondition"))) {
[16:20:46.224]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:46.224]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.224]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:46.224]                   if (TRUE && !signal) {
[16:20:46.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.224]                     {
[16:20:46.224]                       inherits <- base::inherits
[16:20:46.224]                       invokeRestart <- base::invokeRestart
[16:20:46.224]                       is.null <- base::is.null
[16:20:46.224]                       muffled <- FALSE
[16:20:46.224]                       if (inherits(cond, "message")) {
[16:20:46.224]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.224]                         if (muffled) 
[16:20:46.224]                           invokeRestart("muffleMessage")
[16:20:46.224]                       }
[16:20:46.224]                       else if (inherits(cond, "warning")) {
[16:20:46.224]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.224]                         if (muffled) 
[16:20:46.224]                           invokeRestart("muffleWarning")
[16:20:46.224]                       }
[16:20:46.224]                       else if (inherits(cond, "condition")) {
[16:20:46.224]                         if (!is.null(pattern)) {
[16:20:46.224]                           computeRestarts <- base::computeRestarts
[16:20:46.224]                           grepl <- base::grepl
[16:20:46.224]                           restarts <- computeRestarts(cond)
[16:20:46.224]                           for (restart in restarts) {
[16:20:46.224]                             name <- restart$name
[16:20:46.224]                             if (is.null(name)) 
[16:20:46.224]                               next
[16:20:46.224]                             if (!grepl(pattern, name)) 
[16:20:46.224]                               next
[16:20:46.224]                             invokeRestart(restart)
[16:20:46.224]                             muffled <- TRUE
[16:20:46.224]                             break
[16:20:46.224]                           }
[16:20:46.224]                         }
[16:20:46.224]                       }
[16:20:46.224]                       invisible(muffled)
[16:20:46.224]                     }
[16:20:46.224]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.224]                   }
[16:20:46.224]                 }
[16:20:46.224]                 else {
[16:20:46.224]                   if (TRUE) {
[16:20:46.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.224]                     {
[16:20:46.224]                       inherits <- base::inherits
[16:20:46.224]                       invokeRestart <- base::invokeRestart
[16:20:46.224]                       is.null <- base::is.null
[16:20:46.224]                       muffled <- FALSE
[16:20:46.224]                       if (inherits(cond, "message")) {
[16:20:46.224]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.224]                         if (muffled) 
[16:20:46.224]                           invokeRestart("muffleMessage")
[16:20:46.224]                       }
[16:20:46.224]                       else if (inherits(cond, "warning")) {
[16:20:46.224]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.224]                         if (muffled) 
[16:20:46.224]                           invokeRestart("muffleWarning")
[16:20:46.224]                       }
[16:20:46.224]                       else if (inherits(cond, "condition")) {
[16:20:46.224]                         if (!is.null(pattern)) {
[16:20:46.224]                           computeRestarts <- base::computeRestarts
[16:20:46.224]                           grepl <- base::grepl
[16:20:46.224]                           restarts <- computeRestarts(cond)
[16:20:46.224]                           for (restart in restarts) {
[16:20:46.224]                             name <- restart$name
[16:20:46.224]                             if (is.null(name)) 
[16:20:46.224]                               next
[16:20:46.224]                             if (!grepl(pattern, name)) 
[16:20:46.224]                               next
[16:20:46.224]                             invokeRestart(restart)
[16:20:46.224]                             muffled <- TRUE
[16:20:46.224]                             break
[16:20:46.224]                           }
[16:20:46.224]                         }
[16:20:46.224]                       }
[16:20:46.224]                       invisible(muffled)
[16:20:46.224]                     }
[16:20:46.224]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.224]                   }
[16:20:46.224]                 }
[16:20:46.224]             }
[16:20:46.224]         }))
[16:20:46.224]     }, error = function(ex) {
[16:20:46.224]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:46.224]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.224]                 ...future.rng), started = ...future.startTime, 
[16:20:46.224]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:46.224]             version = "1.8"), class = "FutureResult")
[16:20:46.224]     }, finally = {
[16:20:46.224]         if (!identical(...future.workdir, getwd())) 
[16:20:46.224]             setwd(...future.workdir)
[16:20:46.224]         {
[16:20:46.224]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:46.224]                 ...future.oldOptions$nwarnings <- NULL
[16:20:46.224]             }
[16:20:46.224]             base::options(...future.oldOptions)
[16:20:46.224]             if (.Platform$OS.type == "windows") {
[16:20:46.224]                 old_names <- names(...future.oldEnvVars)
[16:20:46.224]                 envs <- base::Sys.getenv()
[16:20:46.224]                 names <- names(envs)
[16:20:46.224]                 common <- intersect(names, old_names)
[16:20:46.224]                 added <- setdiff(names, old_names)
[16:20:46.224]                 removed <- setdiff(old_names, names)
[16:20:46.224]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:46.224]                   envs[common]]
[16:20:46.224]                 NAMES <- toupper(changed)
[16:20:46.224]                 args <- list()
[16:20:46.224]                 for (kk in seq_along(NAMES)) {
[16:20:46.224]                   name <- changed[[kk]]
[16:20:46.224]                   NAME <- NAMES[[kk]]
[16:20:46.224]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.224]                     next
[16:20:46.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.224]                 }
[16:20:46.224]                 NAMES <- toupper(added)
[16:20:46.224]                 for (kk in seq_along(NAMES)) {
[16:20:46.224]                   name <- added[[kk]]
[16:20:46.224]                   NAME <- NAMES[[kk]]
[16:20:46.224]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.224]                     next
[16:20:46.224]                   args[[name]] <- ""
[16:20:46.224]                 }
[16:20:46.224]                 NAMES <- toupper(removed)
[16:20:46.224]                 for (kk in seq_along(NAMES)) {
[16:20:46.224]                   name <- removed[[kk]]
[16:20:46.224]                   NAME <- NAMES[[kk]]
[16:20:46.224]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.224]                     next
[16:20:46.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.224]                 }
[16:20:46.224]                 if (length(args) > 0) 
[16:20:46.224]                   base::do.call(base::Sys.setenv, args = args)
[16:20:46.224]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:46.224]             }
[16:20:46.224]             else {
[16:20:46.224]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:46.224]             }
[16:20:46.224]             {
[16:20:46.224]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:46.224]                   0L) {
[16:20:46.224]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:46.224]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:46.224]                   base::options(opts)
[16:20:46.224]                 }
[16:20:46.224]                 {
[16:20:46.224]                   {
[16:20:46.224]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:46.224]                     NULL
[16:20:46.224]                   }
[16:20:46.224]                   options(future.plan = NULL)
[16:20:46.224]                   if (is.na(NA_character_)) 
[16:20:46.224]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.224]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:46.224]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:46.224]                     .init = FALSE)
[16:20:46.224]                 }
[16:20:46.224]             }
[16:20:46.224]         }
[16:20:46.224]     })
[16:20:46.224]     if (TRUE) {
[16:20:46.224]         base::sink(type = "output", split = FALSE)
[16:20:46.224]         if (TRUE) {
[16:20:46.224]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:46.224]         }
[16:20:46.224]         else {
[16:20:46.224]             ...future.result["stdout"] <- base::list(NULL)
[16:20:46.224]         }
[16:20:46.224]         base::close(...future.stdout)
[16:20:46.224]         ...future.stdout <- NULL
[16:20:46.224]     }
[16:20:46.224]     ...future.result$conditions <- ...future.conditions
[16:20:46.224]     ...future.result$finished <- base::Sys.time()
[16:20:46.224]     ...future.result
[16:20:46.224] }
[16:20:46.227] MultisessionFuture started
[16:20:46.227] - Launch lazy future ... done
[16:20:46.227] run() for ‘MultisessionFuture’ ... done
[16:20:46.227] getGlobalsAndPackages() ...
[16:20:46.227] Searching for globals...
[16:20:46.227] 
[16:20:46.228] Searching for globals ... DONE
[16:20:46.228] - globals: [0] <none>
[16:20:46.228] getGlobalsAndPackages() ... DONE
[16:20:46.228] run() for ‘Future’ ...
[16:20:46.228] - state: ‘created’
[16:20:46.228] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:46.242] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:46.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:46.242]   - Field: ‘node’
[16:20:46.242]   - Field: ‘label’
[16:20:46.242]   - Field: ‘local’
[16:20:46.242]   - Field: ‘owner’
[16:20:46.242]   - Field: ‘envir’
[16:20:46.242]   - Field: ‘workers’
[16:20:46.243]   - Field: ‘packages’
[16:20:46.243]   - Field: ‘gc’
[16:20:46.243]   - Field: ‘conditions’
[16:20:46.243]   - Field: ‘persistent’
[16:20:46.243]   - Field: ‘expr’
[16:20:46.243]   - Field: ‘uuid’
[16:20:46.243]   - Field: ‘seed’
[16:20:46.243]   - Field: ‘version’
[16:20:46.243]   - Field: ‘result’
[16:20:46.243]   - Field: ‘asynchronous’
[16:20:46.243]   - Field: ‘calls’
[16:20:46.244]   - Field: ‘globals’
[16:20:46.244]   - Field: ‘stdout’
[16:20:46.244]   - Field: ‘earlySignal’
[16:20:46.244]   - Field: ‘lazy’
[16:20:46.244]   - Field: ‘state’
[16:20:46.244] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:46.244] - Launch lazy future ...
[16:20:46.244] Packages needed by the future expression (n = 0): <none>
[16:20:46.245] Packages needed by future strategies (n = 0): <none>
[16:20:46.245] {
[16:20:46.245]     {
[16:20:46.245]         {
[16:20:46.245]             ...future.startTime <- base::Sys.time()
[16:20:46.245]             {
[16:20:46.245]                 {
[16:20:46.245]                   {
[16:20:46.245]                     {
[16:20:46.245]                       base::local({
[16:20:46.245]                         has_future <- base::requireNamespace("future", 
[16:20:46.245]                           quietly = TRUE)
[16:20:46.245]                         if (has_future) {
[16:20:46.245]                           ns <- base::getNamespace("future")
[16:20:46.245]                           version <- ns[[".package"]][["version"]]
[16:20:46.245]                           if (is.null(version)) 
[16:20:46.245]                             version <- utils::packageVersion("future")
[16:20:46.245]                         }
[16:20:46.245]                         else {
[16:20:46.245]                           version <- NULL
[16:20:46.245]                         }
[16:20:46.245]                         if (!has_future || version < "1.8.0") {
[16:20:46.245]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:46.245]                             "", base::R.version$version.string), 
[16:20:46.245]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:46.245]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:46.245]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:46.245]                               "release", "version")], collapse = " "), 
[16:20:46.245]                             hostname = base::Sys.info()[["nodename"]])
[16:20:46.245]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:46.245]                             info)
[16:20:46.245]                           info <- base::paste(info, collapse = "; ")
[16:20:46.245]                           if (!has_future) {
[16:20:46.245]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:46.245]                               info)
[16:20:46.245]                           }
[16:20:46.245]                           else {
[16:20:46.245]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:46.245]                               info, version)
[16:20:46.245]                           }
[16:20:46.245]                           base::stop(msg)
[16:20:46.245]                         }
[16:20:46.245]                       })
[16:20:46.245]                     }
[16:20:46.245]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:46.245]                     base::options(mc.cores = 1L)
[16:20:46.245]                   }
[16:20:46.245]                   ...future.strategy.old <- future::plan("list")
[16:20:46.245]                   options(future.plan = NULL)
[16:20:46.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:46.245]                 }
[16:20:46.245]                 ...future.workdir <- getwd()
[16:20:46.245]             }
[16:20:46.245]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:46.245]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:46.245]         }
[16:20:46.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:46.245]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:46.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:46.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:46.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:46.245]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:46.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:46.245]             base::names(...future.oldOptions))
[16:20:46.245]     }
[16:20:46.245]     if (FALSE) {
[16:20:46.245]     }
[16:20:46.245]     else {
[16:20:46.245]         if (TRUE) {
[16:20:46.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:46.245]                 open = "w")
[16:20:46.245]         }
[16:20:46.245]         else {
[16:20:46.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:46.245]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:46.245]         }
[16:20:46.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:46.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:46.245]             base::sink(type = "output", split = FALSE)
[16:20:46.245]             base::close(...future.stdout)
[16:20:46.245]         }, add = TRUE)
[16:20:46.245]     }
[16:20:46.245]     ...future.frame <- base::sys.nframe()
[16:20:46.245]     ...future.conditions <- base::list()
[16:20:46.245]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:46.245]     if (FALSE) {
[16:20:46.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:46.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:46.245]     }
[16:20:46.245]     ...future.result <- base::tryCatch({
[16:20:46.245]         base::withCallingHandlers({
[16:20:46.245]             ...future.value <- base::withVisible(base::local({
[16:20:46.245]                 ...future.makeSendCondition <- base::local({
[16:20:46.245]                   sendCondition <- NULL
[16:20:46.245]                   function(frame = 1L) {
[16:20:46.245]                     if (is.function(sendCondition)) 
[16:20:46.245]                       return(sendCondition)
[16:20:46.245]                     ns <- getNamespace("parallel")
[16:20:46.245]                     if (exists("sendData", mode = "function", 
[16:20:46.245]                       envir = ns)) {
[16:20:46.245]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:46.245]                         envir = ns)
[16:20:46.245]                       envir <- sys.frame(frame)
[16:20:46.245]                       master <- NULL
[16:20:46.245]                       while (!identical(envir, .GlobalEnv) && 
[16:20:46.245]                         !identical(envir, emptyenv())) {
[16:20:46.245]                         if (exists("master", mode = "list", envir = envir, 
[16:20:46.245]                           inherits = FALSE)) {
[16:20:46.245]                           master <- get("master", mode = "list", 
[16:20:46.245]                             envir = envir, inherits = FALSE)
[16:20:46.245]                           if (inherits(master, c("SOCKnode", 
[16:20:46.245]                             "SOCK0node"))) {
[16:20:46.245]                             sendCondition <<- function(cond) {
[16:20:46.245]                               data <- list(type = "VALUE", value = cond, 
[16:20:46.245]                                 success = TRUE)
[16:20:46.245]                               parallel_sendData(master, data)
[16:20:46.245]                             }
[16:20:46.245]                             return(sendCondition)
[16:20:46.245]                           }
[16:20:46.245]                         }
[16:20:46.245]                         frame <- frame + 1L
[16:20:46.245]                         envir <- sys.frame(frame)
[16:20:46.245]                       }
[16:20:46.245]                     }
[16:20:46.245]                     sendCondition <<- function(cond) NULL
[16:20:46.245]                   }
[16:20:46.245]                 })
[16:20:46.245]                 withCallingHandlers({
[16:20:46.245]                   NULL
[16:20:46.245]                 }, immediateCondition = function(cond) {
[16:20:46.245]                   sendCondition <- ...future.makeSendCondition()
[16:20:46.245]                   sendCondition(cond)
[16:20:46.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.245]                   {
[16:20:46.245]                     inherits <- base::inherits
[16:20:46.245]                     invokeRestart <- base::invokeRestart
[16:20:46.245]                     is.null <- base::is.null
[16:20:46.245]                     muffled <- FALSE
[16:20:46.245]                     if (inherits(cond, "message")) {
[16:20:46.245]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:46.245]                       if (muffled) 
[16:20:46.245]                         invokeRestart("muffleMessage")
[16:20:46.245]                     }
[16:20:46.245]                     else if (inherits(cond, "warning")) {
[16:20:46.245]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:46.245]                       if (muffled) 
[16:20:46.245]                         invokeRestart("muffleWarning")
[16:20:46.245]                     }
[16:20:46.245]                     else if (inherits(cond, "condition")) {
[16:20:46.245]                       if (!is.null(pattern)) {
[16:20:46.245]                         computeRestarts <- base::computeRestarts
[16:20:46.245]                         grepl <- base::grepl
[16:20:46.245]                         restarts <- computeRestarts(cond)
[16:20:46.245]                         for (restart in restarts) {
[16:20:46.245]                           name <- restart$name
[16:20:46.245]                           if (is.null(name)) 
[16:20:46.245]                             next
[16:20:46.245]                           if (!grepl(pattern, name)) 
[16:20:46.245]                             next
[16:20:46.245]                           invokeRestart(restart)
[16:20:46.245]                           muffled <- TRUE
[16:20:46.245]                           break
[16:20:46.245]                         }
[16:20:46.245]                       }
[16:20:46.245]                     }
[16:20:46.245]                     invisible(muffled)
[16:20:46.245]                   }
[16:20:46.245]                   muffleCondition(cond)
[16:20:46.245]                 })
[16:20:46.245]             }))
[16:20:46.245]             future::FutureResult(value = ...future.value$value, 
[16:20:46.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.245]                   ...future.rng), globalenv = if (FALSE) 
[16:20:46.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:46.245]                     ...future.globalenv.names))
[16:20:46.245]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:46.245]         }, condition = base::local({
[16:20:46.245]             c <- base::c
[16:20:46.245]             inherits <- base::inherits
[16:20:46.245]             invokeRestart <- base::invokeRestart
[16:20:46.245]             length <- base::length
[16:20:46.245]             list <- base::list
[16:20:46.245]             seq.int <- base::seq.int
[16:20:46.245]             signalCondition <- base::signalCondition
[16:20:46.245]             sys.calls <- base::sys.calls
[16:20:46.245]             `[[` <- base::`[[`
[16:20:46.245]             `+` <- base::`+`
[16:20:46.245]             `<<-` <- base::`<<-`
[16:20:46.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:46.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:46.245]                   3L)]
[16:20:46.245]             }
[16:20:46.245]             function(cond) {
[16:20:46.245]                 is_error <- inherits(cond, "error")
[16:20:46.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:46.245]                   NULL)
[16:20:46.245]                 if (is_error) {
[16:20:46.245]                   sessionInformation <- function() {
[16:20:46.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:46.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:46.245]                       search = base::search(), system = base::Sys.info())
[16:20:46.245]                   }
[16:20:46.245]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:46.245]                     cond$call), session = sessionInformation(), 
[16:20:46.245]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:46.245]                   signalCondition(cond)
[16:20:46.245]                 }
[16:20:46.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:46.245]                 "immediateCondition"))) {
[16:20:46.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:46.245]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:46.245]                   if (TRUE && !signal) {
[16:20:46.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.245]                     {
[16:20:46.245]                       inherits <- base::inherits
[16:20:46.245]                       invokeRestart <- base::invokeRestart
[16:20:46.245]                       is.null <- base::is.null
[16:20:46.245]                       muffled <- FALSE
[16:20:46.245]                       if (inherits(cond, "message")) {
[16:20:46.245]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.245]                         if (muffled) 
[16:20:46.245]                           invokeRestart("muffleMessage")
[16:20:46.245]                       }
[16:20:46.245]                       else if (inherits(cond, "warning")) {
[16:20:46.245]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.245]                         if (muffled) 
[16:20:46.245]                           invokeRestart("muffleWarning")
[16:20:46.245]                       }
[16:20:46.245]                       else if (inherits(cond, "condition")) {
[16:20:46.245]                         if (!is.null(pattern)) {
[16:20:46.245]                           computeRestarts <- base::computeRestarts
[16:20:46.245]                           grepl <- base::grepl
[16:20:46.245]                           restarts <- computeRestarts(cond)
[16:20:46.245]                           for (restart in restarts) {
[16:20:46.245]                             name <- restart$name
[16:20:46.245]                             if (is.null(name)) 
[16:20:46.245]                               next
[16:20:46.245]                             if (!grepl(pattern, name)) 
[16:20:46.245]                               next
[16:20:46.245]                             invokeRestart(restart)
[16:20:46.245]                             muffled <- TRUE
[16:20:46.245]                             break
[16:20:46.245]                           }
[16:20:46.245]                         }
[16:20:46.245]                       }
[16:20:46.245]                       invisible(muffled)
[16:20:46.245]                     }
[16:20:46.245]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.245]                   }
[16:20:46.245]                 }
[16:20:46.245]                 else {
[16:20:46.245]                   if (TRUE) {
[16:20:46.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.245]                     {
[16:20:46.245]                       inherits <- base::inherits
[16:20:46.245]                       invokeRestart <- base::invokeRestart
[16:20:46.245]                       is.null <- base::is.null
[16:20:46.245]                       muffled <- FALSE
[16:20:46.245]                       if (inherits(cond, "message")) {
[16:20:46.245]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.245]                         if (muffled) 
[16:20:46.245]                           invokeRestart("muffleMessage")
[16:20:46.245]                       }
[16:20:46.245]                       else if (inherits(cond, "warning")) {
[16:20:46.245]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.245]                         if (muffled) 
[16:20:46.245]                           invokeRestart("muffleWarning")
[16:20:46.245]                       }
[16:20:46.245]                       else if (inherits(cond, "condition")) {
[16:20:46.245]                         if (!is.null(pattern)) {
[16:20:46.245]                           computeRestarts <- base::computeRestarts
[16:20:46.245]                           grepl <- base::grepl
[16:20:46.245]                           restarts <- computeRestarts(cond)
[16:20:46.245]                           for (restart in restarts) {
[16:20:46.245]                             name <- restart$name
[16:20:46.245]                             if (is.null(name)) 
[16:20:46.245]                               next
[16:20:46.245]                             if (!grepl(pattern, name)) 
[16:20:46.245]                               next
[16:20:46.245]                             invokeRestart(restart)
[16:20:46.245]                             muffled <- TRUE
[16:20:46.245]                             break
[16:20:46.245]                           }
[16:20:46.245]                         }
[16:20:46.245]                       }
[16:20:46.245]                       invisible(muffled)
[16:20:46.245]                     }
[16:20:46.245]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.245]                   }
[16:20:46.245]                 }
[16:20:46.245]             }
[16:20:46.245]         }))
[16:20:46.245]     }, error = function(ex) {
[16:20:46.245]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:46.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.245]                 ...future.rng), started = ...future.startTime, 
[16:20:46.245]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:46.245]             version = "1.8"), class = "FutureResult")
[16:20:46.245]     }, finally = {
[16:20:46.245]         if (!identical(...future.workdir, getwd())) 
[16:20:46.245]             setwd(...future.workdir)
[16:20:46.245]         {
[16:20:46.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:46.245]                 ...future.oldOptions$nwarnings <- NULL
[16:20:46.245]             }
[16:20:46.245]             base::options(...future.oldOptions)
[16:20:46.245]             if (.Platform$OS.type == "windows") {
[16:20:46.245]                 old_names <- names(...future.oldEnvVars)
[16:20:46.245]                 envs <- base::Sys.getenv()
[16:20:46.245]                 names <- names(envs)
[16:20:46.245]                 common <- intersect(names, old_names)
[16:20:46.245]                 added <- setdiff(names, old_names)
[16:20:46.245]                 removed <- setdiff(old_names, names)
[16:20:46.245]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:46.245]                   envs[common]]
[16:20:46.245]                 NAMES <- toupper(changed)
[16:20:46.245]                 args <- list()
[16:20:46.245]                 for (kk in seq_along(NAMES)) {
[16:20:46.245]                   name <- changed[[kk]]
[16:20:46.245]                   NAME <- NAMES[[kk]]
[16:20:46.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.245]                     next
[16:20:46.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.245]                 }
[16:20:46.245]                 NAMES <- toupper(added)
[16:20:46.245]                 for (kk in seq_along(NAMES)) {
[16:20:46.245]                   name <- added[[kk]]
[16:20:46.245]                   NAME <- NAMES[[kk]]
[16:20:46.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.245]                     next
[16:20:46.245]                   args[[name]] <- ""
[16:20:46.245]                 }
[16:20:46.245]                 NAMES <- toupper(removed)
[16:20:46.245]                 for (kk in seq_along(NAMES)) {
[16:20:46.245]                   name <- removed[[kk]]
[16:20:46.245]                   NAME <- NAMES[[kk]]
[16:20:46.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.245]                     next
[16:20:46.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.245]                 }
[16:20:46.245]                 if (length(args) > 0) 
[16:20:46.245]                   base::do.call(base::Sys.setenv, args = args)
[16:20:46.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:46.245]             }
[16:20:46.245]             else {
[16:20:46.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:46.245]             }
[16:20:46.245]             {
[16:20:46.245]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:46.245]                   0L) {
[16:20:46.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:46.245]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:46.245]                   base::options(opts)
[16:20:46.245]                 }
[16:20:46.245]                 {
[16:20:46.245]                   {
[16:20:46.245]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:46.245]                     NULL
[16:20:46.245]                   }
[16:20:46.245]                   options(future.plan = NULL)
[16:20:46.245]                   if (is.na(NA_character_)) 
[16:20:46.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:46.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:46.245]                     .init = FALSE)
[16:20:46.245]                 }
[16:20:46.245]             }
[16:20:46.245]         }
[16:20:46.245]     })
[16:20:46.245]     if (TRUE) {
[16:20:46.245]         base::sink(type = "output", split = FALSE)
[16:20:46.245]         if (TRUE) {
[16:20:46.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:46.245]         }
[16:20:46.245]         else {
[16:20:46.245]             ...future.result["stdout"] <- base::list(NULL)
[16:20:46.245]         }
[16:20:46.245]         base::close(...future.stdout)
[16:20:46.245]         ...future.stdout <- NULL
[16:20:46.245]     }
[16:20:46.245]     ...future.result$conditions <- ...future.conditions
[16:20:46.245]     ...future.result$finished <- base::Sys.time()
[16:20:46.245]     ...future.result
[16:20:46.245] }
[16:20:46.248] MultisessionFuture started
[16:20:46.248] - Launch lazy future ... done
[16:20:46.248] run() for ‘MultisessionFuture’ ... done
[16:20:46.249] getGlobalsAndPackages() ...
[16:20:46.249] Searching for globals...
[16:20:46.249] - globals found: [1] ‘{’
[16:20:46.249] Searching for globals ... DONE
[16:20:46.250] Resolving globals: FALSE
[16:20:46.250] 
[16:20:46.250] 
[16:20:46.250] getGlobalsAndPackages() ... DONE
[16:20:46.250] run() for ‘Future’ ...
[16:20:46.250] - state: ‘created’
[16:20:46.251] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:46.265] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:46.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:46.265]   - Field: ‘node’
[16:20:46.265]   - Field: ‘label’
[16:20:46.265]   - Field: ‘local’
[16:20:46.265]   - Field: ‘owner’
[16:20:46.265]   - Field: ‘envir’
[16:20:46.265]   - Field: ‘workers’
[16:20:46.265]   - Field: ‘packages’
[16:20:46.266]   - Field: ‘gc’
[16:20:46.266]   - Field: ‘conditions’
[16:20:46.266]   - Field: ‘persistent’
[16:20:46.266]   - Field: ‘expr’
[16:20:46.266]   - Field: ‘uuid’
[16:20:46.266]   - Field: ‘seed’
[16:20:46.266]   - Field: ‘version’
[16:20:46.266]   - Field: ‘result’
[16:20:46.266]   - Field: ‘asynchronous’
[16:20:46.266]   - Field: ‘calls’
[16:20:46.266]   - Field: ‘globals’
[16:20:46.267]   - Field: ‘stdout’
[16:20:46.267]   - Field: ‘earlySignal’
[16:20:46.267]   - Field: ‘lazy’
[16:20:46.267]   - Field: ‘state’
[16:20:46.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:46.267] - Launch lazy future ...
[16:20:46.267] Packages needed by the future expression (n = 0): <none>
[16:20:46.267] Packages needed by future strategies (n = 0): <none>
[16:20:46.268] {
[16:20:46.268]     {
[16:20:46.268]         {
[16:20:46.268]             ...future.startTime <- base::Sys.time()
[16:20:46.268]             {
[16:20:46.268]                 {
[16:20:46.268]                   {
[16:20:46.268]                     {
[16:20:46.268]                       base::local({
[16:20:46.268]                         has_future <- base::requireNamespace("future", 
[16:20:46.268]                           quietly = TRUE)
[16:20:46.268]                         if (has_future) {
[16:20:46.268]                           ns <- base::getNamespace("future")
[16:20:46.268]                           version <- ns[[".package"]][["version"]]
[16:20:46.268]                           if (is.null(version)) 
[16:20:46.268]                             version <- utils::packageVersion("future")
[16:20:46.268]                         }
[16:20:46.268]                         else {
[16:20:46.268]                           version <- NULL
[16:20:46.268]                         }
[16:20:46.268]                         if (!has_future || version < "1.8.0") {
[16:20:46.268]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:46.268]                             "", base::R.version$version.string), 
[16:20:46.268]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:46.268]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:46.268]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:46.268]                               "release", "version")], collapse = " "), 
[16:20:46.268]                             hostname = base::Sys.info()[["nodename"]])
[16:20:46.268]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:46.268]                             info)
[16:20:46.268]                           info <- base::paste(info, collapse = "; ")
[16:20:46.268]                           if (!has_future) {
[16:20:46.268]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:46.268]                               info)
[16:20:46.268]                           }
[16:20:46.268]                           else {
[16:20:46.268]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:46.268]                               info, version)
[16:20:46.268]                           }
[16:20:46.268]                           base::stop(msg)
[16:20:46.268]                         }
[16:20:46.268]                       })
[16:20:46.268]                     }
[16:20:46.268]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:46.268]                     base::options(mc.cores = 1L)
[16:20:46.268]                   }
[16:20:46.268]                   ...future.strategy.old <- future::plan("list")
[16:20:46.268]                   options(future.plan = NULL)
[16:20:46.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:46.268]                 }
[16:20:46.268]                 ...future.workdir <- getwd()
[16:20:46.268]             }
[16:20:46.268]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:46.268]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:46.268]         }
[16:20:46.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:46.268]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:46.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:46.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:46.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:46.268]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:46.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:46.268]             base::names(...future.oldOptions))
[16:20:46.268]     }
[16:20:46.268]     if (FALSE) {
[16:20:46.268]     }
[16:20:46.268]     else {
[16:20:46.268]         if (TRUE) {
[16:20:46.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:46.268]                 open = "w")
[16:20:46.268]         }
[16:20:46.268]         else {
[16:20:46.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:46.268]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:46.268]         }
[16:20:46.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:46.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:46.268]             base::sink(type = "output", split = FALSE)
[16:20:46.268]             base::close(...future.stdout)
[16:20:46.268]         }, add = TRUE)
[16:20:46.268]     }
[16:20:46.268]     ...future.frame <- base::sys.nframe()
[16:20:46.268]     ...future.conditions <- base::list()
[16:20:46.268]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:46.268]     if (FALSE) {
[16:20:46.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:46.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:46.268]     }
[16:20:46.268]     ...future.result <- base::tryCatch({
[16:20:46.268]         base::withCallingHandlers({
[16:20:46.268]             ...future.value <- base::withVisible(base::local({
[16:20:46.268]                 ...future.makeSendCondition <- base::local({
[16:20:46.268]                   sendCondition <- NULL
[16:20:46.268]                   function(frame = 1L) {
[16:20:46.268]                     if (is.function(sendCondition)) 
[16:20:46.268]                       return(sendCondition)
[16:20:46.268]                     ns <- getNamespace("parallel")
[16:20:46.268]                     if (exists("sendData", mode = "function", 
[16:20:46.268]                       envir = ns)) {
[16:20:46.268]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:46.268]                         envir = ns)
[16:20:46.268]                       envir <- sys.frame(frame)
[16:20:46.268]                       master <- NULL
[16:20:46.268]                       while (!identical(envir, .GlobalEnv) && 
[16:20:46.268]                         !identical(envir, emptyenv())) {
[16:20:46.268]                         if (exists("master", mode = "list", envir = envir, 
[16:20:46.268]                           inherits = FALSE)) {
[16:20:46.268]                           master <- get("master", mode = "list", 
[16:20:46.268]                             envir = envir, inherits = FALSE)
[16:20:46.268]                           if (inherits(master, c("SOCKnode", 
[16:20:46.268]                             "SOCK0node"))) {
[16:20:46.268]                             sendCondition <<- function(cond) {
[16:20:46.268]                               data <- list(type = "VALUE", value = cond, 
[16:20:46.268]                                 success = TRUE)
[16:20:46.268]                               parallel_sendData(master, data)
[16:20:46.268]                             }
[16:20:46.268]                             return(sendCondition)
[16:20:46.268]                           }
[16:20:46.268]                         }
[16:20:46.268]                         frame <- frame + 1L
[16:20:46.268]                         envir <- sys.frame(frame)
[16:20:46.268]                       }
[16:20:46.268]                     }
[16:20:46.268]                     sendCondition <<- function(cond) NULL
[16:20:46.268]                   }
[16:20:46.268]                 })
[16:20:46.268]                 withCallingHandlers({
[16:20:46.268]                   {
[16:20:46.268]                     4
[16:20:46.268]                   }
[16:20:46.268]                 }, immediateCondition = function(cond) {
[16:20:46.268]                   sendCondition <- ...future.makeSendCondition()
[16:20:46.268]                   sendCondition(cond)
[16:20:46.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.268]                   {
[16:20:46.268]                     inherits <- base::inherits
[16:20:46.268]                     invokeRestart <- base::invokeRestart
[16:20:46.268]                     is.null <- base::is.null
[16:20:46.268]                     muffled <- FALSE
[16:20:46.268]                     if (inherits(cond, "message")) {
[16:20:46.268]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:46.268]                       if (muffled) 
[16:20:46.268]                         invokeRestart("muffleMessage")
[16:20:46.268]                     }
[16:20:46.268]                     else if (inherits(cond, "warning")) {
[16:20:46.268]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:46.268]                       if (muffled) 
[16:20:46.268]                         invokeRestart("muffleWarning")
[16:20:46.268]                     }
[16:20:46.268]                     else if (inherits(cond, "condition")) {
[16:20:46.268]                       if (!is.null(pattern)) {
[16:20:46.268]                         computeRestarts <- base::computeRestarts
[16:20:46.268]                         grepl <- base::grepl
[16:20:46.268]                         restarts <- computeRestarts(cond)
[16:20:46.268]                         for (restart in restarts) {
[16:20:46.268]                           name <- restart$name
[16:20:46.268]                           if (is.null(name)) 
[16:20:46.268]                             next
[16:20:46.268]                           if (!grepl(pattern, name)) 
[16:20:46.268]                             next
[16:20:46.268]                           invokeRestart(restart)
[16:20:46.268]                           muffled <- TRUE
[16:20:46.268]                           break
[16:20:46.268]                         }
[16:20:46.268]                       }
[16:20:46.268]                     }
[16:20:46.268]                     invisible(muffled)
[16:20:46.268]                   }
[16:20:46.268]                   muffleCondition(cond)
[16:20:46.268]                 })
[16:20:46.268]             }))
[16:20:46.268]             future::FutureResult(value = ...future.value$value, 
[16:20:46.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.268]                   ...future.rng), globalenv = if (FALSE) 
[16:20:46.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:46.268]                     ...future.globalenv.names))
[16:20:46.268]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:46.268]         }, condition = base::local({
[16:20:46.268]             c <- base::c
[16:20:46.268]             inherits <- base::inherits
[16:20:46.268]             invokeRestart <- base::invokeRestart
[16:20:46.268]             length <- base::length
[16:20:46.268]             list <- base::list
[16:20:46.268]             seq.int <- base::seq.int
[16:20:46.268]             signalCondition <- base::signalCondition
[16:20:46.268]             sys.calls <- base::sys.calls
[16:20:46.268]             `[[` <- base::`[[`
[16:20:46.268]             `+` <- base::`+`
[16:20:46.268]             `<<-` <- base::`<<-`
[16:20:46.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:46.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:46.268]                   3L)]
[16:20:46.268]             }
[16:20:46.268]             function(cond) {
[16:20:46.268]                 is_error <- inherits(cond, "error")
[16:20:46.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:46.268]                   NULL)
[16:20:46.268]                 if (is_error) {
[16:20:46.268]                   sessionInformation <- function() {
[16:20:46.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:46.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:46.268]                       search = base::search(), system = base::Sys.info())
[16:20:46.268]                   }
[16:20:46.268]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:46.268]                     cond$call), session = sessionInformation(), 
[16:20:46.268]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:46.268]                   signalCondition(cond)
[16:20:46.268]                 }
[16:20:46.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:46.268]                 "immediateCondition"))) {
[16:20:46.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:46.268]                   ...future.conditions[[length(...future.conditions) + 
[16:20:46.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:46.268]                   if (TRUE && !signal) {
[16:20:46.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.268]                     {
[16:20:46.268]                       inherits <- base::inherits
[16:20:46.268]                       invokeRestart <- base::invokeRestart
[16:20:46.268]                       is.null <- base::is.null
[16:20:46.268]                       muffled <- FALSE
[16:20:46.268]                       if (inherits(cond, "message")) {
[16:20:46.268]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.268]                         if (muffled) 
[16:20:46.268]                           invokeRestart("muffleMessage")
[16:20:46.268]                       }
[16:20:46.268]                       else if (inherits(cond, "warning")) {
[16:20:46.268]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.268]                         if (muffled) 
[16:20:46.268]                           invokeRestart("muffleWarning")
[16:20:46.268]                       }
[16:20:46.268]                       else if (inherits(cond, "condition")) {
[16:20:46.268]                         if (!is.null(pattern)) {
[16:20:46.268]                           computeRestarts <- base::computeRestarts
[16:20:46.268]                           grepl <- base::grepl
[16:20:46.268]                           restarts <- computeRestarts(cond)
[16:20:46.268]                           for (restart in restarts) {
[16:20:46.268]                             name <- restart$name
[16:20:46.268]                             if (is.null(name)) 
[16:20:46.268]                               next
[16:20:46.268]                             if (!grepl(pattern, name)) 
[16:20:46.268]                               next
[16:20:46.268]                             invokeRestart(restart)
[16:20:46.268]                             muffled <- TRUE
[16:20:46.268]                             break
[16:20:46.268]                           }
[16:20:46.268]                         }
[16:20:46.268]                       }
[16:20:46.268]                       invisible(muffled)
[16:20:46.268]                     }
[16:20:46.268]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.268]                   }
[16:20:46.268]                 }
[16:20:46.268]                 else {
[16:20:46.268]                   if (TRUE) {
[16:20:46.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:46.268]                     {
[16:20:46.268]                       inherits <- base::inherits
[16:20:46.268]                       invokeRestart <- base::invokeRestart
[16:20:46.268]                       is.null <- base::is.null
[16:20:46.268]                       muffled <- FALSE
[16:20:46.268]                       if (inherits(cond, "message")) {
[16:20:46.268]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:46.268]                         if (muffled) 
[16:20:46.268]                           invokeRestart("muffleMessage")
[16:20:46.268]                       }
[16:20:46.268]                       else if (inherits(cond, "warning")) {
[16:20:46.268]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:46.268]                         if (muffled) 
[16:20:46.268]                           invokeRestart("muffleWarning")
[16:20:46.268]                       }
[16:20:46.268]                       else if (inherits(cond, "condition")) {
[16:20:46.268]                         if (!is.null(pattern)) {
[16:20:46.268]                           computeRestarts <- base::computeRestarts
[16:20:46.268]                           grepl <- base::grepl
[16:20:46.268]                           restarts <- computeRestarts(cond)
[16:20:46.268]                           for (restart in restarts) {
[16:20:46.268]                             name <- restart$name
[16:20:46.268]                             if (is.null(name)) 
[16:20:46.268]                               next
[16:20:46.268]                             if (!grepl(pattern, name)) 
[16:20:46.268]                               next
[16:20:46.268]                             invokeRestart(restart)
[16:20:46.268]                             muffled <- TRUE
[16:20:46.268]                             break
[16:20:46.268]                           }
[16:20:46.268]                         }
[16:20:46.268]                       }
[16:20:46.268]                       invisible(muffled)
[16:20:46.268]                     }
[16:20:46.268]                     muffleCondition(cond, pattern = "^muffle")
[16:20:46.268]                   }
[16:20:46.268]                 }
[16:20:46.268]             }
[16:20:46.268]         }))
[16:20:46.268]     }, error = function(ex) {
[16:20:46.268]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:46.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:46.268]                 ...future.rng), started = ...future.startTime, 
[16:20:46.268]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:46.268]             version = "1.8"), class = "FutureResult")
[16:20:46.268]     }, finally = {
[16:20:46.268]         if (!identical(...future.workdir, getwd())) 
[16:20:46.268]             setwd(...future.workdir)
[16:20:46.268]         {
[16:20:46.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:46.268]                 ...future.oldOptions$nwarnings <- NULL
[16:20:46.268]             }
[16:20:46.268]             base::options(...future.oldOptions)
[16:20:46.268]             if (.Platform$OS.type == "windows") {
[16:20:46.268]                 old_names <- names(...future.oldEnvVars)
[16:20:46.268]                 envs <- base::Sys.getenv()
[16:20:46.268]                 names <- names(envs)
[16:20:46.268]                 common <- intersect(names, old_names)
[16:20:46.268]                 added <- setdiff(names, old_names)
[16:20:46.268]                 removed <- setdiff(old_names, names)
[16:20:46.268]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:46.268]                   envs[common]]
[16:20:46.268]                 NAMES <- toupper(changed)
[16:20:46.268]                 args <- list()
[16:20:46.268]                 for (kk in seq_along(NAMES)) {
[16:20:46.268]                   name <- changed[[kk]]
[16:20:46.268]                   NAME <- NAMES[[kk]]
[16:20:46.268]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.268]                     next
[16:20:46.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.268]                 }
[16:20:46.268]                 NAMES <- toupper(added)
[16:20:46.268]                 for (kk in seq_along(NAMES)) {
[16:20:46.268]                   name <- added[[kk]]
[16:20:46.268]                   NAME <- NAMES[[kk]]
[16:20:46.268]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.268]                     next
[16:20:46.268]                   args[[name]] <- ""
[16:20:46.268]                 }
[16:20:46.268]                 NAMES <- toupper(removed)
[16:20:46.268]                 for (kk in seq_along(NAMES)) {
[16:20:46.268]                   name <- removed[[kk]]
[16:20:46.268]                   NAME <- NAMES[[kk]]
[16:20:46.268]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:46.268]                     next
[16:20:46.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:46.268]                 }
[16:20:46.268]                 if (length(args) > 0) 
[16:20:46.268]                   base::do.call(base::Sys.setenv, args = args)
[16:20:46.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:46.268]             }
[16:20:46.268]             else {
[16:20:46.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:46.268]             }
[16:20:46.268]             {
[16:20:46.268]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:46.268]                   0L) {
[16:20:46.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:46.268]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:46.268]                   base::options(opts)
[16:20:46.268]                 }
[16:20:46.268]                 {
[16:20:46.268]                   {
[16:20:46.268]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:46.268]                     NULL
[16:20:46.268]                   }
[16:20:46.268]                   options(future.plan = NULL)
[16:20:46.268]                   if (is.na(NA_character_)) 
[16:20:46.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:46.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:46.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:46.268]                     .init = FALSE)
[16:20:46.268]                 }
[16:20:46.268]             }
[16:20:46.268]         }
[16:20:46.268]     })
[16:20:46.268]     if (TRUE) {
[16:20:46.268]         base::sink(type = "output", split = FALSE)
[16:20:46.268]         if (TRUE) {
[16:20:46.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:46.268]         }
[16:20:46.268]         else {
[16:20:46.268]             ...future.result["stdout"] <- base::list(NULL)
[16:20:46.268]         }
[16:20:46.268]         base::close(...future.stdout)
[16:20:46.268]         ...future.stdout <- NULL
[16:20:46.268]     }
[16:20:46.268]     ...future.result$conditions <- ...future.conditions
[16:20:46.268]     ...future.result$finished <- base::Sys.time()
[16:20:46.268]     ...future.result
[16:20:46.268] }
[16:20:46.270] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:46.281] receiveMessageFromWorker() for ClusterFuture ...
[16:20:46.281] - Validating connection of MultisessionFuture
[16:20:46.281] - received message: FutureResult
[16:20:46.281] - Received FutureResult
[16:20:46.281] - Erased future from FutureRegistry
[16:20:46.282] result() for ClusterFuture ...
[16:20:46.282] - result already collected: FutureResult
[16:20:46.282] result() for ClusterFuture ... done
[16:20:46.282] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:46.282] result() for ClusterFuture ...
[16:20:46.282] - result already collected: FutureResult
[16:20:46.282] result() for ClusterFuture ... done
[16:20:46.282] result() for ClusterFuture ...
[16:20:46.282] - result already collected: FutureResult
[16:20:46.282] result() for ClusterFuture ... done
[16:20:46.283] MultisessionFuture started
[16:20:46.283] - Launch lazy future ... done
[16:20:46.284] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55ed0aa77ca8> 
Classes 'listenv', 'environment' <environment: 0x55ed0db860a0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:20:46.288] receiveMessageFromWorker() for ClusterFuture ...
[16:20:46.288] - Validating connection of MultisessionFuture
[16:20:46.288] - received message: FutureResult
[16:20:46.289] - Received FutureResult
[16:20:46.289] - Erased future from FutureRegistry
[16:20:46.289] result() for ClusterFuture ...
[16:20:46.289] - result already collected: FutureResult
[16:20:46.289] result() for ClusterFuture ... done
[16:20:46.289] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:46.289] receiveMessageFromWorker() for ClusterFuture ...
[16:20:46.290] - Validating connection of MultisessionFuture
[16:20:46.290] - received message: FutureResult
[16:20:46.290] - Received FutureResult
[16:20:46.290] - Erased future from FutureRegistry
[16:20:46.290] result() for ClusterFuture ...
[16:20:46.290] - result already collected: FutureResult
[16:20:46.290] result() for ClusterFuture ... done
[16:20:46.290] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:20:46.293] resolve() on list environment ...
[16:20:46.293]  recursive: 0
[16:20:46.294]  length: 6
[16:20:46.294]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:20:46.294] signalConditionsASAP(numeric, pos=1) ...
[16:20:46.294] - nx: 6
[16:20:46.294] - relay: TRUE
[16:20:46.294] - stdout: TRUE
[16:20:46.295] - signal: TRUE
[16:20:46.298] - resignal: FALSE
[16:20:46.298] - force: TRUE
[16:20:46.298] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.298] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.298]  - until=2
[16:20:46.298]  - relaying element #2
[16:20:46.298] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.298] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.299] signalConditionsASAP(NULL, pos=1) ... done
[16:20:46.299]  length: 5 (resolved future 1)
[16:20:46.299] Future #2
[16:20:46.299] result() for ClusterFuture ...
[16:20:46.299] - result already collected: FutureResult
[16:20:46.299] result() for ClusterFuture ... done
[16:20:46.299] result() for ClusterFuture ...
[16:20:46.299] - result already collected: FutureResult
[16:20:46.299] result() for ClusterFuture ... done
[16:20:46.299] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:20:46.300] - nx: 6
[16:20:46.300] - relay: TRUE
[16:20:46.300] - stdout: TRUE
[16:20:46.300] - signal: TRUE
[16:20:46.300] - resignal: FALSE
[16:20:46.300] - force: TRUE
[16:20:46.300] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.300] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:20:46.300]  - until=2
[16:20:46.300]  - relaying element #2
[16:20:46.300] result() for ClusterFuture ...
[16:20:46.301] - result already collected: FutureResult
[16:20:46.301] result() for ClusterFuture ... done
[16:20:46.301] result() for ClusterFuture ...
[16:20:46.301] - result already collected: FutureResult
[16:20:46.301] result() for ClusterFuture ... done
[16:20:46.301] result() for ClusterFuture ...
[16:20:46.301] - result already collected: FutureResult
[16:20:46.301] result() for ClusterFuture ... done
[16:20:46.301] result() for ClusterFuture ...
[16:20:46.301] - result already collected: FutureResult
[16:20:46.301] result() for ClusterFuture ... done
[16:20:46.301] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.302] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.302] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:20:46.302]  length: 4 (resolved future 2)
[16:20:46.302] Future #3
[16:20:46.302] result() for ClusterFuture ...
[16:20:46.302] - result already collected: FutureResult
[16:20:46.302] result() for ClusterFuture ... done
[16:20:46.302] result() for ClusterFuture ...
[16:20:46.302] - result already collected: FutureResult
[16:20:46.302] result() for ClusterFuture ... done
[16:20:46.302] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:20:46.303] - nx: 6
[16:20:46.303] - relay: TRUE
[16:20:46.303] - stdout: TRUE
[16:20:46.303] - signal: TRUE
[16:20:46.303] - resignal: FALSE
[16:20:46.303] - force: TRUE
[16:20:46.303] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.303] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:20:46.303]  - until=3
[16:20:46.303]  - relaying element #3
[16:20:46.303] result() for ClusterFuture ...
[16:20:46.303] - result already collected: FutureResult
[16:20:46.304] result() for ClusterFuture ... done
[16:20:46.304] result() for ClusterFuture ...
[16:20:46.304] - result already collected: FutureResult
[16:20:46.304] result() for ClusterFuture ... done
[16:20:46.304] result() for ClusterFuture ...
[16:20:46.304] - result already collected: FutureResult
[16:20:46.304] result() for ClusterFuture ... done
[16:20:46.304] result() for ClusterFuture ...
[16:20:46.304] - result already collected: FutureResult
[16:20:46.304] result() for ClusterFuture ... done
[16:20:46.304] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.305] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.305] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:20:46.305]  length: 3 (resolved future 3)
[16:20:46.305] Future #4
[16:20:46.305] result() for ClusterFuture ...
[16:20:46.305] - result already collected: FutureResult
[16:20:46.305] result() for ClusterFuture ... done
[16:20:46.305] result() for ClusterFuture ...
[16:20:46.305] - result already collected: FutureResult
[16:20:46.305] result() for ClusterFuture ... done
[16:20:46.305] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:20:46.306] - nx: 6
[16:20:46.306] - relay: TRUE
[16:20:46.306] - stdout: TRUE
[16:20:46.306] - signal: TRUE
[16:20:46.306] - resignal: FALSE
[16:20:46.306] - force: TRUE
[16:20:46.306] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.306] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:20:46.306]  - until=4
[16:20:46.306]  - relaying element #4
[16:20:46.306] result() for ClusterFuture ...
[16:20:46.306] - result already collected: FutureResult
[16:20:46.306] result() for ClusterFuture ... done
[16:20:46.307] result() for ClusterFuture ...
[16:20:46.307] - result already collected: FutureResult
[16:20:46.307] result() for ClusterFuture ... done
[16:20:46.307] result() for ClusterFuture ...
[16:20:46.307] - result already collected: FutureResult
[16:20:46.307] result() for ClusterFuture ... done
[16:20:46.307] result() for ClusterFuture ...
[16:20:46.307] - result already collected: FutureResult
[16:20:46.307] result() for ClusterFuture ... done
[16:20:46.307] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.307] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.308] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:20:46.308]  length: 2 (resolved future 4)
[16:20:46.308] signalConditionsASAP(NULL, pos=5) ...
[16:20:46.308] - nx: 6
[16:20:46.308] - relay: TRUE
[16:20:46.308] - stdout: TRUE
[16:20:46.308] - signal: TRUE
[16:20:46.308] - resignal: FALSE
[16:20:46.308] - force: TRUE
[16:20:46.308] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.308] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.308]  - until=6
[16:20:46.309]  - relaying element #6
[16:20:46.309] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:46.309] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.309] signalConditionsASAP(NULL, pos=5) ... done
[16:20:46.309]  length: 1 (resolved future 5)
[16:20:46.309] signalConditionsASAP(numeric, pos=6) ...
[16:20:46.309] - nx: 6
[16:20:46.309] - relay: TRUE
[16:20:46.309] - stdout: TRUE
[16:20:46.309] - signal: TRUE
[16:20:46.309] - resignal: FALSE
[16:20:46.309] - force: TRUE
[16:20:46.310] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:20:46.310] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.310]  - until=6
[16:20:46.310] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:46.310] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.310] signalConditionsASAP(numeric, pos=6) ... done
[16:20:46.310]  length: 0 (resolved future 6)
[16:20:46.310] Relaying remaining futures
[16:20:46.310] signalConditionsASAP(NULL, pos=0) ...
[16:20:46.310] - nx: 6
[16:20:46.310] - relay: TRUE
[16:20:46.310] - stdout: TRUE
[16:20:46.311] - signal: TRUE
[16:20:46.311] - resignal: FALSE
[16:20:46.311] - force: TRUE
[16:20:46.311] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:46.311] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:20:46.311] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:20:46.311] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:20:46.311] signalConditionsASAP(NULL, pos=0) ... done
[16:20:46.311] resolve() on list environment ... DONE
[16:20:46.311] result() for ClusterFuture ...
[16:20:46.311] - result already collected: FutureResult
[16:20:46.312] result() for ClusterFuture ... done
[16:20:46.312] result() for ClusterFuture ...
[16:20:46.312] - result already collected: FutureResult
[16:20:46.312] result() for ClusterFuture ... done
[16:20:46.312] result() for ClusterFuture ...
[16:20:46.312] - result already collected: FutureResult
[16:20:46.312] result() for ClusterFuture ... done
[16:20:46.312] result() for ClusterFuture ...
[16:20:46.312] - result already collected: FutureResult
[16:20:46.312] result() for ClusterFuture ... done
[16:20:46.313] result() for ClusterFuture ...
[16:20:46.313] - result already collected: FutureResult
[16:20:46.313] result() for ClusterFuture ... done
[16:20:46.313] result() for ClusterFuture ...
[16:20:46.313] - result already collected: FutureResult
[16:20:46.313] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55ed0df660c0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[16:20:46.316] plan(): Setting new future strategy stack:
[16:20:46.316] List of future strategies:
[16:20:46.316] 1. FutureStrategy:
[16:20:46.316]    - args: function (..., envir = parent.frame())
[16:20:46.316]    - tweaked: FALSE
[16:20:46.316]    - call: future::plan(oplan)
[16:20:46.317] plan(): nbrOfWorkers() = 1
> 
