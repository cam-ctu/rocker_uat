
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:20:54.703] plan(): Setting new future strategy stack:
[16:20:54.704] List of future strategies:
[16:20:54.704] 1. sequential:
[16:20:54.704]    - args: function (..., envir = parent.frame())
[16:20:54.704]    - tweaked: FALSE
[16:20:54.704]    - call: future::plan("sequential")
[16:20:54.718] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** Globals w/ non-standard evaluation (NSE) ...")
*** Globals w/ non-standard evaluation (NSE) ...
> 
> data <- data.frame(x = 1:5, y = 1:5)
> v0 <- subset(data, x < 3)$y
> 
> for (strategy in supportedStrategies()) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("- Strategy: %s ...", strategy))
+   
+   plan(strategy)
+ 
+   ## Assert option is passed on to future
+   options(future.globals.onMissing = "error")
+   opt1 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt1, "error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   opt2 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt2, "ignore"))
+ 
+   options(future.globals.onMissing = "error")
+   res <- try({ v1 %<-% subset(data, x < 3)$y }, silent = TRUE)
+   stopifnot(inherits(res, "try-error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   v2 %<-% subset(data, x < 3)$y
+   stopifnot(identical(v2, v0))
+ 
+   ## Nested futures (requires option is passed on to future)
+   plan(list(sequential, strategy))
+   options(future.globals.onMissing = "ignore")
+   v3 %<-% {
+     a %<-% subset(data, x < 3)$y
+     a
+   } %lazy% TRUE
+   stopifnot(identical(v3, v0))
+ 
+   message(sprintf("- Strategy: %s ... DONE", strategy))
+ }
- Strategy: sequential ...
[16:20:54.747] plan(): Setting new future strategy stack:
[16:20:54.748] List of future strategies:
[16:20:54.748] 1. sequential:
[16:20:54.748]    - args: function (..., envir = parent.frame())
[16:20:54.748]    - tweaked: FALSE
[16:20:54.748]    - call: plan(strategy)
[16:20:54.760] plan(): nbrOfWorkers() = 1
[16:20:54.761] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:20:54.762] Searching for globals...
[16:20:54.766] - globals found: [1] ‘getOption’
[16:20:54.766] Searching for globals ... DONE
[16:20:54.766] Resolving globals: FALSE
[16:20:54.766] 
[16:20:54.767] 
[16:20:54.767] getGlobalsAndPackages() ... DONE
[16:20:54.767] run() for ‘Future’ ...
[16:20:54.768] - state: ‘created’
[16:20:54.768] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:54.768] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:54.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:54.768]   - Field: ‘label’
[16:20:54.768]   - Field: ‘local’
[16:20:54.769]   - Field: ‘owner’
[16:20:54.769]   - Field: ‘envir’
[16:20:54.769]   - Field: ‘packages’
[16:20:54.769]   - Field: ‘gc’
[16:20:54.769]   - Field: ‘conditions’
[16:20:54.769]   - Field: ‘expr’
[16:20:54.769]   - Field: ‘uuid’
[16:20:54.769]   - Field: ‘seed’
[16:20:54.769]   - Field: ‘version’
[16:20:54.769]   - Field: ‘result’
[16:20:54.769]   - Field: ‘asynchronous’
[16:20:54.769]   - Field: ‘calls’
[16:20:54.770]   - Field: ‘globals’
[16:20:54.770]   - Field: ‘stdout’
[16:20:54.770]   - Field: ‘earlySignal’
[16:20:54.770]   - Field: ‘lazy’
[16:20:54.770]   - Field: ‘state’
[16:20:54.770] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:54.770] - Launch lazy future ...
[16:20:54.771] Packages needed by the future expression (n = 0): <none>
[16:20:54.771] Packages needed by future strategies (n = 0): <none>
[16:20:54.772] {
[16:20:54.772]     {
[16:20:54.772]         {
[16:20:54.772]             ...future.startTime <- base::Sys.time()
[16:20:54.772]             {
[16:20:54.772]                 {
[16:20:54.772]                   {
[16:20:54.772]                     base::local({
[16:20:54.772]                       has_future <- base::requireNamespace("future", 
[16:20:54.772]                         quietly = TRUE)
[16:20:54.772]                       if (has_future) {
[16:20:54.772]                         ns <- base::getNamespace("future")
[16:20:54.772]                         version <- ns[[".package"]][["version"]]
[16:20:54.772]                         if (is.null(version)) 
[16:20:54.772]                           version <- utils::packageVersion("future")
[16:20:54.772]                       }
[16:20:54.772]                       else {
[16:20:54.772]                         version <- NULL
[16:20:54.772]                       }
[16:20:54.772]                       if (!has_future || version < "1.8.0") {
[16:20:54.772]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:54.772]                           "", base::R.version$version.string), 
[16:20:54.772]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:54.772]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:54.772]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:54.772]                             "release", "version")], collapse = " "), 
[16:20:54.772]                           hostname = base::Sys.info()[["nodename"]])
[16:20:54.772]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:54.772]                           info)
[16:20:54.772]                         info <- base::paste(info, collapse = "; ")
[16:20:54.772]                         if (!has_future) {
[16:20:54.772]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:54.772]                             info)
[16:20:54.772]                         }
[16:20:54.772]                         else {
[16:20:54.772]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:54.772]                             info, version)
[16:20:54.772]                         }
[16:20:54.772]                         base::stop(msg)
[16:20:54.772]                       }
[16:20:54.772]                     })
[16:20:54.772]                   }
[16:20:54.772]                   ...future.strategy.old <- future::plan("list")
[16:20:54.772]                   options(future.plan = NULL)
[16:20:54.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.772]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:54.772]                 }
[16:20:54.772]                 ...future.workdir <- getwd()
[16:20:54.772]             }
[16:20:54.772]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:54.772]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:54.772]         }
[16:20:54.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:20:54.772]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:54.772]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:20:54.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:54.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:54.772]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:54.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:54.772]             base::names(...future.oldOptions))
[16:20:54.772]     }
[16:20:54.772]     if (FALSE) {
[16:20:54.772]     }
[16:20:54.772]     else {
[16:20:54.772]         if (TRUE) {
[16:20:54.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:54.772]                 open = "w")
[16:20:54.772]         }
[16:20:54.772]         else {
[16:20:54.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:54.772]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:54.772]         }
[16:20:54.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:54.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:54.772]             base::sink(type = "output", split = FALSE)
[16:20:54.772]             base::close(...future.stdout)
[16:20:54.772]         }, add = TRUE)
[16:20:54.772]     }
[16:20:54.772]     ...future.frame <- base::sys.nframe()
[16:20:54.772]     ...future.conditions <- base::list()
[16:20:54.772]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:54.772]     if (FALSE) {
[16:20:54.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:54.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:54.772]     }
[16:20:54.772]     ...future.result <- base::tryCatch({
[16:20:54.772]         base::withCallingHandlers({
[16:20:54.772]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[16:20:54.772]             future::FutureResult(value = ...future.value$value, 
[16:20:54.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.772]                   ...future.rng), globalenv = if (FALSE) 
[16:20:54.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:54.772]                     ...future.globalenv.names))
[16:20:54.772]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:54.772]         }, condition = base::local({
[16:20:54.772]             c <- base::c
[16:20:54.772]             inherits <- base::inherits
[16:20:54.772]             invokeRestart <- base::invokeRestart
[16:20:54.772]             length <- base::length
[16:20:54.772]             list <- base::list
[16:20:54.772]             seq.int <- base::seq.int
[16:20:54.772]             signalCondition <- base::signalCondition
[16:20:54.772]             sys.calls <- base::sys.calls
[16:20:54.772]             `[[` <- base::`[[`
[16:20:54.772]             `+` <- base::`+`
[16:20:54.772]             `<<-` <- base::`<<-`
[16:20:54.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:54.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:54.772]                   3L)]
[16:20:54.772]             }
[16:20:54.772]             function(cond) {
[16:20:54.772]                 is_error <- inherits(cond, "error")
[16:20:54.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:54.772]                   NULL)
[16:20:54.772]                 if (is_error) {
[16:20:54.772]                   sessionInformation <- function() {
[16:20:54.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:54.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:54.772]                       search = base::search(), system = base::Sys.info())
[16:20:54.772]                   }
[16:20:54.772]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:54.772]                     cond$call), session = sessionInformation(), 
[16:20:54.772]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:54.772]                   signalCondition(cond)
[16:20:54.772]                 }
[16:20:54.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:54.772]                 "immediateCondition"))) {
[16:20:54.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:54.772]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:54.772]                   if (TRUE && !signal) {
[16:20:54.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.772]                     {
[16:20:54.772]                       inherits <- base::inherits
[16:20:54.772]                       invokeRestart <- base::invokeRestart
[16:20:54.772]                       is.null <- base::is.null
[16:20:54.772]                       muffled <- FALSE
[16:20:54.772]                       if (inherits(cond, "message")) {
[16:20:54.772]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.772]                         if (muffled) 
[16:20:54.772]                           invokeRestart("muffleMessage")
[16:20:54.772]                       }
[16:20:54.772]                       else if (inherits(cond, "warning")) {
[16:20:54.772]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.772]                         if (muffled) 
[16:20:54.772]                           invokeRestart("muffleWarning")
[16:20:54.772]                       }
[16:20:54.772]                       else if (inherits(cond, "condition")) {
[16:20:54.772]                         if (!is.null(pattern)) {
[16:20:54.772]                           computeRestarts <- base::computeRestarts
[16:20:54.772]                           grepl <- base::grepl
[16:20:54.772]                           restarts <- computeRestarts(cond)
[16:20:54.772]                           for (restart in restarts) {
[16:20:54.772]                             name <- restart$name
[16:20:54.772]                             if (is.null(name)) 
[16:20:54.772]                               next
[16:20:54.772]                             if (!grepl(pattern, name)) 
[16:20:54.772]                               next
[16:20:54.772]                             invokeRestart(restart)
[16:20:54.772]                             muffled <- TRUE
[16:20:54.772]                             break
[16:20:54.772]                           }
[16:20:54.772]                         }
[16:20:54.772]                       }
[16:20:54.772]                       invisible(muffled)
[16:20:54.772]                     }
[16:20:54.772]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.772]                   }
[16:20:54.772]                 }
[16:20:54.772]                 else {
[16:20:54.772]                   if (TRUE) {
[16:20:54.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.772]                     {
[16:20:54.772]                       inherits <- base::inherits
[16:20:54.772]                       invokeRestart <- base::invokeRestart
[16:20:54.772]                       is.null <- base::is.null
[16:20:54.772]                       muffled <- FALSE
[16:20:54.772]                       if (inherits(cond, "message")) {
[16:20:54.772]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.772]                         if (muffled) 
[16:20:54.772]                           invokeRestart("muffleMessage")
[16:20:54.772]                       }
[16:20:54.772]                       else if (inherits(cond, "warning")) {
[16:20:54.772]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.772]                         if (muffled) 
[16:20:54.772]                           invokeRestart("muffleWarning")
[16:20:54.772]                       }
[16:20:54.772]                       else if (inherits(cond, "condition")) {
[16:20:54.772]                         if (!is.null(pattern)) {
[16:20:54.772]                           computeRestarts <- base::computeRestarts
[16:20:54.772]                           grepl <- base::grepl
[16:20:54.772]                           restarts <- computeRestarts(cond)
[16:20:54.772]                           for (restart in restarts) {
[16:20:54.772]                             name <- restart$name
[16:20:54.772]                             if (is.null(name)) 
[16:20:54.772]                               next
[16:20:54.772]                             if (!grepl(pattern, name)) 
[16:20:54.772]                               next
[16:20:54.772]                             invokeRestart(restart)
[16:20:54.772]                             muffled <- TRUE
[16:20:54.772]                             break
[16:20:54.772]                           }
[16:20:54.772]                         }
[16:20:54.772]                       }
[16:20:54.772]                       invisible(muffled)
[16:20:54.772]                     }
[16:20:54.772]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.772]                   }
[16:20:54.772]                 }
[16:20:54.772]             }
[16:20:54.772]         }))
[16:20:54.772]     }, error = function(ex) {
[16:20:54.772]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:54.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.772]                 ...future.rng), started = ...future.startTime, 
[16:20:54.772]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:54.772]             version = "1.8"), class = "FutureResult")
[16:20:54.772]     }, finally = {
[16:20:54.772]         if (!identical(...future.workdir, getwd())) 
[16:20:54.772]             setwd(...future.workdir)
[16:20:54.772]         {
[16:20:54.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:54.772]                 ...future.oldOptions$nwarnings <- NULL
[16:20:54.772]             }
[16:20:54.772]             base::options(...future.oldOptions)
[16:20:54.772]             if (.Platform$OS.type == "windows") {
[16:20:54.772]                 old_names <- names(...future.oldEnvVars)
[16:20:54.772]                 envs <- base::Sys.getenv()
[16:20:54.772]                 names <- names(envs)
[16:20:54.772]                 common <- intersect(names, old_names)
[16:20:54.772]                 added <- setdiff(names, old_names)
[16:20:54.772]                 removed <- setdiff(old_names, names)
[16:20:54.772]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:54.772]                   envs[common]]
[16:20:54.772]                 NAMES <- toupper(changed)
[16:20:54.772]                 args <- list()
[16:20:54.772]                 for (kk in seq_along(NAMES)) {
[16:20:54.772]                   name <- changed[[kk]]
[16:20:54.772]                   NAME <- NAMES[[kk]]
[16:20:54.772]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.772]                     next
[16:20:54.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.772]                 }
[16:20:54.772]                 NAMES <- toupper(added)
[16:20:54.772]                 for (kk in seq_along(NAMES)) {
[16:20:54.772]                   name <- added[[kk]]
[16:20:54.772]                   NAME <- NAMES[[kk]]
[16:20:54.772]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.772]                     next
[16:20:54.772]                   args[[name]] <- ""
[16:20:54.772]                 }
[16:20:54.772]                 NAMES <- toupper(removed)
[16:20:54.772]                 for (kk in seq_along(NAMES)) {
[16:20:54.772]                   name <- removed[[kk]]
[16:20:54.772]                   NAME <- NAMES[[kk]]
[16:20:54.772]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.772]                     next
[16:20:54.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.772]                 }
[16:20:54.772]                 if (length(args) > 0) 
[16:20:54.772]                   base::do.call(base::Sys.setenv, args = args)
[16:20:54.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:54.772]             }
[16:20:54.772]             else {
[16:20:54.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:54.772]             }
[16:20:54.772]             {
[16:20:54.772]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:54.772]                   0L) {
[16:20:54.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:54.772]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:54.772]                   base::options(opts)
[16:20:54.772]                 }
[16:20:54.772]                 {
[16:20:54.772]                   {
[16:20:54.772]                     NULL
[16:20:54.772]                     RNGkind("Mersenne-Twister")
[16:20:54.772]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:54.772]                       inherits = FALSE)
[16:20:54.772]                   }
[16:20:54.772]                   options(future.plan = NULL)
[16:20:54.772]                   if (is.na(NA_character_)) 
[16:20:54.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:54.772]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:54.772]                     .init = FALSE)
[16:20:54.772]                 }
[16:20:54.772]             }
[16:20:54.772]         }
[16:20:54.772]     })
[16:20:54.772]     if (TRUE) {
[16:20:54.772]         base::sink(type = "output", split = FALSE)
[16:20:54.772]         if (TRUE) {
[16:20:54.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:54.772]         }
[16:20:54.772]         else {
[16:20:54.772]             ...future.result["stdout"] <- base::list(NULL)
[16:20:54.772]         }
[16:20:54.772]         base::close(...future.stdout)
[16:20:54.772]         ...future.stdout <- NULL
[16:20:54.772]     }
[16:20:54.772]     ...future.result$conditions <- ...future.conditions
[16:20:54.772]     ...future.result$finished <- base::Sys.time()
[16:20:54.772]     ...future.result
[16:20:54.772] }
[16:20:54.774] plan(): Setting new future strategy stack:
[16:20:54.774] List of future strategies:
[16:20:54.774] 1. sequential:
[16:20:54.774]    - args: function (..., envir = parent.frame())
[16:20:54.774]    - tweaked: FALSE
[16:20:54.774]    - call: NULL
[16:20:54.774] plan(): nbrOfWorkers() = 1
[16:20:54.775] plan(): Setting new future strategy stack:
[16:20:54.775] List of future strategies:
[16:20:54.775] 1. sequential:
[16:20:54.775]    - args: function (..., envir = parent.frame())
[16:20:54.775]    - tweaked: FALSE
[16:20:54.775]    - call: plan(strategy)
[16:20:54.776] plan(): nbrOfWorkers() = 1
[16:20:54.776] SequentialFuture started (and completed)
[16:20:54.776] - Launch lazy future ... done
[16:20:54.777] run() for ‘SequentialFuture’ ... done
[16:20:54.777] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:54.777] Searching for globals...
[16:20:54.778] - globals found: [1] ‘getOption’
[16:20:54.778] Searching for globals ... DONE
[16:20:54.778] Resolving globals: FALSE
[16:20:54.778] 
[16:20:54.778] 
[16:20:54.778] getGlobalsAndPackages() ... DONE
[16:20:54.779] run() for ‘Future’ ...
[16:20:54.779] - state: ‘created’
[16:20:54.779] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:54.779] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:54.779] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:54.779]   - Field: ‘label’
[16:20:54.779]   - Field: ‘local’
[16:20:54.780]   - Field: ‘owner’
[16:20:54.780]   - Field: ‘envir’
[16:20:54.780]   - Field: ‘packages’
[16:20:54.780]   - Field: ‘gc’
[16:20:54.780]   - Field: ‘conditions’
[16:20:54.780]   - Field: ‘expr’
[16:20:54.780]   - Field: ‘uuid’
[16:20:54.780]   - Field: ‘seed’
[16:20:54.780]   - Field: ‘version’
[16:20:54.780]   - Field: ‘result’
[16:20:54.780]   - Field: ‘asynchronous’
[16:20:54.781]   - Field: ‘calls’
[16:20:54.781]   - Field: ‘globals’
[16:20:54.781]   - Field: ‘stdout’
[16:20:54.781]   - Field: ‘earlySignal’
[16:20:54.781]   - Field: ‘lazy’
[16:20:54.781]   - Field: ‘state’
[16:20:54.781] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:54.781] - Launch lazy future ...
[16:20:54.781] Packages needed by the future expression (n = 0): <none>
[16:20:54.781] Packages needed by future strategies (n = 0): <none>
[16:20:54.782] {
[16:20:54.782]     {
[16:20:54.782]         {
[16:20:54.782]             ...future.startTime <- base::Sys.time()
[16:20:54.782]             {
[16:20:54.782]                 {
[16:20:54.782]                   {
[16:20:54.782]                     base::local({
[16:20:54.782]                       has_future <- base::requireNamespace("future", 
[16:20:54.782]                         quietly = TRUE)
[16:20:54.782]                       if (has_future) {
[16:20:54.782]                         ns <- base::getNamespace("future")
[16:20:54.782]                         version <- ns[[".package"]][["version"]]
[16:20:54.782]                         if (is.null(version)) 
[16:20:54.782]                           version <- utils::packageVersion("future")
[16:20:54.782]                       }
[16:20:54.782]                       else {
[16:20:54.782]                         version <- NULL
[16:20:54.782]                       }
[16:20:54.782]                       if (!has_future || version < "1.8.0") {
[16:20:54.782]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:54.782]                           "", base::R.version$version.string), 
[16:20:54.782]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:54.782]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:54.782]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:54.782]                             "release", "version")], collapse = " "), 
[16:20:54.782]                           hostname = base::Sys.info()[["nodename"]])
[16:20:54.782]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:54.782]                           info)
[16:20:54.782]                         info <- base::paste(info, collapse = "; ")
[16:20:54.782]                         if (!has_future) {
[16:20:54.782]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:54.782]                             info)
[16:20:54.782]                         }
[16:20:54.782]                         else {
[16:20:54.782]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:54.782]                             info, version)
[16:20:54.782]                         }
[16:20:54.782]                         base::stop(msg)
[16:20:54.782]                       }
[16:20:54.782]                     })
[16:20:54.782]                   }
[16:20:54.782]                   ...future.strategy.old <- future::plan("list")
[16:20:54.782]                   options(future.plan = NULL)
[16:20:54.782]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.782]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:54.782]                 }
[16:20:54.782]                 ...future.workdir <- getwd()
[16:20:54.782]             }
[16:20:54.782]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:54.782]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:54.782]         }
[16:20:54.782]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:54.782]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:54.782]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:54.782]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:54.782]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:54.782]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:54.782]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:54.782]             base::names(...future.oldOptions))
[16:20:54.782]     }
[16:20:54.782]     if (FALSE) {
[16:20:54.782]     }
[16:20:54.782]     else {
[16:20:54.782]         if (TRUE) {
[16:20:54.782]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:54.782]                 open = "w")
[16:20:54.782]         }
[16:20:54.782]         else {
[16:20:54.782]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:54.782]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:54.782]         }
[16:20:54.782]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:54.782]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:54.782]             base::sink(type = "output", split = FALSE)
[16:20:54.782]             base::close(...future.stdout)
[16:20:54.782]         }, add = TRUE)
[16:20:54.782]     }
[16:20:54.782]     ...future.frame <- base::sys.nframe()
[16:20:54.782]     ...future.conditions <- base::list()
[16:20:54.782]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:54.782]     if (FALSE) {
[16:20:54.782]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:54.782]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:54.782]     }
[16:20:54.782]     ...future.result <- base::tryCatch({
[16:20:54.782]         base::withCallingHandlers({
[16:20:54.782]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[16:20:54.782]             future::FutureResult(value = ...future.value$value, 
[16:20:54.782]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.782]                   ...future.rng), globalenv = if (FALSE) 
[16:20:54.782]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:54.782]                     ...future.globalenv.names))
[16:20:54.782]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:54.782]         }, condition = base::local({
[16:20:54.782]             c <- base::c
[16:20:54.782]             inherits <- base::inherits
[16:20:54.782]             invokeRestart <- base::invokeRestart
[16:20:54.782]             length <- base::length
[16:20:54.782]             list <- base::list
[16:20:54.782]             seq.int <- base::seq.int
[16:20:54.782]             signalCondition <- base::signalCondition
[16:20:54.782]             sys.calls <- base::sys.calls
[16:20:54.782]             `[[` <- base::`[[`
[16:20:54.782]             `+` <- base::`+`
[16:20:54.782]             `<<-` <- base::`<<-`
[16:20:54.782]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:54.782]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:54.782]                   3L)]
[16:20:54.782]             }
[16:20:54.782]             function(cond) {
[16:20:54.782]                 is_error <- inherits(cond, "error")
[16:20:54.782]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:54.782]                   NULL)
[16:20:54.782]                 if (is_error) {
[16:20:54.782]                   sessionInformation <- function() {
[16:20:54.782]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:54.782]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:54.782]                       search = base::search(), system = base::Sys.info())
[16:20:54.782]                   }
[16:20:54.782]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.782]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:54.782]                     cond$call), session = sessionInformation(), 
[16:20:54.782]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:54.782]                   signalCondition(cond)
[16:20:54.782]                 }
[16:20:54.782]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:54.782]                 "immediateCondition"))) {
[16:20:54.782]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:54.782]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.782]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:54.782]                   if (TRUE && !signal) {
[16:20:54.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.782]                     {
[16:20:54.782]                       inherits <- base::inherits
[16:20:54.782]                       invokeRestart <- base::invokeRestart
[16:20:54.782]                       is.null <- base::is.null
[16:20:54.782]                       muffled <- FALSE
[16:20:54.782]                       if (inherits(cond, "message")) {
[16:20:54.782]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.782]                         if (muffled) 
[16:20:54.782]                           invokeRestart("muffleMessage")
[16:20:54.782]                       }
[16:20:54.782]                       else if (inherits(cond, "warning")) {
[16:20:54.782]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.782]                         if (muffled) 
[16:20:54.782]                           invokeRestart("muffleWarning")
[16:20:54.782]                       }
[16:20:54.782]                       else if (inherits(cond, "condition")) {
[16:20:54.782]                         if (!is.null(pattern)) {
[16:20:54.782]                           computeRestarts <- base::computeRestarts
[16:20:54.782]                           grepl <- base::grepl
[16:20:54.782]                           restarts <- computeRestarts(cond)
[16:20:54.782]                           for (restart in restarts) {
[16:20:54.782]                             name <- restart$name
[16:20:54.782]                             if (is.null(name)) 
[16:20:54.782]                               next
[16:20:54.782]                             if (!grepl(pattern, name)) 
[16:20:54.782]                               next
[16:20:54.782]                             invokeRestart(restart)
[16:20:54.782]                             muffled <- TRUE
[16:20:54.782]                             break
[16:20:54.782]                           }
[16:20:54.782]                         }
[16:20:54.782]                       }
[16:20:54.782]                       invisible(muffled)
[16:20:54.782]                     }
[16:20:54.782]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.782]                   }
[16:20:54.782]                 }
[16:20:54.782]                 else {
[16:20:54.782]                   if (TRUE) {
[16:20:54.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.782]                     {
[16:20:54.782]                       inherits <- base::inherits
[16:20:54.782]                       invokeRestart <- base::invokeRestart
[16:20:54.782]                       is.null <- base::is.null
[16:20:54.782]                       muffled <- FALSE
[16:20:54.782]                       if (inherits(cond, "message")) {
[16:20:54.782]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.782]                         if (muffled) 
[16:20:54.782]                           invokeRestart("muffleMessage")
[16:20:54.782]                       }
[16:20:54.782]                       else if (inherits(cond, "warning")) {
[16:20:54.782]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.782]                         if (muffled) 
[16:20:54.782]                           invokeRestart("muffleWarning")
[16:20:54.782]                       }
[16:20:54.782]                       else if (inherits(cond, "condition")) {
[16:20:54.782]                         if (!is.null(pattern)) {
[16:20:54.782]                           computeRestarts <- base::computeRestarts
[16:20:54.782]                           grepl <- base::grepl
[16:20:54.782]                           restarts <- computeRestarts(cond)
[16:20:54.782]                           for (restart in restarts) {
[16:20:54.782]                             name <- restart$name
[16:20:54.782]                             if (is.null(name)) 
[16:20:54.782]                               next
[16:20:54.782]                             if (!grepl(pattern, name)) 
[16:20:54.782]                               next
[16:20:54.782]                             invokeRestart(restart)
[16:20:54.782]                             muffled <- TRUE
[16:20:54.782]                             break
[16:20:54.782]                           }
[16:20:54.782]                         }
[16:20:54.782]                       }
[16:20:54.782]                       invisible(muffled)
[16:20:54.782]                     }
[16:20:54.782]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.782]                   }
[16:20:54.782]                 }
[16:20:54.782]             }
[16:20:54.782]         }))
[16:20:54.782]     }, error = function(ex) {
[16:20:54.782]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:54.782]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.782]                 ...future.rng), started = ...future.startTime, 
[16:20:54.782]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:54.782]             version = "1.8"), class = "FutureResult")
[16:20:54.782]     }, finally = {
[16:20:54.782]         if (!identical(...future.workdir, getwd())) 
[16:20:54.782]             setwd(...future.workdir)
[16:20:54.782]         {
[16:20:54.782]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:54.782]                 ...future.oldOptions$nwarnings <- NULL
[16:20:54.782]             }
[16:20:54.782]             base::options(...future.oldOptions)
[16:20:54.782]             if (.Platform$OS.type == "windows") {
[16:20:54.782]                 old_names <- names(...future.oldEnvVars)
[16:20:54.782]                 envs <- base::Sys.getenv()
[16:20:54.782]                 names <- names(envs)
[16:20:54.782]                 common <- intersect(names, old_names)
[16:20:54.782]                 added <- setdiff(names, old_names)
[16:20:54.782]                 removed <- setdiff(old_names, names)
[16:20:54.782]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:54.782]                   envs[common]]
[16:20:54.782]                 NAMES <- toupper(changed)
[16:20:54.782]                 args <- list()
[16:20:54.782]                 for (kk in seq_along(NAMES)) {
[16:20:54.782]                   name <- changed[[kk]]
[16:20:54.782]                   NAME <- NAMES[[kk]]
[16:20:54.782]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.782]                     next
[16:20:54.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.782]                 }
[16:20:54.782]                 NAMES <- toupper(added)
[16:20:54.782]                 for (kk in seq_along(NAMES)) {
[16:20:54.782]                   name <- added[[kk]]
[16:20:54.782]                   NAME <- NAMES[[kk]]
[16:20:54.782]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.782]                     next
[16:20:54.782]                   args[[name]] <- ""
[16:20:54.782]                 }
[16:20:54.782]                 NAMES <- toupper(removed)
[16:20:54.782]                 for (kk in seq_along(NAMES)) {
[16:20:54.782]                   name <- removed[[kk]]
[16:20:54.782]                   NAME <- NAMES[[kk]]
[16:20:54.782]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.782]                     next
[16:20:54.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.782]                 }
[16:20:54.782]                 if (length(args) > 0) 
[16:20:54.782]                   base::do.call(base::Sys.setenv, args = args)
[16:20:54.782]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:54.782]             }
[16:20:54.782]             else {
[16:20:54.782]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:54.782]             }
[16:20:54.782]             {
[16:20:54.782]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:54.782]                   0L) {
[16:20:54.782]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:54.782]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:54.782]                   base::options(opts)
[16:20:54.782]                 }
[16:20:54.782]                 {
[16:20:54.782]                   {
[16:20:54.782]                     NULL
[16:20:54.782]                     RNGkind("Mersenne-Twister")
[16:20:54.782]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:54.782]                       inherits = FALSE)
[16:20:54.782]                   }
[16:20:54.782]                   options(future.plan = NULL)
[16:20:54.782]                   if (is.na(NA_character_)) 
[16:20:54.782]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.782]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:54.782]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:54.782]                     .init = FALSE)
[16:20:54.782]                 }
[16:20:54.782]             }
[16:20:54.782]         }
[16:20:54.782]     })
[16:20:54.782]     if (TRUE) {
[16:20:54.782]         base::sink(type = "output", split = FALSE)
[16:20:54.782]         if (TRUE) {
[16:20:54.782]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:54.782]         }
[16:20:54.782]         else {
[16:20:54.782]             ...future.result["stdout"] <- base::list(NULL)
[16:20:54.782]         }
[16:20:54.782]         base::close(...future.stdout)
[16:20:54.782]         ...future.stdout <- NULL
[16:20:54.782]     }
[16:20:54.782]     ...future.result$conditions <- ...future.conditions
[16:20:54.782]     ...future.result$finished <- base::Sys.time()
[16:20:54.782]     ...future.result
[16:20:54.782] }
[16:20:54.784] plan(): Setting new future strategy stack:
[16:20:54.784] List of future strategies:
[16:20:54.784] 1. sequential:
[16:20:54.784]    - args: function (..., envir = parent.frame())
[16:20:54.784]    - tweaked: FALSE
[16:20:54.784]    - call: NULL
[16:20:54.784] plan(): nbrOfWorkers() = 1
[16:20:54.785] plan(): Setting new future strategy stack:
[16:20:54.785] List of future strategies:
[16:20:54.785] 1. sequential:
[16:20:54.785]    - args: function (..., envir = parent.frame())
[16:20:54.785]    - tweaked: FALSE
[16:20:54.785]    - call: plan(strategy)
[16:20:54.785] plan(): nbrOfWorkers() = 1
[16:20:54.785] SequentialFuture started (and completed)
[16:20:54.785] - Launch lazy future ... done
[16:20:54.785] run() for ‘SequentialFuture’ ... done
[16:20:54.786] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:20:54.786] Searching for globals...
[16:20:54.787] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:54.787] Searching for globals...
[16:20:54.788] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[16:20:54.788] Searching for globals ... DONE
[16:20:54.790] Resolving globals: FALSE
[16:20:54.792] The total size of the 1 globals is 160 bytes (160 bytes)
[16:20:54.792] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[16:20:54.792] - globals: [1] ‘data’
[16:20:54.792] 
[16:20:54.792] getGlobalsAndPackages() ... DONE
[16:20:54.793] run() for ‘Future’ ...
[16:20:54.793] - state: ‘created’
[16:20:54.793] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:54.793] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:54.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:54.793]   - Field: ‘label’
[16:20:54.793]   - Field: ‘local’
[16:20:54.794]   - Field: ‘owner’
[16:20:54.794]   - Field: ‘envir’
[16:20:54.794]   - Field: ‘packages’
[16:20:54.794]   - Field: ‘gc’
[16:20:54.794]   - Field: ‘conditions’
[16:20:54.794]   - Field: ‘expr’
[16:20:54.794]   - Field: ‘uuid’
[16:20:54.794]   - Field: ‘seed’
[16:20:54.794]   - Field: ‘version’
[16:20:54.794]   - Field: ‘result’
[16:20:54.794]   - Field: ‘asynchronous’
[16:20:54.795]   - Field: ‘calls’
[16:20:54.795]   - Field: ‘globals’
[16:20:54.795]   - Field: ‘stdout’
[16:20:54.795]   - Field: ‘earlySignal’
[16:20:54.795]   - Field: ‘lazy’
[16:20:54.795]   - Field: ‘state’
[16:20:54.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:54.795] - Launch lazy future ...
[16:20:54.795] Packages needed by the future expression (n = 0): <none>
[16:20:54.796] Packages needed by future strategies (n = 0): <none>
[16:20:54.796] {
[16:20:54.796]     {
[16:20:54.796]         {
[16:20:54.796]             ...future.startTime <- base::Sys.time()
[16:20:54.796]             {
[16:20:54.796]                 {
[16:20:54.796]                   {
[16:20:54.796]                     base::local({
[16:20:54.796]                       has_future <- base::requireNamespace("future", 
[16:20:54.796]                         quietly = TRUE)
[16:20:54.796]                       if (has_future) {
[16:20:54.796]                         ns <- base::getNamespace("future")
[16:20:54.796]                         version <- ns[[".package"]][["version"]]
[16:20:54.796]                         if (is.null(version)) 
[16:20:54.796]                           version <- utils::packageVersion("future")
[16:20:54.796]                       }
[16:20:54.796]                       else {
[16:20:54.796]                         version <- NULL
[16:20:54.796]                       }
[16:20:54.796]                       if (!has_future || version < "1.8.0") {
[16:20:54.796]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:54.796]                           "", base::R.version$version.string), 
[16:20:54.796]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:54.796]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:54.796]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:54.796]                             "release", "version")], collapse = " "), 
[16:20:54.796]                           hostname = base::Sys.info()[["nodename"]])
[16:20:54.796]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:54.796]                           info)
[16:20:54.796]                         info <- base::paste(info, collapse = "; ")
[16:20:54.796]                         if (!has_future) {
[16:20:54.796]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:54.796]                             info)
[16:20:54.796]                         }
[16:20:54.796]                         else {
[16:20:54.796]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:54.796]                             info, version)
[16:20:54.796]                         }
[16:20:54.796]                         base::stop(msg)
[16:20:54.796]                       }
[16:20:54.796]                     })
[16:20:54.796]                   }
[16:20:54.796]                   ...future.strategy.old <- future::plan("list")
[16:20:54.796]                   options(future.plan = NULL)
[16:20:54.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:54.796]                 }
[16:20:54.796]                 ...future.workdir <- getwd()
[16:20:54.796]             }
[16:20:54.796]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:54.796]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:54.796]         }
[16:20:54.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:54.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:54.796]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:54.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:54.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:54.796]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:54.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:54.796]             base::names(...future.oldOptions))
[16:20:54.796]     }
[16:20:54.796]     if (FALSE) {
[16:20:54.796]     }
[16:20:54.796]     else {
[16:20:54.796]         if (TRUE) {
[16:20:54.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:54.796]                 open = "w")
[16:20:54.796]         }
[16:20:54.796]         else {
[16:20:54.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:54.796]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:54.796]         }
[16:20:54.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:54.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:54.796]             base::sink(type = "output", split = FALSE)
[16:20:54.796]             base::close(...future.stdout)
[16:20:54.796]         }, add = TRUE)
[16:20:54.796]     }
[16:20:54.796]     ...future.frame <- base::sys.nframe()
[16:20:54.796]     ...future.conditions <- base::list()
[16:20:54.796]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:54.796]     if (FALSE) {
[16:20:54.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:54.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:54.796]     }
[16:20:54.796]     ...future.result <- base::tryCatch({
[16:20:54.796]         base::withCallingHandlers({
[16:20:54.796]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:20:54.796]                 x < 3)$y))
[16:20:54.796]             future::FutureResult(value = ...future.value$value, 
[16:20:54.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.796]                   ...future.rng), globalenv = if (FALSE) 
[16:20:54.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:54.796]                     ...future.globalenv.names))
[16:20:54.796]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:54.796]         }, condition = base::local({
[16:20:54.796]             c <- base::c
[16:20:54.796]             inherits <- base::inherits
[16:20:54.796]             invokeRestart <- base::invokeRestart
[16:20:54.796]             length <- base::length
[16:20:54.796]             list <- base::list
[16:20:54.796]             seq.int <- base::seq.int
[16:20:54.796]             signalCondition <- base::signalCondition
[16:20:54.796]             sys.calls <- base::sys.calls
[16:20:54.796]             `[[` <- base::`[[`
[16:20:54.796]             `+` <- base::`+`
[16:20:54.796]             `<<-` <- base::`<<-`
[16:20:54.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:54.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:54.796]                   3L)]
[16:20:54.796]             }
[16:20:54.796]             function(cond) {
[16:20:54.796]                 is_error <- inherits(cond, "error")
[16:20:54.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:54.796]                   NULL)
[16:20:54.796]                 if (is_error) {
[16:20:54.796]                   sessionInformation <- function() {
[16:20:54.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:54.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:54.796]                       search = base::search(), system = base::Sys.info())
[16:20:54.796]                   }
[16:20:54.796]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:54.796]                     cond$call), session = sessionInformation(), 
[16:20:54.796]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:54.796]                   signalCondition(cond)
[16:20:54.796]                 }
[16:20:54.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:54.796]                 "immediateCondition"))) {
[16:20:54.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:54.796]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:54.796]                   if (TRUE && !signal) {
[16:20:54.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.796]                     {
[16:20:54.796]                       inherits <- base::inherits
[16:20:54.796]                       invokeRestart <- base::invokeRestart
[16:20:54.796]                       is.null <- base::is.null
[16:20:54.796]                       muffled <- FALSE
[16:20:54.796]                       if (inherits(cond, "message")) {
[16:20:54.796]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.796]                         if (muffled) 
[16:20:54.796]                           invokeRestart("muffleMessage")
[16:20:54.796]                       }
[16:20:54.796]                       else if (inherits(cond, "warning")) {
[16:20:54.796]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.796]                         if (muffled) 
[16:20:54.796]                           invokeRestart("muffleWarning")
[16:20:54.796]                       }
[16:20:54.796]                       else if (inherits(cond, "condition")) {
[16:20:54.796]                         if (!is.null(pattern)) {
[16:20:54.796]                           computeRestarts <- base::computeRestarts
[16:20:54.796]                           grepl <- base::grepl
[16:20:54.796]                           restarts <- computeRestarts(cond)
[16:20:54.796]                           for (restart in restarts) {
[16:20:54.796]                             name <- restart$name
[16:20:54.796]                             if (is.null(name)) 
[16:20:54.796]                               next
[16:20:54.796]                             if (!grepl(pattern, name)) 
[16:20:54.796]                               next
[16:20:54.796]                             invokeRestart(restart)
[16:20:54.796]                             muffled <- TRUE
[16:20:54.796]                             break
[16:20:54.796]                           }
[16:20:54.796]                         }
[16:20:54.796]                       }
[16:20:54.796]                       invisible(muffled)
[16:20:54.796]                     }
[16:20:54.796]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.796]                   }
[16:20:54.796]                 }
[16:20:54.796]                 else {
[16:20:54.796]                   if (TRUE) {
[16:20:54.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.796]                     {
[16:20:54.796]                       inherits <- base::inherits
[16:20:54.796]                       invokeRestart <- base::invokeRestart
[16:20:54.796]                       is.null <- base::is.null
[16:20:54.796]                       muffled <- FALSE
[16:20:54.796]                       if (inherits(cond, "message")) {
[16:20:54.796]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.796]                         if (muffled) 
[16:20:54.796]                           invokeRestart("muffleMessage")
[16:20:54.796]                       }
[16:20:54.796]                       else if (inherits(cond, "warning")) {
[16:20:54.796]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.796]                         if (muffled) 
[16:20:54.796]                           invokeRestart("muffleWarning")
[16:20:54.796]                       }
[16:20:54.796]                       else if (inherits(cond, "condition")) {
[16:20:54.796]                         if (!is.null(pattern)) {
[16:20:54.796]                           computeRestarts <- base::computeRestarts
[16:20:54.796]                           grepl <- base::grepl
[16:20:54.796]                           restarts <- computeRestarts(cond)
[16:20:54.796]                           for (restart in restarts) {
[16:20:54.796]                             name <- restart$name
[16:20:54.796]                             if (is.null(name)) 
[16:20:54.796]                               next
[16:20:54.796]                             if (!grepl(pattern, name)) 
[16:20:54.796]                               next
[16:20:54.796]                             invokeRestart(restart)
[16:20:54.796]                             muffled <- TRUE
[16:20:54.796]                             break
[16:20:54.796]                           }
[16:20:54.796]                         }
[16:20:54.796]                       }
[16:20:54.796]                       invisible(muffled)
[16:20:54.796]                     }
[16:20:54.796]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.796]                   }
[16:20:54.796]                 }
[16:20:54.796]             }
[16:20:54.796]         }))
[16:20:54.796]     }, error = function(ex) {
[16:20:54.796]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:54.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.796]                 ...future.rng), started = ...future.startTime, 
[16:20:54.796]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:54.796]             version = "1.8"), class = "FutureResult")
[16:20:54.796]     }, finally = {
[16:20:54.796]         if (!identical(...future.workdir, getwd())) 
[16:20:54.796]             setwd(...future.workdir)
[16:20:54.796]         {
[16:20:54.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:54.796]                 ...future.oldOptions$nwarnings <- NULL
[16:20:54.796]             }
[16:20:54.796]             base::options(...future.oldOptions)
[16:20:54.796]             if (.Platform$OS.type == "windows") {
[16:20:54.796]                 old_names <- names(...future.oldEnvVars)
[16:20:54.796]                 envs <- base::Sys.getenv()
[16:20:54.796]                 names <- names(envs)
[16:20:54.796]                 common <- intersect(names, old_names)
[16:20:54.796]                 added <- setdiff(names, old_names)
[16:20:54.796]                 removed <- setdiff(old_names, names)
[16:20:54.796]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:54.796]                   envs[common]]
[16:20:54.796]                 NAMES <- toupper(changed)
[16:20:54.796]                 args <- list()
[16:20:54.796]                 for (kk in seq_along(NAMES)) {
[16:20:54.796]                   name <- changed[[kk]]
[16:20:54.796]                   NAME <- NAMES[[kk]]
[16:20:54.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.796]                     next
[16:20:54.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.796]                 }
[16:20:54.796]                 NAMES <- toupper(added)
[16:20:54.796]                 for (kk in seq_along(NAMES)) {
[16:20:54.796]                   name <- added[[kk]]
[16:20:54.796]                   NAME <- NAMES[[kk]]
[16:20:54.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.796]                     next
[16:20:54.796]                   args[[name]] <- ""
[16:20:54.796]                 }
[16:20:54.796]                 NAMES <- toupper(removed)
[16:20:54.796]                 for (kk in seq_along(NAMES)) {
[16:20:54.796]                   name <- removed[[kk]]
[16:20:54.796]                   NAME <- NAMES[[kk]]
[16:20:54.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.796]                     next
[16:20:54.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.796]                 }
[16:20:54.796]                 if (length(args) > 0) 
[16:20:54.796]                   base::do.call(base::Sys.setenv, args = args)
[16:20:54.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:54.796]             }
[16:20:54.796]             else {
[16:20:54.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:54.796]             }
[16:20:54.796]             {
[16:20:54.796]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:54.796]                   0L) {
[16:20:54.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:54.796]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:54.796]                   base::options(opts)
[16:20:54.796]                 }
[16:20:54.796]                 {
[16:20:54.796]                   {
[16:20:54.796]                     NULL
[16:20:54.796]                     RNGkind("Mersenne-Twister")
[16:20:54.796]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:54.796]                       inherits = FALSE)
[16:20:54.796]                   }
[16:20:54.796]                   options(future.plan = NULL)
[16:20:54.796]                   if (is.na(NA_character_)) 
[16:20:54.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:54.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:54.796]                     .init = FALSE)
[16:20:54.796]                 }
[16:20:54.796]             }
[16:20:54.796]         }
[16:20:54.796]     })
[16:20:54.796]     if (TRUE) {
[16:20:54.796]         base::sink(type = "output", split = FALSE)
[16:20:54.796]         if (TRUE) {
[16:20:54.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:54.796]         }
[16:20:54.796]         else {
[16:20:54.796]             ...future.result["stdout"] <- base::list(NULL)
[16:20:54.796]         }
[16:20:54.796]         base::close(...future.stdout)
[16:20:54.796]         ...future.stdout <- NULL
[16:20:54.796]     }
[16:20:54.796]     ...future.result$conditions <- ...future.conditions
[16:20:54.796]     ...future.result$finished <- base::Sys.time()
[16:20:54.796]     ...future.result
[16:20:54.796] }
[16:20:54.798] assign_globals() ...
[16:20:54.798] List of 1
[16:20:54.798]  $ data:'data.frame':	5 obs. of  2 variables:
[16:20:54.798]   ..$ x: int [1:5] 1 2 3 4 5
[16:20:54.798]   ..$ y: int [1:5] 1 2 3 4 5
[16:20:54.798]  - attr(*, "where")=List of 1
[16:20:54.798]   ..$ data:<environment: R_EmptyEnv> 
[16:20:54.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:54.798]  - attr(*, "resolved")= logi FALSE
[16:20:54.798]  - attr(*, "total_size")= num 160
[16:20:54.798]  - attr(*, "already-done")= logi TRUE
[16:20:54.803] - copied ‘data’ to environment
[16:20:54.803] assign_globals() ... done
[16:20:54.804] plan(): Setting new future strategy stack:
[16:20:54.804] List of future strategies:
[16:20:54.804] 1. sequential:
[16:20:54.804]    - args: function (..., envir = parent.frame())
[16:20:54.804]    - tweaked: FALSE
[16:20:54.804]    - call: NULL
[16:20:54.804] plan(): nbrOfWorkers() = 1
[16:20:54.805] plan(): Setting new future strategy stack:
[16:20:54.805] List of future strategies:
[16:20:54.805] 1. sequential:
[16:20:54.805]    - args: function (..., envir = parent.frame())
[16:20:54.805]    - tweaked: FALSE
[16:20:54.805]    - call: plan(strategy)
[16:20:54.805] plan(): nbrOfWorkers() = 1
[16:20:54.805] SequentialFuture started (and completed)
[16:20:54.806] - Launch lazy future ... done
[16:20:54.806] run() for ‘SequentialFuture’ ... done
[16:20:54.806] plan(): Setting new future strategy stack:
[16:20:54.806] List of future strategies:
[16:20:54.806] 1. sequential:
[16:20:54.806]    - args: function (..., envir = parent.frame())
[16:20:54.806]    - tweaked: FALSE
[16:20:54.806]    - call: plan(list(sequential, strategy))
[16:20:54.806] 2. sequential:
[16:20:54.806]    - args: function (..., envir = parent.frame())
[16:20:54.806]    - tweaked: FALSE
[16:20:54.806]    - call: plan(list(sequential, strategy))
[16:20:54.806] plan(): nbrOfWorkers() = 1
[16:20:54.807] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:54.807] Searching for globals...
[16:20:54.812] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[16:20:54.812] Searching for globals ... DONE
[16:20:54.812] Resolving globals: FALSE
[16:20:54.812] The total size of the 1 globals is 160 bytes (160 bytes)
[16:20:54.813] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[16:20:54.813] - globals: [1] ‘data’
[16:20:54.813] - packages: [1] ‘future’
[16:20:54.813] getGlobalsAndPackages() ... DONE
[16:20:54.813] run() for ‘Future’ ...
[16:20:54.814] - state: ‘created’
[16:20:54.814] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:54.814] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:54.814] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:54.814]   - Field: ‘label’
[16:20:54.814]   - Field: ‘local’
[16:20:54.814]   - Field: ‘owner’
[16:20:54.814]   - Field: ‘envir’
[16:20:54.815]   - Field: ‘packages’
[16:20:54.815]   - Field: ‘gc’
[16:20:54.815]   - Field: ‘conditions’
[16:20:54.815]   - Field: ‘expr’
[16:20:54.815]   - Field: ‘uuid’
[16:20:54.815]   - Field: ‘seed’
[16:20:54.815]   - Field: ‘version’
[16:20:54.815]   - Field: ‘result’
[16:20:54.815]   - Field: ‘asynchronous’
[16:20:54.815]   - Field: ‘calls’
[16:20:54.815]   - Field: ‘globals’
[16:20:54.816]   - Field: ‘stdout’
[16:20:54.816]   - Field: ‘earlySignal’
[16:20:54.816]   - Field: ‘lazy’
[16:20:54.816]   - Field: ‘state’
[16:20:54.816] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:54.816] - Launch lazy future ...
[16:20:54.816] Packages needed by the future expression (n = 1): ‘future’
[16:20:54.816] Packages needed by future strategies (n = 1): ‘future’
[16:20:54.817] {
[16:20:54.817]     {
[16:20:54.817]         {
[16:20:54.817]             ...future.startTime <- base::Sys.time()
[16:20:54.817]             {
[16:20:54.817]                 {
[16:20:54.817]                   {
[16:20:54.817]                     {
[16:20:54.817]                       base::local({
[16:20:54.817]                         has_future <- base::requireNamespace("future", 
[16:20:54.817]                           quietly = TRUE)
[16:20:54.817]                         if (has_future) {
[16:20:54.817]                           ns <- base::getNamespace("future")
[16:20:54.817]                           version <- ns[[".package"]][["version"]]
[16:20:54.817]                           if (is.null(version)) 
[16:20:54.817]                             version <- utils::packageVersion("future")
[16:20:54.817]                         }
[16:20:54.817]                         else {
[16:20:54.817]                           version <- NULL
[16:20:54.817]                         }
[16:20:54.817]                         if (!has_future || version < "1.8.0") {
[16:20:54.817]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:54.817]                             "", base::R.version$version.string), 
[16:20:54.817]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:54.817]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:54.817]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:54.817]                               "release", "version")], collapse = " "), 
[16:20:54.817]                             hostname = base::Sys.info()[["nodename"]])
[16:20:54.817]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:54.817]                             info)
[16:20:54.817]                           info <- base::paste(info, collapse = "; ")
[16:20:54.817]                           if (!has_future) {
[16:20:54.817]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:54.817]                               info)
[16:20:54.817]                           }
[16:20:54.817]                           else {
[16:20:54.817]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:54.817]                               info, version)
[16:20:54.817]                           }
[16:20:54.817]                           base::stop(msg)
[16:20:54.817]                         }
[16:20:54.817]                       })
[16:20:54.817]                     }
[16:20:54.817]                     base::local({
[16:20:54.817]                       for (pkg in "future") {
[16:20:54.817]                         base::loadNamespace(pkg)
[16:20:54.817]                         base::library(pkg, character.only = TRUE)
[16:20:54.817]                       }
[16:20:54.817]                     })
[16:20:54.817]                   }
[16:20:54.817]                   ...future.strategy.old <- future::plan("list")
[16:20:54.817]                   options(future.plan = NULL)
[16:20:54.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.817]                   future::plan(list(function (..., envir = parent.frame()) 
[16:20:54.817]                   {
[16:20:54.817]                     future <- SequentialFuture(..., envir = envir)
[16:20:54.817]                     if (!future$lazy) 
[16:20:54.817]                       future <- run(future)
[16:20:54.817]                     invisible(future)
[16:20:54.817]                   }), .cleanup = FALSE, .init = FALSE)
[16:20:54.817]                 }
[16:20:54.817]                 ...future.workdir <- getwd()
[16:20:54.817]             }
[16:20:54.817]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:54.817]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:54.817]         }
[16:20:54.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:54.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:54.817]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:54.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:54.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:54.817]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:54.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:54.817]             base::names(...future.oldOptions))
[16:20:54.817]     }
[16:20:54.817]     if (FALSE) {
[16:20:54.817]     }
[16:20:54.817]     else {
[16:20:54.817]         if (TRUE) {
[16:20:54.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:54.817]                 open = "w")
[16:20:54.817]         }
[16:20:54.817]         else {
[16:20:54.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:54.817]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:54.817]         }
[16:20:54.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:54.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:54.817]             base::sink(type = "output", split = FALSE)
[16:20:54.817]             base::close(...future.stdout)
[16:20:54.817]         }, add = TRUE)
[16:20:54.817]     }
[16:20:54.817]     ...future.frame <- base::sys.nframe()
[16:20:54.817]     ...future.conditions <- base::list()
[16:20:54.817]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:54.817]     if (FALSE) {
[16:20:54.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:54.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:54.817]     }
[16:20:54.817]     ...future.result <- base::tryCatch({
[16:20:54.817]         base::withCallingHandlers({
[16:20:54.817]             ...future.value <- base::withVisible(base::local({
[16:20:54.817]                 a %<-% subset(data, x < 3)$y
[16:20:54.817]                 a
[16:20:54.817]             }))
[16:20:54.817]             future::FutureResult(value = ...future.value$value, 
[16:20:54.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.817]                   ...future.rng), globalenv = if (FALSE) 
[16:20:54.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:54.817]                     ...future.globalenv.names))
[16:20:54.817]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:54.817]         }, condition = base::local({
[16:20:54.817]             c <- base::c
[16:20:54.817]             inherits <- base::inherits
[16:20:54.817]             invokeRestart <- base::invokeRestart
[16:20:54.817]             length <- base::length
[16:20:54.817]             list <- base::list
[16:20:54.817]             seq.int <- base::seq.int
[16:20:54.817]             signalCondition <- base::signalCondition
[16:20:54.817]             sys.calls <- base::sys.calls
[16:20:54.817]             `[[` <- base::`[[`
[16:20:54.817]             `+` <- base::`+`
[16:20:54.817]             `<<-` <- base::`<<-`
[16:20:54.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:54.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:54.817]                   3L)]
[16:20:54.817]             }
[16:20:54.817]             function(cond) {
[16:20:54.817]                 is_error <- inherits(cond, "error")
[16:20:54.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:54.817]                   NULL)
[16:20:54.817]                 if (is_error) {
[16:20:54.817]                   sessionInformation <- function() {
[16:20:54.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:54.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:54.817]                       search = base::search(), system = base::Sys.info())
[16:20:54.817]                   }
[16:20:54.817]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:54.817]                     cond$call), session = sessionInformation(), 
[16:20:54.817]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:54.817]                   signalCondition(cond)
[16:20:54.817]                 }
[16:20:54.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:54.817]                 "immediateCondition"))) {
[16:20:54.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:54.817]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:54.817]                   if (TRUE && !signal) {
[16:20:54.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.817]                     {
[16:20:54.817]                       inherits <- base::inherits
[16:20:54.817]                       invokeRestart <- base::invokeRestart
[16:20:54.817]                       is.null <- base::is.null
[16:20:54.817]                       muffled <- FALSE
[16:20:54.817]                       if (inherits(cond, "message")) {
[16:20:54.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.817]                         if (muffled) 
[16:20:54.817]                           invokeRestart("muffleMessage")
[16:20:54.817]                       }
[16:20:54.817]                       else if (inherits(cond, "warning")) {
[16:20:54.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.817]                         if (muffled) 
[16:20:54.817]                           invokeRestart("muffleWarning")
[16:20:54.817]                       }
[16:20:54.817]                       else if (inherits(cond, "condition")) {
[16:20:54.817]                         if (!is.null(pattern)) {
[16:20:54.817]                           computeRestarts <- base::computeRestarts
[16:20:54.817]                           grepl <- base::grepl
[16:20:54.817]                           restarts <- computeRestarts(cond)
[16:20:54.817]                           for (restart in restarts) {
[16:20:54.817]                             name <- restart$name
[16:20:54.817]                             if (is.null(name)) 
[16:20:54.817]                               next
[16:20:54.817]                             if (!grepl(pattern, name)) 
[16:20:54.817]                               next
[16:20:54.817]                             invokeRestart(restart)
[16:20:54.817]                             muffled <- TRUE
[16:20:54.817]                             break
[16:20:54.817]                           }
[16:20:54.817]                         }
[16:20:54.817]                       }
[16:20:54.817]                       invisible(muffled)
[16:20:54.817]                     }
[16:20:54.817]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.817]                   }
[16:20:54.817]                 }
[16:20:54.817]                 else {
[16:20:54.817]                   if (TRUE) {
[16:20:54.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.817]                     {
[16:20:54.817]                       inherits <- base::inherits
[16:20:54.817]                       invokeRestart <- base::invokeRestart
[16:20:54.817]                       is.null <- base::is.null
[16:20:54.817]                       muffled <- FALSE
[16:20:54.817]                       if (inherits(cond, "message")) {
[16:20:54.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.817]                         if (muffled) 
[16:20:54.817]                           invokeRestart("muffleMessage")
[16:20:54.817]                       }
[16:20:54.817]                       else if (inherits(cond, "warning")) {
[16:20:54.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.817]                         if (muffled) 
[16:20:54.817]                           invokeRestart("muffleWarning")
[16:20:54.817]                       }
[16:20:54.817]                       else if (inherits(cond, "condition")) {
[16:20:54.817]                         if (!is.null(pattern)) {
[16:20:54.817]                           computeRestarts <- base::computeRestarts
[16:20:54.817]                           grepl <- base::grepl
[16:20:54.817]                           restarts <- computeRestarts(cond)
[16:20:54.817]                           for (restart in restarts) {
[16:20:54.817]                             name <- restart$name
[16:20:54.817]                             if (is.null(name)) 
[16:20:54.817]                               next
[16:20:54.817]                             if (!grepl(pattern, name)) 
[16:20:54.817]                               next
[16:20:54.817]                             invokeRestart(restart)
[16:20:54.817]                             muffled <- TRUE
[16:20:54.817]                             break
[16:20:54.817]                           }
[16:20:54.817]                         }
[16:20:54.817]                       }
[16:20:54.817]                       invisible(muffled)
[16:20:54.817]                     }
[16:20:54.817]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.817]                   }
[16:20:54.817]                 }
[16:20:54.817]             }
[16:20:54.817]         }))
[16:20:54.817]     }, error = function(ex) {
[16:20:54.817]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:54.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.817]                 ...future.rng), started = ...future.startTime, 
[16:20:54.817]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:54.817]             version = "1.8"), class = "FutureResult")
[16:20:54.817]     }, finally = {
[16:20:54.817]         if (!identical(...future.workdir, getwd())) 
[16:20:54.817]             setwd(...future.workdir)
[16:20:54.817]         {
[16:20:54.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:54.817]                 ...future.oldOptions$nwarnings <- NULL
[16:20:54.817]             }
[16:20:54.817]             base::options(...future.oldOptions)
[16:20:54.817]             if (.Platform$OS.type == "windows") {
[16:20:54.817]                 old_names <- names(...future.oldEnvVars)
[16:20:54.817]                 envs <- base::Sys.getenv()
[16:20:54.817]                 names <- names(envs)
[16:20:54.817]                 common <- intersect(names, old_names)
[16:20:54.817]                 added <- setdiff(names, old_names)
[16:20:54.817]                 removed <- setdiff(old_names, names)
[16:20:54.817]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:54.817]                   envs[common]]
[16:20:54.817]                 NAMES <- toupper(changed)
[16:20:54.817]                 args <- list()
[16:20:54.817]                 for (kk in seq_along(NAMES)) {
[16:20:54.817]                   name <- changed[[kk]]
[16:20:54.817]                   NAME <- NAMES[[kk]]
[16:20:54.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.817]                     next
[16:20:54.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.817]                 }
[16:20:54.817]                 NAMES <- toupper(added)
[16:20:54.817]                 for (kk in seq_along(NAMES)) {
[16:20:54.817]                   name <- added[[kk]]
[16:20:54.817]                   NAME <- NAMES[[kk]]
[16:20:54.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.817]                     next
[16:20:54.817]                   args[[name]] <- ""
[16:20:54.817]                 }
[16:20:54.817]                 NAMES <- toupper(removed)
[16:20:54.817]                 for (kk in seq_along(NAMES)) {
[16:20:54.817]                   name <- removed[[kk]]
[16:20:54.817]                   NAME <- NAMES[[kk]]
[16:20:54.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.817]                     next
[16:20:54.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.817]                 }
[16:20:54.817]                 if (length(args) > 0) 
[16:20:54.817]                   base::do.call(base::Sys.setenv, args = args)
[16:20:54.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:54.817]             }
[16:20:54.817]             else {
[16:20:54.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:54.817]             }
[16:20:54.817]             {
[16:20:54.817]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:54.817]                   0L) {
[16:20:54.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:54.817]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:54.817]                   base::options(opts)
[16:20:54.817]                 }
[16:20:54.817]                 {
[16:20:54.817]                   {
[16:20:54.817]                     NULL
[16:20:54.817]                     RNGkind("Mersenne-Twister")
[16:20:54.817]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:54.817]                       inherits = FALSE)
[16:20:54.817]                   }
[16:20:54.817]                   options(future.plan = NULL)
[16:20:54.817]                   if (is.na(NA_character_)) 
[16:20:54.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:54.817]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:54.817]                     .init = FALSE)
[16:20:54.817]                 }
[16:20:54.817]             }
[16:20:54.817]         }
[16:20:54.817]     })
[16:20:54.817]     if (TRUE) {
[16:20:54.817]         base::sink(type = "output", split = FALSE)
[16:20:54.817]         if (TRUE) {
[16:20:54.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:54.817]         }
[16:20:54.817]         else {
[16:20:54.817]             ...future.result["stdout"] <- base::list(NULL)
[16:20:54.817]         }
[16:20:54.817]         base::close(...future.stdout)
[16:20:54.817]         ...future.stdout <- NULL
[16:20:54.817]     }
[16:20:54.817]     ...future.result$conditions <- ...future.conditions
[16:20:54.817]     ...future.result$finished <- base::Sys.time()
[16:20:54.817]     ...future.result
[16:20:54.817] }
[16:20:54.818] assign_globals() ...
[16:20:54.818] List of 1
[16:20:54.818]  $ data:'data.frame':	5 obs. of  2 variables:
[16:20:54.818]   ..$ x: int [1:5] 1 2 3 4 5
[16:20:54.818]   ..$ y: int [1:5] 1 2 3 4 5
[16:20:54.818]  - attr(*, "where")=List of 1
[16:20:54.818]   ..$ data:<environment: R_EmptyEnv> 
[16:20:54.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:54.818]  - attr(*, "resolved")= logi FALSE
[16:20:54.818]  - attr(*, "total_size")= num 160
[16:20:54.818]  - attr(*, "already-done")= logi TRUE
[16:20:54.823] - copied ‘data’ to environment
[16:20:54.823] assign_globals() ... done
[16:20:54.823] plan(): Setting new future strategy stack:
[16:20:54.824] List of future strategies:
[16:20:54.824] 1. sequential:
[16:20:54.824]    - args: function (..., envir = parent.frame())
[16:20:54.824]    - tweaked: FALSE
[16:20:54.824]    - call: plan(list(sequential, strategy))
[16:20:54.824] plan(): nbrOfWorkers() = 1
[16:20:54.852] plan(): Setting new future strategy stack:
[16:20:54.852] List of future strategies:
[16:20:54.852] 1. sequential:
[16:20:54.852]    - args: function (..., envir = parent.frame())
[16:20:54.852]    - tweaked: FALSE
[16:20:54.852]    - call: plan(list(sequential, strategy))
[16:20:54.852] 2. sequential:
[16:20:54.852]    - args: function (..., envir = parent.frame())
[16:20:54.852]    - tweaked: FALSE
[16:20:54.852]    - call: plan(list(sequential, strategy))
[16:20:54.852] plan(): nbrOfWorkers() = 1
[16:20:54.852] SequentialFuture started (and completed)
[16:20:54.852] signalConditions() ...
[16:20:54.852]  - include = ‘immediateCondition’
[16:20:54.853]  - exclude = 
[16:20:54.853]  - resignal = FALSE
[16:20:54.853]  - Number of conditions: 53
[16:20:54.853] signalConditions() ... done
[16:20:54.853] - Launch lazy future ... done
[16:20:54.853] run() for ‘SequentialFuture’ ... done
[16:20:54.853] signalConditions() ...
[16:20:54.853]  - include = ‘immediateCondition’
[16:20:54.853]  - exclude = 
[16:20:54.853]  - resignal = FALSE
[16:20:54.853]  - Number of conditions: 53
[16:20:54.854] signalConditions() ... done
[16:20:54.854] Future state: ‘finished’
[16:20:54.854] signalConditions() ...
[16:20:54.854]  - include = ‘condition’
[16:20:54.854]  - exclude = ‘immediateCondition’
[16:20:54.854]  - resignal = TRUE
[16:20:54.854]  - Number of conditions: 53
[16:20:54.854]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.824] getGlobalsAndPackages() ...
[16:20:54.854]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:54.854]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.837] Searching for globals...
[16:20:54.855]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.838] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[16:20:54.855]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.838] Searching for globals ... DONE
[16:20:54.855]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.838] Resolving globals: FALSE
[16:20:54.855]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.839] The total size of the 1 globals is 160 bytes (160 bytes)
[16:20:54.855]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.840] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[16:20:54.855]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.840] - globals: [1] ‘data’
[16:20:54.855]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.840] 
[16:20:54.855]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.840] getGlobalsAndPackages() ... DONE
[16:20:54.856]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.841] run() for ‘Future’ ...
[16:20:54.856]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.841] - state: ‘created’
[16:20:54.856]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.841] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:54.856]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.841] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:54.856]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:54.856]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.841]   - Field: ‘label’
[16:20:54.856]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘local’
[16:20:54.857]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘owner’
[16:20:54.857]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘envir’
[16:20:54.857]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘packages’
[16:20:54.857]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘gc’
[16:20:54.857]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘conditions’
[16:20:54.857]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘expr’
[16:20:54.857]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘uuid’
[16:20:54.857]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘seed’
[16:20:54.858]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.842]   - Field: ‘version’
[16:20:54.858]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843]   - Field: ‘result’
[16:20:54.858]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843]   - Field: ‘asynchronous’
[16:20:54.858]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843]   - Field: ‘calls’
[16:20:54.858]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843]   - Field: ‘globals’
[16:20:54.858]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843]   - Field: ‘stdout’
[16:20:54.858]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843]   - Field: ‘earlySignal’
[16:20:54.858]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843]   - Field: ‘lazy’
[16:20:54.859]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843]   - Field: ‘state’
[16:20:54.859]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:54.859]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.843] - Launch lazy future ...
[16:20:54.859]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.844] Packages needed by the future expression (n = 0): <none>
[16:20:54.859]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.844] Packages needed by future strategies (n = 0): <none>
[16:20:54.859]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.844] {
[16:20:54.844]     {
[16:20:54.844]         {
[16:20:54.844]             ...future.startTime <- base::Sys.time()
[16:20:54.844]             {
[16:20:54.844]                 {
[16:20:54.844]                   {
[16:20:54.844]                     base::local({
[16:20:54.844]                       has_future <- base::requireNamespace("future", 
[16:20:54.844]                         quietly = TRUE)
[16:20:54.844]                       if (has_future) {
[16:20:54.844]                         ns <- base::getNamespace("future")
[16:20:54.844]                         version <- ns[[".package"]][["version"]]
[16:20:54.844]                         if (is.null(version)) 
[16:20:54.844]                           version <- utils::packageVersion("future")
[16:20:54.844]                       }
[16:20:54.844]                       else {
[16:20:54.844]                         version <- NULL
[16:20:54.844]                       }
[16:20:54.844]                       if (!has_future || version < "1.8.0") {
[16:20:54.844]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:54.844]                           "", base::R.version$version.string), 
[16:20:54.844]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:54.844]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:54.844]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:54.844]                             "release", "version")], collapse = " "), 
[16:20:54.844]                           hostname = base::Sys.info()[["nodename"]])
[16:20:54.844]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:54.844]                           info)
[16:20:54.844]                         info <- base::paste(info, collapse = "; ")
[16:20:54.844]                         if (!has_future) {
[16:20:54.844]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:54.844]                             info)
[16:20:54.844]                         }
[16:20:54.844]                         else {
[16:20:54.844]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:54.844]                             info, version)
[16:20:54.844]                         }
[16:20:54.844]                         base::stop(msg)
[16:20:54.844]                       }
[16:20:54.844]                     })
[16:20:54.844]                   }
[16:20:54.844]                   ...future.strategy.old <- future::plan("list")
[16:20:54.844]                   options(future.plan = NULL)
[16:20:54.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:54.844]                 }
[16:20:54.844]                 ...future.workdir <- getwd()
[16:20:54.844]             }
[16:20:54.844]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:54.844]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:54.844]         }
[16:20:54.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:54.844]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:54.844]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:54.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:54.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:54.844]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:54.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:54.844]             base::names(...future.oldOptions))
[16:20:54.844]     }
[16:20:54.844]     if (FALSE) {
[16:20:54.844]     }
[16:20:54.844]     else {
[16:20:54.844]         if (TRUE) {
[16:20:54.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:54.844]                 open = "w")
[16:20:54.844]         }
[16:20:54.844]         else {
[16:20:54.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:54.844]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:54.844]         }
[16:20:54.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:54.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:54.844]             base::sink(type = "output", split = FALSE)
[16:20:54.844]             base::close(...future.stdout)
[16:20:54.844]         }, add = TRUE)
[16:20:54.844]     }
[16:20:54.844]     ...future.frame <- base::sys.nframe()
[16:20:54.844]     ...future.conditions <- base::list()
[16:20:54.844]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:54.844]     if (FALSE) {
[16:20:54.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:54.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:54.844]     }
[16:20:54.844]     ...future.result <- base::tryCatch({
[16:20:54.844]         base::withCallingHandlers({
[16:20:54.844]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:20:54.844]                 x < 3)$y))
[16:20:54.844]             future::FutureResult(value = ...future.value$value, 
[16:20:54.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.844]                   ...future.rng), globalenv = if (FALSE) 
[16:20:54.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:54.844]                     ...future.globalenv.names))
[16:20:54.844]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:54.844]         }, condition = base::local({
[16:20:54.844]             c <- base::c
[16:20:54.844]             inherits <- base::inherits
[16:20:54.844]             invokeRestart <- base::invokeRestart
[16:20:54.844]             length <- base::length
[16:20:54.844]             list <- base::list
[16:20:54.844]             seq.int <- base::seq.int
[16:20:54.844]             signalCondition <- base::signalCondition
[16:20:54.844]             sys.calls <- base::sys.calls
[16:20:54.844]             `[[` <- base::`[[`
[16:20:54.844]             `+` <- base::`+`
[16:20:54.844]             `<<-` <- base::`<<-`
[16:20:54.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:54.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:54.844]                   3L)]
[16:20:54.844]             }
[16:20:54.844]             function(cond) {
[16:20:54.844]                 is_error <- inherits(cond, "error")
[16:20:54.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:54.844]                   NULL)
[16:20:54.844]                 if (is_error) {
[16:20:54.844]                   sessionInformation <- function() {
[16:20:54.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:54.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:54.844]                       search = base::search(), system = base::Sys.info())
[16:20:54.844]                   }
[16:20:54.844]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:54.844]                     cond$call), session = sessionInformation(), 
[16:20:54.844]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:54.844]                   signalCondition(cond)
[16:20:54.844]                 }
[16:20:54.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:54.844]                 "immediateCondition"))) {
[16:20:54.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:54.844]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:54.844]                   if (TRUE && !signal) {
[16:20:54.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.844]                     {
[16:20:54.844]                       inherits <- base::inherits
[16:20:54.844]                       invokeRestart <- base::invokeRestart
[16:20:54.844]                       is.null <- base::is.null
[16:20:54.844]                       muffled <- FALSE
[16:20:54.844]                       if (inherits(cond, "message")) {
[16:20:54.844]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.844]                         if (muffled) 
[16:20:54.844]                           invokeRestart("muffleMessage")
[16:20:54.844]                       }
[16:20:54.844]                       else if (inherits(cond, "warning")) {
[16:20:54.844]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.844]                         if (muffled) 
[16:20:54.844]                           invokeRestart("muffleWarning")
[16:20:54.844]                       }
[16:20:54.844]                       else if (inherits(cond, "condition")) {
[16:20:54.844]                         if (!is.null(pattern)) {
[16:20:54.844]                           computeRestarts <- base::computeRestarts
[16:20:54.844]                           grepl <- base::grepl
[16:20:54.844]                           restarts <- computeRestarts(cond)
[16:20:54.844]                           for (restart in restarts) {
[16:20:54.844]                             name <- restart$name
[16:20:54.844]                             if (is.null(name)) 
[16:20:54.844]                               next
[16:20:54.844]                             if (!grepl(pattern, name)) 
[16:20:54.844]                               next
[16:20:54.844]                             invokeRestart(restart)
[16:20:54.844]                             muffled <- TRUE
[16:20:54.844]                             break
[16:20:54.844]                           }
[16:20:54.844]                         }
[16:20:54.844]                       }
[16:20:54.844]                       invisible(muffled)
[16:20:54.844]                     }
[16:20:54.844]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.844]                   }
[16:20:54.844]                 }
[16:20:54.844]                 else {
[16:20:54.844]                   if (TRUE) {
[16:20:54.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.844]                     {
[16:20:54.844]                       inherits <- base::inherits
[16:20:54.844]                       invokeRestart <- base::invokeRestart
[16:20:54.844]                       is.null <- base::is.null
[16:20:54.844]                       muffled <- FALSE
[16:20:54.844]                       if (inherits(cond, "message")) {
[16:20:54.844]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.844]                         if (muffled) 
[16:20:54.844]                           invokeRestart("muffleMessage")
[16:20:54.844]                       }
[16:20:54.844]                       else if (inherits(cond, "warning")) {
[16:20:54.844]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.844]                         if (muffled) 
[16:20:54.844]                           invokeRestart("muffleWarning")
[16:20:54.844]                       }
[16:20:54.844]                       else if (inherits(cond, "condition")) {
[16:20:54.844]                         if (!is.null(pattern)) {
[16:20:54.844]                           computeRestarts <- base::computeRestarts
[16:20:54.844]                           grepl <- base::grepl
[16:20:54.844]                           restarts <- computeRestarts(cond)
[16:20:54.844]                           for (restart in restarts) {
[16:20:54.844]                             name <- restart$name
[16:20:54.844]                             if (is.null(name)) 
[16:20:54.844]                               next
[16:20:54.844]                             if (!grepl(pattern, name)) 
[16:20:54.844]                               next
[16:20:54.844]                             invokeRestart(restart)
[16:20:54.844]                             muffled <- TRUE
[16:20:54.844]                             break
[16:20:54.844]                           }
[16:20:54.844]                         }
[16:20:54.844]                       }
[16:20:54.844]                       invisible(muffled)
[16:20:54.844]                     }
[16:20:54.844]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.844]                   }
[16:20:54.844]                 }
[16:20:54.844]             }
[16:20:54.844]         }))
[16:20:54.844]     }, error = function(ex) {
[16:20:54.844]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:54.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.844]                 ...future.rng), started = ...future.startTime, 
[16:20:54.844]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:54.844]             version = "1.8"), class = "FutureResult")
[16:20:54.844]     }, finally = {
[16:20:54.844]         if (!identical(...future.workdir, getwd())) 
[16:20:54.844]             setwd(...future.workdir)
[16:20:54.844]         {
[16:20:54.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:54.844]                 ...future.oldOptions$nwarnings <- NULL
[16:20:54.844]             }
[16:20:54.844]             base::options(...future.oldOptions)
[16:20:54.844]             if (.Platform$OS.type == "windows") {
[16:20:54.844]                 old_names <- names(...future.oldEnvVars)
[16:20:54.844]                 envs <- base::Sys.getenv()
[16:20:54.844]                 names <- names(envs)
[16:20:54.844]                 common <- intersect(names, old_names)
[16:20:54.844]                 added <- setdiff(names, old_names)
[16:20:54.844]                 removed <- setdiff(old_names, names)
[16:20:54.844]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:54.844]                   envs[common]]
[16:20:54.844]                 NAMES <- toupper(changed)
[16:20:54.844]                 args <- list()
[16:20:54.844]                 for (kk in seq_along(NAMES)) {
[16:20:54.844]                   name <- changed[[kk]]
[16:20:54.844]                   NAME <- NAMES[[kk]]
[16:20:54.844]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.844]                     next
[16:20:54.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.844]                 }
[16:20:54.844]                 NAMES <- toupper(added)
[16:20:54.844]                 for (kk in seq_along(NAMES)) {
[16:20:54.844]                   name <- added[[kk]]
[16:20:54.844]                   NAME <- NAMES[[kk]]
[16:20:54.844]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.844]                     next
[16:20:54.844]                   args[[name]] <- ""
[16:20:54.844]                 }
[16:20:54.844]                 NAMES <- toupper(removed)
[16:20:54.844]                 for (kk in seq_along(NAMES)) {
[16:20:54.844]                   name <- removed[[kk]]
[16:20:54.844]                   NAME <- NAMES[[kk]]
[16:20:54.844]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.844]                     next
[16:20:54.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.844]                 }
[16:20:54.844]                 if (length(args) > 0) 
[16:20:54.844]                   base::do.call(base::Sys.setenv, args = args)
[16:20:54.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:54.844]             }
[16:20:54.844]             else {
[16:20:54.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:54.844]             }
[16:20:54.844]             {
[16:20:54.844]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:54.844]                   0L) {
[16:20:54.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:54.844]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:54.844]                   base::options(opts)
[16:20:54.844]                 }
[16:20:54.844]                 {
[16:20:54.844]                   {
[16:20:54.844]                     NULL
[16:20:54.844]                     RNGkind("Mersenne-Twister")
[16:20:54.844]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:54.844]                       inherits = FALSE)
[16:20:54.844]                   }
[16:20:54.844]                   options(future.plan = NULL)
[16:20:54.844]                   if (is.na(NA_character_)) 
[16:20:54.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:54.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:54.844]                     .init = FALSE)
[16:20:54.844]                 }
[16:20:54.844]             }
[16:20:54.844]         }
[16:20:54.844]     })
[16:20:54.844]     if (TRUE) {
[16:20:54.844]         base::sink(type = "output", split = FALSE)
[16:20:54.844]         if (TRUE) {
[16:20:54.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:54.844]         }
[16:20:54.844]         else {
[16:20:54.844]             ...future.result["stdout"] <- base::list(NULL)
[16:20:54.844]         }
[16:20:54.844]         base::close(...future.stdout)
[16:20:54.844]         ...future.stdout <- NULL
[16:20:54.844]     }
[16:20:54.844]     ...future.result$conditions <- ...future.conditions
[16:20:54.844]     ...future.result$finished <- base::Sys.time()
[16:20:54.844]     ...future.result
[16:20:54.844] }
[16:20:54.859]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.846] assign_globals() ...
[16:20:54.859]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.846] List of 1
[16:20:54.846]  $ data:'data.frame':	5 obs. of  2 variables:
[16:20:54.846]   ..$ x: int [1:5] 1 2 3 4 5
[16:20:54.846]   ..$ y: int [1:5] 1 2 3 4 5
[16:20:54.846]  - attr(*, "where")=List of 1
[16:20:54.846]   ..$ data:<environment: R_EmptyEnv> 
[16:20:54.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:54.846]  - attr(*, "resolved")= logi FALSE
[16:20:54.846]  - attr(*, "total_size")= num 160
[16:20:54.846]  - attr(*, "already-done")= logi TRUE
[16:20:54.860]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.849] - copied ‘data’ to environment
[16:20:54.860]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.849] assign_globals() ... done
[16:20:54.860]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.849] plan(): Setting new future strategy stack:
[16:20:54.860]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.849] List of future strategies:
[16:20:54.849] 1. sequential:
[16:20:54.849]    - args: function (..., envir = parent.frame())
[16:20:54.849]    - tweaked: FALSE
[16:20:54.849]    - call: NULL
[16:20:54.860]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.849] plan(): nbrOfWorkers() = 1
[16:20:54.860]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.850] plan(): Setting new future strategy stack:
[16:20:54.860]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.850] List of future strategies:
[16:20:54.850] 1. sequential:
[16:20:54.850]    - args: function (..., envir = parent.frame())
[16:20:54.850]    - tweaked: FALSE
[16:20:54.850]    - call: plan(list(sequential, strategy))
[16:20:54.860]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.851] plan(): nbrOfWorkers() = 1
[16:20:54.861]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.851] SequentialFuture started (and completed)
[16:20:54.861]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.851] - Launch lazy future ... done
[16:20:54.861]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.851] run() for ‘SequentialFuture’ ... done
[16:20:54.861] signalConditions() ... done
- Strategy: sequential ... DONE
- Strategy: multicore ...
[16:20:54.861] plan(): Setting new future strategy stack:
[16:20:54.862] List of future strategies:
[16:20:54.862] 1. multicore:
[16:20:54.862]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:54.862]    - tweaked: FALSE
[16:20:54.862]    - call: plan(strategy)
[16:20:54.865] plan(): nbrOfWorkers() = 2
[16:20:54.867] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:20:54.867] Searching for globals...
[16:20:54.867] - globals found: [1] ‘getOption’
[16:20:54.868] Searching for globals ... DONE
[16:20:54.868] Resolving globals: FALSE
[16:20:54.868] 
[16:20:54.868] 
[16:20:54.868] getGlobalsAndPackages() ... DONE
[16:20:54.868] run() for ‘Future’ ...
[16:20:54.868] - state: ‘created’
[16:20:54.869] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:54.872] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:54.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:54.872]   - Field: ‘label’
[16:20:54.872]   - Field: ‘local’
[16:20:54.872]   - Field: ‘owner’
[16:20:54.873]   - Field: ‘envir’
[16:20:54.873]   - Field: ‘workers’
[16:20:54.873]   - Field: ‘packages’
[16:20:54.873]   - Field: ‘gc’
[16:20:54.873]   - Field: ‘job’
[16:20:54.873]   - Field: ‘conditions’
[16:20:54.873]   - Field: ‘expr’
[16:20:54.873]   - Field: ‘uuid’
[16:20:54.873]   - Field: ‘seed’
[16:20:54.873]   - Field: ‘version’
[16:20:54.873]   - Field: ‘result’
[16:20:54.874]   - Field: ‘asynchronous’
[16:20:54.874]   - Field: ‘calls’
[16:20:54.874]   - Field: ‘globals’
[16:20:54.874]   - Field: ‘stdout’
[16:20:54.874]   - Field: ‘earlySignal’
[16:20:54.874]   - Field: ‘lazy’
[16:20:54.874]   - Field: ‘state’
[16:20:54.874] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:54.874] - Launch lazy future ...
[16:20:54.875] Packages needed by the future expression (n = 0): <none>
[16:20:54.875] Packages needed by future strategies (n = 0): <none>
[16:20:54.876] {
[16:20:54.876]     {
[16:20:54.876]         {
[16:20:54.876]             ...future.startTime <- base::Sys.time()
[16:20:54.876]             {
[16:20:54.876]                 {
[16:20:54.876]                   {
[16:20:54.876]                     {
[16:20:54.876]                       base::local({
[16:20:54.876]                         has_future <- base::requireNamespace("future", 
[16:20:54.876]                           quietly = TRUE)
[16:20:54.876]                         if (has_future) {
[16:20:54.876]                           ns <- base::getNamespace("future")
[16:20:54.876]                           version <- ns[[".package"]][["version"]]
[16:20:54.876]                           if (is.null(version)) 
[16:20:54.876]                             version <- utils::packageVersion("future")
[16:20:54.876]                         }
[16:20:54.876]                         else {
[16:20:54.876]                           version <- NULL
[16:20:54.876]                         }
[16:20:54.876]                         if (!has_future || version < "1.8.0") {
[16:20:54.876]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:54.876]                             "", base::R.version$version.string), 
[16:20:54.876]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:54.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:54.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:54.876]                               "release", "version")], collapse = " "), 
[16:20:54.876]                             hostname = base::Sys.info()[["nodename"]])
[16:20:54.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:54.876]                             info)
[16:20:54.876]                           info <- base::paste(info, collapse = "; ")
[16:20:54.876]                           if (!has_future) {
[16:20:54.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:54.876]                               info)
[16:20:54.876]                           }
[16:20:54.876]                           else {
[16:20:54.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:54.876]                               info, version)
[16:20:54.876]                           }
[16:20:54.876]                           base::stop(msg)
[16:20:54.876]                         }
[16:20:54.876]                       })
[16:20:54.876]                     }
[16:20:54.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:54.876]                     base::options(mc.cores = 1L)
[16:20:54.876]                   }
[16:20:54.876]                   ...future.strategy.old <- future::plan("list")
[16:20:54.876]                   options(future.plan = NULL)
[16:20:54.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:54.876]                 }
[16:20:54.876]                 ...future.workdir <- getwd()
[16:20:54.876]             }
[16:20:54.876]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:54.876]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:54.876]         }
[16:20:54.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:20:54.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:54.876]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:20:54.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:54.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:54.876]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:54.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:54.876]             base::names(...future.oldOptions))
[16:20:54.876]     }
[16:20:54.876]     if (FALSE) {
[16:20:54.876]     }
[16:20:54.876]     else {
[16:20:54.876]         if (TRUE) {
[16:20:54.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:54.876]                 open = "w")
[16:20:54.876]         }
[16:20:54.876]         else {
[16:20:54.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:54.876]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:54.876]         }
[16:20:54.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:54.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:54.876]             base::sink(type = "output", split = FALSE)
[16:20:54.876]             base::close(...future.stdout)
[16:20:54.876]         }, add = TRUE)
[16:20:54.876]     }
[16:20:54.876]     ...future.frame <- base::sys.nframe()
[16:20:54.876]     ...future.conditions <- base::list()
[16:20:54.876]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:54.876]     if (FALSE) {
[16:20:54.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:54.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:54.876]     }
[16:20:54.876]     ...future.result <- base::tryCatch({
[16:20:54.876]         base::withCallingHandlers({
[16:20:54.876]             ...future.value <- base::withVisible(base::local({
[16:20:54.876]                 withCallingHandlers({
[16:20:54.876]                   getOption("future.globals.onMissing")
[16:20:54.876]                 }, immediateCondition = function(cond) {
[16:20:54.876]                   save_rds <- function (object, pathname, ...) 
[16:20:54.876]                   {
[16:20:54.876]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:54.876]                     if (file_test("-f", pathname_tmp)) {
[16:20:54.876]                       fi_tmp <- file.info(pathname_tmp)
[16:20:54.876]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:54.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:54.876]                         fi_tmp[["mtime"]])
[16:20:54.876]                     }
[16:20:54.876]                     tryCatch({
[16:20:54.876]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:54.876]                     }, error = function(ex) {
[16:20:54.876]                       msg <- conditionMessage(ex)
[16:20:54.876]                       fi_tmp <- file.info(pathname_tmp)
[16:20:54.876]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:54.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:54.876]                         fi_tmp[["mtime"]], msg)
[16:20:54.876]                       ex$message <- msg
[16:20:54.876]                       stop(ex)
[16:20:54.876]                     })
[16:20:54.876]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:54.876]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:54.876]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:54.876]                       fi_tmp <- file.info(pathname_tmp)
[16:20:54.876]                       fi <- file.info(pathname)
[16:20:54.876]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:54.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:54.876]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:54.876]                         fi[["size"]], fi[["mtime"]])
[16:20:54.876]                       stop(msg)
[16:20:54.876]                     }
[16:20:54.876]                     invisible(pathname)
[16:20:54.876]                   }
[16:20:54.876]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:54.876]                     rootPath = tempdir()) 
[16:20:54.876]                   {
[16:20:54.876]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:54.876]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:54.876]                       tmpdir = path, fileext = ".rds")
[16:20:54.876]                     save_rds(obj, file)
[16:20:54.876]                   }
[16:20:54.876]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6LbKVK/.future/immediateConditions")
[16:20:54.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.876]                   {
[16:20:54.876]                     inherits <- base::inherits
[16:20:54.876]                     invokeRestart <- base::invokeRestart
[16:20:54.876]                     is.null <- base::is.null
[16:20:54.876]                     muffled <- FALSE
[16:20:54.876]                     if (inherits(cond, "message")) {
[16:20:54.876]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:54.876]                       if (muffled) 
[16:20:54.876]                         invokeRestart("muffleMessage")
[16:20:54.876]                     }
[16:20:54.876]                     else if (inherits(cond, "warning")) {
[16:20:54.876]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:54.876]                       if (muffled) 
[16:20:54.876]                         invokeRestart("muffleWarning")
[16:20:54.876]                     }
[16:20:54.876]                     else if (inherits(cond, "condition")) {
[16:20:54.876]                       if (!is.null(pattern)) {
[16:20:54.876]                         computeRestarts <- base::computeRestarts
[16:20:54.876]                         grepl <- base::grepl
[16:20:54.876]                         restarts <- computeRestarts(cond)
[16:20:54.876]                         for (restart in restarts) {
[16:20:54.876]                           name <- restart$name
[16:20:54.876]                           if (is.null(name)) 
[16:20:54.876]                             next
[16:20:54.876]                           if (!grepl(pattern, name)) 
[16:20:54.876]                             next
[16:20:54.876]                           invokeRestart(restart)
[16:20:54.876]                           muffled <- TRUE
[16:20:54.876]                           break
[16:20:54.876]                         }
[16:20:54.876]                       }
[16:20:54.876]                     }
[16:20:54.876]                     invisible(muffled)
[16:20:54.876]                   }
[16:20:54.876]                   muffleCondition(cond)
[16:20:54.876]                 })
[16:20:54.876]             }))
[16:20:54.876]             future::FutureResult(value = ...future.value$value, 
[16:20:54.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.876]                   ...future.rng), globalenv = if (FALSE) 
[16:20:54.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:54.876]                     ...future.globalenv.names))
[16:20:54.876]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:54.876]         }, condition = base::local({
[16:20:54.876]             c <- base::c
[16:20:54.876]             inherits <- base::inherits
[16:20:54.876]             invokeRestart <- base::invokeRestart
[16:20:54.876]             length <- base::length
[16:20:54.876]             list <- base::list
[16:20:54.876]             seq.int <- base::seq.int
[16:20:54.876]             signalCondition <- base::signalCondition
[16:20:54.876]             sys.calls <- base::sys.calls
[16:20:54.876]             `[[` <- base::`[[`
[16:20:54.876]             `+` <- base::`+`
[16:20:54.876]             `<<-` <- base::`<<-`
[16:20:54.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:54.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:54.876]                   3L)]
[16:20:54.876]             }
[16:20:54.876]             function(cond) {
[16:20:54.876]                 is_error <- inherits(cond, "error")
[16:20:54.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:54.876]                   NULL)
[16:20:54.876]                 if (is_error) {
[16:20:54.876]                   sessionInformation <- function() {
[16:20:54.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:54.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:54.876]                       search = base::search(), system = base::Sys.info())
[16:20:54.876]                   }
[16:20:54.876]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:54.876]                     cond$call), session = sessionInformation(), 
[16:20:54.876]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:54.876]                   signalCondition(cond)
[16:20:54.876]                 }
[16:20:54.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:54.876]                 "immediateCondition"))) {
[16:20:54.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:54.876]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:54.876]                   if (TRUE && !signal) {
[16:20:54.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.876]                     {
[16:20:54.876]                       inherits <- base::inherits
[16:20:54.876]                       invokeRestart <- base::invokeRestart
[16:20:54.876]                       is.null <- base::is.null
[16:20:54.876]                       muffled <- FALSE
[16:20:54.876]                       if (inherits(cond, "message")) {
[16:20:54.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.876]                         if (muffled) 
[16:20:54.876]                           invokeRestart("muffleMessage")
[16:20:54.876]                       }
[16:20:54.876]                       else if (inherits(cond, "warning")) {
[16:20:54.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.876]                         if (muffled) 
[16:20:54.876]                           invokeRestart("muffleWarning")
[16:20:54.876]                       }
[16:20:54.876]                       else if (inherits(cond, "condition")) {
[16:20:54.876]                         if (!is.null(pattern)) {
[16:20:54.876]                           computeRestarts <- base::computeRestarts
[16:20:54.876]                           grepl <- base::grepl
[16:20:54.876]                           restarts <- computeRestarts(cond)
[16:20:54.876]                           for (restart in restarts) {
[16:20:54.876]                             name <- restart$name
[16:20:54.876]                             if (is.null(name)) 
[16:20:54.876]                               next
[16:20:54.876]                             if (!grepl(pattern, name)) 
[16:20:54.876]                               next
[16:20:54.876]                             invokeRestart(restart)
[16:20:54.876]                             muffled <- TRUE
[16:20:54.876]                             break
[16:20:54.876]                           }
[16:20:54.876]                         }
[16:20:54.876]                       }
[16:20:54.876]                       invisible(muffled)
[16:20:54.876]                     }
[16:20:54.876]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.876]                   }
[16:20:54.876]                 }
[16:20:54.876]                 else {
[16:20:54.876]                   if (TRUE) {
[16:20:54.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.876]                     {
[16:20:54.876]                       inherits <- base::inherits
[16:20:54.876]                       invokeRestart <- base::invokeRestart
[16:20:54.876]                       is.null <- base::is.null
[16:20:54.876]                       muffled <- FALSE
[16:20:54.876]                       if (inherits(cond, "message")) {
[16:20:54.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.876]                         if (muffled) 
[16:20:54.876]                           invokeRestart("muffleMessage")
[16:20:54.876]                       }
[16:20:54.876]                       else if (inherits(cond, "warning")) {
[16:20:54.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.876]                         if (muffled) 
[16:20:54.876]                           invokeRestart("muffleWarning")
[16:20:54.876]                       }
[16:20:54.876]                       else if (inherits(cond, "condition")) {
[16:20:54.876]                         if (!is.null(pattern)) {
[16:20:54.876]                           computeRestarts <- base::computeRestarts
[16:20:54.876]                           grepl <- base::grepl
[16:20:54.876]                           restarts <- computeRestarts(cond)
[16:20:54.876]                           for (restart in restarts) {
[16:20:54.876]                             name <- restart$name
[16:20:54.876]                             if (is.null(name)) 
[16:20:54.876]                               next
[16:20:54.876]                             if (!grepl(pattern, name)) 
[16:20:54.876]                               next
[16:20:54.876]                             invokeRestart(restart)
[16:20:54.876]                             muffled <- TRUE
[16:20:54.876]                             break
[16:20:54.876]                           }
[16:20:54.876]                         }
[16:20:54.876]                       }
[16:20:54.876]                       invisible(muffled)
[16:20:54.876]                     }
[16:20:54.876]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.876]                   }
[16:20:54.876]                 }
[16:20:54.876]             }
[16:20:54.876]         }))
[16:20:54.876]     }, error = function(ex) {
[16:20:54.876]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:54.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.876]                 ...future.rng), started = ...future.startTime, 
[16:20:54.876]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:54.876]             version = "1.8"), class = "FutureResult")
[16:20:54.876]     }, finally = {
[16:20:54.876]         if (!identical(...future.workdir, getwd())) 
[16:20:54.876]             setwd(...future.workdir)
[16:20:54.876]         {
[16:20:54.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:54.876]                 ...future.oldOptions$nwarnings <- NULL
[16:20:54.876]             }
[16:20:54.876]             base::options(...future.oldOptions)
[16:20:54.876]             if (.Platform$OS.type == "windows") {
[16:20:54.876]                 old_names <- names(...future.oldEnvVars)
[16:20:54.876]                 envs <- base::Sys.getenv()
[16:20:54.876]                 names <- names(envs)
[16:20:54.876]                 common <- intersect(names, old_names)
[16:20:54.876]                 added <- setdiff(names, old_names)
[16:20:54.876]                 removed <- setdiff(old_names, names)
[16:20:54.876]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:54.876]                   envs[common]]
[16:20:54.876]                 NAMES <- toupper(changed)
[16:20:54.876]                 args <- list()
[16:20:54.876]                 for (kk in seq_along(NAMES)) {
[16:20:54.876]                   name <- changed[[kk]]
[16:20:54.876]                   NAME <- NAMES[[kk]]
[16:20:54.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.876]                     next
[16:20:54.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.876]                 }
[16:20:54.876]                 NAMES <- toupper(added)
[16:20:54.876]                 for (kk in seq_along(NAMES)) {
[16:20:54.876]                   name <- added[[kk]]
[16:20:54.876]                   NAME <- NAMES[[kk]]
[16:20:54.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.876]                     next
[16:20:54.876]                   args[[name]] <- ""
[16:20:54.876]                 }
[16:20:54.876]                 NAMES <- toupper(removed)
[16:20:54.876]                 for (kk in seq_along(NAMES)) {
[16:20:54.876]                   name <- removed[[kk]]
[16:20:54.876]                   NAME <- NAMES[[kk]]
[16:20:54.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.876]                     next
[16:20:54.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.876]                 }
[16:20:54.876]                 if (length(args) > 0) 
[16:20:54.876]                   base::do.call(base::Sys.setenv, args = args)
[16:20:54.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:54.876]             }
[16:20:54.876]             else {
[16:20:54.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:54.876]             }
[16:20:54.876]             {
[16:20:54.876]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:54.876]                   0L) {
[16:20:54.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:54.876]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:54.876]                   base::options(opts)
[16:20:54.876]                 }
[16:20:54.876]                 {
[16:20:54.876]                   {
[16:20:54.876]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:54.876]                     NULL
[16:20:54.876]                   }
[16:20:54.876]                   options(future.plan = NULL)
[16:20:54.876]                   if (is.na(NA_character_)) 
[16:20:54.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:54.876]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:54.876]                     .init = FALSE)
[16:20:54.876]                 }
[16:20:54.876]             }
[16:20:54.876]         }
[16:20:54.876]     })
[16:20:54.876]     if (TRUE) {
[16:20:54.876]         base::sink(type = "output", split = FALSE)
[16:20:54.876]         if (TRUE) {
[16:20:54.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:54.876]         }
[16:20:54.876]         else {
[16:20:54.876]             ...future.result["stdout"] <- base::list(NULL)
[16:20:54.876]         }
[16:20:54.876]         base::close(...future.stdout)
[16:20:54.876]         ...future.stdout <- NULL
[16:20:54.876]     }
[16:20:54.876]     ...future.result$conditions <- ...future.conditions
[16:20:54.876]     ...future.result$finished <- base::Sys.time()
[16:20:54.876]     ...future.result
[16:20:54.876] }
[16:20:54.878] requestCore(): workers = 2
[16:20:54.881] MulticoreFuture started
[16:20:54.881] - Launch lazy future ... done
[16:20:54.881] plan(): Setting new future strategy stack:
[16:20:54.881] run() for ‘MulticoreFuture’ ... done
[16:20:54.882] List of future strategies:
[16:20:54.882] 1. sequential:
[16:20:54.882]    - args: function (..., envir = parent.frame())
[16:20:54.882]    - tweaked: FALSE
[16:20:54.882]    - call: NULL
[16:20:54.882] plan(): nbrOfWorkers() = 1
[16:20:54.883] result() for MulticoreFuture ...
[16:20:54.884] plan(): Setting new future strategy stack:
[16:20:54.885] List of future strategies:
[16:20:54.885] 1. multicore:
[16:20:54.885]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:54.885]    - tweaked: FALSE
[16:20:54.885]    - call: plan(strategy)
[16:20:54.890] plan(): nbrOfWorkers() = 2
[16:20:54.894] result() for MulticoreFuture ...
[16:20:54.894] result() for MulticoreFuture ... done
[16:20:54.894] result() for MulticoreFuture ... done
[16:20:54.894] result() for MulticoreFuture ...
[16:20:54.895] result() for MulticoreFuture ... done
[16:20:54.895] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:54.895] Searching for globals...
[16:20:54.896] - globals found: [1] ‘getOption’
[16:20:54.896] Searching for globals ... DONE
[16:20:54.896] Resolving globals: FALSE
[16:20:54.897] 
[16:20:54.897] 
[16:20:54.897] getGlobalsAndPackages() ... DONE
[16:20:54.897] run() for ‘Future’ ...
[16:20:54.897] - state: ‘created’
[16:20:54.897] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:54.901] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:54.902] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:54.902]   - Field: ‘label’
[16:20:54.902]   - Field: ‘local’
[16:20:54.902]   - Field: ‘owner’
[16:20:54.902]   - Field: ‘envir’
[16:20:54.902]   - Field: ‘workers’
[16:20:54.902]   - Field: ‘packages’
[16:20:54.902]   - Field: ‘gc’
[16:20:54.903]   - Field: ‘job’
[16:20:54.903]   - Field: ‘conditions’
[16:20:54.903]   - Field: ‘expr’
[16:20:54.903]   - Field: ‘uuid’
[16:20:54.903]   - Field: ‘seed’
[16:20:54.903]   - Field: ‘version’
[16:20:54.903]   - Field: ‘result’
[16:20:54.903]   - Field: ‘asynchronous’
[16:20:54.903]   - Field: ‘calls’
[16:20:54.904]   - Field: ‘globals’
[16:20:54.904]   - Field: ‘stdout’
[16:20:54.904]   - Field: ‘earlySignal’
[16:20:54.904]   - Field: ‘lazy’
[16:20:54.904]   - Field: ‘state’
[16:20:54.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:54.904] - Launch lazy future ...
[16:20:54.905] Packages needed by the future expression (n = 0): <none>
[16:20:54.905] Packages needed by future strategies (n = 0): <none>
[16:20:54.905] {
[16:20:54.905]     {
[16:20:54.905]         {
[16:20:54.905]             ...future.startTime <- base::Sys.time()
[16:20:54.905]             {
[16:20:54.905]                 {
[16:20:54.905]                   {
[16:20:54.905]                     {
[16:20:54.905]                       base::local({
[16:20:54.905]                         has_future <- base::requireNamespace("future", 
[16:20:54.905]                           quietly = TRUE)
[16:20:54.905]                         if (has_future) {
[16:20:54.905]                           ns <- base::getNamespace("future")
[16:20:54.905]                           version <- ns[[".package"]][["version"]]
[16:20:54.905]                           if (is.null(version)) 
[16:20:54.905]                             version <- utils::packageVersion("future")
[16:20:54.905]                         }
[16:20:54.905]                         else {
[16:20:54.905]                           version <- NULL
[16:20:54.905]                         }
[16:20:54.905]                         if (!has_future || version < "1.8.0") {
[16:20:54.905]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:54.905]                             "", base::R.version$version.string), 
[16:20:54.905]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:54.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:54.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:54.905]                               "release", "version")], collapse = " "), 
[16:20:54.905]                             hostname = base::Sys.info()[["nodename"]])
[16:20:54.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:54.905]                             info)
[16:20:54.905]                           info <- base::paste(info, collapse = "; ")
[16:20:54.905]                           if (!has_future) {
[16:20:54.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:54.905]                               info)
[16:20:54.905]                           }
[16:20:54.905]                           else {
[16:20:54.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:54.905]                               info, version)
[16:20:54.905]                           }
[16:20:54.905]                           base::stop(msg)
[16:20:54.905]                         }
[16:20:54.905]                       })
[16:20:54.905]                     }
[16:20:54.905]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:54.905]                     base::options(mc.cores = 1L)
[16:20:54.905]                   }
[16:20:54.905]                   ...future.strategy.old <- future::plan("list")
[16:20:54.905]                   options(future.plan = NULL)
[16:20:54.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:54.905]                 }
[16:20:54.905]                 ...future.workdir <- getwd()
[16:20:54.905]             }
[16:20:54.905]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:54.905]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:54.905]         }
[16:20:54.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:54.905]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:54.905]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:54.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:54.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:54.905]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:54.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:54.905]             base::names(...future.oldOptions))
[16:20:54.905]     }
[16:20:54.905]     if (FALSE) {
[16:20:54.905]     }
[16:20:54.905]     else {
[16:20:54.905]         if (TRUE) {
[16:20:54.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:54.905]                 open = "w")
[16:20:54.905]         }
[16:20:54.905]         else {
[16:20:54.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:54.905]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:54.905]         }
[16:20:54.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:54.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:54.905]             base::sink(type = "output", split = FALSE)
[16:20:54.905]             base::close(...future.stdout)
[16:20:54.905]         }, add = TRUE)
[16:20:54.905]     }
[16:20:54.905]     ...future.frame <- base::sys.nframe()
[16:20:54.905]     ...future.conditions <- base::list()
[16:20:54.905]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:54.905]     if (FALSE) {
[16:20:54.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:54.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:54.905]     }
[16:20:54.905]     ...future.result <- base::tryCatch({
[16:20:54.905]         base::withCallingHandlers({
[16:20:54.905]             ...future.value <- base::withVisible(base::local({
[16:20:54.905]                 withCallingHandlers({
[16:20:54.905]                   getOption("future.globals.onMissing")
[16:20:54.905]                 }, immediateCondition = function(cond) {
[16:20:54.905]                   save_rds <- function (object, pathname, ...) 
[16:20:54.905]                   {
[16:20:54.905]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:54.905]                     if (file_test("-f", pathname_tmp)) {
[16:20:54.905]                       fi_tmp <- file.info(pathname_tmp)
[16:20:54.905]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:54.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:54.905]                         fi_tmp[["mtime"]])
[16:20:54.905]                     }
[16:20:54.905]                     tryCatch({
[16:20:54.905]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:54.905]                     }, error = function(ex) {
[16:20:54.905]                       msg <- conditionMessage(ex)
[16:20:54.905]                       fi_tmp <- file.info(pathname_tmp)
[16:20:54.905]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:54.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:54.905]                         fi_tmp[["mtime"]], msg)
[16:20:54.905]                       ex$message <- msg
[16:20:54.905]                       stop(ex)
[16:20:54.905]                     })
[16:20:54.905]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:54.905]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:54.905]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:54.905]                       fi_tmp <- file.info(pathname_tmp)
[16:20:54.905]                       fi <- file.info(pathname)
[16:20:54.905]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:54.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:54.905]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:54.905]                         fi[["size"]], fi[["mtime"]])
[16:20:54.905]                       stop(msg)
[16:20:54.905]                     }
[16:20:54.905]                     invisible(pathname)
[16:20:54.905]                   }
[16:20:54.905]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:54.905]                     rootPath = tempdir()) 
[16:20:54.905]                   {
[16:20:54.905]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:54.905]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:54.905]                       tmpdir = path, fileext = ".rds")
[16:20:54.905]                     save_rds(obj, file)
[16:20:54.905]                   }
[16:20:54.905]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6LbKVK/.future/immediateConditions")
[16:20:54.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.905]                   {
[16:20:54.905]                     inherits <- base::inherits
[16:20:54.905]                     invokeRestart <- base::invokeRestart
[16:20:54.905]                     is.null <- base::is.null
[16:20:54.905]                     muffled <- FALSE
[16:20:54.905]                     if (inherits(cond, "message")) {
[16:20:54.905]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:54.905]                       if (muffled) 
[16:20:54.905]                         invokeRestart("muffleMessage")
[16:20:54.905]                     }
[16:20:54.905]                     else if (inherits(cond, "warning")) {
[16:20:54.905]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:54.905]                       if (muffled) 
[16:20:54.905]                         invokeRestart("muffleWarning")
[16:20:54.905]                     }
[16:20:54.905]                     else if (inherits(cond, "condition")) {
[16:20:54.905]                       if (!is.null(pattern)) {
[16:20:54.905]                         computeRestarts <- base::computeRestarts
[16:20:54.905]                         grepl <- base::grepl
[16:20:54.905]                         restarts <- computeRestarts(cond)
[16:20:54.905]                         for (restart in restarts) {
[16:20:54.905]                           name <- restart$name
[16:20:54.905]                           if (is.null(name)) 
[16:20:54.905]                             next
[16:20:54.905]                           if (!grepl(pattern, name)) 
[16:20:54.905]                             next
[16:20:54.905]                           invokeRestart(restart)
[16:20:54.905]                           muffled <- TRUE
[16:20:54.905]                           break
[16:20:54.905]                         }
[16:20:54.905]                       }
[16:20:54.905]                     }
[16:20:54.905]                     invisible(muffled)
[16:20:54.905]                   }
[16:20:54.905]                   muffleCondition(cond)
[16:20:54.905]                 })
[16:20:54.905]             }))
[16:20:54.905]             future::FutureResult(value = ...future.value$value, 
[16:20:54.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.905]                   ...future.rng), globalenv = if (FALSE) 
[16:20:54.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:54.905]                     ...future.globalenv.names))
[16:20:54.905]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:54.905]         }, condition = base::local({
[16:20:54.905]             c <- base::c
[16:20:54.905]             inherits <- base::inherits
[16:20:54.905]             invokeRestart <- base::invokeRestart
[16:20:54.905]             length <- base::length
[16:20:54.905]             list <- base::list
[16:20:54.905]             seq.int <- base::seq.int
[16:20:54.905]             signalCondition <- base::signalCondition
[16:20:54.905]             sys.calls <- base::sys.calls
[16:20:54.905]             `[[` <- base::`[[`
[16:20:54.905]             `+` <- base::`+`
[16:20:54.905]             `<<-` <- base::`<<-`
[16:20:54.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:54.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:54.905]                   3L)]
[16:20:54.905]             }
[16:20:54.905]             function(cond) {
[16:20:54.905]                 is_error <- inherits(cond, "error")
[16:20:54.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:54.905]                   NULL)
[16:20:54.905]                 if (is_error) {
[16:20:54.905]                   sessionInformation <- function() {
[16:20:54.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:54.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:54.905]                       search = base::search(), system = base::Sys.info())
[16:20:54.905]                   }
[16:20:54.905]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:54.905]                     cond$call), session = sessionInformation(), 
[16:20:54.905]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:54.905]                   signalCondition(cond)
[16:20:54.905]                 }
[16:20:54.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:54.905]                 "immediateCondition"))) {
[16:20:54.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:54.905]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:54.905]                   if (TRUE && !signal) {
[16:20:54.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.905]                     {
[16:20:54.905]                       inherits <- base::inherits
[16:20:54.905]                       invokeRestart <- base::invokeRestart
[16:20:54.905]                       is.null <- base::is.null
[16:20:54.905]                       muffled <- FALSE
[16:20:54.905]                       if (inherits(cond, "message")) {
[16:20:54.905]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.905]                         if (muffled) 
[16:20:54.905]                           invokeRestart("muffleMessage")
[16:20:54.905]                       }
[16:20:54.905]                       else if (inherits(cond, "warning")) {
[16:20:54.905]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.905]                         if (muffled) 
[16:20:54.905]                           invokeRestart("muffleWarning")
[16:20:54.905]                       }
[16:20:54.905]                       else if (inherits(cond, "condition")) {
[16:20:54.905]                         if (!is.null(pattern)) {
[16:20:54.905]                           computeRestarts <- base::computeRestarts
[16:20:54.905]                           grepl <- base::grepl
[16:20:54.905]                           restarts <- computeRestarts(cond)
[16:20:54.905]                           for (restart in restarts) {
[16:20:54.905]                             name <- restart$name
[16:20:54.905]                             if (is.null(name)) 
[16:20:54.905]                               next
[16:20:54.905]                             if (!grepl(pattern, name)) 
[16:20:54.905]                               next
[16:20:54.905]                             invokeRestart(restart)
[16:20:54.905]                             muffled <- TRUE
[16:20:54.905]                             break
[16:20:54.905]                           }
[16:20:54.905]                         }
[16:20:54.905]                       }
[16:20:54.905]                       invisible(muffled)
[16:20:54.905]                     }
[16:20:54.905]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.905]                   }
[16:20:54.905]                 }
[16:20:54.905]                 else {
[16:20:54.905]                   if (TRUE) {
[16:20:54.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.905]                     {
[16:20:54.905]                       inherits <- base::inherits
[16:20:54.905]                       invokeRestart <- base::invokeRestart
[16:20:54.905]                       is.null <- base::is.null
[16:20:54.905]                       muffled <- FALSE
[16:20:54.905]                       if (inherits(cond, "message")) {
[16:20:54.905]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.905]                         if (muffled) 
[16:20:54.905]                           invokeRestart("muffleMessage")
[16:20:54.905]                       }
[16:20:54.905]                       else if (inherits(cond, "warning")) {
[16:20:54.905]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.905]                         if (muffled) 
[16:20:54.905]                           invokeRestart("muffleWarning")
[16:20:54.905]                       }
[16:20:54.905]                       else if (inherits(cond, "condition")) {
[16:20:54.905]                         if (!is.null(pattern)) {
[16:20:54.905]                           computeRestarts <- base::computeRestarts
[16:20:54.905]                           grepl <- base::grepl
[16:20:54.905]                           restarts <- computeRestarts(cond)
[16:20:54.905]                           for (restart in restarts) {
[16:20:54.905]                             name <- restart$name
[16:20:54.905]                             if (is.null(name)) 
[16:20:54.905]                               next
[16:20:54.905]                             if (!grepl(pattern, name)) 
[16:20:54.905]                               next
[16:20:54.905]                             invokeRestart(restart)
[16:20:54.905]                             muffled <- TRUE
[16:20:54.905]                             break
[16:20:54.905]                           }
[16:20:54.905]                         }
[16:20:54.905]                       }
[16:20:54.905]                       invisible(muffled)
[16:20:54.905]                     }
[16:20:54.905]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.905]                   }
[16:20:54.905]                 }
[16:20:54.905]             }
[16:20:54.905]         }))
[16:20:54.905]     }, error = function(ex) {
[16:20:54.905]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:54.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.905]                 ...future.rng), started = ...future.startTime, 
[16:20:54.905]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:54.905]             version = "1.8"), class = "FutureResult")
[16:20:54.905]     }, finally = {
[16:20:54.905]         if (!identical(...future.workdir, getwd())) 
[16:20:54.905]             setwd(...future.workdir)
[16:20:54.905]         {
[16:20:54.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:54.905]                 ...future.oldOptions$nwarnings <- NULL
[16:20:54.905]             }
[16:20:54.905]             base::options(...future.oldOptions)
[16:20:54.905]             if (.Platform$OS.type == "windows") {
[16:20:54.905]                 old_names <- names(...future.oldEnvVars)
[16:20:54.905]                 envs <- base::Sys.getenv()
[16:20:54.905]                 names <- names(envs)
[16:20:54.905]                 common <- intersect(names, old_names)
[16:20:54.905]                 added <- setdiff(names, old_names)
[16:20:54.905]                 removed <- setdiff(old_names, names)
[16:20:54.905]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:54.905]                   envs[common]]
[16:20:54.905]                 NAMES <- toupper(changed)
[16:20:54.905]                 args <- list()
[16:20:54.905]                 for (kk in seq_along(NAMES)) {
[16:20:54.905]                   name <- changed[[kk]]
[16:20:54.905]                   NAME <- NAMES[[kk]]
[16:20:54.905]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.905]                     next
[16:20:54.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.905]                 }
[16:20:54.905]                 NAMES <- toupper(added)
[16:20:54.905]                 for (kk in seq_along(NAMES)) {
[16:20:54.905]                   name <- added[[kk]]
[16:20:54.905]                   NAME <- NAMES[[kk]]
[16:20:54.905]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.905]                     next
[16:20:54.905]                   args[[name]] <- ""
[16:20:54.905]                 }
[16:20:54.905]                 NAMES <- toupper(removed)
[16:20:54.905]                 for (kk in seq_along(NAMES)) {
[16:20:54.905]                   name <- removed[[kk]]
[16:20:54.905]                   NAME <- NAMES[[kk]]
[16:20:54.905]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.905]                     next
[16:20:54.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.905]                 }
[16:20:54.905]                 if (length(args) > 0) 
[16:20:54.905]                   base::do.call(base::Sys.setenv, args = args)
[16:20:54.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:54.905]             }
[16:20:54.905]             else {
[16:20:54.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:54.905]             }
[16:20:54.905]             {
[16:20:54.905]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:54.905]                   0L) {
[16:20:54.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:54.905]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:54.905]                   base::options(opts)
[16:20:54.905]                 }
[16:20:54.905]                 {
[16:20:54.905]                   {
[16:20:54.905]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:54.905]                     NULL
[16:20:54.905]                   }
[16:20:54.905]                   options(future.plan = NULL)
[16:20:54.905]                   if (is.na(NA_character_)) 
[16:20:54.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:54.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:54.905]                     .init = FALSE)
[16:20:54.905]                 }
[16:20:54.905]             }
[16:20:54.905]         }
[16:20:54.905]     })
[16:20:54.905]     if (TRUE) {
[16:20:54.905]         base::sink(type = "output", split = FALSE)
[16:20:54.905]         if (TRUE) {
[16:20:54.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:54.905]         }
[16:20:54.905]         else {
[16:20:54.905]             ...future.result["stdout"] <- base::list(NULL)
[16:20:54.905]         }
[16:20:54.905]         base::close(...future.stdout)
[16:20:54.905]         ...future.stdout <- NULL
[16:20:54.905]     }
[16:20:54.905]     ...future.result$conditions <- ...future.conditions
[16:20:54.905]     ...future.result$finished <- base::Sys.time()
[16:20:54.905]     ...future.result
[16:20:54.905] }
[16:20:54.908] requestCore(): workers = 2
[16:20:54.909] MulticoreFuture started
[16:20:54.910] - Launch lazy future ... done
[16:20:54.910] run() for ‘MulticoreFuture’ ... done
[16:20:54.910] result() for MulticoreFuture ...
[16:20:54.910] plan(): Setting new future strategy stack:
[16:20:54.911] List of future strategies:
[16:20:54.911] 1. sequential:
[16:20:54.911]    - args: function (..., envir = parent.frame())
[16:20:54.911]    - tweaked: FALSE
[16:20:54.911]    - call: NULL
[16:20:54.911] plan(): nbrOfWorkers() = 1
[16:20:54.913] plan(): Setting new future strategy stack:
[16:20:54.914] List of future strategies:
[16:20:54.914] 1. multicore:
[16:20:54.914]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:54.914]    - tweaked: FALSE
[16:20:54.914]    - call: plan(strategy)
[16:20:54.918] plan(): nbrOfWorkers() = 2
[16:20:54.919] result() for MulticoreFuture ...
[16:20:54.919] result() for MulticoreFuture ... done
[16:20:54.919] result() for MulticoreFuture ... done
[16:20:54.919] result() for MulticoreFuture ...
[16:20:54.920] result() for MulticoreFuture ... done
[16:20:54.920] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:20:54.920] Searching for globals...
[16:20:54.922] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:54.922] Searching for globals...
[16:20:54.923] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[16:20:54.923] Searching for globals ... DONE
[16:20:54.924] Resolving globals: FALSE
[16:20:54.924] The total size of the 1 globals is 160 bytes (160 bytes)
[16:20:54.925] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[16:20:54.928] - globals: [1] ‘data’
[16:20:54.928] 
[16:20:54.928] getGlobalsAndPackages() ... DONE
[16:20:54.928] run() for ‘Future’ ...
[16:20:54.928] - state: ‘created’
[16:20:54.929] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:54.933] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:54.933] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:54.933]   - Field: ‘label’
[16:20:54.933]   - Field: ‘local’
[16:20:54.933]   - Field: ‘owner’
[16:20:54.933]   - Field: ‘envir’
[16:20:54.933]   - Field: ‘workers’
[16:20:54.933]   - Field: ‘packages’
[16:20:54.934]   - Field: ‘gc’
[16:20:54.934]   - Field: ‘job’
[16:20:54.934]   - Field: ‘conditions’
[16:20:54.934]   - Field: ‘expr’
[16:20:54.934]   - Field: ‘uuid’
[16:20:54.934]   - Field: ‘seed’
[16:20:54.934]   - Field: ‘version’
[16:20:54.934]   - Field: ‘result’
[16:20:54.935]   - Field: ‘asynchronous’
[16:20:54.935]   - Field: ‘calls’
[16:20:54.935]   - Field: ‘globals’
[16:20:54.935]   - Field: ‘stdout’
[16:20:54.935]   - Field: ‘earlySignal’
[16:20:54.935]   - Field: ‘lazy’
[16:20:54.935]   - Field: ‘state’
[16:20:54.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:54.935] - Launch lazy future ...
[16:20:54.936] Packages needed by the future expression (n = 0): <none>
[16:20:54.936] Packages needed by future strategies (n = 0): <none>
[16:20:54.937] {
[16:20:54.937]     {
[16:20:54.937]         {
[16:20:54.937]             ...future.startTime <- base::Sys.time()
[16:20:54.937]             {
[16:20:54.937]                 {
[16:20:54.937]                   {
[16:20:54.937]                     {
[16:20:54.937]                       base::local({
[16:20:54.937]                         has_future <- base::requireNamespace("future", 
[16:20:54.937]                           quietly = TRUE)
[16:20:54.937]                         if (has_future) {
[16:20:54.937]                           ns <- base::getNamespace("future")
[16:20:54.937]                           version <- ns[[".package"]][["version"]]
[16:20:54.937]                           if (is.null(version)) 
[16:20:54.937]                             version <- utils::packageVersion("future")
[16:20:54.937]                         }
[16:20:54.937]                         else {
[16:20:54.937]                           version <- NULL
[16:20:54.937]                         }
[16:20:54.937]                         if (!has_future || version < "1.8.0") {
[16:20:54.937]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:54.937]                             "", base::R.version$version.string), 
[16:20:54.937]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:54.937]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:54.937]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:54.937]                               "release", "version")], collapse = " "), 
[16:20:54.937]                             hostname = base::Sys.info()[["nodename"]])
[16:20:54.937]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:54.937]                             info)
[16:20:54.937]                           info <- base::paste(info, collapse = "; ")
[16:20:54.937]                           if (!has_future) {
[16:20:54.937]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:54.937]                               info)
[16:20:54.937]                           }
[16:20:54.937]                           else {
[16:20:54.937]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:54.937]                               info, version)
[16:20:54.937]                           }
[16:20:54.937]                           base::stop(msg)
[16:20:54.937]                         }
[16:20:54.937]                       })
[16:20:54.937]                     }
[16:20:54.937]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:54.937]                     base::options(mc.cores = 1L)
[16:20:54.937]                   }
[16:20:54.937]                   ...future.strategy.old <- future::plan("list")
[16:20:54.937]                   options(future.plan = NULL)
[16:20:54.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:54.937]                 }
[16:20:54.937]                 ...future.workdir <- getwd()
[16:20:54.937]             }
[16:20:54.937]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:54.937]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:54.937]         }
[16:20:54.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:54.937]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:54.937]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:54.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:54.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:54.937]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:54.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:54.937]             base::names(...future.oldOptions))
[16:20:54.937]     }
[16:20:54.937]     if (FALSE) {
[16:20:54.937]     }
[16:20:54.937]     else {
[16:20:54.937]         if (TRUE) {
[16:20:54.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:54.937]                 open = "w")
[16:20:54.937]         }
[16:20:54.937]         else {
[16:20:54.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:54.937]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:54.937]         }
[16:20:54.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:54.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:54.937]             base::sink(type = "output", split = FALSE)
[16:20:54.937]             base::close(...future.stdout)
[16:20:54.937]         }, add = TRUE)
[16:20:54.937]     }
[16:20:54.937]     ...future.frame <- base::sys.nframe()
[16:20:54.937]     ...future.conditions <- base::list()
[16:20:54.937]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:54.937]     if (FALSE) {
[16:20:54.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:54.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:54.937]     }
[16:20:54.937]     ...future.result <- base::tryCatch({
[16:20:54.937]         base::withCallingHandlers({
[16:20:54.937]             ...future.value <- base::withVisible(base::local({
[16:20:54.937]                 withCallingHandlers({
[16:20:54.937]                   subset(data, x < 3)$y
[16:20:54.937]                 }, immediateCondition = function(cond) {
[16:20:54.937]                   save_rds <- function (object, pathname, ...) 
[16:20:54.937]                   {
[16:20:54.937]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:54.937]                     if (file_test("-f", pathname_tmp)) {
[16:20:54.937]                       fi_tmp <- file.info(pathname_tmp)
[16:20:54.937]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:54.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:54.937]                         fi_tmp[["mtime"]])
[16:20:54.937]                     }
[16:20:54.937]                     tryCatch({
[16:20:54.937]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:54.937]                     }, error = function(ex) {
[16:20:54.937]                       msg <- conditionMessage(ex)
[16:20:54.937]                       fi_tmp <- file.info(pathname_tmp)
[16:20:54.937]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:54.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:54.937]                         fi_tmp[["mtime"]], msg)
[16:20:54.937]                       ex$message <- msg
[16:20:54.937]                       stop(ex)
[16:20:54.937]                     })
[16:20:54.937]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:54.937]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:54.937]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:54.937]                       fi_tmp <- file.info(pathname_tmp)
[16:20:54.937]                       fi <- file.info(pathname)
[16:20:54.937]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:54.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:54.937]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:54.937]                         fi[["size"]], fi[["mtime"]])
[16:20:54.937]                       stop(msg)
[16:20:54.937]                     }
[16:20:54.937]                     invisible(pathname)
[16:20:54.937]                   }
[16:20:54.937]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:54.937]                     rootPath = tempdir()) 
[16:20:54.937]                   {
[16:20:54.937]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:54.937]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:54.937]                       tmpdir = path, fileext = ".rds")
[16:20:54.937]                     save_rds(obj, file)
[16:20:54.937]                   }
[16:20:54.937]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6LbKVK/.future/immediateConditions")
[16:20:54.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.937]                   {
[16:20:54.937]                     inherits <- base::inherits
[16:20:54.937]                     invokeRestart <- base::invokeRestart
[16:20:54.937]                     is.null <- base::is.null
[16:20:54.937]                     muffled <- FALSE
[16:20:54.937]                     if (inherits(cond, "message")) {
[16:20:54.937]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:54.937]                       if (muffled) 
[16:20:54.937]                         invokeRestart("muffleMessage")
[16:20:54.937]                     }
[16:20:54.937]                     else if (inherits(cond, "warning")) {
[16:20:54.937]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:54.937]                       if (muffled) 
[16:20:54.937]                         invokeRestart("muffleWarning")
[16:20:54.937]                     }
[16:20:54.937]                     else if (inherits(cond, "condition")) {
[16:20:54.937]                       if (!is.null(pattern)) {
[16:20:54.937]                         computeRestarts <- base::computeRestarts
[16:20:54.937]                         grepl <- base::grepl
[16:20:54.937]                         restarts <- computeRestarts(cond)
[16:20:54.937]                         for (restart in restarts) {
[16:20:54.937]                           name <- restart$name
[16:20:54.937]                           if (is.null(name)) 
[16:20:54.937]                             next
[16:20:54.937]                           if (!grepl(pattern, name)) 
[16:20:54.937]                             next
[16:20:54.937]                           invokeRestart(restart)
[16:20:54.937]                           muffled <- TRUE
[16:20:54.937]                           break
[16:20:54.937]                         }
[16:20:54.937]                       }
[16:20:54.937]                     }
[16:20:54.937]                     invisible(muffled)
[16:20:54.937]                   }
[16:20:54.937]                   muffleCondition(cond)
[16:20:54.937]                 })
[16:20:54.937]             }))
[16:20:54.937]             future::FutureResult(value = ...future.value$value, 
[16:20:54.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.937]                   ...future.rng), globalenv = if (FALSE) 
[16:20:54.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:54.937]                     ...future.globalenv.names))
[16:20:54.937]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:54.937]         }, condition = base::local({
[16:20:54.937]             c <- base::c
[16:20:54.937]             inherits <- base::inherits
[16:20:54.937]             invokeRestart <- base::invokeRestart
[16:20:54.937]             length <- base::length
[16:20:54.937]             list <- base::list
[16:20:54.937]             seq.int <- base::seq.int
[16:20:54.937]             signalCondition <- base::signalCondition
[16:20:54.937]             sys.calls <- base::sys.calls
[16:20:54.937]             `[[` <- base::`[[`
[16:20:54.937]             `+` <- base::`+`
[16:20:54.937]             `<<-` <- base::`<<-`
[16:20:54.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:54.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:54.937]                   3L)]
[16:20:54.937]             }
[16:20:54.937]             function(cond) {
[16:20:54.937]                 is_error <- inherits(cond, "error")
[16:20:54.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:54.937]                   NULL)
[16:20:54.937]                 if (is_error) {
[16:20:54.937]                   sessionInformation <- function() {
[16:20:54.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:54.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:54.937]                       search = base::search(), system = base::Sys.info())
[16:20:54.937]                   }
[16:20:54.937]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:54.937]                     cond$call), session = sessionInformation(), 
[16:20:54.937]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:54.937]                   signalCondition(cond)
[16:20:54.937]                 }
[16:20:54.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:54.937]                 "immediateCondition"))) {
[16:20:54.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:54.937]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:54.937]                   if (TRUE && !signal) {
[16:20:54.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.937]                     {
[16:20:54.937]                       inherits <- base::inherits
[16:20:54.937]                       invokeRestart <- base::invokeRestart
[16:20:54.937]                       is.null <- base::is.null
[16:20:54.937]                       muffled <- FALSE
[16:20:54.937]                       if (inherits(cond, "message")) {
[16:20:54.937]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.937]                         if (muffled) 
[16:20:54.937]                           invokeRestart("muffleMessage")
[16:20:54.937]                       }
[16:20:54.937]                       else if (inherits(cond, "warning")) {
[16:20:54.937]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.937]                         if (muffled) 
[16:20:54.937]                           invokeRestart("muffleWarning")
[16:20:54.937]                       }
[16:20:54.937]                       else if (inherits(cond, "condition")) {
[16:20:54.937]                         if (!is.null(pattern)) {
[16:20:54.937]                           computeRestarts <- base::computeRestarts
[16:20:54.937]                           grepl <- base::grepl
[16:20:54.937]                           restarts <- computeRestarts(cond)
[16:20:54.937]                           for (restart in restarts) {
[16:20:54.937]                             name <- restart$name
[16:20:54.937]                             if (is.null(name)) 
[16:20:54.937]                               next
[16:20:54.937]                             if (!grepl(pattern, name)) 
[16:20:54.937]                               next
[16:20:54.937]                             invokeRestart(restart)
[16:20:54.937]                             muffled <- TRUE
[16:20:54.937]                             break
[16:20:54.937]                           }
[16:20:54.937]                         }
[16:20:54.937]                       }
[16:20:54.937]                       invisible(muffled)
[16:20:54.937]                     }
[16:20:54.937]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.937]                   }
[16:20:54.937]                 }
[16:20:54.937]                 else {
[16:20:54.937]                   if (TRUE) {
[16:20:54.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.937]                     {
[16:20:54.937]                       inherits <- base::inherits
[16:20:54.937]                       invokeRestart <- base::invokeRestart
[16:20:54.937]                       is.null <- base::is.null
[16:20:54.937]                       muffled <- FALSE
[16:20:54.937]                       if (inherits(cond, "message")) {
[16:20:54.937]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.937]                         if (muffled) 
[16:20:54.937]                           invokeRestart("muffleMessage")
[16:20:54.937]                       }
[16:20:54.937]                       else if (inherits(cond, "warning")) {
[16:20:54.937]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.937]                         if (muffled) 
[16:20:54.937]                           invokeRestart("muffleWarning")
[16:20:54.937]                       }
[16:20:54.937]                       else if (inherits(cond, "condition")) {
[16:20:54.937]                         if (!is.null(pattern)) {
[16:20:54.937]                           computeRestarts <- base::computeRestarts
[16:20:54.937]                           grepl <- base::grepl
[16:20:54.937]                           restarts <- computeRestarts(cond)
[16:20:54.937]                           for (restart in restarts) {
[16:20:54.937]                             name <- restart$name
[16:20:54.937]                             if (is.null(name)) 
[16:20:54.937]                               next
[16:20:54.937]                             if (!grepl(pattern, name)) 
[16:20:54.937]                               next
[16:20:54.937]                             invokeRestart(restart)
[16:20:54.937]                             muffled <- TRUE
[16:20:54.937]                             break
[16:20:54.937]                           }
[16:20:54.937]                         }
[16:20:54.937]                       }
[16:20:54.937]                       invisible(muffled)
[16:20:54.937]                     }
[16:20:54.937]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.937]                   }
[16:20:54.937]                 }
[16:20:54.937]             }
[16:20:54.937]         }))
[16:20:54.937]     }, error = function(ex) {
[16:20:54.937]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:54.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.937]                 ...future.rng), started = ...future.startTime, 
[16:20:54.937]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:54.937]             version = "1.8"), class = "FutureResult")
[16:20:54.937]     }, finally = {
[16:20:54.937]         if (!identical(...future.workdir, getwd())) 
[16:20:54.937]             setwd(...future.workdir)
[16:20:54.937]         {
[16:20:54.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:54.937]                 ...future.oldOptions$nwarnings <- NULL
[16:20:54.937]             }
[16:20:54.937]             base::options(...future.oldOptions)
[16:20:54.937]             if (.Platform$OS.type == "windows") {
[16:20:54.937]                 old_names <- names(...future.oldEnvVars)
[16:20:54.937]                 envs <- base::Sys.getenv()
[16:20:54.937]                 names <- names(envs)
[16:20:54.937]                 common <- intersect(names, old_names)
[16:20:54.937]                 added <- setdiff(names, old_names)
[16:20:54.937]                 removed <- setdiff(old_names, names)
[16:20:54.937]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:54.937]                   envs[common]]
[16:20:54.937]                 NAMES <- toupper(changed)
[16:20:54.937]                 args <- list()
[16:20:54.937]                 for (kk in seq_along(NAMES)) {
[16:20:54.937]                   name <- changed[[kk]]
[16:20:54.937]                   NAME <- NAMES[[kk]]
[16:20:54.937]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.937]                     next
[16:20:54.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.937]                 }
[16:20:54.937]                 NAMES <- toupper(added)
[16:20:54.937]                 for (kk in seq_along(NAMES)) {
[16:20:54.937]                   name <- added[[kk]]
[16:20:54.937]                   NAME <- NAMES[[kk]]
[16:20:54.937]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.937]                     next
[16:20:54.937]                   args[[name]] <- ""
[16:20:54.937]                 }
[16:20:54.937]                 NAMES <- toupper(removed)
[16:20:54.937]                 for (kk in seq_along(NAMES)) {
[16:20:54.937]                   name <- removed[[kk]]
[16:20:54.937]                   NAME <- NAMES[[kk]]
[16:20:54.937]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.937]                     next
[16:20:54.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.937]                 }
[16:20:54.937]                 if (length(args) > 0) 
[16:20:54.937]                   base::do.call(base::Sys.setenv, args = args)
[16:20:54.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:54.937]             }
[16:20:54.937]             else {
[16:20:54.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:54.937]             }
[16:20:54.937]             {
[16:20:54.937]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:54.937]                   0L) {
[16:20:54.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:54.937]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:54.937]                   base::options(opts)
[16:20:54.937]                 }
[16:20:54.937]                 {
[16:20:54.937]                   {
[16:20:54.937]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:54.937]                     NULL
[16:20:54.937]                   }
[16:20:54.937]                   options(future.plan = NULL)
[16:20:54.937]                   if (is.na(NA_character_)) 
[16:20:54.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:54.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:54.937]                     .init = FALSE)
[16:20:54.937]                 }
[16:20:54.937]             }
[16:20:54.937]         }
[16:20:54.937]     })
[16:20:54.937]     if (TRUE) {
[16:20:54.937]         base::sink(type = "output", split = FALSE)
[16:20:54.937]         if (TRUE) {
[16:20:54.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:54.937]         }
[16:20:54.937]         else {
[16:20:54.937]             ...future.result["stdout"] <- base::list(NULL)
[16:20:54.937]         }
[16:20:54.937]         base::close(...future.stdout)
[16:20:54.937]         ...future.stdout <- NULL
[16:20:54.937]     }
[16:20:54.937]     ...future.result$conditions <- ...future.conditions
[16:20:54.937]     ...future.result$finished <- base::Sys.time()
[16:20:54.937]     ...future.result
[16:20:54.937] }
[16:20:54.939] assign_globals() ...
[16:20:54.939] List of 1
[16:20:54.939]  $ data:'data.frame':	5 obs. of  2 variables:
[16:20:54.939]   ..$ x: int [1:5] 1 2 3 4 5
[16:20:54.939]   ..$ y: int [1:5] 1 2 3 4 5
[16:20:54.939]  - attr(*, "where")=List of 1
[16:20:54.939]   ..$ data:<environment: R_EmptyEnv> 
[16:20:54.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:54.939]  - attr(*, "resolved")= logi FALSE
[16:20:54.939]  - attr(*, "total_size")= num 160
[16:20:54.939]  - attr(*, "already-done")= logi TRUE
[16:20:54.943] - copied ‘data’ to environment
[16:20:54.943] assign_globals() ... done
[16:20:54.943] requestCore(): workers = 2
[16:20:54.945] MulticoreFuture started
[16:20:54.945] - Launch lazy future ... done
[16:20:54.945] run() for ‘MulticoreFuture’ ... done
[16:20:54.946] result() for MulticoreFuture ...
[16:20:54.946] plan(): Setting new future strategy stack:
[16:20:54.946] List of future strategies:
[16:20:54.946] 1. sequential:
[16:20:54.946]    - args: function (..., envir = parent.frame())
[16:20:54.946]    - tweaked: FALSE
[16:20:54.946]    - call: NULL
[16:20:54.947] plan(): nbrOfWorkers() = 1
[16:20:54.949] plan(): Setting new future strategy stack:
[16:20:54.949] List of future strategies:
[16:20:54.949] 1. multicore:
[16:20:54.949]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:54.949]    - tweaked: FALSE
[16:20:54.949]    - call: plan(strategy)
[16:20:54.954] plan(): nbrOfWorkers() = 2
[16:20:54.955] result() for MulticoreFuture ...
[16:20:54.955] result() for MulticoreFuture ... done
[16:20:54.955] result() for MulticoreFuture ... done
[16:20:54.955] result() for MulticoreFuture ...
[16:20:54.956] result() for MulticoreFuture ... done
[16:20:54.956] plan(): Setting new future strategy stack:
[16:20:54.956] List of future strategies:
[16:20:54.956] 1. sequential:
[16:20:54.956]    - args: function (..., envir = parent.frame())
[16:20:54.956]    - tweaked: FALSE
[16:20:54.956]    - call: plan(list(sequential, strategy))
[16:20:54.956] 2. multicore:
[16:20:54.956]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:54.956]    - tweaked: FALSE
[16:20:54.956]    - call: plan(list(sequential, strategy))
[16:20:54.957] plan(): nbrOfWorkers() = 1
[16:20:54.957] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:54.957] Searching for globals...
[16:20:54.961] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[16:20:54.961] Searching for globals ... DONE
[16:20:54.961] Resolving globals: FALSE
[16:20:54.962] The total size of the 1 globals is 160 bytes (160 bytes)
[16:20:54.963] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[16:20:54.963] - globals: [1] ‘data’
[16:20:54.963] - packages: [1] ‘future’
[16:20:54.963] getGlobalsAndPackages() ... DONE
[16:20:54.963] run() for ‘Future’ ...
[16:20:54.964] - state: ‘created’
[16:20:54.964] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:54.964] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:54.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:54.964]   - Field: ‘label’
[16:20:54.965]   - Field: ‘local’
[16:20:54.965]   - Field: ‘owner’
[16:20:54.965]   - Field: ‘envir’
[16:20:54.965]   - Field: ‘packages’
[16:20:54.965]   - Field: ‘gc’
[16:20:54.965]   - Field: ‘conditions’
[16:20:54.965]   - Field: ‘expr’
[16:20:54.965]   - Field: ‘uuid’
[16:20:54.965]   - Field: ‘seed’
[16:20:54.966]   - Field: ‘version’
[16:20:54.966]   - Field: ‘result’
[16:20:54.966]   - Field: ‘asynchronous’
[16:20:54.966]   - Field: ‘calls’
[16:20:54.966]   - Field: ‘globals’
[16:20:54.966]   - Field: ‘stdout’
[16:20:54.966]   - Field: ‘earlySignal’
[16:20:54.966]   - Field: ‘lazy’
[16:20:54.966]   - Field: ‘state’
[16:20:54.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:54.967] - Launch lazy future ...
[16:20:54.967] Packages needed by the future expression (n = 1): ‘future’
[16:20:54.967] Packages needed by future strategies (n = 1): ‘future’
[16:20:54.968] {
[16:20:54.968]     {
[16:20:54.968]         {
[16:20:54.968]             ...future.startTime <- base::Sys.time()
[16:20:54.968]             {
[16:20:54.968]                 {
[16:20:54.968]                   {
[16:20:54.968]                     {
[16:20:54.968]                       base::local({
[16:20:54.968]                         has_future <- base::requireNamespace("future", 
[16:20:54.968]                           quietly = TRUE)
[16:20:54.968]                         if (has_future) {
[16:20:54.968]                           ns <- base::getNamespace("future")
[16:20:54.968]                           version <- ns[[".package"]][["version"]]
[16:20:54.968]                           if (is.null(version)) 
[16:20:54.968]                             version <- utils::packageVersion("future")
[16:20:54.968]                         }
[16:20:54.968]                         else {
[16:20:54.968]                           version <- NULL
[16:20:54.968]                         }
[16:20:54.968]                         if (!has_future || version < "1.8.0") {
[16:20:54.968]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:54.968]                             "", base::R.version$version.string), 
[16:20:54.968]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:54.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:54.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:54.968]                               "release", "version")], collapse = " "), 
[16:20:54.968]                             hostname = base::Sys.info()[["nodename"]])
[16:20:54.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:54.968]                             info)
[16:20:54.968]                           info <- base::paste(info, collapse = "; ")
[16:20:54.968]                           if (!has_future) {
[16:20:54.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:54.968]                               info)
[16:20:54.968]                           }
[16:20:54.968]                           else {
[16:20:54.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:54.968]                               info, version)
[16:20:54.968]                           }
[16:20:54.968]                           base::stop(msg)
[16:20:54.968]                         }
[16:20:54.968]                       })
[16:20:54.968]                     }
[16:20:54.968]                     base::local({
[16:20:54.968]                       for (pkg in "future") {
[16:20:54.968]                         base::loadNamespace(pkg)
[16:20:54.968]                         base::library(pkg, character.only = TRUE)
[16:20:54.968]                       }
[16:20:54.968]                     })
[16:20:54.968]                   }
[16:20:54.968]                   ...future.strategy.old <- future::plan("list")
[16:20:54.968]                   options(future.plan = NULL)
[16:20:54.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.968]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:20:54.968]                     envir = parent.frame()) 
[16:20:54.968]                   {
[16:20:54.968]                     default_workers <- missing(workers)
[16:20:54.968]                     if (is.function(workers)) 
[16:20:54.968]                       workers <- workers()
[16:20:54.968]                     workers <- structure(as.integer(workers), 
[16:20:54.968]                       class = class(workers))
[16:20:54.968]                     stop_if_not(is.finite(workers), workers >= 
[16:20:54.968]                       1L)
[16:20:54.968]                     if ((workers == 1L && !inherits(workers, 
[16:20:54.968]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:20:54.968]                       if (default_workers) 
[16:20:54.968]                         supportsMulticore(warn = TRUE)
[16:20:54.968]                       return(sequential(..., envir = envir))
[16:20:54.968]                     }
[16:20:54.968]                     oopts <- options(mc.cores = workers)
[16:20:54.968]                     on.exit(options(oopts))
[16:20:54.968]                     future <- MulticoreFuture(..., workers = workers, 
[16:20:54.968]                       envir = envir)
[16:20:54.968]                     if (!future$lazy) 
[16:20:54.968]                       future <- run(future)
[16:20:54.968]                     invisible(future)
[16:20:54.968]                   }), .cleanup = FALSE, .init = FALSE)
[16:20:54.968]                 }
[16:20:54.968]                 ...future.workdir <- getwd()
[16:20:54.968]             }
[16:20:54.968]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:54.968]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:54.968]         }
[16:20:54.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:54.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:54.968]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:54.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:54.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:54.968]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:54.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:54.968]             base::names(...future.oldOptions))
[16:20:54.968]     }
[16:20:54.968]     if (FALSE) {
[16:20:54.968]     }
[16:20:54.968]     else {
[16:20:54.968]         if (TRUE) {
[16:20:54.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:54.968]                 open = "w")
[16:20:54.968]         }
[16:20:54.968]         else {
[16:20:54.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:54.968]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:54.968]         }
[16:20:54.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:54.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:54.968]             base::sink(type = "output", split = FALSE)
[16:20:54.968]             base::close(...future.stdout)
[16:20:54.968]         }, add = TRUE)
[16:20:54.968]     }
[16:20:54.968]     ...future.frame <- base::sys.nframe()
[16:20:54.968]     ...future.conditions <- base::list()
[16:20:54.968]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:54.968]     if (FALSE) {
[16:20:54.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:54.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:54.968]     }
[16:20:54.968]     ...future.result <- base::tryCatch({
[16:20:54.968]         base::withCallingHandlers({
[16:20:54.968]             ...future.value <- base::withVisible(base::local({
[16:20:54.968]                 a %<-% subset(data, x < 3)$y
[16:20:54.968]                 a
[16:20:54.968]             }))
[16:20:54.968]             future::FutureResult(value = ...future.value$value, 
[16:20:54.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.968]                   ...future.rng), globalenv = if (FALSE) 
[16:20:54.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:54.968]                     ...future.globalenv.names))
[16:20:54.968]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:54.968]         }, condition = base::local({
[16:20:54.968]             c <- base::c
[16:20:54.968]             inherits <- base::inherits
[16:20:54.968]             invokeRestart <- base::invokeRestart
[16:20:54.968]             length <- base::length
[16:20:54.968]             list <- base::list
[16:20:54.968]             seq.int <- base::seq.int
[16:20:54.968]             signalCondition <- base::signalCondition
[16:20:54.968]             sys.calls <- base::sys.calls
[16:20:54.968]             `[[` <- base::`[[`
[16:20:54.968]             `+` <- base::`+`
[16:20:54.968]             `<<-` <- base::`<<-`
[16:20:54.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:54.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:54.968]                   3L)]
[16:20:54.968]             }
[16:20:54.968]             function(cond) {
[16:20:54.968]                 is_error <- inherits(cond, "error")
[16:20:54.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:54.968]                   NULL)
[16:20:54.968]                 if (is_error) {
[16:20:54.968]                   sessionInformation <- function() {
[16:20:54.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:54.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:54.968]                       search = base::search(), system = base::Sys.info())
[16:20:54.968]                   }
[16:20:54.968]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:54.968]                     cond$call), session = sessionInformation(), 
[16:20:54.968]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:54.968]                   signalCondition(cond)
[16:20:54.968]                 }
[16:20:54.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:54.968]                 "immediateCondition"))) {
[16:20:54.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:54.968]                   ...future.conditions[[length(...future.conditions) + 
[16:20:54.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:54.968]                   if (TRUE && !signal) {
[16:20:54.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.968]                     {
[16:20:54.968]                       inherits <- base::inherits
[16:20:54.968]                       invokeRestart <- base::invokeRestart
[16:20:54.968]                       is.null <- base::is.null
[16:20:54.968]                       muffled <- FALSE
[16:20:54.968]                       if (inherits(cond, "message")) {
[16:20:54.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.968]                         if (muffled) 
[16:20:54.968]                           invokeRestart("muffleMessage")
[16:20:54.968]                       }
[16:20:54.968]                       else if (inherits(cond, "warning")) {
[16:20:54.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.968]                         if (muffled) 
[16:20:54.968]                           invokeRestart("muffleWarning")
[16:20:54.968]                       }
[16:20:54.968]                       else if (inherits(cond, "condition")) {
[16:20:54.968]                         if (!is.null(pattern)) {
[16:20:54.968]                           computeRestarts <- base::computeRestarts
[16:20:54.968]                           grepl <- base::grepl
[16:20:54.968]                           restarts <- computeRestarts(cond)
[16:20:54.968]                           for (restart in restarts) {
[16:20:54.968]                             name <- restart$name
[16:20:54.968]                             if (is.null(name)) 
[16:20:54.968]                               next
[16:20:54.968]                             if (!grepl(pattern, name)) 
[16:20:54.968]                               next
[16:20:54.968]                             invokeRestart(restart)
[16:20:54.968]                             muffled <- TRUE
[16:20:54.968]                             break
[16:20:54.968]                           }
[16:20:54.968]                         }
[16:20:54.968]                       }
[16:20:54.968]                       invisible(muffled)
[16:20:54.968]                     }
[16:20:54.968]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.968]                   }
[16:20:54.968]                 }
[16:20:54.968]                 else {
[16:20:54.968]                   if (TRUE) {
[16:20:54.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:54.968]                     {
[16:20:54.968]                       inherits <- base::inherits
[16:20:54.968]                       invokeRestart <- base::invokeRestart
[16:20:54.968]                       is.null <- base::is.null
[16:20:54.968]                       muffled <- FALSE
[16:20:54.968]                       if (inherits(cond, "message")) {
[16:20:54.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:54.968]                         if (muffled) 
[16:20:54.968]                           invokeRestart("muffleMessage")
[16:20:54.968]                       }
[16:20:54.968]                       else if (inherits(cond, "warning")) {
[16:20:54.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:54.968]                         if (muffled) 
[16:20:54.968]                           invokeRestart("muffleWarning")
[16:20:54.968]                       }
[16:20:54.968]                       else if (inherits(cond, "condition")) {
[16:20:54.968]                         if (!is.null(pattern)) {
[16:20:54.968]                           computeRestarts <- base::computeRestarts
[16:20:54.968]                           grepl <- base::grepl
[16:20:54.968]                           restarts <- computeRestarts(cond)
[16:20:54.968]                           for (restart in restarts) {
[16:20:54.968]                             name <- restart$name
[16:20:54.968]                             if (is.null(name)) 
[16:20:54.968]                               next
[16:20:54.968]                             if (!grepl(pattern, name)) 
[16:20:54.968]                               next
[16:20:54.968]                             invokeRestart(restart)
[16:20:54.968]                             muffled <- TRUE
[16:20:54.968]                             break
[16:20:54.968]                           }
[16:20:54.968]                         }
[16:20:54.968]                       }
[16:20:54.968]                       invisible(muffled)
[16:20:54.968]                     }
[16:20:54.968]                     muffleCondition(cond, pattern = "^muffle")
[16:20:54.968]                   }
[16:20:54.968]                 }
[16:20:54.968]             }
[16:20:54.968]         }))
[16:20:54.968]     }, error = function(ex) {
[16:20:54.968]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:54.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:54.968]                 ...future.rng), started = ...future.startTime, 
[16:20:54.968]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:54.968]             version = "1.8"), class = "FutureResult")
[16:20:54.968]     }, finally = {
[16:20:54.968]         if (!identical(...future.workdir, getwd())) 
[16:20:54.968]             setwd(...future.workdir)
[16:20:54.968]         {
[16:20:54.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:54.968]                 ...future.oldOptions$nwarnings <- NULL
[16:20:54.968]             }
[16:20:54.968]             base::options(...future.oldOptions)
[16:20:54.968]             if (.Platform$OS.type == "windows") {
[16:20:54.968]                 old_names <- names(...future.oldEnvVars)
[16:20:54.968]                 envs <- base::Sys.getenv()
[16:20:54.968]                 names <- names(envs)
[16:20:54.968]                 common <- intersect(names, old_names)
[16:20:54.968]                 added <- setdiff(names, old_names)
[16:20:54.968]                 removed <- setdiff(old_names, names)
[16:20:54.968]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:54.968]                   envs[common]]
[16:20:54.968]                 NAMES <- toupper(changed)
[16:20:54.968]                 args <- list()
[16:20:54.968]                 for (kk in seq_along(NAMES)) {
[16:20:54.968]                   name <- changed[[kk]]
[16:20:54.968]                   NAME <- NAMES[[kk]]
[16:20:54.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.968]                     next
[16:20:54.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.968]                 }
[16:20:54.968]                 NAMES <- toupper(added)
[16:20:54.968]                 for (kk in seq_along(NAMES)) {
[16:20:54.968]                   name <- added[[kk]]
[16:20:54.968]                   NAME <- NAMES[[kk]]
[16:20:54.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.968]                     next
[16:20:54.968]                   args[[name]] <- ""
[16:20:54.968]                 }
[16:20:54.968]                 NAMES <- toupper(removed)
[16:20:54.968]                 for (kk in seq_along(NAMES)) {
[16:20:54.968]                   name <- removed[[kk]]
[16:20:54.968]                   NAME <- NAMES[[kk]]
[16:20:54.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:54.968]                     next
[16:20:54.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:54.968]                 }
[16:20:54.968]                 if (length(args) > 0) 
[16:20:54.968]                   base::do.call(base::Sys.setenv, args = args)
[16:20:54.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:54.968]             }
[16:20:54.968]             else {
[16:20:54.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:54.968]             }
[16:20:54.968]             {
[16:20:54.968]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:54.968]                   0L) {
[16:20:54.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:54.968]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:54.968]                   base::options(opts)
[16:20:54.968]                 }
[16:20:54.968]                 {
[16:20:54.968]                   {
[16:20:54.968]                     NULL
[16:20:54.968]                     RNGkind("Mersenne-Twister")
[16:20:54.968]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:54.968]                       inherits = FALSE)
[16:20:54.968]                   }
[16:20:54.968]                   options(future.plan = NULL)
[16:20:54.968]                   if (is.na(NA_character_)) 
[16:20:54.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:54.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:54.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:54.968]                     .init = FALSE)
[16:20:54.968]                 }
[16:20:54.968]             }
[16:20:54.968]         }
[16:20:54.968]     })
[16:20:54.968]     if (TRUE) {
[16:20:54.968]         base::sink(type = "output", split = FALSE)
[16:20:54.968]         if (TRUE) {
[16:20:54.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:54.968]         }
[16:20:54.968]         else {
[16:20:54.968]             ...future.result["stdout"] <- base::list(NULL)
[16:20:54.968]         }
[16:20:54.968]         base::close(...future.stdout)
[16:20:54.968]         ...future.stdout <- NULL
[16:20:54.968]     }
[16:20:54.968]     ...future.result$conditions <- ...future.conditions
[16:20:54.968]     ...future.result$finished <- base::Sys.time()
[16:20:54.968]     ...future.result
[16:20:54.968] }
[16:20:54.970] assign_globals() ...
[16:20:54.970] List of 1
[16:20:54.970]  $ data:'data.frame':	5 obs. of  2 variables:
[16:20:54.970]   ..$ x: int [1:5] 1 2 3 4 5
[16:20:54.970]   ..$ y: int [1:5] 1 2 3 4 5
[16:20:54.970]  - attr(*, "where")=List of 1
[16:20:54.970]   ..$ data:<environment: R_EmptyEnv> 
[16:20:54.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:54.970]  - attr(*, "resolved")= logi FALSE
[16:20:54.970]  - attr(*, "total_size")= num 160
[16:20:54.970]  - attr(*, "already-done")= logi TRUE
[16:20:54.976] - copied ‘data’ to environment
[16:20:54.976] assign_globals() ... done
[16:20:54.977] plan(): Setting new future strategy stack:
[16:20:54.977] List of future strategies:
[16:20:54.977] 1. multicore:
[16:20:54.977]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:54.977]    - tweaked: FALSE
[16:20:54.977]    - call: plan(list(sequential, strategy))
[16:20:54.981] plan(): nbrOfWorkers() = 2
[16:20:55.028] plan(): Setting new future strategy stack:
[16:20:55.029] List of future strategies:
[16:20:55.029] 1. sequential:
[16:20:55.029]    - args: function (..., envir = parent.frame())
[16:20:55.029]    - tweaked: FALSE
[16:20:55.029]    - call: plan(list(sequential, strategy))
[16:20:55.029] 2. multicore:
[16:20:55.029]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:55.029]    - tweaked: FALSE
[16:20:55.029]    - call: plan(list(sequential, strategy))
[16:20:55.029] plan(): nbrOfWorkers() = 1
[16:20:55.030] SequentialFuture started (and completed)
[16:20:55.030] signalConditions() ...
[16:20:55.030]  - include = ‘immediateCondition’
[16:20:55.030]  - exclude = 
[16:20:55.030]  - resignal = FALSE
[16:20:55.030]  - Number of conditions: 56
[16:20:55.030] signalConditions() ... done
[16:20:55.030] - Launch lazy future ... done
[16:20:55.031] run() for ‘SequentialFuture’ ... done
[16:20:55.031] signalConditions() ...
[16:20:55.031]  - include = ‘immediateCondition’
[16:20:55.031]  - exclude = 
[16:20:55.031]  - resignal = FALSE
[16:20:55.031]  - Number of conditions: 56
[16:20:55.031] signalConditions() ... done
[16:20:55.032] Future state: ‘finished’
[16:20:55.032] signalConditions() ...
[16:20:55.032]  - include = ‘condition’
[16:20:55.032]  - exclude = ‘immediateCondition’
[16:20:55.032]  - resignal = TRUE
[16:20:55.032]  - Number of conditions: 56
[16:20:55.032]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.981] getGlobalsAndPackages() ...
[16:20:55.032]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:55.033]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.995] Searching for globals...
[16:20:55.033]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.998] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[16:20:55.033]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.998] Searching for globals ... DONE
[16:20:55.033]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.998] Resolving globals: FALSE
[16:20:55.033]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.999] The total size of the 1 globals is 160 bytes (160 bytes)
[16:20:55.033]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.999] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[16:20:55.034]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.999] - globals: [1] ‘data’
[16:20:55.034]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.999] 
[16:20:55.034]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:54.999] getGlobalsAndPackages() ... DONE
[16:20:55.034]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.000] run() for ‘Future’ ...
[16:20:55.034]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.000] - state: ‘created’
[16:20:55.034]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:55.035]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.004] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:55.035]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:55.035]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.004]   - Field: ‘label’
[16:20:55.035]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.004]   - Field: ‘local’
[16:20:55.035]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.004]   - Field: ‘owner’
[16:20:55.035]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.004]   - Field: ‘envir’
[16:20:55.036]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.004]   - Field: ‘workers’
[16:20:55.036]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.004]   - Field: ‘packages’
[16:20:55.036]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.005]   - Field: ‘gc’
[16:20:55.036]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.005]   - Field: ‘job’
[16:20:55.036]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.005]   - Field: ‘conditions’
[16:20:55.036]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.005]   - Field: ‘expr’
[16:20:55.037]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.005]   - Field: ‘uuid’
[16:20:55.037]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.005]   - Field: ‘seed’
[16:20:55.037]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.005]   - Field: ‘version’
[16:20:55.037]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.005]   - Field: ‘result’
[16:20:55.037]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.005]   - Field: ‘asynchronous’
[16:20:55.037]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.006]   - Field: ‘calls’
[16:20:55.038]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.006]   - Field: ‘globals’
[16:20:55.038]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.006]   - Field: ‘stdout’
[16:20:55.038]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.006]   - Field: ‘earlySignal’
[16:20:55.038]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.006]   - Field: ‘lazy’
[16:20:55.038]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.006]   - Field: ‘state’
[16:20:55.038]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:55.038]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.006] - Launch lazy future ...
[16:20:55.039]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.007] Packages needed by the future expression (n = 0): <none>
[16:20:55.039]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.007] Packages needed by future strategies (n = 0): <none>
[16:20:55.041]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.007] {
[16:20:55.007]     {
[16:20:55.007]         {
[16:20:55.007]             ...future.startTime <- base::Sys.time()
[16:20:55.007]             {
[16:20:55.007]                 {
[16:20:55.007]                   {
[16:20:55.007]                     {
[16:20:55.007]                       base::local({
[16:20:55.007]                         has_future <- base::requireNamespace("future", 
[16:20:55.007]                           quietly = TRUE)
[16:20:55.007]                         if (has_future) {
[16:20:55.007]                           ns <- base::getNamespace("future")
[16:20:55.007]                           version <- ns[[".package"]][["version"]]
[16:20:55.007]                           if (is.null(version)) 
[16:20:55.007]                             version <- utils::packageVersion("future")
[16:20:55.007]                         }
[16:20:55.007]                         else {
[16:20:55.007]                           version <- NULL
[16:20:55.007]                         }
[16:20:55.007]                         if (!has_future || version < "1.8.0") {
[16:20:55.007]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:55.007]                             "", base::R.version$version.string), 
[16:20:55.007]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:55.007]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:55.007]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:55.007]                               "release", "version")], collapse = " "), 
[16:20:55.007]                             hostname = base::Sys.info()[["nodename"]])
[16:20:55.007]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:55.007]                             info)
[16:20:55.007]                           info <- base::paste(info, collapse = "; ")
[16:20:55.007]                           if (!has_future) {
[16:20:55.007]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:55.007]                               info)
[16:20:55.007]                           }
[16:20:55.007]                           else {
[16:20:55.007]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:55.007]                               info, version)
[16:20:55.007]                           }
[16:20:55.007]                           base::stop(msg)
[16:20:55.007]                         }
[16:20:55.007]                       })
[16:20:55.007]                     }
[16:20:55.007]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:55.007]                     base::options(mc.cores = 1L)
[16:20:55.007]                   }
[16:20:55.007]                   ...future.strategy.old <- future::plan("list")
[16:20:55.007]                   options(future.plan = NULL)
[16:20:55.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:55.007]                 }
[16:20:55.007]                 ...future.workdir <- getwd()
[16:20:55.007]             }
[16:20:55.007]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:55.007]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:55.007]         }
[16:20:55.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:55.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:55.007]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:55.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:55.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:55.007]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:55.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:55.007]             base::names(...future.oldOptions))
[16:20:55.007]     }
[16:20:55.007]     if (FALSE) {
[16:20:55.007]     }
[16:20:55.007]     else {
[16:20:55.007]         if (TRUE) {
[16:20:55.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:55.007]                 open = "w")
[16:20:55.007]         }
[16:20:55.007]         else {
[16:20:55.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:55.007]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:55.007]         }
[16:20:55.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:55.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:55.007]             base::sink(type = "output", split = FALSE)
[16:20:55.007]             base::close(...future.stdout)
[16:20:55.007]         }, add = TRUE)
[16:20:55.007]     }
[16:20:55.007]     ...future.frame <- base::sys.nframe()
[16:20:55.007]     ...future.conditions <- base::list()
[16:20:55.007]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:55.007]     if (FALSE) {
[16:20:55.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:55.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:55.007]     }
[16:20:55.007]     ...future.result <- base::tryCatch({
[16:20:55.007]         base::withCallingHandlers({
[16:20:55.007]             ...future.value <- base::withVisible(base::local({
[16:20:55.007]                 withCallingHandlers({
[16:20:55.007]                   subset(data, x < 3)$y
[16:20:55.007]                 }, immediateCondition = function(cond) {
[16:20:55.007]                   save_rds <- function (object, pathname, ...) 
[16:20:55.007]                   {
[16:20:55.007]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:55.007]                     if (file_test("-f", pathname_tmp)) {
[16:20:55.007]                       fi_tmp <- file.info(pathname_tmp)
[16:20:55.007]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:55.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:55.007]                         fi_tmp[["mtime"]])
[16:20:55.007]                     }
[16:20:55.007]                     tryCatch({
[16:20:55.007]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:55.007]                     }, error = function(ex) {
[16:20:55.007]                       msg <- conditionMessage(ex)
[16:20:55.007]                       fi_tmp <- file.info(pathname_tmp)
[16:20:55.007]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:55.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:55.007]                         fi_tmp[["mtime"]], msg)
[16:20:55.007]                       ex$message <- msg
[16:20:55.007]                       stop(ex)
[16:20:55.007]                     })
[16:20:55.007]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:55.007]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:55.007]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:55.007]                       fi_tmp <- file.info(pathname_tmp)
[16:20:55.007]                       fi <- file.info(pathname)
[16:20:55.007]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:55.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:55.007]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:55.007]                         fi[["size"]], fi[["mtime"]])
[16:20:55.007]                       stop(msg)
[16:20:55.007]                     }
[16:20:55.007]                     invisible(pathname)
[16:20:55.007]                   }
[16:20:55.007]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:55.007]                     rootPath = tempdir()) 
[16:20:55.007]                   {
[16:20:55.007]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:55.007]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:55.007]                       tmpdir = path, fileext = ".rds")
[16:20:55.007]                     save_rds(obj, file)
[16:20:55.007]                   }
[16:20:55.007]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6LbKVK/.future/immediateConditions")
[16:20:55.007]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.007]                   {
[16:20:55.007]                     inherits <- base::inherits
[16:20:55.007]                     invokeRestart <- base::invokeRestart
[16:20:55.007]                     is.null <- base::is.null
[16:20:55.007]                     muffled <- FALSE
[16:20:55.007]                     if (inherits(cond, "message")) {
[16:20:55.007]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:55.007]                       if (muffled) 
[16:20:55.007]                         invokeRestart("muffleMessage")
[16:20:55.007]                     }
[16:20:55.007]                     else if (inherits(cond, "warning")) {
[16:20:55.007]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:55.007]                       if (muffled) 
[16:20:55.007]                         invokeRestart("muffleWarning")
[16:20:55.007]                     }
[16:20:55.007]                     else if (inherits(cond, "condition")) {
[16:20:55.007]                       if (!is.null(pattern)) {
[16:20:55.007]                         computeRestarts <- base::computeRestarts
[16:20:55.007]                         grepl <- base::grepl
[16:20:55.007]                         restarts <- computeRestarts(cond)
[16:20:55.007]                         for (restart in restarts) {
[16:20:55.007]                           name <- restart$name
[16:20:55.007]                           if (is.null(name)) 
[16:20:55.007]                             next
[16:20:55.007]                           if (!grepl(pattern, name)) 
[16:20:55.007]                             next
[16:20:55.007]                           invokeRestart(restart)
[16:20:55.007]                           muffled <- TRUE
[16:20:55.007]                           break
[16:20:55.007]                         }
[16:20:55.007]                       }
[16:20:55.007]                     }
[16:20:55.007]                     invisible(muffled)
[16:20:55.007]                   }
[16:20:55.007]                   muffleCondition(cond)
[16:20:55.007]                 })
[16:20:55.007]             }))
[16:20:55.007]             future::FutureResult(value = ...future.value$value, 
[16:20:55.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.007]                   ...future.rng), globalenv = if (FALSE) 
[16:20:55.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:55.007]                     ...future.globalenv.names))
[16:20:55.007]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:55.007]         }, condition = base::local({
[16:20:55.007]             c <- base::c
[16:20:55.007]             inherits <- base::inherits
[16:20:55.007]             invokeRestart <- base::invokeRestart
[16:20:55.007]             length <- base::length
[16:20:55.007]             list <- base::list
[16:20:55.007]             seq.int <- base::seq.int
[16:20:55.007]             signalCondition <- base::signalCondition
[16:20:55.007]             sys.calls <- base::sys.calls
[16:20:55.007]             `[[` <- base::`[[`
[16:20:55.007]             `+` <- base::`+`
[16:20:55.007]             `<<-` <- base::`<<-`
[16:20:55.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:55.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:55.007]                   3L)]
[16:20:55.007]             }
[16:20:55.007]             function(cond) {
[16:20:55.007]                 is_error <- inherits(cond, "error")
[16:20:55.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:55.007]                   NULL)
[16:20:55.007]                 if (is_error) {
[16:20:55.007]                   sessionInformation <- function() {
[16:20:55.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:55.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:55.007]                       search = base::search(), system = base::Sys.info())
[16:20:55.007]                   }
[16:20:55.007]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:55.007]                     cond$call), session = sessionInformation(), 
[16:20:55.007]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:55.007]                   signalCondition(cond)
[16:20:55.007]                 }
[16:20:55.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:55.007]                 "immediateCondition"))) {
[16:20:55.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:55.007]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:55.007]                   if (TRUE && !signal) {
[16:20:55.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.007]                     {
[16:20:55.007]                       inherits <- base::inherits
[16:20:55.007]                       invokeRestart <- base::invokeRestart
[16:20:55.007]                       is.null <- base::is.null
[16:20:55.007]                       muffled <- FALSE
[16:20:55.007]                       if (inherits(cond, "message")) {
[16:20:55.007]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.007]                         if (muffled) 
[16:20:55.007]                           invokeRestart("muffleMessage")
[16:20:55.007]                       }
[16:20:55.007]                       else if (inherits(cond, "warning")) {
[16:20:55.007]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.007]                         if (muffled) 
[16:20:55.007]                           invokeRestart("muffleWarning")
[16:20:55.007]                       }
[16:20:55.007]                       else if (inherits(cond, "condition")) {
[16:20:55.007]                         if (!is.null(pattern)) {
[16:20:55.007]                           computeRestarts <- base::computeRestarts
[16:20:55.007]                           grepl <- base::grepl
[16:20:55.007]                           restarts <- computeRestarts(cond)
[16:20:55.007]                           for (restart in restarts) {
[16:20:55.007]                             name <- restart$name
[16:20:55.007]                             if (is.null(name)) 
[16:20:55.007]                               next
[16:20:55.007]                             if (!grepl(pattern, name)) 
[16:20:55.007]                               next
[16:20:55.007]                             invokeRestart(restart)
[16:20:55.007]                             muffled <- TRUE
[16:20:55.007]                             break
[16:20:55.007]                           }
[16:20:55.007]                         }
[16:20:55.007]                       }
[16:20:55.007]                       invisible(muffled)
[16:20:55.007]                     }
[16:20:55.007]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.007]                   }
[16:20:55.007]                 }
[16:20:55.007]                 else {
[16:20:55.007]                   if (TRUE) {
[16:20:55.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.007]                     {
[16:20:55.007]                       inherits <- base::inherits
[16:20:55.007]                       invokeRestart <- base::invokeRestart
[16:20:55.007]                       is.null <- base::is.null
[16:20:55.007]                       muffled <- FALSE
[16:20:55.007]                       if (inherits(cond, "message")) {
[16:20:55.007]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.007]                         if (muffled) 
[16:20:55.007]                           invokeRestart("muffleMessage")
[16:20:55.007]                       }
[16:20:55.007]                       else if (inherits(cond, "warning")) {
[16:20:55.007]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.007]                         if (muffled) 
[16:20:55.007]                           invokeRestart("muffleWarning")
[16:20:55.007]                       }
[16:20:55.007]                       else if (inherits(cond, "condition")) {
[16:20:55.007]                         if (!is.null(pattern)) {
[16:20:55.007]                           computeRestarts <- base::computeRestarts
[16:20:55.007]                           grepl <- base::grepl
[16:20:55.007]                           restarts <- computeRestarts(cond)
[16:20:55.007]                           for (restart in restarts) {
[16:20:55.007]                             name <- restart$name
[16:20:55.007]                             if (is.null(name)) 
[16:20:55.007]                               next
[16:20:55.007]                             if (!grepl(pattern, name)) 
[16:20:55.007]                               next
[16:20:55.007]                             invokeRestart(restart)
[16:20:55.007]                             muffled <- TRUE
[16:20:55.007]                             break
[16:20:55.007]                           }
[16:20:55.007]                         }
[16:20:55.007]                       }
[16:20:55.007]                       invisible(muffled)
[16:20:55.007]                     }
[16:20:55.007]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.007]                   }
[16:20:55.007]                 }
[16:20:55.007]             }
[16:20:55.007]         }))
[16:20:55.007]     }, error = function(ex) {
[16:20:55.007]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:55.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.007]                 ...future.rng), started = ...future.startTime, 
[16:20:55.007]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:55.007]             version = "1.8"), class = "FutureResult")
[16:20:55.007]     }, finally = {
[16:20:55.007]         if (!identical(...future.workdir, getwd())) 
[16:20:55.007]             setwd(...future.workdir)
[16:20:55.007]         {
[16:20:55.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:55.007]                 ...future.oldOptions$nwarnings <- NULL
[16:20:55.007]             }
[16:20:55.007]             base::options(...future.oldOptions)
[16:20:55.007]             if (.Platform$OS.type == "windows") {
[16:20:55.007]                 old_names <- names(...future.oldEnvVars)
[16:20:55.007]                 envs <- base::Sys.getenv()
[16:20:55.007]                 names <- names(envs)
[16:20:55.007]                 common <- intersect(names, old_names)
[16:20:55.007]                 added <- setdiff(names, old_names)
[16:20:55.007]                 removed <- setdiff(old_names, names)
[16:20:55.007]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:55.007]                   envs[common]]
[16:20:55.007]                 NAMES <- toupper(changed)
[16:20:55.007]                 args <- list()
[16:20:55.007]                 for (kk in seq_along(NAMES)) {
[16:20:55.007]                   name <- changed[[kk]]
[16:20:55.007]                   NAME <- NAMES[[kk]]
[16:20:55.007]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.007]                     next
[16:20:55.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.007]                 }
[16:20:55.007]                 NAMES <- toupper(added)
[16:20:55.007]                 for (kk in seq_along(NAMES)) {
[16:20:55.007]                   name <- added[[kk]]
[16:20:55.007]                   NAME <- NAMES[[kk]]
[16:20:55.007]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.007]                     next
[16:20:55.007]                   args[[name]] <- ""
[16:20:55.007]                 }
[16:20:55.007]                 NAMES <- toupper(removed)
[16:20:55.007]                 for (kk in seq_along(NAMES)) {
[16:20:55.007]                   name <- removed[[kk]]
[16:20:55.007]                   NAME <- NAMES[[kk]]
[16:20:55.007]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.007]                     next
[16:20:55.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.007]                 }
[16:20:55.007]                 if (length(args) > 0) 
[16:20:55.007]                   base::do.call(base::Sys.setenv, args = args)
[16:20:55.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:55.007]             }
[16:20:55.007]             else {
[16:20:55.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:55.007]             }
[16:20:55.007]             {
[16:20:55.007]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:55.007]                   0L) {
[16:20:55.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:55.007]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:55.007]                   base::options(opts)
[16:20:55.007]                 }
[16:20:55.007]                 {
[16:20:55.007]                   {
[16:20:55.007]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:55.007]                     NULL
[16:20:55.007]                   }
[16:20:55.007]                   options(future.plan = NULL)
[16:20:55.007]                   if (is.na(NA_character_)) 
[16:20:55.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:55.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:55.007]                     .init = FALSE)
[16:20:55.007]                 }
[16:20:55.007]             }
[16:20:55.007]         }
[16:20:55.007]     })
[16:20:55.007]     if (TRUE) {
[16:20:55.007]         base::sink(type = "output", split = FALSE)
[16:20:55.007]         if (TRUE) {
[16:20:55.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:55.007]         }
[16:20:55.007]         else {
[16:20:55.007]             ...future.result["stdout"] <- base::list(NULL)
[16:20:55.007]         }
[16:20:55.007]         base::close(...future.stdout)
[16:20:55.007]         ...future.stdout <- NULL
[16:20:55.007]     }
[16:20:55.007]     ...future.result$conditions <- ...future.conditions
[16:20:55.007]     ...future.result$finished <- base::Sys.time()
[16:20:55.007]     ...future.result
[16:20:55.007] }
[16:20:55.042]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.009] assign_globals() ...
[16:20:55.042]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.009] List of 1
[16:20:55.009]  $ data:'data.frame':	5 obs. of  2 variables:
[16:20:55.009]   ..$ x: int [1:5] 1 2 3 4 5
[16:20:55.009]   ..$ y: int [1:5] 1 2 3 4 5
[16:20:55.009]  - attr(*, "where")=List of 1
[16:20:55.009]   ..$ data:<environment: R_EmptyEnv> 
[16:20:55.009]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:55.009]  - attr(*, "resolved")= logi FALSE
[16:20:55.009]  - attr(*, "total_size")= num 160
[16:20:55.009]  - attr(*, "already-done")= logi TRUE
[16:20:55.042]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.013] - copied ‘data’ to environment
[16:20:55.042]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.013] assign_globals() ... done
[16:20:55.042]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.013] requestCore(): workers = 2
[16:20:55.043]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.015] MulticoreFuture started
[16:20:55.043]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.016] - Launch lazy future ... done
[16:20:55.043]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.016] run() for ‘MulticoreFuture’ ... done
[16:20:55.043]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.017] result() for MulticoreFuture ...
[16:20:55.043]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.027] result() for MulticoreFuture ...
[16:20:55.044]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.027] result() for MulticoreFuture ... done
[16:20:55.044]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.027] result() for MulticoreFuture ... done
[16:20:55.044]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.027] result() for MulticoreFuture ...
[16:20:55.044]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.027] result() for MulticoreFuture ... done
[16:20:55.044] signalConditions() ... done
- Strategy: multicore ... DONE
- Strategy: multisession ...
[16:20:55.045] plan(): Setting new future strategy stack:
[16:20:55.045] List of future strategies:
[16:20:55.045] 1. multisession:
[16:20:55.045]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:55.045]    - tweaked: FALSE
[16:20:55.045]    - call: plan(strategy)
[16:20:55.045] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:20:55.046] multisession:
[16:20:55.046] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:55.046] - tweaked: FALSE
[16:20:55.046] - call: plan(strategy)
[16:20:55.052] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:55.052] Not searching for globals
[16:20:55.053] - globals: [0] <none>
[16:20:55.053] getGlobalsAndPackages() ... DONE
[16:20:55.053] [local output] makeClusterPSOCK() ...
[16:20:55.093] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:20:55.095] [local output] Base port: 11665
[16:20:55.095] [local output] Getting setup options for 2 cluster nodes ...
[16:20:55.095] [local output]  - Node 1 of 2 ...
[16:20:55.095] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:55.096] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6LbKVK/worker.rank=1.parallelly.parent=82995.144332a4b062c.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp6LbKVK/worker.rank=1.parallelly.parent=82995.144332a4b062c.pid")'’
[16:20:55.283] - Possible to infer worker's PID: TRUE
[16:20:55.283] [local output] Rscript port: 11665

[16:20:55.284] [local output]  - Node 2 of 2 ...
[16:20:55.284] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:55.285] [local output] Rscript port: 11665

[16:20:55.285] [local output] Getting setup options for 2 cluster nodes ... done
[16:20:55.285] [local output]  - Parallel setup requested for some PSOCK nodes
[16:20:55.286] [local output] Setting up PSOCK nodes in parallel
[16:20:55.286] List of 36
[16:20:55.286]  $ worker          : chr "localhost"
[16:20:55.286]   ..- attr(*, "localhost")= logi TRUE
[16:20:55.286]  $ master          : chr "localhost"
[16:20:55.286]  $ port            : int 11665
[16:20:55.286]  $ connectTimeout  : num 120
[16:20:55.286]  $ timeout         : num 2592000
[16:20:55.286]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:20:55.286]  $ homogeneous     : logi TRUE
[16:20:55.286]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:20:55.286]  $ rscript_envs    : NULL
[16:20:55.286]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:55.286]  $ rscript_startup : NULL
[16:20:55.286]  $ rscript_sh      : chr "sh"
[16:20:55.286]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:55.286]  $ methods         : logi TRUE
[16:20:55.286]  $ socketOptions   : chr "no-delay"
[16:20:55.286]  $ useXDR          : logi FALSE
[16:20:55.286]  $ outfile         : chr "/dev/null"
[16:20:55.286]  $ renice          : int NA
[16:20:55.286]  $ rshcmd          : NULL
[16:20:55.286]  $ user            : chr(0) 
[16:20:55.286]  $ revtunnel       : logi FALSE
[16:20:55.286]  $ rshlogfile      : NULL
[16:20:55.286]  $ rshopts         : chr(0) 
[16:20:55.286]  $ rank            : int 1
[16:20:55.286]  $ manual          : logi FALSE
[16:20:55.286]  $ dryrun          : logi FALSE
[16:20:55.286]  $ quiet           : logi FALSE
[16:20:55.286]  $ setup_strategy  : chr "parallel"
[16:20:55.286]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:55.286]  $ pidfile         : chr "/tmp/Rtmp6LbKVK/worker.rank=1.parallelly.parent=82995.144332a4b062c.pid"
[16:20:55.286]  $ rshcmd_label    : NULL
[16:20:55.286]  $ rsh_call        : NULL
[16:20:55.286]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:55.286]  $ localMachine    : logi TRUE
[16:20:55.286]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:20:55.286]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:20:55.286]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:20:55.286]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:20:55.286]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:20:55.286]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:20:55.286]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:20:55.286]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:20:55.286]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:20:55.286]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:20:55.286]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:20:55.286]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:20:55.286]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:20:55.286]  $ arguments       :List of 28
[16:20:55.286]   ..$ worker          : chr "localhost"
[16:20:55.286]   ..$ master          : NULL
[16:20:55.286]   ..$ port            : int 11665
[16:20:55.286]   ..$ connectTimeout  : num 120
[16:20:55.286]   ..$ timeout         : num 2592000
[16:20:55.286]   ..$ rscript         : NULL
[16:20:55.286]   ..$ homogeneous     : NULL
[16:20:55.286]   ..$ rscript_args    : NULL
[16:20:55.286]   ..$ rscript_envs    : NULL
[16:20:55.286]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:55.286]   ..$ rscript_startup : NULL
[16:20:55.286]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:20:55.286]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:55.286]   ..$ methods         : logi TRUE
[16:20:55.286]   ..$ socketOptions   : chr "no-delay"
[16:20:55.286]   ..$ useXDR          : logi FALSE
[16:20:55.286]   ..$ outfile         : chr "/dev/null"
[16:20:55.286]   ..$ renice          : int NA
[16:20:55.286]   ..$ rshcmd          : NULL
[16:20:55.286]   ..$ user            : NULL
[16:20:55.286]   ..$ revtunnel       : logi NA
[16:20:55.286]   ..$ rshlogfile      : NULL
[16:20:55.286]   ..$ rshopts         : NULL
[16:20:55.286]   ..$ rank            : int 1
[16:20:55.286]   ..$ manual          : logi FALSE
[16:20:55.286]   ..$ dryrun          : logi FALSE
[16:20:55.286]   ..$ quiet           : logi FALSE
[16:20:55.286]   ..$ setup_strategy  : chr "parallel"
[16:20:55.286]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:20:55.302] [local output] System call to launch all workers:
[16:20:55.303] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6LbKVK/worker.rank=1.parallelly.parent=82995.144332a4b062c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11665 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:20:55.303] [local output] Starting PSOCK main server
[16:20:55.308] [local output] Workers launched
[16:20:55.308] [local output] Waiting for workers to connect back
[16:20:55.309]  - [local output] 0 workers out of 2 ready
[16:20:55.575]  - [local output] 0 workers out of 2 ready
[16:20:55.576]  - [local output] 1 workers out of 2 ready
[16:20:55.576]  - [local output] 2 workers out of 2 ready
[16:20:55.577] [local output] Launching of workers completed
[16:20:55.577] [local output] Collecting session information from workers
[16:20:55.578] [local output]  - Worker #1 of 2
[16:20:55.578] [local output]  - Worker #2 of 2
[16:20:55.578] [local output] makeClusterPSOCK() ... done
[16:20:55.590] Packages needed by the future expression (n = 0): <none>
[16:20:55.590] Packages needed by future strategies (n = 0): <none>
[16:20:55.590] {
[16:20:55.590]     {
[16:20:55.590]         {
[16:20:55.590]             ...future.startTime <- base::Sys.time()
[16:20:55.590]             {
[16:20:55.590]                 {
[16:20:55.590]                   {
[16:20:55.590]                     {
[16:20:55.590]                       base::local({
[16:20:55.590]                         has_future <- base::requireNamespace("future", 
[16:20:55.590]                           quietly = TRUE)
[16:20:55.590]                         if (has_future) {
[16:20:55.590]                           ns <- base::getNamespace("future")
[16:20:55.590]                           version <- ns[[".package"]][["version"]]
[16:20:55.590]                           if (is.null(version)) 
[16:20:55.590]                             version <- utils::packageVersion("future")
[16:20:55.590]                         }
[16:20:55.590]                         else {
[16:20:55.590]                           version <- NULL
[16:20:55.590]                         }
[16:20:55.590]                         if (!has_future || version < "1.8.0") {
[16:20:55.590]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:55.590]                             "", base::R.version$version.string), 
[16:20:55.590]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:55.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:55.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:55.590]                               "release", "version")], collapse = " "), 
[16:20:55.590]                             hostname = base::Sys.info()[["nodename"]])
[16:20:55.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:55.590]                             info)
[16:20:55.590]                           info <- base::paste(info, collapse = "; ")
[16:20:55.590]                           if (!has_future) {
[16:20:55.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:55.590]                               info)
[16:20:55.590]                           }
[16:20:55.590]                           else {
[16:20:55.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:55.590]                               info, version)
[16:20:55.590]                           }
[16:20:55.590]                           base::stop(msg)
[16:20:55.590]                         }
[16:20:55.590]                       })
[16:20:55.590]                     }
[16:20:55.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:55.590]                     base::options(mc.cores = 1L)
[16:20:55.590]                   }
[16:20:55.590]                   ...future.strategy.old <- future::plan("list")
[16:20:55.590]                   options(future.plan = NULL)
[16:20:55.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:55.590]                 }
[16:20:55.590]                 ...future.workdir <- getwd()
[16:20:55.590]             }
[16:20:55.590]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:55.590]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:55.590]         }
[16:20:55.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:55.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:55.590]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:55.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:55.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:55.590]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:55.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:55.590]             base::names(...future.oldOptions))
[16:20:55.590]     }
[16:20:55.590]     if (FALSE) {
[16:20:55.590]     }
[16:20:55.590]     else {
[16:20:55.590]         if (TRUE) {
[16:20:55.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:55.590]                 open = "w")
[16:20:55.590]         }
[16:20:55.590]         else {
[16:20:55.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:55.590]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:55.590]         }
[16:20:55.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:55.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:55.590]             base::sink(type = "output", split = FALSE)
[16:20:55.590]             base::close(...future.stdout)
[16:20:55.590]         }, add = TRUE)
[16:20:55.590]     }
[16:20:55.590]     ...future.frame <- base::sys.nframe()
[16:20:55.590]     ...future.conditions <- base::list()
[16:20:55.590]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:55.590]     if (FALSE) {
[16:20:55.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:55.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:55.590]     }
[16:20:55.590]     ...future.result <- base::tryCatch({
[16:20:55.590]         base::withCallingHandlers({
[16:20:55.590]             ...future.value <- base::withVisible(base::local({
[16:20:55.590]                 ...future.makeSendCondition <- base::local({
[16:20:55.590]                   sendCondition <- NULL
[16:20:55.590]                   function(frame = 1L) {
[16:20:55.590]                     if (is.function(sendCondition)) 
[16:20:55.590]                       return(sendCondition)
[16:20:55.590]                     ns <- getNamespace("parallel")
[16:20:55.590]                     if (exists("sendData", mode = "function", 
[16:20:55.590]                       envir = ns)) {
[16:20:55.590]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:55.590]                         envir = ns)
[16:20:55.590]                       envir <- sys.frame(frame)
[16:20:55.590]                       master <- NULL
[16:20:55.590]                       while (!identical(envir, .GlobalEnv) && 
[16:20:55.590]                         !identical(envir, emptyenv())) {
[16:20:55.590]                         if (exists("master", mode = "list", envir = envir, 
[16:20:55.590]                           inherits = FALSE)) {
[16:20:55.590]                           master <- get("master", mode = "list", 
[16:20:55.590]                             envir = envir, inherits = FALSE)
[16:20:55.590]                           if (inherits(master, c("SOCKnode", 
[16:20:55.590]                             "SOCK0node"))) {
[16:20:55.590]                             sendCondition <<- function(cond) {
[16:20:55.590]                               data <- list(type = "VALUE", value = cond, 
[16:20:55.590]                                 success = TRUE)
[16:20:55.590]                               parallel_sendData(master, data)
[16:20:55.590]                             }
[16:20:55.590]                             return(sendCondition)
[16:20:55.590]                           }
[16:20:55.590]                         }
[16:20:55.590]                         frame <- frame + 1L
[16:20:55.590]                         envir <- sys.frame(frame)
[16:20:55.590]                       }
[16:20:55.590]                     }
[16:20:55.590]                     sendCondition <<- function(cond) NULL
[16:20:55.590]                   }
[16:20:55.590]                 })
[16:20:55.590]                 withCallingHandlers({
[16:20:55.590]                   NA
[16:20:55.590]                 }, immediateCondition = function(cond) {
[16:20:55.590]                   sendCondition <- ...future.makeSendCondition()
[16:20:55.590]                   sendCondition(cond)
[16:20:55.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.590]                   {
[16:20:55.590]                     inherits <- base::inherits
[16:20:55.590]                     invokeRestart <- base::invokeRestart
[16:20:55.590]                     is.null <- base::is.null
[16:20:55.590]                     muffled <- FALSE
[16:20:55.590]                     if (inherits(cond, "message")) {
[16:20:55.590]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:55.590]                       if (muffled) 
[16:20:55.590]                         invokeRestart("muffleMessage")
[16:20:55.590]                     }
[16:20:55.590]                     else if (inherits(cond, "warning")) {
[16:20:55.590]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:55.590]                       if (muffled) 
[16:20:55.590]                         invokeRestart("muffleWarning")
[16:20:55.590]                     }
[16:20:55.590]                     else if (inherits(cond, "condition")) {
[16:20:55.590]                       if (!is.null(pattern)) {
[16:20:55.590]                         computeRestarts <- base::computeRestarts
[16:20:55.590]                         grepl <- base::grepl
[16:20:55.590]                         restarts <- computeRestarts(cond)
[16:20:55.590]                         for (restart in restarts) {
[16:20:55.590]                           name <- restart$name
[16:20:55.590]                           if (is.null(name)) 
[16:20:55.590]                             next
[16:20:55.590]                           if (!grepl(pattern, name)) 
[16:20:55.590]                             next
[16:20:55.590]                           invokeRestart(restart)
[16:20:55.590]                           muffled <- TRUE
[16:20:55.590]                           break
[16:20:55.590]                         }
[16:20:55.590]                       }
[16:20:55.590]                     }
[16:20:55.590]                     invisible(muffled)
[16:20:55.590]                   }
[16:20:55.590]                   muffleCondition(cond)
[16:20:55.590]                 })
[16:20:55.590]             }))
[16:20:55.590]             future::FutureResult(value = ...future.value$value, 
[16:20:55.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.590]                   ...future.rng), globalenv = if (FALSE) 
[16:20:55.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:55.590]                     ...future.globalenv.names))
[16:20:55.590]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:55.590]         }, condition = base::local({
[16:20:55.590]             c <- base::c
[16:20:55.590]             inherits <- base::inherits
[16:20:55.590]             invokeRestart <- base::invokeRestart
[16:20:55.590]             length <- base::length
[16:20:55.590]             list <- base::list
[16:20:55.590]             seq.int <- base::seq.int
[16:20:55.590]             signalCondition <- base::signalCondition
[16:20:55.590]             sys.calls <- base::sys.calls
[16:20:55.590]             `[[` <- base::`[[`
[16:20:55.590]             `+` <- base::`+`
[16:20:55.590]             `<<-` <- base::`<<-`
[16:20:55.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:55.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:55.590]                   3L)]
[16:20:55.590]             }
[16:20:55.590]             function(cond) {
[16:20:55.590]                 is_error <- inherits(cond, "error")
[16:20:55.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:55.590]                   NULL)
[16:20:55.590]                 if (is_error) {
[16:20:55.590]                   sessionInformation <- function() {
[16:20:55.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:55.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:55.590]                       search = base::search(), system = base::Sys.info())
[16:20:55.590]                   }
[16:20:55.590]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:55.590]                     cond$call), session = sessionInformation(), 
[16:20:55.590]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:55.590]                   signalCondition(cond)
[16:20:55.590]                 }
[16:20:55.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:55.590]                 "immediateCondition"))) {
[16:20:55.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:55.590]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:55.590]                   if (TRUE && !signal) {
[16:20:55.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.590]                     {
[16:20:55.590]                       inherits <- base::inherits
[16:20:55.590]                       invokeRestart <- base::invokeRestart
[16:20:55.590]                       is.null <- base::is.null
[16:20:55.590]                       muffled <- FALSE
[16:20:55.590]                       if (inherits(cond, "message")) {
[16:20:55.590]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.590]                         if (muffled) 
[16:20:55.590]                           invokeRestart("muffleMessage")
[16:20:55.590]                       }
[16:20:55.590]                       else if (inherits(cond, "warning")) {
[16:20:55.590]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.590]                         if (muffled) 
[16:20:55.590]                           invokeRestart("muffleWarning")
[16:20:55.590]                       }
[16:20:55.590]                       else if (inherits(cond, "condition")) {
[16:20:55.590]                         if (!is.null(pattern)) {
[16:20:55.590]                           computeRestarts <- base::computeRestarts
[16:20:55.590]                           grepl <- base::grepl
[16:20:55.590]                           restarts <- computeRestarts(cond)
[16:20:55.590]                           for (restart in restarts) {
[16:20:55.590]                             name <- restart$name
[16:20:55.590]                             if (is.null(name)) 
[16:20:55.590]                               next
[16:20:55.590]                             if (!grepl(pattern, name)) 
[16:20:55.590]                               next
[16:20:55.590]                             invokeRestart(restart)
[16:20:55.590]                             muffled <- TRUE
[16:20:55.590]                             break
[16:20:55.590]                           }
[16:20:55.590]                         }
[16:20:55.590]                       }
[16:20:55.590]                       invisible(muffled)
[16:20:55.590]                     }
[16:20:55.590]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.590]                   }
[16:20:55.590]                 }
[16:20:55.590]                 else {
[16:20:55.590]                   if (TRUE) {
[16:20:55.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.590]                     {
[16:20:55.590]                       inherits <- base::inherits
[16:20:55.590]                       invokeRestart <- base::invokeRestart
[16:20:55.590]                       is.null <- base::is.null
[16:20:55.590]                       muffled <- FALSE
[16:20:55.590]                       if (inherits(cond, "message")) {
[16:20:55.590]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.590]                         if (muffled) 
[16:20:55.590]                           invokeRestart("muffleMessage")
[16:20:55.590]                       }
[16:20:55.590]                       else if (inherits(cond, "warning")) {
[16:20:55.590]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.590]                         if (muffled) 
[16:20:55.590]                           invokeRestart("muffleWarning")
[16:20:55.590]                       }
[16:20:55.590]                       else if (inherits(cond, "condition")) {
[16:20:55.590]                         if (!is.null(pattern)) {
[16:20:55.590]                           computeRestarts <- base::computeRestarts
[16:20:55.590]                           grepl <- base::grepl
[16:20:55.590]                           restarts <- computeRestarts(cond)
[16:20:55.590]                           for (restart in restarts) {
[16:20:55.590]                             name <- restart$name
[16:20:55.590]                             if (is.null(name)) 
[16:20:55.590]                               next
[16:20:55.590]                             if (!grepl(pattern, name)) 
[16:20:55.590]                               next
[16:20:55.590]                             invokeRestart(restart)
[16:20:55.590]                             muffled <- TRUE
[16:20:55.590]                             break
[16:20:55.590]                           }
[16:20:55.590]                         }
[16:20:55.590]                       }
[16:20:55.590]                       invisible(muffled)
[16:20:55.590]                     }
[16:20:55.590]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.590]                   }
[16:20:55.590]                 }
[16:20:55.590]             }
[16:20:55.590]         }))
[16:20:55.590]     }, error = function(ex) {
[16:20:55.590]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:55.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.590]                 ...future.rng), started = ...future.startTime, 
[16:20:55.590]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:55.590]             version = "1.8"), class = "FutureResult")
[16:20:55.590]     }, finally = {
[16:20:55.590]         if (!identical(...future.workdir, getwd())) 
[16:20:55.590]             setwd(...future.workdir)
[16:20:55.590]         {
[16:20:55.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:55.590]                 ...future.oldOptions$nwarnings <- NULL
[16:20:55.590]             }
[16:20:55.590]             base::options(...future.oldOptions)
[16:20:55.590]             if (.Platform$OS.type == "windows") {
[16:20:55.590]                 old_names <- names(...future.oldEnvVars)
[16:20:55.590]                 envs <- base::Sys.getenv()
[16:20:55.590]                 names <- names(envs)
[16:20:55.590]                 common <- intersect(names, old_names)
[16:20:55.590]                 added <- setdiff(names, old_names)
[16:20:55.590]                 removed <- setdiff(old_names, names)
[16:20:55.590]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:55.590]                   envs[common]]
[16:20:55.590]                 NAMES <- toupper(changed)
[16:20:55.590]                 args <- list()
[16:20:55.590]                 for (kk in seq_along(NAMES)) {
[16:20:55.590]                   name <- changed[[kk]]
[16:20:55.590]                   NAME <- NAMES[[kk]]
[16:20:55.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.590]                     next
[16:20:55.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.590]                 }
[16:20:55.590]                 NAMES <- toupper(added)
[16:20:55.590]                 for (kk in seq_along(NAMES)) {
[16:20:55.590]                   name <- added[[kk]]
[16:20:55.590]                   NAME <- NAMES[[kk]]
[16:20:55.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.590]                     next
[16:20:55.590]                   args[[name]] <- ""
[16:20:55.590]                 }
[16:20:55.590]                 NAMES <- toupper(removed)
[16:20:55.590]                 for (kk in seq_along(NAMES)) {
[16:20:55.590]                   name <- removed[[kk]]
[16:20:55.590]                   NAME <- NAMES[[kk]]
[16:20:55.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.590]                     next
[16:20:55.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.590]                 }
[16:20:55.590]                 if (length(args) > 0) 
[16:20:55.590]                   base::do.call(base::Sys.setenv, args = args)
[16:20:55.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:55.590]             }
[16:20:55.590]             else {
[16:20:55.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:55.590]             }
[16:20:55.590]             {
[16:20:55.590]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:55.590]                   0L) {
[16:20:55.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:55.590]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:55.590]                   base::options(opts)
[16:20:55.590]                 }
[16:20:55.590]                 {
[16:20:55.590]                   {
[16:20:55.590]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:55.590]                     NULL
[16:20:55.590]                   }
[16:20:55.590]                   options(future.plan = NULL)
[16:20:55.590]                   if (is.na(NA_character_)) 
[16:20:55.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:55.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:55.590]                     .init = FALSE)
[16:20:55.590]                 }
[16:20:55.590]             }
[16:20:55.590]         }
[16:20:55.590]     })
[16:20:55.590]     if (TRUE) {
[16:20:55.590]         base::sink(type = "output", split = FALSE)
[16:20:55.590]         if (TRUE) {
[16:20:55.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:55.590]         }
[16:20:55.590]         else {
[16:20:55.590]             ...future.result["stdout"] <- base::list(NULL)
[16:20:55.590]         }
[16:20:55.590]         base::close(...future.stdout)
[16:20:55.590]         ...future.stdout <- NULL
[16:20:55.590]     }
[16:20:55.590]     ...future.result$conditions <- ...future.conditions
[16:20:55.590]     ...future.result$finished <- base::Sys.time()
[16:20:55.590]     ...future.result
[16:20:55.590] }
[16:20:55.643] MultisessionFuture started
[16:20:55.643] result() for ClusterFuture ...
[16:20:55.644] receiveMessageFromWorker() for ClusterFuture ...
[16:20:55.644] - Validating connection of MultisessionFuture
[16:20:55.676] - received message: FutureResult
[16:20:55.677] - Received FutureResult
[16:20:55.677] - Erased future from FutureRegistry
[16:20:55.677] result() for ClusterFuture ...
[16:20:55.677] - result already collected: FutureResult
[16:20:55.677] result() for ClusterFuture ... done
[16:20:55.677] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:55.677] result() for ClusterFuture ... done
[16:20:55.677] result() for ClusterFuture ...
[16:20:55.678] - result already collected: FutureResult
[16:20:55.678] result() for ClusterFuture ... done
[16:20:55.678] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:20:55.682] plan(): nbrOfWorkers() = 2
[16:20:55.682] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:20:55.683] Searching for globals...
[16:20:55.683] - globals found: [1] ‘getOption’
[16:20:55.683] Searching for globals ... DONE
[16:20:55.683] Resolving globals: FALSE
[16:20:55.684] 
[16:20:55.684] 
[16:20:55.684] getGlobalsAndPackages() ... DONE
[16:20:55.684] run() for ‘Future’ ...
[16:20:55.685] - state: ‘created’
[16:20:55.685] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:55.699] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:55.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:55.699]   - Field: ‘node’
[16:20:55.699]   - Field: ‘label’
[16:20:55.699]   - Field: ‘local’
[16:20:55.699]   - Field: ‘owner’
[16:20:55.700]   - Field: ‘envir’
[16:20:55.700]   - Field: ‘workers’
[16:20:55.700]   - Field: ‘packages’
[16:20:55.700]   - Field: ‘gc’
[16:20:55.700]   - Field: ‘conditions’
[16:20:55.700]   - Field: ‘persistent’
[16:20:55.700]   - Field: ‘expr’
[16:20:55.700]   - Field: ‘uuid’
[16:20:55.700]   - Field: ‘seed’
[16:20:55.701]   - Field: ‘version’
[16:20:55.701]   - Field: ‘result’
[16:20:55.701]   - Field: ‘asynchronous’
[16:20:55.701]   - Field: ‘calls’
[16:20:55.701]   - Field: ‘globals’
[16:20:55.701]   - Field: ‘stdout’
[16:20:55.701]   - Field: ‘earlySignal’
[16:20:55.701]   - Field: ‘lazy’
[16:20:55.701]   - Field: ‘state’
[16:20:55.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:55.702] - Launch lazy future ...
[16:20:55.702] Packages needed by the future expression (n = 0): <none>
[16:20:55.702] Packages needed by future strategies (n = 0): <none>
[16:20:55.703] {
[16:20:55.703]     {
[16:20:55.703]         {
[16:20:55.703]             ...future.startTime <- base::Sys.time()
[16:20:55.703]             {
[16:20:55.703]                 {
[16:20:55.703]                   {
[16:20:55.703]                     {
[16:20:55.703]                       base::local({
[16:20:55.703]                         has_future <- base::requireNamespace("future", 
[16:20:55.703]                           quietly = TRUE)
[16:20:55.703]                         if (has_future) {
[16:20:55.703]                           ns <- base::getNamespace("future")
[16:20:55.703]                           version <- ns[[".package"]][["version"]]
[16:20:55.703]                           if (is.null(version)) 
[16:20:55.703]                             version <- utils::packageVersion("future")
[16:20:55.703]                         }
[16:20:55.703]                         else {
[16:20:55.703]                           version <- NULL
[16:20:55.703]                         }
[16:20:55.703]                         if (!has_future || version < "1.8.0") {
[16:20:55.703]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:55.703]                             "", base::R.version$version.string), 
[16:20:55.703]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:55.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:55.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:55.703]                               "release", "version")], collapse = " "), 
[16:20:55.703]                             hostname = base::Sys.info()[["nodename"]])
[16:20:55.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:55.703]                             info)
[16:20:55.703]                           info <- base::paste(info, collapse = "; ")
[16:20:55.703]                           if (!has_future) {
[16:20:55.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:55.703]                               info)
[16:20:55.703]                           }
[16:20:55.703]                           else {
[16:20:55.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:55.703]                               info, version)
[16:20:55.703]                           }
[16:20:55.703]                           base::stop(msg)
[16:20:55.703]                         }
[16:20:55.703]                       })
[16:20:55.703]                     }
[16:20:55.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:55.703]                     base::options(mc.cores = 1L)
[16:20:55.703]                   }
[16:20:55.703]                   ...future.strategy.old <- future::plan("list")
[16:20:55.703]                   options(future.plan = NULL)
[16:20:55.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:55.703]                 }
[16:20:55.703]                 ...future.workdir <- getwd()
[16:20:55.703]             }
[16:20:55.703]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:55.703]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:55.703]         }
[16:20:55.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:20:55.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:55.703]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:20:55.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:55.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:55.703]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:55.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:55.703]             base::names(...future.oldOptions))
[16:20:55.703]     }
[16:20:55.703]     if (FALSE) {
[16:20:55.703]     }
[16:20:55.703]     else {
[16:20:55.703]         if (TRUE) {
[16:20:55.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:55.703]                 open = "w")
[16:20:55.703]         }
[16:20:55.703]         else {
[16:20:55.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:55.703]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:55.703]         }
[16:20:55.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:55.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:55.703]             base::sink(type = "output", split = FALSE)
[16:20:55.703]             base::close(...future.stdout)
[16:20:55.703]         }, add = TRUE)
[16:20:55.703]     }
[16:20:55.703]     ...future.frame <- base::sys.nframe()
[16:20:55.703]     ...future.conditions <- base::list()
[16:20:55.703]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:55.703]     if (FALSE) {
[16:20:55.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:55.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:55.703]     }
[16:20:55.703]     ...future.result <- base::tryCatch({
[16:20:55.703]         base::withCallingHandlers({
[16:20:55.703]             ...future.value <- base::withVisible(base::local({
[16:20:55.703]                 ...future.makeSendCondition <- base::local({
[16:20:55.703]                   sendCondition <- NULL
[16:20:55.703]                   function(frame = 1L) {
[16:20:55.703]                     if (is.function(sendCondition)) 
[16:20:55.703]                       return(sendCondition)
[16:20:55.703]                     ns <- getNamespace("parallel")
[16:20:55.703]                     if (exists("sendData", mode = "function", 
[16:20:55.703]                       envir = ns)) {
[16:20:55.703]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:55.703]                         envir = ns)
[16:20:55.703]                       envir <- sys.frame(frame)
[16:20:55.703]                       master <- NULL
[16:20:55.703]                       while (!identical(envir, .GlobalEnv) && 
[16:20:55.703]                         !identical(envir, emptyenv())) {
[16:20:55.703]                         if (exists("master", mode = "list", envir = envir, 
[16:20:55.703]                           inherits = FALSE)) {
[16:20:55.703]                           master <- get("master", mode = "list", 
[16:20:55.703]                             envir = envir, inherits = FALSE)
[16:20:55.703]                           if (inherits(master, c("SOCKnode", 
[16:20:55.703]                             "SOCK0node"))) {
[16:20:55.703]                             sendCondition <<- function(cond) {
[16:20:55.703]                               data <- list(type = "VALUE", value = cond, 
[16:20:55.703]                                 success = TRUE)
[16:20:55.703]                               parallel_sendData(master, data)
[16:20:55.703]                             }
[16:20:55.703]                             return(sendCondition)
[16:20:55.703]                           }
[16:20:55.703]                         }
[16:20:55.703]                         frame <- frame + 1L
[16:20:55.703]                         envir <- sys.frame(frame)
[16:20:55.703]                       }
[16:20:55.703]                     }
[16:20:55.703]                     sendCondition <<- function(cond) NULL
[16:20:55.703]                   }
[16:20:55.703]                 })
[16:20:55.703]                 withCallingHandlers({
[16:20:55.703]                   getOption("future.globals.onMissing")
[16:20:55.703]                 }, immediateCondition = function(cond) {
[16:20:55.703]                   sendCondition <- ...future.makeSendCondition()
[16:20:55.703]                   sendCondition(cond)
[16:20:55.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.703]                   {
[16:20:55.703]                     inherits <- base::inherits
[16:20:55.703]                     invokeRestart <- base::invokeRestart
[16:20:55.703]                     is.null <- base::is.null
[16:20:55.703]                     muffled <- FALSE
[16:20:55.703]                     if (inherits(cond, "message")) {
[16:20:55.703]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:55.703]                       if (muffled) 
[16:20:55.703]                         invokeRestart("muffleMessage")
[16:20:55.703]                     }
[16:20:55.703]                     else if (inherits(cond, "warning")) {
[16:20:55.703]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:55.703]                       if (muffled) 
[16:20:55.703]                         invokeRestart("muffleWarning")
[16:20:55.703]                     }
[16:20:55.703]                     else if (inherits(cond, "condition")) {
[16:20:55.703]                       if (!is.null(pattern)) {
[16:20:55.703]                         computeRestarts <- base::computeRestarts
[16:20:55.703]                         grepl <- base::grepl
[16:20:55.703]                         restarts <- computeRestarts(cond)
[16:20:55.703]                         for (restart in restarts) {
[16:20:55.703]                           name <- restart$name
[16:20:55.703]                           if (is.null(name)) 
[16:20:55.703]                             next
[16:20:55.703]                           if (!grepl(pattern, name)) 
[16:20:55.703]                             next
[16:20:55.703]                           invokeRestart(restart)
[16:20:55.703]                           muffled <- TRUE
[16:20:55.703]                           break
[16:20:55.703]                         }
[16:20:55.703]                       }
[16:20:55.703]                     }
[16:20:55.703]                     invisible(muffled)
[16:20:55.703]                   }
[16:20:55.703]                   muffleCondition(cond)
[16:20:55.703]                 })
[16:20:55.703]             }))
[16:20:55.703]             future::FutureResult(value = ...future.value$value, 
[16:20:55.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.703]                   ...future.rng), globalenv = if (FALSE) 
[16:20:55.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:55.703]                     ...future.globalenv.names))
[16:20:55.703]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:55.703]         }, condition = base::local({
[16:20:55.703]             c <- base::c
[16:20:55.703]             inherits <- base::inherits
[16:20:55.703]             invokeRestart <- base::invokeRestart
[16:20:55.703]             length <- base::length
[16:20:55.703]             list <- base::list
[16:20:55.703]             seq.int <- base::seq.int
[16:20:55.703]             signalCondition <- base::signalCondition
[16:20:55.703]             sys.calls <- base::sys.calls
[16:20:55.703]             `[[` <- base::`[[`
[16:20:55.703]             `+` <- base::`+`
[16:20:55.703]             `<<-` <- base::`<<-`
[16:20:55.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:55.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:55.703]                   3L)]
[16:20:55.703]             }
[16:20:55.703]             function(cond) {
[16:20:55.703]                 is_error <- inherits(cond, "error")
[16:20:55.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:55.703]                   NULL)
[16:20:55.703]                 if (is_error) {
[16:20:55.703]                   sessionInformation <- function() {
[16:20:55.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:55.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:55.703]                       search = base::search(), system = base::Sys.info())
[16:20:55.703]                   }
[16:20:55.703]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:55.703]                     cond$call), session = sessionInformation(), 
[16:20:55.703]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:55.703]                   signalCondition(cond)
[16:20:55.703]                 }
[16:20:55.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:55.703]                 "immediateCondition"))) {
[16:20:55.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:55.703]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:55.703]                   if (TRUE && !signal) {
[16:20:55.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.703]                     {
[16:20:55.703]                       inherits <- base::inherits
[16:20:55.703]                       invokeRestart <- base::invokeRestart
[16:20:55.703]                       is.null <- base::is.null
[16:20:55.703]                       muffled <- FALSE
[16:20:55.703]                       if (inherits(cond, "message")) {
[16:20:55.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.703]                         if (muffled) 
[16:20:55.703]                           invokeRestart("muffleMessage")
[16:20:55.703]                       }
[16:20:55.703]                       else if (inherits(cond, "warning")) {
[16:20:55.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.703]                         if (muffled) 
[16:20:55.703]                           invokeRestart("muffleWarning")
[16:20:55.703]                       }
[16:20:55.703]                       else if (inherits(cond, "condition")) {
[16:20:55.703]                         if (!is.null(pattern)) {
[16:20:55.703]                           computeRestarts <- base::computeRestarts
[16:20:55.703]                           grepl <- base::grepl
[16:20:55.703]                           restarts <- computeRestarts(cond)
[16:20:55.703]                           for (restart in restarts) {
[16:20:55.703]                             name <- restart$name
[16:20:55.703]                             if (is.null(name)) 
[16:20:55.703]                               next
[16:20:55.703]                             if (!grepl(pattern, name)) 
[16:20:55.703]                               next
[16:20:55.703]                             invokeRestart(restart)
[16:20:55.703]                             muffled <- TRUE
[16:20:55.703]                             break
[16:20:55.703]                           }
[16:20:55.703]                         }
[16:20:55.703]                       }
[16:20:55.703]                       invisible(muffled)
[16:20:55.703]                     }
[16:20:55.703]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.703]                   }
[16:20:55.703]                 }
[16:20:55.703]                 else {
[16:20:55.703]                   if (TRUE) {
[16:20:55.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.703]                     {
[16:20:55.703]                       inherits <- base::inherits
[16:20:55.703]                       invokeRestart <- base::invokeRestart
[16:20:55.703]                       is.null <- base::is.null
[16:20:55.703]                       muffled <- FALSE
[16:20:55.703]                       if (inherits(cond, "message")) {
[16:20:55.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.703]                         if (muffled) 
[16:20:55.703]                           invokeRestart("muffleMessage")
[16:20:55.703]                       }
[16:20:55.703]                       else if (inherits(cond, "warning")) {
[16:20:55.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.703]                         if (muffled) 
[16:20:55.703]                           invokeRestart("muffleWarning")
[16:20:55.703]                       }
[16:20:55.703]                       else if (inherits(cond, "condition")) {
[16:20:55.703]                         if (!is.null(pattern)) {
[16:20:55.703]                           computeRestarts <- base::computeRestarts
[16:20:55.703]                           grepl <- base::grepl
[16:20:55.703]                           restarts <- computeRestarts(cond)
[16:20:55.703]                           for (restart in restarts) {
[16:20:55.703]                             name <- restart$name
[16:20:55.703]                             if (is.null(name)) 
[16:20:55.703]                               next
[16:20:55.703]                             if (!grepl(pattern, name)) 
[16:20:55.703]                               next
[16:20:55.703]                             invokeRestart(restart)
[16:20:55.703]                             muffled <- TRUE
[16:20:55.703]                             break
[16:20:55.703]                           }
[16:20:55.703]                         }
[16:20:55.703]                       }
[16:20:55.703]                       invisible(muffled)
[16:20:55.703]                     }
[16:20:55.703]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.703]                   }
[16:20:55.703]                 }
[16:20:55.703]             }
[16:20:55.703]         }))
[16:20:55.703]     }, error = function(ex) {
[16:20:55.703]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:55.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.703]                 ...future.rng), started = ...future.startTime, 
[16:20:55.703]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:55.703]             version = "1.8"), class = "FutureResult")
[16:20:55.703]     }, finally = {
[16:20:55.703]         if (!identical(...future.workdir, getwd())) 
[16:20:55.703]             setwd(...future.workdir)
[16:20:55.703]         {
[16:20:55.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:55.703]                 ...future.oldOptions$nwarnings <- NULL
[16:20:55.703]             }
[16:20:55.703]             base::options(...future.oldOptions)
[16:20:55.703]             if (.Platform$OS.type == "windows") {
[16:20:55.703]                 old_names <- names(...future.oldEnvVars)
[16:20:55.703]                 envs <- base::Sys.getenv()
[16:20:55.703]                 names <- names(envs)
[16:20:55.703]                 common <- intersect(names, old_names)
[16:20:55.703]                 added <- setdiff(names, old_names)
[16:20:55.703]                 removed <- setdiff(old_names, names)
[16:20:55.703]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:55.703]                   envs[common]]
[16:20:55.703]                 NAMES <- toupper(changed)
[16:20:55.703]                 args <- list()
[16:20:55.703]                 for (kk in seq_along(NAMES)) {
[16:20:55.703]                   name <- changed[[kk]]
[16:20:55.703]                   NAME <- NAMES[[kk]]
[16:20:55.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.703]                     next
[16:20:55.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.703]                 }
[16:20:55.703]                 NAMES <- toupper(added)
[16:20:55.703]                 for (kk in seq_along(NAMES)) {
[16:20:55.703]                   name <- added[[kk]]
[16:20:55.703]                   NAME <- NAMES[[kk]]
[16:20:55.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.703]                     next
[16:20:55.703]                   args[[name]] <- ""
[16:20:55.703]                 }
[16:20:55.703]                 NAMES <- toupper(removed)
[16:20:55.703]                 for (kk in seq_along(NAMES)) {
[16:20:55.703]                   name <- removed[[kk]]
[16:20:55.703]                   NAME <- NAMES[[kk]]
[16:20:55.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.703]                     next
[16:20:55.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.703]                 }
[16:20:55.703]                 if (length(args) > 0) 
[16:20:55.703]                   base::do.call(base::Sys.setenv, args = args)
[16:20:55.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:55.703]             }
[16:20:55.703]             else {
[16:20:55.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:55.703]             }
[16:20:55.703]             {
[16:20:55.703]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:55.703]                   0L) {
[16:20:55.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:55.703]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:55.703]                   base::options(opts)
[16:20:55.703]                 }
[16:20:55.703]                 {
[16:20:55.703]                   {
[16:20:55.703]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:55.703]                     NULL
[16:20:55.703]                   }
[16:20:55.703]                   options(future.plan = NULL)
[16:20:55.703]                   if (is.na(NA_character_)) 
[16:20:55.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:55.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:55.703]                     .init = FALSE)
[16:20:55.703]                 }
[16:20:55.703]             }
[16:20:55.703]         }
[16:20:55.703]     })
[16:20:55.703]     if (TRUE) {
[16:20:55.703]         base::sink(type = "output", split = FALSE)
[16:20:55.703]         if (TRUE) {
[16:20:55.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:55.703]         }
[16:20:55.703]         else {
[16:20:55.703]             ...future.result["stdout"] <- base::list(NULL)
[16:20:55.703]         }
[16:20:55.703]         base::close(...future.stdout)
[16:20:55.703]         ...future.stdout <- NULL
[16:20:55.703]     }
[16:20:55.703]     ...future.result$conditions <- ...future.conditions
[16:20:55.703]     ...future.result$finished <- base::Sys.time()
[16:20:55.703]     ...future.result
[16:20:55.703] }
[16:20:55.706] MultisessionFuture started
[16:20:55.706] - Launch lazy future ... done
[16:20:55.706] run() for ‘MultisessionFuture’ ... done
[16:20:55.707] result() for ClusterFuture ...
[16:20:55.707] receiveMessageFromWorker() for ClusterFuture ...
[16:20:55.707] - Validating connection of MultisessionFuture
[16:20:55.711] - received message: FutureResult
[16:20:55.711] - Received FutureResult
[16:20:55.711] - Erased future from FutureRegistry
[16:20:55.711] result() for ClusterFuture ...
[16:20:55.712] - result already collected: FutureResult
[16:20:55.712] result() for ClusterFuture ... done
[16:20:55.712] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:55.712] result() for ClusterFuture ... done
[16:20:55.712] result() for ClusterFuture ...
[16:20:55.712] - result already collected: FutureResult
[16:20:55.712] result() for ClusterFuture ... done
[16:20:55.713] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:55.713] Searching for globals...
[16:20:55.714] - globals found: [1] ‘getOption’
[16:20:55.714] Searching for globals ... DONE
[16:20:55.714] Resolving globals: FALSE
[16:20:55.714] 
[16:20:55.714] 
[16:20:55.714] getGlobalsAndPackages() ... DONE
[16:20:55.715] run() for ‘Future’ ...
[16:20:55.715] - state: ‘created’
[16:20:55.715] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:55.729] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:55.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:55.729]   - Field: ‘node’
[16:20:55.730]   - Field: ‘label’
[16:20:55.730]   - Field: ‘local’
[16:20:55.730]   - Field: ‘owner’
[16:20:55.730]   - Field: ‘envir’
[16:20:55.730]   - Field: ‘workers’
[16:20:55.730]   - Field: ‘packages’
[16:20:55.730]   - Field: ‘gc’
[16:20:55.730]   - Field: ‘conditions’
[16:20:55.730]   - Field: ‘persistent’
[16:20:55.730]   - Field: ‘expr’
[16:20:55.731]   - Field: ‘uuid’
[16:20:55.731]   - Field: ‘seed’
[16:20:55.731]   - Field: ‘version’
[16:20:55.731]   - Field: ‘result’
[16:20:55.731]   - Field: ‘asynchronous’
[16:20:55.731]   - Field: ‘calls’
[16:20:55.731]   - Field: ‘globals’
[16:20:55.731]   - Field: ‘stdout’
[16:20:55.732]   - Field: ‘earlySignal’
[16:20:55.732]   - Field: ‘lazy’
[16:20:55.732]   - Field: ‘state’
[16:20:55.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:55.732] - Launch lazy future ...
[16:20:55.732] Packages needed by the future expression (n = 0): <none>
[16:20:55.732] Packages needed by future strategies (n = 0): <none>
[16:20:55.733] {
[16:20:55.733]     {
[16:20:55.733]         {
[16:20:55.733]             ...future.startTime <- base::Sys.time()
[16:20:55.733]             {
[16:20:55.733]                 {
[16:20:55.733]                   {
[16:20:55.733]                     {
[16:20:55.733]                       base::local({
[16:20:55.733]                         has_future <- base::requireNamespace("future", 
[16:20:55.733]                           quietly = TRUE)
[16:20:55.733]                         if (has_future) {
[16:20:55.733]                           ns <- base::getNamespace("future")
[16:20:55.733]                           version <- ns[[".package"]][["version"]]
[16:20:55.733]                           if (is.null(version)) 
[16:20:55.733]                             version <- utils::packageVersion("future")
[16:20:55.733]                         }
[16:20:55.733]                         else {
[16:20:55.733]                           version <- NULL
[16:20:55.733]                         }
[16:20:55.733]                         if (!has_future || version < "1.8.0") {
[16:20:55.733]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:55.733]                             "", base::R.version$version.string), 
[16:20:55.733]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:55.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:55.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:55.733]                               "release", "version")], collapse = " "), 
[16:20:55.733]                             hostname = base::Sys.info()[["nodename"]])
[16:20:55.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:55.733]                             info)
[16:20:55.733]                           info <- base::paste(info, collapse = "; ")
[16:20:55.733]                           if (!has_future) {
[16:20:55.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:55.733]                               info)
[16:20:55.733]                           }
[16:20:55.733]                           else {
[16:20:55.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:55.733]                               info, version)
[16:20:55.733]                           }
[16:20:55.733]                           base::stop(msg)
[16:20:55.733]                         }
[16:20:55.733]                       })
[16:20:55.733]                     }
[16:20:55.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:55.733]                     base::options(mc.cores = 1L)
[16:20:55.733]                   }
[16:20:55.733]                   ...future.strategy.old <- future::plan("list")
[16:20:55.733]                   options(future.plan = NULL)
[16:20:55.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:55.733]                 }
[16:20:55.733]                 ...future.workdir <- getwd()
[16:20:55.733]             }
[16:20:55.733]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:55.733]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:55.733]         }
[16:20:55.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:55.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:55.733]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:55.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:55.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:55.733]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:55.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:55.733]             base::names(...future.oldOptions))
[16:20:55.733]     }
[16:20:55.733]     if (FALSE) {
[16:20:55.733]     }
[16:20:55.733]     else {
[16:20:55.733]         if (TRUE) {
[16:20:55.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:55.733]                 open = "w")
[16:20:55.733]         }
[16:20:55.733]         else {
[16:20:55.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:55.733]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:55.733]         }
[16:20:55.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:55.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:55.733]             base::sink(type = "output", split = FALSE)
[16:20:55.733]             base::close(...future.stdout)
[16:20:55.733]         }, add = TRUE)
[16:20:55.733]     }
[16:20:55.733]     ...future.frame <- base::sys.nframe()
[16:20:55.733]     ...future.conditions <- base::list()
[16:20:55.733]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:55.733]     if (FALSE) {
[16:20:55.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:55.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:55.733]     }
[16:20:55.733]     ...future.result <- base::tryCatch({
[16:20:55.733]         base::withCallingHandlers({
[16:20:55.733]             ...future.value <- base::withVisible(base::local({
[16:20:55.733]                 ...future.makeSendCondition <- base::local({
[16:20:55.733]                   sendCondition <- NULL
[16:20:55.733]                   function(frame = 1L) {
[16:20:55.733]                     if (is.function(sendCondition)) 
[16:20:55.733]                       return(sendCondition)
[16:20:55.733]                     ns <- getNamespace("parallel")
[16:20:55.733]                     if (exists("sendData", mode = "function", 
[16:20:55.733]                       envir = ns)) {
[16:20:55.733]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:55.733]                         envir = ns)
[16:20:55.733]                       envir <- sys.frame(frame)
[16:20:55.733]                       master <- NULL
[16:20:55.733]                       while (!identical(envir, .GlobalEnv) && 
[16:20:55.733]                         !identical(envir, emptyenv())) {
[16:20:55.733]                         if (exists("master", mode = "list", envir = envir, 
[16:20:55.733]                           inherits = FALSE)) {
[16:20:55.733]                           master <- get("master", mode = "list", 
[16:20:55.733]                             envir = envir, inherits = FALSE)
[16:20:55.733]                           if (inherits(master, c("SOCKnode", 
[16:20:55.733]                             "SOCK0node"))) {
[16:20:55.733]                             sendCondition <<- function(cond) {
[16:20:55.733]                               data <- list(type = "VALUE", value = cond, 
[16:20:55.733]                                 success = TRUE)
[16:20:55.733]                               parallel_sendData(master, data)
[16:20:55.733]                             }
[16:20:55.733]                             return(sendCondition)
[16:20:55.733]                           }
[16:20:55.733]                         }
[16:20:55.733]                         frame <- frame + 1L
[16:20:55.733]                         envir <- sys.frame(frame)
[16:20:55.733]                       }
[16:20:55.733]                     }
[16:20:55.733]                     sendCondition <<- function(cond) NULL
[16:20:55.733]                   }
[16:20:55.733]                 })
[16:20:55.733]                 withCallingHandlers({
[16:20:55.733]                   getOption("future.globals.onMissing")
[16:20:55.733]                 }, immediateCondition = function(cond) {
[16:20:55.733]                   sendCondition <- ...future.makeSendCondition()
[16:20:55.733]                   sendCondition(cond)
[16:20:55.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.733]                   {
[16:20:55.733]                     inherits <- base::inherits
[16:20:55.733]                     invokeRestart <- base::invokeRestart
[16:20:55.733]                     is.null <- base::is.null
[16:20:55.733]                     muffled <- FALSE
[16:20:55.733]                     if (inherits(cond, "message")) {
[16:20:55.733]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:55.733]                       if (muffled) 
[16:20:55.733]                         invokeRestart("muffleMessage")
[16:20:55.733]                     }
[16:20:55.733]                     else if (inherits(cond, "warning")) {
[16:20:55.733]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:55.733]                       if (muffled) 
[16:20:55.733]                         invokeRestart("muffleWarning")
[16:20:55.733]                     }
[16:20:55.733]                     else if (inherits(cond, "condition")) {
[16:20:55.733]                       if (!is.null(pattern)) {
[16:20:55.733]                         computeRestarts <- base::computeRestarts
[16:20:55.733]                         grepl <- base::grepl
[16:20:55.733]                         restarts <- computeRestarts(cond)
[16:20:55.733]                         for (restart in restarts) {
[16:20:55.733]                           name <- restart$name
[16:20:55.733]                           if (is.null(name)) 
[16:20:55.733]                             next
[16:20:55.733]                           if (!grepl(pattern, name)) 
[16:20:55.733]                             next
[16:20:55.733]                           invokeRestart(restart)
[16:20:55.733]                           muffled <- TRUE
[16:20:55.733]                           break
[16:20:55.733]                         }
[16:20:55.733]                       }
[16:20:55.733]                     }
[16:20:55.733]                     invisible(muffled)
[16:20:55.733]                   }
[16:20:55.733]                   muffleCondition(cond)
[16:20:55.733]                 })
[16:20:55.733]             }))
[16:20:55.733]             future::FutureResult(value = ...future.value$value, 
[16:20:55.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.733]                   ...future.rng), globalenv = if (FALSE) 
[16:20:55.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:55.733]                     ...future.globalenv.names))
[16:20:55.733]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:55.733]         }, condition = base::local({
[16:20:55.733]             c <- base::c
[16:20:55.733]             inherits <- base::inherits
[16:20:55.733]             invokeRestart <- base::invokeRestart
[16:20:55.733]             length <- base::length
[16:20:55.733]             list <- base::list
[16:20:55.733]             seq.int <- base::seq.int
[16:20:55.733]             signalCondition <- base::signalCondition
[16:20:55.733]             sys.calls <- base::sys.calls
[16:20:55.733]             `[[` <- base::`[[`
[16:20:55.733]             `+` <- base::`+`
[16:20:55.733]             `<<-` <- base::`<<-`
[16:20:55.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:55.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:55.733]                   3L)]
[16:20:55.733]             }
[16:20:55.733]             function(cond) {
[16:20:55.733]                 is_error <- inherits(cond, "error")
[16:20:55.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:55.733]                   NULL)
[16:20:55.733]                 if (is_error) {
[16:20:55.733]                   sessionInformation <- function() {
[16:20:55.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:55.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:55.733]                       search = base::search(), system = base::Sys.info())
[16:20:55.733]                   }
[16:20:55.733]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:55.733]                     cond$call), session = sessionInformation(), 
[16:20:55.733]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:55.733]                   signalCondition(cond)
[16:20:55.733]                 }
[16:20:55.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:55.733]                 "immediateCondition"))) {
[16:20:55.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:55.733]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:55.733]                   if (TRUE && !signal) {
[16:20:55.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.733]                     {
[16:20:55.733]                       inherits <- base::inherits
[16:20:55.733]                       invokeRestart <- base::invokeRestart
[16:20:55.733]                       is.null <- base::is.null
[16:20:55.733]                       muffled <- FALSE
[16:20:55.733]                       if (inherits(cond, "message")) {
[16:20:55.733]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.733]                         if (muffled) 
[16:20:55.733]                           invokeRestart("muffleMessage")
[16:20:55.733]                       }
[16:20:55.733]                       else if (inherits(cond, "warning")) {
[16:20:55.733]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.733]                         if (muffled) 
[16:20:55.733]                           invokeRestart("muffleWarning")
[16:20:55.733]                       }
[16:20:55.733]                       else if (inherits(cond, "condition")) {
[16:20:55.733]                         if (!is.null(pattern)) {
[16:20:55.733]                           computeRestarts <- base::computeRestarts
[16:20:55.733]                           grepl <- base::grepl
[16:20:55.733]                           restarts <- computeRestarts(cond)
[16:20:55.733]                           for (restart in restarts) {
[16:20:55.733]                             name <- restart$name
[16:20:55.733]                             if (is.null(name)) 
[16:20:55.733]                               next
[16:20:55.733]                             if (!grepl(pattern, name)) 
[16:20:55.733]                               next
[16:20:55.733]                             invokeRestart(restart)
[16:20:55.733]                             muffled <- TRUE
[16:20:55.733]                             break
[16:20:55.733]                           }
[16:20:55.733]                         }
[16:20:55.733]                       }
[16:20:55.733]                       invisible(muffled)
[16:20:55.733]                     }
[16:20:55.733]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.733]                   }
[16:20:55.733]                 }
[16:20:55.733]                 else {
[16:20:55.733]                   if (TRUE) {
[16:20:55.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.733]                     {
[16:20:55.733]                       inherits <- base::inherits
[16:20:55.733]                       invokeRestart <- base::invokeRestart
[16:20:55.733]                       is.null <- base::is.null
[16:20:55.733]                       muffled <- FALSE
[16:20:55.733]                       if (inherits(cond, "message")) {
[16:20:55.733]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.733]                         if (muffled) 
[16:20:55.733]                           invokeRestart("muffleMessage")
[16:20:55.733]                       }
[16:20:55.733]                       else if (inherits(cond, "warning")) {
[16:20:55.733]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.733]                         if (muffled) 
[16:20:55.733]                           invokeRestart("muffleWarning")
[16:20:55.733]                       }
[16:20:55.733]                       else if (inherits(cond, "condition")) {
[16:20:55.733]                         if (!is.null(pattern)) {
[16:20:55.733]                           computeRestarts <- base::computeRestarts
[16:20:55.733]                           grepl <- base::grepl
[16:20:55.733]                           restarts <- computeRestarts(cond)
[16:20:55.733]                           for (restart in restarts) {
[16:20:55.733]                             name <- restart$name
[16:20:55.733]                             if (is.null(name)) 
[16:20:55.733]                               next
[16:20:55.733]                             if (!grepl(pattern, name)) 
[16:20:55.733]                               next
[16:20:55.733]                             invokeRestart(restart)
[16:20:55.733]                             muffled <- TRUE
[16:20:55.733]                             break
[16:20:55.733]                           }
[16:20:55.733]                         }
[16:20:55.733]                       }
[16:20:55.733]                       invisible(muffled)
[16:20:55.733]                     }
[16:20:55.733]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.733]                   }
[16:20:55.733]                 }
[16:20:55.733]             }
[16:20:55.733]         }))
[16:20:55.733]     }, error = function(ex) {
[16:20:55.733]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:55.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.733]                 ...future.rng), started = ...future.startTime, 
[16:20:55.733]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:55.733]             version = "1.8"), class = "FutureResult")
[16:20:55.733]     }, finally = {
[16:20:55.733]         if (!identical(...future.workdir, getwd())) 
[16:20:55.733]             setwd(...future.workdir)
[16:20:55.733]         {
[16:20:55.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:55.733]                 ...future.oldOptions$nwarnings <- NULL
[16:20:55.733]             }
[16:20:55.733]             base::options(...future.oldOptions)
[16:20:55.733]             if (.Platform$OS.type == "windows") {
[16:20:55.733]                 old_names <- names(...future.oldEnvVars)
[16:20:55.733]                 envs <- base::Sys.getenv()
[16:20:55.733]                 names <- names(envs)
[16:20:55.733]                 common <- intersect(names, old_names)
[16:20:55.733]                 added <- setdiff(names, old_names)
[16:20:55.733]                 removed <- setdiff(old_names, names)
[16:20:55.733]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:55.733]                   envs[common]]
[16:20:55.733]                 NAMES <- toupper(changed)
[16:20:55.733]                 args <- list()
[16:20:55.733]                 for (kk in seq_along(NAMES)) {
[16:20:55.733]                   name <- changed[[kk]]
[16:20:55.733]                   NAME <- NAMES[[kk]]
[16:20:55.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.733]                     next
[16:20:55.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.733]                 }
[16:20:55.733]                 NAMES <- toupper(added)
[16:20:55.733]                 for (kk in seq_along(NAMES)) {
[16:20:55.733]                   name <- added[[kk]]
[16:20:55.733]                   NAME <- NAMES[[kk]]
[16:20:55.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.733]                     next
[16:20:55.733]                   args[[name]] <- ""
[16:20:55.733]                 }
[16:20:55.733]                 NAMES <- toupper(removed)
[16:20:55.733]                 for (kk in seq_along(NAMES)) {
[16:20:55.733]                   name <- removed[[kk]]
[16:20:55.733]                   NAME <- NAMES[[kk]]
[16:20:55.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.733]                     next
[16:20:55.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.733]                 }
[16:20:55.733]                 if (length(args) > 0) 
[16:20:55.733]                   base::do.call(base::Sys.setenv, args = args)
[16:20:55.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:55.733]             }
[16:20:55.733]             else {
[16:20:55.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:55.733]             }
[16:20:55.733]             {
[16:20:55.733]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:55.733]                   0L) {
[16:20:55.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:55.733]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:55.733]                   base::options(opts)
[16:20:55.733]                 }
[16:20:55.733]                 {
[16:20:55.733]                   {
[16:20:55.733]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:55.733]                     NULL
[16:20:55.733]                   }
[16:20:55.733]                   options(future.plan = NULL)
[16:20:55.733]                   if (is.na(NA_character_)) 
[16:20:55.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:55.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:55.733]                     .init = FALSE)
[16:20:55.733]                 }
[16:20:55.733]             }
[16:20:55.733]         }
[16:20:55.733]     })
[16:20:55.733]     if (TRUE) {
[16:20:55.733]         base::sink(type = "output", split = FALSE)
[16:20:55.733]         if (TRUE) {
[16:20:55.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:55.733]         }
[16:20:55.733]         else {
[16:20:55.733]             ...future.result["stdout"] <- base::list(NULL)
[16:20:55.733]         }
[16:20:55.733]         base::close(...future.stdout)
[16:20:55.733]         ...future.stdout <- NULL
[16:20:55.733]     }
[16:20:55.733]     ...future.result$conditions <- ...future.conditions
[16:20:55.733]     ...future.result$finished <- base::Sys.time()
[16:20:55.733]     ...future.result
[16:20:55.733] }
[16:20:55.736] MultisessionFuture started
[16:20:55.736] - Launch lazy future ... done
[16:20:55.736] run() for ‘MultisessionFuture’ ... done
[16:20:55.737] result() for ClusterFuture ...
[16:20:55.737] receiveMessageFromWorker() for ClusterFuture ...
[16:20:55.737] - Validating connection of MultisessionFuture
[16:20:55.738] - received message: FutureResult
[16:20:55.738] - Received FutureResult
[16:20:55.738] - Erased future from FutureRegistry
[16:20:55.738] result() for ClusterFuture ...
[16:20:55.738] - result already collected: FutureResult
[16:20:55.738] result() for ClusterFuture ... done
[16:20:55.738] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:55.738] result() for ClusterFuture ... done
[16:20:55.739] result() for ClusterFuture ...
[16:20:55.739] - result already collected: FutureResult
[16:20:55.739] result() for ClusterFuture ... done
[16:20:55.739] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:20:55.739] Searching for globals...
[16:20:55.741] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:55.741] Searching for globals...
[16:20:55.742] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[16:20:55.742] Searching for globals ... DONE
[16:20:55.742] Resolving globals: FALSE
[16:20:55.743] The total size of the 1 globals is 160 bytes (160 bytes)
[16:20:55.743] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[16:20:55.744] - globals: [1] ‘data’
[16:20:55.744] 
[16:20:55.744] getGlobalsAndPackages() ... DONE
[16:20:55.744] run() for ‘Future’ ...
[16:20:55.744] - state: ‘created’
[16:20:55.744] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:55.759] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:55.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:55.759]   - Field: ‘node’
[16:20:55.760]   - Field: ‘label’
[16:20:55.760]   - Field: ‘local’
[16:20:55.760]   - Field: ‘owner’
[16:20:55.760]   - Field: ‘envir’
[16:20:55.760]   - Field: ‘workers’
[16:20:55.760]   - Field: ‘packages’
[16:20:55.760]   - Field: ‘gc’
[16:20:55.760]   - Field: ‘conditions’
[16:20:55.760]   - Field: ‘persistent’
[16:20:55.760]   - Field: ‘expr’
[16:20:55.761]   - Field: ‘uuid’
[16:20:55.761]   - Field: ‘seed’
[16:20:55.761]   - Field: ‘version’
[16:20:55.761]   - Field: ‘result’
[16:20:55.761]   - Field: ‘asynchronous’
[16:20:55.761]   - Field: ‘calls’
[16:20:55.761]   - Field: ‘globals’
[16:20:55.761]   - Field: ‘stdout’
[16:20:55.762]   - Field: ‘earlySignal’
[16:20:55.762]   - Field: ‘lazy’
[16:20:55.762]   - Field: ‘state’
[16:20:55.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:55.762] - Launch lazy future ...
[16:20:55.762] Packages needed by the future expression (n = 0): <none>
[16:20:55.762] Packages needed by future strategies (n = 0): <none>
[16:20:55.763] {
[16:20:55.763]     {
[16:20:55.763]         {
[16:20:55.763]             ...future.startTime <- base::Sys.time()
[16:20:55.763]             {
[16:20:55.763]                 {
[16:20:55.763]                   {
[16:20:55.763]                     {
[16:20:55.763]                       base::local({
[16:20:55.763]                         has_future <- base::requireNamespace("future", 
[16:20:55.763]                           quietly = TRUE)
[16:20:55.763]                         if (has_future) {
[16:20:55.763]                           ns <- base::getNamespace("future")
[16:20:55.763]                           version <- ns[[".package"]][["version"]]
[16:20:55.763]                           if (is.null(version)) 
[16:20:55.763]                             version <- utils::packageVersion("future")
[16:20:55.763]                         }
[16:20:55.763]                         else {
[16:20:55.763]                           version <- NULL
[16:20:55.763]                         }
[16:20:55.763]                         if (!has_future || version < "1.8.0") {
[16:20:55.763]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:55.763]                             "", base::R.version$version.string), 
[16:20:55.763]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:55.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:55.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:55.763]                               "release", "version")], collapse = " "), 
[16:20:55.763]                             hostname = base::Sys.info()[["nodename"]])
[16:20:55.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:55.763]                             info)
[16:20:55.763]                           info <- base::paste(info, collapse = "; ")
[16:20:55.763]                           if (!has_future) {
[16:20:55.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:55.763]                               info)
[16:20:55.763]                           }
[16:20:55.763]                           else {
[16:20:55.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:55.763]                               info, version)
[16:20:55.763]                           }
[16:20:55.763]                           base::stop(msg)
[16:20:55.763]                         }
[16:20:55.763]                       })
[16:20:55.763]                     }
[16:20:55.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:55.763]                     base::options(mc.cores = 1L)
[16:20:55.763]                   }
[16:20:55.763]                   ...future.strategy.old <- future::plan("list")
[16:20:55.763]                   options(future.plan = NULL)
[16:20:55.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:55.763]                 }
[16:20:55.763]                 ...future.workdir <- getwd()
[16:20:55.763]             }
[16:20:55.763]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:55.763]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:55.763]         }
[16:20:55.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:55.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:55.763]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:55.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:55.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:55.763]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:55.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:55.763]             base::names(...future.oldOptions))
[16:20:55.763]     }
[16:20:55.763]     if (FALSE) {
[16:20:55.763]     }
[16:20:55.763]     else {
[16:20:55.763]         if (TRUE) {
[16:20:55.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:55.763]                 open = "w")
[16:20:55.763]         }
[16:20:55.763]         else {
[16:20:55.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:55.763]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:55.763]         }
[16:20:55.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:55.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:55.763]             base::sink(type = "output", split = FALSE)
[16:20:55.763]             base::close(...future.stdout)
[16:20:55.763]         }, add = TRUE)
[16:20:55.763]     }
[16:20:55.763]     ...future.frame <- base::sys.nframe()
[16:20:55.763]     ...future.conditions <- base::list()
[16:20:55.763]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:55.763]     if (FALSE) {
[16:20:55.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:55.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:55.763]     }
[16:20:55.763]     ...future.result <- base::tryCatch({
[16:20:55.763]         base::withCallingHandlers({
[16:20:55.763]             ...future.value <- base::withVisible(base::local({
[16:20:55.763]                 ...future.makeSendCondition <- base::local({
[16:20:55.763]                   sendCondition <- NULL
[16:20:55.763]                   function(frame = 1L) {
[16:20:55.763]                     if (is.function(sendCondition)) 
[16:20:55.763]                       return(sendCondition)
[16:20:55.763]                     ns <- getNamespace("parallel")
[16:20:55.763]                     if (exists("sendData", mode = "function", 
[16:20:55.763]                       envir = ns)) {
[16:20:55.763]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:55.763]                         envir = ns)
[16:20:55.763]                       envir <- sys.frame(frame)
[16:20:55.763]                       master <- NULL
[16:20:55.763]                       while (!identical(envir, .GlobalEnv) && 
[16:20:55.763]                         !identical(envir, emptyenv())) {
[16:20:55.763]                         if (exists("master", mode = "list", envir = envir, 
[16:20:55.763]                           inherits = FALSE)) {
[16:20:55.763]                           master <- get("master", mode = "list", 
[16:20:55.763]                             envir = envir, inherits = FALSE)
[16:20:55.763]                           if (inherits(master, c("SOCKnode", 
[16:20:55.763]                             "SOCK0node"))) {
[16:20:55.763]                             sendCondition <<- function(cond) {
[16:20:55.763]                               data <- list(type = "VALUE", value = cond, 
[16:20:55.763]                                 success = TRUE)
[16:20:55.763]                               parallel_sendData(master, data)
[16:20:55.763]                             }
[16:20:55.763]                             return(sendCondition)
[16:20:55.763]                           }
[16:20:55.763]                         }
[16:20:55.763]                         frame <- frame + 1L
[16:20:55.763]                         envir <- sys.frame(frame)
[16:20:55.763]                       }
[16:20:55.763]                     }
[16:20:55.763]                     sendCondition <<- function(cond) NULL
[16:20:55.763]                   }
[16:20:55.763]                 })
[16:20:55.763]                 withCallingHandlers({
[16:20:55.763]                   subset(data, x < 3)$y
[16:20:55.763]                 }, immediateCondition = function(cond) {
[16:20:55.763]                   sendCondition <- ...future.makeSendCondition()
[16:20:55.763]                   sendCondition(cond)
[16:20:55.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.763]                   {
[16:20:55.763]                     inherits <- base::inherits
[16:20:55.763]                     invokeRestart <- base::invokeRestart
[16:20:55.763]                     is.null <- base::is.null
[16:20:55.763]                     muffled <- FALSE
[16:20:55.763]                     if (inherits(cond, "message")) {
[16:20:55.763]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:55.763]                       if (muffled) 
[16:20:55.763]                         invokeRestart("muffleMessage")
[16:20:55.763]                     }
[16:20:55.763]                     else if (inherits(cond, "warning")) {
[16:20:55.763]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:55.763]                       if (muffled) 
[16:20:55.763]                         invokeRestart("muffleWarning")
[16:20:55.763]                     }
[16:20:55.763]                     else if (inherits(cond, "condition")) {
[16:20:55.763]                       if (!is.null(pattern)) {
[16:20:55.763]                         computeRestarts <- base::computeRestarts
[16:20:55.763]                         grepl <- base::grepl
[16:20:55.763]                         restarts <- computeRestarts(cond)
[16:20:55.763]                         for (restart in restarts) {
[16:20:55.763]                           name <- restart$name
[16:20:55.763]                           if (is.null(name)) 
[16:20:55.763]                             next
[16:20:55.763]                           if (!grepl(pattern, name)) 
[16:20:55.763]                             next
[16:20:55.763]                           invokeRestart(restart)
[16:20:55.763]                           muffled <- TRUE
[16:20:55.763]                           break
[16:20:55.763]                         }
[16:20:55.763]                       }
[16:20:55.763]                     }
[16:20:55.763]                     invisible(muffled)
[16:20:55.763]                   }
[16:20:55.763]                   muffleCondition(cond)
[16:20:55.763]                 })
[16:20:55.763]             }))
[16:20:55.763]             future::FutureResult(value = ...future.value$value, 
[16:20:55.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.763]                   ...future.rng), globalenv = if (FALSE) 
[16:20:55.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:55.763]                     ...future.globalenv.names))
[16:20:55.763]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:55.763]         }, condition = base::local({
[16:20:55.763]             c <- base::c
[16:20:55.763]             inherits <- base::inherits
[16:20:55.763]             invokeRestart <- base::invokeRestart
[16:20:55.763]             length <- base::length
[16:20:55.763]             list <- base::list
[16:20:55.763]             seq.int <- base::seq.int
[16:20:55.763]             signalCondition <- base::signalCondition
[16:20:55.763]             sys.calls <- base::sys.calls
[16:20:55.763]             `[[` <- base::`[[`
[16:20:55.763]             `+` <- base::`+`
[16:20:55.763]             `<<-` <- base::`<<-`
[16:20:55.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:55.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:55.763]                   3L)]
[16:20:55.763]             }
[16:20:55.763]             function(cond) {
[16:20:55.763]                 is_error <- inherits(cond, "error")
[16:20:55.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:55.763]                   NULL)
[16:20:55.763]                 if (is_error) {
[16:20:55.763]                   sessionInformation <- function() {
[16:20:55.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:55.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:55.763]                       search = base::search(), system = base::Sys.info())
[16:20:55.763]                   }
[16:20:55.763]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:55.763]                     cond$call), session = sessionInformation(), 
[16:20:55.763]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:55.763]                   signalCondition(cond)
[16:20:55.763]                 }
[16:20:55.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:55.763]                 "immediateCondition"))) {
[16:20:55.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:55.763]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:55.763]                   if (TRUE && !signal) {
[16:20:55.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.763]                     {
[16:20:55.763]                       inherits <- base::inherits
[16:20:55.763]                       invokeRestart <- base::invokeRestart
[16:20:55.763]                       is.null <- base::is.null
[16:20:55.763]                       muffled <- FALSE
[16:20:55.763]                       if (inherits(cond, "message")) {
[16:20:55.763]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.763]                         if (muffled) 
[16:20:55.763]                           invokeRestart("muffleMessage")
[16:20:55.763]                       }
[16:20:55.763]                       else if (inherits(cond, "warning")) {
[16:20:55.763]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.763]                         if (muffled) 
[16:20:55.763]                           invokeRestart("muffleWarning")
[16:20:55.763]                       }
[16:20:55.763]                       else if (inherits(cond, "condition")) {
[16:20:55.763]                         if (!is.null(pattern)) {
[16:20:55.763]                           computeRestarts <- base::computeRestarts
[16:20:55.763]                           grepl <- base::grepl
[16:20:55.763]                           restarts <- computeRestarts(cond)
[16:20:55.763]                           for (restart in restarts) {
[16:20:55.763]                             name <- restart$name
[16:20:55.763]                             if (is.null(name)) 
[16:20:55.763]                               next
[16:20:55.763]                             if (!grepl(pattern, name)) 
[16:20:55.763]                               next
[16:20:55.763]                             invokeRestart(restart)
[16:20:55.763]                             muffled <- TRUE
[16:20:55.763]                             break
[16:20:55.763]                           }
[16:20:55.763]                         }
[16:20:55.763]                       }
[16:20:55.763]                       invisible(muffled)
[16:20:55.763]                     }
[16:20:55.763]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.763]                   }
[16:20:55.763]                 }
[16:20:55.763]                 else {
[16:20:55.763]                   if (TRUE) {
[16:20:55.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.763]                     {
[16:20:55.763]                       inherits <- base::inherits
[16:20:55.763]                       invokeRestart <- base::invokeRestart
[16:20:55.763]                       is.null <- base::is.null
[16:20:55.763]                       muffled <- FALSE
[16:20:55.763]                       if (inherits(cond, "message")) {
[16:20:55.763]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.763]                         if (muffled) 
[16:20:55.763]                           invokeRestart("muffleMessage")
[16:20:55.763]                       }
[16:20:55.763]                       else if (inherits(cond, "warning")) {
[16:20:55.763]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.763]                         if (muffled) 
[16:20:55.763]                           invokeRestart("muffleWarning")
[16:20:55.763]                       }
[16:20:55.763]                       else if (inherits(cond, "condition")) {
[16:20:55.763]                         if (!is.null(pattern)) {
[16:20:55.763]                           computeRestarts <- base::computeRestarts
[16:20:55.763]                           grepl <- base::grepl
[16:20:55.763]                           restarts <- computeRestarts(cond)
[16:20:55.763]                           for (restart in restarts) {
[16:20:55.763]                             name <- restart$name
[16:20:55.763]                             if (is.null(name)) 
[16:20:55.763]                               next
[16:20:55.763]                             if (!grepl(pattern, name)) 
[16:20:55.763]                               next
[16:20:55.763]                             invokeRestart(restart)
[16:20:55.763]                             muffled <- TRUE
[16:20:55.763]                             break
[16:20:55.763]                           }
[16:20:55.763]                         }
[16:20:55.763]                       }
[16:20:55.763]                       invisible(muffled)
[16:20:55.763]                     }
[16:20:55.763]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.763]                   }
[16:20:55.763]                 }
[16:20:55.763]             }
[16:20:55.763]         }))
[16:20:55.763]     }, error = function(ex) {
[16:20:55.763]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:55.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.763]                 ...future.rng), started = ...future.startTime, 
[16:20:55.763]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:55.763]             version = "1.8"), class = "FutureResult")
[16:20:55.763]     }, finally = {
[16:20:55.763]         if (!identical(...future.workdir, getwd())) 
[16:20:55.763]             setwd(...future.workdir)
[16:20:55.763]         {
[16:20:55.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:55.763]                 ...future.oldOptions$nwarnings <- NULL
[16:20:55.763]             }
[16:20:55.763]             base::options(...future.oldOptions)
[16:20:55.763]             if (.Platform$OS.type == "windows") {
[16:20:55.763]                 old_names <- names(...future.oldEnvVars)
[16:20:55.763]                 envs <- base::Sys.getenv()
[16:20:55.763]                 names <- names(envs)
[16:20:55.763]                 common <- intersect(names, old_names)
[16:20:55.763]                 added <- setdiff(names, old_names)
[16:20:55.763]                 removed <- setdiff(old_names, names)
[16:20:55.763]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:55.763]                   envs[common]]
[16:20:55.763]                 NAMES <- toupper(changed)
[16:20:55.763]                 args <- list()
[16:20:55.763]                 for (kk in seq_along(NAMES)) {
[16:20:55.763]                   name <- changed[[kk]]
[16:20:55.763]                   NAME <- NAMES[[kk]]
[16:20:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.763]                     next
[16:20:55.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.763]                 }
[16:20:55.763]                 NAMES <- toupper(added)
[16:20:55.763]                 for (kk in seq_along(NAMES)) {
[16:20:55.763]                   name <- added[[kk]]
[16:20:55.763]                   NAME <- NAMES[[kk]]
[16:20:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.763]                     next
[16:20:55.763]                   args[[name]] <- ""
[16:20:55.763]                 }
[16:20:55.763]                 NAMES <- toupper(removed)
[16:20:55.763]                 for (kk in seq_along(NAMES)) {
[16:20:55.763]                   name <- removed[[kk]]
[16:20:55.763]                   NAME <- NAMES[[kk]]
[16:20:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.763]                     next
[16:20:55.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.763]                 }
[16:20:55.763]                 if (length(args) > 0) 
[16:20:55.763]                   base::do.call(base::Sys.setenv, args = args)
[16:20:55.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:55.763]             }
[16:20:55.763]             else {
[16:20:55.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:55.763]             }
[16:20:55.763]             {
[16:20:55.763]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:55.763]                   0L) {
[16:20:55.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:55.763]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:55.763]                   base::options(opts)
[16:20:55.763]                 }
[16:20:55.763]                 {
[16:20:55.763]                   {
[16:20:55.763]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:55.763]                     NULL
[16:20:55.763]                   }
[16:20:55.763]                   options(future.plan = NULL)
[16:20:55.763]                   if (is.na(NA_character_)) 
[16:20:55.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:55.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:55.763]                     .init = FALSE)
[16:20:55.763]                 }
[16:20:55.763]             }
[16:20:55.763]         }
[16:20:55.763]     })
[16:20:55.763]     if (TRUE) {
[16:20:55.763]         base::sink(type = "output", split = FALSE)
[16:20:55.763]         if (TRUE) {
[16:20:55.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:55.763]         }
[16:20:55.763]         else {
[16:20:55.763]             ...future.result["stdout"] <- base::list(NULL)
[16:20:55.763]         }
[16:20:55.763]         base::close(...future.stdout)
[16:20:55.763]         ...future.stdout <- NULL
[16:20:55.763]     }
[16:20:55.763]     ...future.result$conditions <- ...future.conditions
[16:20:55.763]     ...future.result$finished <- base::Sys.time()
[16:20:55.763]     ...future.result
[16:20:55.763] }
[16:20:55.766] Exporting 1 global objects (160 bytes) to cluster node #1 ...
[16:20:55.766] Exporting ‘data’ (160 bytes) to cluster node #1 ...
[16:20:55.767] Exporting ‘data’ (160 bytes) to cluster node #1 ... DONE
[16:20:55.767] Exporting 1 global objects (160 bytes) to cluster node #1 ... DONE
[16:20:55.767] MultisessionFuture started
[16:20:55.768] - Launch lazy future ... done
[16:20:55.768] run() for ‘MultisessionFuture’ ... done
[16:20:55.768] result() for ClusterFuture ...
[16:20:55.768] receiveMessageFromWorker() for ClusterFuture ...
[16:20:55.768] - Validating connection of MultisessionFuture
[16:20:55.770] - received message: FutureResult
[16:20:55.770] - Received FutureResult
[16:20:55.770] - Erased future from FutureRegistry
[16:20:55.770] result() for ClusterFuture ...
[16:20:55.770] - result already collected: FutureResult
[16:20:55.770] result() for ClusterFuture ... done
[16:20:55.770] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:55.771] result() for ClusterFuture ... done
[16:20:55.771] result() for ClusterFuture ...
[16:20:55.771] - result already collected: FutureResult
[16:20:55.771] result() for ClusterFuture ... done
[16:20:55.771] plan(): Setting new future strategy stack:
[16:20:55.771] List of future strategies:
[16:20:55.771] 1. sequential:
[16:20:55.771]    - args: function (..., envir = parent.frame())
[16:20:55.771]    - tweaked: FALSE
[16:20:55.771]    - call: plan(list(sequential, strategy))
[16:20:55.771] 2. multisession:
[16:20:55.771]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:55.771]    - tweaked: FALSE
[16:20:55.771]    - call: plan(list(sequential, strategy))
[16:20:55.772] plan(): nbrOfWorkers() = 1
[16:20:55.773] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:55.773] Searching for globals...
[16:20:55.781] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[16:20:55.781] Searching for globals ... DONE
[16:20:55.781] Resolving globals: FALSE
[16:20:55.782] The total size of the 1 globals is 160 bytes (160 bytes)
[16:20:55.782] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[16:20:55.782] - globals: [1] ‘data’
[16:20:55.782] - packages: [1] ‘future’
[16:20:55.783] getGlobalsAndPackages() ... DONE
[16:20:55.783] run() for ‘Future’ ...
[16:20:55.783] - state: ‘created’
[16:20:55.783] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:55.783] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:55.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:55.784]   - Field: ‘label’
[16:20:55.784]   - Field: ‘local’
[16:20:55.784]   - Field: ‘owner’
[16:20:55.784]   - Field: ‘envir’
[16:20:55.784]   - Field: ‘packages’
[16:20:55.784]   - Field: ‘gc’
[16:20:55.784]   - Field: ‘conditions’
[16:20:55.784]   - Field: ‘expr’
[16:20:55.784]   - Field: ‘uuid’
[16:20:55.785]   - Field: ‘seed’
[16:20:55.785]   - Field: ‘version’
[16:20:55.785]   - Field: ‘result’
[16:20:55.785]   - Field: ‘asynchronous’
[16:20:55.785]   - Field: ‘calls’
[16:20:55.785]   - Field: ‘globals’
[16:20:55.785]   - Field: ‘stdout’
[16:20:55.785]   - Field: ‘earlySignal’
[16:20:55.785]   - Field: ‘lazy’
[16:20:55.786]   - Field: ‘state’
[16:20:55.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:55.786] - Launch lazy future ...
[16:20:55.786] Packages needed by the future expression (n = 1): ‘future’
[16:20:55.786] Packages needed by future strategies (n = 1): ‘future’
[16:20:55.787] {
[16:20:55.787]     {
[16:20:55.787]         {
[16:20:55.787]             ...future.startTime <- base::Sys.time()
[16:20:55.787]             {
[16:20:55.787]                 {
[16:20:55.787]                   {
[16:20:55.787]                     {
[16:20:55.787]                       base::local({
[16:20:55.787]                         has_future <- base::requireNamespace("future", 
[16:20:55.787]                           quietly = TRUE)
[16:20:55.787]                         if (has_future) {
[16:20:55.787]                           ns <- base::getNamespace("future")
[16:20:55.787]                           version <- ns[[".package"]][["version"]]
[16:20:55.787]                           if (is.null(version)) 
[16:20:55.787]                             version <- utils::packageVersion("future")
[16:20:55.787]                         }
[16:20:55.787]                         else {
[16:20:55.787]                           version <- NULL
[16:20:55.787]                         }
[16:20:55.787]                         if (!has_future || version < "1.8.0") {
[16:20:55.787]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:55.787]                             "", base::R.version$version.string), 
[16:20:55.787]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:55.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:55.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:55.787]                               "release", "version")], collapse = " "), 
[16:20:55.787]                             hostname = base::Sys.info()[["nodename"]])
[16:20:55.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:55.787]                             info)
[16:20:55.787]                           info <- base::paste(info, collapse = "; ")
[16:20:55.787]                           if (!has_future) {
[16:20:55.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:55.787]                               info)
[16:20:55.787]                           }
[16:20:55.787]                           else {
[16:20:55.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:55.787]                               info, version)
[16:20:55.787]                           }
[16:20:55.787]                           base::stop(msg)
[16:20:55.787]                         }
[16:20:55.787]                       })
[16:20:55.787]                     }
[16:20:55.787]                     base::local({
[16:20:55.787]                       for (pkg in "future") {
[16:20:55.787]                         base::loadNamespace(pkg)
[16:20:55.787]                         base::library(pkg, character.only = TRUE)
[16:20:55.787]                       }
[16:20:55.787]                     })
[16:20:55.787]                   }
[16:20:55.787]                   ...future.strategy.old <- future::plan("list")
[16:20:55.787]                   options(future.plan = NULL)
[16:20:55.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.787]                   future::plan(list(function (..., workers = availableCores(), 
[16:20:55.787]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:20:55.787]                     envir = parent.frame()) 
[16:20:55.787]                   {
[16:20:55.787]                     if (is.function(workers)) 
[16:20:55.787]                       workers <- workers()
[16:20:55.787]                     workers <- structure(as.integer(workers), 
[16:20:55.787]                       class = class(workers))
[16:20:55.787]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:20:55.787]                       workers >= 1)
[16:20:55.787]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:20:55.787]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:20:55.787]                     }
[16:20:55.787]                     future <- MultisessionFuture(..., workers = workers, 
[16:20:55.787]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:20:55.787]                       envir = envir)
[16:20:55.787]                     if (!future$lazy) 
[16:20:55.787]                       future <- run(future)
[16:20:55.787]                     invisible(future)
[16:20:55.787]                   }), .cleanup = FALSE, .init = FALSE)
[16:20:55.787]                 }
[16:20:55.787]                 ...future.workdir <- getwd()
[16:20:55.787]             }
[16:20:55.787]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:55.787]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:55.787]         }
[16:20:55.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:55.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:55.787]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:55.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:55.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:55.787]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:55.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:55.787]             base::names(...future.oldOptions))
[16:20:55.787]     }
[16:20:55.787]     if (FALSE) {
[16:20:55.787]     }
[16:20:55.787]     else {
[16:20:55.787]         if (TRUE) {
[16:20:55.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:55.787]                 open = "w")
[16:20:55.787]         }
[16:20:55.787]         else {
[16:20:55.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:55.787]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:55.787]         }
[16:20:55.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:55.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:55.787]             base::sink(type = "output", split = FALSE)
[16:20:55.787]             base::close(...future.stdout)
[16:20:55.787]         }, add = TRUE)
[16:20:55.787]     }
[16:20:55.787]     ...future.frame <- base::sys.nframe()
[16:20:55.787]     ...future.conditions <- base::list()
[16:20:55.787]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:55.787]     if (FALSE) {
[16:20:55.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:55.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:55.787]     }
[16:20:55.787]     ...future.result <- base::tryCatch({
[16:20:55.787]         base::withCallingHandlers({
[16:20:55.787]             ...future.value <- base::withVisible(base::local({
[16:20:55.787]                 a %<-% subset(data, x < 3)$y
[16:20:55.787]                 a
[16:20:55.787]             }))
[16:20:55.787]             future::FutureResult(value = ...future.value$value, 
[16:20:55.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.787]                   ...future.rng), globalenv = if (FALSE) 
[16:20:55.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:55.787]                     ...future.globalenv.names))
[16:20:55.787]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:55.787]         }, condition = base::local({
[16:20:55.787]             c <- base::c
[16:20:55.787]             inherits <- base::inherits
[16:20:55.787]             invokeRestart <- base::invokeRestart
[16:20:55.787]             length <- base::length
[16:20:55.787]             list <- base::list
[16:20:55.787]             seq.int <- base::seq.int
[16:20:55.787]             signalCondition <- base::signalCondition
[16:20:55.787]             sys.calls <- base::sys.calls
[16:20:55.787]             `[[` <- base::`[[`
[16:20:55.787]             `+` <- base::`+`
[16:20:55.787]             `<<-` <- base::`<<-`
[16:20:55.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:55.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:55.787]                   3L)]
[16:20:55.787]             }
[16:20:55.787]             function(cond) {
[16:20:55.787]                 is_error <- inherits(cond, "error")
[16:20:55.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:55.787]                   NULL)
[16:20:55.787]                 if (is_error) {
[16:20:55.787]                   sessionInformation <- function() {
[16:20:55.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:55.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:55.787]                       search = base::search(), system = base::Sys.info())
[16:20:55.787]                   }
[16:20:55.787]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:55.787]                     cond$call), session = sessionInformation(), 
[16:20:55.787]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:55.787]                   signalCondition(cond)
[16:20:55.787]                 }
[16:20:55.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:55.787]                 "immediateCondition"))) {
[16:20:55.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:55.787]                   ...future.conditions[[length(...future.conditions) + 
[16:20:55.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:55.787]                   if (TRUE && !signal) {
[16:20:55.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.787]                     {
[16:20:55.787]                       inherits <- base::inherits
[16:20:55.787]                       invokeRestart <- base::invokeRestart
[16:20:55.787]                       is.null <- base::is.null
[16:20:55.787]                       muffled <- FALSE
[16:20:55.787]                       if (inherits(cond, "message")) {
[16:20:55.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.787]                         if (muffled) 
[16:20:55.787]                           invokeRestart("muffleMessage")
[16:20:55.787]                       }
[16:20:55.787]                       else if (inherits(cond, "warning")) {
[16:20:55.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.787]                         if (muffled) 
[16:20:55.787]                           invokeRestart("muffleWarning")
[16:20:55.787]                       }
[16:20:55.787]                       else if (inherits(cond, "condition")) {
[16:20:55.787]                         if (!is.null(pattern)) {
[16:20:55.787]                           computeRestarts <- base::computeRestarts
[16:20:55.787]                           grepl <- base::grepl
[16:20:55.787]                           restarts <- computeRestarts(cond)
[16:20:55.787]                           for (restart in restarts) {
[16:20:55.787]                             name <- restart$name
[16:20:55.787]                             if (is.null(name)) 
[16:20:55.787]                               next
[16:20:55.787]                             if (!grepl(pattern, name)) 
[16:20:55.787]                               next
[16:20:55.787]                             invokeRestart(restart)
[16:20:55.787]                             muffled <- TRUE
[16:20:55.787]                             break
[16:20:55.787]                           }
[16:20:55.787]                         }
[16:20:55.787]                       }
[16:20:55.787]                       invisible(muffled)
[16:20:55.787]                     }
[16:20:55.787]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.787]                   }
[16:20:55.787]                 }
[16:20:55.787]                 else {
[16:20:55.787]                   if (TRUE) {
[16:20:55.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:55.787]                     {
[16:20:55.787]                       inherits <- base::inherits
[16:20:55.787]                       invokeRestart <- base::invokeRestart
[16:20:55.787]                       is.null <- base::is.null
[16:20:55.787]                       muffled <- FALSE
[16:20:55.787]                       if (inherits(cond, "message")) {
[16:20:55.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:55.787]                         if (muffled) 
[16:20:55.787]                           invokeRestart("muffleMessage")
[16:20:55.787]                       }
[16:20:55.787]                       else if (inherits(cond, "warning")) {
[16:20:55.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:55.787]                         if (muffled) 
[16:20:55.787]                           invokeRestart("muffleWarning")
[16:20:55.787]                       }
[16:20:55.787]                       else if (inherits(cond, "condition")) {
[16:20:55.787]                         if (!is.null(pattern)) {
[16:20:55.787]                           computeRestarts <- base::computeRestarts
[16:20:55.787]                           grepl <- base::grepl
[16:20:55.787]                           restarts <- computeRestarts(cond)
[16:20:55.787]                           for (restart in restarts) {
[16:20:55.787]                             name <- restart$name
[16:20:55.787]                             if (is.null(name)) 
[16:20:55.787]                               next
[16:20:55.787]                             if (!grepl(pattern, name)) 
[16:20:55.787]                               next
[16:20:55.787]                             invokeRestart(restart)
[16:20:55.787]                             muffled <- TRUE
[16:20:55.787]                             break
[16:20:55.787]                           }
[16:20:55.787]                         }
[16:20:55.787]                       }
[16:20:55.787]                       invisible(muffled)
[16:20:55.787]                     }
[16:20:55.787]                     muffleCondition(cond, pattern = "^muffle")
[16:20:55.787]                   }
[16:20:55.787]                 }
[16:20:55.787]             }
[16:20:55.787]         }))
[16:20:55.787]     }, error = function(ex) {
[16:20:55.787]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:55.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:55.787]                 ...future.rng), started = ...future.startTime, 
[16:20:55.787]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:55.787]             version = "1.8"), class = "FutureResult")
[16:20:55.787]     }, finally = {
[16:20:55.787]         if (!identical(...future.workdir, getwd())) 
[16:20:55.787]             setwd(...future.workdir)
[16:20:55.787]         {
[16:20:55.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:55.787]                 ...future.oldOptions$nwarnings <- NULL
[16:20:55.787]             }
[16:20:55.787]             base::options(...future.oldOptions)
[16:20:55.787]             if (.Platform$OS.type == "windows") {
[16:20:55.787]                 old_names <- names(...future.oldEnvVars)
[16:20:55.787]                 envs <- base::Sys.getenv()
[16:20:55.787]                 names <- names(envs)
[16:20:55.787]                 common <- intersect(names, old_names)
[16:20:55.787]                 added <- setdiff(names, old_names)
[16:20:55.787]                 removed <- setdiff(old_names, names)
[16:20:55.787]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:55.787]                   envs[common]]
[16:20:55.787]                 NAMES <- toupper(changed)
[16:20:55.787]                 args <- list()
[16:20:55.787]                 for (kk in seq_along(NAMES)) {
[16:20:55.787]                   name <- changed[[kk]]
[16:20:55.787]                   NAME <- NAMES[[kk]]
[16:20:55.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.787]                     next
[16:20:55.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.787]                 }
[16:20:55.787]                 NAMES <- toupper(added)
[16:20:55.787]                 for (kk in seq_along(NAMES)) {
[16:20:55.787]                   name <- added[[kk]]
[16:20:55.787]                   NAME <- NAMES[[kk]]
[16:20:55.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.787]                     next
[16:20:55.787]                   args[[name]] <- ""
[16:20:55.787]                 }
[16:20:55.787]                 NAMES <- toupper(removed)
[16:20:55.787]                 for (kk in seq_along(NAMES)) {
[16:20:55.787]                   name <- removed[[kk]]
[16:20:55.787]                   NAME <- NAMES[[kk]]
[16:20:55.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:55.787]                     next
[16:20:55.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:55.787]                 }
[16:20:55.787]                 if (length(args) > 0) 
[16:20:55.787]                   base::do.call(base::Sys.setenv, args = args)
[16:20:55.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:55.787]             }
[16:20:55.787]             else {
[16:20:55.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:55.787]             }
[16:20:55.787]             {
[16:20:55.787]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:55.787]                   0L) {
[16:20:55.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:55.787]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:55.787]                   base::options(opts)
[16:20:55.787]                 }
[16:20:55.787]                 {
[16:20:55.787]                   {
[16:20:55.787]                     NULL
[16:20:55.787]                     RNGkind("Mersenne-Twister")
[16:20:55.787]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:55.787]                       inherits = FALSE)
[16:20:55.787]                   }
[16:20:55.787]                   options(future.plan = NULL)
[16:20:55.787]                   if (is.na(NA_character_)) 
[16:20:55.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:55.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:55.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:55.787]                     .init = FALSE)
[16:20:55.787]                 }
[16:20:55.787]             }
[16:20:55.787]         }
[16:20:55.787]     })
[16:20:55.787]     if (TRUE) {
[16:20:55.787]         base::sink(type = "output", split = FALSE)
[16:20:55.787]         if (TRUE) {
[16:20:55.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:55.787]         }
[16:20:55.787]         else {
[16:20:55.787]             ...future.result["stdout"] <- base::list(NULL)
[16:20:55.787]         }
[16:20:55.787]         base::close(...future.stdout)
[16:20:55.787]         ...future.stdout <- NULL
[16:20:55.787]     }
[16:20:55.787]     ...future.result$conditions <- ...future.conditions
[16:20:55.787]     ...future.result$finished <- base::Sys.time()
[16:20:55.787]     ...future.result
[16:20:55.787] }
[16:20:55.789] assign_globals() ...
[16:20:55.789] List of 1
[16:20:55.789]  $ data:'data.frame':	5 obs. of  2 variables:
[16:20:55.789]   ..$ x: int [1:5] 1 2 3 4 5
[16:20:55.789]   ..$ y: int [1:5] 1 2 3 4 5
[16:20:55.789]  - attr(*, "where")=List of 1
[16:20:55.789]   ..$ data:<environment: R_EmptyEnv> 
[16:20:55.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:55.789]  - attr(*, "resolved")= logi FALSE
[16:20:55.789]  - attr(*, "total_size")= num 160
[16:20:55.789]  - attr(*, "already-done")= logi TRUE
[16:20:55.792] - copied ‘data’ to environment
[16:20:55.792] assign_globals() ... done
[16:20:55.793] plan(): Setting new future strategy stack:
[16:20:55.793] List of future strategies:
[16:20:55.793] 1. multisession:
[16:20:55.793]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:55.793]    - tweaked: FALSE
[16:20:55.793]    - call: plan(list(sequential, strategy))
[16:20:55.796] plan(): nbrOfWorkers() = 2
[16:20:56.196] plan(): Setting new future strategy stack:
[16:20:56.197] List of future strategies:
[16:20:56.197] 1. sequential:
[16:20:56.197]    - args: function (..., envir = parent.frame())
[16:20:56.197]    - tweaked: FALSE
[16:20:56.197]    - call: plan(list(sequential, strategy))
[16:20:56.197] 2. multisession:
[16:20:56.197]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:56.197]    - tweaked: FALSE
[16:20:56.197]    - call: plan(list(sequential, strategy))
[16:20:56.197] plan(): nbrOfWorkers() = 1
[16:20:56.197] SequentialFuture started (and completed)
[16:20:56.197] signalConditions() ...
[16:20:56.198]  - include = ‘immediateCondition’
[16:20:56.198]  - exclude = 
[16:20:56.198]  - resignal = FALSE
[16:20:56.198]  - Number of conditions: 93
[16:20:56.198] signalConditions() ... done
[16:20:56.198] - Launch lazy future ... done
[16:20:56.198] run() for ‘SequentialFuture’ ... done
[16:20:56.198] signalConditions() ...
[16:20:56.198]  - include = ‘immediateCondition’
[16:20:56.198]  - exclude = 
[16:20:56.199]  - resignal = FALSE
[16:20:56.199]  - Number of conditions: 93
[16:20:56.199] signalConditions() ... done
[16:20:56.199] Future state: ‘finished’
[16:20:56.199] signalConditions() ...
[16:20:56.199]  - include = ‘condition’
[16:20:56.199]  - exclude = ‘immediateCondition’
[16:20:56.199]  - resignal = TRUE
[16:20:56.199]  - Number of conditions: 93
[16:20:56.199]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.797] getGlobalsAndPackages() ...
[16:20:56.200]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[16:20:56.200]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.810] Searching for globals...
[16:20:56.200]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.811] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[16:20:56.200]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.811] Searching for globals ... DONE
[16:20:56.200]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.811] Resolving globals: FALSE
[16:20:56.200]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.812] The total size of the 1 globals is 160 bytes (160 bytes)
[16:20:56.200]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.812] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[16:20:56.200]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.812] - globals: [1] ‘data’
[16:20:56.201]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.812] 
[16:20:56.201]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.812] getGlobalsAndPackages() ... DONE
[16:20:56.201]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.813] run() for ‘Future’ ...
[16:20:56.201]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.813] - state: ‘created’
[16:20:56.201]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.813] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:56.201]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.816] [local output] makeClusterPSOCK() ...
[16:20:56.201]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.819] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:20:56.202]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.820] [local output] Base port: 11254
[16:20:56.202]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.820] [local output] Getting setup options for 2 cluster nodes ...
[16:20:56.202]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.820] [local output]  - Node 1 of 2 ...
[16:20:56.202]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.820] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:56.202]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.821] [local output] Rscript port: 11254

[16:20:56.202]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.821] [local output]  - Node 2 of 2 ...
[16:20:56.202]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.822] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:56.202]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.822] [local output] Rscript port: 11254

[16:20:56.203]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.822] [local output] Getting setup options for 2 cluster nodes ... done
[16:20:56.203]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.823] [local output]  - Parallel setup requested for some PSOCK nodes
[16:20:56.203]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.823] [local output] Setting up PSOCK nodes in parallel
[16:20:56.203]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.823] List of 36
[16:20:55.823]  $ worker          : chr "localhost"
[16:20:55.823]   ..- attr(*, "localhost")= logi TRUE
[16:20:55.823]  $ master          : chr "localhost"
[16:20:55.823]  $ port            : int 11254
[16:20:55.823]  $ connectTimeout  : num 120
[16:20:55.823]  $ timeout         : num 2592000
[16:20:55.823]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:20:55.823]  $ homogeneous     : logi TRUE
[16:20:55.823]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:20:55.823]  $ rscript_envs    : NULL
[16:20:55.823]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:55.823]  $ rscript_startup : NULL
[16:20:55.823]  $ rscript_sh      : chr "sh"
[16:20:55.823]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:55.823]  $ methods         : logi TRUE
[16:20:55.823]  $ socketOptions   : chr "no-delay"
[16:20:55.823]  $ useXDR          : logi FALSE
[16:20:55.823]  $ outfile         : chr "/dev/null"
[16:20:55.823]  $ renice          : int NA
[16:20:55.823]  $ rshcmd          : NULL
[16:20:55.823]  $ user            : chr(0) 
[16:20:55.823]  $ revtunnel       : logi FALSE
[16:20:55.823]  $ rshlogfile      : NULL
[16:20:55.823]  $ rshopts         : chr(0) 
[16:20:55.823]  $ rank            : int 1
[16:20:55.823]  $ manual          : logi FALSE
[16:20:55.823]  $ dryrun          : logi FALSE
[16:20:55.823]  $ quiet           : logi FALSE
[16:20:55.823]  $ setup_strategy  : chr "parallel"
[16:20:55.823]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:55.823]  $ pidfile         : chr "/tmp/Rtmp6LbKVK/worker.rank=1.parallelly.parent=82995.144331fac00ee.pid"
[16:20:55.823]  $ rshcmd_label    : NULL
[16:20:55.823]  $ rsh_call        : NULL
[16:20:55.823]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:55.823]  $ localMachine    : logi TRUE
[16:20:55.823]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:20:55.823]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:20:55.823]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:20:55.823]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:20:55.823]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:20:55.823]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:20:55.823]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:20:55.823]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:20:55.823]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:20:55.823]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:20:55.823]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:20:55.823]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:20:55.823]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:20:55.823]  $ arguments       :List of 28
[16:20:55.823]   ..$ worker          : chr "localhost"
[16:20:55.823]   ..$ master          : NULL
[16:20:55.823]   ..$ port            : int 11254
[16:20:55.823]   ..$ connectTimeout  : num 120
[16:20:55.823]   ..$ timeout         : num 2592000
[16:20:55.823]   ..$ rscript         : NULL
[16:20:55.823]   ..$ homogeneous     : NULL
[16:20:55.823]   ..$ rscript_args    : NULL
[16:20:55.823]   ..$ rscript_envs    : NULL
[16:20:55.823]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:55.823]   ..$ rscript_startup : NULL
[16:20:55.823]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:20:55.823]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:55.823]   ..$ methods         : logi TRUE
[16:20:55.823]   ..$ socketOptions   : chr "no-delay"
[16:20:55.823]   ..$ useXDR          : logi FALSE
[16:20:55.823]   ..$ outfile         : chr "/dev/null"
[16:20:55.823]   ..$ renice          : int NA
[16:20:55.823]   ..$ rshcmd          : NULL
[16:20:55.823]   ..$ user            : NULL
[16:20:55.823]   ..$ revtunnel       : logi NA
[16:20:55.823]   ..$ rshlogfile      : NULL
[16:20:55.823]   ..$ rshopts         : NULL
[16:20:55.823]   ..$ rank            : int 1
[16:20:55.823]   ..$ manual          : logi FALSE
[16:20:55.823]   ..$ dryrun          : logi FALSE
[16:20:55.823]   ..$ quiet           : logi FALSE
[16:20:55.823]   ..$ setup_strategy  : chr "parallel"
[16:20:55.823]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:20:56.203]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.840] [local output] System call to launch all workers:
[16:20:56.203]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.840] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6LbKVK/worker.rank=1.parallelly.parent=82995.144331fac00ee.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11254 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:20:56.203]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.840] [local output] Starting PSOCK main server
[16:20:56.203]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.841] [local output] Workers launched
[16:20:56.204]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.842] [local output] Waiting for workers to connect back
[16:20:56.204]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:55.842]  - [local output] 0 workers out of 2 ready
[16:20:56.204]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.086]  - [local output] 0 workers out of 2 ready
[16:20:56.204]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.086]  - [local output] 1 workers out of 2 ready
[16:20:56.204]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.089]  - [local output] 1 workers out of 2 ready
[16:20:56.204]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.090]  - [local output] 2 workers out of 2 ready
[16:20:56.204]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.090] [local output] Launching of workers completed
[16:20:56.205]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.090] [local output] Collecting session information from workers
[16:20:56.205]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.090] [local output]  - Worker #1 of 2
[16:20:56.205]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.091] [local output]  - Worker #2 of 2
[16:20:56.205]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.091] [local output] makeClusterPSOCK() ... done
[16:20:56.205]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.101] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:56.205]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:56.205]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.102]   - Field: ‘node’
[16:20:56.205]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.102]   - Field: ‘label’
[16:20:56.206]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.102]   - Field: ‘local’
[16:20:56.206]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.102]   - Field: ‘owner’
[16:20:56.206]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.102]   - Field: ‘envir’
[16:20:56.206]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.102]   - Field: ‘workers’
[16:20:56.206]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.102]   - Field: ‘packages’
[16:20:56.206]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.103]   - Field: ‘gc’
[16:20:56.206]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.103]   - Field: ‘conditions’
[16:20:56.206]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.103]   - Field: ‘persistent’
[16:20:56.207]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.103]   - Field: ‘expr’
[16:20:56.207]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.103]   - Field: ‘uuid’
[16:20:56.207]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.103]   - Field: ‘seed’
[16:20:56.207]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.103]   - Field: ‘version’
[16:20:56.207]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.103]   - Field: ‘result’
[16:20:56.207]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.103]   - Field: ‘asynchronous’
[16:20:56.207]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.104]   - Field: ‘calls’
[16:20:56.207]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.104]   - Field: ‘globals’
[16:20:56.208]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.104]   - Field: ‘stdout’
[16:20:56.208]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.104]   - Field: ‘earlySignal’
[16:20:56.208]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.104]   - Field: ‘lazy’
[16:20:56.208]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.104]   - Field: ‘state’
[16:20:56.208]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.104] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:56.208]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.104] - Launch lazy future ...
[16:20:56.208]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.105] Packages needed by the future expression (n = 0): <none>
[16:20:56.209]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.105] Packages needed by future strategies (n = 0): <none>
[16:20:56.209]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.105] {
[16:20:56.105]     {
[16:20:56.105]         {
[16:20:56.105]             ...future.startTime <- base::Sys.time()
[16:20:56.105]             {
[16:20:56.105]                 {
[16:20:56.105]                   {
[16:20:56.105]                     {
[16:20:56.105]                       base::local({
[16:20:56.105]                         has_future <- base::requireNamespace("future", 
[16:20:56.105]                           quietly = TRUE)
[16:20:56.105]                         if (has_future) {
[16:20:56.105]                           ns <- base::getNamespace("future")
[16:20:56.105]                           version <- ns[[".package"]][["version"]]
[16:20:56.105]                           if (is.null(version)) 
[16:20:56.105]                             version <- utils::packageVersion("future")
[16:20:56.105]                         }
[16:20:56.105]                         else {
[16:20:56.105]                           version <- NULL
[16:20:56.105]                         }
[16:20:56.105]                         if (!has_future || version < "1.8.0") {
[16:20:56.105]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:56.105]                             "", base::R.version$version.string), 
[16:20:56.105]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:56.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:56.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:56.105]                               "release", "version")], collapse = " "), 
[16:20:56.105]                             hostname = base::Sys.info()[["nodename"]])
[16:20:56.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:56.105]                             info)
[16:20:56.105]                           info <- base::paste(info, collapse = "; ")
[16:20:56.105]                           if (!has_future) {
[16:20:56.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:56.105]                               info)
[16:20:56.105]                           }
[16:20:56.105]                           else {
[16:20:56.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:56.105]                               info, version)
[16:20:56.105]                           }
[16:20:56.105]                           base::stop(msg)
[16:20:56.105]                         }
[16:20:56.105]                       })
[16:20:56.105]                     }
[16:20:56.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:56.105]                     base::options(mc.cores = 1L)
[16:20:56.105]                   }
[16:20:56.105]                   ...future.strategy.old <- future::plan("list")
[16:20:56.105]                   options(future.plan = NULL)
[16:20:56.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:56.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:56.105]                 }
[16:20:56.105]                 ...future.workdir <- getwd()
[16:20:56.105]             }
[16:20:56.105]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:56.105]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:56.105]         }
[16:20:56.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[16:20:56.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:56.105]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[16:20:56.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:56.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:56.105]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:56.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:56.105]             base::names(...future.oldOptions))
[16:20:56.105]     }
[16:20:56.105]     if (FALSE) {
[16:20:56.105]     }
[16:20:56.105]     else {
[16:20:56.105]         if (TRUE) {
[16:20:56.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:56.105]                 open = "w")
[16:20:56.105]         }
[16:20:56.105]         else {
[16:20:56.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:56.105]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:56.105]         }
[16:20:56.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:56.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:56.105]             base::sink(type = "output", split = FALSE)
[16:20:56.105]             base::close(...future.stdout)
[16:20:56.105]         }, add = TRUE)
[16:20:56.105]     }
[16:20:56.105]     ...future.frame <- base::sys.nframe()
[16:20:56.105]     ...future.conditions <- base::list()
[16:20:56.105]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:56.105]     if (FALSE) {
[16:20:56.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:56.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:56.105]     }
[16:20:56.105]     ...future.result <- base::tryCatch({
[16:20:56.105]         base::withCallingHandlers({
[16:20:56.105]             ...future.value <- base::withVisible(base::local({
[16:20:56.105]                 ...future.makeSendCondition <- base::local({
[16:20:56.105]                   sendCondition <- NULL
[16:20:56.105]                   function(frame = 1L) {
[16:20:56.105]                     if (is.function(sendCondition)) 
[16:20:56.105]                       return(sendCondition)
[16:20:56.105]                     ns <- getNamespace("parallel")
[16:20:56.105]                     if (exists("sendData", mode = "function", 
[16:20:56.105]                       envir = ns)) {
[16:20:56.105]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:56.105]                         envir = ns)
[16:20:56.105]                       envir <- sys.frame(frame)
[16:20:56.105]                       master <- NULL
[16:20:56.105]                       while (!identical(envir, .GlobalEnv) && 
[16:20:56.105]                         !identical(envir, emptyenv())) {
[16:20:56.105]                         if (exists("master", mode = "list", envir = envir, 
[16:20:56.105]                           inherits = FALSE)) {
[16:20:56.105]                           master <- get("master", mode = "list", 
[16:20:56.105]                             envir = envir, inherits = FALSE)
[16:20:56.105]                           if (inherits(master, c("SOCKnode", 
[16:20:56.105]                             "SOCK0node"))) {
[16:20:56.105]                             sendCondition <<- function(cond) {
[16:20:56.105]                               data <- list(type = "VALUE", value = cond, 
[16:20:56.105]                                 success = TRUE)
[16:20:56.105]                               parallel_sendData(master, data)
[16:20:56.105]                             }
[16:20:56.105]                             return(sendCondition)
[16:20:56.105]                           }
[16:20:56.105]                         }
[16:20:56.105]                         frame <- frame + 1L
[16:20:56.105]                         envir <- sys.frame(frame)
[16:20:56.105]                       }
[16:20:56.105]                     }
[16:20:56.105]                     sendCondition <<- function(cond) NULL
[16:20:56.105]                   }
[16:20:56.105]                 })
[16:20:56.105]                 withCallingHandlers({
[16:20:56.105]                   subset(data, x < 3)$y
[16:20:56.105]                 }, immediateCondition = function(cond) {
[16:20:56.105]                   sendCondition <- ...future.makeSendCondition()
[16:20:56.105]                   sendCondition(cond)
[16:20:56.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:56.105]                   {
[16:20:56.105]                     inherits <- base::inherits
[16:20:56.105]                     invokeRestart <- base::invokeRestart
[16:20:56.105]                     is.null <- base::is.null
[16:20:56.105]                     muffled <- FALSE
[16:20:56.105]                     if (inherits(cond, "message")) {
[16:20:56.105]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:56.105]                       if (muffled) 
[16:20:56.105]                         invokeRestart("muffleMessage")
[16:20:56.105]                     }
[16:20:56.105]                     else if (inherits(cond, "warning")) {
[16:20:56.105]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:56.105]                       if (muffled) 
[16:20:56.105]                         invokeRestart("muffleWarning")
[16:20:56.105]                     }
[16:20:56.105]                     else if (inherits(cond, "condition")) {
[16:20:56.105]                       if (!is.null(pattern)) {
[16:20:56.105]                         computeRestarts <- base::computeRestarts
[16:20:56.105]                         grepl <- base::grepl
[16:20:56.105]                         restarts <- computeRestarts(cond)
[16:20:56.105]                         for (restart in restarts) {
[16:20:56.105]                           name <- restart$name
[16:20:56.105]                           if (is.null(name)) 
[16:20:56.105]                             next
[16:20:56.105]                           if (!grepl(pattern, name)) 
[16:20:56.105]                             next
[16:20:56.105]                           invokeRestart(restart)
[16:20:56.105]                           muffled <- TRUE
[16:20:56.105]                           break
[16:20:56.105]                         }
[16:20:56.105]                       }
[16:20:56.105]                     }
[16:20:56.105]                     invisible(muffled)
[16:20:56.105]                   }
[16:20:56.105]                   muffleCondition(cond)
[16:20:56.105]                 })
[16:20:56.105]             }))
[16:20:56.105]             future::FutureResult(value = ...future.value$value, 
[16:20:56.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:56.105]                   ...future.rng), globalenv = if (FALSE) 
[16:20:56.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:56.105]                     ...future.globalenv.names))
[16:20:56.105]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:56.105]         }, condition = base::local({
[16:20:56.105]             c <- base::c
[16:20:56.105]             inherits <- base::inherits
[16:20:56.105]             invokeRestart <- base::invokeRestart
[16:20:56.105]             length <- base::length
[16:20:56.105]             list <- base::list
[16:20:56.105]             seq.int <- base::seq.int
[16:20:56.105]             signalCondition <- base::signalCondition
[16:20:56.105]             sys.calls <- base::sys.calls
[16:20:56.105]             `[[` <- base::`[[`
[16:20:56.105]             `+` <- base::`+`
[16:20:56.105]             `<<-` <- base::`<<-`
[16:20:56.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:56.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:56.105]                   3L)]
[16:20:56.105]             }
[16:20:56.105]             function(cond) {
[16:20:56.105]                 is_error <- inherits(cond, "error")
[16:20:56.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:56.105]                   NULL)
[16:20:56.105]                 if (is_error) {
[16:20:56.105]                   sessionInformation <- function() {
[16:20:56.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:56.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:56.105]                       search = base::search(), system = base::Sys.info())
[16:20:56.105]                   }
[16:20:56.105]                   ...future.conditions[[length(...future.conditions) + 
[16:20:56.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:56.105]                     cond$call), session = sessionInformation(), 
[16:20:56.105]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:56.105]                   signalCondition(cond)
[16:20:56.105]                 }
[16:20:56.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:56.105]                 "immediateCondition"))) {
[16:20:56.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:56.105]                   ...future.conditions[[length(...future.conditions) + 
[16:20:56.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:56.105]                   if (TRUE && !signal) {
[16:20:56.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:56.105]                     {
[16:20:56.105]                       inherits <- base::inherits
[16:20:56.105]                       invokeRestart <- base::invokeRestart
[16:20:56.105]                       is.null <- base::is.null
[16:20:56.105]                       muffled <- FALSE
[16:20:56.105]                       if (inherits(cond, "message")) {
[16:20:56.105]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:56.105]                         if (muffled) 
[16:20:56.105]                           invokeRestart("muffleMessage")
[16:20:56.105]                       }
[16:20:56.105]                       else if (inherits(cond, "warning")) {
[16:20:56.105]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:56.105]                         if (muffled) 
[16:20:56.105]                           invokeRestart("muffleWarning")
[16:20:56.105]                       }
[16:20:56.105]                       else if (inherits(cond, "condition")) {
[16:20:56.105]                         if (!is.null(pattern)) {
[16:20:56.105]                           computeRestarts <- base::computeRestarts
[16:20:56.105]                           grepl <- base::grepl
[16:20:56.105]                           restarts <- computeRestarts(cond)
[16:20:56.105]                           for (restart in restarts) {
[16:20:56.105]                             name <- restart$name
[16:20:56.105]                             if (is.null(name)) 
[16:20:56.105]                               next
[16:20:56.105]                             if (!grepl(pattern, name)) 
[16:20:56.105]                               next
[16:20:56.105]                             invokeRestart(restart)
[16:20:56.105]                             muffled <- TRUE
[16:20:56.105]                             break
[16:20:56.105]                           }
[16:20:56.105]                         }
[16:20:56.105]                       }
[16:20:56.105]                       invisible(muffled)
[16:20:56.105]                     }
[16:20:56.105]                     muffleCondition(cond, pattern = "^muffle")
[16:20:56.105]                   }
[16:20:56.105]                 }
[16:20:56.105]                 else {
[16:20:56.105]                   if (TRUE) {
[16:20:56.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:56.105]                     {
[16:20:56.105]                       inherits <- base::inherits
[16:20:56.105]                       invokeRestart <- base::invokeRestart
[16:20:56.105]                       is.null <- base::is.null
[16:20:56.105]                       muffled <- FALSE
[16:20:56.105]                       if (inherits(cond, "message")) {
[16:20:56.105]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:56.105]                         if (muffled) 
[16:20:56.105]                           invokeRestart("muffleMessage")
[16:20:56.105]                       }
[16:20:56.105]                       else if (inherits(cond, "warning")) {
[16:20:56.105]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:56.105]                         if (muffled) 
[16:20:56.105]                           invokeRestart("muffleWarning")
[16:20:56.105]                       }
[16:20:56.105]                       else if (inherits(cond, "condition")) {
[16:20:56.105]                         if (!is.null(pattern)) {
[16:20:56.105]                           computeRestarts <- base::computeRestarts
[16:20:56.105]                           grepl <- base::grepl
[16:20:56.105]                           restarts <- computeRestarts(cond)
[16:20:56.105]                           for (restart in restarts) {
[16:20:56.105]                             name <- restart$name
[16:20:56.105]                             if (is.null(name)) 
[16:20:56.105]                               next
[16:20:56.105]                             if (!grepl(pattern, name)) 
[16:20:56.105]                               next
[16:20:56.105]                             invokeRestart(restart)
[16:20:56.105]                             muffled <- TRUE
[16:20:56.105]                             break
[16:20:56.105]                           }
[16:20:56.105]                         }
[16:20:56.105]                       }
[16:20:56.105]                       invisible(muffled)
[16:20:56.105]                     }
[16:20:56.105]                     muffleCondition(cond, pattern = "^muffle")
[16:20:56.105]                   }
[16:20:56.105]                 }
[16:20:56.105]             }
[16:20:56.105]         }))
[16:20:56.105]     }, error = function(ex) {
[16:20:56.105]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:56.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:56.105]                 ...future.rng), started = ...future.startTime, 
[16:20:56.105]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:56.105]             version = "1.8"), class = "FutureResult")
[16:20:56.105]     }, finally = {
[16:20:56.105]         if (!identical(...future.workdir, getwd())) 
[16:20:56.105]             setwd(...future.workdir)
[16:20:56.105]         {
[16:20:56.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:56.105]                 ...future.oldOptions$nwarnings <- NULL
[16:20:56.105]             }
[16:20:56.105]             base::options(...future.oldOptions)
[16:20:56.105]             if (.Platform$OS.type == "windows") {
[16:20:56.105]                 old_names <- names(...future.oldEnvVars)
[16:20:56.105]                 envs <- base::Sys.getenv()
[16:20:56.105]                 names <- names(envs)
[16:20:56.105]                 common <- intersect(names, old_names)
[16:20:56.105]                 added <- setdiff(names, old_names)
[16:20:56.105]                 removed <- setdiff(old_names, names)
[16:20:56.105]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:56.105]                   envs[common]]
[16:20:56.105]                 NAMES <- toupper(changed)
[16:20:56.105]                 args <- list()
[16:20:56.105]                 for (kk in seq_along(NAMES)) {
[16:20:56.105]                   name <- changed[[kk]]
[16:20:56.105]                   NAME <- NAMES[[kk]]
[16:20:56.105]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:56.105]                     next
[16:20:56.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:56.105]                 }
[16:20:56.105]                 NAMES <- toupper(added)
[16:20:56.105]                 for (kk in seq_along(NAMES)) {
[16:20:56.105]                   name <- added[[kk]]
[16:20:56.105]                   NAME <- NAMES[[kk]]
[16:20:56.105]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:56.105]                     next
[16:20:56.105]                   args[[name]] <- ""
[16:20:56.105]                 }
[16:20:56.105]                 NAMES <- toupper(removed)
[16:20:56.105]                 for (kk in seq_along(NAMES)) {
[16:20:56.105]                   name <- removed[[kk]]
[16:20:56.105]                   NAME <- NAMES[[kk]]
[16:20:56.105]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:56.105]                     next
[16:20:56.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:56.105]                 }
[16:20:56.105]                 if (length(args) > 0) 
[16:20:56.105]                   base::do.call(base::Sys.setenv, args = args)
[16:20:56.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:56.105]             }
[16:20:56.105]             else {
[16:20:56.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:56.105]             }
[16:20:56.105]             {
[16:20:56.105]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:56.105]                   0L) {
[16:20:56.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:56.105]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:56.105]                   base::options(opts)
[16:20:56.105]                 }
[16:20:56.105]                 {
[16:20:56.105]                   {
[16:20:56.105]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:56.105]                     NULL
[16:20:56.105]                   }
[16:20:56.105]                   options(future.plan = NULL)
[16:20:56.105]                   if (is.na(NA_character_)) 
[16:20:56.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:56.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:56.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:56.105]                     .init = FALSE)
[16:20:56.105]                 }
[16:20:56.105]             }
[16:20:56.105]         }
[16:20:56.105]     })
[16:20:56.105]     if (TRUE) {
[16:20:56.105]         base::sink(type = "output", split = FALSE)
[16:20:56.105]         if (TRUE) {
[16:20:56.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:56.105]         }
[16:20:56.105]         else {
[16:20:56.105]             ...future.result["stdout"] <- base::list(NULL)
[16:20:56.105]         }
[16:20:56.105]         base::close(...future.stdout)
[16:20:56.105]         ...future.stdout <- NULL
[16:20:56.105]     }
[16:20:56.105]     ...future.result$conditions <- ...future.conditions
[16:20:56.105]     ...future.result$finished <- base::Sys.time()
[16:20:56.105]     ...future.result
[16:20:56.105] }
[16:20:56.209]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.157] Exporting 1 global objects (160 bytes) to cluster node #1 ...
[16:20:56.209]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.157] Exporting ‘data’ (160 bytes) to cluster node #1 ...
[16:20:56.209]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.158] Exporting ‘data’ (160 bytes) to cluster node #1 ... DONE
[16:20:56.209]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.160] Exporting 1 global objects (160 bytes) to cluster node #1 ... DONE
[16:20:56.209]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.161] MultisessionFuture started
[16:20:56.210]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.161] - Launch lazy future ... done
[16:20:56.210]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.161] run() for ‘MultisessionFuture’ ... done
[16:20:56.210]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.161] result() for ClusterFuture ...
[16:20:56.210]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.162] receiveMessageFromWorker() for ClusterFuture ...
[16:20:56.210]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.162] - Validating connection of MultisessionFuture
[16:20:56.210]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.195] - received message: FutureResult
[16:20:56.210]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.195] - Received FutureResult
[16:20:56.210]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.195] - Erased future from FutureRegistry
[16:20:56.211]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.195] result() for ClusterFuture ...
[16:20:56.211]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.195] - result already collected: FutureResult
[16:20:56.211]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.195] result() for ClusterFuture ... done
[16:20:56.211]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.196] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:56.211]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.196] result() for ClusterFuture ... done
[16:20:56.211]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.196] result() for ClusterFuture ...
[16:20:56.211]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.196] - result already collected: FutureResult
[16:20:56.211]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:56.196] result() for ClusterFuture ... done
[16:20:56.212] signalConditions() ... done
- Strategy: multisession ... DONE
> 
> 
> message("*** Globals w/ non-standard evaluation (NSE) ... DONE")
*** Globals w/ non-standard evaluation (NSE) ... DONE
> 
> source("incl/end.R")
[16:20:56.212] plan(): Setting new future strategy stack:
[16:20:56.212] List of future strategies:
[16:20:56.212] 1. FutureStrategy:
[16:20:56.212]    - args: function (..., envir = parent.frame())
[16:20:56.212]    - tweaked: FALSE
[16:20:56.212]    - call: future::plan(oplan)
[16:20:56.213] plan(): nbrOfWorkers() = 1
> 
