
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:36:55.579] plan(): Setting new future strategy stack:
[13:36:55.580] List of future strategies:
[13:36:55.580] 1. sequential:
[13:36:55.580]    - args: function (..., envir = parent.frame())
[13:36:55.580]    - tweaked: FALSE
[13:36:55.580]    - call: future::plan("sequential")
[13:36:55.593] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[13:36:55.680] plan(): Setting new future strategy stack:
[13:36:55.680] List of future strategies:
[13:36:55.680] 1. sequential:
[13:36:55.680]    - args: function (..., envir = parent.frame())
[13:36:55.680]    - tweaked: FALSE
[13:36:55.680]    - call: plan(strategy)
[13:36:55.691] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.693] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.693] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.700] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:36:55.700] Searching for globals ... DONE
[13:36:55.700] Resolving globals: TRUE
[13:36:55.700] Resolving any globals that are futures ...
[13:36:55.700] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:36:55.700] Resolving any globals that are futures ... DONE
[13:36:55.701] 
[13:36:55.701] 
[13:36:55.701] getGlobalsAndPackages() ... DONE
[13:36:55.702] run() for ‘Future’ ...
[13:36:55.702] - state: ‘created’
[13:36:55.702] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.702] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.702] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.703]   - Field: ‘label’
[13:36:55.703]   - Field: ‘local’
[13:36:55.703]   - Field: ‘owner’
[13:36:55.703]   - Field: ‘envir’
[13:36:55.703]   - Field: ‘packages’
[13:36:55.703]   - Field: ‘gc’
[13:36:55.703]   - Field: ‘conditions’
[13:36:55.703]   - Field: ‘expr’
[13:36:55.703]   - Field: ‘uuid’
[13:36:55.703]   - Field: ‘seed’
[13:36:55.703]   - Field: ‘version’
[13:36:55.704]   - Field: ‘result’
[13:36:55.704]   - Field: ‘asynchronous’
[13:36:55.704]   - Field: ‘calls’
[13:36:55.704]   - Field: ‘globals’
[13:36:55.704]   - Field: ‘stdout’
[13:36:55.704]   - Field: ‘earlySignal’
[13:36:55.704]   - Field: ‘lazy’
[13:36:55.704]   - Field: ‘state’
[13:36:55.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.704] - Launch lazy future ...
[13:36:55.705] Packages needed by the future expression (n = 0): <none>
[13:36:55.705] Packages needed by future strategies (n = 0): <none>
[13:36:55.706] {
[13:36:55.706]     {
[13:36:55.706]         {
[13:36:55.706]             ...future.startTime <- base::Sys.time()
[13:36:55.706]             {
[13:36:55.706]                 {
[13:36:55.706]                   {
[13:36:55.706]                     base::local({
[13:36:55.706]                       has_future <- base::requireNamespace("future", 
[13:36:55.706]                         quietly = TRUE)
[13:36:55.706]                       if (has_future) {
[13:36:55.706]                         ns <- base::getNamespace("future")
[13:36:55.706]                         version <- ns[[".package"]][["version"]]
[13:36:55.706]                         if (is.null(version)) 
[13:36:55.706]                           version <- utils::packageVersion("future")
[13:36:55.706]                       }
[13:36:55.706]                       else {
[13:36:55.706]                         version <- NULL
[13:36:55.706]                       }
[13:36:55.706]                       if (!has_future || version < "1.8.0") {
[13:36:55.706]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.706]                           "", base::R.version$version.string), 
[13:36:55.706]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.706]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.706]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.706]                             "release", "version")], collapse = " "), 
[13:36:55.706]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.706]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.706]                           info)
[13:36:55.706]                         info <- base::paste(info, collapse = "; ")
[13:36:55.706]                         if (!has_future) {
[13:36:55.706]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.706]                             info)
[13:36:55.706]                         }
[13:36:55.706]                         else {
[13:36:55.706]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.706]                             info, version)
[13:36:55.706]                         }
[13:36:55.706]                         base::stop(msg)
[13:36:55.706]                       }
[13:36:55.706]                     })
[13:36:55.706]                   }
[13:36:55.706]                   ...future.strategy.old <- future::plan("list")
[13:36:55.706]                   options(future.plan = NULL)
[13:36:55.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.706]                 }
[13:36:55.706]                 ...future.workdir <- getwd()
[13:36:55.706]             }
[13:36:55.706]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.706]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.706]         }
[13:36:55.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.706]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.706]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.706]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.706]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.706]             base::names(...future.oldOptions))
[13:36:55.706]     }
[13:36:55.706]     if (FALSE) {
[13:36:55.706]     }
[13:36:55.706]     else {
[13:36:55.706]         if (TRUE) {
[13:36:55.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.706]                 open = "w")
[13:36:55.706]         }
[13:36:55.706]         else {
[13:36:55.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.706]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.706]         }
[13:36:55.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.706]             base::sink(type = "output", split = FALSE)
[13:36:55.706]             base::close(...future.stdout)
[13:36:55.706]         }, add = TRUE)
[13:36:55.706]     }
[13:36:55.706]     ...future.frame <- base::sys.nframe()
[13:36:55.706]     ...future.conditions <- base::list()
[13:36:55.706]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.706]     if (FALSE) {
[13:36:55.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.706]     }
[13:36:55.706]     ...future.result <- base::tryCatch({
[13:36:55.706]         base::withCallingHandlers({
[13:36:55.706]             ...future.value <- base::withVisible(base::local({
[13:36:55.706]                 b <- a
[13:36:55.706]                 a <- 2
[13:36:55.706]                 a * b
[13:36:55.706]             }))
[13:36:55.706]             future::FutureResult(value = ...future.value$value, 
[13:36:55.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.706]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.706]                     ...future.globalenv.names))
[13:36:55.706]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.706]         }, condition = base::local({
[13:36:55.706]             c <- base::c
[13:36:55.706]             inherits <- base::inherits
[13:36:55.706]             invokeRestart <- base::invokeRestart
[13:36:55.706]             length <- base::length
[13:36:55.706]             list <- base::list
[13:36:55.706]             seq.int <- base::seq.int
[13:36:55.706]             signalCondition <- base::signalCondition
[13:36:55.706]             sys.calls <- base::sys.calls
[13:36:55.706]             `[[` <- base::`[[`
[13:36:55.706]             `+` <- base::`+`
[13:36:55.706]             `<<-` <- base::`<<-`
[13:36:55.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.706]                   3L)]
[13:36:55.706]             }
[13:36:55.706]             function(cond) {
[13:36:55.706]                 is_error <- inherits(cond, "error")
[13:36:55.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.706]                   NULL)
[13:36:55.706]                 if (is_error) {
[13:36:55.706]                   sessionInformation <- function() {
[13:36:55.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.706]                       search = base::search(), system = base::Sys.info())
[13:36:55.706]                   }
[13:36:55.706]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.706]                     cond$call), session = sessionInformation(), 
[13:36:55.706]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.706]                   signalCondition(cond)
[13:36:55.706]                 }
[13:36:55.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.706]                 "immediateCondition"))) {
[13:36:55.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.706]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.706]                   if (TRUE && !signal) {
[13:36:55.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.706]                     {
[13:36:55.706]                       inherits <- base::inherits
[13:36:55.706]                       invokeRestart <- base::invokeRestart
[13:36:55.706]                       is.null <- base::is.null
[13:36:55.706]                       muffled <- FALSE
[13:36:55.706]                       if (inherits(cond, "message")) {
[13:36:55.706]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.706]                         if (muffled) 
[13:36:55.706]                           invokeRestart("muffleMessage")
[13:36:55.706]                       }
[13:36:55.706]                       else if (inherits(cond, "warning")) {
[13:36:55.706]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.706]                         if (muffled) 
[13:36:55.706]                           invokeRestart("muffleWarning")
[13:36:55.706]                       }
[13:36:55.706]                       else if (inherits(cond, "condition")) {
[13:36:55.706]                         if (!is.null(pattern)) {
[13:36:55.706]                           computeRestarts <- base::computeRestarts
[13:36:55.706]                           grepl <- base::grepl
[13:36:55.706]                           restarts <- computeRestarts(cond)
[13:36:55.706]                           for (restart in restarts) {
[13:36:55.706]                             name <- restart$name
[13:36:55.706]                             if (is.null(name)) 
[13:36:55.706]                               next
[13:36:55.706]                             if (!grepl(pattern, name)) 
[13:36:55.706]                               next
[13:36:55.706]                             invokeRestart(restart)
[13:36:55.706]                             muffled <- TRUE
[13:36:55.706]                             break
[13:36:55.706]                           }
[13:36:55.706]                         }
[13:36:55.706]                       }
[13:36:55.706]                       invisible(muffled)
[13:36:55.706]                     }
[13:36:55.706]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.706]                   }
[13:36:55.706]                 }
[13:36:55.706]                 else {
[13:36:55.706]                   if (TRUE) {
[13:36:55.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.706]                     {
[13:36:55.706]                       inherits <- base::inherits
[13:36:55.706]                       invokeRestart <- base::invokeRestart
[13:36:55.706]                       is.null <- base::is.null
[13:36:55.706]                       muffled <- FALSE
[13:36:55.706]                       if (inherits(cond, "message")) {
[13:36:55.706]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.706]                         if (muffled) 
[13:36:55.706]                           invokeRestart("muffleMessage")
[13:36:55.706]                       }
[13:36:55.706]                       else if (inherits(cond, "warning")) {
[13:36:55.706]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.706]                         if (muffled) 
[13:36:55.706]                           invokeRestart("muffleWarning")
[13:36:55.706]                       }
[13:36:55.706]                       else if (inherits(cond, "condition")) {
[13:36:55.706]                         if (!is.null(pattern)) {
[13:36:55.706]                           computeRestarts <- base::computeRestarts
[13:36:55.706]                           grepl <- base::grepl
[13:36:55.706]                           restarts <- computeRestarts(cond)
[13:36:55.706]                           for (restart in restarts) {
[13:36:55.706]                             name <- restart$name
[13:36:55.706]                             if (is.null(name)) 
[13:36:55.706]                               next
[13:36:55.706]                             if (!grepl(pattern, name)) 
[13:36:55.706]                               next
[13:36:55.706]                             invokeRestart(restart)
[13:36:55.706]                             muffled <- TRUE
[13:36:55.706]                             break
[13:36:55.706]                           }
[13:36:55.706]                         }
[13:36:55.706]                       }
[13:36:55.706]                       invisible(muffled)
[13:36:55.706]                     }
[13:36:55.706]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.706]                   }
[13:36:55.706]                 }
[13:36:55.706]             }
[13:36:55.706]         }))
[13:36:55.706]     }, error = function(ex) {
[13:36:55.706]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.706]                 ...future.rng), started = ...future.startTime, 
[13:36:55.706]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.706]             version = "1.8"), class = "FutureResult")
[13:36:55.706]     }, finally = {
[13:36:55.706]         if (!identical(...future.workdir, getwd())) 
[13:36:55.706]             setwd(...future.workdir)
[13:36:55.706]         {
[13:36:55.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.706]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.706]             }
[13:36:55.706]             base::options(...future.oldOptions)
[13:36:55.706]             if (.Platform$OS.type == "windows") {
[13:36:55.706]                 old_names <- names(...future.oldEnvVars)
[13:36:55.706]                 envs <- base::Sys.getenv()
[13:36:55.706]                 names <- names(envs)
[13:36:55.706]                 common <- intersect(names, old_names)
[13:36:55.706]                 added <- setdiff(names, old_names)
[13:36:55.706]                 removed <- setdiff(old_names, names)
[13:36:55.706]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.706]                   envs[common]]
[13:36:55.706]                 NAMES <- toupper(changed)
[13:36:55.706]                 args <- list()
[13:36:55.706]                 for (kk in seq_along(NAMES)) {
[13:36:55.706]                   name <- changed[[kk]]
[13:36:55.706]                   NAME <- NAMES[[kk]]
[13:36:55.706]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.706]                     next
[13:36:55.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.706]                 }
[13:36:55.706]                 NAMES <- toupper(added)
[13:36:55.706]                 for (kk in seq_along(NAMES)) {
[13:36:55.706]                   name <- added[[kk]]
[13:36:55.706]                   NAME <- NAMES[[kk]]
[13:36:55.706]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.706]                     next
[13:36:55.706]                   args[[name]] <- ""
[13:36:55.706]                 }
[13:36:55.706]                 NAMES <- toupper(removed)
[13:36:55.706]                 for (kk in seq_along(NAMES)) {
[13:36:55.706]                   name <- removed[[kk]]
[13:36:55.706]                   NAME <- NAMES[[kk]]
[13:36:55.706]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.706]                     next
[13:36:55.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.706]                 }
[13:36:55.706]                 if (length(args) > 0) 
[13:36:55.706]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.706]             }
[13:36:55.706]             else {
[13:36:55.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.706]             }
[13:36:55.706]             {
[13:36:55.706]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.706]                   0L) {
[13:36:55.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.706]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.706]                   base::options(opts)
[13:36:55.706]                 }
[13:36:55.706]                 {
[13:36:55.706]                   {
[13:36:55.706]                     NULL
[13:36:55.706]                     RNGkind("Mersenne-Twister")
[13:36:55.706]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.706]                       inherits = FALSE)
[13:36:55.706]                   }
[13:36:55.706]                   options(future.plan = NULL)
[13:36:55.706]                   if (is.na(NA_character_)) 
[13:36:55.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.706]                     .init = FALSE)
[13:36:55.706]                 }
[13:36:55.706]             }
[13:36:55.706]         }
[13:36:55.706]     })
[13:36:55.706]     if (TRUE) {
[13:36:55.706]         base::sink(type = "output", split = FALSE)
[13:36:55.706]         if (TRUE) {
[13:36:55.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.706]         }
[13:36:55.706]         else {
[13:36:55.706]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.706]         }
[13:36:55.706]         base::close(...future.stdout)
[13:36:55.706]         ...future.stdout <- NULL
[13:36:55.706]     }
[13:36:55.706]     ...future.result$conditions <- ...future.conditions
[13:36:55.706]     ...future.result$finished <- base::Sys.time()
[13:36:55.706]     ...future.result
[13:36:55.706] }
[13:36:55.708] plan(): Setting new future strategy stack:
[13:36:55.708] List of future strategies:
[13:36:55.708] 1. sequential:
[13:36:55.708]    - args: function (..., envir = parent.frame())
[13:36:55.708]    - tweaked: FALSE
[13:36:55.708]    - call: NULL
[13:36:55.708] plan(): nbrOfWorkers() = 1
[13:36:55.709] plan(): Setting new future strategy stack:
[13:36:55.710] List of future strategies:
[13:36:55.710] 1. sequential:
[13:36:55.710]    - args: function (..., envir = parent.frame())
[13:36:55.710]    - tweaked: FALSE
[13:36:55.710]    - call: plan(strategy)
[13:36:55.710] plan(): nbrOfWorkers() = 1
[13:36:55.710] SequentialFuture started (and completed)
[13:36:55.711] - Launch lazy future ... done
[13:36:55.711] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.711] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.712] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.713] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:36:55.713] Searching for globals ... DONE
[13:36:55.713] Resolving globals: TRUE
[13:36:55.713] Resolving any globals that are futures ...
[13:36:55.713] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:36:55.713] Resolving any globals that are futures ... DONE
[13:36:55.714] 
[13:36:55.714] 
[13:36:55.715] getGlobalsAndPackages() ... DONE
[13:36:55.716] run() for ‘Future’ ...
[13:36:55.716] - state: ‘created’
[13:36:55.716] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.716] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.716] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.716]   - Field: ‘label’
[13:36:55.717]   - Field: ‘local’
[13:36:55.717]   - Field: ‘owner’
[13:36:55.717]   - Field: ‘envir’
[13:36:55.717]   - Field: ‘packages’
[13:36:55.717]   - Field: ‘gc’
[13:36:55.717]   - Field: ‘conditions’
[13:36:55.717]   - Field: ‘expr’
[13:36:55.717]   - Field: ‘uuid’
[13:36:55.717]   - Field: ‘seed’
[13:36:55.717]   - Field: ‘version’
[13:36:55.717]   - Field: ‘result’
[13:36:55.718]   - Field: ‘asynchronous’
[13:36:55.718]   - Field: ‘calls’
[13:36:55.718]   - Field: ‘globals’
[13:36:55.718]   - Field: ‘stdout’
[13:36:55.718]   - Field: ‘earlySignal’
[13:36:55.718]   - Field: ‘lazy’
[13:36:55.718]   - Field: ‘state’
[13:36:55.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.718] - Launch lazy future ...
[13:36:55.719] Packages needed by the future expression (n = 0): <none>
[13:36:55.719] Packages needed by future strategies (n = 0): <none>
[13:36:55.719] {
[13:36:55.719]     {
[13:36:55.719]         {
[13:36:55.719]             ...future.startTime <- base::Sys.time()
[13:36:55.719]             {
[13:36:55.719]                 {
[13:36:55.719]                   {
[13:36:55.719]                     base::local({
[13:36:55.719]                       has_future <- base::requireNamespace("future", 
[13:36:55.719]                         quietly = TRUE)
[13:36:55.719]                       if (has_future) {
[13:36:55.719]                         ns <- base::getNamespace("future")
[13:36:55.719]                         version <- ns[[".package"]][["version"]]
[13:36:55.719]                         if (is.null(version)) 
[13:36:55.719]                           version <- utils::packageVersion("future")
[13:36:55.719]                       }
[13:36:55.719]                       else {
[13:36:55.719]                         version <- NULL
[13:36:55.719]                       }
[13:36:55.719]                       if (!has_future || version < "1.8.0") {
[13:36:55.719]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.719]                           "", base::R.version$version.string), 
[13:36:55.719]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.719]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.719]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.719]                             "release", "version")], collapse = " "), 
[13:36:55.719]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.719]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.719]                           info)
[13:36:55.719]                         info <- base::paste(info, collapse = "; ")
[13:36:55.719]                         if (!has_future) {
[13:36:55.719]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.719]                             info)
[13:36:55.719]                         }
[13:36:55.719]                         else {
[13:36:55.719]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.719]                             info, version)
[13:36:55.719]                         }
[13:36:55.719]                         base::stop(msg)
[13:36:55.719]                       }
[13:36:55.719]                     })
[13:36:55.719]                   }
[13:36:55.719]                   ...future.strategy.old <- future::plan("list")
[13:36:55.719]                   options(future.plan = NULL)
[13:36:55.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.719]                 }
[13:36:55.719]                 ...future.workdir <- getwd()
[13:36:55.719]             }
[13:36:55.719]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.719]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.719]         }
[13:36:55.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.719]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.719]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.719]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.719]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.719]             base::names(...future.oldOptions))
[13:36:55.719]     }
[13:36:55.719]     if (FALSE) {
[13:36:55.719]     }
[13:36:55.719]     else {
[13:36:55.719]         if (TRUE) {
[13:36:55.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.719]                 open = "w")
[13:36:55.719]         }
[13:36:55.719]         else {
[13:36:55.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.719]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.719]         }
[13:36:55.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.719]             base::sink(type = "output", split = FALSE)
[13:36:55.719]             base::close(...future.stdout)
[13:36:55.719]         }, add = TRUE)
[13:36:55.719]     }
[13:36:55.719]     ...future.frame <- base::sys.nframe()
[13:36:55.719]     ...future.conditions <- base::list()
[13:36:55.719]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.719]     if (FALSE) {
[13:36:55.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.719]     }
[13:36:55.719]     ...future.result <- base::tryCatch({
[13:36:55.719]         base::withCallingHandlers({
[13:36:55.719]             ...future.value <- base::withVisible(base::local({
[13:36:55.719]                 b <- a
[13:36:55.719]                 a <- 2
[13:36:55.719]                 a * b
[13:36:55.719]             }))
[13:36:55.719]             future::FutureResult(value = ...future.value$value, 
[13:36:55.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.719]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.719]                     ...future.globalenv.names))
[13:36:55.719]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.719]         }, condition = base::local({
[13:36:55.719]             c <- base::c
[13:36:55.719]             inherits <- base::inherits
[13:36:55.719]             invokeRestart <- base::invokeRestart
[13:36:55.719]             length <- base::length
[13:36:55.719]             list <- base::list
[13:36:55.719]             seq.int <- base::seq.int
[13:36:55.719]             signalCondition <- base::signalCondition
[13:36:55.719]             sys.calls <- base::sys.calls
[13:36:55.719]             `[[` <- base::`[[`
[13:36:55.719]             `+` <- base::`+`
[13:36:55.719]             `<<-` <- base::`<<-`
[13:36:55.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.719]                   3L)]
[13:36:55.719]             }
[13:36:55.719]             function(cond) {
[13:36:55.719]                 is_error <- inherits(cond, "error")
[13:36:55.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.719]                   NULL)
[13:36:55.719]                 if (is_error) {
[13:36:55.719]                   sessionInformation <- function() {
[13:36:55.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.719]                       search = base::search(), system = base::Sys.info())
[13:36:55.719]                   }
[13:36:55.719]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.719]                     cond$call), session = sessionInformation(), 
[13:36:55.719]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.719]                   signalCondition(cond)
[13:36:55.719]                 }
[13:36:55.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.719]                 "immediateCondition"))) {
[13:36:55.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.719]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.719]                   if (TRUE && !signal) {
[13:36:55.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.719]                     {
[13:36:55.719]                       inherits <- base::inherits
[13:36:55.719]                       invokeRestart <- base::invokeRestart
[13:36:55.719]                       is.null <- base::is.null
[13:36:55.719]                       muffled <- FALSE
[13:36:55.719]                       if (inherits(cond, "message")) {
[13:36:55.719]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.719]                         if (muffled) 
[13:36:55.719]                           invokeRestart("muffleMessage")
[13:36:55.719]                       }
[13:36:55.719]                       else if (inherits(cond, "warning")) {
[13:36:55.719]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.719]                         if (muffled) 
[13:36:55.719]                           invokeRestart("muffleWarning")
[13:36:55.719]                       }
[13:36:55.719]                       else if (inherits(cond, "condition")) {
[13:36:55.719]                         if (!is.null(pattern)) {
[13:36:55.719]                           computeRestarts <- base::computeRestarts
[13:36:55.719]                           grepl <- base::grepl
[13:36:55.719]                           restarts <- computeRestarts(cond)
[13:36:55.719]                           for (restart in restarts) {
[13:36:55.719]                             name <- restart$name
[13:36:55.719]                             if (is.null(name)) 
[13:36:55.719]                               next
[13:36:55.719]                             if (!grepl(pattern, name)) 
[13:36:55.719]                               next
[13:36:55.719]                             invokeRestart(restart)
[13:36:55.719]                             muffled <- TRUE
[13:36:55.719]                             break
[13:36:55.719]                           }
[13:36:55.719]                         }
[13:36:55.719]                       }
[13:36:55.719]                       invisible(muffled)
[13:36:55.719]                     }
[13:36:55.719]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.719]                   }
[13:36:55.719]                 }
[13:36:55.719]                 else {
[13:36:55.719]                   if (TRUE) {
[13:36:55.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.719]                     {
[13:36:55.719]                       inherits <- base::inherits
[13:36:55.719]                       invokeRestart <- base::invokeRestart
[13:36:55.719]                       is.null <- base::is.null
[13:36:55.719]                       muffled <- FALSE
[13:36:55.719]                       if (inherits(cond, "message")) {
[13:36:55.719]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.719]                         if (muffled) 
[13:36:55.719]                           invokeRestart("muffleMessage")
[13:36:55.719]                       }
[13:36:55.719]                       else if (inherits(cond, "warning")) {
[13:36:55.719]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.719]                         if (muffled) 
[13:36:55.719]                           invokeRestart("muffleWarning")
[13:36:55.719]                       }
[13:36:55.719]                       else if (inherits(cond, "condition")) {
[13:36:55.719]                         if (!is.null(pattern)) {
[13:36:55.719]                           computeRestarts <- base::computeRestarts
[13:36:55.719]                           grepl <- base::grepl
[13:36:55.719]                           restarts <- computeRestarts(cond)
[13:36:55.719]                           for (restart in restarts) {
[13:36:55.719]                             name <- restart$name
[13:36:55.719]                             if (is.null(name)) 
[13:36:55.719]                               next
[13:36:55.719]                             if (!grepl(pattern, name)) 
[13:36:55.719]                               next
[13:36:55.719]                             invokeRestart(restart)
[13:36:55.719]                             muffled <- TRUE
[13:36:55.719]                             break
[13:36:55.719]                           }
[13:36:55.719]                         }
[13:36:55.719]                       }
[13:36:55.719]                       invisible(muffled)
[13:36:55.719]                     }
[13:36:55.719]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.719]                   }
[13:36:55.719]                 }
[13:36:55.719]             }
[13:36:55.719]         }))
[13:36:55.719]     }, error = function(ex) {
[13:36:55.719]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.719]                 ...future.rng), started = ...future.startTime, 
[13:36:55.719]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.719]             version = "1.8"), class = "FutureResult")
[13:36:55.719]     }, finally = {
[13:36:55.719]         if (!identical(...future.workdir, getwd())) 
[13:36:55.719]             setwd(...future.workdir)
[13:36:55.719]         {
[13:36:55.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.719]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.719]             }
[13:36:55.719]             base::options(...future.oldOptions)
[13:36:55.719]             if (.Platform$OS.type == "windows") {
[13:36:55.719]                 old_names <- names(...future.oldEnvVars)
[13:36:55.719]                 envs <- base::Sys.getenv()
[13:36:55.719]                 names <- names(envs)
[13:36:55.719]                 common <- intersect(names, old_names)
[13:36:55.719]                 added <- setdiff(names, old_names)
[13:36:55.719]                 removed <- setdiff(old_names, names)
[13:36:55.719]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.719]                   envs[common]]
[13:36:55.719]                 NAMES <- toupper(changed)
[13:36:55.719]                 args <- list()
[13:36:55.719]                 for (kk in seq_along(NAMES)) {
[13:36:55.719]                   name <- changed[[kk]]
[13:36:55.719]                   NAME <- NAMES[[kk]]
[13:36:55.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.719]                     next
[13:36:55.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.719]                 }
[13:36:55.719]                 NAMES <- toupper(added)
[13:36:55.719]                 for (kk in seq_along(NAMES)) {
[13:36:55.719]                   name <- added[[kk]]
[13:36:55.719]                   NAME <- NAMES[[kk]]
[13:36:55.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.719]                     next
[13:36:55.719]                   args[[name]] <- ""
[13:36:55.719]                 }
[13:36:55.719]                 NAMES <- toupper(removed)
[13:36:55.719]                 for (kk in seq_along(NAMES)) {
[13:36:55.719]                   name <- removed[[kk]]
[13:36:55.719]                   NAME <- NAMES[[kk]]
[13:36:55.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.719]                     next
[13:36:55.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.719]                 }
[13:36:55.719]                 if (length(args) > 0) 
[13:36:55.719]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.719]             }
[13:36:55.719]             else {
[13:36:55.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.719]             }
[13:36:55.719]             {
[13:36:55.719]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.719]                   0L) {
[13:36:55.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.719]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.719]                   base::options(opts)
[13:36:55.719]                 }
[13:36:55.719]                 {
[13:36:55.719]                   {
[13:36:55.719]                     NULL
[13:36:55.719]                     RNGkind("Mersenne-Twister")
[13:36:55.719]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.719]                       inherits = FALSE)
[13:36:55.719]                   }
[13:36:55.719]                   options(future.plan = NULL)
[13:36:55.719]                   if (is.na(NA_character_)) 
[13:36:55.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.719]                     .init = FALSE)
[13:36:55.719]                 }
[13:36:55.719]             }
[13:36:55.719]         }
[13:36:55.719]     })
[13:36:55.719]     if (TRUE) {
[13:36:55.719]         base::sink(type = "output", split = FALSE)
[13:36:55.719]         if (TRUE) {
[13:36:55.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.719]         }
[13:36:55.719]         else {
[13:36:55.719]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.719]         }
[13:36:55.719]         base::close(...future.stdout)
[13:36:55.719]         ...future.stdout <- NULL
[13:36:55.719]     }
[13:36:55.719]     ...future.result$conditions <- ...future.conditions
[13:36:55.719]     ...future.result$finished <- base::Sys.time()
[13:36:55.719]     ...future.result
[13:36:55.719] }
[13:36:55.721] plan(): Setting new future strategy stack:
[13:36:55.721] List of future strategies:
[13:36:55.721] 1. sequential:
[13:36:55.721]    - args: function (..., envir = parent.frame())
[13:36:55.721]    - tweaked: FALSE
[13:36:55.721]    - call: NULL
[13:36:55.721] plan(): nbrOfWorkers() = 1
[13:36:55.722] plan(): Setting new future strategy stack:
[13:36:55.722] List of future strategies:
[13:36:55.722] 1. sequential:
[13:36:55.722]    - args: function (..., envir = parent.frame())
[13:36:55.722]    - tweaked: FALSE
[13:36:55.722]    - call: plan(strategy)
[13:36:55.722] plan(): nbrOfWorkers() = 1
[13:36:55.723] SequentialFuture started (and completed)
[13:36:55.723] signalConditions() ...
[13:36:55.723]  - include = ‘immediateCondition’
[13:36:55.723]  - exclude = 
[13:36:55.723]  - resignal = FALSE
[13:36:55.723]  - Number of conditions: 1
[13:36:55.723] signalConditions() ... done
[13:36:55.723] - Launch lazy future ... done
[13:36:55.723] run() for ‘SequentialFuture’ ... done
[13:36:55.723] signalConditions() ...
[13:36:55.724]  - include = ‘immediateCondition’
[13:36:55.724]  - exclude = 
[13:36:55.724]  - resignal = FALSE
[13:36:55.724]  - Number of conditions: 1
[13:36:55.724] signalConditions() ... done
[13:36:55.724] Future state: ‘finished’
[13:36:55.724] signalConditions() ...
[13:36:55.724]  - include = ‘condition’
[13:36:55.724]  - exclude = ‘immediateCondition’
[13:36:55.724]  - resignal = TRUE
[13:36:55.724]  - Number of conditions: 1
[13:36:55.724]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:55.725] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "57e9b94e809f" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:36:55"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.740] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.741] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.742] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.742] Searching for globals ... DONE
[13:36:55.742] Resolving globals: TRUE
[13:36:55.742] Resolving any globals that are futures ...
[13:36:55.742] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.742] Resolving any globals that are futures ... DONE
[13:36:55.743] Resolving futures part of globals (recursively) ...
[13:36:55.744] resolve() on list ...
[13:36:55.745]  recursive: 99
[13:36:55.745]  length: 1
[13:36:55.745]  elements: ‘ii’
[13:36:55.745]  length: 0 (resolved future 1)
[13:36:55.745] resolve() on list ... DONE
[13:36:55.745] - globals: [1] ‘ii’
[13:36:55.745] Resolving futures part of globals (recursively) ... DONE
[13:36:55.746] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:55.746] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:55.746] - globals: [1] ‘ii’
[13:36:55.746] 
[13:36:55.747] getGlobalsAndPackages() ... DONE
[13:36:55.747] run() for ‘Future’ ...
[13:36:55.747] - state: ‘created’
[13:36:55.747] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.747] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.747]   - Field: ‘label’
[13:36:55.748]   - Field: ‘local’
[13:36:55.748]   - Field: ‘owner’
[13:36:55.748]   - Field: ‘envir’
[13:36:55.748]   - Field: ‘packages’
[13:36:55.748]   - Field: ‘gc’
[13:36:55.748]   - Field: ‘conditions’
[13:36:55.748]   - Field: ‘expr’
[13:36:55.748]   - Field: ‘uuid’
[13:36:55.748]   - Field: ‘seed’
[13:36:55.748]   - Field: ‘version’
[13:36:55.748]   - Field: ‘result’
[13:36:55.748]   - Field: ‘asynchronous’
[13:36:55.749]   - Field: ‘calls’
[13:36:55.749]   - Field: ‘globals’
[13:36:55.749]   - Field: ‘stdout’
[13:36:55.749]   - Field: ‘earlySignal’
[13:36:55.749]   - Field: ‘lazy’
[13:36:55.749]   - Field: ‘state’
[13:36:55.749] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.749] - Launch lazy future ...
[13:36:55.749] Packages needed by the future expression (n = 0): <none>
[13:36:55.749] Packages needed by future strategies (n = 0): <none>
[13:36:55.750] {
[13:36:55.750]     {
[13:36:55.750]         {
[13:36:55.750]             ...future.startTime <- base::Sys.time()
[13:36:55.750]             {
[13:36:55.750]                 {
[13:36:55.750]                   {
[13:36:55.750]                     base::local({
[13:36:55.750]                       has_future <- base::requireNamespace("future", 
[13:36:55.750]                         quietly = TRUE)
[13:36:55.750]                       if (has_future) {
[13:36:55.750]                         ns <- base::getNamespace("future")
[13:36:55.750]                         version <- ns[[".package"]][["version"]]
[13:36:55.750]                         if (is.null(version)) 
[13:36:55.750]                           version <- utils::packageVersion("future")
[13:36:55.750]                       }
[13:36:55.750]                       else {
[13:36:55.750]                         version <- NULL
[13:36:55.750]                       }
[13:36:55.750]                       if (!has_future || version < "1.8.0") {
[13:36:55.750]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.750]                           "", base::R.version$version.string), 
[13:36:55.750]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.750]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.750]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.750]                             "release", "version")], collapse = " "), 
[13:36:55.750]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.750]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.750]                           info)
[13:36:55.750]                         info <- base::paste(info, collapse = "; ")
[13:36:55.750]                         if (!has_future) {
[13:36:55.750]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.750]                             info)
[13:36:55.750]                         }
[13:36:55.750]                         else {
[13:36:55.750]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.750]                             info, version)
[13:36:55.750]                         }
[13:36:55.750]                         base::stop(msg)
[13:36:55.750]                       }
[13:36:55.750]                     })
[13:36:55.750]                   }
[13:36:55.750]                   ...future.strategy.old <- future::plan("list")
[13:36:55.750]                   options(future.plan = NULL)
[13:36:55.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.750]                 }
[13:36:55.750]                 ...future.workdir <- getwd()
[13:36:55.750]             }
[13:36:55.750]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.750]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.750]         }
[13:36:55.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.750]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.750]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.750]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.750]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.750]             base::names(...future.oldOptions))
[13:36:55.750]     }
[13:36:55.750]     if (FALSE) {
[13:36:55.750]     }
[13:36:55.750]     else {
[13:36:55.750]         if (TRUE) {
[13:36:55.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.750]                 open = "w")
[13:36:55.750]         }
[13:36:55.750]         else {
[13:36:55.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.750]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.750]         }
[13:36:55.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.750]             base::sink(type = "output", split = FALSE)
[13:36:55.750]             base::close(...future.stdout)
[13:36:55.750]         }, add = TRUE)
[13:36:55.750]     }
[13:36:55.750]     ...future.frame <- base::sys.nframe()
[13:36:55.750]     ...future.conditions <- base::list()
[13:36:55.750]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.750]     if (FALSE) {
[13:36:55.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.750]     }
[13:36:55.750]     ...future.result <- base::tryCatch({
[13:36:55.750]         base::withCallingHandlers({
[13:36:55.750]             ...future.value <- base::withVisible(base::local({
[13:36:55.750]                 b <- a * ii
[13:36:55.750]                 a <- 0
[13:36:55.750]                 b
[13:36:55.750]             }))
[13:36:55.750]             future::FutureResult(value = ...future.value$value, 
[13:36:55.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.750]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.750]                     ...future.globalenv.names))
[13:36:55.750]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.750]         }, condition = base::local({
[13:36:55.750]             c <- base::c
[13:36:55.750]             inherits <- base::inherits
[13:36:55.750]             invokeRestart <- base::invokeRestart
[13:36:55.750]             length <- base::length
[13:36:55.750]             list <- base::list
[13:36:55.750]             seq.int <- base::seq.int
[13:36:55.750]             signalCondition <- base::signalCondition
[13:36:55.750]             sys.calls <- base::sys.calls
[13:36:55.750]             `[[` <- base::`[[`
[13:36:55.750]             `+` <- base::`+`
[13:36:55.750]             `<<-` <- base::`<<-`
[13:36:55.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.750]                   3L)]
[13:36:55.750]             }
[13:36:55.750]             function(cond) {
[13:36:55.750]                 is_error <- inherits(cond, "error")
[13:36:55.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.750]                   NULL)
[13:36:55.750]                 if (is_error) {
[13:36:55.750]                   sessionInformation <- function() {
[13:36:55.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.750]                       search = base::search(), system = base::Sys.info())
[13:36:55.750]                   }
[13:36:55.750]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.750]                     cond$call), session = sessionInformation(), 
[13:36:55.750]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.750]                   signalCondition(cond)
[13:36:55.750]                 }
[13:36:55.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.750]                 "immediateCondition"))) {
[13:36:55.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.750]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.750]                   if (TRUE && !signal) {
[13:36:55.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.750]                     {
[13:36:55.750]                       inherits <- base::inherits
[13:36:55.750]                       invokeRestart <- base::invokeRestart
[13:36:55.750]                       is.null <- base::is.null
[13:36:55.750]                       muffled <- FALSE
[13:36:55.750]                       if (inherits(cond, "message")) {
[13:36:55.750]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.750]                         if (muffled) 
[13:36:55.750]                           invokeRestart("muffleMessage")
[13:36:55.750]                       }
[13:36:55.750]                       else if (inherits(cond, "warning")) {
[13:36:55.750]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.750]                         if (muffled) 
[13:36:55.750]                           invokeRestart("muffleWarning")
[13:36:55.750]                       }
[13:36:55.750]                       else if (inherits(cond, "condition")) {
[13:36:55.750]                         if (!is.null(pattern)) {
[13:36:55.750]                           computeRestarts <- base::computeRestarts
[13:36:55.750]                           grepl <- base::grepl
[13:36:55.750]                           restarts <- computeRestarts(cond)
[13:36:55.750]                           for (restart in restarts) {
[13:36:55.750]                             name <- restart$name
[13:36:55.750]                             if (is.null(name)) 
[13:36:55.750]                               next
[13:36:55.750]                             if (!grepl(pattern, name)) 
[13:36:55.750]                               next
[13:36:55.750]                             invokeRestart(restart)
[13:36:55.750]                             muffled <- TRUE
[13:36:55.750]                             break
[13:36:55.750]                           }
[13:36:55.750]                         }
[13:36:55.750]                       }
[13:36:55.750]                       invisible(muffled)
[13:36:55.750]                     }
[13:36:55.750]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.750]                   }
[13:36:55.750]                 }
[13:36:55.750]                 else {
[13:36:55.750]                   if (TRUE) {
[13:36:55.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.750]                     {
[13:36:55.750]                       inherits <- base::inherits
[13:36:55.750]                       invokeRestart <- base::invokeRestart
[13:36:55.750]                       is.null <- base::is.null
[13:36:55.750]                       muffled <- FALSE
[13:36:55.750]                       if (inherits(cond, "message")) {
[13:36:55.750]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.750]                         if (muffled) 
[13:36:55.750]                           invokeRestart("muffleMessage")
[13:36:55.750]                       }
[13:36:55.750]                       else if (inherits(cond, "warning")) {
[13:36:55.750]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.750]                         if (muffled) 
[13:36:55.750]                           invokeRestart("muffleWarning")
[13:36:55.750]                       }
[13:36:55.750]                       else if (inherits(cond, "condition")) {
[13:36:55.750]                         if (!is.null(pattern)) {
[13:36:55.750]                           computeRestarts <- base::computeRestarts
[13:36:55.750]                           grepl <- base::grepl
[13:36:55.750]                           restarts <- computeRestarts(cond)
[13:36:55.750]                           for (restart in restarts) {
[13:36:55.750]                             name <- restart$name
[13:36:55.750]                             if (is.null(name)) 
[13:36:55.750]                               next
[13:36:55.750]                             if (!grepl(pattern, name)) 
[13:36:55.750]                               next
[13:36:55.750]                             invokeRestart(restart)
[13:36:55.750]                             muffled <- TRUE
[13:36:55.750]                             break
[13:36:55.750]                           }
[13:36:55.750]                         }
[13:36:55.750]                       }
[13:36:55.750]                       invisible(muffled)
[13:36:55.750]                     }
[13:36:55.750]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.750]                   }
[13:36:55.750]                 }
[13:36:55.750]             }
[13:36:55.750]         }))
[13:36:55.750]     }, error = function(ex) {
[13:36:55.750]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.750]                 ...future.rng), started = ...future.startTime, 
[13:36:55.750]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.750]             version = "1.8"), class = "FutureResult")
[13:36:55.750]     }, finally = {
[13:36:55.750]         if (!identical(...future.workdir, getwd())) 
[13:36:55.750]             setwd(...future.workdir)
[13:36:55.750]         {
[13:36:55.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.750]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.750]             }
[13:36:55.750]             base::options(...future.oldOptions)
[13:36:55.750]             if (.Platform$OS.type == "windows") {
[13:36:55.750]                 old_names <- names(...future.oldEnvVars)
[13:36:55.750]                 envs <- base::Sys.getenv()
[13:36:55.750]                 names <- names(envs)
[13:36:55.750]                 common <- intersect(names, old_names)
[13:36:55.750]                 added <- setdiff(names, old_names)
[13:36:55.750]                 removed <- setdiff(old_names, names)
[13:36:55.750]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.750]                   envs[common]]
[13:36:55.750]                 NAMES <- toupper(changed)
[13:36:55.750]                 args <- list()
[13:36:55.750]                 for (kk in seq_along(NAMES)) {
[13:36:55.750]                   name <- changed[[kk]]
[13:36:55.750]                   NAME <- NAMES[[kk]]
[13:36:55.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.750]                     next
[13:36:55.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.750]                 }
[13:36:55.750]                 NAMES <- toupper(added)
[13:36:55.750]                 for (kk in seq_along(NAMES)) {
[13:36:55.750]                   name <- added[[kk]]
[13:36:55.750]                   NAME <- NAMES[[kk]]
[13:36:55.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.750]                     next
[13:36:55.750]                   args[[name]] <- ""
[13:36:55.750]                 }
[13:36:55.750]                 NAMES <- toupper(removed)
[13:36:55.750]                 for (kk in seq_along(NAMES)) {
[13:36:55.750]                   name <- removed[[kk]]
[13:36:55.750]                   NAME <- NAMES[[kk]]
[13:36:55.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.750]                     next
[13:36:55.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.750]                 }
[13:36:55.750]                 if (length(args) > 0) 
[13:36:55.750]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.750]             }
[13:36:55.750]             else {
[13:36:55.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.750]             }
[13:36:55.750]             {
[13:36:55.750]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.750]                   0L) {
[13:36:55.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.750]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.750]                   base::options(opts)
[13:36:55.750]                 }
[13:36:55.750]                 {
[13:36:55.750]                   {
[13:36:55.750]                     NULL
[13:36:55.750]                     RNGkind("Mersenne-Twister")
[13:36:55.750]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.750]                       inherits = FALSE)
[13:36:55.750]                   }
[13:36:55.750]                   options(future.plan = NULL)
[13:36:55.750]                   if (is.na(NA_character_)) 
[13:36:55.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.750]                     .init = FALSE)
[13:36:55.750]                 }
[13:36:55.750]             }
[13:36:55.750]         }
[13:36:55.750]     })
[13:36:55.750]     if (TRUE) {
[13:36:55.750]         base::sink(type = "output", split = FALSE)
[13:36:55.750]         if (TRUE) {
[13:36:55.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.750]         }
[13:36:55.750]         else {
[13:36:55.750]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.750]         }
[13:36:55.750]         base::close(...future.stdout)
[13:36:55.750]         ...future.stdout <- NULL
[13:36:55.750]     }
[13:36:55.750]     ...future.result$conditions <- ...future.conditions
[13:36:55.750]     ...future.result$finished <- base::Sys.time()
[13:36:55.750]     ...future.result
[13:36:55.750] }
[13:36:55.751] assign_globals() ...
[13:36:55.752] List of 1
[13:36:55.752]  $ ii: int 1
[13:36:55.752]  - attr(*, "where")=List of 1
[13:36:55.752]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:55.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.752]  - attr(*, "resolved")= logi TRUE
[13:36:55.752]  - attr(*, "total_size")= num 56
[13:36:55.752]  - attr(*, "already-done")= logi TRUE
[13:36:55.754] - copied ‘ii’ to environment
[13:36:55.754] assign_globals() ... done
[13:36:55.754] plan(): Setting new future strategy stack:
[13:36:55.754] List of future strategies:
[13:36:55.754] 1. sequential:
[13:36:55.754]    - args: function (..., envir = parent.frame())
[13:36:55.754]    - tweaked: FALSE
[13:36:55.754]    - call: NULL
[13:36:55.755] plan(): nbrOfWorkers() = 1
[13:36:55.755] plan(): Setting new future strategy stack:
[13:36:55.755] List of future strategies:
[13:36:55.755] 1. sequential:
[13:36:55.755]    - args: function (..., envir = parent.frame())
[13:36:55.755]    - tweaked: FALSE
[13:36:55.755]    - call: plan(strategy)
[13:36:55.756] plan(): nbrOfWorkers() = 1
[13:36:55.756] SequentialFuture started (and completed)
[13:36:55.756] - Launch lazy future ... done
[13:36:55.756] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.756] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.757] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.758] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.758] Searching for globals ... DONE
[13:36:55.758] Resolving globals: TRUE
[13:36:55.758] Resolving any globals that are futures ...
[13:36:55.758] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.758] Resolving any globals that are futures ... DONE
[13:36:55.759] Resolving futures part of globals (recursively) ...
[13:36:55.759] resolve() on list ...
[13:36:55.759]  recursive: 99
[13:36:55.759]  length: 1
[13:36:55.759]  elements: ‘ii’
[13:36:55.759]  length: 0 (resolved future 1)
[13:36:55.759] resolve() on list ... DONE
[13:36:55.759] - globals: [1] ‘ii’
[13:36:55.759] Resolving futures part of globals (recursively) ... DONE
[13:36:55.760] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:55.760] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:55.760] - globals: [1] ‘ii’
[13:36:55.760] 
[13:36:55.760] getGlobalsAndPackages() ... DONE
[13:36:55.760] run() for ‘Future’ ...
[13:36:55.761] - state: ‘created’
[13:36:55.761] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.761] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.761] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.761]   - Field: ‘label’
[13:36:55.761]   - Field: ‘local’
[13:36:55.761]   - Field: ‘owner’
[13:36:55.761]   - Field: ‘envir’
[13:36:55.761]   - Field: ‘packages’
[13:36:55.762]   - Field: ‘gc’
[13:36:55.762]   - Field: ‘conditions’
[13:36:55.762]   - Field: ‘expr’
[13:36:55.762]   - Field: ‘uuid’
[13:36:55.762]   - Field: ‘seed’
[13:36:55.762]   - Field: ‘version’
[13:36:55.762]   - Field: ‘result’
[13:36:55.762]   - Field: ‘asynchronous’
[13:36:55.762]   - Field: ‘calls’
[13:36:55.762]   - Field: ‘globals’
[13:36:55.762]   - Field: ‘stdout’
[13:36:55.763]   - Field: ‘earlySignal’
[13:36:55.763]   - Field: ‘lazy’
[13:36:55.763]   - Field: ‘state’
[13:36:55.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.763] - Launch lazy future ...
[13:36:55.763] Packages needed by the future expression (n = 0): <none>
[13:36:55.763] Packages needed by future strategies (n = 0): <none>
[13:36:55.763] {
[13:36:55.763]     {
[13:36:55.763]         {
[13:36:55.763]             ...future.startTime <- base::Sys.time()
[13:36:55.763]             {
[13:36:55.763]                 {
[13:36:55.763]                   {
[13:36:55.763]                     base::local({
[13:36:55.763]                       has_future <- base::requireNamespace("future", 
[13:36:55.763]                         quietly = TRUE)
[13:36:55.763]                       if (has_future) {
[13:36:55.763]                         ns <- base::getNamespace("future")
[13:36:55.763]                         version <- ns[[".package"]][["version"]]
[13:36:55.763]                         if (is.null(version)) 
[13:36:55.763]                           version <- utils::packageVersion("future")
[13:36:55.763]                       }
[13:36:55.763]                       else {
[13:36:55.763]                         version <- NULL
[13:36:55.763]                       }
[13:36:55.763]                       if (!has_future || version < "1.8.0") {
[13:36:55.763]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.763]                           "", base::R.version$version.string), 
[13:36:55.763]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.763]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.763]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.763]                             "release", "version")], collapse = " "), 
[13:36:55.763]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.763]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.763]                           info)
[13:36:55.763]                         info <- base::paste(info, collapse = "; ")
[13:36:55.763]                         if (!has_future) {
[13:36:55.763]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.763]                             info)
[13:36:55.763]                         }
[13:36:55.763]                         else {
[13:36:55.763]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.763]                             info, version)
[13:36:55.763]                         }
[13:36:55.763]                         base::stop(msg)
[13:36:55.763]                       }
[13:36:55.763]                     })
[13:36:55.763]                   }
[13:36:55.763]                   ...future.strategy.old <- future::plan("list")
[13:36:55.763]                   options(future.plan = NULL)
[13:36:55.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.763]                 }
[13:36:55.763]                 ...future.workdir <- getwd()
[13:36:55.763]             }
[13:36:55.763]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.763]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.763]         }
[13:36:55.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.763]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.763]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.763]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.763]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.763]             base::names(...future.oldOptions))
[13:36:55.763]     }
[13:36:55.763]     if (FALSE) {
[13:36:55.763]     }
[13:36:55.763]     else {
[13:36:55.763]         if (TRUE) {
[13:36:55.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.763]                 open = "w")
[13:36:55.763]         }
[13:36:55.763]         else {
[13:36:55.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.763]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.763]         }
[13:36:55.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.763]             base::sink(type = "output", split = FALSE)
[13:36:55.763]             base::close(...future.stdout)
[13:36:55.763]         }, add = TRUE)
[13:36:55.763]     }
[13:36:55.763]     ...future.frame <- base::sys.nframe()
[13:36:55.763]     ...future.conditions <- base::list()
[13:36:55.763]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.763]     if (FALSE) {
[13:36:55.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.763]     }
[13:36:55.763]     ...future.result <- base::tryCatch({
[13:36:55.763]         base::withCallingHandlers({
[13:36:55.763]             ...future.value <- base::withVisible(base::local({
[13:36:55.763]                 b <- a * ii
[13:36:55.763]                 a <- 0
[13:36:55.763]                 b
[13:36:55.763]             }))
[13:36:55.763]             future::FutureResult(value = ...future.value$value, 
[13:36:55.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.763]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.763]                     ...future.globalenv.names))
[13:36:55.763]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.763]         }, condition = base::local({
[13:36:55.763]             c <- base::c
[13:36:55.763]             inherits <- base::inherits
[13:36:55.763]             invokeRestart <- base::invokeRestart
[13:36:55.763]             length <- base::length
[13:36:55.763]             list <- base::list
[13:36:55.763]             seq.int <- base::seq.int
[13:36:55.763]             signalCondition <- base::signalCondition
[13:36:55.763]             sys.calls <- base::sys.calls
[13:36:55.763]             `[[` <- base::`[[`
[13:36:55.763]             `+` <- base::`+`
[13:36:55.763]             `<<-` <- base::`<<-`
[13:36:55.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.763]                   3L)]
[13:36:55.763]             }
[13:36:55.763]             function(cond) {
[13:36:55.763]                 is_error <- inherits(cond, "error")
[13:36:55.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.763]                   NULL)
[13:36:55.763]                 if (is_error) {
[13:36:55.763]                   sessionInformation <- function() {
[13:36:55.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.763]                       search = base::search(), system = base::Sys.info())
[13:36:55.763]                   }
[13:36:55.763]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.763]                     cond$call), session = sessionInformation(), 
[13:36:55.763]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.763]                   signalCondition(cond)
[13:36:55.763]                 }
[13:36:55.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.763]                 "immediateCondition"))) {
[13:36:55.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.763]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.763]                   if (TRUE && !signal) {
[13:36:55.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.763]                     {
[13:36:55.763]                       inherits <- base::inherits
[13:36:55.763]                       invokeRestart <- base::invokeRestart
[13:36:55.763]                       is.null <- base::is.null
[13:36:55.763]                       muffled <- FALSE
[13:36:55.763]                       if (inherits(cond, "message")) {
[13:36:55.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.763]                         if (muffled) 
[13:36:55.763]                           invokeRestart("muffleMessage")
[13:36:55.763]                       }
[13:36:55.763]                       else if (inherits(cond, "warning")) {
[13:36:55.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.763]                         if (muffled) 
[13:36:55.763]                           invokeRestart("muffleWarning")
[13:36:55.763]                       }
[13:36:55.763]                       else if (inherits(cond, "condition")) {
[13:36:55.763]                         if (!is.null(pattern)) {
[13:36:55.763]                           computeRestarts <- base::computeRestarts
[13:36:55.763]                           grepl <- base::grepl
[13:36:55.763]                           restarts <- computeRestarts(cond)
[13:36:55.763]                           for (restart in restarts) {
[13:36:55.763]                             name <- restart$name
[13:36:55.763]                             if (is.null(name)) 
[13:36:55.763]                               next
[13:36:55.763]                             if (!grepl(pattern, name)) 
[13:36:55.763]                               next
[13:36:55.763]                             invokeRestart(restart)
[13:36:55.763]                             muffled <- TRUE
[13:36:55.763]                             break
[13:36:55.763]                           }
[13:36:55.763]                         }
[13:36:55.763]                       }
[13:36:55.763]                       invisible(muffled)
[13:36:55.763]                     }
[13:36:55.763]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.763]                   }
[13:36:55.763]                 }
[13:36:55.763]                 else {
[13:36:55.763]                   if (TRUE) {
[13:36:55.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.763]                     {
[13:36:55.763]                       inherits <- base::inherits
[13:36:55.763]                       invokeRestart <- base::invokeRestart
[13:36:55.763]                       is.null <- base::is.null
[13:36:55.763]                       muffled <- FALSE
[13:36:55.763]                       if (inherits(cond, "message")) {
[13:36:55.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.763]                         if (muffled) 
[13:36:55.763]                           invokeRestart("muffleMessage")
[13:36:55.763]                       }
[13:36:55.763]                       else if (inherits(cond, "warning")) {
[13:36:55.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.763]                         if (muffled) 
[13:36:55.763]                           invokeRestart("muffleWarning")
[13:36:55.763]                       }
[13:36:55.763]                       else if (inherits(cond, "condition")) {
[13:36:55.763]                         if (!is.null(pattern)) {
[13:36:55.763]                           computeRestarts <- base::computeRestarts
[13:36:55.763]                           grepl <- base::grepl
[13:36:55.763]                           restarts <- computeRestarts(cond)
[13:36:55.763]                           for (restart in restarts) {
[13:36:55.763]                             name <- restart$name
[13:36:55.763]                             if (is.null(name)) 
[13:36:55.763]                               next
[13:36:55.763]                             if (!grepl(pattern, name)) 
[13:36:55.763]                               next
[13:36:55.763]                             invokeRestart(restart)
[13:36:55.763]                             muffled <- TRUE
[13:36:55.763]                             break
[13:36:55.763]                           }
[13:36:55.763]                         }
[13:36:55.763]                       }
[13:36:55.763]                       invisible(muffled)
[13:36:55.763]                     }
[13:36:55.763]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.763]                   }
[13:36:55.763]                 }
[13:36:55.763]             }
[13:36:55.763]         }))
[13:36:55.763]     }, error = function(ex) {
[13:36:55.763]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.763]                 ...future.rng), started = ...future.startTime, 
[13:36:55.763]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.763]             version = "1.8"), class = "FutureResult")
[13:36:55.763]     }, finally = {
[13:36:55.763]         if (!identical(...future.workdir, getwd())) 
[13:36:55.763]             setwd(...future.workdir)
[13:36:55.763]         {
[13:36:55.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.763]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.763]             }
[13:36:55.763]             base::options(...future.oldOptions)
[13:36:55.763]             if (.Platform$OS.type == "windows") {
[13:36:55.763]                 old_names <- names(...future.oldEnvVars)
[13:36:55.763]                 envs <- base::Sys.getenv()
[13:36:55.763]                 names <- names(envs)
[13:36:55.763]                 common <- intersect(names, old_names)
[13:36:55.763]                 added <- setdiff(names, old_names)
[13:36:55.763]                 removed <- setdiff(old_names, names)
[13:36:55.763]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.763]                   envs[common]]
[13:36:55.763]                 NAMES <- toupper(changed)
[13:36:55.763]                 args <- list()
[13:36:55.763]                 for (kk in seq_along(NAMES)) {
[13:36:55.763]                   name <- changed[[kk]]
[13:36:55.763]                   NAME <- NAMES[[kk]]
[13:36:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.763]                     next
[13:36:55.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.763]                 }
[13:36:55.763]                 NAMES <- toupper(added)
[13:36:55.763]                 for (kk in seq_along(NAMES)) {
[13:36:55.763]                   name <- added[[kk]]
[13:36:55.763]                   NAME <- NAMES[[kk]]
[13:36:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.763]                     next
[13:36:55.763]                   args[[name]] <- ""
[13:36:55.763]                 }
[13:36:55.763]                 NAMES <- toupper(removed)
[13:36:55.763]                 for (kk in seq_along(NAMES)) {
[13:36:55.763]                   name <- removed[[kk]]
[13:36:55.763]                   NAME <- NAMES[[kk]]
[13:36:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.763]                     next
[13:36:55.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.763]                 }
[13:36:55.763]                 if (length(args) > 0) 
[13:36:55.763]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.763]             }
[13:36:55.763]             else {
[13:36:55.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.763]             }
[13:36:55.763]             {
[13:36:55.763]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.763]                   0L) {
[13:36:55.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.763]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.763]                   base::options(opts)
[13:36:55.763]                 }
[13:36:55.763]                 {
[13:36:55.763]                   {
[13:36:55.763]                     NULL
[13:36:55.763]                     RNGkind("Mersenne-Twister")
[13:36:55.763]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.763]                       inherits = FALSE)
[13:36:55.763]                   }
[13:36:55.763]                   options(future.plan = NULL)
[13:36:55.763]                   if (is.na(NA_character_)) 
[13:36:55.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.763]                     .init = FALSE)
[13:36:55.763]                 }
[13:36:55.763]             }
[13:36:55.763]         }
[13:36:55.763]     })
[13:36:55.763]     if (TRUE) {
[13:36:55.763]         base::sink(type = "output", split = FALSE)
[13:36:55.763]         if (TRUE) {
[13:36:55.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.763]         }
[13:36:55.763]         else {
[13:36:55.763]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.763]         }
[13:36:55.763]         base::close(...future.stdout)
[13:36:55.763]         ...future.stdout <- NULL
[13:36:55.763]     }
[13:36:55.763]     ...future.result$conditions <- ...future.conditions
[13:36:55.763]     ...future.result$finished <- base::Sys.time()
[13:36:55.763]     ...future.result
[13:36:55.763] }
[13:36:55.765] assign_globals() ...
[13:36:55.765] List of 1
[13:36:55.765]  $ ii: int 2
[13:36:55.765]  - attr(*, "where")=List of 1
[13:36:55.765]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:55.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.765]  - attr(*, "resolved")= logi TRUE
[13:36:55.765]  - attr(*, "total_size")= num 56
[13:36:55.765]  - attr(*, "already-done")= logi TRUE
[13:36:55.767] - copied ‘ii’ to environment
[13:36:55.768] assign_globals() ... done
[13:36:55.768] plan(): Setting new future strategy stack:
[13:36:55.768] List of future strategies:
[13:36:55.768] 1. sequential:
[13:36:55.768]    - args: function (..., envir = parent.frame())
[13:36:55.768]    - tweaked: FALSE
[13:36:55.768]    - call: NULL
[13:36:55.768] plan(): nbrOfWorkers() = 1
[13:36:55.769] plan(): Setting new future strategy stack:
[13:36:55.769] List of future strategies:
[13:36:55.769] 1. sequential:
[13:36:55.769]    - args: function (..., envir = parent.frame())
[13:36:55.769]    - tweaked: FALSE
[13:36:55.769]    - call: plan(strategy)
[13:36:55.769] plan(): nbrOfWorkers() = 1
[13:36:55.769] SequentialFuture started (and completed)
[13:36:55.770] - Launch lazy future ... done
[13:36:55.770] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.770] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.770] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.772] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.773] Searching for globals ... DONE
[13:36:55.773] Resolving globals: TRUE
[13:36:55.773] Resolving any globals that are futures ...
[13:36:55.773] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.773] Resolving any globals that are futures ... DONE
[13:36:55.773] Resolving futures part of globals (recursively) ...
[13:36:55.774] resolve() on list ...
[13:36:55.774]  recursive: 99
[13:36:55.774]  length: 1
[13:36:55.774]  elements: ‘ii’
[13:36:55.774]  length: 0 (resolved future 1)
[13:36:55.774] resolve() on list ... DONE
[13:36:55.774] - globals: [1] ‘ii’
[13:36:55.775] Resolving futures part of globals (recursively) ... DONE
[13:36:55.775] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:55.775] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:55.775] - globals: [1] ‘ii’
[13:36:55.775] 
[13:36:55.776] getGlobalsAndPackages() ... DONE
[13:36:55.776] run() for ‘Future’ ...
[13:36:55.776] - state: ‘created’
[13:36:55.776] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.777]   - Field: ‘label’
[13:36:55.777]   - Field: ‘local’
[13:36:55.777]   - Field: ‘owner’
[13:36:55.777]   - Field: ‘envir’
[13:36:55.777]   - Field: ‘packages’
[13:36:55.777]   - Field: ‘gc’
[13:36:55.777]   - Field: ‘conditions’
[13:36:55.777]   - Field: ‘expr’
[13:36:55.777]   - Field: ‘uuid’
[13:36:55.777]   - Field: ‘seed’
[13:36:55.777]   - Field: ‘version’
[13:36:55.778]   - Field: ‘result’
[13:36:55.778]   - Field: ‘asynchronous’
[13:36:55.778]   - Field: ‘calls’
[13:36:55.778]   - Field: ‘globals’
[13:36:55.778]   - Field: ‘stdout’
[13:36:55.778]   - Field: ‘earlySignal’
[13:36:55.778]   - Field: ‘lazy’
[13:36:55.778]   - Field: ‘state’
[13:36:55.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.778] - Launch lazy future ...
[13:36:55.779] Packages needed by the future expression (n = 0): <none>
[13:36:55.779] Packages needed by future strategies (n = 0): <none>
[13:36:55.779] {
[13:36:55.779]     {
[13:36:55.779]         {
[13:36:55.779]             ...future.startTime <- base::Sys.time()
[13:36:55.779]             {
[13:36:55.779]                 {
[13:36:55.779]                   {
[13:36:55.779]                     base::local({
[13:36:55.779]                       has_future <- base::requireNamespace("future", 
[13:36:55.779]                         quietly = TRUE)
[13:36:55.779]                       if (has_future) {
[13:36:55.779]                         ns <- base::getNamespace("future")
[13:36:55.779]                         version <- ns[[".package"]][["version"]]
[13:36:55.779]                         if (is.null(version)) 
[13:36:55.779]                           version <- utils::packageVersion("future")
[13:36:55.779]                       }
[13:36:55.779]                       else {
[13:36:55.779]                         version <- NULL
[13:36:55.779]                       }
[13:36:55.779]                       if (!has_future || version < "1.8.0") {
[13:36:55.779]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.779]                           "", base::R.version$version.string), 
[13:36:55.779]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.779]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.779]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.779]                             "release", "version")], collapse = " "), 
[13:36:55.779]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.779]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.779]                           info)
[13:36:55.779]                         info <- base::paste(info, collapse = "; ")
[13:36:55.779]                         if (!has_future) {
[13:36:55.779]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.779]                             info)
[13:36:55.779]                         }
[13:36:55.779]                         else {
[13:36:55.779]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.779]                             info, version)
[13:36:55.779]                         }
[13:36:55.779]                         base::stop(msg)
[13:36:55.779]                       }
[13:36:55.779]                     })
[13:36:55.779]                   }
[13:36:55.779]                   ...future.strategy.old <- future::plan("list")
[13:36:55.779]                   options(future.plan = NULL)
[13:36:55.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.779]                 }
[13:36:55.779]                 ...future.workdir <- getwd()
[13:36:55.779]             }
[13:36:55.779]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.779]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.779]         }
[13:36:55.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.779]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.779]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.779]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.779]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.779]             base::names(...future.oldOptions))
[13:36:55.779]     }
[13:36:55.779]     if (FALSE) {
[13:36:55.779]     }
[13:36:55.779]     else {
[13:36:55.779]         if (TRUE) {
[13:36:55.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.779]                 open = "w")
[13:36:55.779]         }
[13:36:55.779]         else {
[13:36:55.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.779]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.779]         }
[13:36:55.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.779]             base::sink(type = "output", split = FALSE)
[13:36:55.779]             base::close(...future.stdout)
[13:36:55.779]         }, add = TRUE)
[13:36:55.779]     }
[13:36:55.779]     ...future.frame <- base::sys.nframe()
[13:36:55.779]     ...future.conditions <- base::list()
[13:36:55.779]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.779]     if (FALSE) {
[13:36:55.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.779]     }
[13:36:55.779]     ...future.result <- base::tryCatch({
[13:36:55.779]         base::withCallingHandlers({
[13:36:55.779]             ...future.value <- base::withVisible(base::local({
[13:36:55.779]                 b <- a * ii
[13:36:55.779]                 a <- 0
[13:36:55.779]                 b
[13:36:55.779]             }))
[13:36:55.779]             future::FutureResult(value = ...future.value$value, 
[13:36:55.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.779]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.779]                     ...future.globalenv.names))
[13:36:55.779]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.779]         }, condition = base::local({
[13:36:55.779]             c <- base::c
[13:36:55.779]             inherits <- base::inherits
[13:36:55.779]             invokeRestart <- base::invokeRestart
[13:36:55.779]             length <- base::length
[13:36:55.779]             list <- base::list
[13:36:55.779]             seq.int <- base::seq.int
[13:36:55.779]             signalCondition <- base::signalCondition
[13:36:55.779]             sys.calls <- base::sys.calls
[13:36:55.779]             `[[` <- base::`[[`
[13:36:55.779]             `+` <- base::`+`
[13:36:55.779]             `<<-` <- base::`<<-`
[13:36:55.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.779]                   3L)]
[13:36:55.779]             }
[13:36:55.779]             function(cond) {
[13:36:55.779]                 is_error <- inherits(cond, "error")
[13:36:55.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.779]                   NULL)
[13:36:55.779]                 if (is_error) {
[13:36:55.779]                   sessionInformation <- function() {
[13:36:55.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.779]                       search = base::search(), system = base::Sys.info())
[13:36:55.779]                   }
[13:36:55.779]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.779]                     cond$call), session = sessionInformation(), 
[13:36:55.779]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.779]                   signalCondition(cond)
[13:36:55.779]                 }
[13:36:55.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.779]                 "immediateCondition"))) {
[13:36:55.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.779]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.779]                   if (TRUE && !signal) {
[13:36:55.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.779]                     {
[13:36:55.779]                       inherits <- base::inherits
[13:36:55.779]                       invokeRestart <- base::invokeRestart
[13:36:55.779]                       is.null <- base::is.null
[13:36:55.779]                       muffled <- FALSE
[13:36:55.779]                       if (inherits(cond, "message")) {
[13:36:55.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.779]                         if (muffled) 
[13:36:55.779]                           invokeRestart("muffleMessage")
[13:36:55.779]                       }
[13:36:55.779]                       else if (inherits(cond, "warning")) {
[13:36:55.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.779]                         if (muffled) 
[13:36:55.779]                           invokeRestart("muffleWarning")
[13:36:55.779]                       }
[13:36:55.779]                       else if (inherits(cond, "condition")) {
[13:36:55.779]                         if (!is.null(pattern)) {
[13:36:55.779]                           computeRestarts <- base::computeRestarts
[13:36:55.779]                           grepl <- base::grepl
[13:36:55.779]                           restarts <- computeRestarts(cond)
[13:36:55.779]                           for (restart in restarts) {
[13:36:55.779]                             name <- restart$name
[13:36:55.779]                             if (is.null(name)) 
[13:36:55.779]                               next
[13:36:55.779]                             if (!grepl(pattern, name)) 
[13:36:55.779]                               next
[13:36:55.779]                             invokeRestart(restart)
[13:36:55.779]                             muffled <- TRUE
[13:36:55.779]                             break
[13:36:55.779]                           }
[13:36:55.779]                         }
[13:36:55.779]                       }
[13:36:55.779]                       invisible(muffled)
[13:36:55.779]                     }
[13:36:55.779]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.779]                   }
[13:36:55.779]                 }
[13:36:55.779]                 else {
[13:36:55.779]                   if (TRUE) {
[13:36:55.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.779]                     {
[13:36:55.779]                       inherits <- base::inherits
[13:36:55.779]                       invokeRestart <- base::invokeRestart
[13:36:55.779]                       is.null <- base::is.null
[13:36:55.779]                       muffled <- FALSE
[13:36:55.779]                       if (inherits(cond, "message")) {
[13:36:55.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.779]                         if (muffled) 
[13:36:55.779]                           invokeRestart("muffleMessage")
[13:36:55.779]                       }
[13:36:55.779]                       else if (inherits(cond, "warning")) {
[13:36:55.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.779]                         if (muffled) 
[13:36:55.779]                           invokeRestart("muffleWarning")
[13:36:55.779]                       }
[13:36:55.779]                       else if (inherits(cond, "condition")) {
[13:36:55.779]                         if (!is.null(pattern)) {
[13:36:55.779]                           computeRestarts <- base::computeRestarts
[13:36:55.779]                           grepl <- base::grepl
[13:36:55.779]                           restarts <- computeRestarts(cond)
[13:36:55.779]                           for (restart in restarts) {
[13:36:55.779]                             name <- restart$name
[13:36:55.779]                             if (is.null(name)) 
[13:36:55.779]                               next
[13:36:55.779]                             if (!grepl(pattern, name)) 
[13:36:55.779]                               next
[13:36:55.779]                             invokeRestart(restart)
[13:36:55.779]                             muffled <- TRUE
[13:36:55.779]                             break
[13:36:55.779]                           }
[13:36:55.779]                         }
[13:36:55.779]                       }
[13:36:55.779]                       invisible(muffled)
[13:36:55.779]                     }
[13:36:55.779]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.779]                   }
[13:36:55.779]                 }
[13:36:55.779]             }
[13:36:55.779]         }))
[13:36:55.779]     }, error = function(ex) {
[13:36:55.779]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.779]                 ...future.rng), started = ...future.startTime, 
[13:36:55.779]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.779]             version = "1.8"), class = "FutureResult")
[13:36:55.779]     }, finally = {
[13:36:55.779]         if (!identical(...future.workdir, getwd())) 
[13:36:55.779]             setwd(...future.workdir)
[13:36:55.779]         {
[13:36:55.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.779]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.779]             }
[13:36:55.779]             base::options(...future.oldOptions)
[13:36:55.779]             if (.Platform$OS.type == "windows") {
[13:36:55.779]                 old_names <- names(...future.oldEnvVars)
[13:36:55.779]                 envs <- base::Sys.getenv()
[13:36:55.779]                 names <- names(envs)
[13:36:55.779]                 common <- intersect(names, old_names)
[13:36:55.779]                 added <- setdiff(names, old_names)
[13:36:55.779]                 removed <- setdiff(old_names, names)
[13:36:55.779]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.779]                   envs[common]]
[13:36:55.779]                 NAMES <- toupper(changed)
[13:36:55.779]                 args <- list()
[13:36:55.779]                 for (kk in seq_along(NAMES)) {
[13:36:55.779]                   name <- changed[[kk]]
[13:36:55.779]                   NAME <- NAMES[[kk]]
[13:36:55.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.779]                     next
[13:36:55.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.779]                 }
[13:36:55.779]                 NAMES <- toupper(added)
[13:36:55.779]                 for (kk in seq_along(NAMES)) {
[13:36:55.779]                   name <- added[[kk]]
[13:36:55.779]                   NAME <- NAMES[[kk]]
[13:36:55.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.779]                     next
[13:36:55.779]                   args[[name]] <- ""
[13:36:55.779]                 }
[13:36:55.779]                 NAMES <- toupper(removed)
[13:36:55.779]                 for (kk in seq_along(NAMES)) {
[13:36:55.779]                   name <- removed[[kk]]
[13:36:55.779]                   NAME <- NAMES[[kk]]
[13:36:55.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.779]                     next
[13:36:55.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.779]                 }
[13:36:55.779]                 if (length(args) > 0) 
[13:36:55.779]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.779]             }
[13:36:55.779]             else {
[13:36:55.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.779]             }
[13:36:55.779]             {
[13:36:55.779]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.779]                   0L) {
[13:36:55.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.779]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.779]                   base::options(opts)
[13:36:55.779]                 }
[13:36:55.779]                 {
[13:36:55.779]                   {
[13:36:55.779]                     NULL
[13:36:55.779]                     RNGkind("Mersenne-Twister")
[13:36:55.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.779]                       inherits = FALSE)
[13:36:55.779]                   }
[13:36:55.779]                   options(future.plan = NULL)
[13:36:55.779]                   if (is.na(NA_character_)) 
[13:36:55.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.779]                     .init = FALSE)
[13:36:55.779]                 }
[13:36:55.779]             }
[13:36:55.779]         }
[13:36:55.779]     })
[13:36:55.779]     if (TRUE) {
[13:36:55.779]         base::sink(type = "output", split = FALSE)
[13:36:55.779]         if (TRUE) {
[13:36:55.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.779]         }
[13:36:55.779]         else {
[13:36:55.779]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.779]         }
[13:36:55.779]         base::close(...future.stdout)
[13:36:55.779]         ...future.stdout <- NULL
[13:36:55.779]     }
[13:36:55.779]     ...future.result$conditions <- ...future.conditions
[13:36:55.779]     ...future.result$finished <- base::Sys.time()
[13:36:55.779]     ...future.result
[13:36:55.779] }
[13:36:55.781] assign_globals() ...
[13:36:55.781] List of 1
[13:36:55.781]  $ ii: int 3
[13:36:55.781]  - attr(*, "where")=List of 1
[13:36:55.781]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:55.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.781]  - attr(*, "resolved")= logi TRUE
[13:36:55.781]  - attr(*, "total_size")= num 56
[13:36:55.781]  - attr(*, "already-done")= logi TRUE
[13:36:55.783] - copied ‘ii’ to environment
[13:36:55.783] assign_globals() ... done
[13:36:55.783] plan(): Setting new future strategy stack:
[13:36:55.783] List of future strategies:
[13:36:55.783] 1. sequential:
[13:36:55.783]    - args: function (..., envir = parent.frame())
[13:36:55.783]    - tweaked: FALSE
[13:36:55.783]    - call: NULL
[13:36:55.784] plan(): nbrOfWorkers() = 1
[13:36:55.784] plan(): Setting new future strategy stack:
[13:36:55.784] List of future strategies:
[13:36:55.784] 1. sequential:
[13:36:55.784]    - args: function (..., envir = parent.frame())
[13:36:55.784]    - tweaked: FALSE
[13:36:55.784]    - call: plan(strategy)
[13:36:55.785] plan(): nbrOfWorkers() = 1
[13:36:55.785] SequentialFuture started (and completed)
[13:36:55.785] - Launch lazy future ... done
[13:36:55.785] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.786] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.786] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.787] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.788] Searching for globals ... DONE
[13:36:55.788] Resolving globals: TRUE
[13:36:55.788] Resolving any globals that are futures ...
[13:36:55.788] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.788] Resolving any globals that are futures ... DONE
[13:36:55.788] Resolving futures part of globals (recursively) ...
[13:36:55.788] resolve() on list ...
[13:36:55.789]  recursive: 99
[13:36:55.789]  length: 1
[13:36:55.789]  elements: ‘ii’
[13:36:55.789]  length: 0 (resolved future 1)
[13:36:55.789] resolve() on list ... DONE
[13:36:55.789] - globals: [1] ‘ii’
[13:36:55.789] Resolving futures part of globals (recursively) ... DONE
[13:36:55.789] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:55.789] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:55.790] - globals: [1] ‘ii’
[13:36:55.790] 
[13:36:55.790] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.790] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.791] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.792] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.792] Searching for globals ... DONE
[13:36:55.792] Resolving globals: TRUE
[13:36:55.792] Resolving any globals that are futures ...
[13:36:55.792] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.792] Resolving any globals that are futures ... DONE
[13:36:55.792] Resolving futures part of globals (recursively) ...
[13:36:55.793] resolve() on list ...
[13:36:55.793]  recursive: 99
[13:36:55.793]  length: 1
[13:36:55.793]  elements: ‘ii’
[13:36:55.793]  length: 0 (resolved future 1)
[13:36:55.793] resolve() on list ... DONE
[13:36:55.793] - globals: [1] ‘ii’
[13:36:55.793] Resolving futures part of globals (recursively) ... DONE
[13:36:55.793] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:55.794] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:55.794] - globals: [1] ‘ii’
[13:36:55.794] 
[13:36:55.794] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.795] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.795] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.797] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.797] Searching for globals ... DONE
[13:36:55.797] Resolving globals: TRUE
[13:36:55.797] Resolving any globals that are futures ...
[13:36:55.797] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:55.797] Resolving any globals that are futures ... DONE
[13:36:55.798] Resolving futures part of globals (recursively) ...
[13:36:55.798] resolve() on list ...
[13:36:55.798]  recursive: 99
[13:36:55.798]  length: 1
[13:36:55.798]  elements: ‘ii’
[13:36:55.798]  length: 0 (resolved future 1)
[13:36:55.798] resolve() on list ... DONE
[13:36:55.799] - globals: [1] ‘ii’
[13:36:55.799] Resolving futures part of globals (recursively) ... DONE
[13:36:55.799] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:55.799] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:55.799] - globals: [1] ‘ii’
[13:36:55.799] 
[13:36:55.799] getGlobalsAndPackages() ... DONE
[13:36:55.800] run() for ‘Future’ ...
[13:36:55.800] - state: ‘created’
[13:36:55.800] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.800] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.800]   - Field: ‘label’
[13:36:55.800]   - Field: ‘local’
[13:36:55.800]   - Field: ‘owner’
[13:36:55.801]   - Field: ‘envir’
[13:36:55.801]   - Field: ‘packages’
[13:36:55.801]   - Field: ‘gc’
[13:36:55.801]   - Field: ‘conditions’
[13:36:55.801]   - Field: ‘expr’
[13:36:55.801]   - Field: ‘uuid’
[13:36:55.801]   - Field: ‘seed’
[13:36:55.801]   - Field: ‘version’
[13:36:55.801]   - Field: ‘result’
[13:36:55.801]   - Field: ‘asynchronous’
[13:36:55.801]   - Field: ‘calls’
[13:36:55.802]   - Field: ‘globals’
[13:36:55.802]   - Field: ‘stdout’
[13:36:55.802]   - Field: ‘earlySignal’
[13:36:55.802]   - Field: ‘lazy’
[13:36:55.802]   - Field: ‘state’
[13:36:55.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.802] - Launch lazy future ...
[13:36:55.802] Packages needed by the future expression (n = 0): <none>
[13:36:55.802] Packages needed by future strategies (n = 0): <none>
[13:36:55.803] {
[13:36:55.803]     {
[13:36:55.803]         {
[13:36:55.803]             ...future.startTime <- base::Sys.time()
[13:36:55.803]             {
[13:36:55.803]                 {
[13:36:55.803]                   {
[13:36:55.803]                     base::local({
[13:36:55.803]                       has_future <- base::requireNamespace("future", 
[13:36:55.803]                         quietly = TRUE)
[13:36:55.803]                       if (has_future) {
[13:36:55.803]                         ns <- base::getNamespace("future")
[13:36:55.803]                         version <- ns[[".package"]][["version"]]
[13:36:55.803]                         if (is.null(version)) 
[13:36:55.803]                           version <- utils::packageVersion("future")
[13:36:55.803]                       }
[13:36:55.803]                       else {
[13:36:55.803]                         version <- NULL
[13:36:55.803]                       }
[13:36:55.803]                       if (!has_future || version < "1.8.0") {
[13:36:55.803]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.803]                           "", base::R.version$version.string), 
[13:36:55.803]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.803]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.803]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.803]                             "release", "version")], collapse = " "), 
[13:36:55.803]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.803]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.803]                           info)
[13:36:55.803]                         info <- base::paste(info, collapse = "; ")
[13:36:55.803]                         if (!has_future) {
[13:36:55.803]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.803]                             info)
[13:36:55.803]                         }
[13:36:55.803]                         else {
[13:36:55.803]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.803]                             info, version)
[13:36:55.803]                         }
[13:36:55.803]                         base::stop(msg)
[13:36:55.803]                       }
[13:36:55.803]                     })
[13:36:55.803]                   }
[13:36:55.803]                   ...future.strategy.old <- future::plan("list")
[13:36:55.803]                   options(future.plan = NULL)
[13:36:55.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.803]                 }
[13:36:55.803]                 ...future.workdir <- getwd()
[13:36:55.803]             }
[13:36:55.803]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.803]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.803]         }
[13:36:55.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.803]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.803]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.803]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.803]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.803]             base::names(...future.oldOptions))
[13:36:55.803]     }
[13:36:55.803]     if (FALSE) {
[13:36:55.803]     }
[13:36:55.803]     else {
[13:36:55.803]         if (TRUE) {
[13:36:55.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.803]                 open = "w")
[13:36:55.803]         }
[13:36:55.803]         else {
[13:36:55.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.803]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.803]         }
[13:36:55.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.803]             base::sink(type = "output", split = FALSE)
[13:36:55.803]             base::close(...future.stdout)
[13:36:55.803]         }, add = TRUE)
[13:36:55.803]     }
[13:36:55.803]     ...future.frame <- base::sys.nframe()
[13:36:55.803]     ...future.conditions <- base::list()
[13:36:55.803]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.803]     if (FALSE) {
[13:36:55.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.803]     }
[13:36:55.803]     ...future.result <- base::tryCatch({
[13:36:55.803]         base::withCallingHandlers({
[13:36:55.803]             ...future.value <- base::withVisible(base::local({
[13:36:55.803]                 b <- a * ii
[13:36:55.803]                 a <- 0
[13:36:55.803]                 b
[13:36:55.803]             }))
[13:36:55.803]             future::FutureResult(value = ...future.value$value, 
[13:36:55.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.803]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.803]                     ...future.globalenv.names))
[13:36:55.803]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.803]         }, condition = base::local({
[13:36:55.803]             c <- base::c
[13:36:55.803]             inherits <- base::inherits
[13:36:55.803]             invokeRestart <- base::invokeRestart
[13:36:55.803]             length <- base::length
[13:36:55.803]             list <- base::list
[13:36:55.803]             seq.int <- base::seq.int
[13:36:55.803]             signalCondition <- base::signalCondition
[13:36:55.803]             sys.calls <- base::sys.calls
[13:36:55.803]             `[[` <- base::`[[`
[13:36:55.803]             `+` <- base::`+`
[13:36:55.803]             `<<-` <- base::`<<-`
[13:36:55.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.803]                   3L)]
[13:36:55.803]             }
[13:36:55.803]             function(cond) {
[13:36:55.803]                 is_error <- inherits(cond, "error")
[13:36:55.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.803]                   NULL)
[13:36:55.803]                 if (is_error) {
[13:36:55.803]                   sessionInformation <- function() {
[13:36:55.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.803]                       search = base::search(), system = base::Sys.info())
[13:36:55.803]                   }
[13:36:55.803]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.803]                     cond$call), session = sessionInformation(), 
[13:36:55.803]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.803]                   signalCondition(cond)
[13:36:55.803]                 }
[13:36:55.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.803]                 "immediateCondition"))) {
[13:36:55.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.803]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.803]                   if (TRUE && !signal) {
[13:36:55.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.803]                     {
[13:36:55.803]                       inherits <- base::inherits
[13:36:55.803]                       invokeRestart <- base::invokeRestart
[13:36:55.803]                       is.null <- base::is.null
[13:36:55.803]                       muffled <- FALSE
[13:36:55.803]                       if (inherits(cond, "message")) {
[13:36:55.803]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.803]                         if (muffled) 
[13:36:55.803]                           invokeRestart("muffleMessage")
[13:36:55.803]                       }
[13:36:55.803]                       else if (inherits(cond, "warning")) {
[13:36:55.803]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.803]                         if (muffled) 
[13:36:55.803]                           invokeRestart("muffleWarning")
[13:36:55.803]                       }
[13:36:55.803]                       else if (inherits(cond, "condition")) {
[13:36:55.803]                         if (!is.null(pattern)) {
[13:36:55.803]                           computeRestarts <- base::computeRestarts
[13:36:55.803]                           grepl <- base::grepl
[13:36:55.803]                           restarts <- computeRestarts(cond)
[13:36:55.803]                           for (restart in restarts) {
[13:36:55.803]                             name <- restart$name
[13:36:55.803]                             if (is.null(name)) 
[13:36:55.803]                               next
[13:36:55.803]                             if (!grepl(pattern, name)) 
[13:36:55.803]                               next
[13:36:55.803]                             invokeRestart(restart)
[13:36:55.803]                             muffled <- TRUE
[13:36:55.803]                             break
[13:36:55.803]                           }
[13:36:55.803]                         }
[13:36:55.803]                       }
[13:36:55.803]                       invisible(muffled)
[13:36:55.803]                     }
[13:36:55.803]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.803]                   }
[13:36:55.803]                 }
[13:36:55.803]                 else {
[13:36:55.803]                   if (TRUE) {
[13:36:55.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.803]                     {
[13:36:55.803]                       inherits <- base::inherits
[13:36:55.803]                       invokeRestart <- base::invokeRestart
[13:36:55.803]                       is.null <- base::is.null
[13:36:55.803]                       muffled <- FALSE
[13:36:55.803]                       if (inherits(cond, "message")) {
[13:36:55.803]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.803]                         if (muffled) 
[13:36:55.803]                           invokeRestart("muffleMessage")
[13:36:55.803]                       }
[13:36:55.803]                       else if (inherits(cond, "warning")) {
[13:36:55.803]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.803]                         if (muffled) 
[13:36:55.803]                           invokeRestart("muffleWarning")
[13:36:55.803]                       }
[13:36:55.803]                       else if (inherits(cond, "condition")) {
[13:36:55.803]                         if (!is.null(pattern)) {
[13:36:55.803]                           computeRestarts <- base::computeRestarts
[13:36:55.803]                           grepl <- base::grepl
[13:36:55.803]                           restarts <- computeRestarts(cond)
[13:36:55.803]                           for (restart in restarts) {
[13:36:55.803]                             name <- restart$name
[13:36:55.803]                             if (is.null(name)) 
[13:36:55.803]                               next
[13:36:55.803]                             if (!grepl(pattern, name)) 
[13:36:55.803]                               next
[13:36:55.803]                             invokeRestart(restart)
[13:36:55.803]                             muffled <- TRUE
[13:36:55.803]                             break
[13:36:55.803]                           }
[13:36:55.803]                         }
[13:36:55.803]                       }
[13:36:55.803]                       invisible(muffled)
[13:36:55.803]                     }
[13:36:55.803]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.803]                   }
[13:36:55.803]                 }
[13:36:55.803]             }
[13:36:55.803]         }))
[13:36:55.803]     }, error = function(ex) {
[13:36:55.803]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.803]                 ...future.rng), started = ...future.startTime, 
[13:36:55.803]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.803]             version = "1.8"), class = "FutureResult")
[13:36:55.803]     }, finally = {
[13:36:55.803]         if (!identical(...future.workdir, getwd())) 
[13:36:55.803]             setwd(...future.workdir)
[13:36:55.803]         {
[13:36:55.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.803]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.803]             }
[13:36:55.803]             base::options(...future.oldOptions)
[13:36:55.803]             if (.Platform$OS.type == "windows") {
[13:36:55.803]                 old_names <- names(...future.oldEnvVars)
[13:36:55.803]                 envs <- base::Sys.getenv()
[13:36:55.803]                 names <- names(envs)
[13:36:55.803]                 common <- intersect(names, old_names)
[13:36:55.803]                 added <- setdiff(names, old_names)
[13:36:55.803]                 removed <- setdiff(old_names, names)
[13:36:55.803]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.803]                   envs[common]]
[13:36:55.803]                 NAMES <- toupper(changed)
[13:36:55.803]                 args <- list()
[13:36:55.803]                 for (kk in seq_along(NAMES)) {
[13:36:55.803]                   name <- changed[[kk]]
[13:36:55.803]                   NAME <- NAMES[[kk]]
[13:36:55.803]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.803]                     next
[13:36:55.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.803]                 }
[13:36:55.803]                 NAMES <- toupper(added)
[13:36:55.803]                 for (kk in seq_along(NAMES)) {
[13:36:55.803]                   name <- added[[kk]]
[13:36:55.803]                   NAME <- NAMES[[kk]]
[13:36:55.803]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.803]                     next
[13:36:55.803]                   args[[name]] <- ""
[13:36:55.803]                 }
[13:36:55.803]                 NAMES <- toupper(removed)
[13:36:55.803]                 for (kk in seq_along(NAMES)) {
[13:36:55.803]                   name <- removed[[kk]]
[13:36:55.803]                   NAME <- NAMES[[kk]]
[13:36:55.803]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.803]                     next
[13:36:55.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.803]                 }
[13:36:55.803]                 if (length(args) > 0) 
[13:36:55.803]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.803]             }
[13:36:55.803]             else {
[13:36:55.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.803]             }
[13:36:55.803]             {
[13:36:55.803]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.803]                   0L) {
[13:36:55.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.803]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.803]                   base::options(opts)
[13:36:55.803]                 }
[13:36:55.803]                 {
[13:36:55.803]                   {
[13:36:55.803]                     NULL
[13:36:55.803]                     RNGkind("Mersenne-Twister")
[13:36:55.803]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.803]                       inherits = FALSE)
[13:36:55.803]                   }
[13:36:55.803]                   options(future.plan = NULL)
[13:36:55.803]                   if (is.na(NA_character_)) 
[13:36:55.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.803]                     .init = FALSE)
[13:36:55.803]                 }
[13:36:55.803]             }
[13:36:55.803]         }
[13:36:55.803]     })
[13:36:55.803]     if (TRUE) {
[13:36:55.803]         base::sink(type = "output", split = FALSE)
[13:36:55.803]         if (TRUE) {
[13:36:55.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.803]         }
[13:36:55.803]         else {
[13:36:55.803]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.803]         }
[13:36:55.803]         base::close(...future.stdout)
[13:36:55.803]         ...future.stdout <- NULL
[13:36:55.803]     }
[13:36:55.803]     ...future.result$conditions <- ...future.conditions
[13:36:55.803]     ...future.result$finished <- base::Sys.time()
[13:36:55.803]     ...future.result
[13:36:55.803] }
[13:36:55.804] assign_globals() ...
[13:36:55.804] List of 1
[13:36:55.804]  $ ii: int 1
[13:36:55.804]  - attr(*, "where")=List of 1
[13:36:55.804]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:55.804]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.804]  - attr(*, "resolved")= logi TRUE
[13:36:55.804]  - attr(*, "total_size")= num 56
[13:36:55.804]  - attr(*, "already-done")= logi TRUE
[13:36:55.807] - copied ‘ii’ to environment
[13:36:55.807] assign_globals() ... done
[13:36:55.807] plan(): Setting new future strategy stack:
[13:36:55.807] List of future strategies:
[13:36:55.807] 1. sequential:
[13:36:55.807]    - args: function (..., envir = parent.frame())
[13:36:55.807]    - tweaked: FALSE
[13:36:55.807]    - call: NULL
[13:36:55.807] plan(): nbrOfWorkers() = 1
[13:36:55.808] plan(): Setting new future strategy stack:
[13:36:55.808] List of future strategies:
[13:36:55.808] 1. sequential:
[13:36:55.808]    - args: function (..., envir = parent.frame())
[13:36:55.808]    - tweaked: FALSE
[13:36:55.808]    - call: plan(strategy)
[13:36:55.809] plan(): nbrOfWorkers() = 1
[13:36:55.809] SequentialFuture started (and completed)
[13:36:55.809] signalConditions() ...
[13:36:55.809]  - include = ‘immediateCondition’
[13:36:55.809]  - exclude = 
[13:36:55.809]  - resignal = FALSE
[13:36:55.809]  - Number of conditions: 1
[13:36:55.809] signalConditions() ... done
[13:36:55.809] - Launch lazy future ... done
[13:36:55.809] run() for ‘SequentialFuture’ ... done
[13:36:55.810] signalConditions() ...
[13:36:55.810]  - include = ‘immediateCondition’
[13:36:55.810]  - exclude = 
[13:36:55.810]  - resignal = FALSE
[13:36:55.810]  - Number of conditions: 1
[13:36:55.810] signalConditions() ... done
[13:36:55.810] Future state: ‘finished’
[13:36:55.810] signalConditions() ...
[13:36:55.810]  - include = ‘condition’
[13:36:55.810]  - exclude = ‘immediateCondition’
[13:36:55.811]  - resignal = TRUE
[13:36:55.811]  - Number of conditions: 1
[13:36:55.811]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:55.811] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "57e9b94e809f" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:36:55"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.824] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.825] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.825] 
[13:36:55.825] Searching for globals ... DONE
[13:36:55.825] - globals: [0] <none>
[13:36:55.825] getGlobalsAndPackages() ... DONE
[13:36:55.826] run() for ‘Future’ ...
[13:36:55.826] - state: ‘created’
[13:36:55.826] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.826] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.826]   - Field: ‘label’
[13:36:55.826]   - Field: ‘local’
[13:36:55.826]   - Field: ‘owner’
[13:36:55.827]   - Field: ‘envir’
[13:36:55.827]   - Field: ‘packages’
[13:36:55.827]   - Field: ‘gc’
[13:36:55.827]   - Field: ‘conditions’
[13:36:55.827]   - Field: ‘expr’
[13:36:55.827]   - Field: ‘uuid’
[13:36:55.827]   - Field: ‘seed’
[13:36:55.827]   - Field: ‘version’
[13:36:55.827]   - Field: ‘result’
[13:36:55.827]   - Field: ‘asynchronous’
[13:36:55.827]   - Field: ‘calls’
[13:36:55.827]   - Field: ‘globals’
[13:36:55.828]   - Field: ‘stdout’
[13:36:55.828]   - Field: ‘earlySignal’
[13:36:55.828]   - Field: ‘lazy’
[13:36:55.828]   - Field: ‘state’
[13:36:55.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.828] - Launch lazy future ...
[13:36:55.828] Packages needed by the future expression (n = 0): <none>
[13:36:55.828] Packages needed by future strategies (n = 0): <none>
[13:36:55.829] {
[13:36:55.829]     {
[13:36:55.829]         {
[13:36:55.829]             ...future.startTime <- base::Sys.time()
[13:36:55.829]             {
[13:36:55.829]                 {
[13:36:55.829]                   {
[13:36:55.829]                     base::local({
[13:36:55.829]                       has_future <- base::requireNamespace("future", 
[13:36:55.829]                         quietly = TRUE)
[13:36:55.829]                       if (has_future) {
[13:36:55.829]                         ns <- base::getNamespace("future")
[13:36:55.829]                         version <- ns[[".package"]][["version"]]
[13:36:55.829]                         if (is.null(version)) 
[13:36:55.829]                           version <- utils::packageVersion("future")
[13:36:55.829]                       }
[13:36:55.829]                       else {
[13:36:55.829]                         version <- NULL
[13:36:55.829]                       }
[13:36:55.829]                       if (!has_future || version < "1.8.0") {
[13:36:55.829]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.829]                           "", base::R.version$version.string), 
[13:36:55.829]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.829]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.829]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.829]                             "release", "version")], collapse = " "), 
[13:36:55.829]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.829]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.829]                           info)
[13:36:55.829]                         info <- base::paste(info, collapse = "; ")
[13:36:55.829]                         if (!has_future) {
[13:36:55.829]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.829]                             info)
[13:36:55.829]                         }
[13:36:55.829]                         else {
[13:36:55.829]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.829]                             info, version)
[13:36:55.829]                         }
[13:36:55.829]                         base::stop(msg)
[13:36:55.829]                       }
[13:36:55.829]                     })
[13:36:55.829]                   }
[13:36:55.829]                   ...future.strategy.old <- future::plan("list")
[13:36:55.829]                   options(future.plan = NULL)
[13:36:55.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.829]                 }
[13:36:55.829]                 ...future.workdir <- getwd()
[13:36:55.829]             }
[13:36:55.829]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.829]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.829]         }
[13:36:55.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.829]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.829]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.829]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.829]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.829]             base::names(...future.oldOptions))
[13:36:55.829]     }
[13:36:55.829]     if (FALSE) {
[13:36:55.829]     }
[13:36:55.829]     else {
[13:36:55.829]         if (TRUE) {
[13:36:55.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.829]                 open = "w")
[13:36:55.829]         }
[13:36:55.829]         else {
[13:36:55.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.829]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.829]         }
[13:36:55.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.829]             base::sink(type = "output", split = FALSE)
[13:36:55.829]             base::close(...future.stdout)
[13:36:55.829]         }, add = TRUE)
[13:36:55.829]     }
[13:36:55.829]     ...future.frame <- base::sys.nframe()
[13:36:55.829]     ...future.conditions <- base::list()
[13:36:55.829]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.829]     if (FALSE) {
[13:36:55.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.829]     }
[13:36:55.829]     ...future.result <- base::tryCatch({
[13:36:55.829]         base::withCallingHandlers({
[13:36:55.829]             ...future.value <- base::withVisible(base::local(1))
[13:36:55.829]             future::FutureResult(value = ...future.value$value, 
[13:36:55.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.829]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.829]                     ...future.globalenv.names))
[13:36:55.829]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.829]         }, condition = base::local({
[13:36:55.829]             c <- base::c
[13:36:55.829]             inherits <- base::inherits
[13:36:55.829]             invokeRestart <- base::invokeRestart
[13:36:55.829]             length <- base::length
[13:36:55.829]             list <- base::list
[13:36:55.829]             seq.int <- base::seq.int
[13:36:55.829]             signalCondition <- base::signalCondition
[13:36:55.829]             sys.calls <- base::sys.calls
[13:36:55.829]             `[[` <- base::`[[`
[13:36:55.829]             `+` <- base::`+`
[13:36:55.829]             `<<-` <- base::`<<-`
[13:36:55.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.829]                   3L)]
[13:36:55.829]             }
[13:36:55.829]             function(cond) {
[13:36:55.829]                 is_error <- inherits(cond, "error")
[13:36:55.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.829]                   NULL)
[13:36:55.829]                 if (is_error) {
[13:36:55.829]                   sessionInformation <- function() {
[13:36:55.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.829]                       search = base::search(), system = base::Sys.info())
[13:36:55.829]                   }
[13:36:55.829]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.829]                     cond$call), session = sessionInformation(), 
[13:36:55.829]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.829]                   signalCondition(cond)
[13:36:55.829]                 }
[13:36:55.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.829]                 "immediateCondition"))) {
[13:36:55.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.829]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.829]                   if (TRUE && !signal) {
[13:36:55.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.829]                     {
[13:36:55.829]                       inherits <- base::inherits
[13:36:55.829]                       invokeRestart <- base::invokeRestart
[13:36:55.829]                       is.null <- base::is.null
[13:36:55.829]                       muffled <- FALSE
[13:36:55.829]                       if (inherits(cond, "message")) {
[13:36:55.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.829]                         if (muffled) 
[13:36:55.829]                           invokeRestart("muffleMessage")
[13:36:55.829]                       }
[13:36:55.829]                       else if (inherits(cond, "warning")) {
[13:36:55.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.829]                         if (muffled) 
[13:36:55.829]                           invokeRestart("muffleWarning")
[13:36:55.829]                       }
[13:36:55.829]                       else if (inherits(cond, "condition")) {
[13:36:55.829]                         if (!is.null(pattern)) {
[13:36:55.829]                           computeRestarts <- base::computeRestarts
[13:36:55.829]                           grepl <- base::grepl
[13:36:55.829]                           restarts <- computeRestarts(cond)
[13:36:55.829]                           for (restart in restarts) {
[13:36:55.829]                             name <- restart$name
[13:36:55.829]                             if (is.null(name)) 
[13:36:55.829]                               next
[13:36:55.829]                             if (!grepl(pattern, name)) 
[13:36:55.829]                               next
[13:36:55.829]                             invokeRestart(restart)
[13:36:55.829]                             muffled <- TRUE
[13:36:55.829]                             break
[13:36:55.829]                           }
[13:36:55.829]                         }
[13:36:55.829]                       }
[13:36:55.829]                       invisible(muffled)
[13:36:55.829]                     }
[13:36:55.829]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.829]                   }
[13:36:55.829]                 }
[13:36:55.829]                 else {
[13:36:55.829]                   if (TRUE) {
[13:36:55.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.829]                     {
[13:36:55.829]                       inherits <- base::inherits
[13:36:55.829]                       invokeRestart <- base::invokeRestart
[13:36:55.829]                       is.null <- base::is.null
[13:36:55.829]                       muffled <- FALSE
[13:36:55.829]                       if (inherits(cond, "message")) {
[13:36:55.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.829]                         if (muffled) 
[13:36:55.829]                           invokeRestart("muffleMessage")
[13:36:55.829]                       }
[13:36:55.829]                       else if (inherits(cond, "warning")) {
[13:36:55.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.829]                         if (muffled) 
[13:36:55.829]                           invokeRestart("muffleWarning")
[13:36:55.829]                       }
[13:36:55.829]                       else if (inherits(cond, "condition")) {
[13:36:55.829]                         if (!is.null(pattern)) {
[13:36:55.829]                           computeRestarts <- base::computeRestarts
[13:36:55.829]                           grepl <- base::grepl
[13:36:55.829]                           restarts <- computeRestarts(cond)
[13:36:55.829]                           for (restart in restarts) {
[13:36:55.829]                             name <- restart$name
[13:36:55.829]                             if (is.null(name)) 
[13:36:55.829]                               next
[13:36:55.829]                             if (!grepl(pattern, name)) 
[13:36:55.829]                               next
[13:36:55.829]                             invokeRestart(restart)
[13:36:55.829]                             muffled <- TRUE
[13:36:55.829]                             break
[13:36:55.829]                           }
[13:36:55.829]                         }
[13:36:55.829]                       }
[13:36:55.829]                       invisible(muffled)
[13:36:55.829]                     }
[13:36:55.829]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.829]                   }
[13:36:55.829]                 }
[13:36:55.829]             }
[13:36:55.829]         }))
[13:36:55.829]     }, error = function(ex) {
[13:36:55.829]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.829]                 ...future.rng), started = ...future.startTime, 
[13:36:55.829]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.829]             version = "1.8"), class = "FutureResult")
[13:36:55.829]     }, finally = {
[13:36:55.829]         if (!identical(...future.workdir, getwd())) 
[13:36:55.829]             setwd(...future.workdir)
[13:36:55.829]         {
[13:36:55.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.829]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.829]             }
[13:36:55.829]             base::options(...future.oldOptions)
[13:36:55.829]             if (.Platform$OS.type == "windows") {
[13:36:55.829]                 old_names <- names(...future.oldEnvVars)
[13:36:55.829]                 envs <- base::Sys.getenv()
[13:36:55.829]                 names <- names(envs)
[13:36:55.829]                 common <- intersect(names, old_names)
[13:36:55.829]                 added <- setdiff(names, old_names)
[13:36:55.829]                 removed <- setdiff(old_names, names)
[13:36:55.829]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.829]                   envs[common]]
[13:36:55.829]                 NAMES <- toupper(changed)
[13:36:55.829]                 args <- list()
[13:36:55.829]                 for (kk in seq_along(NAMES)) {
[13:36:55.829]                   name <- changed[[kk]]
[13:36:55.829]                   NAME <- NAMES[[kk]]
[13:36:55.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.829]                     next
[13:36:55.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.829]                 }
[13:36:55.829]                 NAMES <- toupper(added)
[13:36:55.829]                 for (kk in seq_along(NAMES)) {
[13:36:55.829]                   name <- added[[kk]]
[13:36:55.829]                   NAME <- NAMES[[kk]]
[13:36:55.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.829]                     next
[13:36:55.829]                   args[[name]] <- ""
[13:36:55.829]                 }
[13:36:55.829]                 NAMES <- toupper(removed)
[13:36:55.829]                 for (kk in seq_along(NAMES)) {
[13:36:55.829]                   name <- removed[[kk]]
[13:36:55.829]                   NAME <- NAMES[[kk]]
[13:36:55.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.829]                     next
[13:36:55.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.829]                 }
[13:36:55.829]                 if (length(args) > 0) 
[13:36:55.829]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.829]             }
[13:36:55.829]             else {
[13:36:55.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.829]             }
[13:36:55.829]             {
[13:36:55.829]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.829]                   0L) {
[13:36:55.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.829]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.829]                   base::options(opts)
[13:36:55.829]                 }
[13:36:55.829]                 {
[13:36:55.829]                   {
[13:36:55.829]                     NULL
[13:36:55.829]                     RNGkind("Mersenne-Twister")
[13:36:55.829]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.829]                       inherits = FALSE)
[13:36:55.829]                   }
[13:36:55.829]                   options(future.plan = NULL)
[13:36:55.829]                   if (is.na(NA_character_)) 
[13:36:55.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.829]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.829]                     .init = FALSE)
[13:36:55.829]                 }
[13:36:55.829]             }
[13:36:55.829]         }
[13:36:55.829]     })
[13:36:55.829]     if (TRUE) {
[13:36:55.829]         base::sink(type = "output", split = FALSE)
[13:36:55.829]         if (TRUE) {
[13:36:55.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.829]         }
[13:36:55.829]         else {
[13:36:55.829]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.829]         }
[13:36:55.829]         base::close(...future.stdout)
[13:36:55.829]         ...future.stdout <- NULL
[13:36:55.829]     }
[13:36:55.829]     ...future.result$conditions <- ...future.conditions
[13:36:55.829]     ...future.result$finished <- base::Sys.time()
[13:36:55.829]     ...future.result
[13:36:55.829] }
[13:36:55.830] plan(): Setting new future strategy stack:
[13:36:55.830] List of future strategies:
[13:36:55.830] 1. sequential:
[13:36:55.830]    - args: function (..., envir = parent.frame())
[13:36:55.830]    - tweaked: FALSE
[13:36:55.830]    - call: NULL
[13:36:55.831] plan(): nbrOfWorkers() = 1
[13:36:55.831] plan(): Setting new future strategy stack:
[13:36:55.831] List of future strategies:
[13:36:55.831] 1. sequential:
[13:36:55.831]    - args: function (..., envir = parent.frame())
[13:36:55.831]    - tweaked: FALSE
[13:36:55.831]    - call: plan(strategy)
[13:36:55.832] plan(): nbrOfWorkers() = 1
[13:36:55.832] SequentialFuture started (and completed)
[13:36:55.832] - Launch lazy future ... done
[13:36:55.832] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.832] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.832] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.833] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:55.833] Searching for globals ... DONE
[13:36:55.834] Resolving globals: TRUE
[13:36:55.834] Resolving any globals that are futures ...
[13:36:55.834] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:55.834] Resolving any globals that are futures ... DONE
[13:36:55.834] Resolving futures part of globals (recursively) ...
[13:36:55.834] resolve() on list ...
[13:36:55.834]  recursive: 99
[13:36:55.834]  length: 1
[13:36:55.835]  elements: ‘a’
[13:36:55.835] resolved() for ‘SequentialFuture’ ...
[13:36:55.835] - state: ‘finished’
[13:36:55.835] - run: TRUE
[13:36:55.835] - result: ‘FutureResult’
[13:36:55.835] resolved() for ‘SequentialFuture’ ... done
[13:36:55.835] Future #1
[13:36:55.836] resolved() for ‘SequentialFuture’ ...
[13:36:55.836] - state: ‘finished’
[13:36:55.836] - run: TRUE
[13:36:55.836] - result: ‘FutureResult’
[13:36:55.836] resolved() for ‘SequentialFuture’ ... done
[13:36:55.836] A SequentialFuture was resolved
[13:36:55.836]  length: 0 (resolved future 1)
[13:36:55.836] resolve() on list ... DONE
[13:36:55.836] - globals: [1] ‘a’
[13:36:55.836] Resolving futures part of globals (recursively) ... DONE
[13:36:55.837] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[13:36:55.837] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[13:36:55.837] - globals: [1] ‘a’
[13:36:55.838] - packages: [1] ‘future’
[13:36:55.838] getGlobalsAndPackages() ... DONE
[13:36:55.838] run() for ‘Future’ ...
[13:36:55.838] - state: ‘created’
[13:36:55.838] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.838] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.839]   - Field: ‘label’
[13:36:55.839]   - Field: ‘local’
[13:36:55.839]   - Field: ‘owner’
[13:36:55.839]   - Field: ‘envir’
[13:36:55.839]   - Field: ‘packages’
[13:36:55.839]   - Field: ‘gc’
[13:36:55.839]   - Field: ‘conditions’
[13:36:55.839]   - Field: ‘expr’
[13:36:55.839]   - Field: ‘uuid’
[13:36:55.839]   - Field: ‘seed’
[13:36:55.839]   - Field: ‘version’
[13:36:55.840]   - Field: ‘result’
[13:36:55.840]   - Field: ‘asynchronous’
[13:36:55.840]   - Field: ‘calls’
[13:36:55.840]   - Field: ‘globals’
[13:36:55.840]   - Field: ‘stdout’
[13:36:55.840]   - Field: ‘earlySignal’
[13:36:55.840]   - Field: ‘lazy’
[13:36:55.840]   - Field: ‘state’
[13:36:55.840] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.840] - Launch lazy future ...
[13:36:55.840] Packages needed by the future expression (n = 1): ‘future’
[13:36:55.841] Packages needed by future strategies (n = 0): <none>
[13:36:55.841] {
[13:36:55.841]     {
[13:36:55.841]         {
[13:36:55.841]             ...future.startTime <- base::Sys.time()
[13:36:55.841]             {
[13:36:55.841]                 {
[13:36:55.841]                   {
[13:36:55.841]                     {
[13:36:55.841]                       base::local({
[13:36:55.841]                         has_future <- base::requireNamespace("future", 
[13:36:55.841]                           quietly = TRUE)
[13:36:55.841]                         if (has_future) {
[13:36:55.841]                           ns <- base::getNamespace("future")
[13:36:55.841]                           version <- ns[[".package"]][["version"]]
[13:36:55.841]                           if (is.null(version)) 
[13:36:55.841]                             version <- utils::packageVersion("future")
[13:36:55.841]                         }
[13:36:55.841]                         else {
[13:36:55.841]                           version <- NULL
[13:36:55.841]                         }
[13:36:55.841]                         if (!has_future || version < "1.8.0") {
[13:36:55.841]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.841]                             "", base::R.version$version.string), 
[13:36:55.841]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:55.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.841]                               "release", "version")], collapse = " "), 
[13:36:55.841]                             hostname = base::Sys.info()[["nodename"]])
[13:36:55.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.841]                             info)
[13:36:55.841]                           info <- base::paste(info, collapse = "; ")
[13:36:55.841]                           if (!has_future) {
[13:36:55.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.841]                               info)
[13:36:55.841]                           }
[13:36:55.841]                           else {
[13:36:55.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.841]                               info, version)
[13:36:55.841]                           }
[13:36:55.841]                           base::stop(msg)
[13:36:55.841]                         }
[13:36:55.841]                       })
[13:36:55.841]                     }
[13:36:55.841]                     base::local({
[13:36:55.841]                       for (pkg in "future") {
[13:36:55.841]                         base::loadNamespace(pkg)
[13:36:55.841]                         base::library(pkg, character.only = TRUE)
[13:36:55.841]                       }
[13:36:55.841]                     })
[13:36:55.841]                   }
[13:36:55.841]                   ...future.strategy.old <- future::plan("list")
[13:36:55.841]                   options(future.plan = NULL)
[13:36:55.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.841]                 }
[13:36:55.841]                 ...future.workdir <- getwd()
[13:36:55.841]             }
[13:36:55.841]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.841]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.841]         }
[13:36:55.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.841]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.841]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.841]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.841]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.841]             base::names(...future.oldOptions))
[13:36:55.841]     }
[13:36:55.841]     if (FALSE) {
[13:36:55.841]     }
[13:36:55.841]     else {
[13:36:55.841]         if (TRUE) {
[13:36:55.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.841]                 open = "w")
[13:36:55.841]         }
[13:36:55.841]         else {
[13:36:55.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.841]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.841]         }
[13:36:55.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.841]             base::sink(type = "output", split = FALSE)
[13:36:55.841]             base::close(...future.stdout)
[13:36:55.841]         }, add = TRUE)
[13:36:55.841]     }
[13:36:55.841]     ...future.frame <- base::sys.nframe()
[13:36:55.841]     ...future.conditions <- base::list()
[13:36:55.841]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.841]     if (FALSE) {
[13:36:55.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.841]     }
[13:36:55.841]     ...future.result <- base::tryCatch({
[13:36:55.841]         base::withCallingHandlers({
[13:36:55.841]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:36:55.841]                 1))
[13:36:55.841]             future::FutureResult(value = ...future.value$value, 
[13:36:55.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.841]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.841]                     ...future.globalenv.names))
[13:36:55.841]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.841]         }, condition = base::local({
[13:36:55.841]             c <- base::c
[13:36:55.841]             inherits <- base::inherits
[13:36:55.841]             invokeRestart <- base::invokeRestart
[13:36:55.841]             length <- base::length
[13:36:55.841]             list <- base::list
[13:36:55.841]             seq.int <- base::seq.int
[13:36:55.841]             signalCondition <- base::signalCondition
[13:36:55.841]             sys.calls <- base::sys.calls
[13:36:55.841]             `[[` <- base::`[[`
[13:36:55.841]             `+` <- base::`+`
[13:36:55.841]             `<<-` <- base::`<<-`
[13:36:55.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.841]                   3L)]
[13:36:55.841]             }
[13:36:55.841]             function(cond) {
[13:36:55.841]                 is_error <- inherits(cond, "error")
[13:36:55.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.841]                   NULL)
[13:36:55.841]                 if (is_error) {
[13:36:55.841]                   sessionInformation <- function() {
[13:36:55.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.841]                       search = base::search(), system = base::Sys.info())
[13:36:55.841]                   }
[13:36:55.841]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.841]                     cond$call), session = sessionInformation(), 
[13:36:55.841]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.841]                   signalCondition(cond)
[13:36:55.841]                 }
[13:36:55.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.841]                 "immediateCondition"))) {
[13:36:55.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.841]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.841]                   if (TRUE && !signal) {
[13:36:55.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.841]                     {
[13:36:55.841]                       inherits <- base::inherits
[13:36:55.841]                       invokeRestart <- base::invokeRestart
[13:36:55.841]                       is.null <- base::is.null
[13:36:55.841]                       muffled <- FALSE
[13:36:55.841]                       if (inherits(cond, "message")) {
[13:36:55.841]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.841]                         if (muffled) 
[13:36:55.841]                           invokeRestart("muffleMessage")
[13:36:55.841]                       }
[13:36:55.841]                       else if (inherits(cond, "warning")) {
[13:36:55.841]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.841]                         if (muffled) 
[13:36:55.841]                           invokeRestart("muffleWarning")
[13:36:55.841]                       }
[13:36:55.841]                       else if (inherits(cond, "condition")) {
[13:36:55.841]                         if (!is.null(pattern)) {
[13:36:55.841]                           computeRestarts <- base::computeRestarts
[13:36:55.841]                           grepl <- base::grepl
[13:36:55.841]                           restarts <- computeRestarts(cond)
[13:36:55.841]                           for (restart in restarts) {
[13:36:55.841]                             name <- restart$name
[13:36:55.841]                             if (is.null(name)) 
[13:36:55.841]                               next
[13:36:55.841]                             if (!grepl(pattern, name)) 
[13:36:55.841]                               next
[13:36:55.841]                             invokeRestart(restart)
[13:36:55.841]                             muffled <- TRUE
[13:36:55.841]                             break
[13:36:55.841]                           }
[13:36:55.841]                         }
[13:36:55.841]                       }
[13:36:55.841]                       invisible(muffled)
[13:36:55.841]                     }
[13:36:55.841]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.841]                   }
[13:36:55.841]                 }
[13:36:55.841]                 else {
[13:36:55.841]                   if (TRUE) {
[13:36:55.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.841]                     {
[13:36:55.841]                       inherits <- base::inherits
[13:36:55.841]                       invokeRestart <- base::invokeRestart
[13:36:55.841]                       is.null <- base::is.null
[13:36:55.841]                       muffled <- FALSE
[13:36:55.841]                       if (inherits(cond, "message")) {
[13:36:55.841]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.841]                         if (muffled) 
[13:36:55.841]                           invokeRestart("muffleMessage")
[13:36:55.841]                       }
[13:36:55.841]                       else if (inherits(cond, "warning")) {
[13:36:55.841]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.841]                         if (muffled) 
[13:36:55.841]                           invokeRestart("muffleWarning")
[13:36:55.841]                       }
[13:36:55.841]                       else if (inherits(cond, "condition")) {
[13:36:55.841]                         if (!is.null(pattern)) {
[13:36:55.841]                           computeRestarts <- base::computeRestarts
[13:36:55.841]                           grepl <- base::grepl
[13:36:55.841]                           restarts <- computeRestarts(cond)
[13:36:55.841]                           for (restart in restarts) {
[13:36:55.841]                             name <- restart$name
[13:36:55.841]                             if (is.null(name)) 
[13:36:55.841]                               next
[13:36:55.841]                             if (!grepl(pattern, name)) 
[13:36:55.841]                               next
[13:36:55.841]                             invokeRestart(restart)
[13:36:55.841]                             muffled <- TRUE
[13:36:55.841]                             break
[13:36:55.841]                           }
[13:36:55.841]                         }
[13:36:55.841]                       }
[13:36:55.841]                       invisible(muffled)
[13:36:55.841]                     }
[13:36:55.841]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.841]                   }
[13:36:55.841]                 }
[13:36:55.841]             }
[13:36:55.841]         }))
[13:36:55.841]     }, error = function(ex) {
[13:36:55.841]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.841]                 ...future.rng), started = ...future.startTime, 
[13:36:55.841]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.841]             version = "1.8"), class = "FutureResult")
[13:36:55.841]     }, finally = {
[13:36:55.841]         if (!identical(...future.workdir, getwd())) 
[13:36:55.841]             setwd(...future.workdir)
[13:36:55.841]         {
[13:36:55.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.841]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.841]             }
[13:36:55.841]             base::options(...future.oldOptions)
[13:36:55.841]             if (.Platform$OS.type == "windows") {
[13:36:55.841]                 old_names <- names(...future.oldEnvVars)
[13:36:55.841]                 envs <- base::Sys.getenv()
[13:36:55.841]                 names <- names(envs)
[13:36:55.841]                 common <- intersect(names, old_names)
[13:36:55.841]                 added <- setdiff(names, old_names)
[13:36:55.841]                 removed <- setdiff(old_names, names)
[13:36:55.841]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.841]                   envs[common]]
[13:36:55.841]                 NAMES <- toupper(changed)
[13:36:55.841]                 args <- list()
[13:36:55.841]                 for (kk in seq_along(NAMES)) {
[13:36:55.841]                   name <- changed[[kk]]
[13:36:55.841]                   NAME <- NAMES[[kk]]
[13:36:55.841]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.841]                     next
[13:36:55.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.841]                 }
[13:36:55.841]                 NAMES <- toupper(added)
[13:36:55.841]                 for (kk in seq_along(NAMES)) {
[13:36:55.841]                   name <- added[[kk]]
[13:36:55.841]                   NAME <- NAMES[[kk]]
[13:36:55.841]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.841]                     next
[13:36:55.841]                   args[[name]] <- ""
[13:36:55.841]                 }
[13:36:55.841]                 NAMES <- toupper(removed)
[13:36:55.841]                 for (kk in seq_along(NAMES)) {
[13:36:55.841]                   name <- removed[[kk]]
[13:36:55.841]                   NAME <- NAMES[[kk]]
[13:36:55.841]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.841]                     next
[13:36:55.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.841]                 }
[13:36:55.841]                 if (length(args) > 0) 
[13:36:55.841]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.841]             }
[13:36:55.841]             else {
[13:36:55.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.841]             }
[13:36:55.841]             {
[13:36:55.841]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.841]                   0L) {
[13:36:55.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.841]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.841]                   base::options(opts)
[13:36:55.841]                 }
[13:36:55.841]                 {
[13:36:55.841]                   {
[13:36:55.841]                     NULL
[13:36:55.841]                     RNGkind("Mersenne-Twister")
[13:36:55.841]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.841]                       inherits = FALSE)
[13:36:55.841]                   }
[13:36:55.841]                   options(future.plan = NULL)
[13:36:55.841]                   if (is.na(NA_character_)) 
[13:36:55.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.841]                     .init = FALSE)
[13:36:55.841]                 }
[13:36:55.841]             }
[13:36:55.841]         }
[13:36:55.841]     })
[13:36:55.841]     if (TRUE) {
[13:36:55.841]         base::sink(type = "output", split = FALSE)
[13:36:55.841]         if (TRUE) {
[13:36:55.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.841]         }
[13:36:55.841]         else {
[13:36:55.841]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.841]         }
[13:36:55.841]         base::close(...future.stdout)
[13:36:55.841]         ...future.stdout <- NULL
[13:36:55.841]     }
[13:36:55.841]     ...future.result$conditions <- ...future.conditions
[13:36:55.841]     ...future.result$finished <- base::Sys.time()
[13:36:55.841]     ...future.result
[13:36:55.841] }
[13:36:55.843] assign_globals() ...
[13:36:55.843] List of 1
[13:36:55.843]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c6db0eadc0> 
[13:36:55.843]  - attr(*, "where")=List of 1
[13:36:55.843]   ..$ a:<environment: R_EmptyEnv> 
[13:36:55.843]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.843]  - attr(*, "resolved")= logi TRUE
[13:36:55.843]  - attr(*, "total_size")= num 10424
[13:36:55.843]  - attr(*, "already-done")= logi TRUE
[13:36:55.846] - copied ‘a’ to environment
[13:36:55.846] assign_globals() ... done
[13:36:55.846] plan(): Setting new future strategy stack:
[13:36:55.846] List of future strategies:
[13:36:55.846] 1. sequential:
[13:36:55.846]    - args: function (..., envir = parent.frame())
[13:36:55.846]    - tweaked: FALSE
[13:36:55.846]    - call: NULL
[13:36:55.847] plan(): nbrOfWorkers() = 1
[13:36:55.848] plan(): Setting new future strategy stack:
[13:36:55.848] List of future strategies:
[13:36:55.848] 1. sequential:
[13:36:55.848]    - args: function (..., envir = parent.frame())
[13:36:55.848]    - tweaked: FALSE
[13:36:55.848]    - call: plan(strategy)
[13:36:55.848] plan(): nbrOfWorkers() = 1
[13:36:55.848] SequentialFuture started (and completed)
[13:36:55.848] - Launch lazy future ... done
[13:36:55.848] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.849] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.849] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.849] 
[13:36:55.849] Searching for globals ... DONE
[13:36:55.850] - globals: [0] <none>
[13:36:55.850] getGlobalsAndPackages() ... DONE
[13:36:55.850] run() for ‘Future’ ...
[13:36:55.850] - state: ‘created’
[13:36:55.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.850] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.850]   - Field: ‘label’
[13:36:55.851]   - Field: ‘local’
[13:36:55.851]   - Field: ‘owner’
[13:36:55.851]   - Field: ‘envir’
[13:36:55.851]   - Field: ‘packages’
[13:36:55.851]   - Field: ‘gc’
[13:36:55.851]   - Field: ‘conditions’
[13:36:55.851]   - Field: ‘expr’
[13:36:55.851]   - Field: ‘uuid’
[13:36:55.851]   - Field: ‘seed’
[13:36:55.851]   - Field: ‘version’
[13:36:55.851]   - Field: ‘result’
[13:36:55.851]   - Field: ‘asynchronous’
[13:36:55.852]   - Field: ‘calls’
[13:36:55.852]   - Field: ‘globals’
[13:36:55.852]   - Field: ‘stdout’
[13:36:55.852]   - Field: ‘earlySignal’
[13:36:55.852]   - Field: ‘lazy’
[13:36:55.852]   - Field: ‘state’
[13:36:55.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.852] - Launch lazy future ...
[13:36:55.852] Packages needed by the future expression (n = 0): <none>
[13:36:55.852] Packages needed by future strategies (n = 0): <none>
[13:36:55.853] {
[13:36:55.853]     {
[13:36:55.853]         {
[13:36:55.853]             ...future.startTime <- base::Sys.time()
[13:36:55.853]             {
[13:36:55.853]                 {
[13:36:55.853]                   {
[13:36:55.853]                     base::local({
[13:36:55.853]                       has_future <- base::requireNamespace("future", 
[13:36:55.853]                         quietly = TRUE)
[13:36:55.853]                       if (has_future) {
[13:36:55.853]                         ns <- base::getNamespace("future")
[13:36:55.853]                         version <- ns[[".package"]][["version"]]
[13:36:55.853]                         if (is.null(version)) 
[13:36:55.853]                           version <- utils::packageVersion("future")
[13:36:55.853]                       }
[13:36:55.853]                       else {
[13:36:55.853]                         version <- NULL
[13:36:55.853]                       }
[13:36:55.853]                       if (!has_future || version < "1.8.0") {
[13:36:55.853]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.853]                           "", base::R.version$version.string), 
[13:36:55.853]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.853]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.853]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.853]                             "release", "version")], collapse = " "), 
[13:36:55.853]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.853]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.853]                           info)
[13:36:55.853]                         info <- base::paste(info, collapse = "; ")
[13:36:55.853]                         if (!has_future) {
[13:36:55.853]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.853]                             info)
[13:36:55.853]                         }
[13:36:55.853]                         else {
[13:36:55.853]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.853]                             info, version)
[13:36:55.853]                         }
[13:36:55.853]                         base::stop(msg)
[13:36:55.853]                       }
[13:36:55.853]                     })
[13:36:55.853]                   }
[13:36:55.853]                   ...future.strategy.old <- future::plan("list")
[13:36:55.853]                   options(future.plan = NULL)
[13:36:55.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.853]                 }
[13:36:55.853]                 ...future.workdir <- getwd()
[13:36:55.853]             }
[13:36:55.853]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.853]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.853]         }
[13:36:55.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.853]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.853]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.853]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.853]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.853]             base::names(...future.oldOptions))
[13:36:55.853]     }
[13:36:55.853]     if (FALSE) {
[13:36:55.853]     }
[13:36:55.853]     else {
[13:36:55.853]         if (TRUE) {
[13:36:55.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.853]                 open = "w")
[13:36:55.853]         }
[13:36:55.853]         else {
[13:36:55.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.853]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.853]         }
[13:36:55.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.853]             base::sink(type = "output", split = FALSE)
[13:36:55.853]             base::close(...future.stdout)
[13:36:55.853]         }, add = TRUE)
[13:36:55.853]     }
[13:36:55.853]     ...future.frame <- base::sys.nframe()
[13:36:55.853]     ...future.conditions <- base::list()
[13:36:55.853]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.853]     if (FALSE) {
[13:36:55.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.853]     }
[13:36:55.853]     ...future.result <- base::tryCatch({
[13:36:55.853]         base::withCallingHandlers({
[13:36:55.853]             ...future.value <- base::withVisible(base::local(1))
[13:36:55.853]             future::FutureResult(value = ...future.value$value, 
[13:36:55.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.853]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.853]                     ...future.globalenv.names))
[13:36:55.853]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.853]         }, condition = base::local({
[13:36:55.853]             c <- base::c
[13:36:55.853]             inherits <- base::inherits
[13:36:55.853]             invokeRestart <- base::invokeRestart
[13:36:55.853]             length <- base::length
[13:36:55.853]             list <- base::list
[13:36:55.853]             seq.int <- base::seq.int
[13:36:55.853]             signalCondition <- base::signalCondition
[13:36:55.853]             sys.calls <- base::sys.calls
[13:36:55.853]             `[[` <- base::`[[`
[13:36:55.853]             `+` <- base::`+`
[13:36:55.853]             `<<-` <- base::`<<-`
[13:36:55.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.853]                   3L)]
[13:36:55.853]             }
[13:36:55.853]             function(cond) {
[13:36:55.853]                 is_error <- inherits(cond, "error")
[13:36:55.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.853]                   NULL)
[13:36:55.853]                 if (is_error) {
[13:36:55.853]                   sessionInformation <- function() {
[13:36:55.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.853]                       search = base::search(), system = base::Sys.info())
[13:36:55.853]                   }
[13:36:55.853]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.853]                     cond$call), session = sessionInformation(), 
[13:36:55.853]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.853]                   signalCondition(cond)
[13:36:55.853]                 }
[13:36:55.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.853]                 "immediateCondition"))) {
[13:36:55.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.853]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.853]                   if (TRUE && !signal) {
[13:36:55.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.853]                     {
[13:36:55.853]                       inherits <- base::inherits
[13:36:55.853]                       invokeRestart <- base::invokeRestart
[13:36:55.853]                       is.null <- base::is.null
[13:36:55.853]                       muffled <- FALSE
[13:36:55.853]                       if (inherits(cond, "message")) {
[13:36:55.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.853]                         if (muffled) 
[13:36:55.853]                           invokeRestart("muffleMessage")
[13:36:55.853]                       }
[13:36:55.853]                       else if (inherits(cond, "warning")) {
[13:36:55.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.853]                         if (muffled) 
[13:36:55.853]                           invokeRestart("muffleWarning")
[13:36:55.853]                       }
[13:36:55.853]                       else if (inherits(cond, "condition")) {
[13:36:55.853]                         if (!is.null(pattern)) {
[13:36:55.853]                           computeRestarts <- base::computeRestarts
[13:36:55.853]                           grepl <- base::grepl
[13:36:55.853]                           restarts <- computeRestarts(cond)
[13:36:55.853]                           for (restart in restarts) {
[13:36:55.853]                             name <- restart$name
[13:36:55.853]                             if (is.null(name)) 
[13:36:55.853]                               next
[13:36:55.853]                             if (!grepl(pattern, name)) 
[13:36:55.853]                               next
[13:36:55.853]                             invokeRestart(restart)
[13:36:55.853]                             muffled <- TRUE
[13:36:55.853]                             break
[13:36:55.853]                           }
[13:36:55.853]                         }
[13:36:55.853]                       }
[13:36:55.853]                       invisible(muffled)
[13:36:55.853]                     }
[13:36:55.853]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.853]                   }
[13:36:55.853]                 }
[13:36:55.853]                 else {
[13:36:55.853]                   if (TRUE) {
[13:36:55.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.853]                     {
[13:36:55.853]                       inherits <- base::inherits
[13:36:55.853]                       invokeRestart <- base::invokeRestart
[13:36:55.853]                       is.null <- base::is.null
[13:36:55.853]                       muffled <- FALSE
[13:36:55.853]                       if (inherits(cond, "message")) {
[13:36:55.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.853]                         if (muffled) 
[13:36:55.853]                           invokeRestart("muffleMessage")
[13:36:55.853]                       }
[13:36:55.853]                       else if (inherits(cond, "warning")) {
[13:36:55.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.853]                         if (muffled) 
[13:36:55.853]                           invokeRestart("muffleWarning")
[13:36:55.853]                       }
[13:36:55.853]                       else if (inherits(cond, "condition")) {
[13:36:55.853]                         if (!is.null(pattern)) {
[13:36:55.853]                           computeRestarts <- base::computeRestarts
[13:36:55.853]                           grepl <- base::grepl
[13:36:55.853]                           restarts <- computeRestarts(cond)
[13:36:55.853]                           for (restart in restarts) {
[13:36:55.853]                             name <- restart$name
[13:36:55.853]                             if (is.null(name)) 
[13:36:55.853]                               next
[13:36:55.853]                             if (!grepl(pattern, name)) 
[13:36:55.853]                               next
[13:36:55.853]                             invokeRestart(restart)
[13:36:55.853]                             muffled <- TRUE
[13:36:55.853]                             break
[13:36:55.853]                           }
[13:36:55.853]                         }
[13:36:55.853]                       }
[13:36:55.853]                       invisible(muffled)
[13:36:55.853]                     }
[13:36:55.853]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.853]                   }
[13:36:55.853]                 }
[13:36:55.853]             }
[13:36:55.853]         }))
[13:36:55.853]     }, error = function(ex) {
[13:36:55.853]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.853]                 ...future.rng), started = ...future.startTime, 
[13:36:55.853]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.853]             version = "1.8"), class = "FutureResult")
[13:36:55.853]     }, finally = {
[13:36:55.853]         if (!identical(...future.workdir, getwd())) 
[13:36:55.853]             setwd(...future.workdir)
[13:36:55.853]         {
[13:36:55.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.853]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.853]             }
[13:36:55.853]             base::options(...future.oldOptions)
[13:36:55.853]             if (.Platform$OS.type == "windows") {
[13:36:55.853]                 old_names <- names(...future.oldEnvVars)
[13:36:55.853]                 envs <- base::Sys.getenv()
[13:36:55.853]                 names <- names(envs)
[13:36:55.853]                 common <- intersect(names, old_names)
[13:36:55.853]                 added <- setdiff(names, old_names)
[13:36:55.853]                 removed <- setdiff(old_names, names)
[13:36:55.853]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.853]                   envs[common]]
[13:36:55.853]                 NAMES <- toupper(changed)
[13:36:55.853]                 args <- list()
[13:36:55.853]                 for (kk in seq_along(NAMES)) {
[13:36:55.853]                   name <- changed[[kk]]
[13:36:55.853]                   NAME <- NAMES[[kk]]
[13:36:55.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.853]                     next
[13:36:55.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.853]                 }
[13:36:55.853]                 NAMES <- toupper(added)
[13:36:55.853]                 for (kk in seq_along(NAMES)) {
[13:36:55.853]                   name <- added[[kk]]
[13:36:55.853]                   NAME <- NAMES[[kk]]
[13:36:55.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.853]                     next
[13:36:55.853]                   args[[name]] <- ""
[13:36:55.853]                 }
[13:36:55.853]                 NAMES <- toupper(removed)
[13:36:55.853]                 for (kk in seq_along(NAMES)) {
[13:36:55.853]                   name <- removed[[kk]]
[13:36:55.853]                   NAME <- NAMES[[kk]]
[13:36:55.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.853]                     next
[13:36:55.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.853]                 }
[13:36:55.853]                 if (length(args) > 0) 
[13:36:55.853]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.853]             }
[13:36:55.853]             else {
[13:36:55.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.853]             }
[13:36:55.853]             {
[13:36:55.853]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.853]                   0L) {
[13:36:55.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.853]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.853]                   base::options(opts)
[13:36:55.853]                 }
[13:36:55.853]                 {
[13:36:55.853]                   {
[13:36:55.853]                     NULL
[13:36:55.853]                     RNGkind("Mersenne-Twister")
[13:36:55.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.853]                       inherits = FALSE)
[13:36:55.853]                   }
[13:36:55.853]                   options(future.plan = NULL)
[13:36:55.853]                   if (is.na(NA_character_)) 
[13:36:55.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.853]                     .init = FALSE)
[13:36:55.853]                 }
[13:36:55.853]             }
[13:36:55.853]         }
[13:36:55.853]     })
[13:36:55.853]     if (TRUE) {
[13:36:55.853]         base::sink(type = "output", split = FALSE)
[13:36:55.853]         if (TRUE) {
[13:36:55.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.853]         }
[13:36:55.853]         else {
[13:36:55.853]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.853]         }
[13:36:55.853]         base::close(...future.stdout)
[13:36:55.853]         ...future.stdout <- NULL
[13:36:55.853]     }
[13:36:55.853]     ...future.result$conditions <- ...future.conditions
[13:36:55.853]     ...future.result$finished <- base::Sys.time()
[13:36:55.853]     ...future.result
[13:36:55.853] }
[13:36:55.854] plan(): Setting new future strategy stack:
[13:36:55.855] List of future strategies:
[13:36:55.855] 1. sequential:
[13:36:55.855]    - args: function (..., envir = parent.frame())
[13:36:55.855]    - tweaked: FALSE
[13:36:55.855]    - call: NULL
[13:36:55.855] plan(): nbrOfWorkers() = 1
[13:36:55.856] plan(): Setting new future strategy stack:
[13:36:55.856] List of future strategies:
[13:36:55.856] 1. sequential:
[13:36:55.856]    - args: function (..., envir = parent.frame())
[13:36:55.856]    - tweaked: FALSE
[13:36:55.856]    - call: plan(strategy)
[13:36:55.856] plan(): nbrOfWorkers() = 1
[13:36:55.856] SequentialFuture started (and completed)
[13:36:55.856] - Launch lazy future ... done
[13:36:55.856] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.857] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.857] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.857] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:55.858] Searching for globals ... DONE
[13:36:55.858] Resolving globals: TRUE
[13:36:55.858] Resolving any globals that are futures ...
[13:36:55.858] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:55.858] Resolving any globals that are futures ... DONE
[13:36:55.858] Resolving futures part of globals (recursively) ...
[13:36:55.858] resolve() on list ...
[13:36:55.859]  recursive: 99
[13:36:55.859]  length: 1
[13:36:55.859]  elements: ‘a’
[13:36:55.859] resolved() for ‘SequentialFuture’ ...
[13:36:55.859] - state: ‘finished’
[13:36:55.859] - run: TRUE
[13:36:55.859] - result: ‘FutureResult’
[13:36:55.859] resolved() for ‘SequentialFuture’ ... done
[13:36:55.859] Future #1
[13:36:55.859] resolved() for ‘SequentialFuture’ ...
[13:36:55.859] - state: ‘finished’
[13:36:55.860] - run: TRUE
[13:36:55.860] - result: ‘FutureResult’
[13:36:55.860] resolved() for ‘SequentialFuture’ ... done
[13:36:55.860] A SequentialFuture was resolved
[13:36:55.860]  length: 0 (resolved future 1)
[13:36:55.860] resolve() on list ... DONE
[13:36:55.860] - globals: [1] ‘a’
[13:36:55.860] Resolving futures part of globals (recursively) ... DONE
[13:36:55.861] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[13:36:55.861] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[13:36:55.861] - globals: [1] ‘a’
[13:36:55.861] - packages: [1] ‘future’
[13:36:55.861] getGlobalsAndPackages() ... DONE
[13:36:55.862] run() for ‘Future’ ...
[13:36:55.862] - state: ‘created’
[13:36:55.862] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.862] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.862]   - Field: ‘label’
[13:36:55.863]   - Field: ‘local’
[13:36:55.863]   - Field: ‘owner’
[13:36:55.863]   - Field: ‘envir’
[13:36:55.863]   - Field: ‘packages’
[13:36:55.863]   - Field: ‘gc’
[13:36:55.863]   - Field: ‘conditions’
[13:36:55.863]   - Field: ‘expr’
[13:36:55.863]   - Field: ‘uuid’
[13:36:55.863]   - Field: ‘seed’
[13:36:55.863]   - Field: ‘version’
[13:36:55.863]   - Field: ‘result’
[13:36:55.863]   - Field: ‘asynchronous’
[13:36:55.864]   - Field: ‘calls’
[13:36:55.864]   - Field: ‘globals’
[13:36:55.864]   - Field: ‘stdout’
[13:36:55.864]   - Field: ‘earlySignal’
[13:36:55.864]   - Field: ‘lazy’
[13:36:55.864]   - Field: ‘state’
[13:36:55.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.864] - Launch lazy future ...
[13:36:55.864] Packages needed by the future expression (n = 1): ‘future’
[13:36:55.864] Packages needed by future strategies (n = 0): <none>
[13:36:55.865] {
[13:36:55.865]     {
[13:36:55.865]         {
[13:36:55.865]             ...future.startTime <- base::Sys.time()
[13:36:55.865]             {
[13:36:55.865]                 {
[13:36:55.865]                   {
[13:36:55.865]                     {
[13:36:55.865]                       base::local({
[13:36:55.865]                         has_future <- base::requireNamespace("future", 
[13:36:55.865]                           quietly = TRUE)
[13:36:55.865]                         if (has_future) {
[13:36:55.865]                           ns <- base::getNamespace("future")
[13:36:55.865]                           version <- ns[[".package"]][["version"]]
[13:36:55.865]                           if (is.null(version)) 
[13:36:55.865]                             version <- utils::packageVersion("future")
[13:36:55.865]                         }
[13:36:55.865]                         else {
[13:36:55.865]                           version <- NULL
[13:36:55.865]                         }
[13:36:55.865]                         if (!has_future || version < "1.8.0") {
[13:36:55.865]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.865]                             "", base::R.version$version.string), 
[13:36:55.865]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:55.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.865]                               "release", "version")], collapse = " "), 
[13:36:55.865]                             hostname = base::Sys.info()[["nodename"]])
[13:36:55.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.865]                             info)
[13:36:55.865]                           info <- base::paste(info, collapse = "; ")
[13:36:55.865]                           if (!has_future) {
[13:36:55.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.865]                               info)
[13:36:55.865]                           }
[13:36:55.865]                           else {
[13:36:55.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.865]                               info, version)
[13:36:55.865]                           }
[13:36:55.865]                           base::stop(msg)
[13:36:55.865]                         }
[13:36:55.865]                       })
[13:36:55.865]                     }
[13:36:55.865]                     base::local({
[13:36:55.865]                       for (pkg in "future") {
[13:36:55.865]                         base::loadNamespace(pkg)
[13:36:55.865]                         base::library(pkg, character.only = TRUE)
[13:36:55.865]                       }
[13:36:55.865]                     })
[13:36:55.865]                   }
[13:36:55.865]                   ...future.strategy.old <- future::plan("list")
[13:36:55.865]                   options(future.plan = NULL)
[13:36:55.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.865]                 }
[13:36:55.865]                 ...future.workdir <- getwd()
[13:36:55.865]             }
[13:36:55.865]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.865]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.865]         }
[13:36:55.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.865]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.865]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.865]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.865]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.865]             base::names(...future.oldOptions))
[13:36:55.865]     }
[13:36:55.865]     if (FALSE) {
[13:36:55.865]     }
[13:36:55.865]     else {
[13:36:55.865]         if (TRUE) {
[13:36:55.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.865]                 open = "w")
[13:36:55.865]         }
[13:36:55.865]         else {
[13:36:55.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.865]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.865]         }
[13:36:55.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.865]             base::sink(type = "output", split = FALSE)
[13:36:55.865]             base::close(...future.stdout)
[13:36:55.865]         }, add = TRUE)
[13:36:55.865]     }
[13:36:55.865]     ...future.frame <- base::sys.nframe()
[13:36:55.865]     ...future.conditions <- base::list()
[13:36:55.865]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.865]     if (FALSE) {
[13:36:55.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.865]     }
[13:36:55.865]     ...future.result <- base::tryCatch({
[13:36:55.865]         base::withCallingHandlers({
[13:36:55.865]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:36:55.865]                 1))
[13:36:55.865]             future::FutureResult(value = ...future.value$value, 
[13:36:55.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.865]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.865]                     ...future.globalenv.names))
[13:36:55.865]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.865]         }, condition = base::local({
[13:36:55.865]             c <- base::c
[13:36:55.865]             inherits <- base::inherits
[13:36:55.865]             invokeRestart <- base::invokeRestart
[13:36:55.865]             length <- base::length
[13:36:55.865]             list <- base::list
[13:36:55.865]             seq.int <- base::seq.int
[13:36:55.865]             signalCondition <- base::signalCondition
[13:36:55.865]             sys.calls <- base::sys.calls
[13:36:55.865]             `[[` <- base::`[[`
[13:36:55.865]             `+` <- base::`+`
[13:36:55.865]             `<<-` <- base::`<<-`
[13:36:55.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.865]                   3L)]
[13:36:55.865]             }
[13:36:55.865]             function(cond) {
[13:36:55.865]                 is_error <- inherits(cond, "error")
[13:36:55.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.865]                   NULL)
[13:36:55.865]                 if (is_error) {
[13:36:55.865]                   sessionInformation <- function() {
[13:36:55.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.865]                       search = base::search(), system = base::Sys.info())
[13:36:55.865]                   }
[13:36:55.865]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.865]                     cond$call), session = sessionInformation(), 
[13:36:55.865]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.865]                   signalCondition(cond)
[13:36:55.865]                 }
[13:36:55.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.865]                 "immediateCondition"))) {
[13:36:55.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.865]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.865]                   if (TRUE && !signal) {
[13:36:55.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.865]                     {
[13:36:55.865]                       inherits <- base::inherits
[13:36:55.865]                       invokeRestart <- base::invokeRestart
[13:36:55.865]                       is.null <- base::is.null
[13:36:55.865]                       muffled <- FALSE
[13:36:55.865]                       if (inherits(cond, "message")) {
[13:36:55.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.865]                         if (muffled) 
[13:36:55.865]                           invokeRestart("muffleMessage")
[13:36:55.865]                       }
[13:36:55.865]                       else if (inherits(cond, "warning")) {
[13:36:55.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.865]                         if (muffled) 
[13:36:55.865]                           invokeRestart("muffleWarning")
[13:36:55.865]                       }
[13:36:55.865]                       else if (inherits(cond, "condition")) {
[13:36:55.865]                         if (!is.null(pattern)) {
[13:36:55.865]                           computeRestarts <- base::computeRestarts
[13:36:55.865]                           grepl <- base::grepl
[13:36:55.865]                           restarts <- computeRestarts(cond)
[13:36:55.865]                           for (restart in restarts) {
[13:36:55.865]                             name <- restart$name
[13:36:55.865]                             if (is.null(name)) 
[13:36:55.865]                               next
[13:36:55.865]                             if (!grepl(pattern, name)) 
[13:36:55.865]                               next
[13:36:55.865]                             invokeRestart(restart)
[13:36:55.865]                             muffled <- TRUE
[13:36:55.865]                             break
[13:36:55.865]                           }
[13:36:55.865]                         }
[13:36:55.865]                       }
[13:36:55.865]                       invisible(muffled)
[13:36:55.865]                     }
[13:36:55.865]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.865]                   }
[13:36:55.865]                 }
[13:36:55.865]                 else {
[13:36:55.865]                   if (TRUE) {
[13:36:55.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.865]                     {
[13:36:55.865]                       inherits <- base::inherits
[13:36:55.865]                       invokeRestart <- base::invokeRestart
[13:36:55.865]                       is.null <- base::is.null
[13:36:55.865]                       muffled <- FALSE
[13:36:55.865]                       if (inherits(cond, "message")) {
[13:36:55.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.865]                         if (muffled) 
[13:36:55.865]                           invokeRestart("muffleMessage")
[13:36:55.865]                       }
[13:36:55.865]                       else if (inherits(cond, "warning")) {
[13:36:55.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.865]                         if (muffled) 
[13:36:55.865]                           invokeRestart("muffleWarning")
[13:36:55.865]                       }
[13:36:55.865]                       else if (inherits(cond, "condition")) {
[13:36:55.865]                         if (!is.null(pattern)) {
[13:36:55.865]                           computeRestarts <- base::computeRestarts
[13:36:55.865]                           grepl <- base::grepl
[13:36:55.865]                           restarts <- computeRestarts(cond)
[13:36:55.865]                           for (restart in restarts) {
[13:36:55.865]                             name <- restart$name
[13:36:55.865]                             if (is.null(name)) 
[13:36:55.865]                               next
[13:36:55.865]                             if (!grepl(pattern, name)) 
[13:36:55.865]                               next
[13:36:55.865]                             invokeRestart(restart)
[13:36:55.865]                             muffled <- TRUE
[13:36:55.865]                             break
[13:36:55.865]                           }
[13:36:55.865]                         }
[13:36:55.865]                       }
[13:36:55.865]                       invisible(muffled)
[13:36:55.865]                     }
[13:36:55.865]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.865]                   }
[13:36:55.865]                 }
[13:36:55.865]             }
[13:36:55.865]         }))
[13:36:55.865]     }, error = function(ex) {
[13:36:55.865]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.865]                 ...future.rng), started = ...future.startTime, 
[13:36:55.865]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.865]             version = "1.8"), class = "FutureResult")
[13:36:55.865]     }, finally = {
[13:36:55.865]         if (!identical(...future.workdir, getwd())) 
[13:36:55.865]             setwd(...future.workdir)
[13:36:55.865]         {
[13:36:55.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.865]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.865]             }
[13:36:55.865]             base::options(...future.oldOptions)
[13:36:55.865]             if (.Platform$OS.type == "windows") {
[13:36:55.865]                 old_names <- names(...future.oldEnvVars)
[13:36:55.865]                 envs <- base::Sys.getenv()
[13:36:55.865]                 names <- names(envs)
[13:36:55.865]                 common <- intersect(names, old_names)
[13:36:55.865]                 added <- setdiff(names, old_names)
[13:36:55.865]                 removed <- setdiff(old_names, names)
[13:36:55.865]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.865]                   envs[common]]
[13:36:55.865]                 NAMES <- toupper(changed)
[13:36:55.865]                 args <- list()
[13:36:55.865]                 for (kk in seq_along(NAMES)) {
[13:36:55.865]                   name <- changed[[kk]]
[13:36:55.865]                   NAME <- NAMES[[kk]]
[13:36:55.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.865]                     next
[13:36:55.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.865]                 }
[13:36:55.865]                 NAMES <- toupper(added)
[13:36:55.865]                 for (kk in seq_along(NAMES)) {
[13:36:55.865]                   name <- added[[kk]]
[13:36:55.865]                   NAME <- NAMES[[kk]]
[13:36:55.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.865]                     next
[13:36:55.865]                   args[[name]] <- ""
[13:36:55.865]                 }
[13:36:55.865]                 NAMES <- toupper(removed)
[13:36:55.865]                 for (kk in seq_along(NAMES)) {
[13:36:55.865]                   name <- removed[[kk]]
[13:36:55.865]                   NAME <- NAMES[[kk]]
[13:36:55.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.865]                     next
[13:36:55.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.865]                 }
[13:36:55.865]                 if (length(args) > 0) 
[13:36:55.865]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.865]             }
[13:36:55.865]             else {
[13:36:55.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.865]             }
[13:36:55.865]             {
[13:36:55.865]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.865]                   0L) {
[13:36:55.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.865]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.865]                   base::options(opts)
[13:36:55.865]                 }
[13:36:55.865]                 {
[13:36:55.865]                   {
[13:36:55.865]                     NULL
[13:36:55.865]                     RNGkind("Mersenne-Twister")
[13:36:55.865]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.865]                       inherits = FALSE)
[13:36:55.865]                   }
[13:36:55.865]                   options(future.plan = NULL)
[13:36:55.865]                   if (is.na(NA_character_)) 
[13:36:55.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.865]                     .init = FALSE)
[13:36:55.865]                 }
[13:36:55.865]             }
[13:36:55.865]         }
[13:36:55.865]     })
[13:36:55.865]     if (TRUE) {
[13:36:55.865]         base::sink(type = "output", split = FALSE)
[13:36:55.865]         if (TRUE) {
[13:36:55.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.865]         }
[13:36:55.865]         else {
[13:36:55.865]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.865]         }
[13:36:55.865]         base::close(...future.stdout)
[13:36:55.865]         ...future.stdout <- NULL
[13:36:55.865]     }
[13:36:55.865]     ...future.result$conditions <- ...future.conditions
[13:36:55.865]     ...future.result$finished <- base::Sys.time()
[13:36:55.865]     ...future.result
[13:36:55.865] }
[13:36:55.866] assign_globals() ...
[13:36:55.867] List of 1
[13:36:55.867]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c6da9b7c38> 
[13:36:55.867]  - attr(*, "where")=List of 1
[13:36:55.867]   ..$ a:<environment: R_EmptyEnv> 
[13:36:55.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.867]  - attr(*, "resolved")= logi TRUE
[13:36:55.867]  - attr(*, "total_size")= num 10424
[13:36:55.867]  - attr(*, "already-done")= logi TRUE
[13:36:55.869] - copied ‘a’ to environment
[13:36:55.869] assign_globals() ... done
[13:36:55.869] plan(): Setting new future strategy stack:
[13:36:55.869] List of future strategies:
[13:36:55.869] 1. sequential:
[13:36:55.869]    - args: function (..., envir = parent.frame())
[13:36:55.869]    - tweaked: FALSE
[13:36:55.869]    - call: NULL
[13:36:55.870] plan(): nbrOfWorkers() = 1
[13:36:55.871] plan(): Setting new future strategy stack:
[13:36:55.871] List of future strategies:
[13:36:55.871] 1. sequential:
[13:36:55.871]    - args: function (..., envir = parent.frame())
[13:36:55.871]    - tweaked: FALSE
[13:36:55.871]    - call: plan(strategy)
[13:36:55.872] plan(): nbrOfWorkers() = 1
[13:36:55.872] SequentialFuture started (and completed)
[13:36:55.872] - Launch lazy future ... done
[13:36:55.872] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.872] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.873] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.873] 
[13:36:55.873] Searching for globals ... DONE
[13:36:55.873] - globals: [0] <none>
[13:36:55.873] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.874] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.874] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.875] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:55.875] Searching for globals ... DONE
[13:36:55.875] Resolving globals: TRUE
[13:36:55.875] Resolving any globals that are futures ...
[13:36:55.875] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:55.875] Resolving any globals that are futures ... DONE
[13:36:55.875] Resolving futures part of globals (recursively) ...
[13:36:55.876] resolve() on list ...
[13:36:55.876]  recursive: 99
[13:36:55.876]  length: 1
[13:36:55.876]  elements: ‘a’
[13:36:55.876] run() for ‘Future’ ...
[13:36:55.876] - state: ‘created’
[13:36:55.876] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.876] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.877] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.877]   - Field: ‘label’
[13:36:55.877]   - Field: ‘local’
[13:36:55.877]   - Field: ‘owner’
[13:36:55.877]   - Field: ‘envir’
[13:36:55.877]   - Field: ‘packages’
[13:36:55.877]   - Field: ‘gc’
[13:36:55.877]   - Field: ‘conditions’
[13:36:55.877]   - Field: ‘expr’
[13:36:55.877]   - Field: ‘uuid’
[13:36:55.877]   - Field: ‘seed’
[13:36:55.877]   - Field: ‘version’
[13:36:55.878]   - Field: ‘result’
[13:36:55.878]   - Field: ‘asynchronous’
[13:36:55.878]   - Field: ‘calls’
[13:36:55.878]   - Field: ‘globals’
[13:36:55.878]   - Field: ‘stdout’
[13:36:55.878]   - Field: ‘earlySignal’
[13:36:55.878]   - Field: ‘lazy’
[13:36:55.878]   - Field: ‘state’
[13:36:55.878] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.878] - Launch lazy future ...
[13:36:55.879] Packages needed by the future expression (n = 0): <none>
[13:36:55.879] Packages needed by future strategies (n = 0): <none>
[13:36:55.879] {
[13:36:55.879]     {
[13:36:55.879]         {
[13:36:55.879]             ...future.startTime <- base::Sys.time()
[13:36:55.879]             {
[13:36:55.879]                 {
[13:36:55.879]                   {
[13:36:55.879]                     base::local({
[13:36:55.879]                       has_future <- base::requireNamespace("future", 
[13:36:55.879]                         quietly = TRUE)
[13:36:55.879]                       if (has_future) {
[13:36:55.879]                         ns <- base::getNamespace("future")
[13:36:55.879]                         version <- ns[[".package"]][["version"]]
[13:36:55.879]                         if (is.null(version)) 
[13:36:55.879]                           version <- utils::packageVersion("future")
[13:36:55.879]                       }
[13:36:55.879]                       else {
[13:36:55.879]                         version <- NULL
[13:36:55.879]                       }
[13:36:55.879]                       if (!has_future || version < "1.8.0") {
[13:36:55.879]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.879]                           "", base::R.version$version.string), 
[13:36:55.879]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.879]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.879]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.879]                             "release", "version")], collapse = " "), 
[13:36:55.879]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.879]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.879]                           info)
[13:36:55.879]                         info <- base::paste(info, collapse = "; ")
[13:36:55.879]                         if (!has_future) {
[13:36:55.879]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.879]                             info)
[13:36:55.879]                         }
[13:36:55.879]                         else {
[13:36:55.879]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.879]                             info, version)
[13:36:55.879]                         }
[13:36:55.879]                         base::stop(msg)
[13:36:55.879]                       }
[13:36:55.879]                     })
[13:36:55.879]                   }
[13:36:55.879]                   ...future.strategy.old <- future::plan("list")
[13:36:55.879]                   options(future.plan = NULL)
[13:36:55.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.879]                 }
[13:36:55.879]                 ...future.workdir <- getwd()
[13:36:55.879]             }
[13:36:55.879]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.879]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.879]         }
[13:36:55.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.879]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.879]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.879]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.879]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.879]             base::names(...future.oldOptions))
[13:36:55.879]     }
[13:36:55.879]     if (FALSE) {
[13:36:55.879]     }
[13:36:55.879]     else {
[13:36:55.879]         if (TRUE) {
[13:36:55.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.879]                 open = "w")
[13:36:55.879]         }
[13:36:55.879]         else {
[13:36:55.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.879]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.879]         }
[13:36:55.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.879]             base::sink(type = "output", split = FALSE)
[13:36:55.879]             base::close(...future.stdout)
[13:36:55.879]         }, add = TRUE)
[13:36:55.879]     }
[13:36:55.879]     ...future.frame <- base::sys.nframe()
[13:36:55.879]     ...future.conditions <- base::list()
[13:36:55.879]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.879]     if (FALSE) {
[13:36:55.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.879]     }
[13:36:55.879]     ...future.result <- base::tryCatch({
[13:36:55.879]         base::withCallingHandlers({
[13:36:55.879]             ...future.value <- base::withVisible(base::local(1))
[13:36:55.879]             future::FutureResult(value = ...future.value$value, 
[13:36:55.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.879]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.879]                     ...future.globalenv.names))
[13:36:55.879]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.879]         }, condition = base::local({
[13:36:55.879]             c <- base::c
[13:36:55.879]             inherits <- base::inherits
[13:36:55.879]             invokeRestart <- base::invokeRestart
[13:36:55.879]             length <- base::length
[13:36:55.879]             list <- base::list
[13:36:55.879]             seq.int <- base::seq.int
[13:36:55.879]             signalCondition <- base::signalCondition
[13:36:55.879]             sys.calls <- base::sys.calls
[13:36:55.879]             `[[` <- base::`[[`
[13:36:55.879]             `+` <- base::`+`
[13:36:55.879]             `<<-` <- base::`<<-`
[13:36:55.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.879]                   3L)]
[13:36:55.879]             }
[13:36:55.879]             function(cond) {
[13:36:55.879]                 is_error <- inherits(cond, "error")
[13:36:55.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.879]                   NULL)
[13:36:55.879]                 if (is_error) {
[13:36:55.879]                   sessionInformation <- function() {
[13:36:55.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.879]                       search = base::search(), system = base::Sys.info())
[13:36:55.879]                   }
[13:36:55.879]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.879]                     cond$call), session = sessionInformation(), 
[13:36:55.879]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.879]                   signalCondition(cond)
[13:36:55.879]                 }
[13:36:55.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.879]                 "immediateCondition"))) {
[13:36:55.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.879]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.879]                   if (TRUE && !signal) {
[13:36:55.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.879]                     {
[13:36:55.879]                       inherits <- base::inherits
[13:36:55.879]                       invokeRestart <- base::invokeRestart
[13:36:55.879]                       is.null <- base::is.null
[13:36:55.879]                       muffled <- FALSE
[13:36:55.879]                       if (inherits(cond, "message")) {
[13:36:55.879]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.879]                         if (muffled) 
[13:36:55.879]                           invokeRestart("muffleMessage")
[13:36:55.879]                       }
[13:36:55.879]                       else if (inherits(cond, "warning")) {
[13:36:55.879]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.879]                         if (muffled) 
[13:36:55.879]                           invokeRestart("muffleWarning")
[13:36:55.879]                       }
[13:36:55.879]                       else if (inherits(cond, "condition")) {
[13:36:55.879]                         if (!is.null(pattern)) {
[13:36:55.879]                           computeRestarts <- base::computeRestarts
[13:36:55.879]                           grepl <- base::grepl
[13:36:55.879]                           restarts <- computeRestarts(cond)
[13:36:55.879]                           for (restart in restarts) {
[13:36:55.879]                             name <- restart$name
[13:36:55.879]                             if (is.null(name)) 
[13:36:55.879]                               next
[13:36:55.879]                             if (!grepl(pattern, name)) 
[13:36:55.879]                               next
[13:36:55.879]                             invokeRestart(restart)
[13:36:55.879]                             muffled <- TRUE
[13:36:55.879]                             break
[13:36:55.879]                           }
[13:36:55.879]                         }
[13:36:55.879]                       }
[13:36:55.879]                       invisible(muffled)
[13:36:55.879]                     }
[13:36:55.879]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.879]                   }
[13:36:55.879]                 }
[13:36:55.879]                 else {
[13:36:55.879]                   if (TRUE) {
[13:36:55.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.879]                     {
[13:36:55.879]                       inherits <- base::inherits
[13:36:55.879]                       invokeRestart <- base::invokeRestart
[13:36:55.879]                       is.null <- base::is.null
[13:36:55.879]                       muffled <- FALSE
[13:36:55.879]                       if (inherits(cond, "message")) {
[13:36:55.879]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.879]                         if (muffled) 
[13:36:55.879]                           invokeRestart("muffleMessage")
[13:36:55.879]                       }
[13:36:55.879]                       else if (inherits(cond, "warning")) {
[13:36:55.879]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.879]                         if (muffled) 
[13:36:55.879]                           invokeRestart("muffleWarning")
[13:36:55.879]                       }
[13:36:55.879]                       else if (inherits(cond, "condition")) {
[13:36:55.879]                         if (!is.null(pattern)) {
[13:36:55.879]                           computeRestarts <- base::computeRestarts
[13:36:55.879]                           grepl <- base::grepl
[13:36:55.879]                           restarts <- computeRestarts(cond)
[13:36:55.879]                           for (restart in restarts) {
[13:36:55.879]                             name <- restart$name
[13:36:55.879]                             if (is.null(name)) 
[13:36:55.879]                               next
[13:36:55.879]                             if (!grepl(pattern, name)) 
[13:36:55.879]                               next
[13:36:55.879]                             invokeRestart(restart)
[13:36:55.879]                             muffled <- TRUE
[13:36:55.879]                             break
[13:36:55.879]                           }
[13:36:55.879]                         }
[13:36:55.879]                       }
[13:36:55.879]                       invisible(muffled)
[13:36:55.879]                     }
[13:36:55.879]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.879]                   }
[13:36:55.879]                 }
[13:36:55.879]             }
[13:36:55.879]         }))
[13:36:55.879]     }, error = function(ex) {
[13:36:55.879]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.879]                 ...future.rng), started = ...future.startTime, 
[13:36:55.879]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.879]             version = "1.8"), class = "FutureResult")
[13:36:55.879]     }, finally = {
[13:36:55.879]         if (!identical(...future.workdir, getwd())) 
[13:36:55.879]             setwd(...future.workdir)
[13:36:55.879]         {
[13:36:55.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.879]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.879]             }
[13:36:55.879]             base::options(...future.oldOptions)
[13:36:55.879]             if (.Platform$OS.type == "windows") {
[13:36:55.879]                 old_names <- names(...future.oldEnvVars)
[13:36:55.879]                 envs <- base::Sys.getenv()
[13:36:55.879]                 names <- names(envs)
[13:36:55.879]                 common <- intersect(names, old_names)
[13:36:55.879]                 added <- setdiff(names, old_names)
[13:36:55.879]                 removed <- setdiff(old_names, names)
[13:36:55.879]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.879]                   envs[common]]
[13:36:55.879]                 NAMES <- toupper(changed)
[13:36:55.879]                 args <- list()
[13:36:55.879]                 for (kk in seq_along(NAMES)) {
[13:36:55.879]                   name <- changed[[kk]]
[13:36:55.879]                   NAME <- NAMES[[kk]]
[13:36:55.879]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.879]                     next
[13:36:55.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.879]                 }
[13:36:55.879]                 NAMES <- toupper(added)
[13:36:55.879]                 for (kk in seq_along(NAMES)) {
[13:36:55.879]                   name <- added[[kk]]
[13:36:55.879]                   NAME <- NAMES[[kk]]
[13:36:55.879]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.879]                     next
[13:36:55.879]                   args[[name]] <- ""
[13:36:55.879]                 }
[13:36:55.879]                 NAMES <- toupper(removed)
[13:36:55.879]                 for (kk in seq_along(NAMES)) {
[13:36:55.879]                   name <- removed[[kk]]
[13:36:55.879]                   NAME <- NAMES[[kk]]
[13:36:55.879]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.879]                     next
[13:36:55.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.879]                 }
[13:36:55.879]                 if (length(args) > 0) 
[13:36:55.879]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.879]             }
[13:36:55.879]             else {
[13:36:55.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.879]             }
[13:36:55.879]             {
[13:36:55.879]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.879]                   0L) {
[13:36:55.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.879]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.879]                   base::options(opts)
[13:36:55.879]                 }
[13:36:55.879]                 {
[13:36:55.879]                   {
[13:36:55.879]                     NULL
[13:36:55.879]                     RNGkind("Mersenne-Twister")
[13:36:55.879]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.879]                       inherits = FALSE)
[13:36:55.879]                   }
[13:36:55.879]                   options(future.plan = NULL)
[13:36:55.879]                   if (is.na(NA_character_)) 
[13:36:55.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.879]                     .init = FALSE)
[13:36:55.879]                 }
[13:36:55.879]             }
[13:36:55.879]         }
[13:36:55.879]     })
[13:36:55.879]     if (TRUE) {
[13:36:55.879]         base::sink(type = "output", split = FALSE)
[13:36:55.879]         if (TRUE) {
[13:36:55.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.879]         }
[13:36:55.879]         else {
[13:36:55.879]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.879]         }
[13:36:55.879]         base::close(...future.stdout)
[13:36:55.879]         ...future.stdout <- NULL
[13:36:55.879]     }
[13:36:55.879]     ...future.result$conditions <- ...future.conditions
[13:36:55.879]     ...future.result$finished <- base::Sys.time()
[13:36:55.879]     ...future.result
[13:36:55.879] }
[13:36:55.881] plan(): Setting new future strategy stack:
[13:36:55.881] List of future strategies:
[13:36:55.881] 1. sequential:
[13:36:55.881]    - args: function (..., envir = parent.frame())
[13:36:55.881]    - tweaked: FALSE
[13:36:55.881]    - call: NULL
[13:36:55.881] plan(): nbrOfWorkers() = 1
[13:36:55.882] plan(): Setting new future strategy stack:
[13:36:55.882] List of future strategies:
[13:36:55.882] 1. sequential:
[13:36:55.882]    - args: function (..., envir = parent.frame())
[13:36:55.882]    - tweaked: FALSE
[13:36:55.882]    - call: plan(strategy)
[13:36:55.882] plan(): nbrOfWorkers() = 1
[13:36:55.882] SequentialFuture started (and completed)
[13:36:55.882] - Launch lazy future ... done
[13:36:55.882] run() for ‘SequentialFuture’ ... done
[13:36:55.883] resolved() for ‘SequentialFuture’ ...
[13:36:55.883] - state: ‘finished’
[13:36:55.883] - run: TRUE
[13:36:55.883] - result: ‘FutureResult’
[13:36:55.883] resolved() for ‘SequentialFuture’ ... done
[13:36:55.883] Future #1
[13:36:55.883] resolved() for ‘SequentialFuture’ ...
[13:36:55.883] - state: ‘finished’
[13:36:55.883] - run: TRUE
[13:36:55.883] - result: ‘FutureResult’
[13:36:55.884] resolved() for ‘SequentialFuture’ ... done
[13:36:55.884] A SequentialFuture was resolved
[13:36:55.884]  length: 0 (resolved future 1)
[13:36:55.884] resolve() on list ... DONE
[13:36:55.884] - globals: [1] ‘a’
[13:36:55.884] Resolving futures part of globals (recursively) ... DONE
[13:36:55.885] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[13:36:55.885] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[13:36:55.885] - globals: [1] ‘a’
[13:36:55.885] - packages: [1] ‘future’
[13:36:55.885] getGlobalsAndPackages() ... DONE
[13:36:55.886] run() for ‘Future’ ...
[13:36:55.886] - state: ‘created’
[13:36:55.886] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.886] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.886] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.886]   - Field: ‘label’
[13:36:55.886]   - Field: ‘local’
[13:36:55.886]   - Field: ‘owner’
[13:36:55.886]   - Field: ‘envir’
[13:36:55.887]   - Field: ‘packages’
[13:36:55.887]   - Field: ‘gc’
[13:36:55.887]   - Field: ‘conditions’
[13:36:55.887]   - Field: ‘expr’
[13:36:55.887]   - Field: ‘uuid’
[13:36:55.887]   - Field: ‘seed’
[13:36:55.887]   - Field: ‘version’
[13:36:55.887]   - Field: ‘result’
[13:36:55.887]   - Field: ‘asynchronous’
[13:36:55.887]   - Field: ‘calls’
[13:36:55.887]   - Field: ‘globals’
[13:36:55.887]   - Field: ‘stdout’
[13:36:55.888]   - Field: ‘earlySignal’
[13:36:55.888]   - Field: ‘lazy’
[13:36:55.888]   - Field: ‘state’
[13:36:55.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.888] - Launch lazy future ...
[13:36:55.888] Packages needed by the future expression (n = 1): ‘future’
[13:36:55.888] Packages needed by future strategies (n = 0): <none>
[13:36:55.889] {
[13:36:55.889]     {
[13:36:55.889]         {
[13:36:55.889]             ...future.startTime <- base::Sys.time()
[13:36:55.889]             {
[13:36:55.889]                 {
[13:36:55.889]                   {
[13:36:55.889]                     {
[13:36:55.889]                       base::local({
[13:36:55.889]                         has_future <- base::requireNamespace("future", 
[13:36:55.889]                           quietly = TRUE)
[13:36:55.889]                         if (has_future) {
[13:36:55.889]                           ns <- base::getNamespace("future")
[13:36:55.889]                           version <- ns[[".package"]][["version"]]
[13:36:55.889]                           if (is.null(version)) 
[13:36:55.889]                             version <- utils::packageVersion("future")
[13:36:55.889]                         }
[13:36:55.889]                         else {
[13:36:55.889]                           version <- NULL
[13:36:55.889]                         }
[13:36:55.889]                         if (!has_future || version < "1.8.0") {
[13:36:55.889]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.889]                             "", base::R.version$version.string), 
[13:36:55.889]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:55.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.889]                               "release", "version")], collapse = " "), 
[13:36:55.889]                             hostname = base::Sys.info()[["nodename"]])
[13:36:55.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.889]                             info)
[13:36:55.889]                           info <- base::paste(info, collapse = "; ")
[13:36:55.889]                           if (!has_future) {
[13:36:55.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.889]                               info)
[13:36:55.889]                           }
[13:36:55.889]                           else {
[13:36:55.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.889]                               info, version)
[13:36:55.889]                           }
[13:36:55.889]                           base::stop(msg)
[13:36:55.889]                         }
[13:36:55.889]                       })
[13:36:55.889]                     }
[13:36:55.889]                     base::local({
[13:36:55.889]                       for (pkg in "future") {
[13:36:55.889]                         base::loadNamespace(pkg)
[13:36:55.889]                         base::library(pkg, character.only = TRUE)
[13:36:55.889]                       }
[13:36:55.889]                     })
[13:36:55.889]                   }
[13:36:55.889]                   ...future.strategy.old <- future::plan("list")
[13:36:55.889]                   options(future.plan = NULL)
[13:36:55.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.889]                 }
[13:36:55.889]                 ...future.workdir <- getwd()
[13:36:55.889]             }
[13:36:55.889]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.889]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.889]         }
[13:36:55.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.889]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.889]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.889]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.889]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.889]             base::names(...future.oldOptions))
[13:36:55.889]     }
[13:36:55.889]     if (FALSE) {
[13:36:55.889]     }
[13:36:55.889]     else {
[13:36:55.889]         if (TRUE) {
[13:36:55.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.889]                 open = "w")
[13:36:55.889]         }
[13:36:55.889]         else {
[13:36:55.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.889]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.889]         }
[13:36:55.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.889]             base::sink(type = "output", split = FALSE)
[13:36:55.889]             base::close(...future.stdout)
[13:36:55.889]         }, add = TRUE)
[13:36:55.889]     }
[13:36:55.889]     ...future.frame <- base::sys.nframe()
[13:36:55.889]     ...future.conditions <- base::list()
[13:36:55.889]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.889]     if (FALSE) {
[13:36:55.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.889]     }
[13:36:55.889]     ...future.result <- base::tryCatch({
[13:36:55.889]         base::withCallingHandlers({
[13:36:55.889]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:36:55.889]                 1))
[13:36:55.889]             future::FutureResult(value = ...future.value$value, 
[13:36:55.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.889]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.889]                     ...future.globalenv.names))
[13:36:55.889]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.889]         }, condition = base::local({
[13:36:55.889]             c <- base::c
[13:36:55.889]             inherits <- base::inherits
[13:36:55.889]             invokeRestart <- base::invokeRestart
[13:36:55.889]             length <- base::length
[13:36:55.889]             list <- base::list
[13:36:55.889]             seq.int <- base::seq.int
[13:36:55.889]             signalCondition <- base::signalCondition
[13:36:55.889]             sys.calls <- base::sys.calls
[13:36:55.889]             `[[` <- base::`[[`
[13:36:55.889]             `+` <- base::`+`
[13:36:55.889]             `<<-` <- base::`<<-`
[13:36:55.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.889]                   3L)]
[13:36:55.889]             }
[13:36:55.889]             function(cond) {
[13:36:55.889]                 is_error <- inherits(cond, "error")
[13:36:55.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.889]                   NULL)
[13:36:55.889]                 if (is_error) {
[13:36:55.889]                   sessionInformation <- function() {
[13:36:55.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.889]                       search = base::search(), system = base::Sys.info())
[13:36:55.889]                   }
[13:36:55.889]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.889]                     cond$call), session = sessionInformation(), 
[13:36:55.889]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.889]                   signalCondition(cond)
[13:36:55.889]                 }
[13:36:55.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.889]                 "immediateCondition"))) {
[13:36:55.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.889]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.889]                   if (TRUE && !signal) {
[13:36:55.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.889]                     {
[13:36:55.889]                       inherits <- base::inherits
[13:36:55.889]                       invokeRestart <- base::invokeRestart
[13:36:55.889]                       is.null <- base::is.null
[13:36:55.889]                       muffled <- FALSE
[13:36:55.889]                       if (inherits(cond, "message")) {
[13:36:55.889]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.889]                         if (muffled) 
[13:36:55.889]                           invokeRestart("muffleMessage")
[13:36:55.889]                       }
[13:36:55.889]                       else if (inherits(cond, "warning")) {
[13:36:55.889]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.889]                         if (muffled) 
[13:36:55.889]                           invokeRestart("muffleWarning")
[13:36:55.889]                       }
[13:36:55.889]                       else if (inherits(cond, "condition")) {
[13:36:55.889]                         if (!is.null(pattern)) {
[13:36:55.889]                           computeRestarts <- base::computeRestarts
[13:36:55.889]                           grepl <- base::grepl
[13:36:55.889]                           restarts <- computeRestarts(cond)
[13:36:55.889]                           for (restart in restarts) {
[13:36:55.889]                             name <- restart$name
[13:36:55.889]                             if (is.null(name)) 
[13:36:55.889]                               next
[13:36:55.889]                             if (!grepl(pattern, name)) 
[13:36:55.889]                               next
[13:36:55.889]                             invokeRestart(restart)
[13:36:55.889]                             muffled <- TRUE
[13:36:55.889]                             break
[13:36:55.889]                           }
[13:36:55.889]                         }
[13:36:55.889]                       }
[13:36:55.889]                       invisible(muffled)
[13:36:55.889]                     }
[13:36:55.889]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.889]                   }
[13:36:55.889]                 }
[13:36:55.889]                 else {
[13:36:55.889]                   if (TRUE) {
[13:36:55.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.889]                     {
[13:36:55.889]                       inherits <- base::inherits
[13:36:55.889]                       invokeRestart <- base::invokeRestart
[13:36:55.889]                       is.null <- base::is.null
[13:36:55.889]                       muffled <- FALSE
[13:36:55.889]                       if (inherits(cond, "message")) {
[13:36:55.889]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.889]                         if (muffled) 
[13:36:55.889]                           invokeRestart("muffleMessage")
[13:36:55.889]                       }
[13:36:55.889]                       else if (inherits(cond, "warning")) {
[13:36:55.889]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.889]                         if (muffled) 
[13:36:55.889]                           invokeRestart("muffleWarning")
[13:36:55.889]                       }
[13:36:55.889]                       else if (inherits(cond, "condition")) {
[13:36:55.889]                         if (!is.null(pattern)) {
[13:36:55.889]                           computeRestarts <- base::computeRestarts
[13:36:55.889]                           grepl <- base::grepl
[13:36:55.889]                           restarts <- computeRestarts(cond)
[13:36:55.889]                           for (restart in restarts) {
[13:36:55.889]                             name <- restart$name
[13:36:55.889]                             if (is.null(name)) 
[13:36:55.889]                               next
[13:36:55.889]                             if (!grepl(pattern, name)) 
[13:36:55.889]                               next
[13:36:55.889]                             invokeRestart(restart)
[13:36:55.889]                             muffled <- TRUE
[13:36:55.889]                             break
[13:36:55.889]                           }
[13:36:55.889]                         }
[13:36:55.889]                       }
[13:36:55.889]                       invisible(muffled)
[13:36:55.889]                     }
[13:36:55.889]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.889]                   }
[13:36:55.889]                 }
[13:36:55.889]             }
[13:36:55.889]         }))
[13:36:55.889]     }, error = function(ex) {
[13:36:55.889]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.889]                 ...future.rng), started = ...future.startTime, 
[13:36:55.889]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.889]             version = "1.8"), class = "FutureResult")
[13:36:55.889]     }, finally = {
[13:36:55.889]         if (!identical(...future.workdir, getwd())) 
[13:36:55.889]             setwd(...future.workdir)
[13:36:55.889]         {
[13:36:55.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.889]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.889]             }
[13:36:55.889]             base::options(...future.oldOptions)
[13:36:55.889]             if (.Platform$OS.type == "windows") {
[13:36:55.889]                 old_names <- names(...future.oldEnvVars)
[13:36:55.889]                 envs <- base::Sys.getenv()
[13:36:55.889]                 names <- names(envs)
[13:36:55.889]                 common <- intersect(names, old_names)
[13:36:55.889]                 added <- setdiff(names, old_names)
[13:36:55.889]                 removed <- setdiff(old_names, names)
[13:36:55.889]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.889]                   envs[common]]
[13:36:55.889]                 NAMES <- toupper(changed)
[13:36:55.889]                 args <- list()
[13:36:55.889]                 for (kk in seq_along(NAMES)) {
[13:36:55.889]                   name <- changed[[kk]]
[13:36:55.889]                   NAME <- NAMES[[kk]]
[13:36:55.889]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.889]                     next
[13:36:55.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.889]                 }
[13:36:55.889]                 NAMES <- toupper(added)
[13:36:55.889]                 for (kk in seq_along(NAMES)) {
[13:36:55.889]                   name <- added[[kk]]
[13:36:55.889]                   NAME <- NAMES[[kk]]
[13:36:55.889]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.889]                     next
[13:36:55.889]                   args[[name]] <- ""
[13:36:55.889]                 }
[13:36:55.889]                 NAMES <- toupper(removed)
[13:36:55.889]                 for (kk in seq_along(NAMES)) {
[13:36:55.889]                   name <- removed[[kk]]
[13:36:55.889]                   NAME <- NAMES[[kk]]
[13:36:55.889]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.889]                     next
[13:36:55.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.889]                 }
[13:36:55.889]                 if (length(args) > 0) 
[13:36:55.889]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.889]             }
[13:36:55.889]             else {
[13:36:55.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.889]             }
[13:36:55.889]             {
[13:36:55.889]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.889]                   0L) {
[13:36:55.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.889]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.889]                   base::options(opts)
[13:36:55.889]                 }
[13:36:55.889]                 {
[13:36:55.889]                   {
[13:36:55.889]                     NULL
[13:36:55.889]                     RNGkind("Mersenne-Twister")
[13:36:55.889]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.889]                       inherits = FALSE)
[13:36:55.889]                   }
[13:36:55.889]                   options(future.plan = NULL)
[13:36:55.889]                   if (is.na(NA_character_)) 
[13:36:55.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.889]                     .init = FALSE)
[13:36:55.889]                 }
[13:36:55.889]             }
[13:36:55.889]         }
[13:36:55.889]     })
[13:36:55.889]     if (TRUE) {
[13:36:55.889]         base::sink(type = "output", split = FALSE)
[13:36:55.889]         if (TRUE) {
[13:36:55.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.889]         }
[13:36:55.889]         else {
[13:36:55.889]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.889]         }
[13:36:55.889]         base::close(...future.stdout)
[13:36:55.889]         ...future.stdout <- NULL
[13:36:55.889]     }
[13:36:55.889]     ...future.result$conditions <- ...future.conditions
[13:36:55.889]     ...future.result$finished <- base::Sys.time()
[13:36:55.889]     ...future.result
[13:36:55.889] }
[13:36:55.890] assign_globals() ...
[13:36:55.890] List of 1
[13:36:55.890]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c6db065cd0> 
[13:36:55.890]  - attr(*, "where")=List of 1
[13:36:55.890]   ..$ a:<environment: R_EmptyEnv> 
[13:36:55.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.890]  - attr(*, "resolved")= logi TRUE
[13:36:55.890]  - attr(*, "total_size")= num 10592
[13:36:55.890]  - attr(*, "already-done")= logi TRUE
[13:36:55.892] - copied ‘a’ to environment
[13:36:55.893] assign_globals() ... done
[13:36:55.893] plan(): Setting new future strategy stack:
[13:36:55.893] List of future strategies:
[13:36:55.893] 1. sequential:
[13:36:55.893]    - args: function (..., envir = parent.frame())
[13:36:55.893]    - tweaked: FALSE
[13:36:55.893]    - call: NULL
[13:36:55.893] plan(): nbrOfWorkers() = 1
[13:36:55.894] plan(): Setting new future strategy stack:
[13:36:55.894] List of future strategies:
[13:36:55.894] 1. sequential:
[13:36:55.894]    - args: function (..., envir = parent.frame())
[13:36:55.894]    - tweaked: FALSE
[13:36:55.894]    - call: plan(strategy)
[13:36:55.894] plan(): nbrOfWorkers() = 1
[13:36:55.895] SequentialFuture started (and completed)
[13:36:55.895] - Launch lazy future ... done
[13:36:55.895] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.896] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.896] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.897] 
[13:36:55.897] Searching for globals ... DONE
[13:36:55.897] - globals: [0] <none>
[13:36:55.897] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.897] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.897] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.898] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:55.898] Searching for globals ... DONE
[13:36:55.898] Resolving globals: TRUE
[13:36:55.899] Resolving any globals that are futures ...
[13:36:55.899] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:55.899] Resolving any globals that are futures ... DONE
[13:36:55.899] Resolving futures part of globals (recursively) ...
[13:36:55.899] resolve() on list ...
[13:36:55.899]  recursive: 99
[13:36:55.899]  length: 1
[13:36:55.899]  elements: ‘a’
[13:36:55.900] run() for ‘Future’ ...
[13:36:55.900] - state: ‘created’
[13:36:55.900] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.900] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.900] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.900]   - Field: ‘label’
[13:36:55.900]   - Field: ‘local’
[13:36:55.900]   - Field: ‘owner’
[13:36:55.901]   - Field: ‘envir’
[13:36:55.901]   - Field: ‘packages’
[13:36:55.901]   - Field: ‘gc’
[13:36:55.901]   - Field: ‘conditions’
[13:36:55.901]   - Field: ‘expr’
[13:36:55.901]   - Field: ‘uuid’
[13:36:55.901]   - Field: ‘seed’
[13:36:55.901]   - Field: ‘version’
[13:36:55.901]   - Field: ‘result’
[13:36:55.901]   - Field: ‘asynchronous’
[13:36:55.901]   - Field: ‘calls’
[13:36:55.901]   - Field: ‘globals’
[13:36:55.902]   - Field: ‘stdout’
[13:36:55.902]   - Field: ‘earlySignal’
[13:36:55.902]   - Field: ‘lazy’
[13:36:55.902]   - Field: ‘state’
[13:36:55.902] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.902] - Launch lazy future ...
[13:36:55.902] Packages needed by the future expression (n = 0): <none>
[13:36:55.902] Packages needed by future strategies (n = 0): <none>
[13:36:55.903] {
[13:36:55.903]     {
[13:36:55.903]         {
[13:36:55.903]             ...future.startTime <- base::Sys.time()
[13:36:55.903]             {
[13:36:55.903]                 {
[13:36:55.903]                   {
[13:36:55.903]                     base::local({
[13:36:55.903]                       has_future <- base::requireNamespace("future", 
[13:36:55.903]                         quietly = TRUE)
[13:36:55.903]                       if (has_future) {
[13:36:55.903]                         ns <- base::getNamespace("future")
[13:36:55.903]                         version <- ns[[".package"]][["version"]]
[13:36:55.903]                         if (is.null(version)) 
[13:36:55.903]                           version <- utils::packageVersion("future")
[13:36:55.903]                       }
[13:36:55.903]                       else {
[13:36:55.903]                         version <- NULL
[13:36:55.903]                       }
[13:36:55.903]                       if (!has_future || version < "1.8.0") {
[13:36:55.903]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.903]                           "", base::R.version$version.string), 
[13:36:55.903]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.903]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.903]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.903]                             "release", "version")], collapse = " "), 
[13:36:55.903]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.903]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.903]                           info)
[13:36:55.903]                         info <- base::paste(info, collapse = "; ")
[13:36:55.903]                         if (!has_future) {
[13:36:55.903]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.903]                             info)
[13:36:55.903]                         }
[13:36:55.903]                         else {
[13:36:55.903]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.903]                             info, version)
[13:36:55.903]                         }
[13:36:55.903]                         base::stop(msg)
[13:36:55.903]                       }
[13:36:55.903]                     })
[13:36:55.903]                   }
[13:36:55.903]                   ...future.strategy.old <- future::plan("list")
[13:36:55.903]                   options(future.plan = NULL)
[13:36:55.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.903]                 }
[13:36:55.903]                 ...future.workdir <- getwd()
[13:36:55.903]             }
[13:36:55.903]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.903]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.903]         }
[13:36:55.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.903]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.903]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.903]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.903]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.903]             base::names(...future.oldOptions))
[13:36:55.903]     }
[13:36:55.903]     if (FALSE) {
[13:36:55.903]     }
[13:36:55.903]     else {
[13:36:55.903]         if (TRUE) {
[13:36:55.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.903]                 open = "w")
[13:36:55.903]         }
[13:36:55.903]         else {
[13:36:55.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.903]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.903]         }
[13:36:55.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.903]             base::sink(type = "output", split = FALSE)
[13:36:55.903]             base::close(...future.stdout)
[13:36:55.903]         }, add = TRUE)
[13:36:55.903]     }
[13:36:55.903]     ...future.frame <- base::sys.nframe()
[13:36:55.903]     ...future.conditions <- base::list()
[13:36:55.903]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.903]     if (FALSE) {
[13:36:55.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.903]     }
[13:36:55.903]     ...future.result <- base::tryCatch({
[13:36:55.903]         base::withCallingHandlers({
[13:36:55.903]             ...future.value <- base::withVisible(base::local(1))
[13:36:55.903]             future::FutureResult(value = ...future.value$value, 
[13:36:55.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.903]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.903]                     ...future.globalenv.names))
[13:36:55.903]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.903]         }, condition = base::local({
[13:36:55.903]             c <- base::c
[13:36:55.903]             inherits <- base::inherits
[13:36:55.903]             invokeRestart <- base::invokeRestart
[13:36:55.903]             length <- base::length
[13:36:55.903]             list <- base::list
[13:36:55.903]             seq.int <- base::seq.int
[13:36:55.903]             signalCondition <- base::signalCondition
[13:36:55.903]             sys.calls <- base::sys.calls
[13:36:55.903]             `[[` <- base::`[[`
[13:36:55.903]             `+` <- base::`+`
[13:36:55.903]             `<<-` <- base::`<<-`
[13:36:55.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.903]                   3L)]
[13:36:55.903]             }
[13:36:55.903]             function(cond) {
[13:36:55.903]                 is_error <- inherits(cond, "error")
[13:36:55.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.903]                   NULL)
[13:36:55.903]                 if (is_error) {
[13:36:55.903]                   sessionInformation <- function() {
[13:36:55.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.903]                       search = base::search(), system = base::Sys.info())
[13:36:55.903]                   }
[13:36:55.903]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.903]                     cond$call), session = sessionInformation(), 
[13:36:55.903]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.903]                   signalCondition(cond)
[13:36:55.903]                 }
[13:36:55.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.903]                 "immediateCondition"))) {
[13:36:55.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.903]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.903]                   if (TRUE && !signal) {
[13:36:55.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.903]                     {
[13:36:55.903]                       inherits <- base::inherits
[13:36:55.903]                       invokeRestart <- base::invokeRestart
[13:36:55.903]                       is.null <- base::is.null
[13:36:55.903]                       muffled <- FALSE
[13:36:55.903]                       if (inherits(cond, "message")) {
[13:36:55.903]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.903]                         if (muffled) 
[13:36:55.903]                           invokeRestart("muffleMessage")
[13:36:55.903]                       }
[13:36:55.903]                       else if (inherits(cond, "warning")) {
[13:36:55.903]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.903]                         if (muffled) 
[13:36:55.903]                           invokeRestart("muffleWarning")
[13:36:55.903]                       }
[13:36:55.903]                       else if (inherits(cond, "condition")) {
[13:36:55.903]                         if (!is.null(pattern)) {
[13:36:55.903]                           computeRestarts <- base::computeRestarts
[13:36:55.903]                           grepl <- base::grepl
[13:36:55.903]                           restarts <- computeRestarts(cond)
[13:36:55.903]                           for (restart in restarts) {
[13:36:55.903]                             name <- restart$name
[13:36:55.903]                             if (is.null(name)) 
[13:36:55.903]                               next
[13:36:55.903]                             if (!grepl(pattern, name)) 
[13:36:55.903]                               next
[13:36:55.903]                             invokeRestart(restart)
[13:36:55.903]                             muffled <- TRUE
[13:36:55.903]                             break
[13:36:55.903]                           }
[13:36:55.903]                         }
[13:36:55.903]                       }
[13:36:55.903]                       invisible(muffled)
[13:36:55.903]                     }
[13:36:55.903]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.903]                   }
[13:36:55.903]                 }
[13:36:55.903]                 else {
[13:36:55.903]                   if (TRUE) {
[13:36:55.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.903]                     {
[13:36:55.903]                       inherits <- base::inherits
[13:36:55.903]                       invokeRestart <- base::invokeRestart
[13:36:55.903]                       is.null <- base::is.null
[13:36:55.903]                       muffled <- FALSE
[13:36:55.903]                       if (inherits(cond, "message")) {
[13:36:55.903]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.903]                         if (muffled) 
[13:36:55.903]                           invokeRestart("muffleMessage")
[13:36:55.903]                       }
[13:36:55.903]                       else if (inherits(cond, "warning")) {
[13:36:55.903]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.903]                         if (muffled) 
[13:36:55.903]                           invokeRestart("muffleWarning")
[13:36:55.903]                       }
[13:36:55.903]                       else if (inherits(cond, "condition")) {
[13:36:55.903]                         if (!is.null(pattern)) {
[13:36:55.903]                           computeRestarts <- base::computeRestarts
[13:36:55.903]                           grepl <- base::grepl
[13:36:55.903]                           restarts <- computeRestarts(cond)
[13:36:55.903]                           for (restart in restarts) {
[13:36:55.903]                             name <- restart$name
[13:36:55.903]                             if (is.null(name)) 
[13:36:55.903]                               next
[13:36:55.903]                             if (!grepl(pattern, name)) 
[13:36:55.903]                               next
[13:36:55.903]                             invokeRestart(restart)
[13:36:55.903]                             muffled <- TRUE
[13:36:55.903]                             break
[13:36:55.903]                           }
[13:36:55.903]                         }
[13:36:55.903]                       }
[13:36:55.903]                       invisible(muffled)
[13:36:55.903]                     }
[13:36:55.903]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.903]                   }
[13:36:55.903]                 }
[13:36:55.903]             }
[13:36:55.903]         }))
[13:36:55.903]     }, error = function(ex) {
[13:36:55.903]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.903]                 ...future.rng), started = ...future.startTime, 
[13:36:55.903]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.903]             version = "1.8"), class = "FutureResult")
[13:36:55.903]     }, finally = {
[13:36:55.903]         if (!identical(...future.workdir, getwd())) 
[13:36:55.903]             setwd(...future.workdir)
[13:36:55.903]         {
[13:36:55.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.903]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.903]             }
[13:36:55.903]             base::options(...future.oldOptions)
[13:36:55.903]             if (.Platform$OS.type == "windows") {
[13:36:55.903]                 old_names <- names(...future.oldEnvVars)
[13:36:55.903]                 envs <- base::Sys.getenv()
[13:36:55.903]                 names <- names(envs)
[13:36:55.903]                 common <- intersect(names, old_names)
[13:36:55.903]                 added <- setdiff(names, old_names)
[13:36:55.903]                 removed <- setdiff(old_names, names)
[13:36:55.903]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.903]                   envs[common]]
[13:36:55.903]                 NAMES <- toupper(changed)
[13:36:55.903]                 args <- list()
[13:36:55.903]                 for (kk in seq_along(NAMES)) {
[13:36:55.903]                   name <- changed[[kk]]
[13:36:55.903]                   NAME <- NAMES[[kk]]
[13:36:55.903]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.903]                     next
[13:36:55.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.903]                 }
[13:36:55.903]                 NAMES <- toupper(added)
[13:36:55.903]                 for (kk in seq_along(NAMES)) {
[13:36:55.903]                   name <- added[[kk]]
[13:36:55.903]                   NAME <- NAMES[[kk]]
[13:36:55.903]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.903]                     next
[13:36:55.903]                   args[[name]] <- ""
[13:36:55.903]                 }
[13:36:55.903]                 NAMES <- toupper(removed)
[13:36:55.903]                 for (kk in seq_along(NAMES)) {
[13:36:55.903]                   name <- removed[[kk]]
[13:36:55.903]                   NAME <- NAMES[[kk]]
[13:36:55.903]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.903]                     next
[13:36:55.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.903]                 }
[13:36:55.903]                 if (length(args) > 0) 
[13:36:55.903]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.903]             }
[13:36:55.903]             else {
[13:36:55.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.903]             }
[13:36:55.903]             {
[13:36:55.903]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.903]                   0L) {
[13:36:55.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.903]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.903]                   base::options(opts)
[13:36:55.903]                 }
[13:36:55.903]                 {
[13:36:55.903]                   {
[13:36:55.903]                     NULL
[13:36:55.903]                     RNGkind("Mersenne-Twister")
[13:36:55.903]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.903]                       inherits = FALSE)
[13:36:55.903]                   }
[13:36:55.903]                   options(future.plan = NULL)
[13:36:55.903]                   if (is.na(NA_character_)) 
[13:36:55.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.903]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.903]                     .init = FALSE)
[13:36:55.903]                 }
[13:36:55.903]             }
[13:36:55.903]         }
[13:36:55.903]     })
[13:36:55.903]     if (TRUE) {
[13:36:55.903]         base::sink(type = "output", split = FALSE)
[13:36:55.903]         if (TRUE) {
[13:36:55.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.903]         }
[13:36:55.903]         else {
[13:36:55.903]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.903]         }
[13:36:55.903]         base::close(...future.stdout)
[13:36:55.903]         ...future.stdout <- NULL
[13:36:55.903]     }
[13:36:55.903]     ...future.result$conditions <- ...future.conditions
[13:36:55.903]     ...future.result$finished <- base::Sys.time()
[13:36:55.903]     ...future.result
[13:36:55.903] }
[13:36:55.904] plan(): Setting new future strategy stack:
[13:36:55.904] List of future strategies:
[13:36:55.904] 1. sequential:
[13:36:55.904]    - args: function (..., envir = parent.frame())
[13:36:55.904]    - tweaked: FALSE
[13:36:55.904]    - call: NULL
[13:36:55.905] plan(): nbrOfWorkers() = 1
[13:36:55.905] plan(): Setting new future strategy stack:
[13:36:55.905] List of future strategies:
[13:36:55.905] 1. sequential:
[13:36:55.905]    - args: function (..., envir = parent.frame())
[13:36:55.905]    - tweaked: FALSE
[13:36:55.905]    - call: plan(strategy)
[13:36:55.906] plan(): nbrOfWorkers() = 1
[13:36:55.906] SequentialFuture started (and completed)
[13:36:55.906] - Launch lazy future ... done
[13:36:55.906] run() for ‘SequentialFuture’ ... done
[13:36:55.906] resolved() for ‘SequentialFuture’ ...
[13:36:55.906] - state: ‘finished’
[13:36:55.906] - run: TRUE
[13:36:55.906] - result: ‘FutureResult’
[13:36:55.907] resolved() for ‘SequentialFuture’ ... done
[13:36:55.907] Future #1
[13:36:55.907] resolved() for ‘SequentialFuture’ ...
[13:36:55.907] - state: ‘finished’
[13:36:55.907] - run: TRUE
[13:36:55.907] - result: ‘FutureResult’
[13:36:55.907] resolved() for ‘SequentialFuture’ ... done
[13:36:55.907] A SequentialFuture was resolved
[13:36:55.907]  length: 0 (resolved future 1)
[13:36:55.907] resolve() on list ... DONE
[13:36:55.908] - globals: [1] ‘a’
[13:36:55.908] Resolving futures part of globals (recursively) ... DONE
[13:36:55.908] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[13:36:55.909] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[13:36:55.909] - globals: [1] ‘a’
[13:36:55.909] - packages: [1] ‘future’
[13:36:55.909] getGlobalsAndPackages() ... DONE
[13:36:55.909] run() for ‘Future’ ...
[13:36:55.909] - state: ‘created’
[13:36:55.909] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.910] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.910] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.910]   - Field: ‘label’
[13:36:55.910]   - Field: ‘local’
[13:36:55.910]   - Field: ‘owner’
[13:36:55.910]   - Field: ‘envir’
[13:36:55.910]   - Field: ‘packages’
[13:36:55.910]   - Field: ‘gc’
[13:36:55.910]   - Field: ‘conditions’
[13:36:55.910]   - Field: ‘expr’
[13:36:55.911]   - Field: ‘uuid’
[13:36:55.911]   - Field: ‘seed’
[13:36:55.911]   - Field: ‘version’
[13:36:55.911]   - Field: ‘result’
[13:36:55.911]   - Field: ‘asynchronous’
[13:36:55.911]   - Field: ‘calls’
[13:36:55.911]   - Field: ‘globals’
[13:36:55.911]   - Field: ‘stdout’
[13:36:55.911]   - Field: ‘earlySignal’
[13:36:55.911]   - Field: ‘lazy’
[13:36:55.911]   - Field: ‘state’
[13:36:55.911] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.912] - Launch lazy future ...
[13:36:55.912] Packages needed by the future expression (n = 1): ‘future’
[13:36:55.912] Packages needed by future strategies (n = 0): <none>
[13:36:55.912] {
[13:36:55.912]     {
[13:36:55.912]         {
[13:36:55.912]             ...future.startTime <- base::Sys.time()
[13:36:55.912]             {
[13:36:55.912]                 {
[13:36:55.912]                   {
[13:36:55.912]                     {
[13:36:55.912]                       base::local({
[13:36:55.912]                         has_future <- base::requireNamespace("future", 
[13:36:55.912]                           quietly = TRUE)
[13:36:55.912]                         if (has_future) {
[13:36:55.912]                           ns <- base::getNamespace("future")
[13:36:55.912]                           version <- ns[[".package"]][["version"]]
[13:36:55.912]                           if (is.null(version)) 
[13:36:55.912]                             version <- utils::packageVersion("future")
[13:36:55.912]                         }
[13:36:55.912]                         else {
[13:36:55.912]                           version <- NULL
[13:36:55.912]                         }
[13:36:55.912]                         if (!has_future || version < "1.8.0") {
[13:36:55.912]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.912]                             "", base::R.version$version.string), 
[13:36:55.912]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:55.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.912]                               "release", "version")], collapse = " "), 
[13:36:55.912]                             hostname = base::Sys.info()[["nodename"]])
[13:36:55.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.912]                             info)
[13:36:55.912]                           info <- base::paste(info, collapse = "; ")
[13:36:55.912]                           if (!has_future) {
[13:36:55.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.912]                               info)
[13:36:55.912]                           }
[13:36:55.912]                           else {
[13:36:55.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.912]                               info, version)
[13:36:55.912]                           }
[13:36:55.912]                           base::stop(msg)
[13:36:55.912]                         }
[13:36:55.912]                       })
[13:36:55.912]                     }
[13:36:55.912]                     base::local({
[13:36:55.912]                       for (pkg in "future") {
[13:36:55.912]                         base::loadNamespace(pkg)
[13:36:55.912]                         base::library(pkg, character.only = TRUE)
[13:36:55.912]                       }
[13:36:55.912]                     })
[13:36:55.912]                   }
[13:36:55.912]                   ...future.strategy.old <- future::plan("list")
[13:36:55.912]                   options(future.plan = NULL)
[13:36:55.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.912]                 }
[13:36:55.912]                 ...future.workdir <- getwd()
[13:36:55.912]             }
[13:36:55.912]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.912]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.912]         }
[13:36:55.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.912]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.912]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.912]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.912]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.912]             base::names(...future.oldOptions))
[13:36:55.912]     }
[13:36:55.912]     if (FALSE) {
[13:36:55.912]     }
[13:36:55.912]     else {
[13:36:55.912]         if (TRUE) {
[13:36:55.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.912]                 open = "w")
[13:36:55.912]         }
[13:36:55.912]         else {
[13:36:55.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.912]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.912]         }
[13:36:55.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.912]             base::sink(type = "output", split = FALSE)
[13:36:55.912]             base::close(...future.stdout)
[13:36:55.912]         }, add = TRUE)
[13:36:55.912]     }
[13:36:55.912]     ...future.frame <- base::sys.nframe()
[13:36:55.912]     ...future.conditions <- base::list()
[13:36:55.912]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.912]     if (FALSE) {
[13:36:55.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.912]     }
[13:36:55.912]     ...future.result <- base::tryCatch({
[13:36:55.912]         base::withCallingHandlers({
[13:36:55.912]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:36:55.912]                 1))
[13:36:55.912]             future::FutureResult(value = ...future.value$value, 
[13:36:55.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.912]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.912]                     ...future.globalenv.names))
[13:36:55.912]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.912]         }, condition = base::local({
[13:36:55.912]             c <- base::c
[13:36:55.912]             inherits <- base::inherits
[13:36:55.912]             invokeRestart <- base::invokeRestart
[13:36:55.912]             length <- base::length
[13:36:55.912]             list <- base::list
[13:36:55.912]             seq.int <- base::seq.int
[13:36:55.912]             signalCondition <- base::signalCondition
[13:36:55.912]             sys.calls <- base::sys.calls
[13:36:55.912]             `[[` <- base::`[[`
[13:36:55.912]             `+` <- base::`+`
[13:36:55.912]             `<<-` <- base::`<<-`
[13:36:55.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.912]                   3L)]
[13:36:55.912]             }
[13:36:55.912]             function(cond) {
[13:36:55.912]                 is_error <- inherits(cond, "error")
[13:36:55.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.912]                   NULL)
[13:36:55.912]                 if (is_error) {
[13:36:55.912]                   sessionInformation <- function() {
[13:36:55.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.912]                       search = base::search(), system = base::Sys.info())
[13:36:55.912]                   }
[13:36:55.912]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.912]                     cond$call), session = sessionInformation(), 
[13:36:55.912]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.912]                   signalCondition(cond)
[13:36:55.912]                 }
[13:36:55.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.912]                 "immediateCondition"))) {
[13:36:55.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.912]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.912]                   if (TRUE && !signal) {
[13:36:55.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.912]                     {
[13:36:55.912]                       inherits <- base::inherits
[13:36:55.912]                       invokeRestart <- base::invokeRestart
[13:36:55.912]                       is.null <- base::is.null
[13:36:55.912]                       muffled <- FALSE
[13:36:55.912]                       if (inherits(cond, "message")) {
[13:36:55.912]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.912]                         if (muffled) 
[13:36:55.912]                           invokeRestart("muffleMessage")
[13:36:55.912]                       }
[13:36:55.912]                       else if (inherits(cond, "warning")) {
[13:36:55.912]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.912]                         if (muffled) 
[13:36:55.912]                           invokeRestart("muffleWarning")
[13:36:55.912]                       }
[13:36:55.912]                       else if (inherits(cond, "condition")) {
[13:36:55.912]                         if (!is.null(pattern)) {
[13:36:55.912]                           computeRestarts <- base::computeRestarts
[13:36:55.912]                           grepl <- base::grepl
[13:36:55.912]                           restarts <- computeRestarts(cond)
[13:36:55.912]                           for (restart in restarts) {
[13:36:55.912]                             name <- restart$name
[13:36:55.912]                             if (is.null(name)) 
[13:36:55.912]                               next
[13:36:55.912]                             if (!grepl(pattern, name)) 
[13:36:55.912]                               next
[13:36:55.912]                             invokeRestart(restart)
[13:36:55.912]                             muffled <- TRUE
[13:36:55.912]                             break
[13:36:55.912]                           }
[13:36:55.912]                         }
[13:36:55.912]                       }
[13:36:55.912]                       invisible(muffled)
[13:36:55.912]                     }
[13:36:55.912]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.912]                   }
[13:36:55.912]                 }
[13:36:55.912]                 else {
[13:36:55.912]                   if (TRUE) {
[13:36:55.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.912]                     {
[13:36:55.912]                       inherits <- base::inherits
[13:36:55.912]                       invokeRestart <- base::invokeRestart
[13:36:55.912]                       is.null <- base::is.null
[13:36:55.912]                       muffled <- FALSE
[13:36:55.912]                       if (inherits(cond, "message")) {
[13:36:55.912]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.912]                         if (muffled) 
[13:36:55.912]                           invokeRestart("muffleMessage")
[13:36:55.912]                       }
[13:36:55.912]                       else if (inherits(cond, "warning")) {
[13:36:55.912]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.912]                         if (muffled) 
[13:36:55.912]                           invokeRestart("muffleWarning")
[13:36:55.912]                       }
[13:36:55.912]                       else if (inherits(cond, "condition")) {
[13:36:55.912]                         if (!is.null(pattern)) {
[13:36:55.912]                           computeRestarts <- base::computeRestarts
[13:36:55.912]                           grepl <- base::grepl
[13:36:55.912]                           restarts <- computeRestarts(cond)
[13:36:55.912]                           for (restart in restarts) {
[13:36:55.912]                             name <- restart$name
[13:36:55.912]                             if (is.null(name)) 
[13:36:55.912]                               next
[13:36:55.912]                             if (!grepl(pattern, name)) 
[13:36:55.912]                               next
[13:36:55.912]                             invokeRestart(restart)
[13:36:55.912]                             muffled <- TRUE
[13:36:55.912]                             break
[13:36:55.912]                           }
[13:36:55.912]                         }
[13:36:55.912]                       }
[13:36:55.912]                       invisible(muffled)
[13:36:55.912]                     }
[13:36:55.912]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.912]                   }
[13:36:55.912]                 }
[13:36:55.912]             }
[13:36:55.912]         }))
[13:36:55.912]     }, error = function(ex) {
[13:36:55.912]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.912]                 ...future.rng), started = ...future.startTime, 
[13:36:55.912]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.912]             version = "1.8"), class = "FutureResult")
[13:36:55.912]     }, finally = {
[13:36:55.912]         if (!identical(...future.workdir, getwd())) 
[13:36:55.912]             setwd(...future.workdir)
[13:36:55.912]         {
[13:36:55.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.912]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.912]             }
[13:36:55.912]             base::options(...future.oldOptions)
[13:36:55.912]             if (.Platform$OS.type == "windows") {
[13:36:55.912]                 old_names <- names(...future.oldEnvVars)
[13:36:55.912]                 envs <- base::Sys.getenv()
[13:36:55.912]                 names <- names(envs)
[13:36:55.912]                 common <- intersect(names, old_names)
[13:36:55.912]                 added <- setdiff(names, old_names)
[13:36:55.912]                 removed <- setdiff(old_names, names)
[13:36:55.912]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.912]                   envs[common]]
[13:36:55.912]                 NAMES <- toupper(changed)
[13:36:55.912]                 args <- list()
[13:36:55.912]                 for (kk in seq_along(NAMES)) {
[13:36:55.912]                   name <- changed[[kk]]
[13:36:55.912]                   NAME <- NAMES[[kk]]
[13:36:55.912]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.912]                     next
[13:36:55.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.912]                 }
[13:36:55.912]                 NAMES <- toupper(added)
[13:36:55.912]                 for (kk in seq_along(NAMES)) {
[13:36:55.912]                   name <- added[[kk]]
[13:36:55.912]                   NAME <- NAMES[[kk]]
[13:36:55.912]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.912]                     next
[13:36:55.912]                   args[[name]] <- ""
[13:36:55.912]                 }
[13:36:55.912]                 NAMES <- toupper(removed)
[13:36:55.912]                 for (kk in seq_along(NAMES)) {
[13:36:55.912]                   name <- removed[[kk]]
[13:36:55.912]                   NAME <- NAMES[[kk]]
[13:36:55.912]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.912]                     next
[13:36:55.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.912]                 }
[13:36:55.912]                 if (length(args) > 0) 
[13:36:55.912]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.912]             }
[13:36:55.912]             else {
[13:36:55.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.912]             }
[13:36:55.912]             {
[13:36:55.912]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.912]                   0L) {
[13:36:55.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.912]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.912]                   base::options(opts)
[13:36:55.912]                 }
[13:36:55.912]                 {
[13:36:55.912]                   {
[13:36:55.912]                     NULL
[13:36:55.912]                     RNGkind("Mersenne-Twister")
[13:36:55.912]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.912]                       inherits = FALSE)
[13:36:55.912]                   }
[13:36:55.912]                   options(future.plan = NULL)
[13:36:55.912]                   if (is.na(NA_character_)) 
[13:36:55.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.912]                     .init = FALSE)
[13:36:55.912]                 }
[13:36:55.912]             }
[13:36:55.912]         }
[13:36:55.912]     })
[13:36:55.912]     if (TRUE) {
[13:36:55.912]         base::sink(type = "output", split = FALSE)
[13:36:55.912]         if (TRUE) {
[13:36:55.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.912]         }
[13:36:55.912]         else {
[13:36:55.912]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.912]         }
[13:36:55.912]         base::close(...future.stdout)
[13:36:55.912]         ...future.stdout <- NULL
[13:36:55.912]     }
[13:36:55.912]     ...future.result$conditions <- ...future.conditions
[13:36:55.912]     ...future.result$finished <- base::Sys.time()
[13:36:55.912]     ...future.result
[13:36:55.912] }
[13:36:55.914] assign_globals() ...
[13:36:55.914] List of 1
[13:36:55.914]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c6db3883b0> 
[13:36:55.914]  - attr(*, "where")=List of 1
[13:36:55.914]   ..$ a:<environment: R_EmptyEnv> 
[13:36:55.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.914]  - attr(*, "resolved")= logi TRUE
[13:36:55.914]  - attr(*, "total_size")= num 10592
[13:36:55.914]  - attr(*, "already-done")= logi TRUE
[13:36:55.916] - copied ‘a’ to environment
[13:36:55.916] assign_globals() ... done
[13:36:55.916] plan(): Setting new future strategy stack:
[13:36:55.917] List of future strategies:
[13:36:55.917] 1. sequential:
[13:36:55.917]    - args: function (..., envir = parent.frame())
[13:36:55.917]    - tweaked: FALSE
[13:36:55.917]    - call: NULL
[13:36:55.917] plan(): nbrOfWorkers() = 1
[13:36:55.918] plan(): Setting new future strategy stack:
[13:36:55.918] List of future strategies:
[13:36:55.918] 1. sequential:
[13:36:55.918]    - args: function (..., envir = parent.frame())
[13:36:55.918]    - tweaked: FALSE
[13:36:55.918]    - call: plan(strategy)
[13:36:55.918] plan(): nbrOfWorkers() = 1
[13:36:55.918] SequentialFuture started (and completed)
[13:36:55.918] - Launch lazy future ... done
[13:36:55.918] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.919] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.919] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:55.921] - globals found: [2] ‘{’, ‘pkg’
[13:36:55.921] Searching for globals ... DONE
[13:36:55.921] Resolving globals: TRUE
[13:36:55.921] Resolving any globals that are futures ...
[13:36:55.921] - globals: [2] ‘{’, ‘pkg’
[13:36:55.921] Resolving any globals that are futures ... DONE
[13:36:55.921] Resolving futures part of globals (recursively) ...
[13:36:55.922] resolve() on list ...
[13:36:55.922]  recursive: 99
[13:36:55.922]  length: 1
[13:36:55.922]  elements: ‘pkg’
[13:36:55.922]  length: 0 (resolved future 1)
[13:36:55.922] resolve() on list ... DONE
[13:36:55.922] - globals: [1] ‘pkg’
[13:36:55.922] Resolving futures part of globals (recursively) ... DONE
[13:36:55.922] The total size of the 1 globals is 112 bytes (112 bytes)
[13:36:55.923] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:36:55.923] - globals: [1] ‘pkg’
[13:36:55.923] 
[13:36:55.923] getGlobalsAndPackages() ... DONE
[13:36:55.923] Packages needed by the future expression (n = 0): <none>
[13:36:55.923] Packages needed by future strategies (n = 0): <none>
[13:36:55.924] {
[13:36:55.924]     {
[13:36:55.924]         {
[13:36:55.924]             ...future.startTime <- base::Sys.time()
[13:36:55.924]             {
[13:36:55.924]                 {
[13:36:55.924]                   {
[13:36:55.924]                     base::local({
[13:36:55.924]                       has_future <- base::requireNamespace("future", 
[13:36:55.924]                         quietly = TRUE)
[13:36:55.924]                       if (has_future) {
[13:36:55.924]                         ns <- base::getNamespace("future")
[13:36:55.924]                         version <- ns[[".package"]][["version"]]
[13:36:55.924]                         if (is.null(version)) 
[13:36:55.924]                           version <- utils::packageVersion("future")
[13:36:55.924]                       }
[13:36:55.924]                       else {
[13:36:55.924]                         version <- NULL
[13:36:55.924]                       }
[13:36:55.924]                       if (!has_future || version < "1.8.0") {
[13:36:55.924]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.924]                           "", base::R.version$version.string), 
[13:36:55.924]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.924]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.924]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.924]                             "release", "version")], collapse = " "), 
[13:36:55.924]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.924]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.924]                           info)
[13:36:55.924]                         info <- base::paste(info, collapse = "; ")
[13:36:55.924]                         if (!has_future) {
[13:36:55.924]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.924]                             info)
[13:36:55.924]                         }
[13:36:55.924]                         else {
[13:36:55.924]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.924]                             info, version)
[13:36:55.924]                         }
[13:36:55.924]                         base::stop(msg)
[13:36:55.924]                       }
[13:36:55.924]                     })
[13:36:55.924]                   }
[13:36:55.924]                   ...future.strategy.old <- future::plan("list")
[13:36:55.924]                   options(future.plan = NULL)
[13:36:55.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.924]                 }
[13:36:55.924]                 ...future.workdir <- getwd()
[13:36:55.924]             }
[13:36:55.924]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.924]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.924]         }
[13:36:55.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.924]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:55.924]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.924]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.924]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.924]             base::names(...future.oldOptions))
[13:36:55.924]     }
[13:36:55.924]     if (FALSE) {
[13:36:55.924]     }
[13:36:55.924]     else {
[13:36:55.924]         if (TRUE) {
[13:36:55.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.924]                 open = "w")
[13:36:55.924]         }
[13:36:55.924]         else {
[13:36:55.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.924]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.924]         }
[13:36:55.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.924]             base::sink(type = "output", split = FALSE)
[13:36:55.924]             base::close(...future.stdout)
[13:36:55.924]         }, add = TRUE)
[13:36:55.924]     }
[13:36:55.924]     ...future.frame <- base::sys.nframe()
[13:36:55.924]     ...future.conditions <- base::list()
[13:36:55.924]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.924]     if (FALSE) {
[13:36:55.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.924]     }
[13:36:55.924]     ...future.result <- base::tryCatch({
[13:36:55.924]         base::withCallingHandlers({
[13:36:55.924]             ...future.value <- base::withVisible(base::local({
[13:36:55.924]                 pkg
[13:36:55.924]             }))
[13:36:55.924]             future::FutureResult(value = ...future.value$value, 
[13:36:55.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.924]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.924]                     ...future.globalenv.names))
[13:36:55.924]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.924]         }, condition = base::local({
[13:36:55.924]             c <- base::c
[13:36:55.924]             inherits <- base::inherits
[13:36:55.924]             invokeRestart <- base::invokeRestart
[13:36:55.924]             length <- base::length
[13:36:55.924]             list <- base::list
[13:36:55.924]             seq.int <- base::seq.int
[13:36:55.924]             signalCondition <- base::signalCondition
[13:36:55.924]             sys.calls <- base::sys.calls
[13:36:55.924]             `[[` <- base::`[[`
[13:36:55.924]             `+` <- base::`+`
[13:36:55.924]             `<<-` <- base::`<<-`
[13:36:55.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.924]                   3L)]
[13:36:55.924]             }
[13:36:55.924]             function(cond) {
[13:36:55.924]                 is_error <- inherits(cond, "error")
[13:36:55.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.924]                   NULL)
[13:36:55.924]                 if (is_error) {
[13:36:55.924]                   sessionInformation <- function() {
[13:36:55.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.924]                       search = base::search(), system = base::Sys.info())
[13:36:55.924]                   }
[13:36:55.924]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.924]                     cond$call), session = sessionInformation(), 
[13:36:55.924]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.924]                   signalCondition(cond)
[13:36:55.924]                 }
[13:36:55.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.924]                 "immediateCondition"))) {
[13:36:55.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.924]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.924]                   if (TRUE && !signal) {
[13:36:55.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.924]                     {
[13:36:55.924]                       inherits <- base::inherits
[13:36:55.924]                       invokeRestart <- base::invokeRestart
[13:36:55.924]                       is.null <- base::is.null
[13:36:55.924]                       muffled <- FALSE
[13:36:55.924]                       if (inherits(cond, "message")) {
[13:36:55.924]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.924]                         if (muffled) 
[13:36:55.924]                           invokeRestart("muffleMessage")
[13:36:55.924]                       }
[13:36:55.924]                       else if (inherits(cond, "warning")) {
[13:36:55.924]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.924]                         if (muffled) 
[13:36:55.924]                           invokeRestart("muffleWarning")
[13:36:55.924]                       }
[13:36:55.924]                       else if (inherits(cond, "condition")) {
[13:36:55.924]                         if (!is.null(pattern)) {
[13:36:55.924]                           computeRestarts <- base::computeRestarts
[13:36:55.924]                           grepl <- base::grepl
[13:36:55.924]                           restarts <- computeRestarts(cond)
[13:36:55.924]                           for (restart in restarts) {
[13:36:55.924]                             name <- restart$name
[13:36:55.924]                             if (is.null(name)) 
[13:36:55.924]                               next
[13:36:55.924]                             if (!grepl(pattern, name)) 
[13:36:55.924]                               next
[13:36:55.924]                             invokeRestart(restart)
[13:36:55.924]                             muffled <- TRUE
[13:36:55.924]                             break
[13:36:55.924]                           }
[13:36:55.924]                         }
[13:36:55.924]                       }
[13:36:55.924]                       invisible(muffled)
[13:36:55.924]                     }
[13:36:55.924]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.924]                   }
[13:36:55.924]                 }
[13:36:55.924]                 else {
[13:36:55.924]                   if (TRUE) {
[13:36:55.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.924]                     {
[13:36:55.924]                       inherits <- base::inherits
[13:36:55.924]                       invokeRestart <- base::invokeRestart
[13:36:55.924]                       is.null <- base::is.null
[13:36:55.924]                       muffled <- FALSE
[13:36:55.924]                       if (inherits(cond, "message")) {
[13:36:55.924]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.924]                         if (muffled) 
[13:36:55.924]                           invokeRestart("muffleMessage")
[13:36:55.924]                       }
[13:36:55.924]                       else if (inherits(cond, "warning")) {
[13:36:55.924]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.924]                         if (muffled) 
[13:36:55.924]                           invokeRestart("muffleWarning")
[13:36:55.924]                       }
[13:36:55.924]                       else if (inherits(cond, "condition")) {
[13:36:55.924]                         if (!is.null(pattern)) {
[13:36:55.924]                           computeRestarts <- base::computeRestarts
[13:36:55.924]                           grepl <- base::grepl
[13:36:55.924]                           restarts <- computeRestarts(cond)
[13:36:55.924]                           for (restart in restarts) {
[13:36:55.924]                             name <- restart$name
[13:36:55.924]                             if (is.null(name)) 
[13:36:55.924]                               next
[13:36:55.924]                             if (!grepl(pattern, name)) 
[13:36:55.924]                               next
[13:36:55.924]                             invokeRestart(restart)
[13:36:55.924]                             muffled <- TRUE
[13:36:55.924]                             break
[13:36:55.924]                           }
[13:36:55.924]                         }
[13:36:55.924]                       }
[13:36:55.924]                       invisible(muffled)
[13:36:55.924]                     }
[13:36:55.924]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.924]                   }
[13:36:55.924]                 }
[13:36:55.924]             }
[13:36:55.924]         }))
[13:36:55.924]     }, error = function(ex) {
[13:36:55.924]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.924]                 ...future.rng), started = ...future.startTime, 
[13:36:55.924]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.924]             version = "1.8"), class = "FutureResult")
[13:36:55.924]     }, finally = {
[13:36:55.924]         if (!identical(...future.workdir, getwd())) 
[13:36:55.924]             setwd(...future.workdir)
[13:36:55.924]         {
[13:36:55.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.924]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.924]             }
[13:36:55.924]             base::options(...future.oldOptions)
[13:36:55.924]             if (.Platform$OS.type == "windows") {
[13:36:55.924]                 old_names <- names(...future.oldEnvVars)
[13:36:55.924]                 envs <- base::Sys.getenv()
[13:36:55.924]                 names <- names(envs)
[13:36:55.924]                 common <- intersect(names, old_names)
[13:36:55.924]                 added <- setdiff(names, old_names)
[13:36:55.924]                 removed <- setdiff(old_names, names)
[13:36:55.924]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.924]                   envs[common]]
[13:36:55.924]                 NAMES <- toupper(changed)
[13:36:55.924]                 args <- list()
[13:36:55.924]                 for (kk in seq_along(NAMES)) {
[13:36:55.924]                   name <- changed[[kk]]
[13:36:55.924]                   NAME <- NAMES[[kk]]
[13:36:55.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.924]                     next
[13:36:55.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.924]                 }
[13:36:55.924]                 NAMES <- toupper(added)
[13:36:55.924]                 for (kk in seq_along(NAMES)) {
[13:36:55.924]                   name <- added[[kk]]
[13:36:55.924]                   NAME <- NAMES[[kk]]
[13:36:55.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.924]                     next
[13:36:55.924]                   args[[name]] <- ""
[13:36:55.924]                 }
[13:36:55.924]                 NAMES <- toupper(removed)
[13:36:55.924]                 for (kk in seq_along(NAMES)) {
[13:36:55.924]                   name <- removed[[kk]]
[13:36:55.924]                   NAME <- NAMES[[kk]]
[13:36:55.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.924]                     next
[13:36:55.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.924]                 }
[13:36:55.924]                 if (length(args) > 0) 
[13:36:55.924]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.924]             }
[13:36:55.924]             else {
[13:36:55.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.924]             }
[13:36:55.924]             {
[13:36:55.924]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.924]                   0L) {
[13:36:55.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.924]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.924]                   base::options(opts)
[13:36:55.924]                 }
[13:36:55.924]                 {
[13:36:55.924]                   {
[13:36:55.924]                     NULL
[13:36:55.924]                     RNGkind("Mersenne-Twister")
[13:36:55.924]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.924]                       inherits = FALSE)
[13:36:55.924]                   }
[13:36:55.924]                   options(future.plan = NULL)
[13:36:55.924]                   if (is.na(NA_character_)) 
[13:36:55.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.924]                     .init = FALSE)
[13:36:55.924]                 }
[13:36:55.924]             }
[13:36:55.924]         }
[13:36:55.924]     })
[13:36:55.924]     if (TRUE) {
[13:36:55.924]         base::sink(type = "output", split = FALSE)
[13:36:55.924]         if (TRUE) {
[13:36:55.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.924]         }
[13:36:55.924]         else {
[13:36:55.924]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.924]         }
[13:36:55.924]         base::close(...future.stdout)
[13:36:55.924]         ...future.stdout <- NULL
[13:36:55.924]     }
[13:36:55.924]     ...future.result$conditions <- ...future.conditions
[13:36:55.924]     ...future.result$finished <- base::Sys.time()
[13:36:55.924]     ...future.result
[13:36:55.924] }
[13:36:55.925] assign_globals() ...
[13:36:55.925] List of 1
[13:36:55.925]  $ pkg: chr "foo"
[13:36:55.925]  - attr(*, "where")=List of 1
[13:36:55.925]   ..$ pkg:<environment: R_EmptyEnv> 
[13:36:55.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.925]  - attr(*, "resolved")= logi TRUE
[13:36:55.925]  - attr(*, "total_size")= num 112
[13:36:55.927] - copied ‘pkg’ to environment
[13:36:55.927] assign_globals() ... done
[13:36:55.928] plan(): Setting new future strategy stack:
[13:36:55.928] List of future strategies:
[13:36:55.928] 1. sequential:
[13:36:55.928]    - args: function (..., envir = parent.frame())
[13:36:55.928]    - tweaked: FALSE
[13:36:55.928]    - call: NULL
[13:36:55.928] plan(): nbrOfWorkers() = 1
[13:36:55.929] plan(): Setting new future strategy stack:
[13:36:55.929] List of future strategies:
[13:36:55.929] 1. sequential:
[13:36:55.929]    - args: function (..., envir = parent.frame())
[13:36:55.929]    - tweaked: FALSE
[13:36:55.929]    - call: plan(strategy)
[13:36:55.929] plan(): nbrOfWorkers() = 1
[13:36:55.929] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.930] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.930] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:55.932] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:55.932] Searching for globals ... DONE
[13:36:55.932] Resolving globals: TRUE
[13:36:55.932] Resolving any globals that are futures ...
[13:36:55.933] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:55.933] Resolving any globals that are futures ... DONE
[13:36:55.933] Resolving futures part of globals (recursively) ...
[13:36:55.933] resolve() on list ...
[13:36:55.933]  recursive: 99
[13:36:55.933]  length: 1
[13:36:55.933]  elements: ‘a’
[13:36:55.933]  length: 0 (resolved future 1)
[13:36:55.934] resolve() on list ... DONE
[13:36:55.934] - globals: [1] ‘a’
[13:36:55.934] Resolving futures part of globals (recursively) ... DONE
[13:36:55.934] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:55.934] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:55.934] - globals: [1] ‘a’
[13:36:55.934] 
[13:36:55.934] getGlobalsAndPackages() ... DONE
[13:36:55.935] run() for ‘Future’ ...
[13:36:55.935] - state: ‘created’
[13:36:55.935] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.935] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.935] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.935]   - Field: ‘label’
[13:36:55.935]   - Field: ‘local’
[13:36:55.936]   - Field: ‘owner’
[13:36:55.936]   - Field: ‘envir’
[13:36:55.936]   - Field: ‘packages’
[13:36:55.936]   - Field: ‘gc’
[13:36:55.936]   - Field: ‘conditions’
[13:36:55.936]   - Field: ‘expr’
[13:36:55.936]   - Field: ‘uuid’
[13:36:55.936]   - Field: ‘seed’
[13:36:55.936]   - Field: ‘version’
[13:36:55.936]   - Field: ‘result’
[13:36:55.936]   - Field: ‘asynchronous’
[13:36:55.936]   - Field: ‘calls’
[13:36:55.937]   - Field: ‘globals’
[13:36:55.937]   - Field: ‘stdout’
[13:36:55.937]   - Field: ‘earlySignal’
[13:36:55.937]   - Field: ‘lazy’
[13:36:55.937]   - Field: ‘state’
[13:36:55.937] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.937] - Launch lazy future ...
[13:36:55.937] Packages needed by the future expression (n = 0): <none>
[13:36:55.937] Packages needed by future strategies (n = 0): <none>
[13:36:55.938] {
[13:36:55.938]     {
[13:36:55.938]         {
[13:36:55.938]             ...future.startTime <- base::Sys.time()
[13:36:55.938]             {
[13:36:55.938]                 {
[13:36:55.938]                   {
[13:36:55.938]                     base::local({
[13:36:55.938]                       has_future <- base::requireNamespace("future", 
[13:36:55.938]                         quietly = TRUE)
[13:36:55.938]                       if (has_future) {
[13:36:55.938]                         ns <- base::getNamespace("future")
[13:36:55.938]                         version <- ns[[".package"]][["version"]]
[13:36:55.938]                         if (is.null(version)) 
[13:36:55.938]                           version <- utils::packageVersion("future")
[13:36:55.938]                       }
[13:36:55.938]                       else {
[13:36:55.938]                         version <- NULL
[13:36:55.938]                       }
[13:36:55.938]                       if (!has_future || version < "1.8.0") {
[13:36:55.938]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.938]                           "", base::R.version$version.string), 
[13:36:55.938]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.938]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.938]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.938]                             "release", "version")], collapse = " "), 
[13:36:55.938]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.938]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.938]                           info)
[13:36:55.938]                         info <- base::paste(info, collapse = "; ")
[13:36:55.938]                         if (!has_future) {
[13:36:55.938]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.938]                             info)
[13:36:55.938]                         }
[13:36:55.938]                         else {
[13:36:55.938]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.938]                             info, version)
[13:36:55.938]                         }
[13:36:55.938]                         base::stop(msg)
[13:36:55.938]                       }
[13:36:55.938]                     })
[13:36:55.938]                   }
[13:36:55.938]                   ...future.strategy.old <- future::plan("list")
[13:36:55.938]                   options(future.plan = NULL)
[13:36:55.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.938]                 }
[13:36:55.938]                 ...future.workdir <- getwd()
[13:36:55.938]             }
[13:36:55.938]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.938]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.938]         }
[13:36:55.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.938]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:55.938]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.938]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.938]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.938]             base::names(...future.oldOptions))
[13:36:55.938]     }
[13:36:55.938]     if (FALSE) {
[13:36:55.938]     }
[13:36:55.938]     else {
[13:36:55.938]         if (TRUE) {
[13:36:55.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.938]                 open = "w")
[13:36:55.938]         }
[13:36:55.938]         else {
[13:36:55.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.938]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.938]         }
[13:36:55.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.938]             base::sink(type = "output", split = FALSE)
[13:36:55.938]             base::close(...future.stdout)
[13:36:55.938]         }, add = TRUE)
[13:36:55.938]     }
[13:36:55.938]     ...future.frame <- base::sys.nframe()
[13:36:55.938]     ...future.conditions <- base::list()
[13:36:55.938]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.938]     if (FALSE) {
[13:36:55.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.938]     }
[13:36:55.938]     ...future.result <- base::tryCatch({
[13:36:55.938]         base::withCallingHandlers({
[13:36:55.938]             ...future.value <- base::withVisible(base::local({
[13:36:55.938]                 b <- a
[13:36:55.938]                 a <- 2
[13:36:55.938]                 a * b
[13:36:55.938]             }))
[13:36:55.938]             future::FutureResult(value = ...future.value$value, 
[13:36:55.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.938]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.938]                     ...future.globalenv.names))
[13:36:55.938]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.938]         }, condition = base::local({
[13:36:55.938]             c <- base::c
[13:36:55.938]             inherits <- base::inherits
[13:36:55.938]             invokeRestart <- base::invokeRestart
[13:36:55.938]             length <- base::length
[13:36:55.938]             list <- base::list
[13:36:55.938]             seq.int <- base::seq.int
[13:36:55.938]             signalCondition <- base::signalCondition
[13:36:55.938]             sys.calls <- base::sys.calls
[13:36:55.938]             `[[` <- base::`[[`
[13:36:55.938]             `+` <- base::`+`
[13:36:55.938]             `<<-` <- base::`<<-`
[13:36:55.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.938]                   3L)]
[13:36:55.938]             }
[13:36:55.938]             function(cond) {
[13:36:55.938]                 is_error <- inherits(cond, "error")
[13:36:55.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.938]                   NULL)
[13:36:55.938]                 if (is_error) {
[13:36:55.938]                   sessionInformation <- function() {
[13:36:55.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.938]                       search = base::search(), system = base::Sys.info())
[13:36:55.938]                   }
[13:36:55.938]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.938]                     cond$call), session = sessionInformation(), 
[13:36:55.938]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.938]                   signalCondition(cond)
[13:36:55.938]                 }
[13:36:55.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.938]                 "immediateCondition"))) {
[13:36:55.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.938]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.938]                   if (TRUE && !signal) {
[13:36:55.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.938]                     {
[13:36:55.938]                       inherits <- base::inherits
[13:36:55.938]                       invokeRestart <- base::invokeRestart
[13:36:55.938]                       is.null <- base::is.null
[13:36:55.938]                       muffled <- FALSE
[13:36:55.938]                       if (inherits(cond, "message")) {
[13:36:55.938]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.938]                         if (muffled) 
[13:36:55.938]                           invokeRestart("muffleMessage")
[13:36:55.938]                       }
[13:36:55.938]                       else if (inherits(cond, "warning")) {
[13:36:55.938]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.938]                         if (muffled) 
[13:36:55.938]                           invokeRestart("muffleWarning")
[13:36:55.938]                       }
[13:36:55.938]                       else if (inherits(cond, "condition")) {
[13:36:55.938]                         if (!is.null(pattern)) {
[13:36:55.938]                           computeRestarts <- base::computeRestarts
[13:36:55.938]                           grepl <- base::grepl
[13:36:55.938]                           restarts <- computeRestarts(cond)
[13:36:55.938]                           for (restart in restarts) {
[13:36:55.938]                             name <- restart$name
[13:36:55.938]                             if (is.null(name)) 
[13:36:55.938]                               next
[13:36:55.938]                             if (!grepl(pattern, name)) 
[13:36:55.938]                               next
[13:36:55.938]                             invokeRestart(restart)
[13:36:55.938]                             muffled <- TRUE
[13:36:55.938]                             break
[13:36:55.938]                           }
[13:36:55.938]                         }
[13:36:55.938]                       }
[13:36:55.938]                       invisible(muffled)
[13:36:55.938]                     }
[13:36:55.938]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.938]                   }
[13:36:55.938]                 }
[13:36:55.938]                 else {
[13:36:55.938]                   if (TRUE) {
[13:36:55.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.938]                     {
[13:36:55.938]                       inherits <- base::inherits
[13:36:55.938]                       invokeRestart <- base::invokeRestart
[13:36:55.938]                       is.null <- base::is.null
[13:36:55.938]                       muffled <- FALSE
[13:36:55.938]                       if (inherits(cond, "message")) {
[13:36:55.938]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.938]                         if (muffled) 
[13:36:55.938]                           invokeRestart("muffleMessage")
[13:36:55.938]                       }
[13:36:55.938]                       else if (inherits(cond, "warning")) {
[13:36:55.938]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.938]                         if (muffled) 
[13:36:55.938]                           invokeRestart("muffleWarning")
[13:36:55.938]                       }
[13:36:55.938]                       else if (inherits(cond, "condition")) {
[13:36:55.938]                         if (!is.null(pattern)) {
[13:36:55.938]                           computeRestarts <- base::computeRestarts
[13:36:55.938]                           grepl <- base::grepl
[13:36:55.938]                           restarts <- computeRestarts(cond)
[13:36:55.938]                           for (restart in restarts) {
[13:36:55.938]                             name <- restart$name
[13:36:55.938]                             if (is.null(name)) 
[13:36:55.938]                               next
[13:36:55.938]                             if (!grepl(pattern, name)) 
[13:36:55.938]                               next
[13:36:55.938]                             invokeRestart(restart)
[13:36:55.938]                             muffled <- TRUE
[13:36:55.938]                             break
[13:36:55.938]                           }
[13:36:55.938]                         }
[13:36:55.938]                       }
[13:36:55.938]                       invisible(muffled)
[13:36:55.938]                     }
[13:36:55.938]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.938]                   }
[13:36:55.938]                 }
[13:36:55.938]             }
[13:36:55.938]         }))
[13:36:55.938]     }, error = function(ex) {
[13:36:55.938]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.938]                 ...future.rng), started = ...future.startTime, 
[13:36:55.938]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.938]             version = "1.8"), class = "FutureResult")
[13:36:55.938]     }, finally = {
[13:36:55.938]         if (!identical(...future.workdir, getwd())) 
[13:36:55.938]             setwd(...future.workdir)
[13:36:55.938]         {
[13:36:55.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.938]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.938]             }
[13:36:55.938]             base::options(...future.oldOptions)
[13:36:55.938]             if (.Platform$OS.type == "windows") {
[13:36:55.938]                 old_names <- names(...future.oldEnvVars)
[13:36:55.938]                 envs <- base::Sys.getenv()
[13:36:55.938]                 names <- names(envs)
[13:36:55.938]                 common <- intersect(names, old_names)
[13:36:55.938]                 added <- setdiff(names, old_names)
[13:36:55.938]                 removed <- setdiff(old_names, names)
[13:36:55.938]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.938]                   envs[common]]
[13:36:55.938]                 NAMES <- toupper(changed)
[13:36:55.938]                 args <- list()
[13:36:55.938]                 for (kk in seq_along(NAMES)) {
[13:36:55.938]                   name <- changed[[kk]]
[13:36:55.938]                   NAME <- NAMES[[kk]]
[13:36:55.938]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.938]                     next
[13:36:55.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.938]                 }
[13:36:55.938]                 NAMES <- toupper(added)
[13:36:55.938]                 for (kk in seq_along(NAMES)) {
[13:36:55.938]                   name <- added[[kk]]
[13:36:55.938]                   NAME <- NAMES[[kk]]
[13:36:55.938]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.938]                     next
[13:36:55.938]                   args[[name]] <- ""
[13:36:55.938]                 }
[13:36:55.938]                 NAMES <- toupper(removed)
[13:36:55.938]                 for (kk in seq_along(NAMES)) {
[13:36:55.938]                   name <- removed[[kk]]
[13:36:55.938]                   NAME <- NAMES[[kk]]
[13:36:55.938]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.938]                     next
[13:36:55.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.938]                 }
[13:36:55.938]                 if (length(args) > 0) 
[13:36:55.938]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.938]             }
[13:36:55.938]             else {
[13:36:55.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.938]             }
[13:36:55.938]             {
[13:36:55.938]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.938]                   0L) {
[13:36:55.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.938]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.938]                   base::options(opts)
[13:36:55.938]                 }
[13:36:55.938]                 {
[13:36:55.938]                   {
[13:36:55.938]                     NULL
[13:36:55.938]                     RNGkind("Mersenne-Twister")
[13:36:55.938]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.938]                       inherits = FALSE)
[13:36:55.938]                   }
[13:36:55.938]                   options(future.plan = NULL)
[13:36:55.938]                   if (is.na(NA_character_)) 
[13:36:55.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.938]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.938]                     .init = FALSE)
[13:36:55.938]                 }
[13:36:55.938]             }
[13:36:55.938]         }
[13:36:55.938]     })
[13:36:55.938]     if (TRUE) {
[13:36:55.938]         base::sink(type = "output", split = FALSE)
[13:36:55.938]         if (TRUE) {
[13:36:55.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.938]         }
[13:36:55.938]         else {
[13:36:55.938]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.938]         }
[13:36:55.938]         base::close(...future.stdout)
[13:36:55.938]         ...future.stdout <- NULL
[13:36:55.938]     }
[13:36:55.938]     ...future.result$conditions <- ...future.conditions
[13:36:55.938]     ...future.result$finished <- base::Sys.time()
[13:36:55.938]     ...future.result
[13:36:55.938] }
[13:36:55.939] assign_globals() ...
[13:36:55.939] List of 1
[13:36:55.939]  $ a: num 3
[13:36:55.939]  - attr(*, "where")=List of 1
[13:36:55.939]   ..$ a:<environment: R_EmptyEnv> 
[13:36:55.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.939]  - attr(*, "resolved")= logi TRUE
[13:36:55.939]  - attr(*, "total_size")= num 56
[13:36:55.939]  - attr(*, "already-done")= logi TRUE
[13:36:55.942] - copied ‘a’ to environment
[13:36:55.942] assign_globals() ... done
[13:36:55.942] plan(): Setting new future strategy stack:
[13:36:55.942] List of future strategies:
[13:36:55.942] 1. sequential:
[13:36:55.942]    - args: function (..., envir = parent.frame())
[13:36:55.942]    - tweaked: FALSE
[13:36:55.942]    - call: NULL
[13:36:55.942] plan(): nbrOfWorkers() = 1
[13:36:55.943] plan(): Setting new future strategy stack:
[13:36:55.943] List of future strategies:
[13:36:55.943] 1. sequential:
[13:36:55.943]    - args: function (..., envir = parent.frame())
[13:36:55.943]    - tweaked: FALSE
[13:36:55.943]    - call: plan(strategy)
[13:36:55.943] plan(): nbrOfWorkers() = 1
[13:36:55.944] SequentialFuture started (and completed)
[13:36:55.944] - Launch lazy future ... done
[13:36:55.944] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.945] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.945] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:55.947] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:55.947] Searching for globals ... DONE
[13:36:55.947] Resolving globals: TRUE
[13:36:55.947] Resolving any globals that are futures ...
[13:36:55.948] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:55.948] Resolving any globals that are futures ... DONE
[13:36:55.948] Resolving futures part of globals (recursively) ...
[13:36:55.948] resolve() on list ...
[13:36:55.948]  recursive: 99
[13:36:55.948]  length: 1
[13:36:55.948]  elements: ‘a’
[13:36:55.948]  length: 0 (resolved future 1)
[13:36:55.949] resolve() on list ... DONE
[13:36:55.949] - globals: [1] ‘a’
[13:36:55.949] Resolving futures part of globals (recursively) ... DONE
[13:36:55.949] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:55.949] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:55.949] - globals: [1] ‘a’
[13:36:55.949] 
[13:36:55.949] getGlobalsAndPackages() ... DONE
[13:36:55.950] run() for ‘Future’ ...
[13:36:55.950] - state: ‘created’
[13:36:55.950] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.950] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.950] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.950]   - Field: ‘label’
[13:36:55.950]   - Field: ‘local’
[13:36:55.951]   - Field: ‘owner’
[13:36:55.951]   - Field: ‘envir’
[13:36:55.951]   - Field: ‘packages’
[13:36:55.951]   - Field: ‘gc’
[13:36:55.951]   - Field: ‘conditions’
[13:36:55.951]   - Field: ‘expr’
[13:36:55.951]   - Field: ‘uuid’
[13:36:55.951]   - Field: ‘seed’
[13:36:55.951]   - Field: ‘version’
[13:36:55.951]   - Field: ‘result’
[13:36:55.951]   - Field: ‘asynchronous’
[13:36:55.951]   - Field: ‘calls’
[13:36:55.952]   - Field: ‘globals’
[13:36:55.952]   - Field: ‘stdout’
[13:36:55.952]   - Field: ‘earlySignal’
[13:36:55.952]   - Field: ‘lazy’
[13:36:55.952]   - Field: ‘state’
[13:36:55.952] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.952] - Launch lazy future ...
[13:36:55.952] Packages needed by the future expression (n = 0): <none>
[13:36:55.952] Packages needed by future strategies (n = 0): <none>
[13:36:55.953] {
[13:36:55.953]     {
[13:36:55.953]         {
[13:36:55.953]             ...future.startTime <- base::Sys.time()
[13:36:55.953]             {
[13:36:55.953]                 {
[13:36:55.953]                   {
[13:36:55.953]                     base::local({
[13:36:55.953]                       has_future <- base::requireNamespace("future", 
[13:36:55.953]                         quietly = TRUE)
[13:36:55.953]                       if (has_future) {
[13:36:55.953]                         ns <- base::getNamespace("future")
[13:36:55.953]                         version <- ns[[".package"]][["version"]]
[13:36:55.953]                         if (is.null(version)) 
[13:36:55.953]                           version <- utils::packageVersion("future")
[13:36:55.953]                       }
[13:36:55.953]                       else {
[13:36:55.953]                         version <- NULL
[13:36:55.953]                       }
[13:36:55.953]                       if (!has_future || version < "1.8.0") {
[13:36:55.953]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.953]                           "", base::R.version$version.string), 
[13:36:55.953]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.953]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.953]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.953]                             "release", "version")], collapse = " "), 
[13:36:55.953]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.953]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.953]                           info)
[13:36:55.953]                         info <- base::paste(info, collapse = "; ")
[13:36:55.953]                         if (!has_future) {
[13:36:55.953]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.953]                             info)
[13:36:55.953]                         }
[13:36:55.953]                         else {
[13:36:55.953]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.953]                             info, version)
[13:36:55.953]                         }
[13:36:55.953]                         base::stop(msg)
[13:36:55.953]                       }
[13:36:55.953]                     })
[13:36:55.953]                   }
[13:36:55.953]                   ...future.strategy.old <- future::plan("list")
[13:36:55.953]                   options(future.plan = NULL)
[13:36:55.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.953]                 }
[13:36:55.953]                 ...future.workdir <- getwd()
[13:36:55.953]             }
[13:36:55.953]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.953]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.953]         }
[13:36:55.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.953]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:55.953]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.953]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.953]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.953]             base::names(...future.oldOptions))
[13:36:55.953]     }
[13:36:55.953]     if (FALSE) {
[13:36:55.953]     }
[13:36:55.953]     else {
[13:36:55.953]         if (TRUE) {
[13:36:55.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.953]                 open = "w")
[13:36:55.953]         }
[13:36:55.953]         else {
[13:36:55.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.953]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.953]         }
[13:36:55.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.953]             base::sink(type = "output", split = FALSE)
[13:36:55.953]             base::close(...future.stdout)
[13:36:55.953]         }, add = TRUE)
[13:36:55.953]     }
[13:36:55.953]     ...future.frame <- base::sys.nframe()
[13:36:55.953]     ...future.conditions <- base::list()
[13:36:55.953]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.953]     if (FALSE) {
[13:36:55.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.953]     }
[13:36:55.953]     ...future.result <- base::tryCatch({
[13:36:55.953]         base::withCallingHandlers({
[13:36:55.953]             ...future.value <- base::withVisible(base::local({
[13:36:55.953]                 b <- a
[13:36:55.953]                 a <- 2
[13:36:55.953]                 a * b
[13:36:55.953]             }))
[13:36:55.953]             future::FutureResult(value = ...future.value$value, 
[13:36:55.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.953]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.953]                     ...future.globalenv.names))
[13:36:55.953]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.953]         }, condition = base::local({
[13:36:55.953]             c <- base::c
[13:36:55.953]             inherits <- base::inherits
[13:36:55.953]             invokeRestart <- base::invokeRestart
[13:36:55.953]             length <- base::length
[13:36:55.953]             list <- base::list
[13:36:55.953]             seq.int <- base::seq.int
[13:36:55.953]             signalCondition <- base::signalCondition
[13:36:55.953]             sys.calls <- base::sys.calls
[13:36:55.953]             `[[` <- base::`[[`
[13:36:55.953]             `+` <- base::`+`
[13:36:55.953]             `<<-` <- base::`<<-`
[13:36:55.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.953]                   3L)]
[13:36:55.953]             }
[13:36:55.953]             function(cond) {
[13:36:55.953]                 is_error <- inherits(cond, "error")
[13:36:55.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.953]                   NULL)
[13:36:55.953]                 if (is_error) {
[13:36:55.953]                   sessionInformation <- function() {
[13:36:55.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.953]                       search = base::search(), system = base::Sys.info())
[13:36:55.953]                   }
[13:36:55.953]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.953]                     cond$call), session = sessionInformation(), 
[13:36:55.953]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.953]                   signalCondition(cond)
[13:36:55.953]                 }
[13:36:55.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.953]                 "immediateCondition"))) {
[13:36:55.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.953]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.953]                   if (TRUE && !signal) {
[13:36:55.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.953]                     {
[13:36:55.953]                       inherits <- base::inherits
[13:36:55.953]                       invokeRestart <- base::invokeRestart
[13:36:55.953]                       is.null <- base::is.null
[13:36:55.953]                       muffled <- FALSE
[13:36:55.953]                       if (inherits(cond, "message")) {
[13:36:55.953]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.953]                         if (muffled) 
[13:36:55.953]                           invokeRestart("muffleMessage")
[13:36:55.953]                       }
[13:36:55.953]                       else if (inherits(cond, "warning")) {
[13:36:55.953]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.953]                         if (muffled) 
[13:36:55.953]                           invokeRestart("muffleWarning")
[13:36:55.953]                       }
[13:36:55.953]                       else if (inherits(cond, "condition")) {
[13:36:55.953]                         if (!is.null(pattern)) {
[13:36:55.953]                           computeRestarts <- base::computeRestarts
[13:36:55.953]                           grepl <- base::grepl
[13:36:55.953]                           restarts <- computeRestarts(cond)
[13:36:55.953]                           for (restart in restarts) {
[13:36:55.953]                             name <- restart$name
[13:36:55.953]                             if (is.null(name)) 
[13:36:55.953]                               next
[13:36:55.953]                             if (!grepl(pattern, name)) 
[13:36:55.953]                               next
[13:36:55.953]                             invokeRestart(restart)
[13:36:55.953]                             muffled <- TRUE
[13:36:55.953]                             break
[13:36:55.953]                           }
[13:36:55.953]                         }
[13:36:55.953]                       }
[13:36:55.953]                       invisible(muffled)
[13:36:55.953]                     }
[13:36:55.953]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.953]                   }
[13:36:55.953]                 }
[13:36:55.953]                 else {
[13:36:55.953]                   if (TRUE) {
[13:36:55.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.953]                     {
[13:36:55.953]                       inherits <- base::inherits
[13:36:55.953]                       invokeRestart <- base::invokeRestart
[13:36:55.953]                       is.null <- base::is.null
[13:36:55.953]                       muffled <- FALSE
[13:36:55.953]                       if (inherits(cond, "message")) {
[13:36:55.953]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.953]                         if (muffled) 
[13:36:55.953]                           invokeRestart("muffleMessage")
[13:36:55.953]                       }
[13:36:55.953]                       else if (inherits(cond, "warning")) {
[13:36:55.953]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.953]                         if (muffled) 
[13:36:55.953]                           invokeRestart("muffleWarning")
[13:36:55.953]                       }
[13:36:55.953]                       else if (inherits(cond, "condition")) {
[13:36:55.953]                         if (!is.null(pattern)) {
[13:36:55.953]                           computeRestarts <- base::computeRestarts
[13:36:55.953]                           grepl <- base::grepl
[13:36:55.953]                           restarts <- computeRestarts(cond)
[13:36:55.953]                           for (restart in restarts) {
[13:36:55.953]                             name <- restart$name
[13:36:55.953]                             if (is.null(name)) 
[13:36:55.953]                               next
[13:36:55.953]                             if (!grepl(pattern, name)) 
[13:36:55.953]                               next
[13:36:55.953]                             invokeRestart(restart)
[13:36:55.953]                             muffled <- TRUE
[13:36:55.953]                             break
[13:36:55.953]                           }
[13:36:55.953]                         }
[13:36:55.953]                       }
[13:36:55.953]                       invisible(muffled)
[13:36:55.953]                     }
[13:36:55.953]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.953]                   }
[13:36:55.953]                 }
[13:36:55.953]             }
[13:36:55.953]         }))
[13:36:55.953]     }, error = function(ex) {
[13:36:55.953]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.953]                 ...future.rng), started = ...future.startTime, 
[13:36:55.953]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.953]             version = "1.8"), class = "FutureResult")
[13:36:55.953]     }, finally = {
[13:36:55.953]         if (!identical(...future.workdir, getwd())) 
[13:36:55.953]             setwd(...future.workdir)
[13:36:55.953]         {
[13:36:55.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.953]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.953]             }
[13:36:55.953]             base::options(...future.oldOptions)
[13:36:55.953]             if (.Platform$OS.type == "windows") {
[13:36:55.953]                 old_names <- names(...future.oldEnvVars)
[13:36:55.953]                 envs <- base::Sys.getenv()
[13:36:55.953]                 names <- names(envs)
[13:36:55.953]                 common <- intersect(names, old_names)
[13:36:55.953]                 added <- setdiff(names, old_names)
[13:36:55.953]                 removed <- setdiff(old_names, names)
[13:36:55.953]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.953]                   envs[common]]
[13:36:55.953]                 NAMES <- toupper(changed)
[13:36:55.953]                 args <- list()
[13:36:55.953]                 for (kk in seq_along(NAMES)) {
[13:36:55.953]                   name <- changed[[kk]]
[13:36:55.953]                   NAME <- NAMES[[kk]]
[13:36:55.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.953]                     next
[13:36:55.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.953]                 }
[13:36:55.953]                 NAMES <- toupper(added)
[13:36:55.953]                 for (kk in seq_along(NAMES)) {
[13:36:55.953]                   name <- added[[kk]]
[13:36:55.953]                   NAME <- NAMES[[kk]]
[13:36:55.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.953]                     next
[13:36:55.953]                   args[[name]] <- ""
[13:36:55.953]                 }
[13:36:55.953]                 NAMES <- toupper(removed)
[13:36:55.953]                 for (kk in seq_along(NAMES)) {
[13:36:55.953]                   name <- removed[[kk]]
[13:36:55.953]                   NAME <- NAMES[[kk]]
[13:36:55.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.953]                     next
[13:36:55.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.953]                 }
[13:36:55.953]                 if (length(args) > 0) 
[13:36:55.953]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.953]             }
[13:36:55.953]             else {
[13:36:55.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.953]             }
[13:36:55.953]             {
[13:36:55.953]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.953]                   0L) {
[13:36:55.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.953]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.953]                   base::options(opts)
[13:36:55.953]                 }
[13:36:55.953]                 {
[13:36:55.953]                   {
[13:36:55.953]                     NULL
[13:36:55.953]                     RNGkind("Mersenne-Twister")
[13:36:55.953]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.953]                       inherits = FALSE)
[13:36:55.953]                   }
[13:36:55.953]                   options(future.plan = NULL)
[13:36:55.953]                   if (is.na(NA_character_)) 
[13:36:55.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.953]                     .init = FALSE)
[13:36:55.953]                 }
[13:36:55.953]             }
[13:36:55.953]         }
[13:36:55.953]     })
[13:36:55.953]     if (TRUE) {
[13:36:55.953]         base::sink(type = "output", split = FALSE)
[13:36:55.953]         if (TRUE) {
[13:36:55.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.953]         }
[13:36:55.953]         else {
[13:36:55.953]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.953]         }
[13:36:55.953]         base::close(...future.stdout)
[13:36:55.953]         ...future.stdout <- NULL
[13:36:55.953]     }
[13:36:55.953]     ...future.result$conditions <- ...future.conditions
[13:36:55.953]     ...future.result$finished <- base::Sys.time()
[13:36:55.953]     ...future.result
[13:36:55.953] }
[13:36:55.954] assign_globals() ...
[13:36:55.954] List of 1
[13:36:55.954]  $ a: num 3
[13:36:55.954]  - attr(*, "where")=List of 1
[13:36:55.954]   ..$ a:<environment: R_EmptyEnv> 
[13:36:55.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.954]  - attr(*, "resolved")= logi TRUE
[13:36:55.954]  - attr(*, "total_size")= num 56
[13:36:55.954]  - attr(*, "already-done")= logi TRUE
[13:36:55.957] - copied ‘a’ to environment
[13:36:55.957] assign_globals() ... done
[13:36:55.957] plan(): Setting new future strategy stack:
[13:36:55.957] List of future strategies:
[13:36:55.957] 1. sequential:
[13:36:55.957]    - args: function (..., envir = parent.frame())
[13:36:55.957]    - tweaked: FALSE
[13:36:55.957]    - call: NULL
[13:36:55.957] plan(): nbrOfWorkers() = 1
[13:36:55.958] plan(): Setting new future strategy stack:
[13:36:55.958] List of future strategies:
[13:36:55.958] 1. sequential:
[13:36:55.958]    - args: function (..., envir = parent.frame())
[13:36:55.958]    - tweaked: FALSE
[13:36:55.958]    - call: plan(strategy)
[13:36:55.958] plan(): nbrOfWorkers() = 1
[13:36:55.959] SequentialFuture started (and completed)
[13:36:55.959] - Launch lazy future ... done
[13:36:55.959] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.959] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.960] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:55.961] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:55.961] Searching for globals ... DONE
[13:36:55.961] Resolving globals: TRUE
[13:36:55.961] Resolving any globals that are futures ...
[13:36:55.962] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:55.962] Resolving any globals that are futures ... DONE
[13:36:55.962] Resolving futures part of globals (recursively) ...
[13:36:55.962] resolve() on list ...
[13:36:55.962]  recursive: 99
[13:36:55.962]  length: 2
[13:36:55.962]  elements: ‘a’, ‘ii’
[13:36:55.963]  length: 1 (resolved future 1)
[13:36:55.963]  length: 0 (resolved future 2)
[13:36:55.963] resolve() on list ... DONE
[13:36:55.963] - globals: [2] ‘a’, ‘ii’
[13:36:55.963] Resolving futures part of globals (recursively) ... DONE
[13:36:55.963] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:55.963] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:55.964] - globals: [2] ‘a’, ‘ii’
[13:36:55.964] 
[13:36:55.964] getGlobalsAndPackages() ... DONE
[13:36:55.964] run() for ‘Future’ ...
[13:36:55.964] - state: ‘created’
[13:36:55.964] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.964] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.965]   - Field: ‘label’
[13:36:55.965]   - Field: ‘local’
[13:36:55.965]   - Field: ‘owner’
[13:36:55.965]   - Field: ‘envir’
[13:36:55.965]   - Field: ‘packages’
[13:36:55.965]   - Field: ‘gc’
[13:36:55.965]   - Field: ‘conditions’
[13:36:55.965]   - Field: ‘expr’
[13:36:55.965]   - Field: ‘uuid’
[13:36:55.965]   - Field: ‘seed’
[13:36:55.965]   - Field: ‘version’
[13:36:55.966]   - Field: ‘result’
[13:36:55.966]   - Field: ‘asynchronous’
[13:36:55.966]   - Field: ‘calls’
[13:36:55.966]   - Field: ‘globals’
[13:36:55.966]   - Field: ‘stdout’
[13:36:55.966]   - Field: ‘earlySignal’
[13:36:55.966]   - Field: ‘lazy’
[13:36:55.966]   - Field: ‘state’
[13:36:55.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.967] - Launch lazy future ...
[13:36:55.967] Packages needed by the future expression (n = 0): <none>
[13:36:55.967] Packages needed by future strategies (n = 0): <none>
[13:36:55.968] {
[13:36:55.968]     {
[13:36:55.968]         {
[13:36:55.968]             ...future.startTime <- base::Sys.time()
[13:36:55.968]             {
[13:36:55.968]                 {
[13:36:55.968]                   {
[13:36:55.968]                     base::local({
[13:36:55.968]                       has_future <- base::requireNamespace("future", 
[13:36:55.968]                         quietly = TRUE)
[13:36:55.968]                       if (has_future) {
[13:36:55.968]                         ns <- base::getNamespace("future")
[13:36:55.968]                         version <- ns[[".package"]][["version"]]
[13:36:55.968]                         if (is.null(version)) 
[13:36:55.968]                           version <- utils::packageVersion("future")
[13:36:55.968]                       }
[13:36:55.968]                       else {
[13:36:55.968]                         version <- NULL
[13:36:55.968]                       }
[13:36:55.968]                       if (!has_future || version < "1.8.0") {
[13:36:55.968]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.968]                           "", base::R.version$version.string), 
[13:36:55.968]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.968]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.968]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.968]                             "release", "version")], collapse = " "), 
[13:36:55.968]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.968]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.968]                           info)
[13:36:55.968]                         info <- base::paste(info, collapse = "; ")
[13:36:55.968]                         if (!has_future) {
[13:36:55.968]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.968]                             info)
[13:36:55.968]                         }
[13:36:55.968]                         else {
[13:36:55.968]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.968]                             info, version)
[13:36:55.968]                         }
[13:36:55.968]                         base::stop(msg)
[13:36:55.968]                       }
[13:36:55.968]                     })
[13:36:55.968]                   }
[13:36:55.968]                   ...future.strategy.old <- future::plan("list")
[13:36:55.968]                   options(future.plan = NULL)
[13:36:55.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.968]                 }
[13:36:55.968]                 ...future.workdir <- getwd()
[13:36:55.968]             }
[13:36:55.968]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.968]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.968]         }
[13:36:55.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.968]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:55.968]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.968]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.968]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.968]             base::names(...future.oldOptions))
[13:36:55.968]     }
[13:36:55.968]     if (FALSE) {
[13:36:55.968]     }
[13:36:55.968]     else {
[13:36:55.968]         if (TRUE) {
[13:36:55.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.968]                 open = "w")
[13:36:55.968]         }
[13:36:55.968]         else {
[13:36:55.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.968]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.968]         }
[13:36:55.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.968]             base::sink(type = "output", split = FALSE)
[13:36:55.968]             base::close(...future.stdout)
[13:36:55.968]         }, add = TRUE)
[13:36:55.968]     }
[13:36:55.968]     ...future.frame <- base::sys.nframe()
[13:36:55.968]     ...future.conditions <- base::list()
[13:36:55.968]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.968]     if (FALSE) {
[13:36:55.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.968]     }
[13:36:55.968]     ...future.result <- base::tryCatch({
[13:36:55.968]         base::withCallingHandlers({
[13:36:55.968]             ...future.value <- base::withVisible(base::local({
[13:36:55.968]                 b <- a * ii
[13:36:55.968]                 a <- 0
[13:36:55.968]                 b
[13:36:55.968]             }))
[13:36:55.968]             future::FutureResult(value = ...future.value$value, 
[13:36:55.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.968]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.968]                     ...future.globalenv.names))
[13:36:55.968]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.968]         }, condition = base::local({
[13:36:55.968]             c <- base::c
[13:36:55.968]             inherits <- base::inherits
[13:36:55.968]             invokeRestart <- base::invokeRestart
[13:36:55.968]             length <- base::length
[13:36:55.968]             list <- base::list
[13:36:55.968]             seq.int <- base::seq.int
[13:36:55.968]             signalCondition <- base::signalCondition
[13:36:55.968]             sys.calls <- base::sys.calls
[13:36:55.968]             `[[` <- base::`[[`
[13:36:55.968]             `+` <- base::`+`
[13:36:55.968]             `<<-` <- base::`<<-`
[13:36:55.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.968]                   3L)]
[13:36:55.968]             }
[13:36:55.968]             function(cond) {
[13:36:55.968]                 is_error <- inherits(cond, "error")
[13:36:55.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.968]                   NULL)
[13:36:55.968]                 if (is_error) {
[13:36:55.968]                   sessionInformation <- function() {
[13:36:55.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.968]                       search = base::search(), system = base::Sys.info())
[13:36:55.968]                   }
[13:36:55.968]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.968]                     cond$call), session = sessionInformation(), 
[13:36:55.968]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.968]                   signalCondition(cond)
[13:36:55.968]                 }
[13:36:55.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.968]                 "immediateCondition"))) {
[13:36:55.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.968]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.968]                   if (TRUE && !signal) {
[13:36:55.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.968]                     {
[13:36:55.968]                       inherits <- base::inherits
[13:36:55.968]                       invokeRestart <- base::invokeRestart
[13:36:55.968]                       is.null <- base::is.null
[13:36:55.968]                       muffled <- FALSE
[13:36:55.968]                       if (inherits(cond, "message")) {
[13:36:55.968]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.968]                         if (muffled) 
[13:36:55.968]                           invokeRestart("muffleMessage")
[13:36:55.968]                       }
[13:36:55.968]                       else if (inherits(cond, "warning")) {
[13:36:55.968]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.968]                         if (muffled) 
[13:36:55.968]                           invokeRestart("muffleWarning")
[13:36:55.968]                       }
[13:36:55.968]                       else if (inherits(cond, "condition")) {
[13:36:55.968]                         if (!is.null(pattern)) {
[13:36:55.968]                           computeRestarts <- base::computeRestarts
[13:36:55.968]                           grepl <- base::grepl
[13:36:55.968]                           restarts <- computeRestarts(cond)
[13:36:55.968]                           for (restart in restarts) {
[13:36:55.968]                             name <- restart$name
[13:36:55.968]                             if (is.null(name)) 
[13:36:55.968]                               next
[13:36:55.968]                             if (!grepl(pattern, name)) 
[13:36:55.968]                               next
[13:36:55.968]                             invokeRestart(restart)
[13:36:55.968]                             muffled <- TRUE
[13:36:55.968]                             break
[13:36:55.968]                           }
[13:36:55.968]                         }
[13:36:55.968]                       }
[13:36:55.968]                       invisible(muffled)
[13:36:55.968]                     }
[13:36:55.968]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.968]                   }
[13:36:55.968]                 }
[13:36:55.968]                 else {
[13:36:55.968]                   if (TRUE) {
[13:36:55.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.968]                     {
[13:36:55.968]                       inherits <- base::inherits
[13:36:55.968]                       invokeRestart <- base::invokeRestart
[13:36:55.968]                       is.null <- base::is.null
[13:36:55.968]                       muffled <- FALSE
[13:36:55.968]                       if (inherits(cond, "message")) {
[13:36:55.968]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.968]                         if (muffled) 
[13:36:55.968]                           invokeRestart("muffleMessage")
[13:36:55.968]                       }
[13:36:55.968]                       else if (inherits(cond, "warning")) {
[13:36:55.968]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.968]                         if (muffled) 
[13:36:55.968]                           invokeRestart("muffleWarning")
[13:36:55.968]                       }
[13:36:55.968]                       else if (inherits(cond, "condition")) {
[13:36:55.968]                         if (!is.null(pattern)) {
[13:36:55.968]                           computeRestarts <- base::computeRestarts
[13:36:55.968]                           grepl <- base::grepl
[13:36:55.968]                           restarts <- computeRestarts(cond)
[13:36:55.968]                           for (restart in restarts) {
[13:36:55.968]                             name <- restart$name
[13:36:55.968]                             if (is.null(name)) 
[13:36:55.968]                               next
[13:36:55.968]                             if (!grepl(pattern, name)) 
[13:36:55.968]                               next
[13:36:55.968]                             invokeRestart(restart)
[13:36:55.968]                             muffled <- TRUE
[13:36:55.968]                             break
[13:36:55.968]                           }
[13:36:55.968]                         }
[13:36:55.968]                       }
[13:36:55.968]                       invisible(muffled)
[13:36:55.968]                     }
[13:36:55.968]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.968]                   }
[13:36:55.968]                 }
[13:36:55.968]             }
[13:36:55.968]         }))
[13:36:55.968]     }, error = function(ex) {
[13:36:55.968]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.968]                 ...future.rng), started = ...future.startTime, 
[13:36:55.968]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.968]             version = "1.8"), class = "FutureResult")
[13:36:55.968]     }, finally = {
[13:36:55.968]         if (!identical(...future.workdir, getwd())) 
[13:36:55.968]             setwd(...future.workdir)
[13:36:55.968]         {
[13:36:55.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.968]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.968]             }
[13:36:55.968]             base::options(...future.oldOptions)
[13:36:55.968]             if (.Platform$OS.type == "windows") {
[13:36:55.968]                 old_names <- names(...future.oldEnvVars)
[13:36:55.968]                 envs <- base::Sys.getenv()
[13:36:55.968]                 names <- names(envs)
[13:36:55.968]                 common <- intersect(names, old_names)
[13:36:55.968]                 added <- setdiff(names, old_names)
[13:36:55.968]                 removed <- setdiff(old_names, names)
[13:36:55.968]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.968]                   envs[common]]
[13:36:55.968]                 NAMES <- toupper(changed)
[13:36:55.968]                 args <- list()
[13:36:55.968]                 for (kk in seq_along(NAMES)) {
[13:36:55.968]                   name <- changed[[kk]]
[13:36:55.968]                   NAME <- NAMES[[kk]]
[13:36:55.968]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.968]                     next
[13:36:55.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.968]                 }
[13:36:55.968]                 NAMES <- toupper(added)
[13:36:55.968]                 for (kk in seq_along(NAMES)) {
[13:36:55.968]                   name <- added[[kk]]
[13:36:55.968]                   NAME <- NAMES[[kk]]
[13:36:55.968]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.968]                     next
[13:36:55.968]                   args[[name]] <- ""
[13:36:55.968]                 }
[13:36:55.968]                 NAMES <- toupper(removed)
[13:36:55.968]                 for (kk in seq_along(NAMES)) {
[13:36:55.968]                   name <- removed[[kk]]
[13:36:55.968]                   NAME <- NAMES[[kk]]
[13:36:55.968]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.968]                     next
[13:36:55.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.968]                 }
[13:36:55.968]                 if (length(args) > 0) 
[13:36:55.968]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.968]             }
[13:36:55.968]             else {
[13:36:55.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.968]             }
[13:36:55.968]             {
[13:36:55.968]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.968]                   0L) {
[13:36:55.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.968]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.968]                   base::options(opts)
[13:36:55.968]                 }
[13:36:55.968]                 {
[13:36:55.968]                   {
[13:36:55.968]                     NULL
[13:36:55.968]                     RNGkind("Mersenne-Twister")
[13:36:55.968]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.968]                       inherits = FALSE)
[13:36:55.968]                   }
[13:36:55.968]                   options(future.plan = NULL)
[13:36:55.968]                   if (is.na(NA_character_)) 
[13:36:55.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.968]                     .init = FALSE)
[13:36:55.968]                 }
[13:36:55.968]             }
[13:36:55.968]         }
[13:36:55.968]     })
[13:36:55.968]     if (TRUE) {
[13:36:55.968]         base::sink(type = "output", split = FALSE)
[13:36:55.968]         if (TRUE) {
[13:36:55.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.968]         }
[13:36:55.968]         else {
[13:36:55.968]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.968]         }
[13:36:55.968]         base::close(...future.stdout)
[13:36:55.968]         ...future.stdout <- NULL
[13:36:55.968]     }
[13:36:55.968]     ...future.result$conditions <- ...future.conditions
[13:36:55.968]     ...future.result$finished <- base::Sys.time()
[13:36:55.968]     ...future.result
[13:36:55.968] }
[13:36:55.969] assign_globals() ...
[13:36:55.970] List of 2
[13:36:55.970]  $ a : num 1
[13:36:55.970]  $ ii: int 1
[13:36:55.970]  - attr(*, "where")=List of 2
[13:36:55.970]   ..$ a :<environment: R_EmptyEnv> 
[13:36:55.970]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:55.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.970]  - attr(*, "resolved")= logi TRUE
[13:36:55.970]  - attr(*, "total_size")= num 112
[13:36:55.970]  - attr(*, "already-done")= logi TRUE
[13:36:55.972] - copied ‘a’ to environment
[13:36:55.972] - copied ‘ii’ to environment
[13:36:55.972] assign_globals() ... done
[13:36:55.973] plan(): Setting new future strategy stack:
[13:36:55.973] List of future strategies:
[13:36:55.973] 1. sequential:
[13:36:55.973]    - args: function (..., envir = parent.frame())
[13:36:55.973]    - tweaked: FALSE
[13:36:55.973]    - call: NULL
[13:36:55.973] plan(): nbrOfWorkers() = 1
[13:36:55.974] plan(): Setting new future strategy stack:
[13:36:55.974] List of future strategies:
[13:36:55.974] 1. sequential:
[13:36:55.974]    - args: function (..., envir = parent.frame())
[13:36:55.974]    - tweaked: FALSE
[13:36:55.974]    - call: plan(strategy)
[13:36:55.974] plan(): nbrOfWorkers() = 1
[13:36:55.974] SequentialFuture started (and completed)
[13:36:55.974] - Launch lazy future ... done
[13:36:55.975] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.975] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.975] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:55.977] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:55.977] Searching for globals ... DONE
[13:36:55.977] Resolving globals: TRUE
[13:36:55.977] Resolving any globals that are futures ...
[13:36:55.977] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:55.977] Resolving any globals that are futures ... DONE
[13:36:55.978] Resolving futures part of globals (recursively) ...
[13:36:55.978] resolve() on list ...
[13:36:55.978]  recursive: 99
[13:36:55.978]  length: 2
[13:36:55.978]  elements: ‘a’, ‘ii’
[13:36:55.978]  length: 1 (resolved future 1)
[13:36:55.978]  length: 0 (resolved future 2)
[13:36:55.978] resolve() on list ... DONE
[13:36:55.978] - globals: [2] ‘a’, ‘ii’
[13:36:55.979] Resolving futures part of globals (recursively) ... DONE
[13:36:55.979] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:55.979] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:55.979] - globals: [2] ‘a’, ‘ii’
[13:36:55.979] 
[13:36:55.979] getGlobalsAndPackages() ... DONE
[13:36:55.979] run() for ‘Future’ ...
[13:36:55.980] - state: ‘created’
[13:36:55.980] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.980] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.980] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.980]   - Field: ‘label’
[13:36:55.980]   - Field: ‘local’
[13:36:55.980]   - Field: ‘owner’
[13:36:55.980]   - Field: ‘envir’
[13:36:55.980]   - Field: ‘packages’
[13:36:55.981]   - Field: ‘gc’
[13:36:55.981]   - Field: ‘conditions’
[13:36:55.981]   - Field: ‘expr’
[13:36:55.981]   - Field: ‘uuid’
[13:36:55.981]   - Field: ‘seed’
[13:36:55.981]   - Field: ‘version’
[13:36:55.981]   - Field: ‘result’
[13:36:55.981]   - Field: ‘asynchronous’
[13:36:55.981]   - Field: ‘calls’
[13:36:55.981]   - Field: ‘globals’
[13:36:55.981]   - Field: ‘stdout’
[13:36:55.981]   - Field: ‘earlySignal’
[13:36:55.982]   - Field: ‘lazy’
[13:36:55.982]   - Field: ‘state’
[13:36:55.982] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.982] - Launch lazy future ...
[13:36:55.982] Packages needed by the future expression (n = 0): <none>
[13:36:55.982] Packages needed by future strategies (n = 0): <none>
[13:36:55.982] {
[13:36:55.982]     {
[13:36:55.982]         {
[13:36:55.982]             ...future.startTime <- base::Sys.time()
[13:36:55.982]             {
[13:36:55.982]                 {
[13:36:55.982]                   {
[13:36:55.982]                     base::local({
[13:36:55.982]                       has_future <- base::requireNamespace("future", 
[13:36:55.982]                         quietly = TRUE)
[13:36:55.982]                       if (has_future) {
[13:36:55.982]                         ns <- base::getNamespace("future")
[13:36:55.982]                         version <- ns[[".package"]][["version"]]
[13:36:55.982]                         if (is.null(version)) 
[13:36:55.982]                           version <- utils::packageVersion("future")
[13:36:55.982]                       }
[13:36:55.982]                       else {
[13:36:55.982]                         version <- NULL
[13:36:55.982]                       }
[13:36:55.982]                       if (!has_future || version < "1.8.0") {
[13:36:55.982]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.982]                           "", base::R.version$version.string), 
[13:36:55.982]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.982]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.982]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.982]                             "release", "version")], collapse = " "), 
[13:36:55.982]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.982]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.982]                           info)
[13:36:55.982]                         info <- base::paste(info, collapse = "; ")
[13:36:55.982]                         if (!has_future) {
[13:36:55.982]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.982]                             info)
[13:36:55.982]                         }
[13:36:55.982]                         else {
[13:36:55.982]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.982]                             info, version)
[13:36:55.982]                         }
[13:36:55.982]                         base::stop(msg)
[13:36:55.982]                       }
[13:36:55.982]                     })
[13:36:55.982]                   }
[13:36:55.982]                   ...future.strategy.old <- future::plan("list")
[13:36:55.982]                   options(future.plan = NULL)
[13:36:55.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.982]                 }
[13:36:55.982]                 ...future.workdir <- getwd()
[13:36:55.982]             }
[13:36:55.982]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.982]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.982]         }
[13:36:55.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.982]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:55.982]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.982]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.982]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.982]             base::names(...future.oldOptions))
[13:36:55.982]     }
[13:36:55.982]     if (FALSE) {
[13:36:55.982]     }
[13:36:55.982]     else {
[13:36:55.982]         if (TRUE) {
[13:36:55.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.982]                 open = "w")
[13:36:55.982]         }
[13:36:55.982]         else {
[13:36:55.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.982]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.982]         }
[13:36:55.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.982]             base::sink(type = "output", split = FALSE)
[13:36:55.982]             base::close(...future.stdout)
[13:36:55.982]         }, add = TRUE)
[13:36:55.982]     }
[13:36:55.982]     ...future.frame <- base::sys.nframe()
[13:36:55.982]     ...future.conditions <- base::list()
[13:36:55.982]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.982]     if (FALSE) {
[13:36:55.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.982]     }
[13:36:55.982]     ...future.result <- base::tryCatch({
[13:36:55.982]         base::withCallingHandlers({
[13:36:55.982]             ...future.value <- base::withVisible(base::local({
[13:36:55.982]                 b <- a * ii
[13:36:55.982]                 a <- 0
[13:36:55.982]                 b
[13:36:55.982]             }))
[13:36:55.982]             future::FutureResult(value = ...future.value$value, 
[13:36:55.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.982]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.982]                     ...future.globalenv.names))
[13:36:55.982]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.982]         }, condition = base::local({
[13:36:55.982]             c <- base::c
[13:36:55.982]             inherits <- base::inherits
[13:36:55.982]             invokeRestart <- base::invokeRestart
[13:36:55.982]             length <- base::length
[13:36:55.982]             list <- base::list
[13:36:55.982]             seq.int <- base::seq.int
[13:36:55.982]             signalCondition <- base::signalCondition
[13:36:55.982]             sys.calls <- base::sys.calls
[13:36:55.982]             `[[` <- base::`[[`
[13:36:55.982]             `+` <- base::`+`
[13:36:55.982]             `<<-` <- base::`<<-`
[13:36:55.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.982]                   3L)]
[13:36:55.982]             }
[13:36:55.982]             function(cond) {
[13:36:55.982]                 is_error <- inherits(cond, "error")
[13:36:55.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.982]                   NULL)
[13:36:55.982]                 if (is_error) {
[13:36:55.982]                   sessionInformation <- function() {
[13:36:55.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.982]                       search = base::search(), system = base::Sys.info())
[13:36:55.982]                   }
[13:36:55.982]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.982]                     cond$call), session = sessionInformation(), 
[13:36:55.982]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.982]                   signalCondition(cond)
[13:36:55.982]                 }
[13:36:55.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.982]                 "immediateCondition"))) {
[13:36:55.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.982]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.982]                   if (TRUE && !signal) {
[13:36:55.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.982]                     {
[13:36:55.982]                       inherits <- base::inherits
[13:36:55.982]                       invokeRestart <- base::invokeRestart
[13:36:55.982]                       is.null <- base::is.null
[13:36:55.982]                       muffled <- FALSE
[13:36:55.982]                       if (inherits(cond, "message")) {
[13:36:55.982]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.982]                         if (muffled) 
[13:36:55.982]                           invokeRestart("muffleMessage")
[13:36:55.982]                       }
[13:36:55.982]                       else if (inherits(cond, "warning")) {
[13:36:55.982]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.982]                         if (muffled) 
[13:36:55.982]                           invokeRestart("muffleWarning")
[13:36:55.982]                       }
[13:36:55.982]                       else if (inherits(cond, "condition")) {
[13:36:55.982]                         if (!is.null(pattern)) {
[13:36:55.982]                           computeRestarts <- base::computeRestarts
[13:36:55.982]                           grepl <- base::grepl
[13:36:55.982]                           restarts <- computeRestarts(cond)
[13:36:55.982]                           for (restart in restarts) {
[13:36:55.982]                             name <- restart$name
[13:36:55.982]                             if (is.null(name)) 
[13:36:55.982]                               next
[13:36:55.982]                             if (!grepl(pattern, name)) 
[13:36:55.982]                               next
[13:36:55.982]                             invokeRestart(restart)
[13:36:55.982]                             muffled <- TRUE
[13:36:55.982]                             break
[13:36:55.982]                           }
[13:36:55.982]                         }
[13:36:55.982]                       }
[13:36:55.982]                       invisible(muffled)
[13:36:55.982]                     }
[13:36:55.982]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.982]                   }
[13:36:55.982]                 }
[13:36:55.982]                 else {
[13:36:55.982]                   if (TRUE) {
[13:36:55.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.982]                     {
[13:36:55.982]                       inherits <- base::inherits
[13:36:55.982]                       invokeRestart <- base::invokeRestart
[13:36:55.982]                       is.null <- base::is.null
[13:36:55.982]                       muffled <- FALSE
[13:36:55.982]                       if (inherits(cond, "message")) {
[13:36:55.982]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.982]                         if (muffled) 
[13:36:55.982]                           invokeRestart("muffleMessage")
[13:36:55.982]                       }
[13:36:55.982]                       else if (inherits(cond, "warning")) {
[13:36:55.982]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.982]                         if (muffled) 
[13:36:55.982]                           invokeRestart("muffleWarning")
[13:36:55.982]                       }
[13:36:55.982]                       else if (inherits(cond, "condition")) {
[13:36:55.982]                         if (!is.null(pattern)) {
[13:36:55.982]                           computeRestarts <- base::computeRestarts
[13:36:55.982]                           grepl <- base::grepl
[13:36:55.982]                           restarts <- computeRestarts(cond)
[13:36:55.982]                           for (restart in restarts) {
[13:36:55.982]                             name <- restart$name
[13:36:55.982]                             if (is.null(name)) 
[13:36:55.982]                               next
[13:36:55.982]                             if (!grepl(pattern, name)) 
[13:36:55.982]                               next
[13:36:55.982]                             invokeRestart(restart)
[13:36:55.982]                             muffled <- TRUE
[13:36:55.982]                             break
[13:36:55.982]                           }
[13:36:55.982]                         }
[13:36:55.982]                       }
[13:36:55.982]                       invisible(muffled)
[13:36:55.982]                     }
[13:36:55.982]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.982]                   }
[13:36:55.982]                 }
[13:36:55.982]             }
[13:36:55.982]         }))
[13:36:55.982]     }, error = function(ex) {
[13:36:55.982]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.982]                 ...future.rng), started = ...future.startTime, 
[13:36:55.982]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.982]             version = "1.8"), class = "FutureResult")
[13:36:55.982]     }, finally = {
[13:36:55.982]         if (!identical(...future.workdir, getwd())) 
[13:36:55.982]             setwd(...future.workdir)
[13:36:55.982]         {
[13:36:55.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.982]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.982]             }
[13:36:55.982]             base::options(...future.oldOptions)
[13:36:55.982]             if (.Platform$OS.type == "windows") {
[13:36:55.982]                 old_names <- names(...future.oldEnvVars)
[13:36:55.982]                 envs <- base::Sys.getenv()
[13:36:55.982]                 names <- names(envs)
[13:36:55.982]                 common <- intersect(names, old_names)
[13:36:55.982]                 added <- setdiff(names, old_names)
[13:36:55.982]                 removed <- setdiff(old_names, names)
[13:36:55.982]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.982]                   envs[common]]
[13:36:55.982]                 NAMES <- toupper(changed)
[13:36:55.982]                 args <- list()
[13:36:55.982]                 for (kk in seq_along(NAMES)) {
[13:36:55.982]                   name <- changed[[kk]]
[13:36:55.982]                   NAME <- NAMES[[kk]]
[13:36:55.982]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.982]                     next
[13:36:55.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.982]                 }
[13:36:55.982]                 NAMES <- toupper(added)
[13:36:55.982]                 for (kk in seq_along(NAMES)) {
[13:36:55.982]                   name <- added[[kk]]
[13:36:55.982]                   NAME <- NAMES[[kk]]
[13:36:55.982]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.982]                     next
[13:36:55.982]                   args[[name]] <- ""
[13:36:55.982]                 }
[13:36:55.982]                 NAMES <- toupper(removed)
[13:36:55.982]                 for (kk in seq_along(NAMES)) {
[13:36:55.982]                   name <- removed[[kk]]
[13:36:55.982]                   NAME <- NAMES[[kk]]
[13:36:55.982]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.982]                     next
[13:36:55.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.982]                 }
[13:36:55.982]                 if (length(args) > 0) 
[13:36:55.982]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.982]             }
[13:36:55.982]             else {
[13:36:55.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.982]             }
[13:36:55.982]             {
[13:36:55.982]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.982]                   0L) {
[13:36:55.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.982]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.982]                   base::options(opts)
[13:36:55.982]                 }
[13:36:55.982]                 {
[13:36:55.982]                   {
[13:36:55.982]                     NULL
[13:36:55.982]                     RNGkind("Mersenne-Twister")
[13:36:55.982]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.982]                       inherits = FALSE)
[13:36:55.982]                   }
[13:36:55.982]                   options(future.plan = NULL)
[13:36:55.982]                   if (is.na(NA_character_)) 
[13:36:55.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.982]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.982]                     .init = FALSE)
[13:36:55.982]                 }
[13:36:55.982]             }
[13:36:55.982]         }
[13:36:55.982]     })
[13:36:55.982]     if (TRUE) {
[13:36:55.982]         base::sink(type = "output", split = FALSE)
[13:36:55.982]         if (TRUE) {
[13:36:55.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.982]         }
[13:36:55.982]         else {
[13:36:55.982]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.982]         }
[13:36:55.982]         base::close(...future.stdout)
[13:36:55.982]         ...future.stdout <- NULL
[13:36:55.982]     }
[13:36:55.982]     ...future.result$conditions <- ...future.conditions
[13:36:55.982]     ...future.result$finished <- base::Sys.time()
[13:36:55.982]     ...future.result
[13:36:55.982] }
[13:36:55.984] assign_globals() ...
[13:36:55.984] List of 2
[13:36:55.984]  $ a : num 1
[13:36:55.984]  $ ii: int 2
[13:36:55.984]  - attr(*, "where")=List of 2
[13:36:55.984]   ..$ a :<environment: R_EmptyEnv> 
[13:36:55.984]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:55.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:55.984]  - attr(*, "resolved")= logi TRUE
[13:36:55.984]  - attr(*, "total_size")= num 112
[13:36:55.984]  - attr(*, "already-done")= logi TRUE
[13:36:55.987] - copied ‘a’ to environment
[13:36:55.987] - copied ‘ii’ to environment
[13:36:55.987] assign_globals() ... done
[13:36:55.987] plan(): Setting new future strategy stack:
[13:36:55.987] List of future strategies:
[13:36:55.987] 1. sequential:
[13:36:55.987]    - args: function (..., envir = parent.frame())
[13:36:55.987]    - tweaked: FALSE
[13:36:55.987]    - call: NULL
[13:36:55.988] plan(): nbrOfWorkers() = 1
[13:36:55.988] plan(): Setting new future strategy stack:
[13:36:55.988] List of future strategies:
[13:36:55.988] 1. sequential:
[13:36:55.988]    - args: function (..., envir = parent.frame())
[13:36:55.988]    - tweaked: FALSE
[13:36:55.988]    - call: plan(strategy)
[13:36:55.989] plan(): nbrOfWorkers() = 1
[13:36:55.989] SequentialFuture started (and completed)
[13:36:55.989] - Launch lazy future ... done
[13:36:55.989] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:55.990] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:55.991] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:55.992] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:55.993] Searching for globals ... DONE
[13:36:55.993] Resolving globals: TRUE
[13:36:55.993] Resolving any globals that are futures ...
[13:36:55.993] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:55.993] Resolving any globals that are futures ... DONE
[13:36:55.993] Resolving futures part of globals (recursively) ...
[13:36:55.993] resolve() on list ...
[13:36:55.994]  recursive: 99
[13:36:55.994]  length: 2
[13:36:55.994]  elements: ‘a’, ‘ii’
[13:36:55.994]  length: 1 (resolved future 1)
[13:36:55.994]  length: 0 (resolved future 2)
[13:36:55.994] resolve() on list ... DONE
[13:36:55.994] - globals: [2] ‘a’, ‘ii’
[13:36:55.994] Resolving futures part of globals (recursively) ... DONE
[13:36:55.994] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:55.995] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:55.995] - globals: [2] ‘a’, ‘ii’
[13:36:55.995] 
[13:36:55.995] getGlobalsAndPackages() ... DONE
[13:36:55.995] run() for ‘Future’ ...
[13:36:55.995] - state: ‘created’
[13:36:55.995] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:55.996] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:55.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:55.996]   - Field: ‘label’
[13:36:55.996]   - Field: ‘local’
[13:36:55.996]   - Field: ‘owner’
[13:36:55.996]   - Field: ‘envir’
[13:36:55.996]   - Field: ‘packages’
[13:36:55.996]   - Field: ‘gc’
[13:36:55.996]   - Field: ‘conditions’
[13:36:55.996]   - Field: ‘expr’
[13:36:55.996]   - Field: ‘uuid’
[13:36:55.997]   - Field: ‘seed’
[13:36:55.997]   - Field: ‘version’
[13:36:55.997]   - Field: ‘result’
[13:36:55.997]   - Field: ‘asynchronous’
[13:36:55.997]   - Field: ‘calls’
[13:36:55.997]   - Field: ‘globals’
[13:36:55.997]   - Field: ‘stdout’
[13:36:55.997]   - Field: ‘earlySignal’
[13:36:55.997]   - Field: ‘lazy’
[13:36:55.997]   - Field: ‘state’
[13:36:55.997] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:55.998] - Launch lazy future ...
[13:36:55.998] Packages needed by the future expression (n = 0): <none>
[13:36:55.998] Packages needed by future strategies (n = 0): <none>
[13:36:55.998] {
[13:36:55.998]     {
[13:36:55.998]         {
[13:36:55.998]             ...future.startTime <- base::Sys.time()
[13:36:55.998]             {
[13:36:55.998]                 {
[13:36:55.998]                   {
[13:36:55.998]                     base::local({
[13:36:55.998]                       has_future <- base::requireNamespace("future", 
[13:36:55.998]                         quietly = TRUE)
[13:36:55.998]                       if (has_future) {
[13:36:55.998]                         ns <- base::getNamespace("future")
[13:36:55.998]                         version <- ns[[".package"]][["version"]]
[13:36:55.998]                         if (is.null(version)) 
[13:36:55.998]                           version <- utils::packageVersion("future")
[13:36:55.998]                       }
[13:36:55.998]                       else {
[13:36:55.998]                         version <- NULL
[13:36:55.998]                       }
[13:36:55.998]                       if (!has_future || version < "1.8.0") {
[13:36:55.998]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:55.998]                           "", base::R.version$version.string), 
[13:36:55.998]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:55.998]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:55.998]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:55.998]                             "release", "version")], collapse = " "), 
[13:36:55.998]                           hostname = base::Sys.info()[["nodename"]])
[13:36:55.998]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:55.998]                           info)
[13:36:55.998]                         info <- base::paste(info, collapse = "; ")
[13:36:55.998]                         if (!has_future) {
[13:36:55.998]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:55.998]                             info)
[13:36:55.998]                         }
[13:36:55.998]                         else {
[13:36:55.998]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:55.998]                             info, version)
[13:36:55.998]                         }
[13:36:55.998]                         base::stop(msg)
[13:36:55.998]                       }
[13:36:55.998]                     })
[13:36:55.998]                   }
[13:36:55.998]                   ...future.strategy.old <- future::plan("list")
[13:36:55.998]                   options(future.plan = NULL)
[13:36:55.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:55.998]                 }
[13:36:55.998]                 ...future.workdir <- getwd()
[13:36:55.998]             }
[13:36:55.998]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:55.998]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:55.998]         }
[13:36:55.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:55.998]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:55.998]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:55.998]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:55.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:55.998]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:55.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:55.998]             base::names(...future.oldOptions))
[13:36:55.998]     }
[13:36:55.998]     if (FALSE) {
[13:36:55.998]     }
[13:36:55.998]     else {
[13:36:55.998]         if (TRUE) {
[13:36:55.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:55.998]                 open = "w")
[13:36:55.998]         }
[13:36:55.998]         else {
[13:36:55.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:55.998]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:55.998]         }
[13:36:55.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:55.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:55.998]             base::sink(type = "output", split = FALSE)
[13:36:55.998]             base::close(...future.stdout)
[13:36:55.998]         }, add = TRUE)
[13:36:55.998]     }
[13:36:55.998]     ...future.frame <- base::sys.nframe()
[13:36:55.998]     ...future.conditions <- base::list()
[13:36:55.998]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:55.998]     if (FALSE) {
[13:36:55.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:55.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:55.998]     }
[13:36:55.998]     ...future.result <- base::tryCatch({
[13:36:55.998]         base::withCallingHandlers({
[13:36:55.998]             ...future.value <- base::withVisible(base::local({
[13:36:55.998]                 b <- a * ii
[13:36:55.998]                 a <- 0
[13:36:55.998]                 b
[13:36:55.998]             }))
[13:36:55.998]             future::FutureResult(value = ...future.value$value, 
[13:36:55.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.998]                   ...future.rng), globalenv = if (FALSE) 
[13:36:55.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:55.998]                     ...future.globalenv.names))
[13:36:55.998]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:55.998]         }, condition = base::local({
[13:36:55.998]             c <- base::c
[13:36:55.998]             inherits <- base::inherits
[13:36:55.998]             invokeRestart <- base::invokeRestart
[13:36:55.998]             length <- base::length
[13:36:55.998]             list <- base::list
[13:36:55.998]             seq.int <- base::seq.int
[13:36:55.998]             signalCondition <- base::signalCondition
[13:36:55.998]             sys.calls <- base::sys.calls
[13:36:55.998]             `[[` <- base::`[[`
[13:36:55.998]             `+` <- base::`+`
[13:36:55.998]             `<<-` <- base::`<<-`
[13:36:55.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:55.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:55.998]                   3L)]
[13:36:55.998]             }
[13:36:55.998]             function(cond) {
[13:36:55.998]                 is_error <- inherits(cond, "error")
[13:36:55.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:55.998]                   NULL)
[13:36:55.998]                 if (is_error) {
[13:36:55.998]                   sessionInformation <- function() {
[13:36:55.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:55.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:55.998]                       search = base::search(), system = base::Sys.info())
[13:36:55.998]                   }
[13:36:55.998]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:55.998]                     cond$call), session = sessionInformation(), 
[13:36:55.998]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:55.998]                   signalCondition(cond)
[13:36:55.998]                 }
[13:36:55.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:55.998]                 "immediateCondition"))) {
[13:36:55.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:55.998]                   ...future.conditions[[length(...future.conditions) + 
[13:36:55.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:55.998]                   if (TRUE && !signal) {
[13:36:55.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.998]                     {
[13:36:55.998]                       inherits <- base::inherits
[13:36:55.998]                       invokeRestart <- base::invokeRestart
[13:36:55.998]                       is.null <- base::is.null
[13:36:55.998]                       muffled <- FALSE
[13:36:55.998]                       if (inherits(cond, "message")) {
[13:36:55.998]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.998]                         if (muffled) 
[13:36:55.998]                           invokeRestart("muffleMessage")
[13:36:55.998]                       }
[13:36:55.998]                       else if (inherits(cond, "warning")) {
[13:36:55.998]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.998]                         if (muffled) 
[13:36:55.998]                           invokeRestart("muffleWarning")
[13:36:55.998]                       }
[13:36:55.998]                       else if (inherits(cond, "condition")) {
[13:36:55.998]                         if (!is.null(pattern)) {
[13:36:55.998]                           computeRestarts <- base::computeRestarts
[13:36:55.998]                           grepl <- base::grepl
[13:36:55.998]                           restarts <- computeRestarts(cond)
[13:36:55.998]                           for (restart in restarts) {
[13:36:55.998]                             name <- restart$name
[13:36:55.998]                             if (is.null(name)) 
[13:36:55.998]                               next
[13:36:55.998]                             if (!grepl(pattern, name)) 
[13:36:55.998]                               next
[13:36:55.998]                             invokeRestart(restart)
[13:36:55.998]                             muffled <- TRUE
[13:36:55.998]                             break
[13:36:55.998]                           }
[13:36:55.998]                         }
[13:36:55.998]                       }
[13:36:55.998]                       invisible(muffled)
[13:36:55.998]                     }
[13:36:55.998]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.998]                   }
[13:36:55.998]                 }
[13:36:55.998]                 else {
[13:36:55.998]                   if (TRUE) {
[13:36:55.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:55.998]                     {
[13:36:55.998]                       inherits <- base::inherits
[13:36:55.998]                       invokeRestart <- base::invokeRestart
[13:36:55.998]                       is.null <- base::is.null
[13:36:55.998]                       muffled <- FALSE
[13:36:55.998]                       if (inherits(cond, "message")) {
[13:36:55.998]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:55.998]                         if (muffled) 
[13:36:55.998]                           invokeRestart("muffleMessage")
[13:36:55.998]                       }
[13:36:55.998]                       else if (inherits(cond, "warning")) {
[13:36:55.998]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:55.998]                         if (muffled) 
[13:36:55.998]                           invokeRestart("muffleWarning")
[13:36:55.998]                       }
[13:36:55.998]                       else if (inherits(cond, "condition")) {
[13:36:55.998]                         if (!is.null(pattern)) {
[13:36:55.998]                           computeRestarts <- base::computeRestarts
[13:36:55.998]                           grepl <- base::grepl
[13:36:55.998]                           restarts <- computeRestarts(cond)
[13:36:55.998]                           for (restart in restarts) {
[13:36:55.998]                             name <- restart$name
[13:36:55.998]                             if (is.null(name)) 
[13:36:55.998]                               next
[13:36:55.998]                             if (!grepl(pattern, name)) 
[13:36:55.998]                               next
[13:36:55.998]                             invokeRestart(restart)
[13:36:55.998]                             muffled <- TRUE
[13:36:55.998]                             break
[13:36:55.998]                           }
[13:36:55.998]                         }
[13:36:55.998]                       }
[13:36:55.998]                       invisible(muffled)
[13:36:55.998]                     }
[13:36:55.998]                     muffleCondition(cond, pattern = "^muffle")
[13:36:55.998]                   }
[13:36:55.998]                 }
[13:36:55.998]             }
[13:36:55.998]         }))
[13:36:55.998]     }, error = function(ex) {
[13:36:55.998]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:55.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:55.998]                 ...future.rng), started = ...future.startTime, 
[13:36:55.998]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:55.998]             version = "1.8"), class = "FutureResult")
[13:36:55.998]     }, finally = {
[13:36:55.998]         if (!identical(...future.workdir, getwd())) 
[13:36:55.998]             setwd(...future.workdir)
[13:36:55.998]         {
[13:36:55.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:55.998]                 ...future.oldOptions$nwarnings <- NULL
[13:36:55.998]             }
[13:36:55.998]             base::options(...future.oldOptions)
[13:36:55.998]             if (.Platform$OS.type == "windows") {
[13:36:55.998]                 old_names <- names(...future.oldEnvVars)
[13:36:55.998]                 envs <- base::Sys.getenv()
[13:36:55.998]                 names <- names(envs)
[13:36:55.998]                 common <- intersect(names, old_names)
[13:36:55.998]                 added <- setdiff(names, old_names)
[13:36:55.998]                 removed <- setdiff(old_names, names)
[13:36:55.998]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:55.998]                   envs[common]]
[13:36:55.998]                 NAMES <- toupper(changed)
[13:36:55.998]                 args <- list()
[13:36:55.998]                 for (kk in seq_along(NAMES)) {
[13:36:55.998]                   name <- changed[[kk]]
[13:36:55.998]                   NAME <- NAMES[[kk]]
[13:36:55.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.998]                     next
[13:36:55.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.998]                 }
[13:36:55.998]                 NAMES <- toupper(added)
[13:36:55.998]                 for (kk in seq_along(NAMES)) {
[13:36:55.998]                   name <- added[[kk]]
[13:36:55.998]                   NAME <- NAMES[[kk]]
[13:36:55.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.998]                     next
[13:36:55.998]                   args[[name]] <- ""
[13:36:55.998]                 }
[13:36:55.998]                 NAMES <- toupper(removed)
[13:36:55.998]                 for (kk in seq_along(NAMES)) {
[13:36:55.998]                   name <- removed[[kk]]
[13:36:55.998]                   NAME <- NAMES[[kk]]
[13:36:55.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:55.998]                     next
[13:36:55.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:55.998]                 }
[13:36:55.998]                 if (length(args) > 0) 
[13:36:55.998]                   base::do.call(base::Sys.setenv, args = args)
[13:36:55.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:55.998]             }
[13:36:55.998]             else {
[13:36:55.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:55.998]             }
[13:36:55.998]             {
[13:36:55.998]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:55.998]                   0L) {
[13:36:55.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:55.998]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:55.998]                   base::options(opts)
[13:36:55.998]                 }
[13:36:55.998]                 {
[13:36:55.998]                   {
[13:36:55.998]                     NULL
[13:36:55.998]                     RNGkind("Mersenne-Twister")
[13:36:55.998]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:55.998]                       inherits = FALSE)
[13:36:55.998]                   }
[13:36:55.998]                   options(future.plan = NULL)
[13:36:55.998]                   if (is.na(NA_character_)) 
[13:36:55.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:55.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:55.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:55.998]                     .init = FALSE)
[13:36:55.998]                 }
[13:36:55.998]             }
[13:36:55.998]         }
[13:36:55.998]     })
[13:36:55.998]     if (TRUE) {
[13:36:55.998]         base::sink(type = "output", split = FALSE)
[13:36:55.998]         if (TRUE) {
[13:36:55.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:55.998]         }
[13:36:55.998]         else {
[13:36:55.998]             ...future.result["stdout"] <- base::list(NULL)
[13:36:55.998]         }
[13:36:55.998]         base::close(...future.stdout)
[13:36:55.998]         ...future.stdout <- NULL
[13:36:55.998]     }
[13:36:55.998]     ...future.result$conditions <- ...future.conditions
[13:36:55.998]     ...future.result$finished <- base::Sys.time()
[13:36:55.998]     ...future.result
[13:36:55.998] }
[13:36:56.000] assign_globals() ...
[13:36:56.000] List of 2
[13:36:56.000]  $ a : num 1
[13:36:56.000]  $ ii: int 3
[13:36:56.000]  - attr(*, "where")=List of 2
[13:36:56.000]   ..$ a :<environment: R_EmptyEnv> 
[13:36:56.000]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.000]  - attr(*, "resolved")= logi TRUE
[13:36:56.000]  - attr(*, "total_size")= num 112
[13:36:56.000]  - attr(*, "already-done")= logi TRUE
[13:36:56.003] - copied ‘a’ to environment
[13:36:56.003] - copied ‘ii’ to environment
[13:36:56.003] assign_globals() ... done
[13:36:56.003] plan(): Setting new future strategy stack:
[13:36:56.003] List of future strategies:
[13:36:56.003] 1. sequential:
[13:36:56.003]    - args: function (..., envir = parent.frame())
[13:36:56.003]    - tweaked: FALSE
[13:36:56.003]    - call: NULL
[13:36:56.003] plan(): nbrOfWorkers() = 1
[13:36:56.004] plan(): Setting new future strategy stack:
[13:36:56.004] List of future strategies:
[13:36:56.004] 1. sequential:
[13:36:56.004]    - args: function (..., envir = parent.frame())
[13:36:56.004]    - tweaked: FALSE
[13:36:56.004]    - call: plan(strategy)
[13:36:56.004] plan(): nbrOfWorkers() = 1
[13:36:56.005] SequentialFuture started (and completed)
[13:36:56.005] - Launch lazy future ... done
[13:36:56.005] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.006] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.006] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.007] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.007] Searching for globals ... DONE
[13:36:56.008] Resolving globals: TRUE
[13:36:56.008] Resolving any globals that are futures ...
[13:36:56.008] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.008] Resolving any globals that are futures ... DONE
[13:36:56.008] Resolving futures part of globals (recursively) ...
[13:36:56.008] resolve() on list ...
[13:36:56.008]  recursive: 99
[13:36:56.009]  length: 2
[13:36:56.009]  elements: ‘a’, ‘ii’
[13:36:56.009]  length: 1 (resolved future 1)
[13:36:56.009]  length: 0 (resolved future 2)
[13:36:56.009] resolve() on list ... DONE
[13:36:56.009] - globals: [2] ‘a’, ‘ii’
[13:36:56.009] Resolving futures part of globals (recursively) ... DONE
[13:36:56.009] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:56.010] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.010] - globals: [2] ‘a’, ‘ii’
[13:36:56.010] 
[13:36:56.010] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.010] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.011] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.013] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.013] Searching for globals ... DONE
[13:36:56.013] Resolving globals: TRUE
[13:36:56.013] Resolving any globals that are futures ...
[13:36:56.014] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.014] Resolving any globals that are futures ... DONE
[13:36:56.014] Resolving futures part of globals (recursively) ...
[13:36:56.014] resolve() on list ...
[13:36:56.014]  recursive: 99
[13:36:56.014]  length: 2
[13:36:56.014]  elements: ‘a’, ‘ii’
[13:36:56.015]  length: 1 (resolved future 1)
[13:36:56.015]  length: 0 (resolved future 2)
[13:36:56.015] resolve() on list ... DONE
[13:36:56.015] - globals: [2] ‘a’, ‘ii’
[13:36:56.015] Resolving futures part of globals (recursively) ... DONE
[13:36:56.015] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:56.015] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.016] - globals: [2] ‘a’, ‘ii’
[13:36:56.016] 
[13:36:56.016] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.016] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.016] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.018] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.018] Searching for globals ... DONE
[13:36:56.018] Resolving globals: TRUE
[13:36:56.018] Resolving any globals that are futures ...
[13:36:56.018] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.019] Resolving any globals that are futures ... DONE
[13:36:56.019] Resolving futures part of globals (recursively) ...
[13:36:56.019] resolve() on list ...
[13:36:56.019]  recursive: 99
[13:36:56.019]  length: 2
[13:36:56.019]  elements: ‘a’, ‘ii’
[13:36:56.019]  length: 1 (resolved future 1)
[13:36:56.020]  length: 0 (resolved future 2)
[13:36:56.020] resolve() on list ... DONE
[13:36:56.020] - globals: [2] ‘a’, ‘ii’
[13:36:56.020] Resolving futures part of globals (recursively) ... DONE
[13:36:56.020] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:56.020] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.020] - globals: [2] ‘a’, ‘ii’
[13:36:56.021] 
[13:36:56.021] getGlobalsAndPackages() ... DONE
[13:36:56.021] run() for ‘Future’ ...
[13:36:56.021] - state: ‘created’
[13:36:56.021] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.021] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.022] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.022]   - Field: ‘label’
[13:36:56.022]   - Field: ‘local’
[13:36:56.022]   - Field: ‘owner’
[13:36:56.022]   - Field: ‘envir’
[13:36:56.022]   - Field: ‘packages’
[13:36:56.022]   - Field: ‘gc’
[13:36:56.022]   - Field: ‘conditions’
[13:36:56.022]   - Field: ‘expr’
[13:36:56.022]   - Field: ‘uuid’
[13:36:56.022]   - Field: ‘seed’
[13:36:56.022]   - Field: ‘version’
[13:36:56.023]   - Field: ‘result’
[13:36:56.023]   - Field: ‘asynchronous’
[13:36:56.023]   - Field: ‘calls’
[13:36:56.023]   - Field: ‘globals’
[13:36:56.023]   - Field: ‘stdout’
[13:36:56.023]   - Field: ‘earlySignal’
[13:36:56.023]   - Field: ‘lazy’
[13:36:56.023]   - Field: ‘state’
[13:36:56.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.023] - Launch lazy future ...
[13:36:56.023] Packages needed by the future expression (n = 0): <none>
[13:36:56.024] Packages needed by future strategies (n = 0): <none>
[13:36:56.024] {
[13:36:56.024]     {
[13:36:56.024]         {
[13:36:56.024]             ...future.startTime <- base::Sys.time()
[13:36:56.024]             {
[13:36:56.024]                 {
[13:36:56.024]                   {
[13:36:56.024]                     base::local({
[13:36:56.024]                       has_future <- base::requireNamespace("future", 
[13:36:56.024]                         quietly = TRUE)
[13:36:56.024]                       if (has_future) {
[13:36:56.024]                         ns <- base::getNamespace("future")
[13:36:56.024]                         version <- ns[[".package"]][["version"]]
[13:36:56.024]                         if (is.null(version)) 
[13:36:56.024]                           version <- utils::packageVersion("future")
[13:36:56.024]                       }
[13:36:56.024]                       else {
[13:36:56.024]                         version <- NULL
[13:36:56.024]                       }
[13:36:56.024]                       if (!has_future || version < "1.8.0") {
[13:36:56.024]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.024]                           "", base::R.version$version.string), 
[13:36:56.024]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.024]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.024]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.024]                             "release", "version")], collapse = " "), 
[13:36:56.024]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.024]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.024]                           info)
[13:36:56.024]                         info <- base::paste(info, collapse = "; ")
[13:36:56.024]                         if (!has_future) {
[13:36:56.024]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.024]                             info)
[13:36:56.024]                         }
[13:36:56.024]                         else {
[13:36:56.024]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.024]                             info, version)
[13:36:56.024]                         }
[13:36:56.024]                         base::stop(msg)
[13:36:56.024]                       }
[13:36:56.024]                     })
[13:36:56.024]                   }
[13:36:56.024]                   ...future.strategy.old <- future::plan("list")
[13:36:56.024]                   options(future.plan = NULL)
[13:36:56.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.024]                 }
[13:36:56.024]                 ...future.workdir <- getwd()
[13:36:56.024]             }
[13:36:56.024]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.024]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.024]         }
[13:36:56.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.024]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.024]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.024]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.024]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.024]             base::names(...future.oldOptions))
[13:36:56.024]     }
[13:36:56.024]     if (FALSE) {
[13:36:56.024]     }
[13:36:56.024]     else {
[13:36:56.024]         if (TRUE) {
[13:36:56.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.024]                 open = "w")
[13:36:56.024]         }
[13:36:56.024]         else {
[13:36:56.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.024]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.024]         }
[13:36:56.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.024]             base::sink(type = "output", split = FALSE)
[13:36:56.024]             base::close(...future.stdout)
[13:36:56.024]         }, add = TRUE)
[13:36:56.024]     }
[13:36:56.024]     ...future.frame <- base::sys.nframe()
[13:36:56.024]     ...future.conditions <- base::list()
[13:36:56.024]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.024]     if (FALSE) {
[13:36:56.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.024]     }
[13:36:56.024]     ...future.result <- base::tryCatch({
[13:36:56.024]         base::withCallingHandlers({
[13:36:56.024]             ...future.value <- base::withVisible(base::local({
[13:36:56.024]                 b <- a * ii
[13:36:56.024]                 a <- 0
[13:36:56.024]                 b
[13:36:56.024]             }))
[13:36:56.024]             future::FutureResult(value = ...future.value$value, 
[13:36:56.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.024]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.024]                     ...future.globalenv.names))
[13:36:56.024]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.024]         }, condition = base::local({
[13:36:56.024]             c <- base::c
[13:36:56.024]             inherits <- base::inherits
[13:36:56.024]             invokeRestart <- base::invokeRestart
[13:36:56.024]             length <- base::length
[13:36:56.024]             list <- base::list
[13:36:56.024]             seq.int <- base::seq.int
[13:36:56.024]             signalCondition <- base::signalCondition
[13:36:56.024]             sys.calls <- base::sys.calls
[13:36:56.024]             `[[` <- base::`[[`
[13:36:56.024]             `+` <- base::`+`
[13:36:56.024]             `<<-` <- base::`<<-`
[13:36:56.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.024]                   3L)]
[13:36:56.024]             }
[13:36:56.024]             function(cond) {
[13:36:56.024]                 is_error <- inherits(cond, "error")
[13:36:56.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.024]                   NULL)
[13:36:56.024]                 if (is_error) {
[13:36:56.024]                   sessionInformation <- function() {
[13:36:56.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.024]                       search = base::search(), system = base::Sys.info())
[13:36:56.024]                   }
[13:36:56.024]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.024]                     cond$call), session = sessionInformation(), 
[13:36:56.024]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.024]                   signalCondition(cond)
[13:36:56.024]                 }
[13:36:56.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.024]                 "immediateCondition"))) {
[13:36:56.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.024]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.024]                   if (TRUE && !signal) {
[13:36:56.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.024]                     {
[13:36:56.024]                       inherits <- base::inherits
[13:36:56.024]                       invokeRestart <- base::invokeRestart
[13:36:56.024]                       is.null <- base::is.null
[13:36:56.024]                       muffled <- FALSE
[13:36:56.024]                       if (inherits(cond, "message")) {
[13:36:56.024]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.024]                         if (muffled) 
[13:36:56.024]                           invokeRestart("muffleMessage")
[13:36:56.024]                       }
[13:36:56.024]                       else if (inherits(cond, "warning")) {
[13:36:56.024]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.024]                         if (muffled) 
[13:36:56.024]                           invokeRestart("muffleWarning")
[13:36:56.024]                       }
[13:36:56.024]                       else if (inherits(cond, "condition")) {
[13:36:56.024]                         if (!is.null(pattern)) {
[13:36:56.024]                           computeRestarts <- base::computeRestarts
[13:36:56.024]                           grepl <- base::grepl
[13:36:56.024]                           restarts <- computeRestarts(cond)
[13:36:56.024]                           for (restart in restarts) {
[13:36:56.024]                             name <- restart$name
[13:36:56.024]                             if (is.null(name)) 
[13:36:56.024]                               next
[13:36:56.024]                             if (!grepl(pattern, name)) 
[13:36:56.024]                               next
[13:36:56.024]                             invokeRestart(restart)
[13:36:56.024]                             muffled <- TRUE
[13:36:56.024]                             break
[13:36:56.024]                           }
[13:36:56.024]                         }
[13:36:56.024]                       }
[13:36:56.024]                       invisible(muffled)
[13:36:56.024]                     }
[13:36:56.024]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.024]                   }
[13:36:56.024]                 }
[13:36:56.024]                 else {
[13:36:56.024]                   if (TRUE) {
[13:36:56.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.024]                     {
[13:36:56.024]                       inherits <- base::inherits
[13:36:56.024]                       invokeRestart <- base::invokeRestart
[13:36:56.024]                       is.null <- base::is.null
[13:36:56.024]                       muffled <- FALSE
[13:36:56.024]                       if (inherits(cond, "message")) {
[13:36:56.024]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.024]                         if (muffled) 
[13:36:56.024]                           invokeRestart("muffleMessage")
[13:36:56.024]                       }
[13:36:56.024]                       else if (inherits(cond, "warning")) {
[13:36:56.024]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.024]                         if (muffled) 
[13:36:56.024]                           invokeRestart("muffleWarning")
[13:36:56.024]                       }
[13:36:56.024]                       else if (inherits(cond, "condition")) {
[13:36:56.024]                         if (!is.null(pattern)) {
[13:36:56.024]                           computeRestarts <- base::computeRestarts
[13:36:56.024]                           grepl <- base::grepl
[13:36:56.024]                           restarts <- computeRestarts(cond)
[13:36:56.024]                           for (restart in restarts) {
[13:36:56.024]                             name <- restart$name
[13:36:56.024]                             if (is.null(name)) 
[13:36:56.024]                               next
[13:36:56.024]                             if (!grepl(pattern, name)) 
[13:36:56.024]                               next
[13:36:56.024]                             invokeRestart(restart)
[13:36:56.024]                             muffled <- TRUE
[13:36:56.024]                             break
[13:36:56.024]                           }
[13:36:56.024]                         }
[13:36:56.024]                       }
[13:36:56.024]                       invisible(muffled)
[13:36:56.024]                     }
[13:36:56.024]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.024]                   }
[13:36:56.024]                 }
[13:36:56.024]             }
[13:36:56.024]         }))
[13:36:56.024]     }, error = function(ex) {
[13:36:56.024]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.024]                 ...future.rng), started = ...future.startTime, 
[13:36:56.024]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.024]             version = "1.8"), class = "FutureResult")
[13:36:56.024]     }, finally = {
[13:36:56.024]         if (!identical(...future.workdir, getwd())) 
[13:36:56.024]             setwd(...future.workdir)
[13:36:56.024]         {
[13:36:56.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.024]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.024]             }
[13:36:56.024]             base::options(...future.oldOptions)
[13:36:56.024]             if (.Platform$OS.type == "windows") {
[13:36:56.024]                 old_names <- names(...future.oldEnvVars)
[13:36:56.024]                 envs <- base::Sys.getenv()
[13:36:56.024]                 names <- names(envs)
[13:36:56.024]                 common <- intersect(names, old_names)
[13:36:56.024]                 added <- setdiff(names, old_names)
[13:36:56.024]                 removed <- setdiff(old_names, names)
[13:36:56.024]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.024]                   envs[common]]
[13:36:56.024]                 NAMES <- toupper(changed)
[13:36:56.024]                 args <- list()
[13:36:56.024]                 for (kk in seq_along(NAMES)) {
[13:36:56.024]                   name <- changed[[kk]]
[13:36:56.024]                   NAME <- NAMES[[kk]]
[13:36:56.024]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.024]                     next
[13:36:56.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.024]                 }
[13:36:56.024]                 NAMES <- toupper(added)
[13:36:56.024]                 for (kk in seq_along(NAMES)) {
[13:36:56.024]                   name <- added[[kk]]
[13:36:56.024]                   NAME <- NAMES[[kk]]
[13:36:56.024]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.024]                     next
[13:36:56.024]                   args[[name]] <- ""
[13:36:56.024]                 }
[13:36:56.024]                 NAMES <- toupper(removed)
[13:36:56.024]                 for (kk in seq_along(NAMES)) {
[13:36:56.024]                   name <- removed[[kk]]
[13:36:56.024]                   NAME <- NAMES[[kk]]
[13:36:56.024]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.024]                     next
[13:36:56.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.024]                 }
[13:36:56.024]                 if (length(args) > 0) 
[13:36:56.024]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.024]             }
[13:36:56.024]             else {
[13:36:56.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.024]             }
[13:36:56.024]             {
[13:36:56.024]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.024]                   0L) {
[13:36:56.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.024]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.024]                   base::options(opts)
[13:36:56.024]                 }
[13:36:56.024]                 {
[13:36:56.024]                   {
[13:36:56.024]                     NULL
[13:36:56.024]                     RNGkind("Mersenne-Twister")
[13:36:56.024]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.024]                       inherits = FALSE)
[13:36:56.024]                   }
[13:36:56.024]                   options(future.plan = NULL)
[13:36:56.024]                   if (is.na(NA_character_)) 
[13:36:56.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.024]                     .init = FALSE)
[13:36:56.024]                 }
[13:36:56.024]             }
[13:36:56.024]         }
[13:36:56.024]     })
[13:36:56.024]     if (TRUE) {
[13:36:56.024]         base::sink(type = "output", split = FALSE)
[13:36:56.024]         if (TRUE) {
[13:36:56.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.024]         }
[13:36:56.024]         else {
[13:36:56.024]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.024]         }
[13:36:56.024]         base::close(...future.stdout)
[13:36:56.024]         ...future.stdout <- NULL
[13:36:56.024]     }
[13:36:56.024]     ...future.result$conditions <- ...future.conditions
[13:36:56.024]     ...future.result$finished <- base::Sys.time()
[13:36:56.024]     ...future.result
[13:36:56.024] }
[13:36:56.025] assign_globals() ...
[13:36:56.026] List of 2
[13:36:56.026]  $ a : num 1
[13:36:56.026]  $ ii: int 1
[13:36:56.026]  - attr(*, "where")=List of 2
[13:36:56.026]   ..$ a :<environment: R_EmptyEnv> 
[13:36:56.026]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.026]  - attr(*, "resolved")= logi TRUE
[13:36:56.026]  - attr(*, "total_size")= num 112
[13:36:56.026]  - attr(*, "already-done")= logi TRUE
[13:36:56.028] - copied ‘a’ to environment
[13:36:56.028] - copied ‘ii’ to environment
[13:36:56.029] assign_globals() ... done
[13:36:56.029] plan(): Setting new future strategy stack:
[13:36:56.029] List of future strategies:
[13:36:56.029] 1. sequential:
[13:36:56.029]    - args: function (..., envir = parent.frame())
[13:36:56.029]    - tweaked: FALSE
[13:36:56.029]    - call: NULL
[13:36:56.029] plan(): nbrOfWorkers() = 1
[13:36:56.030] plan(): Setting new future strategy stack:
[13:36:56.030] List of future strategies:
[13:36:56.030] 1. sequential:
[13:36:56.030]    - args: function (..., envir = parent.frame())
[13:36:56.030]    - tweaked: FALSE
[13:36:56.030]    - call: plan(strategy)
[13:36:56.030] plan(): nbrOfWorkers() = 1
[13:36:56.030] SequentialFuture started (and completed)
[13:36:56.031] - Launch lazy future ... done
[13:36:56.031] run() for ‘SequentialFuture’ ... done
[13:36:56.031] run() for ‘Future’ ...
[13:36:56.031] - state: ‘created’
[13:36:56.031] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.031] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.031]   - Field: ‘label’
[13:36:56.032]   - Field: ‘local’
[13:36:56.032]   - Field: ‘owner’
[13:36:56.032]   - Field: ‘envir’
[13:36:56.032]   - Field: ‘packages’
[13:36:56.032]   - Field: ‘gc’
[13:36:56.032]   - Field: ‘conditions’
[13:36:56.032]   - Field: ‘expr’
[13:36:56.032]   - Field: ‘uuid’
[13:36:56.032]   - Field: ‘seed’
[13:36:56.032]   - Field: ‘version’
[13:36:56.032]   - Field: ‘result’
[13:36:56.032]   - Field: ‘asynchronous’
[13:36:56.033]   - Field: ‘calls’
[13:36:56.034]   - Field: ‘globals’
[13:36:56.034]   - Field: ‘stdout’
[13:36:56.034]   - Field: ‘earlySignal’
[13:36:56.034]   - Field: ‘lazy’
[13:36:56.034]   - Field: ‘state’
[13:36:56.034] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.034] - Launch lazy future ...
[13:36:56.034] Packages needed by the future expression (n = 0): <none>
[13:36:56.034] Packages needed by future strategies (n = 0): <none>
[13:36:56.035] {
[13:36:56.035]     {
[13:36:56.035]         {
[13:36:56.035]             ...future.startTime <- base::Sys.time()
[13:36:56.035]             {
[13:36:56.035]                 {
[13:36:56.035]                   {
[13:36:56.035]                     base::local({
[13:36:56.035]                       has_future <- base::requireNamespace("future", 
[13:36:56.035]                         quietly = TRUE)
[13:36:56.035]                       if (has_future) {
[13:36:56.035]                         ns <- base::getNamespace("future")
[13:36:56.035]                         version <- ns[[".package"]][["version"]]
[13:36:56.035]                         if (is.null(version)) 
[13:36:56.035]                           version <- utils::packageVersion("future")
[13:36:56.035]                       }
[13:36:56.035]                       else {
[13:36:56.035]                         version <- NULL
[13:36:56.035]                       }
[13:36:56.035]                       if (!has_future || version < "1.8.0") {
[13:36:56.035]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.035]                           "", base::R.version$version.string), 
[13:36:56.035]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.035]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.035]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.035]                             "release", "version")], collapse = " "), 
[13:36:56.035]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.035]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.035]                           info)
[13:36:56.035]                         info <- base::paste(info, collapse = "; ")
[13:36:56.035]                         if (!has_future) {
[13:36:56.035]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.035]                             info)
[13:36:56.035]                         }
[13:36:56.035]                         else {
[13:36:56.035]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.035]                             info, version)
[13:36:56.035]                         }
[13:36:56.035]                         base::stop(msg)
[13:36:56.035]                       }
[13:36:56.035]                     })
[13:36:56.035]                   }
[13:36:56.035]                   ...future.strategy.old <- future::plan("list")
[13:36:56.035]                   options(future.plan = NULL)
[13:36:56.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.035]                 }
[13:36:56.035]                 ...future.workdir <- getwd()
[13:36:56.035]             }
[13:36:56.035]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.035]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.035]         }
[13:36:56.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.035]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.035]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.035]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.035]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.035]             base::names(...future.oldOptions))
[13:36:56.035]     }
[13:36:56.035]     if (FALSE) {
[13:36:56.035]     }
[13:36:56.035]     else {
[13:36:56.035]         if (TRUE) {
[13:36:56.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.035]                 open = "w")
[13:36:56.035]         }
[13:36:56.035]         else {
[13:36:56.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.035]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.035]         }
[13:36:56.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.035]             base::sink(type = "output", split = FALSE)
[13:36:56.035]             base::close(...future.stdout)
[13:36:56.035]         }, add = TRUE)
[13:36:56.035]     }
[13:36:56.035]     ...future.frame <- base::sys.nframe()
[13:36:56.035]     ...future.conditions <- base::list()
[13:36:56.035]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.035]     if (FALSE) {
[13:36:56.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.035]     }
[13:36:56.035]     ...future.result <- base::tryCatch({
[13:36:56.035]         base::withCallingHandlers({
[13:36:56.035]             ...future.value <- base::withVisible(base::local({
[13:36:56.035]                 b <- a * ii
[13:36:56.035]                 a <- 0
[13:36:56.035]                 b
[13:36:56.035]             }))
[13:36:56.035]             future::FutureResult(value = ...future.value$value, 
[13:36:56.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.035]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.035]                     ...future.globalenv.names))
[13:36:56.035]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.035]         }, condition = base::local({
[13:36:56.035]             c <- base::c
[13:36:56.035]             inherits <- base::inherits
[13:36:56.035]             invokeRestart <- base::invokeRestart
[13:36:56.035]             length <- base::length
[13:36:56.035]             list <- base::list
[13:36:56.035]             seq.int <- base::seq.int
[13:36:56.035]             signalCondition <- base::signalCondition
[13:36:56.035]             sys.calls <- base::sys.calls
[13:36:56.035]             `[[` <- base::`[[`
[13:36:56.035]             `+` <- base::`+`
[13:36:56.035]             `<<-` <- base::`<<-`
[13:36:56.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.035]                   3L)]
[13:36:56.035]             }
[13:36:56.035]             function(cond) {
[13:36:56.035]                 is_error <- inherits(cond, "error")
[13:36:56.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.035]                   NULL)
[13:36:56.035]                 if (is_error) {
[13:36:56.035]                   sessionInformation <- function() {
[13:36:56.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.035]                       search = base::search(), system = base::Sys.info())
[13:36:56.035]                   }
[13:36:56.035]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.035]                     cond$call), session = sessionInformation(), 
[13:36:56.035]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.035]                   signalCondition(cond)
[13:36:56.035]                 }
[13:36:56.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.035]                 "immediateCondition"))) {
[13:36:56.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.035]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.035]                   if (TRUE && !signal) {
[13:36:56.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.035]                     {
[13:36:56.035]                       inherits <- base::inherits
[13:36:56.035]                       invokeRestart <- base::invokeRestart
[13:36:56.035]                       is.null <- base::is.null
[13:36:56.035]                       muffled <- FALSE
[13:36:56.035]                       if (inherits(cond, "message")) {
[13:36:56.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.035]                         if (muffled) 
[13:36:56.035]                           invokeRestart("muffleMessage")
[13:36:56.035]                       }
[13:36:56.035]                       else if (inherits(cond, "warning")) {
[13:36:56.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.035]                         if (muffled) 
[13:36:56.035]                           invokeRestart("muffleWarning")
[13:36:56.035]                       }
[13:36:56.035]                       else if (inherits(cond, "condition")) {
[13:36:56.035]                         if (!is.null(pattern)) {
[13:36:56.035]                           computeRestarts <- base::computeRestarts
[13:36:56.035]                           grepl <- base::grepl
[13:36:56.035]                           restarts <- computeRestarts(cond)
[13:36:56.035]                           for (restart in restarts) {
[13:36:56.035]                             name <- restart$name
[13:36:56.035]                             if (is.null(name)) 
[13:36:56.035]                               next
[13:36:56.035]                             if (!grepl(pattern, name)) 
[13:36:56.035]                               next
[13:36:56.035]                             invokeRestart(restart)
[13:36:56.035]                             muffled <- TRUE
[13:36:56.035]                             break
[13:36:56.035]                           }
[13:36:56.035]                         }
[13:36:56.035]                       }
[13:36:56.035]                       invisible(muffled)
[13:36:56.035]                     }
[13:36:56.035]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.035]                   }
[13:36:56.035]                 }
[13:36:56.035]                 else {
[13:36:56.035]                   if (TRUE) {
[13:36:56.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.035]                     {
[13:36:56.035]                       inherits <- base::inherits
[13:36:56.035]                       invokeRestart <- base::invokeRestart
[13:36:56.035]                       is.null <- base::is.null
[13:36:56.035]                       muffled <- FALSE
[13:36:56.035]                       if (inherits(cond, "message")) {
[13:36:56.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.035]                         if (muffled) 
[13:36:56.035]                           invokeRestart("muffleMessage")
[13:36:56.035]                       }
[13:36:56.035]                       else if (inherits(cond, "warning")) {
[13:36:56.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.035]                         if (muffled) 
[13:36:56.035]                           invokeRestart("muffleWarning")
[13:36:56.035]                       }
[13:36:56.035]                       else if (inherits(cond, "condition")) {
[13:36:56.035]                         if (!is.null(pattern)) {
[13:36:56.035]                           computeRestarts <- base::computeRestarts
[13:36:56.035]                           grepl <- base::grepl
[13:36:56.035]                           restarts <- computeRestarts(cond)
[13:36:56.035]                           for (restart in restarts) {
[13:36:56.035]                             name <- restart$name
[13:36:56.035]                             if (is.null(name)) 
[13:36:56.035]                               next
[13:36:56.035]                             if (!grepl(pattern, name)) 
[13:36:56.035]                               next
[13:36:56.035]                             invokeRestart(restart)
[13:36:56.035]                             muffled <- TRUE
[13:36:56.035]                             break
[13:36:56.035]                           }
[13:36:56.035]                         }
[13:36:56.035]                       }
[13:36:56.035]                       invisible(muffled)
[13:36:56.035]                     }
[13:36:56.035]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.035]                   }
[13:36:56.035]                 }
[13:36:56.035]             }
[13:36:56.035]         }))
[13:36:56.035]     }, error = function(ex) {
[13:36:56.035]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.035]                 ...future.rng), started = ...future.startTime, 
[13:36:56.035]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.035]             version = "1.8"), class = "FutureResult")
[13:36:56.035]     }, finally = {
[13:36:56.035]         if (!identical(...future.workdir, getwd())) 
[13:36:56.035]             setwd(...future.workdir)
[13:36:56.035]         {
[13:36:56.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.035]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.035]             }
[13:36:56.035]             base::options(...future.oldOptions)
[13:36:56.035]             if (.Platform$OS.type == "windows") {
[13:36:56.035]                 old_names <- names(...future.oldEnvVars)
[13:36:56.035]                 envs <- base::Sys.getenv()
[13:36:56.035]                 names <- names(envs)
[13:36:56.035]                 common <- intersect(names, old_names)
[13:36:56.035]                 added <- setdiff(names, old_names)
[13:36:56.035]                 removed <- setdiff(old_names, names)
[13:36:56.035]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.035]                   envs[common]]
[13:36:56.035]                 NAMES <- toupper(changed)
[13:36:56.035]                 args <- list()
[13:36:56.035]                 for (kk in seq_along(NAMES)) {
[13:36:56.035]                   name <- changed[[kk]]
[13:36:56.035]                   NAME <- NAMES[[kk]]
[13:36:56.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.035]                     next
[13:36:56.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.035]                 }
[13:36:56.035]                 NAMES <- toupper(added)
[13:36:56.035]                 for (kk in seq_along(NAMES)) {
[13:36:56.035]                   name <- added[[kk]]
[13:36:56.035]                   NAME <- NAMES[[kk]]
[13:36:56.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.035]                     next
[13:36:56.035]                   args[[name]] <- ""
[13:36:56.035]                 }
[13:36:56.035]                 NAMES <- toupper(removed)
[13:36:56.035]                 for (kk in seq_along(NAMES)) {
[13:36:56.035]                   name <- removed[[kk]]
[13:36:56.035]                   NAME <- NAMES[[kk]]
[13:36:56.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.035]                     next
[13:36:56.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.035]                 }
[13:36:56.035]                 if (length(args) > 0) 
[13:36:56.035]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.035]             }
[13:36:56.035]             else {
[13:36:56.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.035]             }
[13:36:56.035]             {
[13:36:56.035]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.035]                   0L) {
[13:36:56.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.035]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.035]                   base::options(opts)
[13:36:56.035]                 }
[13:36:56.035]                 {
[13:36:56.035]                   {
[13:36:56.035]                     NULL
[13:36:56.035]                     RNGkind("Mersenne-Twister")
[13:36:56.035]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.035]                       inherits = FALSE)
[13:36:56.035]                   }
[13:36:56.035]                   options(future.plan = NULL)
[13:36:56.035]                   if (is.na(NA_character_)) 
[13:36:56.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.035]                     .init = FALSE)
[13:36:56.035]                 }
[13:36:56.035]             }
[13:36:56.035]         }
[13:36:56.035]     })
[13:36:56.035]     if (TRUE) {
[13:36:56.035]         base::sink(type = "output", split = FALSE)
[13:36:56.035]         if (TRUE) {
[13:36:56.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.035]         }
[13:36:56.035]         else {
[13:36:56.035]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.035]         }
[13:36:56.035]         base::close(...future.stdout)
[13:36:56.035]         ...future.stdout <- NULL
[13:36:56.035]     }
[13:36:56.035]     ...future.result$conditions <- ...future.conditions
[13:36:56.035]     ...future.result$finished <- base::Sys.time()
[13:36:56.035]     ...future.result
[13:36:56.035] }
[13:36:56.036] assign_globals() ...
[13:36:56.036] List of 2
[13:36:56.036]  $ a : num 1
[13:36:56.036]  $ ii: int 2
[13:36:56.036]  - attr(*, "where")=List of 2
[13:36:56.036]   ..$ a :<environment: R_EmptyEnv> 
[13:36:56.036]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.036]  - attr(*, "resolved")= logi TRUE
[13:36:56.036]  - attr(*, "total_size")= num 112
[13:36:56.036]  - attr(*, "already-done")= logi TRUE
[13:36:56.039] - copied ‘a’ to environment
[13:36:56.039] - copied ‘ii’ to environment
[13:36:56.039] assign_globals() ... done
[13:36:56.040] plan(): Setting new future strategy stack:
[13:36:56.040] List of future strategies:
[13:36:56.040] 1. sequential:
[13:36:56.040]    - args: function (..., envir = parent.frame())
[13:36:56.040]    - tweaked: FALSE
[13:36:56.040]    - call: NULL
[13:36:56.040] plan(): nbrOfWorkers() = 1
[13:36:56.041] plan(): Setting new future strategy stack:
[13:36:56.041] List of future strategies:
[13:36:56.041] 1. sequential:
[13:36:56.041]    - args: function (..., envir = parent.frame())
[13:36:56.041]    - tweaked: FALSE
[13:36:56.041]    - call: plan(strategy)
[13:36:56.041] plan(): nbrOfWorkers() = 1
[13:36:56.041] SequentialFuture started (and completed)
[13:36:56.041] - Launch lazy future ... done
[13:36:56.041] run() for ‘SequentialFuture’ ... done
[13:36:56.042] run() for ‘Future’ ...
[13:36:56.042] - state: ‘created’
[13:36:56.042] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.042] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.042] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.042]   - Field: ‘label’
[13:36:56.042]   - Field: ‘local’
[13:36:56.042]   - Field: ‘owner’
[13:36:56.043]   - Field: ‘envir’
[13:36:56.043]   - Field: ‘packages’
[13:36:56.043]   - Field: ‘gc’
[13:36:56.043]   - Field: ‘conditions’
[13:36:56.043]   - Field: ‘expr’
[13:36:56.043]   - Field: ‘uuid’
[13:36:56.043]   - Field: ‘seed’
[13:36:56.043]   - Field: ‘version’
[13:36:56.043]   - Field: ‘result’
[13:36:56.043]   - Field: ‘asynchronous’
[13:36:56.043]   - Field: ‘calls’
[13:36:56.043]   - Field: ‘globals’
[13:36:56.044]   - Field: ‘stdout’
[13:36:56.044]   - Field: ‘earlySignal’
[13:36:56.044]   - Field: ‘lazy’
[13:36:56.044]   - Field: ‘state’
[13:36:56.044] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.044] - Launch lazy future ...
[13:36:56.044] Packages needed by the future expression (n = 0): <none>
[13:36:56.044] Packages needed by future strategies (n = 0): <none>
[13:36:56.045] {
[13:36:56.045]     {
[13:36:56.045]         {
[13:36:56.045]             ...future.startTime <- base::Sys.time()
[13:36:56.045]             {
[13:36:56.045]                 {
[13:36:56.045]                   {
[13:36:56.045]                     base::local({
[13:36:56.045]                       has_future <- base::requireNamespace("future", 
[13:36:56.045]                         quietly = TRUE)
[13:36:56.045]                       if (has_future) {
[13:36:56.045]                         ns <- base::getNamespace("future")
[13:36:56.045]                         version <- ns[[".package"]][["version"]]
[13:36:56.045]                         if (is.null(version)) 
[13:36:56.045]                           version <- utils::packageVersion("future")
[13:36:56.045]                       }
[13:36:56.045]                       else {
[13:36:56.045]                         version <- NULL
[13:36:56.045]                       }
[13:36:56.045]                       if (!has_future || version < "1.8.0") {
[13:36:56.045]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.045]                           "", base::R.version$version.string), 
[13:36:56.045]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.045]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.045]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.045]                             "release", "version")], collapse = " "), 
[13:36:56.045]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.045]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.045]                           info)
[13:36:56.045]                         info <- base::paste(info, collapse = "; ")
[13:36:56.045]                         if (!has_future) {
[13:36:56.045]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.045]                             info)
[13:36:56.045]                         }
[13:36:56.045]                         else {
[13:36:56.045]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.045]                             info, version)
[13:36:56.045]                         }
[13:36:56.045]                         base::stop(msg)
[13:36:56.045]                       }
[13:36:56.045]                     })
[13:36:56.045]                   }
[13:36:56.045]                   ...future.strategy.old <- future::plan("list")
[13:36:56.045]                   options(future.plan = NULL)
[13:36:56.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.045]                 }
[13:36:56.045]                 ...future.workdir <- getwd()
[13:36:56.045]             }
[13:36:56.045]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.045]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.045]         }
[13:36:56.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.045]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.045]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.045]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.045]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.045]             base::names(...future.oldOptions))
[13:36:56.045]     }
[13:36:56.045]     if (FALSE) {
[13:36:56.045]     }
[13:36:56.045]     else {
[13:36:56.045]         if (TRUE) {
[13:36:56.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.045]                 open = "w")
[13:36:56.045]         }
[13:36:56.045]         else {
[13:36:56.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.045]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.045]         }
[13:36:56.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.045]             base::sink(type = "output", split = FALSE)
[13:36:56.045]             base::close(...future.stdout)
[13:36:56.045]         }, add = TRUE)
[13:36:56.045]     }
[13:36:56.045]     ...future.frame <- base::sys.nframe()
[13:36:56.045]     ...future.conditions <- base::list()
[13:36:56.045]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.045]     if (FALSE) {
[13:36:56.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.045]     }
[13:36:56.045]     ...future.result <- base::tryCatch({
[13:36:56.045]         base::withCallingHandlers({
[13:36:56.045]             ...future.value <- base::withVisible(base::local({
[13:36:56.045]                 b <- a * ii
[13:36:56.045]                 a <- 0
[13:36:56.045]                 b
[13:36:56.045]             }))
[13:36:56.045]             future::FutureResult(value = ...future.value$value, 
[13:36:56.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.045]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.045]                     ...future.globalenv.names))
[13:36:56.045]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.045]         }, condition = base::local({
[13:36:56.045]             c <- base::c
[13:36:56.045]             inherits <- base::inherits
[13:36:56.045]             invokeRestart <- base::invokeRestart
[13:36:56.045]             length <- base::length
[13:36:56.045]             list <- base::list
[13:36:56.045]             seq.int <- base::seq.int
[13:36:56.045]             signalCondition <- base::signalCondition
[13:36:56.045]             sys.calls <- base::sys.calls
[13:36:56.045]             `[[` <- base::`[[`
[13:36:56.045]             `+` <- base::`+`
[13:36:56.045]             `<<-` <- base::`<<-`
[13:36:56.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.045]                   3L)]
[13:36:56.045]             }
[13:36:56.045]             function(cond) {
[13:36:56.045]                 is_error <- inherits(cond, "error")
[13:36:56.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.045]                   NULL)
[13:36:56.045]                 if (is_error) {
[13:36:56.045]                   sessionInformation <- function() {
[13:36:56.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.045]                       search = base::search(), system = base::Sys.info())
[13:36:56.045]                   }
[13:36:56.045]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.045]                     cond$call), session = sessionInformation(), 
[13:36:56.045]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.045]                   signalCondition(cond)
[13:36:56.045]                 }
[13:36:56.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.045]                 "immediateCondition"))) {
[13:36:56.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.045]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.045]                   if (TRUE && !signal) {
[13:36:56.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.045]                     {
[13:36:56.045]                       inherits <- base::inherits
[13:36:56.045]                       invokeRestart <- base::invokeRestart
[13:36:56.045]                       is.null <- base::is.null
[13:36:56.045]                       muffled <- FALSE
[13:36:56.045]                       if (inherits(cond, "message")) {
[13:36:56.045]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.045]                         if (muffled) 
[13:36:56.045]                           invokeRestart("muffleMessage")
[13:36:56.045]                       }
[13:36:56.045]                       else if (inherits(cond, "warning")) {
[13:36:56.045]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.045]                         if (muffled) 
[13:36:56.045]                           invokeRestart("muffleWarning")
[13:36:56.045]                       }
[13:36:56.045]                       else if (inherits(cond, "condition")) {
[13:36:56.045]                         if (!is.null(pattern)) {
[13:36:56.045]                           computeRestarts <- base::computeRestarts
[13:36:56.045]                           grepl <- base::grepl
[13:36:56.045]                           restarts <- computeRestarts(cond)
[13:36:56.045]                           for (restart in restarts) {
[13:36:56.045]                             name <- restart$name
[13:36:56.045]                             if (is.null(name)) 
[13:36:56.045]                               next
[13:36:56.045]                             if (!grepl(pattern, name)) 
[13:36:56.045]                               next
[13:36:56.045]                             invokeRestart(restart)
[13:36:56.045]                             muffled <- TRUE
[13:36:56.045]                             break
[13:36:56.045]                           }
[13:36:56.045]                         }
[13:36:56.045]                       }
[13:36:56.045]                       invisible(muffled)
[13:36:56.045]                     }
[13:36:56.045]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.045]                   }
[13:36:56.045]                 }
[13:36:56.045]                 else {
[13:36:56.045]                   if (TRUE) {
[13:36:56.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.045]                     {
[13:36:56.045]                       inherits <- base::inherits
[13:36:56.045]                       invokeRestart <- base::invokeRestart
[13:36:56.045]                       is.null <- base::is.null
[13:36:56.045]                       muffled <- FALSE
[13:36:56.045]                       if (inherits(cond, "message")) {
[13:36:56.045]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.045]                         if (muffled) 
[13:36:56.045]                           invokeRestart("muffleMessage")
[13:36:56.045]                       }
[13:36:56.045]                       else if (inherits(cond, "warning")) {
[13:36:56.045]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.045]                         if (muffled) 
[13:36:56.045]                           invokeRestart("muffleWarning")
[13:36:56.045]                       }
[13:36:56.045]                       else if (inherits(cond, "condition")) {
[13:36:56.045]                         if (!is.null(pattern)) {
[13:36:56.045]                           computeRestarts <- base::computeRestarts
[13:36:56.045]                           grepl <- base::grepl
[13:36:56.045]                           restarts <- computeRestarts(cond)
[13:36:56.045]                           for (restart in restarts) {
[13:36:56.045]                             name <- restart$name
[13:36:56.045]                             if (is.null(name)) 
[13:36:56.045]                               next
[13:36:56.045]                             if (!grepl(pattern, name)) 
[13:36:56.045]                               next
[13:36:56.045]                             invokeRestart(restart)
[13:36:56.045]                             muffled <- TRUE
[13:36:56.045]                             break
[13:36:56.045]                           }
[13:36:56.045]                         }
[13:36:56.045]                       }
[13:36:56.045]                       invisible(muffled)
[13:36:56.045]                     }
[13:36:56.045]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.045]                   }
[13:36:56.045]                 }
[13:36:56.045]             }
[13:36:56.045]         }))
[13:36:56.045]     }, error = function(ex) {
[13:36:56.045]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.045]                 ...future.rng), started = ...future.startTime, 
[13:36:56.045]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.045]             version = "1.8"), class = "FutureResult")
[13:36:56.045]     }, finally = {
[13:36:56.045]         if (!identical(...future.workdir, getwd())) 
[13:36:56.045]             setwd(...future.workdir)
[13:36:56.045]         {
[13:36:56.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.045]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.045]             }
[13:36:56.045]             base::options(...future.oldOptions)
[13:36:56.045]             if (.Platform$OS.type == "windows") {
[13:36:56.045]                 old_names <- names(...future.oldEnvVars)
[13:36:56.045]                 envs <- base::Sys.getenv()
[13:36:56.045]                 names <- names(envs)
[13:36:56.045]                 common <- intersect(names, old_names)
[13:36:56.045]                 added <- setdiff(names, old_names)
[13:36:56.045]                 removed <- setdiff(old_names, names)
[13:36:56.045]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.045]                   envs[common]]
[13:36:56.045]                 NAMES <- toupper(changed)
[13:36:56.045]                 args <- list()
[13:36:56.045]                 for (kk in seq_along(NAMES)) {
[13:36:56.045]                   name <- changed[[kk]]
[13:36:56.045]                   NAME <- NAMES[[kk]]
[13:36:56.045]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.045]                     next
[13:36:56.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.045]                 }
[13:36:56.045]                 NAMES <- toupper(added)
[13:36:56.045]                 for (kk in seq_along(NAMES)) {
[13:36:56.045]                   name <- added[[kk]]
[13:36:56.045]                   NAME <- NAMES[[kk]]
[13:36:56.045]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.045]                     next
[13:36:56.045]                   args[[name]] <- ""
[13:36:56.045]                 }
[13:36:56.045]                 NAMES <- toupper(removed)
[13:36:56.045]                 for (kk in seq_along(NAMES)) {
[13:36:56.045]                   name <- removed[[kk]]
[13:36:56.045]                   NAME <- NAMES[[kk]]
[13:36:56.045]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.045]                     next
[13:36:56.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.045]                 }
[13:36:56.045]                 if (length(args) > 0) 
[13:36:56.045]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.045]             }
[13:36:56.045]             else {
[13:36:56.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.045]             }
[13:36:56.045]             {
[13:36:56.045]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.045]                   0L) {
[13:36:56.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.045]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.045]                   base::options(opts)
[13:36:56.045]                 }
[13:36:56.045]                 {
[13:36:56.045]                   {
[13:36:56.045]                     NULL
[13:36:56.045]                     RNGkind("Mersenne-Twister")
[13:36:56.045]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.045]                       inherits = FALSE)
[13:36:56.045]                   }
[13:36:56.045]                   options(future.plan = NULL)
[13:36:56.045]                   if (is.na(NA_character_)) 
[13:36:56.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.045]                     .init = FALSE)
[13:36:56.045]                 }
[13:36:56.045]             }
[13:36:56.045]         }
[13:36:56.045]     })
[13:36:56.045]     if (TRUE) {
[13:36:56.045]         base::sink(type = "output", split = FALSE)
[13:36:56.045]         if (TRUE) {
[13:36:56.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.045]         }
[13:36:56.045]         else {
[13:36:56.045]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.045]         }
[13:36:56.045]         base::close(...future.stdout)
[13:36:56.045]         ...future.stdout <- NULL
[13:36:56.045]     }
[13:36:56.045]     ...future.result$conditions <- ...future.conditions
[13:36:56.045]     ...future.result$finished <- base::Sys.time()
[13:36:56.045]     ...future.result
[13:36:56.045] }
[13:36:56.046] assign_globals() ...
[13:36:56.046] List of 2
[13:36:56.046]  $ a : num 1
[13:36:56.046]  $ ii: int 3
[13:36:56.046]  - attr(*, "where")=List of 2
[13:36:56.046]   ..$ a :<environment: R_EmptyEnv> 
[13:36:56.046]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.046]  - attr(*, "resolved")= logi TRUE
[13:36:56.046]  - attr(*, "total_size")= num 112
[13:36:56.046]  - attr(*, "already-done")= logi TRUE
[13:36:56.049] - copied ‘a’ to environment
[13:36:56.049] - copied ‘ii’ to environment
[13:36:56.049] assign_globals() ... done
[13:36:56.049] plan(): Setting new future strategy stack:
[13:36:56.050] List of future strategies:
[13:36:56.050] 1. sequential:
[13:36:56.050]    - args: function (..., envir = parent.frame())
[13:36:56.050]    - tweaked: FALSE
[13:36:56.050]    - call: NULL
[13:36:56.050] plan(): nbrOfWorkers() = 1
[13:36:56.051] plan(): Setting new future strategy stack:
[13:36:56.051] List of future strategies:
[13:36:56.051] 1. sequential:
[13:36:56.051]    - args: function (..., envir = parent.frame())
[13:36:56.051]    - tweaked: FALSE
[13:36:56.051]    - call: plan(strategy)
[13:36:56.051] plan(): nbrOfWorkers() = 1
[13:36:56.051] SequentialFuture started (and completed)
[13:36:56.051] - Launch lazy future ... done
[13:36:56.051] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.052] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.052] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.052] 
[13:36:56.052] Searching for globals ... DONE
[13:36:56.052] - globals: [0] <none>
[13:36:56.052] getGlobalsAndPackages() ... DONE
[13:36:56.053] run() for ‘Future’ ...
[13:36:56.053] - state: ‘created’
[13:36:56.053] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.053] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.053]   - Field: ‘label’
[13:36:56.053]   - Field: ‘local’
[13:36:56.053]   - Field: ‘owner’
[13:36:56.054]   - Field: ‘envir’
[13:36:56.054]   - Field: ‘packages’
[13:36:56.054]   - Field: ‘gc’
[13:36:56.054]   - Field: ‘conditions’
[13:36:56.054]   - Field: ‘expr’
[13:36:56.054]   - Field: ‘uuid’
[13:36:56.054]   - Field: ‘seed’
[13:36:56.054]   - Field: ‘version’
[13:36:56.054]   - Field: ‘result’
[13:36:56.054]   - Field: ‘asynchronous’
[13:36:56.055]   - Field: ‘calls’
[13:36:56.055]   - Field: ‘globals’
[13:36:56.055]   - Field: ‘stdout’
[13:36:56.055]   - Field: ‘earlySignal’
[13:36:56.055]   - Field: ‘lazy’
[13:36:56.055]   - Field: ‘state’
[13:36:56.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.055] - Launch lazy future ...
[13:36:56.055] Packages needed by the future expression (n = 0): <none>
[13:36:56.055] Packages needed by future strategies (n = 0): <none>
[13:36:56.056] {
[13:36:56.056]     {
[13:36:56.056]         {
[13:36:56.056]             ...future.startTime <- base::Sys.time()
[13:36:56.056]             {
[13:36:56.056]                 {
[13:36:56.056]                   {
[13:36:56.056]                     base::local({
[13:36:56.056]                       has_future <- base::requireNamespace("future", 
[13:36:56.056]                         quietly = TRUE)
[13:36:56.056]                       if (has_future) {
[13:36:56.056]                         ns <- base::getNamespace("future")
[13:36:56.056]                         version <- ns[[".package"]][["version"]]
[13:36:56.056]                         if (is.null(version)) 
[13:36:56.056]                           version <- utils::packageVersion("future")
[13:36:56.056]                       }
[13:36:56.056]                       else {
[13:36:56.056]                         version <- NULL
[13:36:56.056]                       }
[13:36:56.056]                       if (!has_future || version < "1.8.0") {
[13:36:56.056]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.056]                           "", base::R.version$version.string), 
[13:36:56.056]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.056]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.056]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.056]                             "release", "version")], collapse = " "), 
[13:36:56.056]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.056]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.056]                           info)
[13:36:56.056]                         info <- base::paste(info, collapse = "; ")
[13:36:56.056]                         if (!has_future) {
[13:36:56.056]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.056]                             info)
[13:36:56.056]                         }
[13:36:56.056]                         else {
[13:36:56.056]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.056]                             info, version)
[13:36:56.056]                         }
[13:36:56.056]                         base::stop(msg)
[13:36:56.056]                       }
[13:36:56.056]                     })
[13:36:56.056]                   }
[13:36:56.056]                   ...future.strategy.old <- future::plan("list")
[13:36:56.056]                   options(future.plan = NULL)
[13:36:56.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.056]                 }
[13:36:56.056]                 ...future.workdir <- getwd()
[13:36:56.056]             }
[13:36:56.056]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.056]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.056]         }
[13:36:56.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.056]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.056]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.056]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.056]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.056]             base::names(...future.oldOptions))
[13:36:56.056]     }
[13:36:56.056]     if (FALSE) {
[13:36:56.056]     }
[13:36:56.056]     else {
[13:36:56.056]         if (TRUE) {
[13:36:56.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.056]                 open = "w")
[13:36:56.056]         }
[13:36:56.056]         else {
[13:36:56.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.056]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.056]         }
[13:36:56.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.056]             base::sink(type = "output", split = FALSE)
[13:36:56.056]             base::close(...future.stdout)
[13:36:56.056]         }, add = TRUE)
[13:36:56.056]     }
[13:36:56.056]     ...future.frame <- base::sys.nframe()
[13:36:56.056]     ...future.conditions <- base::list()
[13:36:56.056]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.056]     if (FALSE) {
[13:36:56.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.056]     }
[13:36:56.056]     ...future.result <- base::tryCatch({
[13:36:56.056]         base::withCallingHandlers({
[13:36:56.056]             ...future.value <- base::withVisible(base::local(1))
[13:36:56.056]             future::FutureResult(value = ...future.value$value, 
[13:36:56.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.056]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.056]                     ...future.globalenv.names))
[13:36:56.056]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.056]         }, condition = base::local({
[13:36:56.056]             c <- base::c
[13:36:56.056]             inherits <- base::inherits
[13:36:56.056]             invokeRestart <- base::invokeRestart
[13:36:56.056]             length <- base::length
[13:36:56.056]             list <- base::list
[13:36:56.056]             seq.int <- base::seq.int
[13:36:56.056]             signalCondition <- base::signalCondition
[13:36:56.056]             sys.calls <- base::sys.calls
[13:36:56.056]             `[[` <- base::`[[`
[13:36:56.056]             `+` <- base::`+`
[13:36:56.056]             `<<-` <- base::`<<-`
[13:36:56.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.056]                   3L)]
[13:36:56.056]             }
[13:36:56.056]             function(cond) {
[13:36:56.056]                 is_error <- inherits(cond, "error")
[13:36:56.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.056]                   NULL)
[13:36:56.056]                 if (is_error) {
[13:36:56.056]                   sessionInformation <- function() {
[13:36:56.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.056]                       search = base::search(), system = base::Sys.info())
[13:36:56.056]                   }
[13:36:56.056]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.056]                     cond$call), session = sessionInformation(), 
[13:36:56.056]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.056]                   signalCondition(cond)
[13:36:56.056]                 }
[13:36:56.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.056]                 "immediateCondition"))) {
[13:36:56.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.056]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.056]                   if (TRUE && !signal) {
[13:36:56.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.056]                     {
[13:36:56.056]                       inherits <- base::inherits
[13:36:56.056]                       invokeRestart <- base::invokeRestart
[13:36:56.056]                       is.null <- base::is.null
[13:36:56.056]                       muffled <- FALSE
[13:36:56.056]                       if (inherits(cond, "message")) {
[13:36:56.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.056]                         if (muffled) 
[13:36:56.056]                           invokeRestart("muffleMessage")
[13:36:56.056]                       }
[13:36:56.056]                       else if (inherits(cond, "warning")) {
[13:36:56.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.056]                         if (muffled) 
[13:36:56.056]                           invokeRestart("muffleWarning")
[13:36:56.056]                       }
[13:36:56.056]                       else if (inherits(cond, "condition")) {
[13:36:56.056]                         if (!is.null(pattern)) {
[13:36:56.056]                           computeRestarts <- base::computeRestarts
[13:36:56.056]                           grepl <- base::grepl
[13:36:56.056]                           restarts <- computeRestarts(cond)
[13:36:56.056]                           for (restart in restarts) {
[13:36:56.056]                             name <- restart$name
[13:36:56.056]                             if (is.null(name)) 
[13:36:56.056]                               next
[13:36:56.056]                             if (!grepl(pattern, name)) 
[13:36:56.056]                               next
[13:36:56.056]                             invokeRestart(restart)
[13:36:56.056]                             muffled <- TRUE
[13:36:56.056]                             break
[13:36:56.056]                           }
[13:36:56.056]                         }
[13:36:56.056]                       }
[13:36:56.056]                       invisible(muffled)
[13:36:56.056]                     }
[13:36:56.056]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.056]                   }
[13:36:56.056]                 }
[13:36:56.056]                 else {
[13:36:56.056]                   if (TRUE) {
[13:36:56.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.056]                     {
[13:36:56.056]                       inherits <- base::inherits
[13:36:56.056]                       invokeRestart <- base::invokeRestart
[13:36:56.056]                       is.null <- base::is.null
[13:36:56.056]                       muffled <- FALSE
[13:36:56.056]                       if (inherits(cond, "message")) {
[13:36:56.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.056]                         if (muffled) 
[13:36:56.056]                           invokeRestart("muffleMessage")
[13:36:56.056]                       }
[13:36:56.056]                       else if (inherits(cond, "warning")) {
[13:36:56.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.056]                         if (muffled) 
[13:36:56.056]                           invokeRestart("muffleWarning")
[13:36:56.056]                       }
[13:36:56.056]                       else if (inherits(cond, "condition")) {
[13:36:56.056]                         if (!is.null(pattern)) {
[13:36:56.056]                           computeRestarts <- base::computeRestarts
[13:36:56.056]                           grepl <- base::grepl
[13:36:56.056]                           restarts <- computeRestarts(cond)
[13:36:56.056]                           for (restart in restarts) {
[13:36:56.056]                             name <- restart$name
[13:36:56.056]                             if (is.null(name)) 
[13:36:56.056]                               next
[13:36:56.056]                             if (!grepl(pattern, name)) 
[13:36:56.056]                               next
[13:36:56.056]                             invokeRestart(restart)
[13:36:56.056]                             muffled <- TRUE
[13:36:56.056]                             break
[13:36:56.056]                           }
[13:36:56.056]                         }
[13:36:56.056]                       }
[13:36:56.056]                       invisible(muffled)
[13:36:56.056]                     }
[13:36:56.056]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.056]                   }
[13:36:56.056]                 }
[13:36:56.056]             }
[13:36:56.056]         }))
[13:36:56.056]     }, error = function(ex) {
[13:36:56.056]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.056]                 ...future.rng), started = ...future.startTime, 
[13:36:56.056]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.056]             version = "1.8"), class = "FutureResult")
[13:36:56.056]     }, finally = {
[13:36:56.056]         if (!identical(...future.workdir, getwd())) 
[13:36:56.056]             setwd(...future.workdir)
[13:36:56.056]         {
[13:36:56.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.056]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.056]             }
[13:36:56.056]             base::options(...future.oldOptions)
[13:36:56.056]             if (.Platform$OS.type == "windows") {
[13:36:56.056]                 old_names <- names(...future.oldEnvVars)
[13:36:56.056]                 envs <- base::Sys.getenv()
[13:36:56.056]                 names <- names(envs)
[13:36:56.056]                 common <- intersect(names, old_names)
[13:36:56.056]                 added <- setdiff(names, old_names)
[13:36:56.056]                 removed <- setdiff(old_names, names)
[13:36:56.056]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.056]                   envs[common]]
[13:36:56.056]                 NAMES <- toupper(changed)
[13:36:56.056]                 args <- list()
[13:36:56.056]                 for (kk in seq_along(NAMES)) {
[13:36:56.056]                   name <- changed[[kk]]
[13:36:56.056]                   NAME <- NAMES[[kk]]
[13:36:56.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.056]                     next
[13:36:56.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.056]                 }
[13:36:56.056]                 NAMES <- toupper(added)
[13:36:56.056]                 for (kk in seq_along(NAMES)) {
[13:36:56.056]                   name <- added[[kk]]
[13:36:56.056]                   NAME <- NAMES[[kk]]
[13:36:56.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.056]                     next
[13:36:56.056]                   args[[name]] <- ""
[13:36:56.056]                 }
[13:36:56.056]                 NAMES <- toupper(removed)
[13:36:56.056]                 for (kk in seq_along(NAMES)) {
[13:36:56.056]                   name <- removed[[kk]]
[13:36:56.056]                   NAME <- NAMES[[kk]]
[13:36:56.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.056]                     next
[13:36:56.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.056]                 }
[13:36:56.056]                 if (length(args) > 0) 
[13:36:56.056]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.056]             }
[13:36:56.056]             else {
[13:36:56.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.056]             }
[13:36:56.056]             {
[13:36:56.056]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.056]                   0L) {
[13:36:56.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.056]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.056]                   base::options(opts)
[13:36:56.056]                 }
[13:36:56.056]                 {
[13:36:56.056]                   {
[13:36:56.056]                     NULL
[13:36:56.056]                     RNGkind("Mersenne-Twister")
[13:36:56.056]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.056]                       inherits = FALSE)
[13:36:56.056]                   }
[13:36:56.056]                   options(future.plan = NULL)
[13:36:56.056]                   if (is.na(NA_character_)) 
[13:36:56.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.056]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.056]                     .init = FALSE)
[13:36:56.056]                 }
[13:36:56.056]             }
[13:36:56.056]         }
[13:36:56.056]     })
[13:36:56.056]     if (TRUE) {
[13:36:56.056]         base::sink(type = "output", split = FALSE)
[13:36:56.056]         if (TRUE) {
[13:36:56.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.056]         }
[13:36:56.056]         else {
[13:36:56.056]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.056]         }
[13:36:56.056]         base::close(...future.stdout)
[13:36:56.056]         ...future.stdout <- NULL
[13:36:56.056]     }
[13:36:56.056]     ...future.result$conditions <- ...future.conditions
[13:36:56.056]     ...future.result$finished <- base::Sys.time()
[13:36:56.056]     ...future.result
[13:36:56.056] }
[13:36:56.059] plan(): Setting new future strategy stack:
[13:36:56.059] List of future strategies:
[13:36:56.059] 1. sequential:
[13:36:56.059]    - args: function (..., envir = parent.frame())
[13:36:56.059]    - tweaked: FALSE
[13:36:56.059]    - call: NULL
[13:36:56.059] plan(): nbrOfWorkers() = 1
[13:36:56.060] plan(): Setting new future strategy stack:
[13:36:56.060] List of future strategies:
[13:36:56.060] 1. sequential:
[13:36:56.060]    - args: function (..., envir = parent.frame())
[13:36:56.060]    - tweaked: FALSE
[13:36:56.060]    - call: plan(strategy)
[13:36:56.060] plan(): nbrOfWorkers() = 1
[13:36:56.060] SequentialFuture started (and completed)
[13:36:56.061] - Launch lazy future ... done
[13:36:56.061] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.061] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.061] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.062] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:56.062] Searching for globals ... DONE
[13:36:56.062] Resolving globals: TRUE
[13:36:56.062] Resolving any globals that are futures ...
[13:36:56.062] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:56.062] Resolving any globals that are futures ... DONE
[13:36:56.062] Resolving futures part of globals (recursively) ...
[13:36:56.063] resolve() on list ...
[13:36:56.063]  recursive: 99
[13:36:56.063]  length: 1
[13:36:56.063]  elements: ‘a’
[13:36:56.063] resolved() for ‘SequentialFuture’ ...
[13:36:56.063] - state: ‘finished’
[13:36:56.063] - run: TRUE
[13:36:56.063] - result: ‘FutureResult’
[13:36:56.063] resolved() for ‘SequentialFuture’ ... done
[13:36:56.064] Future #1
[13:36:56.064] resolved() for ‘SequentialFuture’ ...
[13:36:56.064] - state: ‘finished’
[13:36:56.064] - run: TRUE
[13:36:56.064] - result: ‘FutureResult’
[13:36:56.064] resolved() for ‘SequentialFuture’ ... done
[13:36:56.064] A SequentialFuture was resolved
[13:36:56.064]  length: 0 (resolved future 1)
[13:36:56.064] resolve() on list ... DONE
[13:36:56.064] - globals: [1] ‘a’
[13:36:56.064] Resolving futures part of globals (recursively) ... DONE
[13:36:56.066] The total size of the 1 globals is 1.55 MiB (1621800 bytes)
[13:36:56.067] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:36:56.067] - globals: [1] ‘a’
[13:36:56.067] - packages: [1] ‘future’
[13:36:56.067] getGlobalsAndPackages() ... DONE
[13:36:56.067] run() for ‘Future’ ...
[13:36:56.067] - state: ‘created’
[13:36:56.067] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.068] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.068] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.068]   - Field: ‘label’
[13:36:56.068]   - Field: ‘local’
[13:36:56.068]   - Field: ‘owner’
[13:36:56.068]   - Field: ‘envir’
[13:36:56.068]   - Field: ‘packages’
[13:36:56.068]   - Field: ‘gc’
[13:36:56.068]   - Field: ‘conditions’
[13:36:56.068]   - Field: ‘expr’
[13:36:56.068]   - Field: ‘uuid’
[13:36:56.069]   - Field: ‘seed’
[13:36:56.069]   - Field: ‘version’
[13:36:56.069]   - Field: ‘result’
[13:36:56.069]   - Field: ‘asynchronous’
[13:36:56.069]   - Field: ‘calls’
[13:36:56.069]   - Field: ‘globals’
[13:36:56.069]   - Field: ‘stdout’
[13:36:56.069]   - Field: ‘earlySignal’
[13:36:56.069]   - Field: ‘lazy’
[13:36:56.069]   - Field: ‘state’
[13:36:56.069] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.070] - Launch lazy future ...
[13:36:56.070] Packages needed by the future expression (n = 1): ‘future’
[13:36:56.070] Packages needed by future strategies (n = 0): <none>
[13:36:56.070] {
[13:36:56.070]     {
[13:36:56.070]         {
[13:36:56.070]             ...future.startTime <- base::Sys.time()
[13:36:56.070]             {
[13:36:56.070]                 {
[13:36:56.070]                   {
[13:36:56.070]                     {
[13:36:56.070]                       base::local({
[13:36:56.070]                         has_future <- base::requireNamespace("future", 
[13:36:56.070]                           quietly = TRUE)
[13:36:56.070]                         if (has_future) {
[13:36:56.070]                           ns <- base::getNamespace("future")
[13:36:56.070]                           version <- ns[[".package"]][["version"]]
[13:36:56.070]                           if (is.null(version)) 
[13:36:56.070]                             version <- utils::packageVersion("future")
[13:36:56.070]                         }
[13:36:56.070]                         else {
[13:36:56.070]                           version <- NULL
[13:36:56.070]                         }
[13:36:56.070]                         if (!has_future || version < "1.8.0") {
[13:36:56.070]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.070]                             "", base::R.version$version.string), 
[13:36:56.070]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.070]                               "release", "version")], collapse = " "), 
[13:36:56.070]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.070]                             info)
[13:36:56.070]                           info <- base::paste(info, collapse = "; ")
[13:36:56.070]                           if (!has_future) {
[13:36:56.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.070]                               info)
[13:36:56.070]                           }
[13:36:56.070]                           else {
[13:36:56.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.070]                               info, version)
[13:36:56.070]                           }
[13:36:56.070]                           base::stop(msg)
[13:36:56.070]                         }
[13:36:56.070]                       })
[13:36:56.070]                     }
[13:36:56.070]                     base::local({
[13:36:56.070]                       for (pkg in "future") {
[13:36:56.070]                         base::loadNamespace(pkg)
[13:36:56.070]                         base::library(pkg, character.only = TRUE)
[13:36:56.070]                       }
[13:36:56.070]                     })
[13:36:56.070]                   }
[13:36:56.070]                   ...future.strategy.old <- future::plan("list")
[13:36:56.070]                   options(future.plan = NULL)
[13:36:56.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.070]                 }
[13:36:56.070]                 ...future.workdir <- getwd()
[13:36:56.070]             }
[13:36:56.070]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.070]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.070]         }
[13:36:56.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.070]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.070]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.070]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.070]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.070]             base::names(...future.oldOptions))
[13:36:56.070]     }
[13:36:56.070]     if (FALSE) {
[13:36:56.070]     }
[13:36:56.070]     else {
[13:36:56.070]         if (TRUE) {
[13:36:56.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.070]                 open = "w")
[13:36:56.070]         }
[13:36:56.070]         else {
[13:36:56.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.070]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.070]         }
[13:36:56.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.070]             base::sink(type = "output", split = FALSE)
[13:36:56.070]             base::close(...future.stdout)
[13:36:56.070]         }, add = TRUE)
[13:36:56.070]     }
[13:36:56.070]     ...future.frame <- base::sys.nframe()
[13:36:56.070]     ...future.conditions <- base::list()
[13:36:56.070]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.070]     if (FALSE) {
[13:36:56.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.070]     }
[13:36:56.070]     ...future.result <- base::tryCatch({
[13:36:56.070]         base::withCallingHandlers({
[13:36:56.070]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:36:56.070]                 1))
[13:36:56.070]             future::FutureResult(value = ...future.value$value, 
[13:36:56.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.070]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.070]                     ...future.globalenv.names))
[13:36:56.070]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.070]         }, condition = base::local({
[13:36:56.070]             c <- base::c
[13:36:56.070]             inherits <- base::inherits
[13:36:56.070]             invokeRestart <- base::invokeRestart
[13:36:56.070]             length <- base::length
[13:36:56.070]             list <- base::list
[13:36:56.070]             seq.int <- base::seq.int
[13:36:56.070]             signalCondition <- base::signalCondition
[13:36:56.070]             sys.calls <- base::sys.calls
[13:36:56.070]             `[[` <- base::`[[`
[13:36:56.070]             `+` <- base::`+`
[13:36:56.070]             `<<-` <- base::`<<-`
[13:36:56.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.070]                   3L)]
[13:36:56.070]             }
[13:36:56.070]             function(cond) {
[13:36:56.070]                 is_error <- inherits(cond, "error")
[13:36:56.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.070]                   NULL)
[13:36:56.070]                 if (is_error) {
[13:36:56.070]                   sessionInformation <- function() {
[13:36:56.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.070]                       search = base::search(), system = base::Sys.info())
[13:36:56.070]                   }
[13:36:56.070]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.070]                     cond$call), session = sessionInformation(), 
[13:36:56.070]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.070]                   signalCondition(cond)
[13:36:56.070]                 }
[13:36:56.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.070]                 "immediateCondition"))) {
[13:36:56.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.070]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.070]                   if (TRUE && !signal) {
[13:36:56.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.070]                     {
[13:36:56.070]                       inherits <- base::inherits
[13:36:56.070]                       invokeRestart <- base::invokeRestart
[13:36:56.070]                       is.null <- base::is.null
[13:36:56.070]                       muffled <- FALSE
[13:36:56.070]                       if (inherits(cond, "message")) {
[13:36:56.070]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.070]                         if (muffled) 
[13:36:56.070]                           invokeRestart("muffleMessage")
[13:36:56.070]                       }
[13:36:56.070]                       else if (inherits(cond, "warning")) {
[13:36:56.070]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.070]                         if (muffled) 
[13:36:56.070]                           invokeRestart("muffleWarning")
[13:36:56.070]                       }
[13:36:56.070]                       else if (inherits(cond, "condition")) {
[13:36:56.070]                         if (!is.null(pattern)) {
[13:36:56.070]                           computeRestarts <- base::computeRestarts
[13:36:56.070]                           grepl <- base::grepl
[13:36:56.070]                           restarts <- computeRestarts(cond)
[13:36:56.070]                           for (restart in restarts) {
[13:36:56.070]                             name <- restart$name
[13:36:56.070]                             if (is.null(name)) 
[13:36:56.070]                               next
[13:36:56.070]                             if (!grepl(pattern, name)) 
[13:36:56.070]                               next
[13:36:56.070]                             invokeRestart(restart)
[13:36:56.070]                             muffled <- TRUE
[13:36:56.070]                             break
[13:36:56.070]                           }
[13:36:56.070]                         }
[13:36:56.070]                       }
[13:36:56.070]                       invisible(muffled)
[13:36:56.070]                     }
[13:36:56.070]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.070]                   }
[13:36:56.070]                 }
[13:36:56.070]                 else {
[13:36:56.070]                   if (TRUE) {
[13:36:56.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.070]                     {
[13:36:56.070]                       inherits <- base::inherits
[13:36:56.070]                       invokeRestart <- base::invokeRestart
[13:36:56.070]                       is.null <- base::is.null
[13:36:56.070]                       muffled <- FALSE
[13:36:56.070]                       if (inherits(cond, "message")) {
[13:36:56.070]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.070]                         if (muffled) 
[13:36:56.070]                           invokeRestart("muffleMessage")
[13:36:56.070]                       }
[13:36:56.070]                       else if (inherits(cond, "warning")) {
[13:36:56.070]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.070]                         if (muffled) 
[13:36:56.070]                           invokeRestart("muffleWarning")
[13:36:56.070]                       }
[13:36:56.070]                       else if (inherits(cond, "condition")) {
[13:36:56.070]                         if (!is.null(pattern)) {
[13:36:56.070]                           computeRestarts <- base::computeRestarts
[13:36:56.070]                           grepl <- base::grepl
[13:36:56.070]                           restarts <- computeRestarts(cond)
[13:36:56.070]                           for (restart in restarts) {
[13:36:56.070]                             name <- restart$name
[13:36:56.070]                             if (is.null(name)) 
[13:36:56.070]                               next
[13:36:56.070]                             if (!grepl(pattern, name)) 
[13:36:56.070]                               next
[13:36:56.070]                             invokeRestart(restart)
[13:36:56.070]                             muffled <- TRUE
[13:36:56.070]                             break
[13:36:56.070]                           }
[13:36:56.070]                         }
[13:36:56.070]                       }
[13:36:56.070]                       invisible(muffled)
[13:36:56.070]                     }
[13:36:56.070]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.070]                   }
[13:36:56.070]                 }
[13:36:56.070]             }
[13:36:56.070]         }))
[13:36:56.070]     }, error = function(ex) {
[13:36:56.070]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.070]                 ...future.rng), started = ...future.startTime, 
[13:36:56.070]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.070]             version = "1.8"), class = "FutureResult")
[13:36:56.070]     }, finally = {
[13:36:56.070]         if (!identical(...future.workdir, getwd())) 
[13:36:56.070]             setwd(...future.workdir)
[13:36:56.070]         {
[13:36:56.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.070]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.070]             }
[13:36:56.070]             base::options(...future.oldOptions)
[13:36:56.070]             if (.Platform$OS.type == "windows") {
[13:36:56.070]                 old_names <- names(...future.oldEnvVars)
[13:36:56.070]                 envs <- base::Sys.getenv()
[13:36:56.070]                 names <- names(envs)
[13:36:56.070]                 common <- intersect(names, old_names)
[13:36:56.070]                 added <- setdiff(names, old_names)
[13:36:56.070]                 removed <- setdiff(old_names, names)
[13:36:56.070]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.070]                   envs[common]]
[13:36:56.070]                 NAMES <- toupper(changed)
[13:36:56.070]                 args <- list()
[13:36:56.070]                 for (kk in seq_along(NAMES)) {
[13:36:56.070]                   name <- changed[[kk]]
[13:36:56.070]                   NAME <- NAMES[[kk]]
[13:36:56.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.070]                     next
[13:36:56.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.070]                 }
[13:36:56.070]                 NAMES <- toupper(added)
[13:36:56.070]                 for (kk in seq_along(NAMES)) {
[13:36:56.070]                   name <- added[[kk]]
[13:36:56.070]                   NAME <- NAMES[[kk]]
[13:36:56.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.070]                     next
[13:36:56.070]                   args[[name]] <- ""
[13:36:56.070]                 }
[13:36:56.070]                 NAMES <- toupper(removed)
[13:36:56.070]                 for (kk in seq_along(NAMES)) {
[13:36:56.070]                   name <- removed[[kk]]
[13:36:56.070]                   NAME <- NAMES[[kk]]
[13:36:56.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.070]                     next
[13:36:56.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.070]                 }
[13:36:56.070]                 if (length(args) > 0) 
[13:36:56.070]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.070]             }
[13:36:56.070]             else {
[13:36:56.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.070]             }
[13:36:56.070]             {
[13:36:56.070]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.070]                   0L) {
[13:36:56.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.070]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.070]                   base::options(opts)
[13:36:56.070]                 }
[13:36:56.070]                 {
[13:36:56.070]                   {
[13:36:56.070]                     NULL
[13:36:56.070]                     RNGkind("Mersenne-Twister")
[13:36:56.070]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.070]                       inherits = FALSE)
[13:36:56.070]                   }
[13:36:56.070]                   options(future.plan = NULL)
[13:36:56.070]                   if (is.na(NA_character_)) 
[13:36:56.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.070]                     .init = FALSE)
[13:36:56.070]                 }
[13:36:56.070]             }
[13:36:56.070]         }
[13:36:56.070]     })
[13:36:56.070]     if (TRUE) {
[13:36:56.070]         base::sink(type = "output", split = FALSE)
[13:36:56.070]         if (TRUE) {
[13:36:56.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.070]         }
[13:36:56.070]         else {
[13:36:56.070]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.070]         }
[13:36:56.070]         base::close(...future.stdout)
[13:36:56.070]         ...future.stdout <- NULL
[13:36:56.070]     }
[13:36:56.070]     ...future.result$conditions <- ...future.conditions
[13:36:56.070]     ...future.result$finished <- base::Sys.time()
[13:36:56.070]     ...future.result
[13:36:56.070] }
[13:36:56.072] assign_globals() ...
[13:36:56.072] List of 1
[13:36:56.072]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c6dcb4e658> 
[13:36:56.072]  - attr(*, "where")=List of 1
[13:36:56.072]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.072]  - attr(*, "resolved")= logi TRUE
[13:36:56.072]  - attr(*, "total_size")= num 1621800
[13:36:56.072]  - attr(*, "already-done")= logi TRUE
[13:36:56.074] - copied ‘a’ to environment
[13:36:56.074] assign_globals() ... done
[13:36:56.074] plan(): Setting new future strategy stack:
[13:36:56.075] List of future strategies:
[13:36:56.075] 1. sequential:
[13:36:56.075]    - args: function (..., envir = parent.frame())
[13:36:56.075]    - tweaked: FALSE
[13:36:56.075]    - call: NULL
[13:36:56.075] plan(): nbrOfWorkers() = 1
[13:36:56.076] plan(): Setting new future strategy stack:
[13:36:56.076] List of future strategies:
[13:36:56.076] 1. sequential:
[13:36:56.076]    - args: function (..., envir = parent.frame())
[13:36:56.076]    - tweaked: FALSE
[13:36:56.076]    - call: plan(strategy)
[13:36:56.076] plan(): nbrOfWorkers() = 1
[13:36:56.076] SequentialFuture started (and completed)
[13:36:56.076] - Launch lazy future ... done
[13:36:56.076] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.077] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.077] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.077] 
[13:36:56.077] Searching for globals ... DONE
[13:36:56.078] - globals: [0] <none>
[13:36:56.078] getGlobalsAndPackages() ... DONE
[13:36:56.078] run() for ‘Future’ ...
[13:36:56.078] - state: ‘created’
[13:36:56.078] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.078] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.078]   - Field: ‘label’
[13:36:56.079]   - Field: ‘local’
[13:36:56.079]   - Field: ‘owner’
[13:36:56.079]   - Field: ‘envir’
[13:36:56.079]   - Field: ‘packages’
[13:36:56.079]   - Field: ‘gc’
[13:36:56.079]   - Field: ‘conditions’
[13:36:56.079]   - Field: ‘expr’
[13:36:56.079]   - Field: ‘uuid’
[13:36:56.079]   - Field: ‘seed’
[13:36:56.079]   - Field: ‘version’
[13:36:56.079]   - Field: ‘result’
[13:36:56.080]   - Field: ‘asynchronous’
[13:36:56.080]   - Field: ‘calls’
[13:36:56.080]   - Field: ‘globals’
[13:36:56.080]   - Field: ‘stdout’
[13:36:56.104]   - Field: ‘earlySignal’
[13:36:56.104]   - Field: ‘lazy’
[13:36:56.104]   - Field: ‘state’
[13:36:56.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.105] - Launch lazy future ...
[13:36:56.105] Packages needed by the future expression (n = 0): <none>
[13:36:56.105] Packages needed by future strategies (n = 0): <none>
[13:36:56.105] {
[13:36:56.105]     {
[13:36:56.105]         {
[13:36:56.105]             ...future.startTime <- base::Sys.time()
[13:36:56.105]             {
[13:36:56.105]                 {
[13:36:56.105]                   {
[13:36:56.105]                     base::local({
[13:36:56.105]                       has_future <- base::requireNamespace("future", 
[13:36:56.105]                         quietly = TRUE)
[13:36:56.105]                       if (has_future) {
[13:36:56.105]                         ns <- base::getNamespace("future")
[13:36:56.105]                         version <- ns[[".package"]][["version"]]
[13:36:56.105]                         if (is.null(version)) 
[13:36:56.105]                           version <- utils::packageVersion("future")
[13:36:56.105]                       }
[13:36:56.105]                       else {
[13:36:56.105]                         version <- NULL
[13:36:56.105]                       }
[13:36:56.105]                       if (!has_future || version < "1.8.0") {
[13:36:56.105]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.105]                           "", base::R.version$version.string), 
[13:36:56.105]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.105]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.105]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.105]                             "release", "version")], collapse = " "), 
[13:36:56.105]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.105]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.105]                           info)
[13:36:56.105]                         info <- base::paste(info, collapse = "; ")
[13:36:56.105]                         if (!has_future) {
[13:36:56.105]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.105]                             info)
[13:36:56.105]                         }
[13:36:56.105]                         else {
[13:36:56.105]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.105]                             info, version)
[13:36:56.105]                         }
[13:36:56.105]                         base::stop(msg)
[13:36:56.105]                       }
[13:36:56.105]                     })
[13:36:56.105]                   }
[13:36:56.105]                   ...future.strategy.old <- future::plan("list")
[13:36:56.105]                   options(future.plan = NULL)
[13:36:56.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.105]                 }
[13:36:56.105]                 ...future.workdir <- getwd()
[13:36:56.105]             }
[13:36:56.105]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.105]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.105]         }
[13:36:56.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.105]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.105]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.105]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.105]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.105]             base::names(...future.oldOptions))
[13:36:56.105]     }
[13:36:56.105]     if (FALSE) {
[13:36:56.105]     }
[13:36:56.105]     else {
[13:36:56.105]         if (TRUE) {
[13:36:56.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.105]                 open = "w")
[13:36:56.105]         }
[13:36:56.105]         else {
[13:36:56.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.105]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.105]         }
[13:36:56.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.105]             base::sink(type = "output", split = FALSE)
[13:36:56.105]             base::close(...future.stdout)
[13:36:56.105]         }, add = TRUE)
[13:36:56.105]     }
[13:36:56.105]     ...future.frame <- base::sys.nframe()
[13:36:56.105]     ...future.conditions <- base::list()
[13:36:56.105]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.105]     if (FALSE) {
[13:36:56.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.105]     }
[13:36:56.105]     ...future.result <- base::tryCatch({
[13:36:56.105]         base::withCallingHandlers({
[13:36:56.105]             ...future.value <- base::withVisible(base::local(1))
[13:36:56.105]             future::FutureResult(value = ...future.value$value, 
[13:36:56.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.105]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.105]                     ...future.globalenv.names))
[13:36:56.105]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.105]         }, condition = base::local({
[13:36:56.105]             c <- base::c
[13:36:56.105]             inherits <- base::inherits
[13:36:56.105]             invokeRestart <- base::invokeRestart
[13:36:56.105]             length <- base::length
[13:36:56.105]             list <- base::list
[13:36:56.105]             seq.int <- base::seq.int
[13:36:56.105]             signalCondition <- base::signalCondition
[13:36:56.105]             sys.calls <- base::sys.calls
[13:36:56.105]             `[[` <- base::`[[`
[13:36:56.105]             `+` <- base::`+`
[13:36:56.105]             `<<-` <- base::`<<-`
[13:36:56.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.105]                   3L)]
[13:36:56.105]             }
[13:36:56.105]             function(cond) {
[13:36:56.105]                 is_error <- inherits(cond, "error")
[13:36:56.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.105]                   NULL)
[13:36:56.105]                 if (is_error) {
[13:36:56.105]                   sessionInformation <- function() {
[13:36:56.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.105]                       search = base::search(), system = base::Sys.info())
[13:36:56.105]                   }
[13:36:56.105]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.105]                     cond$call), session = sessionInformation(), 
[13:36:56.105]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.105]                   signalCondition(cond)
[13:36:56.105]                 }
[13:36:56.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.105]                 "immediateCondition"))) {
[13:36:56.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.105]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.105]                   if (TRUE && !signal) {
[13:36:56.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.105]                     {
[13:36:56.105]                       inherits <- base::inherits
[13:36:56.105]                       invokeRestart <- base::invokeRestart
[13:36:56.105]                       is.null <- base::is.null
[13:36:56.105]                       muffled <- FALSE
[13:36:56.105]                       if (inherits(cond, "message")) {
[13:36:56.105]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.105]                         if (muffled) 
[13:36:56.105]                           invokeRestart("muffleMessage")
[13:36:56.105]                       }
[13:36:56.105]                       else if (inherits(cond, "warning")) {
[13:36:56.105]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.105]                         if (muffled) 
[13:36:56.105]                           invokeRestart("muffleWarning")
[13:36:56.105]                       }
[13:36:56.105]                       else if (inherits(cond, "condition")) {
[13:36:56.105]                         if (!is.null(pattern)) {
[13:36:56.105]                           computeRestarts <- base::computeRestarts
[13:36:56.105]                           grepl <- base::grepl
[13:36:56.105]                           restarts <- computeRestarts(cond)
[13:36:56.105]                           for (restart in restarts) {
[13:36:56.105]                             name <- restart$name
[13:36:56.105]                             if (is.null(name)) 
[13:36:56.105]                               next
[13:36:56.105]                             if (!grepl(pattern, name)) 
[13:36:56.105]                               next
[13:36:56.105]                             invokeRestart(restart)
[13:36:56.105]                             muffled <- TRUE
[13:36:56.105]                             break
[13:36:56.105]                           }
[13:36:56.105]                         }
[13:36:56.105]                       }
[13:36:56.105]                       invisible(muffled)
[13:36:56.105]                     }
[13:36:56.105]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.105]                   }
[13:36:56.105]                 }
[13:36:56.105]                 else {
[13:36:56.105]                   if (TRUE) {
[13:36:56.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.105]                     {
[13:36:56.105]                       inherits <- base::inherits
[13:36:56.105]                       invokeRestart <- base::invokeRestart
[13:36:56.105]                       is.null <- base::is.null
[13:36:56.105]                       muffled <- FALSE
[13:36:56.105]                       if (inherits(cond, "message")) {
[13:36:56.105]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.105]                         if (muffled) 
[13:36:56.105]                           invokeRestart("muffleMessage")
[13:36:56.105]                       }
[13:36:56.105]                       else if (inherits(cond, "warning")) {
[13:36:56.105]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.105]                         if (muffled) 
[13:36:56.105]                           invokeRestart("muffleWarning")
[13:36:56.105]                       }
[13:36:56.105]                       else if (inherits(cond, "condition")) {
[13:36:56.105]                         if (!is.null(pattern)) {
[13:36:56.105]                           computeRestarts <- base::computeRestarts
[13:36:56.105]                           grepl <- base::grepl
[13:36:56.105]                           restarts <- computeRestarts(cond)
[13:36:56.105]                           for (restart in restarts) {
[13:36:56.105]                             name <- restart$name
[13:36:56.105]                             if (is.null(name)) 
[13:36:56.105]                               next
[13:36:56.105]                             if (!grepl(pattern, name)) 
[13:36:56.105]                               next
[13:36:56.105]                             invokeRestart(restart)
[13:36:56.105]                             muffled <- TRUE
[13:36:56.105]                             break
[13:36:56.105]                           }
[13:36:56.105]                         }
[13:36:56.105]                       }
[13:36:56.105]                       invisible(muffled)
[13:36:56.105]                     }
[13:36:56.105]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.105]                   }
[13:36:56.105]                 }
[13:36:56.105]             }
[13:36:56.105]         }))
[13:36:56.105]     }, error = function(ex) {
[13:36:56.105]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.105]                 ...future.rng), started = ...future.startTime, 
[13:36:56.105]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.105]             version = "1.8"), class = "FutureResult")
[13:36:56.105]     }, finally = {
[13:36:56.105]         if (!identical(...future.workdir, getwd())) 
[13:36:56.105]             setwd(...future.workdir)
[13:36:56.105]         {
[13:36:56.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.105]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.105]             }
[13:36:56.105]             base::options(...future.oldOptions)
[13:36:56.105]             if (.Platform$OS.type == "windows") {
[13:36:56.105]                 old_names <- names(...future.oldEnvVars)
[13:36:56.105]                 envs <- base::Sys.getenv()
[13:36:56.105]                 names <- names(envs)
[13:36:56.105]                 common <- intersect(names, old_names)
[13:36:56.105]                 added <- setdiff(names, old_names)
[13:36:56.105]                 removed <- setdiff(old_names, names)
[13:36:56.105]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.105]                   envs[common]]
[13:36:56.105]                 NAMES <- toupper(changed)
[13:36:56.105]                 args <- list()
[13:36:56.105]                 for (kk in seq_along(NAMES)) {
[13:36:56.105]                   name <- changed[[kk]]
[13:36:56.105]                   NAME <- NAMES[[kk]]
[13:36:56.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.105]                     next
[13:36:56.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.105]                 }
[13:36:56.105]                 NAMES <- toupper(added)
[13:36:56.105]                 for (kk in seq_along(NAMES)) {
[13:36:56.105]                   name <- added[[kk]]
[13:36:56.105]                   NAME <- NAMES[[kk]]
[13:36:56.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.105]                     next
[13:36:56.105]                   args[[name]] <- ""
[13:36:56.105]                 }
[13:36:56.105]                 NAMES <- toupper(removed)
[13:36:56.105]                 for (kk in seq_along(NAMES)) {
[13:36:56.105]                   name <- removed[[kk]]
[13:36:56.105]                   NAME <- NAMES[[kk]]
[13:36:56.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.105]                     next
[13:36:56.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.105]                 }
[13:36:56.105]                 if (length(args) > 0) 
[13:36:56.105]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.105]             }
[13:36:56.105]             else {
[13:36:56.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.105]             }
[13:36:56.105]             {
[13:36:56.105]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.105]                   0L) {
[13:36:56.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.105]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.105]                   base::options(opts)
[13:36:56.105]                 }
[13:36:56.105]                 {
[13:36:56.105]                   {
[13:36:56.105]                     NULL
[13:36:56.105]                     RNGkind("Mersenne-Twister")
[13:36:56.105]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.105]                       inherits = FALSE)
[13:36:56.105]                   }
[13:36:56.105]                   options(future.plan = NULL)
[13:36:56.105]                   if (is.na(NA_character_)) 
[13:36:56.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.105]                     .init = FALSE)
[13:36:56.105]                 }
[13:36:56.105]             }
[13:36:56.105]         }
[13:36:56.105]     })
[13:36:56.105]     if (TRUE) {
[13:36:56.105]         base::sink(type = "output", split = FALSE)
[13:36:56.105]         if (TRUE) {
[13:36:56.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.105]         }
[13:36:56.105]         else {
[13:36:56.105]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.105]         }
[13:36:56.105]         base::close(...future.stdout)
[13:36:56.105]         ...future.stdout <- NULL
[13:36:56.105]     }
[13:36:56.105]     ...future.result$conditions <- ...future.conditions
[13:36:56.105]     ...future.result$finished <- base::Sys.time()
[13:36:56.105]     ...future.result
[13:36:56.105] }
[13:36:56.107] plan(): Setting new future strategy stack:
[13:36:56.107] List of future strategies:
[13:36:56.107] 1. sequential:
[13:36:56.107]    - args: function (..., envir = parent.frame())
[13:36:56.107]    - tweaked: FALSE
[13:36:56.107]    - call: NULL
[13:36:56.108] plan(): nbrOfWorkers() = 1
[13:36:56.108] plan(): Setting new future strategy stack:
[13:36:56.108] List of future strategies:
[13:36:56.108] 1. sequential:
[13:36:56.108]    - args: function (..., envir = parent.frame())
[13:36:56.108]    - tweaked: FALSE
[13:36:56.108]    - call: plan(strategy)
[13:36:56.109] plan(): nbrOfWorkers() = 1
[13:36:56.109] SequentialFuture started (and completed)
[13:36:56.109] - Launch lazy future ... done
[13:36:56.109] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.109] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.109] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.110] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:56.110] Searching for globals ... DONE
[13:36:56.110] Resolving globals: TRUE
[13:36:56.110] Resolving any globals that are futures ...
[13:36:56.111] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:56.111] Resolving any globals that are futures ... DONE
[13:36:56.111] Resolving futures part of globals (recursively) ...
[13:36:56.111] resolve() on list ...
[13:36:56.111]  recursive: 99
[13:36:56.111]  length: 1
[13:36:56.111]  elements: ‘a’
[13:36:56.111] resolved() for ‘SequentialFuture’ ...
[13:36:56.112] - state: ‘finished’
[13:36:56.112] - run: TRUE
[13:36:56.112] - result: ‘FutureResult’
[13:36:56.112] resolved() for ‘SequentialFuture’ ... done
[13:36:56.112] Future #1
[13:36:56.112] resolved() for ‘SequentialFuture’ ...
[13:36:56.112] - state: ‘finished’
[13:36:56.112] - run: TRUE
[13:36:56.112] - result: ‘FutureResult’
[13:36:56.112] resolved() for ‘SequentialFuture’ ... done
[13:36:56.113] A SequentialFuture was resolved
[13:36:56.113]  length: 0 (resolved future 1)
[13:36:56.113] resolve() on list ... DONE
[13:36:56.113] - globals: [1] ‘a’
[13:36:56.113] Resolving futures part of globals (recursively) ... DONE
[13:36:56.115] The total size of the 1 globals is 1.55 MiB (1621800 bytes)
[13:36:56.115] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:36:56.115] - globals: [1] ‘a’
[13:36:56.115] - packages: [1] ‘future’
[13:36:56.115] getGlobalsAndPackages() ... DONE
[13:36:56.115] run() for ‘Future’ ...
[13:36:56.116] - state: ‘created’
[13:36:56.116] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.116] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.116] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.116]   - Field: ‘label’
[13:36:56.116]   - Field: ‘local’
[13:36:56.116]   - Field: ‘owner’
[13:36:56.116]   - Field: ‘envir’
[13:36:56.117]   - Field: ‘packages’
[13:36:56.117]   - Field: ‘gc’
[13:36:56.117]   - Field: ‘conditions’
[13:36:56.117]   - Field: ‘expr’
[13:36:56.117]   - Field: ‘uuid’
[13:36:56.117]   - Field: ‘seed’
[13:36:56.117]   - Field: ‘version’
[13:36:56.117]   - Field: ‘result’
[13:36:56.117]   - Field: ‘asynchronous’
[13:36:56.117]   - Field: ‘calls’
[13:36:56.117]   - Field: ‘globals’
[13:36:56.117]   - Field: ‘stdout’
[13:36:56.118]   - Field: ‘earlySignal’
[13:36:56.118]   - Field: ‘lazy’
[13:36:56.118]   - Field: ‘state’
[13:36:56.118] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.118] - Launch lazy future ...
[13:36:56.118] Packages needed by the future expression (n = 1): ‘future’
[13:36:56.118] Packages needed by future strategies (n = 0): <none>
[13:36:56.119] {
[13:36:56.119]     {
[13:36:56.119]         {
[13:36:56.119]             ...future.startTime <- base::Sys.time()
[13:36:56.119]             {
[13:36:56.119]                 {
[13:36:56.119]                   {
[13:36:56.119]                     {
[13:36:56.119]                       base::local({
[13:36:56.119]                         has_future <- base::requireNamespace("future", 
[13:36:56.119]                           quietly = TRUE)
[13:36:56.119]                         if (has_future) {
[13:36:56.119]                           ns <- base::getNamespace("future")
[13:36:56.119]                           version <- ns[[".package"]][["version"]]
[13:36:56.119]                           if (is.null(version)) 
[13:36:56.119]                             version <- utils::packageVersion("future")
[13:36:56.119]                         }
[13:36:56.119]                         else {
[13:36:56.119]                           version <- NULL
[13:36:56.119]                         }
[13:36:56.119]                         if (!has_future || version < "1.8.0") {
[13:36:56.119]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.119]                             "", base::R.version$version.string), 
[13:36:56.119]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.119]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.119]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.119]                               "release", "version")], collapse = " "), 
[13:36:56.119]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.119]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.119]                             info)
[13:36:56.119]                           info <- base::paste(info, collapse = "; ")
[13:36:56.119]                           if (!has_future) {
[13:36:56.119]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.119]                               info)
[13:36:56.119]                           }
[13:36:56.119]                           else {
[13:36:56.119]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.119]                               info, version)
[13:36:56.119]                           }
[13:36:56.119]                           base::stop(msg)
[13:36:56.119]                         }
[13:36:56.119]                       })
[13:36:56.119]                     }
[13:36:56.119]                     base::local({
[13:36:56.119]                       for (pkg in "future") {
[13:36:56.119]                         base::loadNamespace(pkg)
[13:36:56.119]                         base::library(pkg, character.only = TRUE)
[13:36:56.119]                       }
[13:36:56.119]                     })
[13:36:56.119]                   }
[13:36:56.119]                   ...future.strategy.old <- future::plan("list")
[13:36:56.119]                   options(future.plan = NULL)
[13:36:56.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.119]                 }
[13:36:56.119]                 ...future.workdir <- getwd()
[13:36:56.119]             }
[13:36:56.119]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.119]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.119]         }
[13:36:56.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.119]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.119]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.119]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.119]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.119]             base::names(...future.oldOptions))
[13:36:56.119]     }
[13:36:56.119]     if (FALSE) {
[13:36:56.119]     }
[13:36:56.119]     else {
[13:36:56.119]         if (TRUE) {
[13:36:56.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.119]                 open = "w")
[13:36:56.119]         }
[13:36:56.119]         else {
[13:36:56.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.119]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.119]         }
[13:36:56.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.119]             base::sink(type = "output", split = FALSE)
[13:36:56.119]             base::close(...future.stdout)
[13:36:56.119]         }, add = TRUE)
[13:36:56.119]     }
[13:36:56.119]     ...future.frame <- base::sys.nframe()
[13:36:56.119]     ...future.conditions <- base::list()
[13:36:56.119]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.119]     if (FALSE) {
[13:36:56.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.119]     }
[13:36:56.119]     ...future.result <- base::tryCatch({
[13:36:56.119]         base::withCallingHandlers({
[13:36:56.119]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:36:56.119]                 1))
[13:36:56.119]             future::FutureResult(value = ...future.value$value, 
[13:36:56.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.119]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.119]                     ...future.globalenv.names))
[13:36:56.119]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.119]         }, condition = base::local({
[13:36:56.119]             c <- base::c
[13:36:56.119]             inherits <- base::inherits
[13:36:56.119]             invokeRestart <- base::invokeRestart
[13:36:56.119]             length <- base::length
[13:36:56.119]             list <- base::list
[13:36:56.119]             seq.int <- base::seq.int
[13:36:56.119]             signalCondition <- base::signalCondition
[13:36:56.119]             sys.calls <- base::sys.calls
[13:36:56.119]             `[[` <- base::`[[`
[13:36:56.119]             `+` <- base::`+`
[13:36:56.119]             `<<-` <- base::`<<-`
[13:36:56.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.119]                   3L)]
[13:36:56.119]             }
[13:36:56.119]             function(cond) {
[13:36:56.119]                 is_error <- inherits(cond, "error")
[13:36:56.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.119]                   NULL)
[13:36:56.119]                 if (is_error) {
[13:36:56.119]                   sessionInformation <- function() {
[13:36:56.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.119]                       search = base::search(), system = base::Sys.info())
[13:36:56.119]                   }
[13:36:56.119]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.119]                     cond$call), session = sessionInformation(), 
[13:36:56.119]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.119]                   signalCondition(cond)
[13:36:56.119]                 }
[13:36:56.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.119]                 "immediateCondition"))) {
[13:36:56.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.119]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.119]                   if (TRUE && !signal) {
[13:36:56.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.119]                     {
[13:36:56.119]                       inherits <- base::inherits
[13:36:56.119]                       invokeRestart <- base::invokeRestart
[13:36:56.119]                       is.null <- base::is.null
[13:36:56.119]                       muffled <- FALSE
[13:36:56.119]                       if (inherits(cond, "message")) {
[13:36:56.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.119]                         if (muffled) 
[13:36:56.119]                           invokeRestart("muffleMessage")
[13:36:56.119]                       }
[13:36:56.119]                       else if (inherits(cond, "warning")) {
[13:36:56.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.119]                         if (muffled) 
[13:36:56.119]                           invokeRestart("muffleWarning")
[13:36:56.119]                       }
[13:36:56.119]                       else if (inherits(cond, "condition")) {
[13:36:56.119]                         if (!is.null(pattern)) {
[13:36:56.119]                           computeRestarts <- base::computeRestarts
[13:36:56.119]                           grepl <- base::grepl
[13:36:56.119]                           restarts <- computeRestarts(cond)
[13:36:56.119]                           for (restart in restarts) {
[13:36:56.119]                             name <- restart$name
[13:36:56.119]                             if (is.null(name)) 
[13:36:56.119]                               next
[13:36:56.119]                             if (!grepl(pattern, name)) 
[13:36:56.119]                               next
[13:36:56.119]                             invokeRestart(restart)
[13:36:56.119]                             muffled <- TRUE
[13:36:56.119]                             break
[13:36:56.119]                           }
[13:36:56.119]                         }
[13:36:56.119]                       }
[13:36:56.119]                       invisible(muffled)
[13:36:56.119]                     }
[13:36:56.119]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.119]                   }
[13:36:56.119]                 }
[13:36:56.119]                 else {
[13:36:56.119]                   if (TRUE) {
[13:36:56.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.119]                     {
[13:36:56.119]                       inherits <- base::inherits
[13:36:56.119]                       invokeRestart <- base::invokeRestart
[13:36:56.119]                       is.null <- base::is.null
[13:36:56.119]                       muffled <- FALSE
[13:36:56.119]                       if (inherits(cond, "message")) {
[13:36:56.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.119]                         if (muffled) 
[13:36:56.119]                           invokeRestart("muffleMessage")
[13:36:56.119]                       }
[13:36:56.119]                       else if (inherits(cond, "warning")) {
[13:36:56.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.119]                         if (muffled) 
[13:36:56.119]                           invokeRestart("muffleWarning")
[13:36:56.119]                       }
[13:36:56.119]                       else if (inherits(cond, "condition")) {
[13:36:56.119]                         if (!is.null(pattern)) {
[13:36:56.119]                           computeRestarts <- base::computeRestarts
[13:36:56.119]                           grepl <- base::grepl
[13:36:56.119]                           restarts <- computeRestarts(cond)
[13:36:56.119]                           for (restart in restarts) {
[13:36:56.119]                             name <- restart$name
[13:36:56.119]                             if (is.null(name)) 
[13:36:56.119]                               next
[13:36:56.119]                             if (!grepl(pattern, name)) 
[13:36:56.119]                               next
[13:36:56.119]                             invokeRestart(restart)
[13:36:56.119]                             muffled <- TRUE
[13:36:56.119]                             break
[13:36:56.119]                           }
[13:36:56.119]                         }
[13:36:56.119]                       }
[13:36:56.119]                       invisible(muffled)
[13:36:56.119]                     }
[13:36:56.119]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.119]                   }
[13:36:56.119]                 }
[13:36:56.119]             }
[13:36:56.119]         }))
[13:36:56.119]     }, error = function(ex) {
[13:36:56.119]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.119]                 ...future.rng), started = ...future.startTime, 
[13:36:56.119]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.119]             version = "1.8"), class = "FutureResult")
[13:36:56.119]     }, finally = {
[13:36:56.119]         if (!identical(...future.workdir, getwd())) 
[13:36:56.119]             setwd(...future.workdir)
[13:36:56.119]         {
[13:36:56.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.119]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.119]             }
[13:36:56.119]             base::options(...future.oldOptions)
[13:36:56.119]             if (.Platform$OS.type == "windows") {
[13:36:56.119]                 old_names <- names(...future.oldEnvVars)
[13:36:56.119]                 envs <- base::Sys.getenv()
[13:36:56.119]                 names <- names(envs)
[13:36:56.119]                 common <- intersect(names, old_names)
[13:36:56.119]                 added <- setdiff(names, old_names)
[13:36:56.119]                 removed <- setdiff(old_names, names)
[13:36:56.119]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.119]                   envs[common]]
[13:36:56.119]                 NAMES <- toupper(changed)
[13:36:56.119]                 args <- list()
[13:36:56.119]                 for (kk in seq_along(NAMES)) {
[13:36:56.119]                   name <- changed[[kk]]
[13:36:56.119]                   NAME <- NAMES[[kk]]
[13:36:56.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.119]                     next
[13:36:56.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.119]                 }
[13:36:56.119]                 NAMES <- toupper(added)
[13:36:56.119]                 for (kk in seq_along(NAMES)) {
[13:36:56.119]                   name <- added[[kk]]
[13:36:56.119]                   NAME <- NAMES[[kk]]
[13:36:56.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.119]                     next
[13:36:56.119]                   args[[name]] <- ""
[13:36:56.119]                 }
[13:36:56.119]                 NAMES <- toupper(removed)
[13:36:56.119]                 for (kk in seq_along(NAMES)) {
[13:36:56.119]                   name <- removed[[kk]]
[13:36:56.119]                   NAME <- NAMES[[kk]]
[13:36:56.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.119]                     next
[13:36:56.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.119]                 }
[13:36:56.119]                 if (length(args) > 0) 
[13:36:56.119]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.119]             }
[13:36:56.119]             else {
[13:36:56.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.119]             }
[13:36:56.119]             {
[13:36:56.119]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.119]                   0L) {
[13:36:56.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.119]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.119]                   base::options(opts)
[13:36:56.119]                 }
[13:36:56.119]                 {
[13:36:56.119]                   {
[13:36:56.119]                     NULL
[13:36:56.119]                     RNGkind("Mersenne-Twister")
[13:36:56.119]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.119]                       inherits = FALSE)
[13:36:56.119]                   }
[13:36:56.119]                   options(future.plan = NULL)
[13:36:56.119]                   if (is.na(NA_character_)) 
[13:36:56.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.119]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.119]                     .init = FALSE)
[13:36:56.119]                 }
[13:36:56.119]             }
[13:36:56.119]         }
[13:36:56.119]     })
[13:36:56.119]     if (TRUE) {
[13:36:56.119]         base::sink(type = "output", split = FALSE)
[13:36:56.119]         if (TRUE) {
[13:36:56.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.119]         }
[13:36:56.119]         else {
[13:36:56.119]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.119]         }
[13:36:56.119]         base::close(...future.stdout)
[13:36:56.119]         ...future.stdout <- NULL
[13:36:56.119]     }
[13:36:56.119]     ...future.result$conditions <- ...future.conditions
[13:36:56.119]     ...future.result$finished <- base::Sys.time()
[13:36:56.119]     ...future.result
[13:36:56.119] }
[13:36:56.120] assign_globals() ...
[13:36:56.120] List of 1
[13:36:56.120]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c6dcc39c98> 
[13:36:56.120]  - attr(*, "where")=List of 1
[13:36:56.120]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.120]  - attr(*, "resolved")= logi TRUE
[13:36:56.120]  - attr(*, "total_size")= num 1621800
[13:36:56.120]  - attr(*, "already-done")= logi TRUE
[13:36:56.123] - copied ‘a’ to environment
[13:36:56.123] assign_globals() ... done
[13:36:56.123] plan(): Setting new future strategy stack:
[13:36:56.123] List of future strategies:
[13:36:56.123] 1. sequential:
[13:36:56.123]    - args: function (..., envir = parent.frame())
[13:36:56.123]    - tweaked: FALSE
[13:36:56.123]    - call: NULL
[13:36:56.123] plan(): nbrOfWorkers() = 1
[13:36:56.124] plan(): Setting new future strategy stack:
[13:36:56.124] List of future strategies:
[13:36:56.124] 1. sequential:
[13:36:56.124]    - args: function (..., envir = parent.frame())
[13:36:56.124]    - tweaked: FALSE
[13:36:56.124]    - call: plan(strategy)
[13:36:56.125] plan(): nbrOfWorkers() = 1
[13:36:56.125] SequentialFuture started (and completed)
[13:36:56.125] - Launch lazy future ... done
[13:36:56.125] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.125] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.126] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.126] 
[13:36:56.126] Searching for globals ... DONE
[13:36:56.126] - globals: [0] <none>
[13:36:56.126] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.127] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.127] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.127] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:56.127] Searching for globals ... DONE
[13:36:56.128] Resolving globals: TRUE
[13:36:56.128] Resolving any globals that are futures ...
[13:36:56.128] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:56.128] Resolving any globals that are futures ... DONE
[13:36:56.128] Resolving futures part of globals (recursively) ...
[13:36:56.128] resolve() on list ...
[13:36:56.128]  recursive: 99
[13:36:56.129]  length: 1
[13:36:56.129]  elements: ‘a’
[13:36:56.129] run() for ‘Future’ ...
[13:36:56.129] - state: ‘created’
[13:36:56.129] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.129] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.129] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.129]   - Field: ‘label’
[13:36:56.129]   - Field: ‘local’
[13:36:56.130]   - Field: ‘owner’
[13:36:56.130]   - Field: ‘envir’
[13:36:56.130]   - Field: ‘packages’
[13:36:56.130]   - Field: ‘gc’
[13:36:56.130]   - Field: ‘conditions’
[13:36:56.130]   - Field: ‘expr’
[13:36:56.130]   - Field: ‘uuid’
[13:36:56.130]   - Field: ‘seed’
[13:36:56.130]   - Field: ‘version’
[13:36:56.131]   - Field: ‘result’
[13:36:56.131]   - Field: ‘asynchronous’
[13:36:56.131]   - Field: ‘calls’
[13:36:56.131]   - Field: ‘globals’
[13:36:56.132]   - Field: ‘stdout’
[13:36:56.132]   - Field: ‘earlySignal’
[13:36:56.132]   - Field: ‘lazy’
[13:36:56.132]   - Field: ‘state’
[13:36:56.132] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.132] - Launch lazy future ...
[13:36:56.132] Packages needed by the future expression (n = 0): <none>
[13:36:56.132] Packages needed by future strategies (n = 0): <none>
[13:36:56.133] {
[13:36:56.133]     {
[13:36:56.133]         {
[13:36:56.133]             ...future.startTime <- base::Sys.time()
[13:36:56.133]             {
[13:36:56.133]                 {
[13:36:56.133]                   {
[13:36:56.133]                     base::local({
[13:36:56.133]                       has_future <- base::requireNamespace("future", 
[13:36:56.133]                         quietly = TRUE)
[13:36:56.133]                       if (has_future) {
[13:36:56.133]                         ns <- base::getNamespace("future")
[13:36:56.133]                         version <- ns[[".package"]][["version"]]
[13:36:56.133]                         if (is.null(version)) 
[13:36:56.133]                           version <- utils::packageVersion("future")
[13:36:56.133]                       }
[13:36:56.133]                       else {
[13:36:56.133]                         version <- NULL
[13:36:56.133]                       }
[13:36:56.133]                       if (!has_future || version < "1.8.0") {
[13:36:56.133]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.133]                           "", base::R.version$version.string), 
[13:36:56.133]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.133]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.133]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.133]                             "release", "version")], collapse = " "), 
[13:36:56.133]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.133]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.133]                           info)
[13:36:56.133]                         info <- base::paste(info, collapse = "; ")
[13:36:56.133]                         if (!has_future) {
[13:36:56.133]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.133]                             info)
[13:36:56.133]                         }
[13:36:56.133]                         else {
[13:36:56.133]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.133]                             info, version)
[13:36:56.133]                         }
[13:36:56.133]                         base::stop(msg)
[13:36:56.133]                       }
[13:36:56.133]                     })
[13:36:56.133]                   }
[13:36:56.133]                   ...future.strategy.old <- future::plan("list")
[13:36:56.133]                   options(future.plan = NULL)
[13:36:56.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.133]                 }
[13:36:56.133]                 ...future.workdir <- getwd()
[13:36:56.133]             }
[13:36:56.133]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.133]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.133]         }
[13:36:56.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.133]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.133]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.133]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.133]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.133]             base::names(...future.oldOptions))
[13:36:56.133]     }
[13:36:56.133]     if (FALSE) {
[13:36:56.133]     }
[13:36:56.133]     else {
[13:36:56.133]         if (TRUE) {
[13:36:56.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.133]                 open = "w")
[13:36:56.133]         }
[13:36:56.133]         else {
[13:36:56.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.133]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.133]         }
[13:36:56.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.133]             base::sink(type = "output", split = FALSE)
[13:36:56.133]             base::close(...future.stdout)
[13:36:56.133]         }, add = TRUE)
[13:36:56.133]     }
[13:36:56.133]     ...future.frame <- base::sys.nframe()
[13:36:56.133]     ...future.conditions <- base::list()
[13:36:56.133]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.133]     if (FALSE) {
[13:36:56.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.133]     }
[13:36:56.133]     ...future.result <- base::tryCatch({
[13:36:56.133]         base::withCallingHandlers({
[13:36:56.133]             ...future.value <- base::withVisible(base::local(1))
[13:36:56.133]             future::FutureResult(value = ...future.value$value, 
[13:36:56.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.133]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.133]                     ...future.globalenv.names))
[13:36:56.133]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.133]         }, condition = base::local({
[13:36:56.133]             c <- base::c
[13:36:56.133]             inherits <- base::inherits
[13:36:56.133]             invokeRestart <- base::invokeRestart
[13:36:56.133]             length <- base::length
[13:36:56.133]             list <- base::list
[13:36:56.133]             seq.int <- base::seq.int
[13:36:56.133]             signalCondition <- base::signalCondition
[13:36:56.133]             sys.calls <- base::sys.calls
[13:36:56.133]             `[[` <- base::`[[`
[13:36:56.133]             `+` <- base::`+`
[13:36:56.133]             `<<-` <- base::`<<-`
[13:36:56.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.133]                   3L)]
[13:36:56.133]             }
[13:36:56.133]             function(cond) {
[13:36:56.133]                 is_error <- inherits(cond, "error")
[13:36:56.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.133]                   NULL)
[13:36:56.133]                 if (is_error) {
[13:36:56.133]                   sessionInformation <- function() {
[13:36:56.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.133]                       search = base::search(), system = base::Sys.info())
[13:36:56.133]                   }
[13:36:56.133]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.133]                     cond$call), session = sessionInformation(), 
[13:36:56.133]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.133]                   signalCondition(cond)
[13:36:56.133]                 }
[13:36:56.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.133]                 "immediateCondition"))) {
[13:36:56.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.133]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.133]                   if (TRUE && !signal) {
[13:36:56.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.133]                     {
[13:36:56.133]                       inherits <- base::inherits
[13:36:56.133]                       invokeRestart <- base::invokeRestart
[13:36:56.133]                       is.null <- base::is.null
[13:36:56.133]                       muffled <- FALSE
[13:36:56.133]                       if (inherits(cond, "message")) {
[13:36:56.133]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.133]                         if (muffled) 
[13:36:56.133]                           invokeRestart("muffleMessage")
[13:36:56.133]                       }
[13:36:56.133]                       else if (inherits(cond, "warning")) {
[13:36:56.133]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.133]                         if (muffled) 
[13:36:56.133]                           invokeRestart("muffleWarning")
[13:36:56.133]                       }
[13:36:56.133]                       else if (inherits(cond, "condition")) {
[13:36:56.133]                         if (!is.null(pattern)) {
[13:36:56.133]                           computeRestarts <- base::computeRestarts
[13:36:56.133]                           grepl <- base::grepl
[13:36:56.133]                           restarts <- computeRestarts(cond)
[13:36:56.133]                           for (restart in restarts) {
[13:36:56.133]                             name <- restart$name
[13:36:56.133]                             if (is.null(name)) 
[13:36:56.133]                               next
[13:36:56.133]                             if (!grepl(pattern, name)) 
[13:36:56.133]                               next
[13:36:56.133]                             invokeRestart(restart)
[13:36:56.133]                             muffled <- TRUE
[13:36:56.133]                             break
[13:36:56.133]                           }
[13:36:56.133]                         }
[13:36:56.133]                       }
[13:36:56.133]                       invisible(muffled)
[13:36:56.133]                     }
[13:36:56.133]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.133]                   }
[13:36:56.133]                 }
[13:36:56.133]                 else {
[13:36:56.133]                   if (TRUE) {
[13:36:56.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.133]                     {
[13:36:56.133]                       inherits <- base::inherits
[13:36:56.133]                       invokeRestart <- base::invokeRestart
[13:36:56.133]                       is.null <- base::is.null
[13:36:56.133]                       muffled <- FALSE
[13:36:56.133]                       if (inherits(cond, "message")) {
[13:36:56.133]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.133]                         if (muffled) 
[13:36:56.133]                           invokeRestart("muffleMessage")
[13:36:56.133]                       }
[13:36:56.133]                       else if (inherits(cond, "warning")) {
[13:36:56.133]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.133]                         if (muffled) 
[13:36:56.133]                           invokeRestart("muffleWarning")
[13:36:56.133]                       }
[13:36:56.133]                       else if (inherits(cond, "condition")) {
[13:36:56.133]                         if (!is.null(pattern)) {
[13:36:56.133]                           computeRestarts <- base::computeRestarts
[13:36:56.133]                           grepl <- base::grepl
[13:36:56.133]                           restarts <- computeRestarts(cond)
[13:36:56.133]                           for (restart in restarts) {
[13:36:56.133]                             name <- restart$name
[13:36:56.133]                             if (is.null(name)) 
[13:36:56.133]                               next
[13:36:56.133]                             if (!grepl(pattern, name)) 
[13:36:56.133]                               next
[13:36:56.133]                             invokeRestart(restart)
[13:36:56.133]                             muffled <- TRUE
[13:36:56.133]                             break
[13:36:56.133]                           }
[13:36:56.133]                         }
[13:36:56.133]                       }
[13:36:56.133]                       invisible(muffled)
[13:36:56.133]                     }
[13:36:56.133]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.133]                   }
[13:36:56.133]                 }
[13:36:56.133]             }
[13:36:56.133]         }))
[13:36:56.133]     }, error = function(ex) {
[13:36:56.133]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.133]                 ...future.rng), started = ...future.startTime, 
[13:36:56.133]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.133]             version = "1.8"), class = "FutureResult")
[13:36:56.133]     }, finally = {
[13:36:56.133]         if (!identical(...future.workdir, getwd())) 
[13:36:56.133]             setwd(...future.workdir)
[13:36:56.133]         {
[13:36:56.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.133]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.133]             }
[13:36:56.133]             base::options(...future.oldOptions)
[13:36:56.133]             if (.Platform$OS.type == "windows") {
[13:36:56.133]                 old_names <- names(...future.oldEnvVars)
[13:36:56.133]                 envs <- base::Sys.getenv()
[13:36:56.133]                 names <- names(envs)
[13:36:56.133]                 common <- intersect(names, old_names)
[13:36:56.133]                 added <- setdiff(names, old_names)
[13:36:56.133]                 removed <- setdiff(old_names, names)
[13:36:56.133]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.133]                   envs[common]]
[13:36:56.133]                 NAMES <- toupper(changed)
[13:36:56.133]                 args <- list()
[13:36:56.133]                 for (kk in seq_along(NAMES)) {
[13:36:56.133]                   name <- changed[[kk]]
[13:36:56.133]                   NAME <- NAMES[[kk]]
[13:36:56.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.133]                     next
[13:36:56.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.133]                 }
[13:36:56.133]                 NAMES <- toupper(added)
[13:36:56.133]                 for (kk in seq_along(NAMES)) {
[13:36:56.133]                   name <- added[[kk]]
[13:36:56.133]                   NAME <- NAMES[[kk]]
[13:36:56.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.133]                     next
[13:36:56.133]                   args[[name]] <- ""
[13:36:56.133]                 }
[13:36:56.133]                 NAMES <- toupper(removed)
[13:36:56.133]                 for (kk in seq_along(NAMES)) {
[13:36:56.133]                   name <- removed[[kk]]
[13:36:56.133]                   NAME <- NAMES[[kk]]
[13:36:56.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.133]                     next
[13:36:56.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.133]                 }
[13:36:56.133]                 if (length(args) > 0) 
[13:36:56.133]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.133]             }
[13:36:56.133]             else {
[13:36:56.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.133]             }
[13:36:56.133]             {
[13:36:56.133]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.133]                   0L) {
[13:36:56.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.133]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.133]                   base::options(opts)
[13:36:56.133]                 }
[13:36:56.133]                 {
[13:36:56.133]                   {
[13:36:56.133]                     NULL
[13:36:56.133]                     RNGkind("Mersenne-Twister")
[13:36:56.133]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.133]                       inherits = FALSE)
[13:36:56.133]                   }
[13:36:56.133]                   options(future.plan = NULL)
[13:36:56.133]                   if (is.na(NA_character_)) 
[13:36:56.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.133]                     .init = FALSE)
[13:36:56.133]                 }
[13:36:56.133]             }
[13:36:56.133]         }
[13:36:56.133]     })
[13:36:56.133]     if (TRUE) {
[13:36:56.133]         base::sink(type = "output", split = FALSE)
[13:36:56.133]         if (TRUE) {
[13:36:56.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.133]         }
[13:36:56.133]         else {
[13:36:56.133]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.133]         }
[13:36:56.133]         base::close(...future.stdout)
[13:36:56.133]         ...future.stdout <- NULL
[13:36:56.133]     }
[13:36:56.133]     ...future.result$conditions <- ...future.conditions
[13:36:56.133]     ...future.result$finished <- base::Sys.time()
[13:36:56.133]     ...future.result
[13:36:56.133] }
[13:36:56.134] plan(): Setting new future strategy stack:
[13:36:56.135] List of future strategies:
[13:36:56.135] 1. sequential:
[13:36:56.135]    - args: function (..., envir = parent.frame())
[13:36:56.135]    - tweaked: FALSE
[13:36:56.135]    - call: NULL
[13:36:56.135] plan(): nbrOfWorkers() = 1
[13:36:56.136] plan(): Setting new future strategy stack:
[13:36:56.136] List of future strategies:
[13:36:56.136] 1. sequential:
[13:36:56.136]    - args: function (..., envir = parent.frame())
[13:36:56.136]    - tweaked: FALSE
[13:36:56.136]    - call: plan(strategy)
[13:36:56.136] plan(): nbrOfWorkers() = 1
[13:36:56.136] SequentialFuture started (and completed)
[13:36:56.136] - Launch lazy future ... done
[13:36:56.136] run() for ‘SequentialFuture’ ... done
[13:36:56.136] resolved() for ‘SequentialFuture’ ...
[13:36:56.136] - state: ‘finished’
[13:36:56.137] - run: TRUE
[13:36:56.137] - result: ‘FutureResult’
[13:36:56.137] resolved() for ‘SequentialFuture’ ... done
[13:36:56.137] Future #1
[13:36:56.137] resolved() for ‘SequentialFuture’ ...
[13:36:56.137] - state: ‘finished’
[13:36:56.137] - run: TRUE
[13:36:56.137] - result: ‘FutureResult’
[13:36:56.137] resolved() for ‘SequentialFuture’ ... done
[13:36:56.137] A SequentialFuture was resolved
[13:36:56.138]  length: 0 (resolved future 1)
[13:36:56.138] resolve() on list ... DONE
[13:36:56.138] - globals: [1] ‘a’
[13:36:56.138] Resolving futures part of globals (recursively) ... DONE
[13:36:56.139] The total size of the 1 globals is 1.55 MiB (1621968 bytes)
[13:36:56.140] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:36:56.140] - globals: [1] ‘a’
[13:36:56.140] - packages: [1] ‘future’
[13:36:56.140] getGlobalsAndPackages() ... DONE
[13:36:56.140] run() for ‘Future’ ...
[13:36:56.140] - state: ‘created’
[13:36:56.141] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.141] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.141] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.141]   - Field: ‘label’
[13:36:56.141]   - Field: ‘local’
[13:36:56.141]   - Field: ‘owner’
[13:36:56.141]   - Field: ‘envir’
[13:36:56.141]   - Field: ‘packages’
[13:36:56.141]   - Field: ‘gc’
[13:36:56.142]   - Field: ‘conditions’
[13:36:56.142]   - Field: ‘expr’
[13:36:56.142]   - Field: ‘uuid’
[13:36:56.142]   - Field: ‘seed’
[13:36:56.142]   - Field: ‘version’
[13:36:56.142]   - Field: ‘result’
[13:36:56.142]   - Field: ‘asynchronous’
[13:36:56.142]   - Field: ‘calls’
[13:36:56.142]   - Field: ‘globals’
[13:36:56.142]   - Field: ‘stdout’
[13:36:56.142]   - Field: ‘earlySignal’
[13:36:56.143]   - Field: ‘lazy’
[13:36:56.143]   - Field: ‘state’
[13:36:56.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.143] - Launch lazy future ...
[13:36:56.143] Packages needed by the future expression (n = 1): ‘future’
[13:36:56.143] Packages needed by future strategies (n = 0): <none>
[13:36:56.143] {
[13:36:56.143]     {
[13:36:56.143]         {
[13:36:56.143]             ...future.startTime <- base::Sys.time()
[13:36:56.143]             {
[13:36:56.143]                 {
[13:36:56.143]                   {
[13:36:56.143]                     {
[13:36:56.143]                       base::local({
[13:36:56.143]                         has_future <- base::requireNamespace("future", 
[13:36:56.143]                           quietly = TRUE)
[13:36:56.143]                         if (has_future) {
[13:36:56.143]                           ns <- base::getNamespace("future")
[13:36:56.143]                           version <- ns[[".package"]][["version"]]
[13:36:56.143]                           if (is.null(version)) 
[13:36:56.143]                             version <- utils::packageVersion("future")
[13:36:56.143]                         }
[13:36:56.143]                         else {
[13:36:56.143]                           version <- NULL
[13:36:56.143]                         }
[13:36:56.143]                         if (!has_future || version < "1.8.0") {
[13:36:56.143]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.143]                             "", base::R.version$version.string), 
[13:36:56.143]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.143]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.143]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.143]                               "release", "version")], collapse = " "), 
[13:36:56.143]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.143]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.143]                             info)
[13:36:56.143]                           info <- base::paste(info, collapse = "; ")
[13:36:56.143]                           if (!has_future) {
[13:36:56.143]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.143]                               info)
[13:36:56.143]                           }
[13:36:56.143]                           else {
[13:36:56.143]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.143]                               info, version)
[13:36:56.143]                           }
[13:36:56.143]                           base::stop(msg)
[13:36:56.143]                         }
[13:36:56.143]                       })
[13:36:56.143]                     }
[13:36:56.143]                     base::local({
[13:36:56.143]                       for (pkg in "future") {
[13:36:56.143]                         base::loadNamespace(pkg)
[13:36:56.143]                         base::library(pkg, character.only = TRUE)
[13:36:56.143]                       }
[13:36:56.143]                     })
[13:36:56.143]                   }
[13:36:56.143]                   ...future.strategy.old <- future::plan("list")
[13:36:56.143]                   options(future.plan = NULL)
[13:36:56.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.143]                 }
[13:36:56.143]                 ...future.workdir <- getwd()
[13:36:56.143]             }
[13:36:56.143]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.143]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.143]         }
[13:36:56.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.143]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.143]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.143]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.143]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.143]             base::names(...future.oldOptions))
[13:36:56.143]     }
[13:36:56.143]     if (FALSE) {
[13:36:56.143]     }
[13:36:56.143]     else {
[13:36:56.143]         if (TRUE) {
[13:36:56.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.143]                 open = "w")
[13:36:56.143]         }
[13:36:56.143]         else {
[13:36:56.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.143]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.143]         }
[13:36:56.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.143]             base::sink(type = "output", split = FALSE)
[13:36:56.143]             base::close(...future.stdout)
[13:36:56.143]         }, add = TRUE)
[13:36:56.143]     }
[13:36:56.143]     ...future.frame <- base::sys.nframe()
[13:36:56.143]     ...future.conditions <- base::list()
[13:36:56.143]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.143]     if (FALSE) {
[13:36:56.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.143]     }
[13:36:56.143]     ...future.result <- base::tryCatch({
[13:36:56.143]         base::withCallingHandlers({
[13:36:56.143]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:36:56.143]                 1))
[13:36:56.143]             future::FutureResult(value = ...future.value$value, 
[13:36:56.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.143]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.143]                     ...future.globalenv.names))
[13:36:56.143]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.143]         }, condition = base::local({
[13:36:56.143]             c <- base::c
[13:36:56.143]             inherits <- base::inherits
[13:36:56.143]             invokeRestart <- base::invokeRestart
[13:36:56.143]             length <- base::length
[13:36:56.143]             list <- base::list
[13:36:56.143]             seq.int <- base::seq.int
[13:36:56.143]             signalCondition <- base::signalCondition
[13:36:56.143]             sys.calls <- base::sys.calls
[13:36:56.143]             `[[` <- base::`[[`
[13:36:56.143]             `+` <- base::`+`
[13:36:56.143]             `<<-` <- base::`<<-`
[13:36:56.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.143]                   3L)]
[13:36:56.143]             }
[13:36:56.143]             function(cond) {
[13:36:56.143]                 is_error <- inherits(cond, "error")
[13:36:56.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.143]                   NULL)
[13:36:56.143]                 if (is_error) {
[13:36:56.143]                   sessionInformation <- function() {
[13:36:56.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.143]                       search = base::search(), system = base::Sys.info())
[13:36:56.143]                   }
[13:36:56.143]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.143]                     cond$call), session = sessionInformation(), 
[13:36:56.143]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.143]                   signalCondition(cond)
[13:36:56.143]                 }
[13:36:56.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.143]                 "immediateCondition"))) {
[13:36:56.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.143]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.143]                   if (TRUE && !signal) {
[13:36:56.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.143]                     {
[13:36:56.143]                       inherits <- base::inherits
[13:36:56.143]                       invokeRestart <- base::invokeRestart
[13:36:56.143]                       is.null <- base::is.null
[13:36:56.143]                       muffled <- FALSE
[13:36:56.143]                       if (inherits(cond, "message")) {
[13:36:56.143]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.143]                         if (muffled) 
[13:36:56.143]                           invokeRestart("muffleMessage")
[13:36:56.143]                       }
[13:36:56.143]                       else if (inherits(cond, "warning")) {
[13:36:56.143]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.143]                         if (muffled) 
[13:36:56.143]                           invokeRestart("muffleWarning")
[13:36:56.143]                       }
[13:36:56.143]                       else if (inherits(cond, "condition")) {
[13:36:56.143]                         if (!is.null(pattern)) {
[13:36:56.143]                           computeRestarts <- base::computeRestarts
[13:36:56.143]                           grepl <- base::grepl
[13:36:56.143]                           restarts <- computeRestarts(cond)
[13:36:56.143]                           for (restart in restarts) {
[13:36:56.143]                             name <- restart$name
[13:36:56.143]                             if (is.null(name)) 
[13:36:56.143]                               next
[13:36:56.143]                             if (!grepl(pattern, name)) 
[13:36:56.143]                               next
[13:36:56.143]                             invokeRestart(restart)
[13:36:56.143]                             muffled <- TRUE
[13:36:56.143]                             break
[13:36:56.143]                           }
[13:36:56.143]                         }
[13:36:56.143]                       }
[13:36:56.143]                       invisible(muffled)
[13:36:56.143]                     }
[13:36:56.143]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.143]                   }
[13:36:56.143]                 }
[13:36:56.143]                 else {
[13:36:56.143]                   if (TRUE) {
[13:36:56.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.143]                     {
[13:36:56.143]                       inherits <- base::inherits
[13:36:56.143]                       invokeRestart <- base::invokeRestart
[13:36:56.143]                       is.null <- base::is.null
[13:36:56.143]                       muffled <- FALSE
[13:36:56.143]                       if (inherits(cond, "message")) {
[13:36:56.143]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.143]                         if (muffled) 
[13:36:56.143]                           invokeRestart("muffleMessage")
[13:36:56.143]                       }
[13:36:56.143]                       else if (inherits(cond, "warning")) {
[13:36:56.143]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.143]                         if (muffled) 
[13:36:56.143]                           invokeRestart("muffleWarning")
[13:36:56.143]                       }
[13:36:56.143]                       else if (inherits(cond, "condition")) {
[13:36:56.143]                         if (!is.null(pattern)) {
[13:36:56.143]                           computeRestarts <- base::computeRestarts
[13:36:56.143]                           grepl <- base::grepl
[13:36:56.143]                           restarts <- computeRestarts(cond)
[13:36:56.143]                           for (restart in restarts) {
[13:36:56.143]                             name <- restart$name
[13:36:56.143]                             if (is.null(name)) 
[13:36:56.143]                               next
[13:36:56.143]                             if (!grepl(pattern, name)) 
[13:36:56.143]                               next
[13:36:56.143]                             invokeRestart(restart)
[13:36:56.143]                             muffled <- TRUE
[13:36:56.143]                             break
[13:36:56.143]                           }
[13:36:56.143]                         }
[13:36:56.143]                       }
[13:36:56.143]                       invisible(muffled)
[13:36:56.143]                     }
[13:36:56.143]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.143]                   }
[13:36:56.143]                 }
[13:36:56.143]             }
[13:36:56.143]         }))
[13:36:56.143]     }, error = function(ex) {
[13:36:56.143]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.143]                 ...future.rng), started = ...future.startTime, 
[13:36:56.143]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.143]             version = "1.8"), class = "FutureResult")
[13:36:56.143]     }, finally = {
[13:36:56.143]         if (!identical(...future.workdir, getwd())) 
[13:36:56.143]             setwd(...future.workdir)
[13:36:56.143]         {
[13:36:56.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.143]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.143]             }
[13:36:56.143]             base::options(...future.oldOptions)
[13:36:56.143]             if (.Platform$OS.type == "windows") {
[13:36:56.143]                 old_names <- names(...future.oldEnvVars)
[13:36:56.143]                 envs <- base::Sys.getenv()
[13:36:56.143]                 names <- names(envs)
[13:36:56.143]                 common <- intersect(names, old_names)
[13:36:56.143]                 added <- setdiff(names, old_names)
[13:36:56.143]                 removed <- setdiff(old_names, names)
[13:36:56.143]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.143]                   envs[common]]
[13:36:56.143]                 NAMES <- toupper(changed)
[13:36:56.143]                 args <- list()
[13:36:56.143]                 for (kk in seq_along(NAMES)) {
[13:36:56.143]                   name <- changed[[kk]]
[13:36:56.143]                   NAME <- NAMES[[kk]]
[13:36:56.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.143]                     next
[13:36:56.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.143]                 }
[13:36:56.143]                 NAMES <- toupper(added)
[13:36:56.143]                 for (kk in seq_along(NAMES)) {
[13:36:56.143]                   name <- added[[kk]]
[13:36:56.143]                   NAME <- NAMES[[kk]]
[13:36:56.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.143]                     next
[13:36:56.143]                   args[[name]] <- ""
[13:36:56.143]                 }
[13:36:56.143]                 NAMES <- toupper(removed)
[13:36:56.143]                 for (kk in seq_along(NAMES)) {
[13:36:56.143]                   name <- removed[[kk]]
[13:36:56.143]                   NAME <- NAMES[[kk]]
[13:36:56.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.143]                     next
[13:36:56.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.143]                 }
[13:36:56.143]                 if (length(args) > 0) 
[13:36:56.143]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.143]             }
[13:36:56.143]             else {
[13:36:56.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.143]             }
[13:36:56.143]             {
[13:36:56.143]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.143]                   0L) {
[13:36:56.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.143]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.143]                   base::options(opts)
[13:36:56.143]                 }
[13:36:56.143]                 {
[13:36:56.143]                   {
[13:36:56.143]                     NULL
[13:36:56.143]                     RNGkind("Mersenne-Twister")
[13:36:56.143]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.143]                       inherits = FALSE)
[13:36:56.143]                   }
[13:36:56.143]                   options(future.plan = NULL)
[13:36:56.143]                   if (is.na(NA_character_)) 
[13:36:56.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.143]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.143]                     .init = FALSE)
[13:36:56.143]                 }
[13:36:56.143]             }
[13:36:56.143]         }
[13:36:56.143]     })
[13:36:56.143]     if (TRUE) {
[13:36:56.143]         base::sink(type = "output", split = FALSE)
[13:36:56.143]         if (TRUE) {
[13:36:56.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.143]         }
[13:36:56.143]         else {
[13:36:56.143]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.143]         }
[13:36:56.143]         base::close(...future.stdout)
[13:36:56.143]         ...future.stdout <- NULL
[13:36:56.143]     }
[13:36:56.143]     ...future.result$conditions <- ...future.conditions
[13:36:56.143]     ...future.result$finished <- base::Sys.time()
[13:36:56.143]     ...future.result
[13:36:56.143] }
[13:36:56.145] assign_globals() ...
[13:36:56.145] List of 1
[13:36:56.145]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c6dcb7e6b0> 
[13:36:56.145]  - attr(*, "where")=List of 1
[13:36:56.145]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.145]  - attr(*, "resolved")= logi TRUE
[13:36:56.145]  - attr(*, "total_size")= num 1621968
[13:36:56.145]  - attr(*, "already-done")= logi TRUE
[13:36:56.147] - copied ‘a’ to environment
[13:36:56.147] assign_globals() ... done
[13:36:56.148] plan(): Setting new future strategy stack:
[13:36:56.148] List of future strategies:
[13:36:56.148] 1. sequential:
[13:36:56.148]    - args: function (..., envir = parent.frame())
[13:36:56.148]    - tweaked: FALSE
[13:36:56.148]    - call: NULL
[13:36:56.148] plan(): nbrOfWorkers() = 1
[13:36:56.149] plan(): Setting new future strategy stack:
[13:36:56.149] List of future strategies:
[13:36:56.149] 1. sequential:
[13:36:56.149]    - args: function (..., envir = parent.frame())
[13:36:56.149]    - tweaked: FALSE
[13:36:56.149]    - call: plan(strategy)
[13:36:56.149] plan(): nbrOfWorkers() = 1
[13:36:56.150] SequentialFuture started (and completed)
[13:36:56.150] - Launch lazy future ... done
[13:36:56.150] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.150] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.150] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.151] 
[13:36:56.151] Searching for globals ... DONE
[13:36:56.151] - globals: [0] <none>
[13:36:56.151] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.151] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.151] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.152] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:56.152] Searching for globals ... DONE
[13:36:56.152] Resolving globals: TRUE
[13:36:56.152] Resolving any globals that are futures ...
[13:36:56.152] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:56.152] Resolving any globals that are futures ... DONE
[13:36:56.153] Resolving futures part of globals (recursively) ...
[13:36:56.153] resolve() on list ...
[13:36:56.153]  recursive: 99
[13:36:56.153]  length: 1
[13:36:56.153]  elements: ‘a’
[13:36:56.153] run() for ‘Future’ ...
[13:36:56.153] - state: ‘created’
[13:36:56.154] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.154] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.154] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.154]   - Field: ‘label’
[13:36:56.154]   - Field: ‘local’
[13:36:56.154]   - Field: ‘owner’
[13:36:56.154]   - Field: ‘envir’
[13:36:56.154]   - Field: ‘packages’
[13:36:56.154]   - Field: ‘gc’
[13:36:56.155]   - Field: ‘conditions’
[13:36:56.155]   - Field: ‘expr’
[13:36:56.155]   - Field: ‘uuid’
[13:36:56.155]   - Field: ‘seed’
[13:36:56.155]   - Field: ‘version’
[13:36:56.155]   - Field: ‘result’
[13:36:56.155]   - Field: ‘asynchronous’
[13:36:56.155]   - Field: ‘calls’
[13:36:56.155]   - Field: ‘globals’
[13:36:56.155]   - Field: ‘stdout’
[13:36:56.155]   - Field: ‘earlySignal’
[13:36:56.156]   - Field: ‘lazy’
[13:36:56.156]   - Field: ‘state’
[13:36:56.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.156] - Launch lazy future ...
[13:36:56.156] Packages needed by the future expression (n = 0): <none>
[13:36:56.156] Packages needed by future strategies (n = 0): <none>
[13:36:56.156] {
[13:36:56.156]     {
[13:36:56.156]         {
[13:36:56.156]             ...future.startTime <- base::Sys.time()
[13:36:56.156]             {
[13:36:56.156]                 {
[13:36:56.156]                   {
[13:36:56.156]                     base::local({
[13:36:56.156]                       has_future <- base::requireNamespace("future", 
[13:36:56.156]                         quietly = TRUE)
[13:36:56.156]                       if (has_future) {
[13:36:56.156]                         ns <- base::getNamespace("future")
[13:36:56.156]                         version <- ns[[".package"]][["version"]]
[13:36:56.156]                         if (is.null(version)) 
[13:36:56.156]                           version <- utils::packageVersion("future")
[13:36:56.156]                       }
[13:36:56.156]                       else {
[13:36:56.156]                         version <- NULL
[13:36:56.156]                       }
[13:36:56.156]                       if (!has_future || version < "1.8.0") {
[13:36:56.156]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.156]                           "", base::R.version$version.string), 
[13:36:56.156]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.156]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.156]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.156]                             "release", "version")], collapse = " "), 
[13:36:56.156]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.156]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.156]                           info)
[13:36:56.156]                         info <- base::paste(info, collapse = "; ")
[13:36:56.156]                         if (!has_future) {
[13:36:56.156]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.156]                             info)
[13:36:56.156]                         }
[13:36:56.156]                         else {
[13:36:56.156]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.156]                             info, version)
[13:36:56.156]                         }
[13:36:56.156]                         base::stop(msg)
[13:36:56.156]                       }
[13:36:56.156]                     })
[13:36:56.156]                   }
[13:36:56.156]                   ...future.strategy.old <- future::plan("list")
[13:36:56.156]                   options(future.plan = NULL)
[13:36:56.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.156]                 }
[13:36:56.156]                 ...future.workdir <- getwd()
[13:36:56.156]             }
[13:36:56.156]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.156]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.156]         }
[13:36:56.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.156]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.156]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.156]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.156]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.156]             base::names(...future.oldOptions))
[13:36:56.156]     }
[13:36:56.156]     if (FALSE) {
[13:36:56.156]     }
[13:36:56.156]     else {
[13:36:56.156]         if (TRUE) {
[13:36:56.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.156]                 open = "w")
[13:36:56.156]         }
[13:36:56.156]         else {
[13:36:56.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.156]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.156]         }
[13:36:56.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.156]             base::sink(type = "output", split = FALSE)
[13:36:56.156]             base::close(...future.stdout)
[13:36:56.156]         }, add = TRUE)
[13:36:56.156]     }
[13:36:56.156]     ...future.frame <- base::sys.nframe()
[13:36:56.156]     ...future.conditions <- base::list()
[13:36:56.156]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.156]     if (FALSE) {
[13:36:56.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.156]     }
[13:36:56.156]     ...future.result <- base::tryCatch({
[13:36:56.156]         base::withCallingHandlers({
[13:36:56.156]             ...future.value <- base::withVisible(base::local(1))
[13:36:56.156]             future::FutureResult(value = ...future.value$value, 
[13:36:56.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.156]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.156]                     ...future.globalenv.names))
[13:36:56.156]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.156]         }, condition = base::local({
[13:36:56.156]             c <- base::c
[13:36:56.156]             inherits <- base::inherits
[13:36:56.156]             invokeRestart <- base::invokeRestart
[13:36:56.156]             length <- base::length
[13:36:56.156]             list <- base::list
[13:36:56.156]             seq.int <- base::seq.int
[13:36:56.156]             signalCondition <- base::signalCondition
[13:36:56.156]             sys.calls <- base::sys.calls
[13:36:56.156]             `[[` <- base::`[[`
[13:36:56.156]             `+` <- base::`+`
[13:36:56.156]             `<<-` <- base::`<<-`
[13:36:56.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.156]                   3L)]
[13:36:56.156]             }
[13:36:56.156]             function(cond) {
[13:36:56.156]                 is_error <- inherits(cond, "error")
[13:36:56.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.156]                   NULL)
[13:36:56.156]                 if (is_error) {
[13:36:56.156]                   sessionInformation <- function() {
[13:36:56.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.156]                       search = base::search(), system = base::Sys.info())
[13:36:56.156]                   }
[13:36:56.156]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.156]                     cond$call), session = sessionInformation(), 
[13:36:56.156]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.156]                   signalCondition(cond)
[13:36:56.156]                 }
[13:36:56.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.156]                 "immediateCondition"))) {
[13:36:56.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.156]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.156]                   if (TRUE && !signal) {
[13:36:56.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.156]                     {
[13:36:56.156]                       inherits <- base::inherits
[13:36:56.156]                       invokeRestart <- base::invokeRestart
[13:36:56.156]                       is.null <- base::is.null
[13:36:56.156]                       muffled <- FALSE
[13:36:56.156]                       if (inherits(cond, "message")) {
[13:36:56.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.156]                         if (muffled) 
[13:36:56.156]                           invokeRestart("muffleMessage")
[13:36:56.156]                       }
[13:36:56.156]                       else if (inherits(cond, "warning")) {
[13:36:56.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.156]                         if (muffled) 
[13:36:56.156]                           invokeRestart("muffleWarning")
[13:36:56.156]                       }
[13:36:56.156]                       else if (inherits(cond, "condition")) {
[13:36:56.156]                         if (!is.null(pattern)) {
[13:36:56.156]                           computeRestarts <- base::computeRestarts
[13:36:56.156]                           grepl <- base::grepl
[13:36:56.156]                           restarts <- computeRestarts(cond)
[13:36:56.156]                           for (restart in restarts) {
[13:36:56.156]                             name <- restart$name
[13:36:56.156]                             if (is.null(name)) 
[13:36:56.156]                               next
[13:36:56.156]                             if (!grepl(pattern, name)) 
[13:36:56.156]                               next
[13:36:56.156]                             invokeRestart(restart)
[13:36:56.156]                             muffled <- TRUE
[13:36:56.156]                             break
[13:36:56.156]                           }
[13:36:56.156]                         }
[13:36:56.156]                       }
[13:36:56.156]                       invisible(muffled)
[13:36:56.156]                     }
[13:36:56.156]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.156]                   }
[13:36:56.156]                 }
[13:36:56.156]                 else {
[13:36:56.156]                   if (TRUE) {
[13:36:56.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.156]                     {
[13:36:56.156]                       inherits <- base::inherits
[13:36:56.156]                       invokeRestart <- base::invokeRestart
[13:36:56.156]                       is.null <- base::is.null
[13:36:56.156]                       muffled <- FALSE
[13:36:56.156]                       if (inherits(cond, "message")) {
[13:36:56.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.156]                         if (muffled) 
[13:36:56.156]                           invokeRestart("muffleMessage")
[13:36:56.156]                       }
[13:36:56.156]                       else if (inherits(cond, "warning")) {
[13:36:56.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.156]                         if (muffled) 
[13:36:56.156]                           invokeRestart("muffleWarning")
[13:36:56.156]                       }
[13:36:56.156]                       else if (inherits(cond, "condition")) {
[13:36:56.156]                         if (!is.null(pattern)) {
[13:36:56.156]                           computeRestarts <- base::computeRestarts
[13:36:56.156]                           grepl <- base::grepl
[13:36:56.156]                           restarts <- computeRestarts(cond)
[13:36:56.156]                           for (restart in restarts) {
[13:36:56.156]                             name <- restart$name
[13:36:56.156]                             if (is.null(name)) 
[13:36:56.156]                               next
[13:36:56.156]                             if (!grepl(pattern, name)) 
[13:36:56.156]                               next
[13:36:56.156]                             invokeRestart(restart)
[13:36:56.156]                             muffled <- TRUE
[13:36:56.156]                             break
[13:36:56.156]                           }
[13:36:56.156]                         }
[13:36:56.156]                       }
[13:36:56.156]                       invisible(muffled)
[13:36:56.156]                     }
[13:36:56.156]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.156]                   }
[13:36:56.156]                 }
[13:36:56.156]             }
[13:36:56.156]         }))
[13:36:56.156]     }, error = function(ex) {
[13:36:56.156]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.156]                 ...future.rng), started = ...future.startTime, 
[13:36:56.156]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.156]             version = "1.8"), class = "FutureResult")
[13:36:56.156]     }, finally = {
[13:36:56.156]         if (!identical(...future.workdir, getwd())) 
[13:36:56.156]             setwd(...future.workdir)
[13:36:56.156]         {
[13:36:56.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.156]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.156]             }
[13:36:56.156]             base::options(...future.oldOptions)
[13:36:56.156]             if (.Platform$OS.type == "windows") {
[13:36:56.156]                 old_names <- names(...future.oldEnvVars)
[13:36:56.156]                 envs <- base::Sys.getenv()
[13:36:56.156]                 names <- names(envs)
[13:36:56.156]                 common <- intersect(names, old_names)
[13:36:56.156]                 added <- setdiff(names, old_names)
[13:36:56.156]                 removed <- setdiff(old_names, names)
[13:36:56.156]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.156]                   envs[common]]
[13:36:56.156]                 NAMES <- toupper(changed)
[13:36:56.156]                 args <- list()
[13:36:56.156]                 for (kk in seq_along(NAMES)) {
[13:36:56.156]                   name <- changed[[kk]]
[13:36:56.156]                   NAME <- NAMES[[kk]]
[13:36:56.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.156]                     next
[13:36:56.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.156]                 }
[13:36:56.156]                 NAMES <- toupper(added)
[13:36:56.156]                 for (kk in seq_along(NAMES)) {
[13:36:56.156]                   name <- added[[kk]]
[13:36:56.156]                   NAME <- NAMES[[kk]]
[13:36:56.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.156]                     next
[13:36:56.156]                   args[[name]] <- ""
[13:36:56.156]                 }
[13:36:56.156]                 NAMES <- toupper(removed)
[13:36:56.156]                 for (kk in seq_along(NAMES)) {
[13:36:56.156]                   name <- removed[[kk]]
[13:36:56.156]                   NAME <- NAMES[[kk]]
[13:36:56.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.156]                     next
[13:36:56.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.156]                 }
[13:36:56.156]                 if (length(args) > 0) 
[13:36:56.156]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.156]             }
[13:36:56.156]             else {
[13:36:56.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.156]             }
[13:36:56.156]             {
[13:36:56.156]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.156]                   0L) {
[13:36:56.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.156]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.156]                   base::options(opts)
[13:36:56.156]                 }
[13:36:56.156]                 {
[13:36:56.156]                   {
[13:36:56.156]                     NULL
[13:36:56.156]                     RNGkind("Mersenne-Twister")
[13:36:56.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.156]                       inherits = FALSE)
[13:36:56.156]                   }
[13:36:56.156]                   options(future.plan = NULL)
[13:36:56.156]                   if (is.na(NA_character_)) 
[13:36:56.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.156]                     .init = FALSE)
[13:36:56.156]                 }
[13:36:56.156]             }
[13:36:56.156]         }
[13:36:56.156]     })
[13:36:56.156]     if (TRUE) {
[13:36:56.156]         base::sink(type = "output", split = FALSE)
[13:36:56.156]         if (TRUE) {
[13:36:56.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.156]         }
[13:36:56.156]         else {
[13:36:56.156]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.156]         }
[13:36:56.156]         base::close(...future.stdout)
[13:36:56.156]         ...future.stdout <- NULL
[13:36:56.156]     }
[13:36:56.156]     ...future.result$conditions <- ...future.conditions
[13:36:56.156]     ...future.result$finished <- base::Sys.time()
[13:36:56.156]     ...future.result
[13:36:56.156] }
[13:36:56.159] plan(): Setting new future strategy stack:
[13:36:56.159] List of future strategies:
[13:36:56.159] 1. sequential:
[13:36:56.159]    - args: function (..., envir = parent.frame())
[13:36:56.159]    - tweaked: FALSE
[13:36:56.159]    - call: NULL
[13:36:56.159] plan(): nbrOfWorkers() = 1
[13:36:56.160] plan(): Setting new future strategy stack:
[13:36:56.160] List of future strategies:
[13:36:56.160] 1. sequential:
[13:36:56.160]    - args: function (..., envir = parent.frame())
[13:36:56.160]    - tweaked: FALSE
[13:36:56.160]    - call: plan(strategy)
[13:36:56.160] plan(): nbrOfWorkers() = 1
[13:36:56.161] SequentialFuture started (and completed)
[13:36:56.161] - Launch lazy future ... done
[13:36:56.161] run() for ‘SequentialFuture’ ... done
[13:36:56.161] resolved() for ‘SequentialFuture’ ...
[13:36:56.161] - state: ‘finished’
[13:36:56.161] - run: TRUE
[13:36:56.161] - result: ‘FutureResult’
[13:36:56.161] resolved() for ‘SequentialFuture’ ... done
[13:36:56.161] Future #1
[13:36:56.162] resolved() for ‘SequentialFuture’ ...
[13:36:56.162] - state: ‘finished’
[13:36:56.162] - run: TRUE
[13:36:56.162] - result: ‘FutureResult’
[13:36:56.162] resolved() for ‘SequentialFuture’ ... done
[13:36:56.162] A SequentialFuture was resolved
[13:36:56.162]  length: 0 (resolved future 1)
[13:36:56.162] resolve() on list ... DONE
[13:36:56.162] - globals: [1] ‘a’
[13:36:56.162] Resolving futures part of globals (recursively) ... DONE
[13:36:56.164] The total size of the 1 globals is 1.55 MiB (1621968 bytes)
[13:36:56.164] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:36:56.164] - globals: [1] ‘a’
[13:36:56.165] - packages: [1] ‘future’
[13:36:56.165] getGlobalsAndPackages() ... DONE
[13:36:56.165] run() for ‘Future’ ...
[13:36:56.165] - state: ‘created’
[13:36:56.165] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.165] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.165] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.166]   - Field: ‘label’
[13:36:56.166]   - Field: ‘local’
[13:36:56.166]   - Field: ‘owner’
[13:36:56.166]   - Field: ‘envir’
[13:36:56.166]   - Field: ‘packages’
[13:36:56.166]   - Field: ‘gc’
[13:36:56.166]   - Field: ‘conditions’
[13:36:56.166]   - Field: ‘expr’
[13:36:56.166]   - Field: ‘uuid’
[13:36:56.166]   - Field: ‘seed’
[13:36:56.166]   - Field: ‘version’
[13:36:56.166]   - Field: ‘result’
[13:36:56.167]   - Field: ‘asynchronous’
[13:36:56.167]   - Field: ‘calls’
[13:36:56.167]   - Field: ‘globals’
[13:36:56.167]   - Field: ‘stdout’
[13:36:56.167]   - Field: ‘earlySignal’
[13:36:56.167]   - Field: ‘lazy’
[13:36:56.167]   - Field: ‘state’
[13:36:56.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.167] - Launch lazy future ...
[13:36:56.167] Packages needed by the future expression (n = 1): ‘future’
[13:36:56.168] Packages needed by future strategies (n = 0): <none>
[13:36:56.168] {
[13:36:56.168]     {
[13:36:56.168]         {
[13:36:56.168]             ...future.startTime <- base::Sys.time()
[13:36:56.168]             {
[13:36:56.168]                 {
[13:36:56.168]                   {
[13:36:56.168]                     {
[13:36:56.168]                       base::local({
[13:36:56.168]                         has_future <- base::requireNamespace("future", 
[13:36:56.168]                           quietly = TRUE)
[13:36:56.168]                         if (has_future) {
[13:36:56.168]                           ns <- base::getNamespace("future")
[13:36:56.168]                           version <- ns[[".package"]][["version"]]
[13:36:56.168]                           if (is.null(version)) 
[13:36:56.168]                             version <- utils::packageVersion("future")
[13:36:56.168]                         }
[13:36:56.168]                         else {
[13:36:56.168]                           version <- NULL
[13:36:56.168]                         }
[13:36:56.168]                         if (!has_future || version < "1.8.0") {
[13:36:56.168]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.168]                             "", base::R.version$version.string), 
[13:36:56.168]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.168]                               "release", "version")], collapse = " "), 
[13:36:56.168]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.168]                             info)
[13:36:56.168]                           info <- base::paste(info, collapse = "; ")
[13:36:56.168]                           if (!has_future) {
[13:36:56.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.168]                               info)
[13:36:56.168]                           }
[13:36:56.168]                           else {
[13:36:56.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.168]                               info, version)
[13:36:56.168]                           }
[13:36:56.168]                           base::stop(msg)
[13:36:56.168]                         }
[13:36:56.168]                       })
[13:36:56.168]                     }
[13:36:56.168]                     base::local({
[13:36:56.168]                       for (pkg in "future") {
[13:36:56.168]                         base::loadNamespace(pkg)
[13:36:56.168]                         base::library(pkg, character.only = TRUE)
[13:36:56.168]                       }
[13:36:56.168]                     })
[13:36:56.168]                   }
[13:36:56.168]                   ...future.strategy.old <- future::plan("list")
[13:36:56.168]                   options(future.plan = NULL)
[13:36:56.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.168]                 }
[13:36:56.168]                 ...future.workdir <- getwd()
[13:36:56.168]             }
[13:36:56.168]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.168]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.168]         }
[13:36:56.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.168]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.168]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.168]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.168]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.168]             base::names(...future.oldOptions))
[13:36:56.168]     }
[13:36:56.168]     if (FALSE) {
[13:36:56.168]     }
[13:36:56.168]     else {
[13:36:56.168]         if (TRUE) {
[13:36:56.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.168]                 open = "w")
[13:36:56.168]         }
[13:36:56.168]         else {
[13:36:56.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.168]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.168]         }
[13:36:56.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.168]             base::sink(type = "output", split = FALSE)
[13:36:56.168]             base::close(...future.stdout)
[13:36:56.168]         }, add = TRUE)
[13:36:56.168]     }
[13:36:56.168]     ...future.frame <- base::sys.nframe()
[13:36:56.168]     ...future.conditions <- base::list()
[13:36:56.168]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.168]     if (FALSE) {
[13:36:56.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.168]     }
[13:36:56.168]     ...future.result <- base::tryCatch({
[13:36:56.168]         base::withCallingHandlers({
[13:36:56.168]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:36:56.168]                 1))
[13:36:56.168]             future::FutureResult(value = ...future.value$value, 
[13:36:56.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.168]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.168]                     ...future.globalenv.names))
[13:36:56.168]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.168]         }, condition = base::local({
[13:36:56.168]             c <- base::c
[13:36:56.168]             inherits <- base::inherits
[13:36:56.168]             invokeRestart <- base::invokeRestart
[13:36:56.168]             length <- base::length
[13:36:56.168]             list <- base::list
[13:36:56.168]             seq.int <- base::seq.int
[13:36:56.168]             signalCondition <- base::signalCondition
[13:36:56.168]             sys.calls <- base::sys.calls
[13:36:56.168]             `[[` <- base::`[[`
[13:36:56.168]             `+` <- base::`+`
[13:36:56.168]             `<<-` <- base::`<<-`
[13:36:56.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.168]                   3L)]
[13:36:56.168]             }
[13:36:56.168]             function(cond) {
[13:36:56.168]                 is_error <- inherits(cond, "error")
[13:36:56.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.168]                   NULL)
[13:36:56.168]                 if (is_error) {
[13:36:56.168]                   sessionInformation <- function() {
[13:36:56.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.168]                       search = base::search(), system = base::Sys.info())
[13:36:56.168]                   }
[13:36:56.168]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.168]                     cond$call), session = sessionInformation(), 
[13:36:56.168]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.168]                   signalCondition(cond)
[13:36:56.168]                 }
[13:36:56.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.168]                 "immediateCondition"))) {
[13:36:56.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.168]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.168]                   if (TRUE && !signal) {
[13:36:56.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.168]                     {
[13:36:56.168]                       inherits <- base::inherits
[13:36:56.168]                       invokeRestart <- base::invokeRestart
[13:36:56.168]                       is.null <- base::is.null
[13:36:56.168]                       muffled <- FALSE
[13:36:56.168]                       if (inherits(cond, "message")) {
[13:36:56.168]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.168]                         if (muffled) 
[13:36:56.168]                           invokeRestart("muffleMessage")
[13:36:56.168]                       }
[13:36:56.168]                       else if (inherits(cond, "warning")) {
[13:36:56.168]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.168]                         if (muffled) 
[13:36:56.168]                           invokeRestart("muffleWarning")
[13:36:56.168]                       }
[13:36:56.168]                       else if (inherits(cond, "condition")) {
[13:36:56.168]                         if (!is.null(pattern)) {
[13:36:56.168]                           computeRestarts <- base::computeRestarts
[13:36:56.168]                           grepl <- base::grepl
[13:36:56.168]                           restarts <- computeRestarts(cond)
[13:36:56.168]                           for (restart in restarts) {
[13:36:56.168]                             name <- restart$name
[13:36:56.168]                             if (is.null(name)) 
[13:36:56.168]                               next
[13:36:56.168]                             if (!grepl(pattern, name)) 
[13:36:56.168]                               next
[13:36:56.168]                             invokeRestart(restart)
[13:36:56.168]                             muffled <- TRUE
[13:36:56.168]                             break
[13:36:56.168]                           }
[13:36:56.168]                         }
[13:36:56.168]                       }
[13:36:56.168]                       invisible(muffled)
[13:36:56.168]                     }
[13:36:56.168]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.168]                   }
[13:36:56.168]                 }
[13:36:56.168]                 else {
[13:36:56.168]                   if (TRUE) {
[13:36:56.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.168]                     {
[13:36:56.168]                       inherits <- base::inherits
[13:36:56.168]                       invokeRestart <- base::invokeRestart
[13:36:56.168]                       is.null <- base::is.null
[13:36:56.168]                       muffled <- FALSE
[13:36:56.168]                       if (inherits(cond, "message")) {
[13:36:56.168]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.168]                         if (muffled) 
[13:36:56.168]                           invokeRestart("muffleMessage")
[13:36:56.168]                       }
[13:36:56.168]                       else if (inherits(cond, "warning")) {
[13:36:56.168]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.168]                         if (muffled) 
[13:36:56.168]                           invokeRestart("muffleWarning")
[13:36:56.168]                       }
[13:36:56.168]                       else if (inherits(cond, "condition")) {
[13:36:56.168]                         if (!is.null(pattern)) {
[13:36:56.168]                           computeRestarts <- base::computeRestarts
[13:36:56.168]                           grepl <- base::grepl
[13:36:56.168]                           restarts <- computeRestarts(cond)
[13:36:56.168]                           for (restart in restarts) {
[13:36:56.168]                             name <- restart$name
[13:36:56.168]                             if (is.null(name)) 
[13:36:56.168]                               next
[13:36:56.168]                             if (!grepl(pattern, name)) 
[13:36:56.168]                               next
[13:36:56.168]                             invokeRestart(restart)
[13:36:56.168]                             muffled <- TRUE
[13:36:56.168]                             break
[13:36:56.168]                           }
[13:36:56.168]                         }
[13:36:56.168]                       }
[13:36:56.168]                       invisible(muffled)
[13:36:56.168]                     }
[13:36:56.168]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.168]                   }
[13:36:56.168]                 }
[13:36:56.168]             }
[13:36:56.168]         }))
[13:36:56.168]     }, error = function(ex) {
[13:36:56.168]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.168]                 ...future.rng), started = ...future.startTime, 
[13:36:56.168]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.168]             version = "1.8"), class = "FutureResult")
[13:36:56.168]     }, finally = {
[13:36:56.168]         if (!identical(...future.workdir, getwd())) 
[13:36:56.168]             setwd(...future.workdir)
[13:36:56.168]         {
[13:36:56.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.168]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.168]             }
[13:36:56.168]             base::options(...future.oldOptions)
[13:36:56.168]             if (.Platform$OS.type == "windows") {
[13:36:56.168]                 old_names <- names(...future.oldEnvVars)
[13:36:56.168]                 envs <- base::Sys.getenv()
[13:36:56.168]                 names <- names(envs)
[13:36:56.168]                 common <- intersect(names, old_names)
[13:36:56.168]                 added <- setdiff(names, old_names)
[13:36:56.168]                 removed <- setdiff(old_names, names)
[13:36:56.168]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.168]                   envs[common]]
[13:36:56.168]                 NAMES <- toupper(changed)
[13:36:56.168]                 args <- list()
[13:36:56.168]                 for (kk in seq_along(NAMES)) {
[13:36:56.168]                   name <- changed[[kk]]
[13:36:56.168]                   NAME <- NAMES[[kk]]
[13:36:56.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.168]                     next
[13:36:56.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.168]                 }
[13:36:56.168]                 NAMES <- toupper(added)
[13:36:56.168]                 for (kk in seq_along(NAMES)) {
[13:36:56.168]                   name <- added[[kk]]
[13:36:56.168]                   NAME <- NAMES[[kk]]
[13:36:56.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.168]                     next
[13:36:56.168]                   args[[name]] <- ""
[13:36:56.168]                 }
[13:36:56.168]                 NAMES <- toupper(removed)
[13:36:56.168]                 for (kk in seq_along(NAMES)) {
[13:36:56.168]                   name <- removed[[kk]]
[13:36:56.168]                   NAME <- NAMES[[kk]]
[13:36:56.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.168]                     next
[13:36:56.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.168]                 }
[13:36:56.168]                 if (length(args) > 0) 
[13:36:56.168]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.168]             }
[13:36:56.168]             else {
[13:36:56.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.168]             }
[13:36:56.168]             {
[13:36:56.168]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.168]                   0L) {
[13:36:56.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.168]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.168]                   base::options(opts)
[13:36:56.168]                 }
[13:36:56.168]                 {
[13:36:56.168]                   {
[13:36:56.168]                     NULL
[13:36:56.168]                     RNGkind("Mersenne-Twister")
[13:36:56.168]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.168]                       inherits = FALSE)
[13:36:56.168]                   }
[13:36:56.168]                   options(future.plan = NULL)
[13:36:56.168]                   if (is.na(NA_character_)) 
[13:36:56.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.168]                     .init = FALSE)
[13:36:56.168]                 }
[13:36:56.168]             }
[13:36:56.168]         }
[13:36:56.168]     })
[13:36:56.168]     if (TRUE) {
[13:36:56.168]         base::sink(type = "output", split = FALSE)
[13:36:56.168]         if (TRUE) {
[13:36:56.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.168]         }
[13:36:56.168]         else {
[13:36:56.168]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.168]         }
[13:36:56.168]         base::close(...future.stdout)
[13:36:56.168]         ...future.stdout <- NULL
[13:36:56.168]     }
[13:36:56.168]     ...future.result$conditions <- ...future.conditions
[13:36:56.168]     ...future.result$finished <- base::Sys.time()
[13:36:56.168]     ...future.result
[13:36:56.168] }
[13:36:56.170] assign_globals() ...
[13:36:56.170] List of 1
[13:36:56.170]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c6dca73d98> 
[13:36:56.170]  - attr(*, "where")=List of 1
[13:36:56.170]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.170]  - attr(*, "resolved")= logi TRUE
[13:36:56.170]  - attr(*, "total_size")= num 1621968
[13:36:56.170]  - attr(*, "already-done")= logi TRUE
[13:36:56.172] - copied ‘a’ to environment
[13:36:56.172] assign_globals() ... done
[13:36:56.172] plan(): Setting new future strategy stack:
[13:36:56.172] List of future strategies:
[13:36:56.172] 1. sequential:
[13:36:56.172]    - args: function (..., envir = parent.frame())
[13:36:56.172]    - tweaked: FALSE
[13:36:56.172]    - call: NULL
[13:36:56.173] plan(): nbrOfWorkers() = 1
[13:36:56.173] plan(): Setting new future strategy stack:
[13:36:56.174] List of future strategies:
[13:36:56.174] 1. sequential:
[13:36:56.174]    - args: function (..., envir = parent.frame())
[13:36:56.174]    - tweaked: FALSE
[13:36:56.174]    - call: plan(strategy)
[13:36:56.174] plan(): nbrOfWorkers() = 1
[13:36:56.174] SequentialFuture started (and completed)
[13:36:56.174] - Launch lazy future ... done
[13:36:56.174] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.175] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.175] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.176] - globals found: [2] ‘{’, ‘pkg’
[13:36:56.176] Searching for globals ... DONE
[13:36:56.176] Resolving globals: TRUE
[13:36:56.176] Resolving any globals that are futures ...
[13:36:56.176] - globals: [2] ‘{’, ‘pkg’
[13:36:56.176] Resolving any globals that are futures ... DONE
[13:36:56.176] Resolving futures part of globals (recursively) ...
[13:36:56.176] resolve() on list ...
[13:36:56.177]  recursive: 99
[13:36:56.177]  length: 1
[13:36:56.177]  elements: ‘pkg’
[13:36:56.177]  length: 0 (resolved future 1)
[13:36:56.177] resolve() on list ... DONE
[13:36:56.177] - globals: [1] ‘pkg’
[13:36:56.177] Resolving futures part of globals (recursively) ... DONE
[13:36:56.177] The total size of the 1 globals is 112 bytes (112 bytes)
[13:36:56.177] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:36:56.178] - globals: [1] ‘pkg’
[13:36:56.178] 
[13:36:56.178] getGlobalsAndPackages() ... DONE
[13:36:56.178] Packages needed by the future expression (n = 0): <none>
[13:36:56.178] Packages needed by future strategies (n = 0): <none>
[13:36:56.179] {
[13:36:56.179]     {
[13:36:56.179]         {
[13:36:56.179]             ...future.startTime <- base::Sys.time()
[13:36:56.179]             {
[13:36:56.179]                 {
[13:36:56.179]                   {
[13:36:56.179]                     base::local({
[13:36:56.179]                       has_future <- base::requireNamespace("future", 
[13:36:56.179]                         quietly = TRUE)
[13:36:56.179]                       if (has_future) {
[13:36:56.179]                         ns <- base::getNamespace("future")
[13:36:56.179]                         version <- ns[[".package"]][["version"]]
[13:36:56.179]                         if (is.null(version)) 
[13:36:56.179]                           version <- utils::packageVersion("future")
[13:36:56.179]                       }
[13:36:56.179]                       else {
[13:36:56.179]                         version <- NULL
[13:36:56.179]                       }
[13:36:56.179]                       if (!has_future || version < "1.8.0") {
[13:36:56.179]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.179]                           "", base::R.version$version.string), 
[13:36:56.179]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.179]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.179]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.179]                             "release", "version")], collapse = " "), 
[13:36:56.179]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.179]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.179]                           info)
[13:36:56.179]                         info <- base::paste(info, collapse = "; ")
[13:36:56.179]                         if (!has_future) {
[13:36:56.179]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.179]                             info)
[13:36:56.179]                         }
[13:36:56.179]                         else {
[13:36:56.179]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.179]                             info, version)
[13:36:56.179]                         }
[13:36:56.179]                         base::stop(msg)
[13:36:56.179]                       }
[13:36:56.179]                     })
[13:36:56.179]                   }
[13:36:56.179]                   ...future.strategy.old <- future::plan("list")
[13:36:56.179]                   options(future.plan = NULL)
[13:36:56.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.179]                 }
[13:36:56.179]                 ...future.workdir <- getwd()
[13:36:56.179]             }
[13:36:56.179]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.179]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.179]         }
[13:36:56.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.179]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.179]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.179]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.179]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.179]             base::names(...future.oldOptions))
[13:36:56.179]     }
[13:36:56.179]     if (FALSE) {
[13:36:56.179]     }
[13:36:56.179]     else {
[13:36:56.179]         if (TRUE) {
[13:36:56.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.179]                 open = "w")
[13:36:56.179]         }
[13:36:56.179]         else {
[13:36:56.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.179]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.179]         }
[13:36:56.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.179]             base::sink(type = "output", split = FALSE)
[13:36:56.179]             base::close(...future.stdout)
[13:36:56.179]         }, add = TRUE)
[13:36:56.179]     }
[13:36:56.179]     ...future.frame <- base::sys.nframe()
[13:36:56.179]     ...future.conditions <- base::list()
[13:36:56.179]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.179]     if (FALSE) {
[13:36:56.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.179]     }
[13:36:56.179]     ...future.result <- base::tryCatch({
[13:36:56.179]         base::withCallingHandlers({
[13:36:56.179]             ...future.value <- base::withVisible(base::local({
[13:36:56.179]                 pkg
[13:36:56.179]             }))
[13:36:56.179]             future::FutureResult(value = ...future.value$value, 
[13:36:56.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.179]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.179]                     ...future.globalenv.names))
[13:36:56.179]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.179]         }, condition = base::local({
[13:36:56.179]             c <- base::c
[13:36:56.179]             inherits <- base::inherits
[13:36:56.179]             invokeRestart <- base::invokeRestart
[13:36:56.179]             length <- base::length
[13:36:56.179]             list <- base::list
[13:36:56.179]             seq.int <- base::seq.int
[13:36:56.179]             signalCondition <- base::signalCondition
[13:36:56.179]             sys.calls <- base::sys.calls
[13:36:56.179]             `[[` <- base::`[[`
[13:36:56.179]             `+` <- base::`+`
[13:36:56.179]             `<<-` <- base::`<<-`
[13:36:56.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.179]                   3L)]
[13:36:56.179]             }
[13:36:56.179]             function(cond) {
[13:36:56.179]                 is_error <- inherits(cond, "error")
[13:36:56.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.179]                   NULL)
[13:36:56.179]                 if (is_error) {
[13:36:56.179]                   sessionInformation <- function() {
[13:36:56.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.179]                       search = base::search(), system = base::Sys.info())
[13:36:56.179]                   }
[13:36:56.179]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.179]                     cond$call), session = sessionInformation(), 
[13:36:56.179]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.179]                   signalCondition(cond)
[13:36:56.179]                 }
[13:36:56.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.179]                 "immediateCondition"))) {
[13:36:56.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.179]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.179]                   if (TRUE && !signal) {
[13:36:56.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.179]                     {
[13:36:56.179]                       inherits <- base::inherits
[13:36:56.179]                       invokeRestart <- base::invokeRestart
[13:36:56.179]                       is.null <- base::is.null
[13:36:56.179]                       muffled <- FALSE
[13:36:56.179]                       if (inherits(cond, "message")) {
[13:36:56.179]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.179]                         if (muffled) 
[13:36:56.179]                           invokeRestart("muffleMessage")
[13:36:56.179]                       }
[13:36:56.179]                       else if (inherits(cond, "warning")) {
[13:36:56.179]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.179]                         if (muffled) 
[13:36:56.179]                           invokeRestart("muffleWarning")
[13:36:56.179]                       }
[13:36:56.179]                       else if (inherits(cond, "condition")) {
[13:36:56.179]                         if (!is.null(pattern)) {
[13:36:56.179]                           computeRestarts <- base::computeRestarts
[13:36:56.179]                           grepl <- base::grepl
[13:36:56.179]                           restarts <- computeRestarts(cond)
[13:36:56.179]                           for (restart in restarts) {
[13:36:56.179]                             name <- restart$name
[13:36:56.179]                             if (is.null(name)) 
[13:36:56.179]                               next
[13:36:56.179]                             if (!grepl(pattern, name)) 
[13:36:56.179]                               next
[13:36:56.179]                             invokeRestart(restart)
[13:36:56.179]                             muffled <- TRUE
[13:36:56.179]                             break
[13:36:56.179]                           }
[13:36:56.179]                         }
[13:36:56.179]                       }
[13:36:56.179]                       invisible(muffled)
[13:36:56.179]                     }
[13:36:56.179]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.179]                   }
[13:36:56.179]                 }
[13:36:56.179]                 else {
[13:36:56.179]                   if (TRUE) {
[13:36:56.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.179]                     {
[13:36:56.179]                       inherits <- base::inherits
[13:36:56.179]                       invokeRestart <- base::invokeRestart
[13:36:56.179]                       is.null <- base::is.null
[13:36:56.179]                       muffled <- FALSE
[13:36:56.179]                       if (inherits(cond, "message")) {
[13:36:56.179]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.179]                         if (muffled) 
[13:36:56.179]                           invokeRestart("muffleMessage")
[13:36:56.179]                       }
[13:36:56.179]                       else if (inherits(cond, "warning")) {
[13:36:56.179]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.179]                         if (muffled) 
[13:36:56.179]                           invokeRestart("muffleWarning")
[13:36:56.179]                       }
[13:36:56.179]                       else if (inherits(cond, "condition")) {
[13:36:56.179]                         if (!is.null(pattern)) {
[13:36:56.179]                           computeRestarts <- base::computeRestarts
[13:36:56.179]                           grepl <- base::grepl
[13:36:56.179]                           restarts <- computeRestarts(cond)
[13:36:56.179]                           for (restart in restarts) {
[13:36:56.179]                             name <- restart$name
[13:36:56.179]                             if (is.null(name)) 
[13:36:56.179]                               next
[13:36:56.179]                             if (!grepl(pattern, name)) 
[13:36:56.179]                               next
[13:36:56.179]                             invokeRestart(restart)
[13:36:56.179]                             muffled <- TRUE
[13:36:56.179]                             break
[13:36:56.179]                           }
[13:36:56.179]                         }
[13:36:56.179]                       }
[13:36:56.179]                       invisible(muffled)
[13:36:56.179]                     }
[13:36:56.179]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.179]                   }
[13:36:56.179]                 }
[13:36:56.179]             }
[13:36:56.179]         }))
[13:36:56.179]     }, error = function(ex) {
[13:36:56.179]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.179]                 ...future.rng), started = ...future.startTime, 
[13:36:56.179]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.179]             version = "1.8"), class = "FutureResult")
[13:36:56.179]     }, finally = {
[13:36:56.179]         if (!identical(...future.workdir, getwd())) 
[13:36:56.179]             setwd(...future.workdir)
[13:36:56.179]         {
[13:36:56.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.179]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.179]             }
[13:36:56.179]             base::options(...future.oldOptions)
[13:36:56.179]             if (.Platform$OS.type == "windows") {
[13:36:56.179]                 old_names <- names(...future.oldEnvVars)
[13:36:56.179]                 envs <- base::Sys.getenv()
[13:36:56.179]                 names <- names(envs)
[13:36:56.179]                 common <- intersect(names, old_names)
[13:36:56.179]                 added <- setdiff(names, old_names)
[13:36:56.179]                 removed <- setdiff(old_names, names)
[13:36:56.179]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.179]                   envs[common]]
[13:36:56.179]                 NAMES <- toupper(changed)
[13:36:56.179]                 args <- list()
[13:36:56.179]                 for (kk in seq_along(NAMES)) {
[13:36:56.179]                   name <- changed[[kk]]
[13:36:56.179]                   NAME <- NAMES[[kk]]
[13:36:56.179]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.179]                     next
[13:36:56.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.179]                 }
[13:36:56.179]                 NAMES <- toupper(added)
[13:36:56.179]                 for (kk in seq_along(NAMES)) {
[13:36:56.179]                   name <- added[[kk]]
[13:36:56.179]                   NAME <- NAMES[[kk]]
[13:36:56.179]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.179]                     next
[13:36:56.179]                   args[[name]] <- ""
[13:36:56.179]                 }
[13:36:56.179]                 NAMES <- toupper(removed)
[13:36:56.179]                 for (kk in seq_along(NAMES)) {
[13:36:56.179]                   name <- removed[[kk]]
[13:36:56.179]                   NAME <- NAMES[[kk]]
[13:36:56.179]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.179]                     next
[13:36:56.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.179]                 }
[13:36:56.179]                 if (length(args) > 0) 
[13:36:56.179]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.179]             }
[13:36:56.179]             else {
[13:36:56.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.179]             }
[13:36:56.179]             {
[13:36:56.179]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.179]                   0L) {
[13:36:56.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.179]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.179]                   base::options(opts)
[13:36:56.179]                 }
[13:36:56.179]                 {
[13:36:56.179]                   {
[13:36:56.179]                     NULL
[13:36:56.179]                     RNGkind("Mersenne-Twister")
[13:36:56.179]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.179]                       inherits = FALSE)
[13:36:56.179]                   }
[13:36:56.179]                   options(future.plan = NULL)
[13:36:56.179]                   if (is.na(NA_character_)) 
[13:36:56.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.179]                     .init = FALSE)
[13:36:56.179]                 }
[13:36:56.179]             }
[13:36:56.179]         }
[13:36:56.179]     })
[13:36:56.179]     if (TRUE) {
[13:36:56.179]         base::sink(type = "output", split = FALSE)
[13:36:56.179]         if (TRUE) {
[13:36:56.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.179]         }
[13:36:56.179]         else {
[13:36:56.179]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.179]         }
[13:36:56.179]         base::close(...future.stdout)
[13:36:56.179]         ...future.stdout <- NULL
[13:36:56.179]     }
[13:36:56.179]     ...future.result$conditions <- ...future.conditions
[13:36:56.179]     ...future.result$finished <- base::Sys.time()
[13:36:56.179]     ...future.result
[13:36:56.179] }
[13:36:56.180] assign_globals() ...
[13:36:56.180] List of 1
[13:36:56.180]  $ pkg: chr "foo"
[13:36:56.180]  - attr(*, "where")=List of 1
[13:36:56.180]   ..$ pkg:<environment: R_EmptyEnv> 
[13:36:56.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.180]  - attr(*, "resolved")= logi TRUE
[13:36:56.180]  - attr(*, "total_size")= num 112
[13:36:56.182] - copied ‘pkg’ to environment
[13:36:56.182] assign_globals() ... done
[13:36:56.182] plan(): Setting new future strategy stack:
[13:36:56.182] List of future strategies:
[13:36:56.182] 1. sequential:
[13:36:56.182]    - args: function (..., envir = parent.frame())
[13:36:56.182]    - tweaked: FALSE
[13:36:56.182]    - call: NULL
[13:36:56.183] plan(): nbrOfWorkers() = 1
[13:36:56.183] plan(): Setting new future strategy stack:
[13:36:56.184] List of future strategies:
[13:36:56.184] 1. sequential:
[13:36:56.184]    - args: function (..., envir = parent.frame())
[13:36:56.184]    - tweaked: FALSE
[13:36:56.184]    - call: plan(strategy)
[13:36:56.184] plan(): nbrOfWorkers() = 1
[13:36:56.184] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.185] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.186] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.187] - globals found: [3] ‘{’, ‘<-’, ‘+’
[13:36:56.187] Searching for globals ... DONE
[13:36:56.187] Resolving globals: TRUE
[13:36:56.188] Resolving any globals that are futures ...
[13:36:56.188] - globals: [3] ‘{’, ‘<-’, ‘+’
[13:36:56.188] Resolving any globals that are futures ... DONE
[13:36:56.188] 
[13:36:56.188] 
[13:36:56.188] getGlobalsAndPackages() ... DONE
[13:36:56.188] run() for ‘Future’ ...
[13:36:56.188] - state: ‘created’
[13:36:56.189] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.189] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.189] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.189]   - Field: ‘label’
[13:36:56.189]   - Field: ‘local’
[13:36:56.189]   - Field: ‘owner’
[13:36:56.189]   - Field: ‘envir’
[13:36:56.189]   - Field: ‘packages’
[13:36:56.190]   - Field: ‘gc’
[13:36:56.190]   - Field: ‘conditions’
[13:36:56.190]   - Field: ‘expr’
[13:36:56.190]   - Field: ‘uuid’
[13:36:56.190]   - Field: ‘seed’
[13:36:56.190]   - Field: ‘version’
[13:36:56.190]   - Field: ‘result’
[13:36:56.190]   - Field: ‘asynchronous’
[13:36:56.190]   - Field: ‘calls’
[13:36:56.190]   - Field: ‘globals’
[13:36:56.190]   - Field: ‘stdout’
[13:36:56.190]   - Field: ‘earlySignal’
[13:36:56.191]   - Field: ‘lazy’
[13:36:56.191]   - Field: ‘state’
[13:36:56.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.191] - Launch lazy future ...
[13:36:56.191] Packages needed by the future expression (n = 0): <none>
[13:36:56.191] Packages needed by future strategies (n = 0): <none>
[13:36:56.191] {
[13:36:56.191]     {
[13:36:56.191]         {
[13:36:56.191]             ...future.startTime <- base::Sys.time()
[13:36:56.191]             {
[13:36:56.191]                 {
[13:36:56.191]                   {
[13:36:56.191]                     base::local({
[13:36:56.191]                       has_future <- base::requireNamespace("future", 
[13:36:56.191]                         quietly = TRUE)
[13:36:56.191]                       if (has_future) {
[13:36:56.191]                         ns <- base::getNamespace("future")
[13:36:56.191]                         version <- ns[[".package"]][["version"]]
[13:36:56.191]                         if (is.null(version)) 
[13:36:56.191]                           version <- utils::packageVersion("future")
[13:36:56.191]                       }
[13:36:56.191]                       else {
[13:36:56.191]                         version <- NULL
[13:36:56.191]                       }
[13:36:56.191]                       if (!has_future || version < "1.8.0") {
[13:36:56.191]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.191]                           "", base::R.version$version.string), 
[13:36:56.191]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.191]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.191]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.191]                             "release", "version")], collapse = " "), 
[13:36:56.191]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.191]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.191]                           info)
[13:36:56.191]                         info <- base::paste(info, collapse = "; ")
[13:36:56.191]                         if (!has_future) {
[13:36:56.191]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.191]                             info)
[13:36:56.191]                         }
[13:36:56.191]                         else {
[13:36:56.191]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.191]                             info, version)
[13:36:56.191]                         }
[13:36:56.191]                         base::stop(msg)
[13:36:56.191]                       }
[13:36:56.191]                     })
[13:36:56.191]                   }
[13:36:56.191]                   ...future.strategy.old <- future::plan("list")
[13:36:56.191]                   options(future.plan = NULL)
[13:36:56.191]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.191]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.191]                 }
[13:36:56.191]                 ...future.workdir <- getwd()
[13:36:56.191]             }
[13:36:56.191]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.191]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.191]         }
[13:36:56.191]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.191]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.191]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.191]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.191]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.191]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.191]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.191]             base::names(...future.oldOptions))
[13:36:56.191]     }
[13:36:56.191]     if (FALSE) {
[13:36:56.191]     }
[13:36:56.191]     else {
[13:36:56.191]         if (TRUE) {
[13:36:56.191]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.191]                 open = "w")
[13:36:56.191]         }
[13:36:56.191]         else {
[13:36:56.191]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.191]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.191]         }
[13:36:56.191]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.191]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.191]             base::sink(type = "output", split = FALSE)
[13:36:56.191]             base::close(...future.stdout)
[13:36:56.191]         }, add = TRUE)
[13:36:56.191]     }
[13:36:56.191]     ...future.frame <- base::sys.nframe()
[13:36:56.191]     ...future.conditions <- base::list()
[13:36:56.191]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.191]     if (FALSE) {
[13:36:56.191]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.191]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.191]     }
[13:36:56.191]     ...future.result <- base::tryCatch({
[13:36:56.191]         base::withCallingHandlers({
[13:36:56.191]             ...future.value <- base::withVisible(base::local({
[13:36:56.191]                 x <- 0
[13:36:56.191]                 x <- x + 1
[13:36:56.191]                 x
[13:36:56.191]             }))
[13:36:56.191]             future::FutureResult(value = ...future.value$value, 
[13:36:56.191]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.191]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.191]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.191]                     ...future.globalenv.names))
[13:36:56.191]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.191]         }, condition = base::local({
[13:36:56.191]             c <- base::c
[13:36:56.191]             inherits <- base::inherits
[13:36:56.191]             invokeRestart <- base::invokeRestart
[13:36:56.191]             length <- base::length
[13:36:56.191]             list <- base::list
[13:36:56.191]             seq.int <- base::seq.int
[13:36:56.191]             signalCondition <- base::signalCondition
[13:36:56.191]             sys.calls <- base::sys.calls
[13:36:56.191]             `[[` <- base::`[[`
[13:36:56.191]             `+` <- base::`+`
[13:36:56.191]             `<<-` <- base::`<<-`
[13:36:56.191]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.191]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.191]                   3L)]
[13:36:56.191]             }
[13:36:56.191]             function(cond) {
[13:36:56.191]                 is_error <- inherits(cond, "error")
[13:36:56.191]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.191]                   NULL)
[13:36:56.191]                 if (is_error) {
[13:36:56.191]                   sessionInformation <- function() {
[13:36:56.191]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.191]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.191]                       search = base::search(), system = base::Sys.info())
[13:36:56.191]                   }
[13:36:56.191]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.191]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.191]                     cond$call), session = sessionInformation(), 
[13:36:56.191]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.191]                   signalCondition(cond)
[13:36:56.191]                 }
[13:36:56.191]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.191]                 "immediateCondition"))) {
[13:36:56.191]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.191]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.191]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.191]                   if (TRUE && !signal) {
[13:36:56.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.191]                     {
[13:36:56.191]                       inherits <- base::inherits
[13:36:56.191]                       invokeRestart <- base::invokeRestart
[13:36:56.191]                       is.null <- base::is.null
[13:36:56.191]                       muffled <- FALSE
[13:36:56.191]                       if (inherits(cond, "message")) {
[13:36:56.191]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.191]                         if (muffled) 
[13:36:56.191]                           invokeRestart("muffleMessage")
[13:36:56.191]                       }
[13:36:56.191]                       else if (inherits(cond, "warning")) {
[13:36:56.191]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.191]                         if (muffled) 
[13:36:56.191]                           invokeRestart("muffleWarning")
[13:36:56.191]                       }
[13:36:56.191]                       else if (inherits(cond, "condition")) {
[13:36:56.191]                         if (!is.null(pattern)) {
[13:36:56.191]                           computeRestarts <- base::computeRestarts
[13:36:56.191]                           grepl <- base::grepl
[13:36:56.191]                           restarts <- computeRestarts(cond)
[13:36:56.191]                           for (restart in restarts) {
[13:36:56.191]                             name <- restart$name
[13:36:56.191]                             if (is.null(name)) 
[13:36:56.191]                               next
[13:36:56.191]                             if (!grepl(pattern, name)) 
[13:36:56.191]                               next
[13:36:56.191]                             invokeRestart(restart)
[13:36:56.191]                             muffled <- TRUE
[13:36:56.191]                             break
[13:36:56.191]                           }
[13:36:56.191]                         }
[13:36:56.191]                       }
[13:36:56.191]                       invisible(muffled)
[13:36:56.191]                     }
[13:36:56.191]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.191]                   }
[13:36:56.191]                 }
[13:36:56.191]                 else {
[13:36:56.191]                   if (TRUE) {
[13:36:56.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.191]                     {
[13:36:56.191]                       inherits <- base::inherits
[13:36:56.191]                       invokeRestart <- base::invokeRestart
[13:36:56.191]                       is.null <- base::is.null
[13:36:56.191]                       muffled <- FALSE
[13:36:56.191]                       if (inherits(cond, "message")) {
[13:36:56.191]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.191]                         if (muffled) 
[13:36:56.191]                           invokeRestart("muffleMessage")
[13:36:56.191]                       }
[13:36:56.191]                       else if (inherits(cond, "warning")) {
[13:36:56.191]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.191]                         if (muffled) 
[13:36:56.191]                           invokeRestart("muffleWarning")
[13:36:56.191]                       }
[13:36:56.191]                       else if (inherits(cond, "condition")) {
[13:36:56.191]                         if (!is.null(pattern)) {
[13:36:56.191]                           computeRestarts <- base::computeRestarts
[13:36:56.191]                           grepl <- base::grepl
[13:36:56.191]                           restarts <- computeRestarts(cond)
[13:36:56.191]                           for (restart in restarts) {
[13:36:56.191]                             name <- restart$name
[13:36:56.191]                             if (is.null(name)) 
[13:36:56.191]                               next
[13:36:56.191]                             if (!grepl(pattern, name)) 
[13:36:56.191]                               next
[13:36:56.191]                             invokeRestart(restart)
[13:36:56.191]                             muffled <- TRUE
[13:36:56.191]                             break
[13:36:56.191]                           }
[13:36:56.191]                         }
[13:36:56.191]                       }
[13:36:56.191]                       invisible(muffled)
[13:36:56.191]                     }
[13:36:56.191]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.191]                   }
[13:36:56.191]                 }
[13:36:56.191]             }
[13:36:56.191]         }))
[13:36:56.191]     }, error = function(ex) {
[13:36:56.191]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.191]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.191]                 ...future.rng), started = ...future.startTime, 
[13:36:56.191]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.191]             version = "1.8"), class = "FutureResult")
[13:36:56.191]     }, finally = {
[13:36:56.191]         if (!identical(...future.workdir, getwd())) 
[13:36:56.191]             setwd(...future.workdir)
[13:36:56.191]         {
[13:36:56.191]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.191]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.191]             }
[13:36:56.191]             base::options(...future.oldOptions)
[13:36:56.191]             if (.Platform$OS.type == "windows") {
[13:36:56.191]                 old_names <- names(...future.oldEnvVars)
[13:36:56.191]                 envs <- base::Sys.getenv()
[13:36:56.191]                 names <- names(envs)
[13:36:56.191]                 common <- intersect(names, old_names)
[13:36:56.191]                 added <- setdiff(names, old_names)
[13:36:56.191]                 removed <- setdiff(old_names, names)
[13:36:56.191]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.191]                   envs[common]]
[13:36:56.191]                 NAMES <- toupper(changed)
[13:36:56.191]                 args <- list()
[13:36:56.191]                 for (kk in seq_along(NAMES)) {
[13:36:56.191]                   name <- changed[[kk]]
[13:36:56.191]                   NAME <- NAMES[[kk]]
[13:36:56.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.191]                     next
[13:36:56.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.191]                 }
[13:36:56.191]                 NAMES <- toupper(added)
[13:36:56.191]                 for (kk in seq_along(NAMES)) {
[13:36:56.191]                   name <- added[[kk]]
[13:36:56.191]                   NAME <- NAMES[[kk]]
[13:36:56.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.191]                     next
[13:36:56.191]                   args[[name]] <- ""
[13:36:56.191]                 }
[13:36:56.191]                 NAMES <- toupper(removed)
[13:36:56.191]                 for (kk in seq_along(NAMES)) {
[13:36:56.191]                   name <- removed[[kk]]
[13:36:56.191]                   NAME <- NAMES[[kk]]
[13:36:56.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.191]                     next
[13:36:56.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.191]                 }
[13:36:56.191]                 if (length(args) > 0) 
[13:36:56.191]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.191]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.191]             }
[13:36:56.191]             else {
[13:36:56.191]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.191]             }
[13:36:56.191]             {
[13:36:56.191]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.191]                   0L) {
[13:36:56.191]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.191]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.191]                   base::options(opts)
[13:36:56.191]                 }
[13:36:56.191]                 {
[13:36:56.191]                   {
[13:36:56.191]                     NULL
[13:36:56.191]                     RNGkind("Mersenne-Twister")
[13:36:56.191]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.191]                       inherits = FALSE)
[13:36:56.191]                   }
[13:36:56.191]                   options(future.plan = NULL)
[13:36:56.191]                   if (is.na(NA_character_)) 
[13:36:56.191]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.191]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.191]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.191]                     .init = FALSE)
[13:36:56.191]                 }
[13:36:56.191]             }
[13:36:56.191]         }
[13:36:56.191]     })
[13:36:56.191]     if (TRUE) {
[13:36:56.191]         base::sink(type = "output", split = FALSE)
[13:36:56.191]         if (TRUE) {
[13:36:56.191]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.191]         }
[13:36:56.191]         else {
[13:36:56.191]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.191]         }
[13:36:56.191]         base::close(...future.stdout)
[13:36:56.191]         ...future.stdout <- NULL
[13:36:56.191]     }
[13:36:56.191]     ...future.result$conditions <- ...future.conditions
[13:36:56.191]     ...future.result$finished <- base::Sys.time()
[13:36:56.191]     ...future.result
[13:36:56.191] }
[13:36:56.193] plan(): Setting new future strategy stack:
[13:36:56.193] List of future strategies:
[13:36:56.193] 1. sequential:
[13:36:56.193]    - args: function (..., envir = parent.frame())
[13:36:56.193]    - tweaked: FALSE
[13:36:56.193]    - call: NULL
[13:36:56.194] plan(): nbrOfWorkers() = 1
[13:36:56.194] plan(): Setting new future strategy stack:
[13:36:56.194] List of future strategies:
[13:36:56.194] 1. sequential:
[13:36:56.194]    - args: function (..., envir = parent.frame())
[13:36:56.194]    - tweaked: FALSE
[13:36:56.194]    - call: plan(strategy)
[13:36:56.195] plan(): nbrOfWorkers() = 1
[13:36:56.195] SequentialFuture started (and completed)
[13:36:56.195] - Launch lazy future ... done
[13:36:56.195] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.195] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.196] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.197] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:36:56.197] Searching for globals ... DONE
[13:36:56.197] Resolving globals: TRUE
[13:36:56.197] Resolving any globals that are futures ...
[13:36:56.197] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:36:56.197] Resolving any globals that are futures ... DONE
[13:36:56.198] Resolving futures part of globals (recursively) ...
[13:36:56.198] resolve() on list ...
[13:36:56.198]  recursive: 99
[13:36:56.198]  length: 1
[13:36:56.198]  elements: ‘x’
[13:36:56.198]  length: 0 (resolved future 1)
[13:36:56.198] resolve() on list ... DONE
[13:36:56.198] - globals: [1] ‘x’
[13:36:56.198] Resolving futures part of globals (recursively) ... DONE
[13:36:56.199] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:56.199] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[13:36:56.199] - globals: [1] ‘x’
[13:36:56.199] 
[13:36:56.199] getGlobalsAndPackages() ... DONE
[13:36:56.199] run() for ‘Future’ ...
[13:36:56.199] - state: ‘created’
[13:36:56.200] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.200] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.200] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.200]   - Field: ‘label’
[13:36:56.200]   - Field: ‘local’
[13:36:56.200]   - Field: ‘owner’
[13:36:56.200]   - Field: ‘envir’
[13:36:56.200]   - Field: ‘packages’
[13:36:56.200]   - Field: ‘gc’
[13:36:56.201]   - Field: ‘conditions’
[13:36:56.201]   - Field: ‘expr’
[13:36:56.201]   - Field: ‘uuid’
[13:36:56.201]   - Field: ‘seed’
[13:36:56.201]   - Field: ‘version’
[13:36:56.201]   - Field: ‘result’
[13:36:56.201]   - Field: ‘asynchronous’
[13:36:56.201]   - Field: ‘calls’
[13:36:56.201]   - Field: ‘globals’
[13:36:56.201]   - Field: ‘stdout’
[13:36:56.201]   - Field: ‘earlySignal’
[13:36:56.202]   - Field: ‘lazy’
[13:36:56.202]   - Field: ‘state’
[13:36:56.202] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.202] - Launch lazy future ...
[13:36:56.202] Packages needed by the future expression (n = 0): <none>
[13:36:56.202] Packages needed by future strategies (n = 0): <none>
[13:36:56.202] {
[13:36:56.202]     {
[13:36:56.202]         {
[13:36:56.202]             ...future.startTime <- base::Sys.time()
[13:36:56.202]             {
[13:36:56.202]                 {
[13:36:56.202]                   {
[13:36:56.202]                     base::local({
[13:36:56.202]                       has_future <- base::requireNamespace("future", 
[13:36:56.202]                         quietly = TRUE)
[13:36:56.202]                       if (has_future) {
[13:36:56.202]                         ns <- base::getNamespace("future")
[13:36:56.202]                         version <- ns[[".package"]][["version"]]
[13:36:56.202]                         if (is.null(version)) 
[13:36:56.202]                           version <- utils::packageVersion("future")
[13:36:56.202]                       }
[13:36:56.202]                       else {
[13:36:56.202]                         version <- NULL
[13:36:56.202]                       }
[13:36:56.202]                       if (!has_future || version < "1.8.0") {
[13:36:56.202]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.202]                           "", base::R.version$version.string), 
[13:36:56.202]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.202]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.202]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.202]                             "release", "version")], collapse = " "), 
[13:36:56.202]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.202]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.202]                           info)
[13:36:56.202]                         info <- base::paste(info, collapse = "; ")
[13:36:56.202]                         if (!has_future) {
[13:36:56.202]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.202]                             info)
[13:36:56.202]                         }
[13:36:56.202]                         else {
[13:36:56.202]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.202]                             info, version)
[13:36:56.202]                         }
[13:36:56.202]                         base::stop(msg)
[13:36:56.202]                       }
[13:36:56.202]                     })
[13:36:56.202]                   }
[13:36:56.202]                   ...future.strategy.old <- future::plan("list")
[13:36:56.202]                   options(future.plan = NULL)
[13:36:56.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.202]                 }
[13:36:56.202]                 ...future.workdir <- getwd()
[13:36:56.202]             }
[13:36:56.202]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.202]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.202]         }
[13:36:56.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.202]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.202]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.202]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.202]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.202]             base::names(...future.oldOptions))
[13:36:56.202]     }
[13:36:56.202]     if (FALSE) {
[13:36:56.202]     }
[13:36:56.202]     else {
[13:36:56.202]         if (TRUE) {
[13:36:56.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.202]                 open = "w")
[13:36:56.202]         }
[13:36:56.202]         else {
[13:36:56.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.202]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.202]         }
[13:36:56.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.202]             base::sink(type = "output", split = FALSE)
[13:36:56.202]             base::close(...future.stdout)
[13:36:56.202]         }, add = TRUE)
[13:36:56.202]     }
[13:36:56.202]     ...future.frame <- base::sys.nframe()
[13:36:56.202]     ...future.conditions <- base::list()
[13:36:56.202]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.202]     if (FALSE) {
[13:36:56.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.202]     }
[13:36:56.202]     ...future.result <- base::tryCatch({
[13:36:56.202]         base::withCallingHandlers({
[13:36:56.202]             ...future.value <- base::withVisible(base::local({
[13:36:56.202]                 x <- x + 1
[13:36:56.202]                 x
[13:36:56.202]             }))
[13:36:56.202]             future::FutureResult(value = ...future.value$value, 
[13:36:56.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.202]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.202]                     ...future.globalenv.names))
[13:36:56.202]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.202]         }, condition = base::local({
[13:36:56.202]             c <- base::c
[13:36:56.202]             inherits <- base::inherits
[13:36:56.202]             invokeRestart <- base::invokeRestart
[13:36:56.202]             length <- base::length
[13:36:56.202]             list <- base::list
[13:36:56.202]             seq.int <- base::seq.int
[13:36:56.202]             signalCondition <- base::signalCondition
[13:36:56.202]             sys.calls <- base::sys.calls
[13:36:56.202]             `[[` <- base::`[[`
[13:36:56.202]             `+` <- base::`+`
[13:36:56.202]             `<<-` <- base::`<<-`
[13:36:56.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.202]                   3L)]
[13:36:56.202]             }
[13:36:56.202]             function(cond) {
[13:36:56.202]                 is_error <- inherits(cond, "error")
[13:36:56.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.202]                   NULL)
[13:36:56.202]                 if (is_error) {
[13:36:56.202]                   sessionInformation <- function() {
[13:36:56.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.202]                       search = base::search(), system = base::Sys.info())
[13:36:56.202]                   }
[13:36:56.202]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.202]                     cond$call), session = sessionInformation(), 
[13:36:56.202]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.202]                   signalCondition(cond)
[13:36:56.202]                 }
[13:36:56.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.202]                 "immediateCondition"))) {
[13:36:56.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.202]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.202]                   if (TRUE && !signal) {
[13:36:56.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.202]                     {
[13:36:56.202]                       inherits <- base::inherits
[13:36:56.202]                       invokeRestart <- base::invokeRestart
[13:36:56.202]                       is.null <- base::is.null
[13:36:56.202]                       muffled <- FALSE
[13:36:56.202]                       if (inherits(cond, "message")) {
[13:36:56.202]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.202]                         if (muffled) 
[13:36:56.202]                           invokeRestart("muffleMessage")
[13:36:56.202]                       }
[13:36:56.202]                       else if (inherits(cond, "warning")) {
[13:36:56.202]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.202]                         if (muffled) 
[13:36:56.202]                           invokeRestart("muffleWarning")
[13:36:56.202]                       }
[13:36:56.202]                       else if (inherits(cond, "condition")) {
[13:36:56.202]                         if (!is.null(pattern)) {
[13:36:56.202]                           computeRestarts <- base::computeRestarts
[13:36:56.202]                           grepl <- base::grepl
[13:36:56.202]                           restarts <- computeRestarts(cond)
[13:36:56.202]                           for (restart in restarts) {
[13:36:56.202]                             name <- restart$name
[13:36:56.202]                             if (is.null(name)) 
[13:36:56.202]                               next
[13:36:56.202]                             if (!grepl(pattern, name)) 
[13:36:56.202]                               next
[13:36:56.202]                             invokeRestart(restart)
[13:36:56.202]                             muffled <- TRUE
[13:36:56.202]                             break
[13:36:56.202]                           }
[13:36:56.202]                         }
[13:36:56.202]                       }
[13:36:56.202]                       invisible(muffled)
[13:36:56.202]                     }
[13:36:56.202]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.202]                   }
[13:36:56.202]                 }
[13:36:56.202]                 else {
[13:36:56.202]                   if (TRUE) {
[13:36:56.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.202]                     {
[13:36:56.202]                       inherits <- base::inherits
[13:36:56.202]                       invokeRestart <- base::invokeRestart
[13:36:56.202]                       is.null <- base::is.null
[13:36:56.202]                       muffled <- FALSE
[13:36:56.202]                       if (inherits(cond, "message")) {
[13:36:56.202]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.202]                         if (muffled) 
[13:36:56.202]                           invokeRestart("muffleMessage")
[13:36:56.202]                       }
[13:36:56.202]                       else if (inherits(cond, "warning")) {
[13:36:56.202]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.202]                         if (muffled) 
[13:36:56.202]                           invokeRestart("muffleWarning")
[13:36:56.202]                       }
[13:36:56.202]                       else if (inherits(cond, "condition")) {
[13:36:56.202]                         if (!is.null(pattern)) {
[13:36:56.202]                           computeRestarts <- base::computeRestarts
[13:36:56.202]                           grepl <- base::grepl
[13:36:56.202]                           restarts <- computeRestarts(cond)
[13:36:56.202]                           for (restart in restarts) {
[13:36:56.202]                             name <- restart$name
[13:36:56.202]                             if (is.null(name)) 
[13:36:56.202]                               next
[13:36:56.202]                             if (!grepl(pattern, name)) 
[13:36:56.202]                               next
[13:36:56.202]                             invokeRestart(restart)
[13:36:56.202]                             muffled <- TRUE
[13:36:56.202]                             break
[13:36:56.202]                           }
[13:36:56.202]                         }
[13:36:56.202]                       }
[13:36:56.202]                       invisible(muffled)
[13:36:56.202]                     }
[13:36:56.202]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.202]                   }
[13:36:56.202]                 }
[13:36:56.202]             }
[13:36:56.202]         }))
[13:36:56.202]     }, error = function(ex) {
[13:36:56.202]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.202]                 ...future.rng), started = ...future.startTime, 
[13:36:56.202]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.202]             version = "1.8"), class = "FutureResult")
[13:36:56.202]     }, finally = {
[13:36:56.202]         if (!identical(...future.workdir, getwd())) 
[13:36:56.202]             setwd(...future.workdir)
[13:36:56.202]         {
[13:36:56.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.202]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.202]             }
[13:36:56.202]             base::options(...future.oldOptions)
[13:36:56.202]             if (.Platform$OS.type == "windows") {
[13:36:56.202]                 old_names <- names(...future.oldEnvVars)
[13:36:56.202]                 envs <- base::Sys.getenv()
[13:36:56.202]                 names <- names(envs)
[13:36:56.202]                 common <- intersect(names, old_names)
[13:36:56.202]                 added <- setdiff(names, old_names)
[13:36:56.202]                 removed <- setdiff(old_names, names)
[13:36:56.202]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.202]                   envs[common]]
[13:36:56.202]                 NAMES <- toupper(changed)
[13:36:56.202]                 args <- list()
[13:36:56.202]                 for (kk in seq_along(NAMES)) {
[13:36:56.202]                   name <- changed[[kk]]
[13:36:56.202]                   NAME <- NAMES[[kk]]
[13:36:56.202]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.202]                     next
[13:36:56.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.202]                 }
[13:36:56.202]                 NAMES <- toupper(added)
[13:36:56.202]                 for (kk in seq_along(NAMES)) {
[13:36:56.202]                   name <- added[[kk]]
[13:36:56.202]                   NAME <- NAMES[[kk]]
[13:36:56.202]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.202]                     next
[13:36:56.202]                   args[[name]] <- ""
[13:36:56.202]                 }
[13:36:56.202]                 NAMES <- toupper(removed)
[13:36:56.202]                 for (kk in seq_along(NAMES)) {
[13:36:56.202]                   name <- removed[[kk]]
[13:36:56.202]                   NAME <- NAMES[[kk]]
[13:36:56.202]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.202]                     next
[13:36:56.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.202]                 }
[13:36:56.202]                 if (length(args) > 0) 
[13:36:56.202]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.202]             }
[13:36:56.202]             else {
[13:36:56.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.202]             }
[13:36:56.202]             {
[13:36:56.202]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.202]                   0L) {
[13:36:56.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.202]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.202]                   base::options(opts)
[13:36:56.202]                 }
[13:36:56.202]                 {
[13:36:56.202]                   {
[13:36:56.202]                     NULL
[13:36:56.202]                     RNGkind("Mersenne-Twister")
[13:36:56.202]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.202]                       inherits = FALSE)
[13:36:56.202]                   }
[13:36:56.202]                   options(future.plan = NULL)
[13:36:56.202]                   if (is.na(NA_character_)) 
[13:36:56.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.202]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.202]                     .init = FALSE)
[13:36:56.202]                 }
[13:36:56.202]             }
[13:36:56.202]         }
[13:36:56.202]     })
[13:36:56.202]     if (TRUE) {
[13:36:56.202]         base::sink(type = "output", split = FALSE)
[13:36:56.202]         if (TRUE) {
[13:36:56.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.202]         }
[13:36:56.202]         else {
[13:36:56.202]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.202]         }
[13:36:56.202]         base::close(...future.stdout)
[13:36:56.202]         ...future.stdout <- NULL
[13:36:56.202]     }
[13:36:56.202]     ...future.result$conditions <- ...future.conditions
[13:36:56.202]     ...future.result$finished <- base::Sys.time()
[13:36:56.202]     ...future.result
[13:36:56.202] }
[13:36:56.204] assign_globals() ...
[13:36:56.204] List of 1
[13:36:56.204]  $ x: num 1
[13:36:56.204]  - attr(*, "where")=List of 1
[13:36:56.204]   ..$ x:<environment: R_EmptyEnv> 
[13:36:56.204]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.204]  - attr(*, "resolved")= logi TRUE
[13:36:56.204]  - attr(*, "total_size")= num 56
[13:36:56.204]  - attr(*, "already-done")= logi TRUE
[13:36:56.206] - copied ‘x’ to environment
[13:36:56.206] assign_globals() ... done
[13:36:56.207] plan(): Setting new future strategy stack:
[13:36:56.207] List of future strategies:
[13:36:56.207] 1. sequential:
[13:36:56.207]    - args: function (..., envir = parent.frame())
[13:36:56.207]    - tweaked: FALSE
[13:36:56.207]    - call: NULL
[13:36:56.207] plan(): nbrOfWorkers() = 1
[13:36:56.208] plan(): Setting new future strategy stack:
[13:36:56.208] List of future strategies:
[13:36:56.208] 1. sequential:
[13:36:56.208]    - args: function (..., envir = parent.frame())
[13:36:56.208]    - tweaked: FALSE
[13:36:56.208]    - call: plan(strategy)
[13:36:56.208] plan(): nbrOfWorkers() = 1
[13:36:56.208] SequentialFuture started (and completed)
[13:36:56.208] - Launch lazy future ... done
[13:36:56.209] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.209] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.209] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.212] - globals found: [3] ‘{’, ‘<-’, ‘x’
[13:36:56.212] Searching for globals ... DONE
[13:36:56.212] Resolving globals: TRUE
[13:36:56.212] Resolving any globals that are futures ...
[13:36:56.212] - globals: [3] ‘{’, ‘<-’, ‘x’
[13:36:56.212] Resolving any globals that are futures ... DONE
[13:36:56.212] Resolving futures part of globals (recursively) ...
[13:36:56.213] resolve() on list ...
[13:36:56.213]  recursive: 99
[13:36:56.213]  length: 1
[13:36:56.213]  elements: ‘x’
[13:36:56.213]  length: 0 (resolved future 1)
[13:36:56.213] resolve() on list ... DONE
[13:36:56.213] - globals: [1] ‘x’
[13:36:56.213] Resolving futures part of globals (recursively) ... DONE
[13:36:56.213] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[13:36:56.214] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[13:36:56.214] - globals: [1] ‘x’
[13:36:56.214] 
[13:36:56.214] getGlobalsAndPackages() ... DONE
[13:36:56.214] run() for ‘Future’ ...
[13:36:56.214] - state: ‘created’
[13:36:56.215] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:56.215] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:56.215] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:56.215]   - Field: ‘label’
[13:36:56.215]   - Field: ‘local’
[13:36:56.215]   - Field: ‘owner’
[13:36:56.215]   - Field: ‘envir’
[13:36:56.215]   - Field: ‘packages’
[13:36:56.215]   - Field: ‘gc’
[13:36:56.216]   - Field: ‘conditions’
[13:36:56.216]   - Field: ‘expr’
[13:36:56.216]   - Field: ‘uuid’
[13:36:56.216]   - Field: ‘seed’
[13:36:56.216]   - Field: ‘version’
[13:36:56.216]   - Field: ‘result’
[13:36:56.216]   - Field: ‘asynchronous’
[13:36:56.216]   - Field: ‘calls’
[13:36:56.216]   - Field: ‘globals’
[13:36:56.216]   - Field: ‘stdout’
[13:36:56.216]   - Field: ‘earlySignal’
[13:36:56.217]   - Field: ‘lazy’
[13:36:56.217]   - Field: ‘state’
[13:36:56.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:56.217] - Launch lazy future ...
[13:36:56.217] Packages needed by the future expression (n = 0): <none>
[13:36:56.217] Packages needed by future strategies (n = 0): <none>
[13:36:56.217] {
[13:36:56.217]     {
[13:36:56.217]         {
[13:36:56.217]             ...future.startTime <- base::Sys.time()
[13:36:56.217]             {
[13:36:56.217]                 {
[13:36:56.217]                   {
[13:36:56.217]                     base::local({
[13:36:56.217]                       has_future <- base::requireNamespace("future", 
[13:36:56.217]                         quietly = TRUE)
[13:36:56.217]                       if (has_future) {
[13:36:56.217]                         ns <- base::getNamespace("future")
[13:36:56.217]                         version <- ns[[".package"]][["version"]]
[13:36:56.217]                         if (is.null(version)) 
[13:36:56.217]                           version <- utils::packageVersion("future")
[13:36:56.217]                       }
[13:36:56.217]                       else {
[13:36:56.217]                         version <- NULL
[13:36:56.217]                       }
[13:36:56.217]                       if (!has_future || version < "1.8.0") {
[13:36:56.217]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.217]                           "", base::R.version$version.string), 
[13:36:56.217]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.217]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.217]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.217]                             "release", "version")], collapse = " "), 
[13:36:56.217]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.217]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.217]                           info)
[13:36:56.217]                         info <- base::paste(info, collapse = "; ")
[13:36:56.217]                         if (!has_future) {
[13:36:56.217]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.217]                             info)
[13:36:56.217]                         }
[13:36:56.217]                         else {
[13:36:56.217]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.217]                             info, version)
[13:36:56.217]                         }
[13:36:56.217]                         base::stop(msg)
[13:36:56.217]                       }
[13:36:56.217]                     })
[13:36:56.217]                   }
[13:36:56.217]                   ...future.strategy.old <- future::plan("list")
[13:36:56.217]                   options(future.plan = NULL)
[13:36:56.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.217]                 }
[13:36:56.217]                 ...future.workdir <- getwd()
[13:36:56.217]             }
[13:36:56.217]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.217]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.217]         }
[13:36:56.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.217]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.217]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.217]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.217]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.217]             base::names(...future.oldOptions))
[13:36:56.217]     }
[13:36:56.217]     if (FALSE) {
[13:36:56.217]     }
[13:36:56.217]     else {
[13:36:56.217]         if (TRUE) {
[13:36:56.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.217]                 open = "w")
[13:36:56.217]         }
[13:36:56.217]         else {
[13:36:56.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.217]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.217]         }
[13:36:56.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.217]             base::sink(type = "output", split = FALSE)
[13:36:56.217]             base::close(...future.stdout)
[13:36:56.217]         }, add = TRUE)
[13:36:56.217]     }
[13:36:56.217]     ...future.frame <- base::sys.nframe()
[13:36:56.217]     ...future.conditions <- base::list()
[13:36:56.217]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.217]     if (FALSE) {
[13:36:56.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.217]     }
[13:36:56.217]     ...future.result <- base::tryCatch({
[13:36:56.217]         base::withCallingHandlers({
[13:36:56.217]             ...future.value <- base::withVisible(base::local({
[13:36:56.217]                 x <- x()
[13:36:56.217]                 x
[13:36:56.217]             }))
[13:36:56.217]             future::FutureResult(value = ...future.value$value, 
[13:36:56.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.217]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.217]                     ...future.globalenv.names))
[13:36:56.217]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.217]         }, condition = base::local({
[13:36:56.217]             c <- base::c
[13:36:56.217]             inherits <- base::inherits
[13:36:56.217]             invokeRestart <- base::invokeRestart
[13:36:56.217]             length <- base::length
[13:36:56.217]             list <- base::list
[13:36:56.217]             seq.int <- base::seq.int
[13:36:56.217]             signalCondition <- base::signalCondition
[13:36:56.217]             sys.calls <- base::sys.calls
[13:36:56.217]             `[[` <- base::`[[`
[13:36:56.217]             `+` <- base::`+`
[13:36:56.217]             `<<-` <- base::`<<-`
[13:36:56.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.217]                   3L)]
[13:36:56.217]             }
[13:36:56.217]             function(cond) {
[13:36:56.217]                 is_error <- inherits(cond, "error")
[13:36:56.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.217]                   NULL)
[13:36:56.217]                 if (is_error) {
[13:36:56.217]                   sessionInformation <- function() {
[13:36:56.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.217]                       search = base::search(), system = base::Sys.info())
[13:36:56.217]                   }
[13:36:56.217]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.217]                     cond$call), session = sessionInformation(), 
[13:36:56.217]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.217]                   signalCondition(cond)
[13:36:56.217]                 }
[13:36:56.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.217]                 "immediateCondition"))) {
[13:36:56.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.217]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.217]                   if (TRUE && !signal) {
[13:36:56.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.217]                     {
[13:36:56.217]                       inherits <- base::inherits
[13:36:56.217]                       invokeRestart <- base::invokeRestart
[13:36:56.217]                       is.null <- base::is.null
[13:36:56.217]                       muffled <- FALSE
[13:36:56.217]                       if (inherits(cond, "message")) {
[13:36:56.217]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.217]                         if (muffled) 
[13:36:56.217]                           invokeRestart("muffleMessage")
[13:36:56.217]                       }
[13:36:56.217]                       else if (inherits(cond, "warning")) {
[13:36:56.217]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.217]                         if (muffled) 
[13:36:56.217]                           invokeRestart("muffleWarning")
[13:36:56.217]                       }
[13:36:56.217]                       else if (inherits(cond, "condition")) {
[13:36:56.217]                         if (!is.null(pattern)) {
[13:36:56.217]                           computeRestarts <- base::computeRestarts
[13:36:56.217]                           grepl <- base::grepl
[13:36:56.217]                           restarts <- computeRestarts(cond)
[13:36:56.217]                           for (restart in restarts) {
[13:36:56.217]                             name <- restart$name
[13:36:56.217]                             if (is.null(name)) 
[13:36:56.217]                               next
[13:36:56.217]                             if (!grepl(pattern, name)) 
[13:36:56.217]                               next
[13:36:56.217]                             invokeRestart(restart)
[13:36:56.217]                             muffled <- TRUE
[13:36:56.217]                             break
[13:36:56.217]                           }
[13:36:56.217]                         }
[13:36:56.217]                       }
[13:36:56.217]                       invisible(muffled)
[13:36:56.217]                     }
[13:36:56.217]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.217]                   }
[13:36:56.217]                 }
[13:36:56.217]                 else {
[13:36:56.217]                   if (TRUE) {
[13:36:56.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.217]                     {
[13:36:56.217]                       inherits <- base::inherits
[13:36:56.217]                       invokeRestart <- base::invokeRestart
[13:36:56.217]                       is.null <- base::is.null
[13:36:56.217]                       muffled <- FALSE
[13:36:56.217]                       if (inherits(cond, "message")) {
[13:36:56.217]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.217]                         if (muffled) 
[13:36:56.217]                           invokeRestart("muffleMessage")
[13:36:56.217]                       }
[13:36:56.217]                       else if (inherits(cond, "warning")) {
[13:36:56.217]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.217]                         if (muffled) 
[13:36:56.217]                           invokeRestart("muffleWarning")
[13:36:56.217]                       }
[13:36:56.217]                       else if (inherits(cond, "condition")) {
[13:36:56.217]                         if (!is.null(pattern)) {
[13:36:56.217]                           computeRestarts <- base::computeRestarts
[13:36:56.217]                           grepl <- base::grepl
[13:36:56.217]                           restarts <- computeRestarts(cond)
[13:36:56.217]                           for (restart in restarts) {
[13:36:56.217]                             name <- restart$name
[13:36:56.217]                             if (is.null(name)) 
[13:36:56.217]                               next
[13:36:56.217]                             if (!grepl(pattern, name)) 
[13:36:56.217]                               next
[13:36:56.217]                             invokeRestart(restart)
[13:36:56.217]                             muffled <- TRUE
[13:36:56.217]                             break
[13:36:56.217]                           }
[13:36:56.217]                         }
[13:36:56.217]                       }
[13:36:56.217]                       invisible(muffled)
[13:36:56.217]                     }
[13:36:56.217]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.217]                   }
[13:36:56.217]                 }
[13:36:56.217]             }
[13:36:56.217]         }))
[13:36:56.217]     }, error = function(ex) {
[13:36:56.217]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.217]                 ...future.rng), started = ...future.startTime, 
[13:36:56.217]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.217]             version = "1.8"), class = "FutureResult")
[13:36:56.217]     }, finally = {
[13:36:56.217]         if (!identical(...future.workdir, getwd())) 
[13:36:56.217]             setwd(...future.workdir)
[13:36:56.217]         {
[13:36:56.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.217]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.217]             }
[13:36:56.217]             base::options(...future.oldOptions)
[13:36:56.217]             if (.Platform$OS.type == "windows") {
[13:36:56.217]                 old_names <- names(...future.oldEnvVars)
[13:36:56.217]                 envs <- base::Sys.getenv()
[13:36:56.217]                 names <- names(envs)
[13:36:56.217]                 common <- intersect(names, old_names)
[13:36:56.217]                 added <- setdiff(names, old_names)
[13:36:56.217]                 removed <- setdiff(old_names, names)
[13:36:56.217]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.217]                   envs[common]]
[13:36:56.217]                 NAMES <- toupper(changed)
[13:36:56.217]                 args <- list()
[13:36:56.217]                 for (kk in seq_along(NAMES)) {
[13:36:56.217]                   name <- changed[[kk]]
[13:36:56.217]                   NAME <- NAMES[[kk]]
[13:36:56.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.217]                     next
[13:36:56.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.217]                 }
[13:36:56.217]                 NAMES <- toupper(added)
[13:36:56.217]                 for (kk in seq_along(NAMES)) {
[13:36:56.217]                   name <- added[[kk]]
[13:36:56.217]                   NAME <- NAMES[[kk]]
[13:36:56.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.217]                     next
[13:36:56.217]                   args[[name]] <- ""
[13:36:56.217]                 }
[13:36:56.217]                 NAMES <- toupper(removed)
[13:36:56.217]                 for (kk in seq_along(NAMES)) {
[13:36:56.217]                   name <- removed[[kk]]
[13:36:56.217]                   NAME <- NAMES[[kk]]
[13:36:56.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.217]                     next
[13:36:56.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.217]                 }
[13:36:56.217]                 if (length(args) > 0) 
[13:36:56.217]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.217]             }
[13:36:56.217]             else {
[13:36:56.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.217]             }
[13:36:56.217]             {
[13:36:56.217]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.217]                   0L) {
[13:36:56.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.217]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.217]                   base::options(opts)
[13:36:56.217]                 }
[13:36:56.217]                 {
[13:36:56.217]                   {
[13:36:56.217]                     NULL
[13:36:56.217]                     RNGkind("Mersenne-Twister")
[13:36:56.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.217]                       inherits = FALSE)
[13:36:56.217]                   }
[13:36:56.217]                   options(future.plan = NULL)
[13:36:56.217]                   if (is.na(NA_character_)) 
[13:36:56.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.217]                     .init = FALSE)
[13:36:56.217]                 }
[13:36:56.217]             }
[13:36:56.217]         }
[13:36:56.217]     })
[13:36:56.217]     if (TRUE) {
[13:36:56.217]         base::sink(type = "output", split = FALSE)
[13:36:56.217]         if (TRUE) {
[13:36:56.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.217]         }
[13:36:56.217]         else {
[13:36:56.217]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.217]         }
[13:36:56.217]         base::close(...future.stdout)
[13:36:56.217]         ...future.stdout <- NULL
[13:36:56.217]     }
[13:36:56.217]     ...future.result$conditions <- ...future.conditions
[13:36:56.217]     ...future.result$finished <- base::Sys.time()
[13:36:56.217]     ...future.result
[13:36:56.217] }
[13:36:56.219] assign_globals() ...
[13:36:56.219] List of 1
[13:36:56.219]  $ x:function ()  
[13:36:56.219]  - attr(*, "where")=List of 1
[13:36:56.219]   ..$ x:<environment: R_EmptyEnv> 
[13:36:56.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.219]  - attr(*, "resolved")= logi TRUE
[13:36:56.219]  - attr(*, "total_size")= num 1032
[13:36:56.219]  - attr(*, "already-done")= logi TRUE
[13:36:56.221] - reassign environment for ‘x’
[13:36:56.221] - copied ‘x’ to environment
[13:36:56.221] assign_globals() ... done
[13:36:56.222] plan(): Setting new future strategy stack:
[13:36:56.222] List of future strategies:
[13:36:56.222] 1. sequential:
[13:36:56.222]    - args: function (..., envir = parent.frame())
[13:36:56.222]    - tweaked: FALSE
[13:36:56.222]    - call: NULL
[13:36:56.222] plan(): nbrOfWorkers() = 1
[13:36:56.223] plan(): Setting new future strategy stack:
[13:36:56.223] List of future strategies:
[13:36:56.223] 1. sequential:
[13:36:56.223]    - args: function (..., envir = parent.frame())
[13:36:56.223]    - tweaked: FALSE
[13:36:56.223]    - call: plan(strategy)
[13:36:56.223] plan(): nbrOfWorkers() = 1
[13:36:56.223] SequentialFuture started (and completed)
[13:36:56.223] - Launch lazy future ... done
[13:36:56.224] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[13:36:56.232] plan(): Setting new future strategy stack:
[13:36:56.232] List of future strategies:
[13:36:56.232] 1. multicore:
[13:36:56.232]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.232]    - tweaked: FALSE
[13:36:56.232]    - call: plan(strategy)
[13:36:56.235] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.236] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.236] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.237] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:36:56.237] Searching for globals ... DONE
[13:36:56.237] Resolving globals: TRUE
[13:36:56.238] Resolving any globals that are futures ...
[13:36:56.238] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:36:56.239] Resolving any globals that are futures ... DONE
[13:36:56.239] 
[13:36:56.239] 
[13:36:56.239] getGlobalsAndPackages() ... DONE
[13:36:56.240] run() for ‘Future’ ...
[13:36:56.240] - state: ‘created’
[13:36:56.240] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.243] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.244]   - Field: ‘label’
[13:36:56.244]   - Field: ‘local’
[13:36:56.244]   - Field: ‘owner’
[13:36:56.244]   - Field: ‘envir’
[13:36:56.244]   - Field: ‘workers’
[13:36:56.244]   - Field: ‘packages’
[13:36:56.244]   - Field: ‘gc’
[13:36:56.244]   - Field: ‘job’
[13:36:56.244]   - Field: ‘conditions’
[13:36:56.244]   - Field: ‘expr’
[13:36:56.244]   - Field: ‘uuid’
[13:36:56.245]   - Field: ‘seed’
[13:36:56.245]   - Field: ‘version’
[13:36:56.245]   - Field: ‘result’
[13:36:56.245]   - Field: ‘asynchronous’
[13:36:56.245]   - Field: ‘calls’
[13:36:56.245]   - Field: ‘globals’
[13:36:56.245]   - Field: ‘stdout’
[13:36:56.245]   - Field: ‘earlySignal’
[13:36:56.245]   - Field: ‘lazy’
[13:36:56.245]   - Field: ‘state’
[13:36:56.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.245] - Launch lazy future ...
[13:36:56.246] Packages needed by the future expression (n = 0): <none>
[13:36:56.247] Packages needed by future strategies (n = 0): <none>
[13:36:56.247] {
[13:36:56.247]     {
[13:36:56.247]         {
[13:36:56.247]             ...future.startTime <- base::Sys.time()
[13:36:56.247]             {
[13:36:56.247]                 {
[13:36:56.247]                   {
[13:36:56.247]                     {
[13:36:56.247]                       base::local({
[13:36:56.247]                         has_future <- base::requireNamespace("future", 
[13:36:56.247]                           quietly = TRUE)
[13:36:56.247]                         if (has_future) {
[13:36:56.247]                           ns <- base::getNamespace("future")
[13:36:56.247]                           version <- ns[[".package"]][["version"]]
[13:36:56.247]                           if (is.null(version)) 
[13:36:56.247]                             version <- utils::packageVersion("future")
[13:36:56.247]                         }
[13:36:56.247]                         else {
[13:36:56.247]                           version <- NULL
[13:36:56.247]                         }
[13:36:56.247]                         if (!has_future || version < "1.8.0") {
[13:36:56.247]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.247]                             "", base::R.version$version.string), 
[13:36:56.247]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.247]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.247]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.247]                               "release", "version")], collapse = " "), 
[13:36:56.247]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.247]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.247]                             info)
[13:36:56.247]                           info <- base::paste(info, collapse = "; ")
[13:36:56.247]                           if (!has_future) {
[13:36:56.247]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.247]                               info)
[13:36:56.247]                           }
[13:36:56.247]                           else {
[13:36:56.247]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.247]                               info, version)
[13:36:56.247]                           }
[13:36:56.247]                           base::stop(msg)
[13:36:56.247]                         }
[13:36:56.247]                       })
[13:36:56.247]                     }
[13:36:56.247]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.247]                     base::options(mc.cores = 1L)
[13:36:56.247]                   }
[13:36:56.247]                   ...future.strategy.old <- future::plan("list")
[13:36:56.247]                   options(future.plan = NULL)
[13:36:56.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.247]                 }
[13:36:56.247]                 ...future.workdir <- getwd()
[13:36:56.247]             }
[13:36:56.247]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.247]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.247]         }
[13:36:56.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.247]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.247]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.247]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.247]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.247]             base::names(...future.oldOptions))
[13:36:56.247]     }
[13:36:56.247]     if (FALSE) {
[13:36:56.247]     }
[13:36:56.247]     else {
[13:36:56.247]         if (TRUE) {
[13:36:56.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.247]                 open = "w")
[13:36:56.247]         }
[13:36:56.247]         else {
[13:36:56.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.247]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.247]         }
[13:36:56.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.247]             base::sink(type = "output", split = FALSE)
[13:36:56.247]             base::close(...future.stdout)
[13:36:56.247]         }, add = TRUE)
[13:36:56.247]     }
[13:36:56.247]     ...future.frame <- base::sys.nframe()
[13:36:56.247]     ...future.conditions <- base::list()
[13:36:56.247]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.247]     if (FALSE) {
[13:36:56.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.247]     }
[13:36:56.247]     ...future.result <- base::tryCatch({
[13:36:56.247]         base::withCallingHandlers({
[13:36:56.247]             ...future.value <- base::withVisible(base::local({
[13:36:56.247]                 withCallingHandlers({
[13:36:56.247]                   {
[13:36:56.247]                     b <- a
[13:36:56.247]                     a <- 2
[13:36:56.247]                     a * b
[13:36:56.247]                   }
[13:36:56.247]                 }, immediateCondition = function(cond) {
[13:36:56.247]                   save_rds <- function (object, pathname, ...) 
[13:36:56.247]                   {
[13:36:56.247]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.247]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.247]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.247]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.247]                         fi_tmp[["mtime"]])
[13:36:56.247]                     }
[13:36:56.247]                     tryCatch({
[13:36:56.247]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.247]                     }, error = function(ex) {
[13:36:56.247]                       msg <- conditionMessage(ex)
[13:36:56.247]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.247]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.247]                         fi_tmp[["mtime"]], msg)
[13:36:56.247]                       ex$message <- msg
[13:36:56.247]                       stop(ex)
[13:36:56.247]                     })
[13:36:56.247]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.247]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.247]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.247]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.247]                       fi <- file.info(pathname)
[13:36:56.247]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.247]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.247]                         fi[["size"]], fi[["mtime"]])
[13:36:56.247]                       stop(msg)
[13:36:56.247]                     }
[13:36:56.247]                     invisible(pathname)
[13:36:56.247]                   }
[13:36:56.247]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.247]                     rootPath = tempdir()) 
[13:36:56.247]                   {
[13:36:56.247]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.247]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.247]                       tmpdir = path, fileext = ".rds")
[13:36:56.247]                     save_rds(obj, file)
[13:36:56.247]                   }
[13:36:56.247]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.247]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.247]                   {
[13:36:56.247]                     inherits <- base::inherits
[13:36:56.247]                     invokeRestart <- base::invokeRestart
[13:36:56.247]                     is.null <- base::is.null
[13:36:56.247]                     muffled <- FALSE
[13:36:56.247]                     if (inherits(cond, "message")) {
[13:36:56.247]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.247]                       if (muffled) 
[13:36:56.247]                         invokeRestart("muffleMessage")
[13:36:56.247]                     }
[13:36:56.247]                     else if (inherits(cond, "warning")) {
[13:36:56.247]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.247]                       if (muffled) 
[13:36:56.247]                         invokeRestart("muffleWarning")
[13:36:56.247]                     }
[13:36:56.247]                     else if (inherits(cond, "condition")) {
[13:36:56.247]                       if (!is.null(pattern)) {
[13:36:56.247]                         computeRestarts <- base::computeRestarts
[13:36:56.247]                         grepl <- base::grepl
[13:36:56.247]                         restarts <- computeRestarts(cond)
[13:36:56.247]                         for (restart in restarts) {
[13:36:56.247]                           name <- restart$name
[13:36:56.247]                           if (is.null(name)) 
[13:36:56.247]                             next
[13:36:56.247]                           if (!grepl(pattern, name)) 
[13:36:56.247]                             next
[13:36:56.247]                           invokeRestart(restart)
[13:36:56.247]                           muffled <- TRUE
[13:36:56.247]                           break
[13:36:56.247]                         }
[13:36:56.247]                       }
[13:36:56.247]                     }
[13:36:56.247]                     invisible(muffled)
[13:36:56.247]                   }
[13:36:56.247]                   muffleCondition(cond)
[13:36:56.247]                 })
[13:36:56.247]             }))
[13:36:56.247]             future::FutureResult(value = ...future.value$value, 
[13:36:56.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.247]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.247]                     ...future.globalenv.names))
[13:36:56.247]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.247]         }, condition = base::local({
[13:36:56.247]             c <- base::c
[13:36:56.247]             inherits <- base::inherits
[13:36:56.247]             invokeRestart <- base::invokeRestart
[13:36:56.247]             length <- base::length
[13:36:56.247]             list <- base::list
[13:36:56.247]             seq.int <- base::seq.int
[13:36:56.247]             signalCondition <- base::signalCondition
[13:36:56.247]             sys.calls <- base::sys.calls
[13:36:56.247]             `[[` <- base::`[[`
[13:36:56.247]             `+` <- base::`+`
[13:36:56.247]             `<<-` <- base::`<<-`
[13:36:56.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.247]                   3L)]
[13:36:56.247]             }
[13:36:56.247]             function(cond) {
[13:36:56.247]                 is_error <- inherits(cond, "error")
[13:36:56.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.247]                   NULL)
[13:36:56.247]                 if (is_error) {
[13:36:56.247]                   sessionInformation <- function() {
[13:36:56.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.247]                       search = base::search(), system = base::Sys.info())
[13:36:56.247]                   }
[13:36:56.247]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.247]                     cond$call), session = sessionInformation(), 
[13:36:56.247]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.247]                   signalCondition(cond)
[13:36:56.247]                 }
[13:36:56.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.247]                 "immediateCondition"))) {
[13:36:56.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.247]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.247]                   if (TRUE && !signal) {
[13:36:56.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.247]                     {
[13:36:56.247]                       inherits <- base::inherits
[13:36:56.247]                       invokeRestart <- base::invokeRestart
[13:36:56.247]                       is.null <- base::is.null
[13:36:56.247]                       muffled <- FALSE
[13:36:56.247]                       if (inherits(cond, "message")) {
[13:36:56.247]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.247]                         if (muffled) 
[13:36:56.247]                           invokeRestart("muffleMessage")
[13:36:56.247]                       }
[13:36:56.247]                       else if (inherits(cond, "warning")) {
[13:36:56.247]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.247]                         if (muffled) 
[13:36:56.247]                           invokeRestart("muffleWarning")
[13:36:56.247]                       }
[13:36:56.247]                       else if (inherits(cond, "condition")) {
[13:36:56.247]                         if (!is.null(pattern)) {
[13:36:56.247]                           computeRestarts <- base::computeRestarts
[13:36:56.247]                           grepl <- base::grepl
[13:36:56.247]                           restarts <- computeRestarts(cond)
[13:36:56.247]                           for (restart in restarts) {
[13:36:56.247]                             name <- restart$name
[13:36:56.247]                             if (is.null(name)) 
[13:36:56.247]                               next
[13:36:56.247]                             if (!grepl(pattern, name)) 
[13:36:56.247]                               next
[13:36:56.247]                             invokeRestart(restart)
[13:36:56.247]                             muffled <- TRUE
[13:36:56.247]                             break
[13:36:56.247]                           }
[13:36:56.247]                         }
[13:36:56.247]                       }
[13:36:56.247]                       invisible(muffled)
[13:36:56.247]                     }
[13:36:56.247]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.247]                   }
[13:36:56.247]                 }
[13:36:56.247]                 else {
[13:36:56.247]                   if (TRUE) {
[13:36:56.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.247]                     {
[13:36:56.247]                       inherits <- base::inherits
[13:36:56.247]                       invokeRestart <- base::invokeRestart
[13:36:56.247]                       is.null <- base::is.null
[13:36:56.247]                       muffled <- FALSE
[13:36:56.247]                       if (inherits(cond, "message")) {
[13:36:56.247]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.247]                         if (muffled) 
[13:36:56.247]                           invokeRestart("muffleMessage")
[13:36:56.247]                       }
[13:36:56.247]                       else if (inherits(cond, "warning")) {
[13:36:56.247]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.247]                         if (muffled) 
[13:36:56.247]                           invokeRestart("muffleWarning")
[13:36:56.247]                       }
[13:36:56.247]                       else if (inherits(cond, "condition")) {
[13:36:56.247]                         if (!is.null(pattern)) {
[13:36:56.247]                           computeRestarts <- base::computeRestarts
[13:36:56.247]                           grepl <- base::grepl
[13:36:56.247]                           restarts <- computeRestarts(cond)
[13:36:56.247]                           for (restart in restarts) {
[13:36:56.247]                             name <- restart$name
[13:36:56.247]                             if (is.null(name)) 
[13:36:56.247]                               next
[13:36:56.247]                             if (!grepl(pattern, name)) 
[13:36:56.247]                               next
[13:36:56.247]                             invokeRestart(restart)
[13:36:56.247]                             muffled <- TRUE
[13:36:56.247]                             break
[13:36:56.247]                           }
[13:36:56.247]                         }
[13:36:56.247]                       }
[13:36:56.247]                       invisible(muffled)
[13:36:56.247]                     }
[13:36:56.247]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.247]                   }
[13:36:56.247]                 }
[13:36:56.247]             }
[13:36:56.247]         }))
[13:36:56.247]     }, error = function(ex) {
[13:36:56.247]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.247]                 ...future.rng), started = ...future.startTime, 
[13:36:56.247]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.247]             version = "1.8"), class = "FutureResult")
[13:36:56.247]     }, finally = {
[13:36:56.247]         if (!identical(...future.workdir, getwd())) 
[13:36:56.247]             setwd(...future.workdir)
[13:36:56.247]         {
[13:36:56.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.247]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.247]             }
[13:36:56.247]             base::options(...future.oldOptions)
[13:36:56.247]             if (.Platform$OS.type == "windows") {
[13:36:56.247]                 old_names <- names(...future.oldEnvVars)
[13:36:56.247]                 envs <- base::Sys.getenv()
[13:36:56.247]                 names <- names(envs)
[13:36:56.247]                 common <- intersect(names, old_names)
[13:36:56.247]                 added <- setdiff(names, old_names)
[13:36:56.247]                 removed <- setdiff(old_names, names)
[13:36:56.247]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.247]                   envs[common]]
[13:36:56.247]                 NAMES <- toupper(changed)
[13:36:56.247]                 args <- list()
[13:36:56.247]                 for (kk in seq_along(NAMES)) {
[13:36:56.247]                   name <- changed[[kk]]
[13:36:56.247]                   NAME <- NAMES[[kk]]
[13:36:56.247]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.247]                     next
[13:36:56.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.247]                 }
[13:36:56.247]                 NAMES <- toupper(added)
[13:36:56.247]                 for (kk in seq_along(NAMES)) {
[13:36:56.247]                   name <- added[[kk]]
[13:36:56.247]                   NAME <- NAMES[[kk]]
[13:36:56.247]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.247]                     next
[13:36:56.247]                   args[[name]] <- ""
[13:36:56.247]                 }
[13:36:56.247]                 NAMES <- toupper(removed)
[13:36:56.247]                 for (kk in seq_along(NAMES)) {
[13:36:56.247]                   name <- removed[[kk]]
[13:36:56.247]                   NAME <- NAMES[[kk]]
[13:36:56.247]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.247]                     next
[13:36:56.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.247]                 }
[13:36:56.247]                 if (length(args) > 0) 
[13:36:56.247]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.247]             }
[13:36:56.247]             else {
[13:36:56.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.247]             }
[13:36:56.247]             {
[13:36:56.247]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.247]                   0L) {
[13:36:56.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.247]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.247]                   base::options(opts)
[13:36:56.247]                 }
[13:36:56.247]                 {
[13:36:56.247]                   {
[13:36:56.247]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.247]                     NULL
[13:36:56.247]                   }
[13:36:56.247]                   options(future.plan = NULL)
[13:36:56.247]                   if (is.na(NA_character_)) 
[13:36:56.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.247]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.247]                     .init = FALSE)
[13:36:56.247]                 }
[13:36:56.247]             }
[13:36:56.247]         }
[13:36:56.247]     })
[13:36:56.247]     if (TRUE) {
[13:36:56.247]         base::sink(type = "output", split = FALSE)
[13:36:56.247]         if (TRUE) {
[13:36:56.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.247]         }
[13:36:56.247]         else {
[13:36:56.247]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.247]         }
[13:36:56.247]         base::close(...future.stdout)
[13:36:56.247]         ...future.stdout <- NULL
[13:36:56.247]     }
[13:36:56.247]     ...future.result$conditions <- ...future.conditions
[13:36:56.247]     ...future.result$finished <- base::Sys.time()
[13:36:56.247]     ...future.result
[13:36:56.247] }
[13:36:56.249] requestCore(): workers = 2
[13:36:56.252] MulticoreFuture started
[13:36:56.253] - Launch lazy future ... done
[13:36:56.253] plan(): Setting new future strategy stack:
[13:36:56.253] run() for ‘MulticoreFuture’ ... done
[13:36:56.253] List of future strategies:
[13:36:56.253] 1. sequential:
[13:36:56.253]    - args: function (..., envir = parent.frame())
[13:36:56.253]    - tweaked: FALSE
[13:36:56.253]    - call: NULL
[13:36:56.254] plan(): nbrOfWorkers() = 1
[13:36:56.254] result() for MulticoreFuture ...
[13:36:56.256] plan(): Setting new future strategy stack:
[13:36:56.256] List of future strategies:
[13:36:56.256] 1. multicore:
[13:36:56.256]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.256]    - tweaked: FALSE
[13:36:56.256]    - call: plan(strategy)
[13:36:56.261] plan(): nbrOfWorkers() = 2
[13:36:56.266] result() for MulticoreFuture ...
[13:36:56.267] result() for MulticoreFuture ... done
[13:36:56.267] result() for MulticoreFuture ... done
[13:36:56.267] result() for MulticoreFuture ...
[13:36:56.267] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.268] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.268] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.269] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:36:56.270] Searching for globals ... DONE
[13:36:56.270] Resolving globals: TRUE
[13:36:56.270] Resolving any globals that are futures ...
[13:36:56.270] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:36:56.270] Resolving any globals that are futures ... DONE
[13:36:56.271] 
[13:36:56.271] 
[13:36:56.271] getGlobalsAndPackages() ... DONE
[13:36:56.271] run() for ‘Future’ ...
[13:36:56.271] - state: ‘created’
[13:36:56.271] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.275] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.276]   - Field: ‘label’
[13:36:56.276]   - Field: ‘local’
[13:36:56.276]   - Field: ‘owner’
[13:36:56.276]   - Field: ‘envir’
[13:36:56.276]   - Field: ‘workers’
[13:36:56.276]   - Field: ‘packages’
[13:36:56.276]   - Field: ‘gc’
[13:36:56.276]   - Field: ‘job’
[13:36:56.277]   - Field: ‘conditions’
[13:36:56.277]   - Field: ‘expr’
[13:36:56.277]   - Field: ‘uuid’
[13:36:56.277]   - Field: ‘seed’
[13:36:56.277]   - Field: ‘version’
[13:36:56.277]   - Field: ‘result’
[13:36:56.277]   - Field: ‘asynchronous’
[13:36:56.277]   - Field: ‘calls’
[13:36:56.277]   - Field: ‘globals’
[13:36:56.278]   - Field: ‘stdout’
[13:36:56.278]   - Field: ‘earlySignal’
[13:36:56.278]   - Field: ‘lazy’
[13:36:56.278]   - Field: ‘state’
[13:36:56.278] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.278] - Launch lazy future ...
[13:36:56.278] Packages needed by the future expression (n = 0): <none>
[13:36:56.279] Packages needed by future strategies (n = 0): <none>
[13:36:56.279] {
[13:36:56.279]     {
[13:36:56.279]         {
[13:36:56.279]             ...future.startTime <- base::Sys.time()
[13:36:56.279]             {
[13:36:56.279]                 {
[13:36:56.279]                   {
[13:36:56.279]                     {
[13:36:56.279]                       base::local({
[13:36:56.279]                         has_future <- base::requireNamespace("future", 
[13:36:56.279]                           quietly = TRUE)
[13:36:56.279]                         if (has_future) {
[13:36:56.279]                           ns <- base::getNamespace("future")
[13:36:56.279]                           version <- ns[[".package"]][["version"]]
[13:36:56.279]                           if (is.null(version)) 
[13:36:56.279]                             version <- utils::packageVersion("future")
[13:36:56.279]                         }
[13:36:56.279]                         else {
[13:36:56.279]                           version <- NULL
[13:36:56.279]                         }
[13:36:56.279]                         if (!has_future || version < "1.8.0") {
[13:36:56.279]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.279]                             "", base::R.version$version.string), 
[13:36:56.279]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.279]                               "release", "version")], collapse = " "), 
[13:36:56.279]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.279]                             info)
[13:36:56.279]                           info <- base::paste(info, collapse = "; ")
[13:36:56.279]                           if (!has_future) {
[13:36:56.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.279]                               info)
[13:36:56.279]                           }
[13:36:56.279]                           else {
[13:36:56.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.279]                               info, version)
[13:36:56.279]                           }
[13:36:56.279]                           base::stop(msg)
[13:36:56.279]                         }
[13:36:56.279]                       })
[13:36:56.279]                     }
[13:36:56.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.279]                     base::options(mc.cores = 1L)
[13:36:56.279]                   }
[13:36:56.279]                   ...future.strategy.old <- future::plan("list")
[13:36:56.279]                   options(future.plan = NULL)
[13:36:56.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.279]                 }
[13:36:56.279]                 ...future.workdir <- getwd()
[13:36:56.279]             }
[13:36:56.279]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.279]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.279]         }
[13:36:56.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.279]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.279]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.279]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.279]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.279]             base::names(...future.oldOptions))
[13:36:56.279]     }
[13:36:56.279]     if (FALSE) {
[13:36:56.279]     }
[13:36:56.279]     else {
[13:36:56.279]         if (TRUE) {
[13:36:56.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.279]                 open = "w")
[13:36:56.279]         }
[13:36:56.279]         else {
[13:36:56.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.279]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.279]         }
[13:36:56.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.279]             base::sink(type = "output", split = FALSE)
[13:36:56.279]             base::close(...future.stdout)
[13:36:56.279]         }, add = TRUE)
[13:36:56.279]     }
[13:36:56.279]     ...future.frame <- base::sys.nframe()
[13:36:56.279]     ...future.conditions <- base::list()
[13:36:56.279]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.279]     if (FALSE) {
[13:36:56.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.279]     }
[13:36:56.279]     ...future.result <- base::tryCatch({
[13:36:56.279]         base::withCallingHandlers({
[13:36:56.279]             ...future.value <- base::withVisible(base::local({
[13:36:56.279]                 withCallingHandlers({
[13:36:56.279]                   {
[13:36:56.279]                     b <- a
[13:36:56.279]                     a <- 2
[13:36:56.279]                     a * b
[13:36:56.279]                   }
[13:36:56.279]                 }, immediateCondition = function(cond) {
[13:36:56.279]                   save_rds <- function (object, pathname, ...) 
[13:36:56.279]                   {
[13:36:56.279]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.279]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.279]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.279]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.279]                         fi_tmp[["mtime"]])
[13:36:56.279]                     }
[13:36:56.279]                     tryCatch({
[13:36:56.279]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.279]                     }, error = function(ex) {
[13:36:56.279]                       msg <- conditionMessage(ex)
[13:36:56.279]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.279]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.279]                         fi_tmp[["mtime"]], msg)
[13:36:56.279]                       ex$message <- msg
[13:36:56.279]                       stop(ex)
[13:36:56.279]                     })
[13:36:56.279]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.279]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.279]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.279]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.279]                       fi <- file.info(pathname)
[13:36:56.279]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.279]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.279]                         fi[["size"]], fi[["mtime"]])
[13:36:56.279]                       stop(msg)
[13:36:56.279]                     }
[13:36:56.279]                     invisible(pathname)
[13:36:56.279]                   }
[13:36:56.279]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.279]                     rootPath = tempdir()) 
[13:36:56.279]                   {
[13:36:56.279]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.279]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.279]                       tmpdir = path, fileext = ".rds")
[13:36:56.279]                     save_rds(obj, file)
[13:36:56.279]                   }
[13:36:56.279]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.279]                   {
[13:36:56.279]                     inherits <- base::inherits
[13:36:56.279]                     invokeRestart <- base::invokeRestart
[13:36:56.279]                     is.null <- base::is.null
[13:36:56.279]                     muffled <- FALSE
[13:36:56.279]                     if (inherits(cond, "message")) {
[13:36:56.279]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.279]                       if (muffled) 
[13:36:56.279]                         invokeRestart("muffleMessage")
[13:36:56.279]                     }
[13:36:56.279]                     else if (inherits(cond, "warning")) {
[13:36:56.279]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.279]                       if (muffled) 
[13:36:56.279]                         invokeRestart("muffleWarning")
[13:36:56.279]                     }
[13:36:56.279]                     else if (inherits(cond, "condition")) {
[13:36:56.279]                       if (!is.null(pattern)) {
[13:36:56.279]                         computeRestarts <- base::computeRestarts
[13:36:56.279]                         grepl <- base::grepl
[13:36:56.279]                         restarts <- computeRestarts(cond)
[13:36:56.279]                         for (restart in restarts) {
[13:36:56.279]                           name <- restart$name
[13:36:56.279]                           if (is.null(name)) 
[13:36:56.279]                             next
[13:36:56.279]                           if (!grepl(pattern, name)) 
[13:36:56.279]                             next
[13:36:56.279]                           invokeRestart(restart)
[13:36:56.279]                           muffled <- TRUE
[13:36:56.279]                           break
[13:36:56.279]                         }
[13:36:56.279]                       }
[13:36:56.279]                     }
[13:36:56.279]                     invisible(muffled)
[13:36:56.279]                   }
[13:36:56.279]                   muffleCondition(cond)
[13:36:56.279]                 })
[13:36:56.279]             }))
[13:36:56.279]             future::FutureResult(value = ...future.value$value, 
[13:36:56.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.279]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.279]                     ...future.globalenv.names))
[13:36:56.279]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.279]         }, condition = base::local({
[13:36:56.279]             c <- base::c
[13:36:56.279]             inherits <- base::inherits
[13:36:56.279]             invokeRestart <- base::invokeRestart
[13:36:56.279]             length <- base::length
[13:36:56.279]             list <- base::list
[13:36:56.279]             seq.int <- base::seq.int
[13:36:56.279]             signalCondition <- base::signalCondition
[13:36:56.279]             sys.calls <- base::sys.calls
[13:36:56.279]             `[[` <- base::`[[`
[13:36:56.279]             `+` <- base::`+`
[13:36:56.279]             `<<-` <- base::`<<-`
[13:36:56.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.279]                   3L)]
[13:36:56.279]             }
[13:36:56.279]             function(cond) {
[13:36:56.279]                 is_error <- inherits(cond, "error")
[13:36:56.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.279]                   NULL)
[13:36:56.279]                 if (is_error) {
[13:36:56.279]                   sessionInformation <- function() {
[13:36:56.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.279]                       search = base::search(), system = base::Sys.info())
[13:36:56.279]                   }
[13:36:56.279]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.279]                     cond$call), session = sessionInformation(), 
[13:36:56.279]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.279]                   signalCondition(cond)
[13:36:56.279]                 }
[13:36:56.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.279]                 "immediateCondition"))) {
[13:36:56.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.279]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.279]                   if (TRUE && !signal) {
[13:36:56.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.279]                     {
[13:36:56.279]                       inherits <- base::inherits
[13:36:56.279]                       invokeRestart <- base::invokeRestart
[13:36:56.279]                       is.null <- base::is.null
[13:36:56.279]                       muffled <- FALSE
[13:36:56.279]                       if (inherits(cond, "message")) {
[13:36:56.279]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.279]                         if (muffled) 
[13:36:56.279]                           invokeRestart("muffleMessage")
[13:36:56.279]                       }
[13:36:56.279]                       else if (inherits(cond, "warning")) {
[13:36:56.279]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.279]                         if (muffled) 
[13:36:56.279]                           invokeRestart("muffleWarning")
[13:36:56.279]                       }
[13:36:56.279]                       else if (inherits(cond, "condition")) {
[13:36:56.279]                         if (!is.null(pattern)) {
[13:36:56.279]                           computeRestarts <- base::computeRestarts
[13:36:56.279]                           grepl <- base::grepl
[13:36:56.279]                           restarts <- computeRestarts(cond)
[13:36:56.279]                           for (restart in restarts) {
[13:36:56.279]                             name <- restart$name
[13:36:56.279]                             if (is.null(name)) 
[13:36:56.279]                               next
[13:36:56.279]                             if (!grepl(pattern, name)) 
[13:36:56.279]                               next
[13:36:56.279]                             invokeRestart(restart)
[13:36:56.279]                             muffled <- TRUE
[13:36:56.279]                             break
[13:36:56.279]                           }
[13:36:56.279]                         }
[13:36:56.279]                       }
[13:36:56.279]                       invisible(muffled)
[13:36:56.279]                     }
[13:36:56.279]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.279]                   }
[13:36:56.279]                 }
[13:36:56.279]                 else {
[13:36:56.279]                   if (TRUE) {
[13:36:56.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.279]                     {
[13:36:56.279]                       inherits <- base::inherits
[13:36:56.279]                       invokeRestart <- base::invokeRestart
[13:36:56.279]                       is.null <- base::is.null
[13:36:56.279]                       muffled <- FALSE
[13:36:56.279]                       if (inherits(cond, "message")) {
[13:36:56.279]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.279]                         if (muffled) 
[13:36:56.279]                           invokeRestart("muffleMessage")
[13:36:56.279]                       }
[13:36:56.279]                       else if (inherits(cond, "warning")) {
[13:36:56.279]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.279]                         if (muffled) 
[13:36:56.279]                           invokeRestart("muffleWarning")
[13:36:56.279]                       }
[13:36:56.279]                       else if (inherits(cond, "condition")) {
[13:36:56.279]                         if (!is.null(pattern)) {
[13:36:56.279]                           computeRestarts <- base::computeRestarts
[13:36:56.279]                           grepl <- base::grepl
[13:36:56.279]                           restarts <- computeRestarts(cond)
[13:36:56.279]                           for (restart in restarts) {
[13:36:56.279]                             name <- restart$name
[13:36:56.279]                             if (is.null(name)) 
[13:36:56.279]                               next
[13:36:56.279]                             if (!grepl(pattern, name)) 
[13:36:56.279]                               next
[13:36:56.279]                             invokeRestart(restart)
[13:36:56.279]                             muffled <- TRUE
[13:36:56.279]                             break
[13:36:56.279]                           }
[13:36:56.279]                         }
[13:36:56.279]                       }
[13:36:56.279]                       invisible(muffled)
[13:36:56.279]                     }
[13:36:56.279]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.279]                   }
[13:36:56.279]                 }
[13:36:56.279]             }
[13:36:56.279]         }))
[13:36:56.279]     }, error = function(ex) {
[13:36:56.279]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.279]                 ...future.rng), started = ...future.startTime, 
[13:36:56.279]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.279]             version = "1.8"), class = "FutureResult")
[13:36:56.279]     }, finally = {
[13:36:56.279]         if (!identical(...future.workdir, getwd())) 
[13:36:56.279]             setwd(...future.workdir)
[13:36:56.279]         {
[13:36:56.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.279]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.279]             }
[13:36:56.279]             base::options(...future.oldOptions)
[13:36:56.279]             if (.Platform$OS.type == "windows") {
[13:36:56.279]                 old_names <- names(...future.oldEnvVars)
[13:36:56.279]                 envs <- base::Sys.getenv()
[13:36:56.279]                 names <- names(envs)
[13:36:56.279]                 common <- intersect(names, old_names)
[13:36:56.279]                 added <- setdiff(names, old_names)
[13:36:56.279]                 removed <- setdiff(old_names, names)
[13:36:56.279]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.279]                   envs[common]]
[13:36:56.279]                 NAMES <- toupper(changed)
[13:36:56.279]                 args <- list()
[13:36:56.279]                 for (kk in seq_along(NAMES)) {
[13:36:56.279]                   name <- changed[[kk]]
[13:36:56.279]                   NAME <- NAMES[[kk]]
[13:36:56.279]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.279]                     next
[13:36:56.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.279]                 }
[13:36:56.279]                 NAMES <- toupper(added)
[13:36:56.279]                 for (kk in seq_along(NAMES)) {
[13:36:56.279]                   name <- added[[kk]]
[13:36:56.279]                   NAME <- NAMES[[kk]]
[13:36:56.279]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.279]                     next
[13:36:56.279]                   args[[name]] <- ""
[13:36:56.279]                 }
[13:36:56.279]                 NAMES <- toupper(removed)
[13:36:56.279]                 for (kk in seq_along(NAMES)) {
[13:36:56.279]                   name <- removed[[kk]]
[13:36:56.279]                   NAME <- NAMES[[kk]]
[13:36:56.279]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.279]                     next
[13:36:56.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.279]                 }
[13:36:56.279]                 if (length(args) > 0) 
[13:36:56.279]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.279]             }
[13:36:56.279]             else {
[13:36:56.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.279]             }
[13:36:56.279]             {
[13:36:56.279]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.279]                   0L) {
[13:36:56.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.279]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.279]                   base::options(opts)
[13:36:56.279]                 }
[13:36:56.279]                 {
[13:36:56.279]                   {
[13:36:56.279]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.279]                     NULL
[13:36:56.279]                   }
[13:36:56.279]                   options(future.plan = NULL)
[13:36:56.279]                   if (is.na(NA_character_)) 
[13:36:56.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.279]                     .init = FALSE)
[13:36:56.279]                 }
[13:36:56.279]             }
[13:36:56.279]         }
[13:36:56.279]     })
[13:36:56.279]     if (TRUE) {
[13:36:56.279]         base::sink(type = "output", split = FALSE)
[13:36:56.279]         if (TRUE) {
[13:36:56.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.279]         }
[13:36:56.279]         else {
[13:36:56.279]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.279]         }
[13:36:56.279]         base::close(...future.stdout)
[13:36:56.279]         ...future.stdout <- NULL
[13:36:56.279]     }
[13:36:56.279]     ...future.result$conditions <- ...future.conditions
[13:36:56.279]     ...future.result$finished <- base::Sys.time()
[13:36:56.279]     ...future.result
[13:36:56.279] }
[13:36:56.282] requestCore(): workers = 2
[13:36:56.283] MulticoreFuture started
[13:36:56.284] - Launch lazy future ... done
[13:36:56.284] run() for ‘MulticoreFuture’ ... done
[13:36:56.284] result() for MulticoreFuture ...
[13:36:56.284] plan(): Setting new future strategy stack:
[13:36:56.285] List of future strategies:
[13:36:56.285] 1. sequential:
[13:36:56.285]    - args: function (..., envir = parent.frame())
[13:36:56.285]    - tweaked: FALSE
[13:36:56.285]    - call: NULL
[13:36:56.285] plan(): nbrOfWorkers() = 1
[13:36:56.288] plan(): Setting new future strategy stack:
[13:36:56.288] List of future strategies:
[13:36:56.288] 1. multicore:
[13:36:56.288]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.288]    - tweaked: FALSE
[13:36:56.288]    - call: plan(strategy)
[13:36:56.293] plan(): nbrOfWorkers() = 2
[13:36:56.299] result() for MulticoreFuture ...
[13:36:56.299] result() for MulticoreFuture ... done
[13:36:56.299] signalConditions() ...
[13:36:56.299]  - include = ‘immediateCondition’
[13:36:56.300]  - exclude = 
[13:36:56.300]  - resignal = FALSE
[13:36:56.300]  - Number of conditions: 1
[13:36:56.300] signalConditions() ... done
[13:36:56.300] result() for MulticoreFuture ... done
[13:36:56.300] result() for MulticoreFuture ...
[13:36:56.300] result() for MulticoreFuture ... done
[13:36:56.301] signalConditions() ...
[13:36:56.301]  - include = ‘immediateCondition’
[13:36:56.301]  - exclude = 
[13:36:56.301]  - resignal = FALSE
[13:36:56.301]  - Number of conditions: 1
[13:36:56.301] signalConditions() ... done
[13:36:56.301] Future state: ‘finished’
[13:36:56.302] result() for MulticoreFuture ...
[13:36:56.302] result() for MulticoreFuture ... done
[13:36:56.302] signalConditions() ...
[13:36:56.302]  - include = ‘condition’
[13:36:56.306]  - exclude = ‘immediateCondition’
[13:36:56.306]  - resignal = TRUE
[13:36:56.306]  - Number of conditions: 1
[13:36:56.306]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:56.307] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "57e9b94e809f" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:36:56"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.335] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.335] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.337] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.337] Searching for globals ... DONE
[13:36:56.337] Resolving globals: TRUE
[13:36:56.337] Resolving any globals that are futures ...
[13:36:56.337] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.337] Resolving any globals that are futures ... DONE
[13:36:56.338] Resolving futures part of globals (recursively) ...
[13:36:56.338] resolve() on list ...
[13:36:56.338]  recursive: 99
[13:36:56.338]  length: 1
[13:36:56.338]  elements: ‘ii’
[13:36:56.338]  length: 0 (resolved future 1)
[13:36:56.339] resolve() on list ... DONE
[13:36:56.339] - globals: [1] ‘ii’
[13:36:56.339] Resolving futures part of globals (recursively) ... DONE
[13:36:56.339] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:56.339] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.339] - globals: [1] ‘ii’
[13:36:56.339] 
[13:36:56.340] getGlobalsAndPackages() ... DONE
[13:36:56.340] run() for ‘Future’ ...
[13:36:56.340] - state: ‘created’
[13:36:56.340] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.344] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.344] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.344]   - Field: ‘label’
[13:36:56.344]   - Field: ‘local’
[13:36:56.344]   - Field: ‘owner’
[13:36:56.345]   - Field: ‘envir’
[13:36:56.345]   - Field: ‘workers’
[13:36:56.345]   - Field: ‘packages’
[13:36:56.345]   - Field: ‘gc’
[13:36:56.345]   - Field: ‘job’
[13:36:56.345]   - Field: ‘conditions’
[13:36:56.345]   - Field: ‘expr’
[13:36:56.345]   - Field: ‘uuid’
[13:36:56.345]   - Field: ‘seed’
[13:36:56.345]   - Field: ‘version’
[13:36:56.346]   - Field: ‘result’
[13:36:56.346]   - Field: ‘asynchronous’
[13:36:56.346]   - Field: ‘calls’
[13:36:56.346]   - Field: ‘globals’
[13:36:56.346]   - Field: ‘stdout’
[13:36:56.346]   - Field: ‘earlySignal’
[13:36:56.346]   - Field: ‘lazy’
[13:36:56.346]   - Field: ‘state’
[13:36:56.346] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.346] - Launch lazy future ...
[13:36:56.347] Packages needed by the future expression (n = 0): <none>
[13:36:56.347] Packages needed by future strategies (n = 0): <none>
[13:36:56.347] {
[13:36:56.347]     {
[13:36:56.347]         {
[13:36:56.347]             ...future.startTime <- base::Sys.time()
[13:36:56.347]             {
[13:36:56.347]                 {
[13:36:56.347]                   {
[13:36:56.347]                     {
[13:36:56.347]                       base::local({
[13:36:56.347]                         has_future <- base::requireNamespace("future", 
[13:36:56.347]                           quietly = TRUE)
[13:36:56.347]                         if (has_future) {
[13:36:56.347]                           ns <- base::getNamespace("future")
[13:36:56.347]                           version <- ns[[".package"]][["version"]]
[13:36:56.347]                           if (is.null(version)) 
[13:36:56.347]                             version <- utils::packageVersion("future")
[13:36:56.347]                         }
[13:36:56.347]                         else {
[13:36:56.347]                           version <- NULL
[13:36:56.347]                         }
[13:36:56.347]                         if (!has_future || version < "1.8.0") {
[13:36:56.347]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.347]                             "", base::R.version$version.string), 
[13:36:56.347]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.347]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.347]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.347]                               "release", "version")], collapse = " "), 
[13:36:56.347]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.347]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.347]                             info)
[13:36:56.347]                           info <- base::paste(info, collapse = "; ")
[13:36:56.347]                           if (!has_future) {
[13:36:56.347]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.347]                               info)
[13:36:56.347]                           }
[13:36:56.347]                           else {
[13:36:56.347]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.347]                               info, version)
[13:36:56.347]                           }
[13:36:56.347]                           base::stop(msg)
[13:36:56.347]                         }
[13:36:56.347]                       })
[13:36:56.347]                     }
[13:36:56.347]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.347]                     base::options(mc.cores = 1L)
[13:36:56.347]                   }
[13:36:56.347]                   ...future.strategy.old <- future::plan("list")
[13:36:56.347]                   options(future.plan = NULL)
[13:36:56.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.347]                 }
[13:36:56.347]                 ...future.workdir <- getwd()
[13:36:56.347]             }
[13:36:56.347]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.347]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.347]         }
[13:36:56.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.347]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.347]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.347]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.347]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.347]             base::names(...future.oldOptions))
[13:36:56.347]     }
[13:36:56.347]     if (FALSE) {
[13:36:56.347]     }
[13:36:56.347]     else {
[13:36:56.347]         if (TRUE) {
[13:36:56.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.347]                 open = "w")
[13:36:56.347]         }
[13:36:56.347]         else {
[13:36:56.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.347]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.347]         }
[13:36:56.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.347]             base::sink(type = "output", split = FALSE)
[13:36:56.347]             base::close(...future.stdout)
[13:36:56.347]         }, add = TRUE)
[13:36:56.347]     }
[13:36:56.347]     ...future.frame <- base::sys.nframe()
[13:36:56.347]     ...future.conditions <- base::list()
[13:36:56.347]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.347]     if (FALSE) {
[13:36:56.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.347]     }
[13:36:56.347]     ...future.result <- base::tryCatch({
[13:36:56.347]         base::withCallingHandlers({
[13:36:56.347]             ...future.value <- base::withVisible(base::local({
[13:36:56.347]                 withCallingHandlers({
[13:36:56.347]                   {
[13:36:56.347]                     b <- a * ii
[13:36:56.347]                     a <- 0
[13:36:56.347]                     b
[13:36:56.347]                   }
[13:36:56.347]                 }, immediateCondition = function(cond) {
[13:36:56.347]                   save_rds <- function (object, pathname, ...) 
[13:36:56.347]                   {
[13:36:56.347]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.347]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.347]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.347]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.347]                         fi_tmp[["mtime"]])
[13:36:56.347]                     }
[13:36:56.347]                     tryCatch({
[13:36:56.347]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.347]                     }, error = function(ex) {
[13:36:56.347]                       msg <- conditionMessage(ex)
[13:36:56.347]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.347]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.347]                         fi_tmp[["mtime"]], msg)
[13:36:56.347]                       ex$message <- msg
[13:36:56.347]                       stop(ex)
[13:36:56.347]                     })
[13:36:56.347]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.347]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.347]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.347]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.347]                       fi <- file.info(pathname)
[13:36:56.347]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.347]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.347]                         fi[["size"]], fi[["mtime"]])
[13:36:56.347]                       stop(msg)
[13:36:56.347]                     }
[13:36:56.347]                     invisible(pathname)
[13:36:56.347]                   }
[13:36:56.347]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.347]                     rootPath = tempdir()) 
[13:36:56.347]                   {
[13:36:56.347]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.347]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.347]                       tmpdir = path, fileext = ".rds")
[13:36:56.347]                     save_rds(obj, file)
[13:36:56.347]                   }
[13:36:56.347]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.347]                   {
[13:36:56.347]                     inherits <- base::inherits
[13:36:56.347]                     invokeRestart <- base::invokeRestart
[13:36:56.347]                     is.null <- base::is.null
[13:36:56.347]                     muffled <- FALSE
[13:36:56.347]                     if (inherits(cond, "message")) {
[13:36:56.347]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.347]                       if (muffled) 
[13:36:56.347]                         invokeRestart("muffleMessage")
[13:36:56.347]                     }
[13:36:56.347]                     else if (inherits(cond, "warning")) {
[13:36:56.347]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.347]                       if (muffled) 
[13:36:56.347]                         invokeRestart("muffleWarning")
[13:36:56.347]                     }
[13:36:56.347]                     else if (inherits(cond, "condition")) {
[13:36:56.347]                       if (!is.null(pattern)) {
[13:36:56.347]                         computeRestarts <- base::computeRestarts
[13:36:56.347]                         grepl <- base::grepl
[13:36:56.347]                         restarts <- computeRestarts(cond)
[13:36:56.347]                         for (restart in restarts) {
[13:36:56.347]                           name <- restart$name
[13:36:56.347]                           if (is.null(name)) 
[13:36:56.347]                             next
[13:36:56.347]                           if (!grepl(pattern, name)) 
[13:36:56.347]                             next
[13:36:56.347]                           invokeRestart(restart)
[13:36:56.347]                           muffled <- TRUE
[13:36:56.347]                           break
[13:36:56.347]                         }
[13:36:56.347]                       }
[13:36:56.347]                     }
[13:36:56.347]                     invisible(muffled)
[13:36:56.347]                   }
[13:36:56.347]                   muffleCondition(cond)
[13:36:56.347]                 })
[13:36:56.347]             }))
[13:36:56.347]             future::FutureResult(value = ...future.value$value, 
[13:36:56.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.347]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.347]                     ...future.globalenv.names))
[13:36:56.347]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.347]         }, condition = base::local({
[13:36:56.347]             c <- base::c
[13:36:56.347]             inherits <- base::inherits
[13:36:56.347]             invokeRestart <- base::invokeRestart
[13:36:56.347]             length <- base::length
[13:36:56.347]             list <- base::list
[13:36:56.347]             seq.int <- base::seq.int
[13:36:56.347]             signalCondition <- base::signalCondition
[13:36:56.347]             sys.calls <- base::sys.calls
[13:36:56.347]             `[[` <- base::`[[`
[13:36:56.347]             `+` <- base::`+`
[13:36:56.347]             `<<-` <- base::`<<-`
[13:36:56.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.347]                   3L)]
[13:36:56.347]             }
[13:36:56.347]             function(cond) {
[13:36:56.347]                 is_error <- inherits(cond, "error")
[13:36:56.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.347]                   NULL)
[13:36:56.347]                 if (is_error) {
[13:36:56.347]                   sessionInformation <- function() {
[13:36:56.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.347]                       search = base::search(), system = base::Sys.info())
[13:36:56.347]                   }
[13:36:56.347]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.347]                     cond$call), session = sessionInformation(), 
[13:36:56.347]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.347]                   signalCondition(cond)
[13:36:56.347]                 }
[13:36:56.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.347]                 "immediateCondition"))) {
[13:36:56.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.347]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.347]                   if (TRUE && !signal) {
[13:36:56.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.347]                     {
[13:36:56.347]                       inherits <- base::inherits
[13:36:56.347]                       invokeRestart <- base::invokeRestart
[13:36:56.347]                       is.null <- base::is.null
[13:36:56.347]                       muffled <- FALSE
[13:36:56.347]                       if (inherits(cond, "message")) {
[13:36:56.347]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.347]                         if (muffled) 
[13:36:56.347]                           invokeRestart("muffleMessage")
[13:36:56.347]                       }
[13:36:56.347]                       else if (inherits(cond, "warning")) {
[13:36:56.347]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.347]                         if (muffled) 
[13:36:56.347]                           invokeRestart("muffleWarning")
[13:36:56.347]                       }
[13:36:56.347]                       else if (inherits(cond, "condition")) {
[13:36:56.347]                         if (!is.null(pattern)) {
[13:36:56.347]                           computeRestarts <- base::computeRestarts
[13:36:56.347]                           grepl <- base::grepl
[13:36:56.347]                           restarts <- computeRestarts(cond)
[13:36:56.347]                           for (restart in restarts) {
[13:36:56.347]                             name <- restart$name
[13:36:56.347]                             if (is.null(name)) 
[13:36:56.347]                               next
[13:36:56.347]                             if (!grepl(pattern, name)) 
[13:36:56.347]                               next
[13:36:56.347]                             invokeRestart(restart)
[13:36:56.347]                             muffled <- TRUE
[13:36:56.347]                             break
[13:36:56.347]                           }
[13:36:56.347]                         }
[13:36:56.347]                       }
[13:36:56.347]                       invisible(muffled)
[13:36:56.347]                     }
[13:36:56.347]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.347]                   }
[13:36:56.347]                 }
[13:36:56.347]                 else {
[13:36:56.347]                   if (TRUE) {
[13:36:56.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.347]                     {
[13:36:56.347]                       inherits <- base::inherits
[13:36:56.347]                       invokeRestart <- base::invokeRestart
[13:36:56.347]                       is.null <- base::is.null
[13:36:56.347]                       muffled <- FALSE
[13:36:56.347]                       if (inherits(cond, "message")) {
[13:36:56.347]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.347]                         if (muffled) 
[13:36:56.347]                           invokeRestart("muffleMessage")
[13:36:56.347]                       }
[13:36:56.347]                       else if (inherits(cond, "warning")) {
[13:36:56.347]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.347]                         if (muffled) 
[13:36:56.347]                           invokeRestart("muffleWarning")
[13:36:56.347]                       }
[13:36:56.347]                       else if (inherits(cond, "condition")) {
[13:36:56.347]                         if (!is.null(pattern)) {
[13:36:56.347]                           computeRestarts <- base::computeRestarts
[13:36:56.347]                           grepl <- base::grepl
[13:36:56.347]                           restarts <- computeRestarts(cond)
[13:36:56.347]                           for (restart in restarts) {
[13:36:56.347]                             name <- restart$name
[13:36:56.347]                             if (is.null(name)) 
[13:36:56.347]                               next
[13:36:56.347]                             if (!grepl(pattern, name)) 
[13:36:56.347]                               next
[13:36:56.347]                             invokeRestart(restart)
[13:36:56.347]                             muffled <- TRUE
[13:36:56.347]                             break
[13:36:56.347]                           }
[13:36:56.347]                         }
[13:36:56.347]                       }
[13:36:56.347]                       invisible(muffled)
[13:36:56.347]                     }
[13:36:56.347]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.347]                   }
[13:36:56.347]                 }
[13:36:56.347]             }
[13:36:56.347]         }))
[13:36:56.347]     }, error = function(ex) {
[13:36:56.347]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.347]                 ...future.rng), started = ...future.startTime, 
[13:36:56.347]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.347]             version = "1.8"), class = "FutureResult")
[13:36:56.347]     }, finally = {
[13:36:56.347]         if (!identical(...future.workdir, getwd())) 
[13:36:56.347]             setwd(...future.workdir)
[13:36:56.347]         {
[13:36:56.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.347]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.347]             }
[13:36:56.347]             base::options(...future.oldOptions)
[13:36:56.347]             if (.Platform$OS.type == "windows") {
[13:36:56.347]                 old_names <- names(...future.oldEnvVars)
[13:36:56.347]                 envs <- base::Sys.getenv()
[13:36:56.347]                 names <- names(envs)
[13:36:56.347]                 common <- intersect(names, old_names)
[13:36:56.347]                 added <- setdiff(names, old_names)
[13:36:56.347]                 removed <- setdiff(old_names, names)
[13:36:56.347]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.347]                   envs[common]]
[13:36:56.347]                 NAMES <- toupper(changed)
[13:36:56.347]                 args <- list()
[13:36:56.347]                 for (kk in seq_along(NAMES)) {
[13:36:56.347]                   name <- changed[[kk]]
[13:36:56.347]                   NAME <- NAMES[[kk]]
[13:36:56.347]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.347]                     next
[13:36:56.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.347]                 }
[13:36:56.347]                 NAMES <- toupper(added)
[13:36:56.347]                 for (kk in seq_along(NAMES)) {
[13:36:56.347]                   name <- added[[kk]]
[13:36:56.347]                   NAME <- NAMES[[kk]]
[13:36:56.347]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.347]                     next
[13:36:56.347]                   args[[name]] <- ""
[13:36:56.347]                 }
[13:36:56.347]                 NAMES <- toupper(removed)
[13:36:56.347]                 for (kk in seq_along(NAMES)) {
[13:36:56.347]                   name <- removed[[kk]]
[13:36:56.347]                   NAME <- NAMES[[kk]]
[13:36:56.347]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.347]                     next
[13:36:56.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.347]                 }
[13:36:56.347]                 if (length(args) > 0) 
[13:36:56.347]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.347]             }
[13:36:56.347]             else {
[13:36:56.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.347]             }
[13:36:56.347]             {
[13:36:56.347]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.347]                   0L) {
[13:36:56.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.347]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.347]                   base::options(opts)
[13:36:56.347]                 }
[13:36:56.347]                 {
[13:36:56.347]                   {
[13:36:56.347]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.347]                     NULL
[13:36:56.347]                   }
[13:36:56.347]                   options(future.plan = NULL)
[13:36:56.347]                   if (is.na(NA_character_)) 
[13:36:56.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.347]                     .init = FALSE)
[13:36:56.347]                 }
[13:36:56.347]             }
[13:36:56.347]         }
[13:36:56.347]     })
[13:36:56.347]     if (TRUE) {
[13:36:56.347]         base::sink(type = "output", split = FALSE)
[13:36:56.347]         if (TRUE) {
[13:36:56.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.347]         }
[13:36:56.347]         else {
[13:36:56.347]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.347]         }
[13:36:56.347]         base::close(...future.stdout)
[13:36:56.347]         ...future.stdout <- NULL
[13:36:56.347]     }
[13:36:56.347]     ...future.result$conditions <- ...future.conditions
[13:36:56.347]     ...future.result$finished <- base::Sys.time()
[13:36:56.347]     ...future.result
[13:36:56.347] }
[13:36:56.349] assign_globals() ...
[13:36:56.350] List of 1
[13:36:56.350]  $ ii: int 1
[13:36:56.350]  - attr(*, "where")=List of 1
[13:36:56.350]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.350]  - attr(*, "resolved")= logi TRUE
[13:36:56.350]  - attr(*, "total_size")= num 56
[13:36:56.350]  - attr(*, "already-done")= logi TRUE
[13:36:56.352] - copied ‘ii’ to environment
[13:36:56.352] assign_globals() ... done
[13:36:56.352] requestCore(): workers = 2
[13:36:56.354] MulticoreFuture started
[13:36:56.355] - Launch lazy future ... done
[13:36:56.355] run() for ‘MulticoreFuture’ ... done
[13:36:56.356] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.356] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.356] List of future strategies:
[13:36:56.356] 1. sequential:
[13:36:56.356]    - args: function (..., envir = parent.frame())
[13:36:56.356]    - tweaked: FALSE
[13:36:56.356]    - call: NULL
[13:36:56.357] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.357] plan(): nbrOfWorkers() = 1
[13:36:56.359] plan(): Setting new future strategy stack:
[13:36:56.359] List of future strategies:
[13:36:56.359] 1. multicore:
[13:36:56.359]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.359]    - tweaked: FALSE
[13:36:56.359]    - call: plan(strategy)
[13:36:56.359] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.359] Searching for globals ... DONE
[13:36:56.360] Resolving globals: TRUE
[13:36:56.360] Resolving any globals that are futures ...
[13:36:56.360] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.360] Resolving any globals that are futures ... DONE
[13:36:56.361] Resolving futures part of globals (recursively) ...
[13:36:56.361] resolve() on list ...
[13:36:56.362]  recursive: 99
[13:36:56.362]  length: 1
[13:36:56.362]  elements: ‘ii’
[13:36:56.362]  length: 0 (resolved future 1)
[13:36:56.362] resolve() on list ... DONE
[13:36:56.362] - globals: [1] ‘ii’
[13:36:56.363] Resolving futures part of globals (recursively) ... DONE
[13:36:56.363] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:56.363] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.364] plan(): nbrOfWorkers() = 2
[13:36:56.364] - globals: [1] ‘ii’
[13:36:56.364] 
[13:36:56.364] getGlobalsAndPackages() ... DONE
[13:36:56.368] run() for ‘Future’ ...
[13:36:56.368] - state: ‘created’
[13:36:56.369] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.375] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.375]   - Field: ‘label’
[13:36:56.375]   - Field: ‘local’
[13:36:56.375]   - Field: ‘owner’
[13:36:56.376]   - Field: ‘envir’
[13:36:56.376]   - Field: ‘workers’
[13:36:56.376]   - Field: ‘packages’
[13:36:56.376]   - Field: ‘gc’
[13:36:56.376]   - Field: ‘job’
[13:36:56.376]   - Field: ‘conditions’
[13:36:56.377]   - Field: ‘expr’
[13:36:56.377]   - Field: ‘uuid’
[13:36:56.377]   - Field: ‘seed’
[13:36:56.377]   - Field: ‘version’
[13:36:56.377]   - Field: ‘result’
[13:36:56.377]   - Field: ‘asynchronous’
[13:36:56.378]   - Field: ‘calls’
[13:36:56.378]   - Field: ‘globals’
[13:36:56.378]   - Field: ‘stdout’
[13:36:56.378]   - Field: ‘earlySignal’
[13:36:56.378]   - Field: ‘lazy’
[13:36:56.379]   - Field: ‘state’
[13:36:56.379] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.379] - Launch lazy future ...
[13:36:56.379] Packages needed by the future expression (n = 0): <none>
[13:36:56.380] Packages needed by future strategies (n = 0): <none>
[13:36:56.380] {
[13:36:56.380]     {
[13:36:56.380]         {
[13:36:56.380]             ...future.startTime <- base::Sys.time()
[13:36:56.380]             {
[13:36:56.380]                 {
[13:36:56.380]                   {
[13:36:56.380]                     {
[13:36:56.380]                       base::local({
[13:36:56.380]                         has_future <- base::requireNamespace("future", 
[13:36:56.380]                           quietly = TRUE)
[13:36:56.380]                         if (has_future) {
[13:36:56.380]                           ns <- base::getNamespace("future")
[13:36:56.380]                           version <- ns[[".package"]][["version"]]
[13:36:56.380]                           if (is.null(version)) 
[13:36:56.380]                             version <- utils::packageVersion("future")
[13:36:56.380]                         }
[13:36:56.380]                         else {
[13:36:56.380]                           version <- NULL
[13:36:56.380]                         }
[13:36:56.380]                         if (!has_future || version < "1.8.0") {
[13:36:56.380]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.380]                             "", base::R.version$version.string), 
[13:36:56.380]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.380]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.380]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.380]                               "release", "version")], collapse = " "), 
[13:36:56.380]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.380]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.380]                             info)
[13:36:56.380]                           info <- base::paste(info, collapse = "; ")
[13:36:56.380]                           if (!has_future) {
[13:36:56.380]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.380]                               info)
[13:36:56.380]                           }
[13:36:56.380]                           else {
[13:36:56.380]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.380]                               info, version)
[13:36:56.380]                           }
[13:36:56.380]                           base::stop(msg)
[13:36:56.380]                         }
[13:36:56.380]                       })
[13:36:56.380]                     }
[13:36:56.380]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.380]                     base::options(mc.cores = 1L)
[13:36:56.380]                   }
[13:36:56.380]                   ...future.strategy.old <- future::plan("list")
[13:36:56.380]                   options(future.plan = NULL)
[13:36:56.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.380]                 }
[13:36:56.380]                 ...future.workdir <- getwd()
[13:36:56.380]             }
[13:36:56.380]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.380]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.380]         }
[13:36:56.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.380]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.380]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.380]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.380]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.380]             base::names(...future.oldOptions))
[13:36:56.380]     }
[13:36:56.380]     if (FALSE) {
[13:36:56.380]     }
[13:36:56.380]     else {
[13:36:56.380]         if (TRUE) {
[13:36:56.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.380]                 open = "w")
[13:36:56.380]         }
[13:36:56.380]         else {
[13:36:56.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.380]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.380]         }
[13:36:56.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.380]             base::sink(type = "output", split = FALSE)
[13:36:56.380]             base::close(...future.stdout)
[13:36:56.380]         }, add = TRUE)
[13:36:56.380]     }
[13:36:56.380]     ...future.frame <- base::sys.nframe()
[13:36:56.380]     ...future.conditions <- base::list()
[13:36:56.380]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.380]     if (FALSE) {
[13:36:56.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.380]     }
[13:36:56.380]     ...future.result <- base::tryCatch({
[13:36:56.380]         base::withCallingHandlers({
[13:36:56.380]             ...future.value <- base::withVisible(base::local({
[13:36:56.380]                 withCallingHandlers({
[13:36:56.380]                   {
[13:36:56.380]                     b <- a * ii
[13:36:56.380]                     a <- 0
[13:36:56.380]                     b
[13:36:56.380]                   }
[13:36:56.380]                 }, immediateCondition = function(cond) {
[13:36:56.380]                   save_rds <- function (object, pathname, ...) 
[13:36:56.380]                   {
[13:36:56.380]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.380]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.380]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.380]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.380]                         fi_tmp[["mtime"]])
[13:36:56.380]                     }
[13:36:56.380]                     tryCatch({
[13:36:56.380]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.380]                     }, error = function(ex) {
[13:36:56.380]                       msg <- conditionMessage(ex)
[13:36:56.380]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.380]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.380]                         fi_tmp[["mtime"]], msg)
[13:36:56.380]                       ex$message <- msg
[13:36:56.380]                       stop(ex)
[13:36:56.380]                     })
[13:36:56.380]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.380]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.380]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.380]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.380]                       fi <- file.info(pathname)
[13:36:56.380]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.380]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.380]                         fi[["size"]], fi[["mtime"]])
[13:36:56.380]                       stop(msg)
[13:36:56.380]                     }
[13:36:56.380]                     invisible(pathname)
[13:36:56.380]                   }
[13:36:56.380]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.380]                     rootPath = tempdir()) 
[13:36:56.380]                   {
[13:36:56.380]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.380]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.380]                       tmpdir = path, fileext = ".rds")
[13:36:56.380]                     save_rds(obj, file)
[13:36:56.380]                   }
[13:36:56.380]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.380]                   {
[13:36:56.380]                     inherits <- base::inherits
[13:36:56.380]                     invokeRestart <- base::invokeRestart
[13:36:56.380]                     is.null <- base::is.null
[13:36:56.380]                     muffled <- FALSE
[13:36:56.380]                     if (inherits(cond, "message")) {
[13:36:56.380]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.380]                       if (muffled) 
[13:36:56.380]                         invokeRestart("muffleMessage")
[13:36:56.380]                     }
[13:36:56.380]                     else if (inherits(cond, "warning")) {
[13:36:56.380]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.380]                       if (muffled) 
[13:36:56.380]                         invokeRestart("muffleWarning")
[13:36:56.380]                     }
[13:36:56.380]                     else if (inherits(cond, "condition")) {
[13:36:56.380]                       if (!is.null(pattern)) {
[13:36:56.380]                         computeRestarts <- base::computeRestarts
[13:36:56.380]                         grepl <- base::grepl
[13:36:56.380]                         restarts <- computeRestarts(cond)
[13:36:56.380]                         for (restart in restarts) {
[13:36:56.380]                           name <- restart$name
[13:36:56.380]                           if (is.null(name)) 
[13:36:56.380]                             next
[13:36:56.380]                           if (!grepl(pattern, name)) 
[13:36:56.380]                             next
[13:36:56.380]                           invokeRestart(restart)
[13:36:56.380]                           muffled <- TRUE
[13:36:56.380]                           break
[13:36:56.380]                         }
[13:36:56.380]                       }
[13:36:56.380]                     }
[13:36:56.380]                     invisible(muffled)
[13:36:56.380]                   }
[13:36:56.380]                   muffleCondition(cond)
[13:36:56.380]                 })
[13:36:56.380]             }))
[13:36:56.380]             future::FutureResult(value = ...future.value$value, 
[13:36:56.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.380]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.380]                     ...future.globalenv.names))
[13:36:56.380]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.380]         }, condition = base::local({
[13:36:56.380]             c <- base::c
[13:36:56.380]             inherits <- base::inherits
[13:36:56.380]             invokeRestart <- base::invokeRestart
[13:36:56.380]             length <- base::length
[13:36:56.380]             list <- base::list
[13:36:56.380]             seq.int <- base::seq.int
[13:36:56.380]             signalCondition <- base::signalCondition
[13:36:56.380]             sys.calls <- base::sys.calls
[13:36:56.380]             `[[` <- base::`[[`
[13:36:56.380]             `+` <- base::`+`
[13:36:56.380]             `<<-` <- base::`<<-`
[13:36:56.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.380]                   3L)]
[13:36:56.380]             }
[13:36:56.380]             function(cond) {
[13:36:56.380]                 is_error <- inherits(cond, "error")
[13:36:56.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.380]                   NULL)
[13:36:56.380]                 if (is_error) {
[13:36:56.380]                   sessionInformation <- function() {
[13:36:56.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.380]                       search = base::search(), system = base::Sys.info())
[13:36:56.380]                   }
[13:36:56.380]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.380]                     cond$call), session = sessionInformation(), 
[13:36:56.380]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.380]                   signalCondition(cond)
[13:36:56.380]                 }
[13:36:56.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.380]                 "immediateCondition"))) {
[13:36:56.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.380]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.380]                   if (TRUE && !signal) {
[13:36:56.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.380]                     {
[13:36:56.380]                       inherits <- base::inherits
[13:36:56.380]                       invokeRestart <- base::invokeRestart
[13:36:56.380]                       is.null <- base::is.null
[13:36:56.380]                       muffled <- FALSE
[13:36:56.380]                       if (inherits(cond, "message")) {
[13:36:56.380]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.380]                         if (muffled) 
[13:36:56.380]                           invokeRestart("muffleMessage")
[13:36:56.380]                       }
[13:36:56.380]                       else if (inherits(cond, "warning")) {
[13:36:56.380]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.380]                         if (muffled) 
[13:36:56.380]                           invokeRestart("muffleWarning")
[13:36:56.380]                       }
[13:36:56.380]                       else if (inherits(cond, "condition")) {
[13:36:56.380]                         if (!is.null(pattern)) {
[13:36:56.380]                           computeRestarts <- base::computeRestarts
[13:36:56.380]                           grepl <- base::grepl
[13:36:56.380]                           restarts <- computeRestarts(cond)
[13:36:56.380]                           for (restart in restarts) {
[13:36:56.380]                             name <- restart$name
[13:36:56.380]                             if (is.null(name)) 
[13:36:56.380]                               next
[13:36:56.380]                             if (!grepl(pattern, name)) 
[13:36:56.380]                               next
[13:36:56.380]                             invokeRestart(restart)
[13:36:56.380]                             muffled <- TRUE
[13:36:56.380]                             break
[13:36:56.380]                           }
[13:36:56.380]                         }
[13:36:56.380]                       }
[13:36:56.380]                       invisible(muffled)
[13:36:56.380]                     }
[13:36:56.380]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.380]                   }
[13:36:56.380]                 }
[13:36:56.380]                 else {
[13:36:56.380]                   if (TRUE) {
[13:36:56.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.380]                     {
[13:36:56.380]                       inherits <- base::inherits
[13:36:56.380]                       invokeRestart <- base::invokeRestart
[13:36:56.380]                       is.null <- base::is.null
[13:36:56.380]                       muffled <- FALSE
[13:36:56.380]                       if (inherits(cond, "message")) {
[13:36:56.380]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.380]                         if (muffled) 
[13:36:56.380]                           invokeRestart("muffleMessage")
[13:36:56.380]                       }
[13:36:56.380]                       else if (inherits(cond, "warning")) {
[13:36:56.380]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.380]                         if (muffled) 
[13:36:56.380]                           invokeRestart("muffleWarning")
[13:36:56.380]                       }
[13:36:56.380]                       else if (inherits(cond, "condition")) {
[13:36:56.380]                         if (!is.null(pattern)) {
[13:36:56.380]                           computeRestarts <- base::computeRestarts
[13:36:56.380]                           grepl <- base::grepl
[13:36:56.380]                           restarts <- computeRestarts(cond)
[13:36:56.380]                           for (restart in restarts) {
[13:36:56.380]                             name <- restart$name
[13:36:56.380]                             if (is.null(name)) 
[13:36:56.380]                               next
[13:36:56.380]                             if (!grepl(pattern, name)) 
[13:36:56.380]                               next
[13:36:56.380]                             invokeRestart(restart)
[13:36:56.380]                             muffled <- TRUE
[13:36:56.380]                             break
[13:36:56.380]                           }
[13:36:56.380]                         }
[13:36:56.380]                       }
[13:36:56.380]                       invisible(muffled)
[13:36:56.380]                     }
[13:36:56.380]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.380]                   }
[13:36:56.380]                 }
[13:36:56.380]             }
[13:36:56.380]         }))
[13:36:56.380]     }, error = function(ex) {
[13:36:56.380]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.380]                 ...future.rng), started = ...future.startTime, 
[13:36:56.380]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.380]             version = "1.8"), class = "FutureResult")
[13:36:56.380]     }, finally = {
[13:36:56.380]         if (!identical(...future.workdir, getwd())) 
[13:36:56.380]             setwd(...future.workdir)
[13:36:56.380]         {
[13:36:56.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.380]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.380]             }
[13:36:56.380]             base::options(...future.oldOptions)
[13:36:56.380]             if (.Platform$OS.type == "windows") {
[13:36:56.380]                 old_names <- names(...future.oldEnvVars)
[13:36:56.380]                 envs <- base::Sys.getenv()
[13:36:56.380]                 names <- names(envs)
[13:36:56.380]                 common <- intersect(names, old_names)
[13:36:56.380]                 added <- setdiff(names, old_names)
[13:36:56.380]                 removed <- setdiff(old_names, names)
[13:36:56.380]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.380]                   envs[common]]
[13:36:56.380]                 NAMES <- toupper(changed)
[13:36:56.380]                 args <- list()
[13:36:56.380]                 for (kk in seq_along(NAMES)) {
[13:36:56.380]                   name <- changed[[kk]]
[13:36:56.380]                   NAME <- NAMES[[kk]]
[13:36:56.380]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.380]                     next
[13:36:56.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.380]                 }
[13:36:56.380]                 NAMES <- toupper(added)
[13:36:56.380]                 for (kk in seq_along(NAMES)) {
[13:36:56.380]                   name <- added[[kk]]
[13:36:56.380]                   NAME <- NAMES[[kk]]
[13:36:56.380]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.380]                     next
[13:36:56.380]                   args[[name]] <- ""
[13:36:56.380]                 }
[13:36:56.380]                 NAMES <- toupper(removed)
[13:36:56.380]                 for (kk in seq_along(NAMES)) {
[13:36:56.380]                   name <- removed[[kk]]
[13:36:56.380]                   NAME <- NAMES[[kk]]
[13:36:56.380]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.380]                     next
[13:36:56.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.380]                 }
[13:36:56.380]                 if (length(args) > 0) 
[13:36:56.380]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.380]             }
[13:36:56.380]             else {
[13:36:56.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.380]             }
[13:36:56.380]             {
[13:36:56.380]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.380]                   0L) {
[13:36:56.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.380]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.380]                   base::options(opts)
[13:36:56.380]                 }
[13:36:56.380]                 {
[13:36:56.380]                   {
[13:36:56.380]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.380]                     NULL
[13:36:56.380]                   }
[13:36:56.380]                   options(future.plan = NULL)
[13:36:56.380]                   if (is.na(NA_character_)) 
[13:36:56.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.380]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.380]                     .init = FALSE)
[13:36:56.380]                 }
[13:36:56.380]             }
[13:36:56.380]         }
[13:36:56.380]     })
[13:36:56.380]     if (TRUE) {
[13:36:56.380]         base::sink(type = "output", split = FALSE)
[13:36:56.380]         if (TRUE) {
[13:36:56.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.380]         }
[13:36:56.380]         else {
[13:36:56.380]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.380]         }
[13:36:56.380]         base::close(...future.stdout)
[13:36:56.380]         ...future.stdout <- NULL
[13:36:56.380]     }
[13:36:56.380]     ...future.result$conditions <- ...future.conditions
[13:36:56.380]     ...future.result$finished <- base::Sys.time()
[13:36:56.380]     ...future.result
[13:36:56.380] }
[13:36:56.383] assign_globals() ...
[13:36:56.383] List of 1
[13:36:56.383]  $ ii: int 2
[13:36:56.383]  - attr(*, "where")=List of 1
[13:36:56.383]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.383]  - attr(*, "resolved")= logi TRUE
[13:36:56.383]  - attr(*, "total_size")= num 56
[13:36:56.383]  - attr(*, "already-done")= logi TRUE
[13:36:56.387] - copied ‘ii’ to environment
[13:36:56.387] assign_globals() ... done
[13:36:56.387] requestCore(): workers = 2
[13:36:56.389] MulticoreFuture started
[13:36:56.390] - Launch lazy future ... done
[13:36:56.390] run() for ‘MulticoreFuture’ ... done
[13:36:56.391] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.391] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.391] List of future strategies:
[13:36:56.391] 1. sequential:
[13:36:56.391]    - args: function (..., envir = parent.frame())
[13:36:56.391]    - tweaked: FALSE
[13:36:56.391]    - call: NULL
[13:36:56.392] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.392] plan(): nbrOfWorkers() = 1
[13:36:56.394] plan(): Setting new future strategy stack:
[13:36:56.394] List of future strategies:
[13:36:56.394] 1. multicore:
[13:36:56.394]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.394]    - tweaked: FALSE
[13:36:56.394]    - call: plan(strategy)
[13:36:56.395] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.395] Searching for globals ... DONE
[13:36:56.395] Resolving globals: TRUE
[13:36:56.395] Resolving any globals that are futures ...
[13:36:56.395] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.395] Resolving any globals that are futures ... DONE
[13:36:56.396] Resolving futures part of globals (recursively) ...
[13:36:56.397] resolve() on list ...
[13:36:56.397]  recursive: 99
[13:36:56.397]  length: 1
[13:36:56.397]  elements: ‘ii’
[13:36:56.397]  length: 0 (resolved future 1)
[13:36:56.398] resolve() on list ... DONE
[13:36:56.398] - globals: [1] ‘ii’
[13:36:56.398] Resolving futures part of globals (recursively) ... DONE
[13:36:56.398] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:56.399] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.399] - globals: [1] ‘ii’
[13:36:56.399] 
[13:36:56.399] plan(): nbrOfWorkers() = 2
[13:36:56.399] getGlobalsAndPackages() ... DONE
[13:36:56.400] run() for ‘Future’ ...
[13:36:56.400] - state: ‘created’
[13:36:56.400] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.405] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.405] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.405]   - Field: ‘label’
[13:36:56.405]   - Field: ‘local’
[13:36:56.405]   - Field: ‘owner’
[13:36:56.405]   - Field: ‘envir’
[13:36:56.406]   - Field: ‘workers’
[13:36:56.406]   - Field: ‘packages’
[13:36:56.406]   - Field: ‘gc’
[13:36:56.406]   - Field: ‘job’
[13:36:56.406]   - Field: ‘conditions’
[13:36:56.406]   - Field: ‘expr’
[13:36:56.407]   - Field: ‘uuid’
[13:36:56.407]   - Field: ‘seed’
[13:36:56.407]   - Field: ‘version’
[13:36:56.407]   - Field: ‘result’
[13:36:56.407]   - Field: ‘asynchronous’
[13:36:56.407]   - Field: ‘calls’
[13:36:56.407]   - Field: ‘globals’
[13:36:56.407]   - Field: ‘stdout’
[13:36:56.408]   - Field: ‘earlySignal’
[13:36:56.408]   - Field: ‘lazy’
[13:36:56.408]   - Field: ‘state’
[13:36:56.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.408] - Launch lazy future ...
[13:36:56.409] Packages needed by the future expression (n = 0): <none>
[13:36:56.409] Packages needed by future strategies (n = 0): <none>
[13:36:56.409] {
[13:36:56.409]     {
[13:36:56.409]         {
[13:36:56.409]             ...future.startTime <- base::Sys.time()
[13:36:56.409]             {
[13:36:56.409]                 {
[13:36:56.409]                   {
[13:36:56.409]                     {
[13:36:56.409]                       base::local({
[13:36:56.409]                         has_future <- base::requireNamespace("future", 
[13:36:56.409]                           quietly = TRUE)
[13:36:56.409]                         if (has_future) {
[13:36:56.409]                           ns <- base::getNamespace("future")
[13:36:56.409]                           version <- ns[[".package"]][["version"]]
[13:36:56.409]                           if (is.null(version)) 
[13:36:56.409]                             version <- utils::packageVersion("future")
[13:36:56.409]                         }
[13:36:56.409]                         else {
[13:36:56.409]                           version <- NULL
[13:36:56.409]                         }
[13:36:56.409]                         if (!has_future || version < "1.8.0") {
[13:36:56.409]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.409]                             "", base::R.version$version.string), 
[13:36:56.409]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.409]                               "release", "version")], collapse = " "), 
[13:36:56.409]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.409]                             info)
[13:36:56.409]                           info <- base::paste(info, collapse = "; ")
[13:36:56.409]                           if (!has_future) {
[13:36:56.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.409]                               info)
[13:36:56.409]                           }
[13:36:56.409]                           else {
[13:36:56.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.409]                               info, version)
[13:36:56.409]                           }
[13:36:56.409]                           base::stop(msg)
[13:36:56.409]                         }
[13:36:56.409]                       })
[13:36:56.409]                     }
[13:36:56.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.409]                     base::options(mc.cores = 1L)
[13:36:56.409]                   }
[13:36:56.409]                   ...future.strategy.old <- future::plan("list")
[13:36:56.409]                   options(future.plan = NULL)
[13:36:56.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.409]                 }
[13:36:56.409]                 ...future.workdir <- getwd()
[13:36:56.409]             }
[13:36:56.409]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.409]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.409]         }
[13:36:56.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.409]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.409]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.409]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.409]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.409]             base::names(...future.oldOptions))
[13:36:56.409]     }
[13:36:56.409]     if (FALSE) {
[13:36:56.409]     }
[13:36:56.409]     else {
[13:36:56.409]         if (TRUE) {
[13:36:56.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.409]                 open = "w")
[13:36:56.409]         }
[13:36:56.409]         else {
[13:36:56.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.409]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.409]         }
[13:36:56.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.409]             base::sink(type = "output", split = FALSE)
[13:36:56.409]             base::close(...future.stdout)
[13:36:56.409]         }, add = TRUE)
[13:36:56.409]     }
[13:36:56.409]     ...future.frame <- base::sys.nframe()
[13:36:56.409]     ...future.conditions <- base::list()
[13:36:56.409]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.409]     if (FALSE) {
[13:36:56.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.409]     }
[13:36:56.409]     ...future.result <- base::tryCatch({
[13:36:56.409]         base::withCallingHandlers({
[13:36:56.409]             ...future.value <- base::withVisible(base::local({
[13:36:56.409]                 withCallingHandlers({
[13:36:56.409]                   {
[13:36:56.409]                     b <- a * ii
[13:36:56.409]                     a <- 0
[13:36:56.409]                     b
[13:36:56.409]                   }
[13:36:56.409]                 }, immediateCondition = function(cond) {
[13:36:56.409]                   save_rds <- function (object, pathname, ...) 
[13:36:56.409]                   {
[13:36:56.409]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.409]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.409]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.409]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.409]                         fi_tmp[["mtime"]])
[13:36:56.409]                     }
[13:36:56.409]                     tryCatch({
[13:36:56.409]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.409]                     }, error = function(ex) {
[13:36:56.409]                       msg <- conditionMessage(ex)
[13:36:56.409]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.409]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.409]                         fi_tmp[["mtime"]], msg)
[13:36:56.409]                       ex$message <- msg
[13:36:56.409]                       stop(ex)
[13:36:56.409]                     })
[13:36:56.409]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.409]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.409]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.409]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.409]                       fi <- file.info(pathname)
[13:36:56.409]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.409]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.409]                         fi[["size"]], fi[["mtime"]])
[13:36:56.409]                       stop(msg)
[13:36:56.409]                     }
[13:36:56.409]                     invisible(pathname)
[13:36:56.409]                   }
[13:36:56.409]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.409]                     rootPath = tempdir()) 
[13:36:56.409]                   {
[13:36:56.409]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.409]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.409]                       tmpdir = path, fileext = ".rds")
[13:36:56.409]                     save_rds(obj, file)
[13:36:56.409]                   }
[13:36:56.409]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.409]                   {
[13:36:56.409]                     inherits <- base::inherits
[13:36:56.409]                     invokeRestart <- base::invokeRestart
[13:36:56.409]                     is.null <- base::is.null
[13:36:56.409]                     muffled <- FALSE
[13:36:56.409]                     if (inherits(cond, "message")) {
[13:36:56.409]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.409]                       if (muffled) 
[13:36:56.409]                         invokeRestart("muffleMessage")
[13:36:56.409]                     }
[13:36:56.409]                     else if (inherits(cond, "warning")) {
[13:36:56.409]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.409]                       if (muffled) 
[13:36:56.409]                         invokeRestart("muffleWarning")
[13:36:56.409]                     }
[13:36:56.409]                     else if (inherits(cond, "condition")) {
[13:36:56.409]                       if (!is.null(pattern)) {
[13:36:56.409]                         computeRestarts <- base::computeRestarts
[13:36:56.409]                         grepl <- base::grepl
[13:36:56.409]                         restarts <- computeRestarts(cond)
[13:36:56.409]                         for (restart in restarts) {
[13:36:56.409]                           name <- restart$name
[13:36:56.409]                           if (is.null(name)) 
[13:36:56.409]                             next
[13:36:56.409]                           if (!grepl(pattern, name)) 
[13:36:56.409]                             next
[13:36:56.409]                           invokeRestart(restart)
[13:36:56.409]                           muffled <- TRUE
[13:36:56.409]                           break
[13:36:56.409]                         }
[13:36:56.409]                       }
[13:36:56.409]                     }
[13:36:56.409]                     invisible(muffled)
[13:36:56.409]                   }
[13:36:56.409]                   muffleCondition(cond)
[13:36:56.409]                 })
[13:36:56.409]             }))
[13:36:56.409]             future::FutureResult(value = ...future.value$value, 
[13:36:56.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.409]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.409]                     ...future.globalenv.names))
[13:36:56.409]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.409]         }, condition = base::local({
[13:36:56.409]             c <- base::c
[13:36:56.409]             inherits <- base::inherits
[13:36:56.409]             invokeRestart <- base::invokeRestart
[13:36:56.409]             length <- base::length
[13:36:56.409]             list <- base::list
[13:36:56.409]             seq.int <- base::seq.int
[13:36:56.409]             signalCondition <- base::signalCondition
[13:36:56.409]             sys.calls <- base::sys.calls
[13:36:56.409]             `[[` <- base::`[[`
[13:36:56.409]             `+` <- base::`+`
[13:36:56.409]             `<<-` <- base::`<<-`
[13:36:56.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.409]                   3L)]
[13:36:56.409]             }
[13:36:56.409]             function(cond) {
[13:36:56.409]                 is_error <- inherits(cond, "error")
[13:36:56.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.409]                   NULL)
[13:36:56.409]                 if (is_error) {
[13:36:56.409]                   sessionInformation <- function() {
[13:36:56.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.409]                       search = base::search(), system = base::Sys.info())
[13:36:56.409]                   }
[13:36:56.409]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.409]                     cond$call), session = sessionInformation(), 
[13:36:56.409]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.409]                   signalCondition(cond)
[13:36:56.409]                 }
[13:36:56.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.409]                 "immediateCondition"))) {
[13:36:56.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.409]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.409]                   if (TRUE && !signal) {
[13:36:56.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.409]                     {
[13:36:56.409]                       inherits <- base::inherits
[13:36:56.409]                       invokeRestart <- base::invokeRestart
[13:36:56.409]                       is.null <- base::is.null
[13:36:56.409]                       muffled <- FALSE
[13:36:56.409]                       if (inherits(cond, "message")) {
[13:36:56.409]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.409]                         if (muffled) 
[13:36:56.409]                           invokeRestart("muffleMessage")
[13:36:56.409]                       }
[13:36:56.409]                       else if (inherits(cond, "warning")) {
[13:36:56.409]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.409]                         if (muffled) 
[13:36:56.409]                           invokeRestart("muffleWarning")
[13:36:56.409]                       }
[13:36:56.409]                       else if (inherits(cond, "condition")) {
[13:36:56.409]                         if (!is.null(pattern)) {
[13:36:56.409]                           computeRestarts <- base::computeRestarts
[13:36:56.409]                           grepl <- base::grepl
[13:36:56.409]                           restarts <- computeRestarts(cond)
[13:36:56.409]                           for (restart in restarts) {
[13:36:56.409]                             name <- restart$name
[13:36:56.409]                             if (is.null(name)) 
[13:36:56.409]                               next
[13:36:56.409]                             if (!grepl(pattern, name)) 
[13:36:56.409]                               next
[13:36:56.409]                             invokeRestart(restart)
[13:36:56.409]                             muffled <- TRUE
[13:36:56.409]                             break
[13:36:56.409]                           }
[13:36:56.409]                         }
[13:36:56.409]                       }
[13:36:56.409]                       invisible(muffled)
[13:36:56.409]                     }
[13:36:56.409]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.409]                   }
[13:36:56.409]                 }
[13:36:56.409]                 else {
[13:36:56.409]                   if (TRUE) {
[13:36:56.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.409]                     {
[13:36:56.409]                       inherits <- base::inherits
[13:36:56.409]                       invokeRestart <- base::invokeRestart
[13:36:56.409]                       is.null <- base::is.null
[13:36:56.409]                       muffled <- FALSE
[13:36:56.409]                       if (inherits(cond, "message")) {
[13:36:56.409]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.409]                         if (muffled) 
[13:36:56.409]                           invokeRestart("muffleMessage")
[13:36:56.409]                       }
[13:36:56.409]                       else if (inherits(cond, "warning")) {
[13:36:56.409]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.409]                         if (muffled) 
[13:36:56.409]                           invokeRestart("muffleWarning")
[13:36:56.409]                       }
[13:36:56.409]                       else if (inherits(cond, "condition")) {
[13:36:56.409]                         if (!is.null(pattern)) {
[13:36:56.409]                           computeRestarts <- base::computeRestarts
[13:36:56.409]                           grepl <- base::grepl
[13:36:56.409]                           restarts <- computeRestarts(cond)
[13:36:56.409]                           for (restart in restarts) {
[13:36:56.409]                             name <- restart$name
[13:36:56.409]                             if (is.null(name)) 
[13:36:56.409]                               next
[13:36:56.409]                             if (!grepl(pattern, name)) 
[13:36:56.409]                               next
[13:36:56.409]                             invokeRestart(restart)
[13:36:56.409]                             muffled <- TRUE
[13:36:56.409]                             break
[13:36:56.409]                           }
[13:36:56.409]                         }
[13:36:56.409]                       }
[13:36:56.409]                       invisible(muffled)
[13:36:56.409]                     }
[13:36:56.409]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.409]                   }
[13:36:56.409]                 }
[13:36:56.409]             }
[13:36:56.409]         }))
[13:36:56.409]     }, error = function(ex) {
[13:36:56.409]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.409]                 ...future.rng), started = ...future.startTime, 
[13:36:56.409]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.409]             version = "1.8"), class = "FutureResult")
[13:36:56.409]     }, finally = {
[13:36:56.409]         if (!identical(...future.workdir, getwd())) 
[13:36:56.409]             setwd(...future.workdir)
[13:36:56.409]         {
[13:36:56.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.409]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.409]             }
[13:36:56.409]             base::options(...future.oldOptions)
[13:36:56.409]             if (.Platform$OS.type == "windows") {
[13:36:56.409]                 old_names <- names(...future.oldEnvVars)
[13:36:56.409]                 envs <- base::Sys.getenv()
[13:36:56.409]                 names <- names(envs)
[13:36:56.409]                 common <- intersect(names, old_names)
[13:36:56.409]                 added <- setdiff(names, old_names)
[13:36:56.409]                 removed <- setdiff(old_names, names)
[13:36:56.409]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.409]                   envs[common]]
[13:36:56.409]                 NAMES <- toupper(changed)
[13:36:56.409]                 args <- list()
[13:36:56.409]                 for (kk in seq_along(NAMES)) {
[13:36:56.409]                   name <- changed[[kk]]
[13:36:56.409]                   NAME <- NAMES[[kk]]
[13:36:56.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.409]                     next
[13:36:56.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.409]                 }
[13:36:56.409]                 NAMES <- toupper(added)
[13:36:56.409]                 for (kk in seq_along(NAMES)) {
[13:36:56.409]                   name <- added[[kk]]
[13:36:56.409]                   NAME <- NAMES[[kk]]
[13:36:56.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.409]                     next
[13:36:56.409]                   args[[name]] <- ""
[13:36:56.409]                 }
[13:36:56.409]                 NAMES <- toupper(removed)
[13:36:56.409]                 for (kk in seq_along(NAMES)) {
[13:36:56.409]                   name <- removed[[kk]]
[13:36:56.409]                   NAME <- NAMES[[kk]]
[13:36:56.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.409]                     next
[13:36:56.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.409]                 }
[13:36:56.409]                 if (length(args) > 0) 
[13:36:56.409]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.409]             }
[13:36:56.409]             else {
[13:36:56.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.409]             }
[13:36:56.409]             {
[13:36:56.409]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.409]                   0L) {
[13:36:56.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.409]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.409]                   base::options(opts)
[13:36:56.409]                 }
[13:36:56.409]                 {
[13:36:56.409]                   {
[13:36:56.409]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.409]                     NULL
[13:36:56.409]                   }
[13:36:56.409]                   options(future.plan = NULL)
[13:36:56.409]                   if (is.na(NA_character_)) 
[13:36:56.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.409]                     .init = FALSE)
[13:36:56.409]                 }
[13:36:56.409]             }
[13:36:56.409]         }
[13:36:56.409]     })
[13:36:56.409]     if (TRUE) {
[13:36:56.409]         base::sink(type = "output", split = FALSE)
[13:36:56.409]         if (TRUE) {
[13:36:56.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.409]         }
[13:36:56.409]         else {
[13:36:56.409]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.409]         }
[13:36:56.409]         base::close(...future.stdout)
[13:36:56.409]         ...future.stdout <- NULL
[13:36:56.409]     }
[13:36:56.409]     ...future.result$conditions <- ...future.conditions
[13:36:56.409]     ...future.result$finished <- base::Sys.time()
[13:36:56.409]     ...future.result
[13:36:56.409] }
[13:36:56.413] assign_globals() ...
[13:36:56.413] List of 1
[13:36:56.413]  $ ii: int 3
[13:36:56.413]  - attr(*, "where")=List of 1
[13:36:56.413]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.413]  - attr(*, "resolved")= logi TRUE
[13:36:56.413]  - attr(*, "total_size")= num 56
[13:36:56.413]  - attr(*, "already-done")= logi TRUE
[13:36:56.421] - copied ‘ii’ to environment
[13:36:56.421] assign_globals() ... done
[13:36:56.421] requestCore(): workers = 2
[13:36:56.422] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:56.433] result() for MulticoreFuture ...
[13:36:56.434] result() for MulticoreFuture ...
[13:36:56.434] result() for MulticoreFuture ... done
[13:36:56.435] result() for MulticoreFuture ... done
[13:36:56.435] result() for MulticoreFuture ...
[13:36:56.435] result() for MulticoreFuture ... done
[13:36:56.438] MulticoreFuture started
[13:36:56.438] - Launch lazy future ... done
[13:36:56.439] run() for ‘MulticoreFuture’ ... done
[13:36:56.439] plan(): Setting new future strategy stack:
[13:36:56.440] result() for MulticoreFuture ...
[13:36:56.440] result() for MulticoreFuture ... done
[13:36:56.441] result() for MulticoreFuture ...
[13:36:56.440] List of future strategies:
[13:36:56.440] 1. sequential:
[13:36:56.440]    - args: function (..., envir = parent.frame())
[13:36:56.440]    - tweaked: FALSE
[13:36:56.440]    - call: NULL
[13:36:56.441] result() for MulticoreFuture ... done
[13:36:56.441] plan(): nbrOfWorkers() = 1
[13:36:56.441] result() for MulticoreFuture ...
[13:36:56.444] result() for MulticoreFuture ...
[13:36:56.444] result() for MulticoreFuture ... done
[13:36:56.444] result() for MulticoreFuture ... done
[13:36:56.444] plan(): Setting new future strategy stack:
[13:36:56.445] result() for MulticoreFuture ...
[13:36:56.445] result() for MulticoreFuture ... done
[13:36:56.445] List of future strategies:
[13:36:56.445] 1. multicore:
[13:36:56.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.445]    - tweaked: FALSE
[13:36:56.445]    - call: plan(strategy)
[13:36:56.445] result() for MulticoreFuture ...
[13:36:56.450] plan(): nbrOfWorkers() = 2
[13:36:56.451] result() for MulticoreFuture ...
[13:36:56.451] result() for MulticoreFuture ... done
[13:36:56.451] result() for MulticoreFuture ... done
[13:36:56.452] result() for MulticoreFuture ...
[13:36:56.452] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.453] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.453] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.455] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.455] Searching for globals ... DONE
[13:36:56.455] Resolving globals: TRUE
[13:36:56.455] Resolving any globals that are futures ...
[13:36:56.456] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.456] Resolving any globals that are futures ... DONE
[13:36:56.456] Resolving futures part of globals (recursively) ...
[13:36:56.456] resolve() on list ...
[13:36:56.457]  recursive: 99
[13:36:56.457]  length: 1
[13:36:56.457]  elements: ‘ii’
[13:36:56.457]  length: 0 (resolved future 1)
[13:36:56.457] resolve() on list ... DONE
[13:36:56.457] - globals: [1] ‘ii’
[13:36:56.457] Resolving futures part of globals (recursively) ... DONE
[13:36:56.458] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:56.458] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.458] - globals: [1] ‘ii’
[13:36:56.458] 
[13:36:56.458] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.459] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.459] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.461] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.461] Searching for globals ... DONE
[13:36:56.461] Resolving globals: TRUE
[13:36:56.461] Resolving any globals that are futures ...
[13:36:56.461] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.462] Resolving any globals that are futures ... DONE
[13:36:56.462] Resolving futures part of globals (recursively) ...
[13:36:56.462] resolve() on list ...
[13:36:56.462]  recursive: 99
[13:36:56.463]  length: 1
[13:36:56.463]  elements: ‘ii’
[13:36:56.463]  length: 0 (resolved future 1)
[13:36:56.463] resolve() on list ... DONE
[13:36:56.463] - globals: [1] ‘ii’
[13:36:56.463] Resolving futures part of globals (recursively) ... DONE
[13:36:56.463] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:56.464] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.464] - globals: [1] ‘ii’
[13:36:56.464] 
[13:36:56.464] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.465] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.465] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.466] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.467] Searching for globals ... DONE
[13:36:56.467] Resolving globals: TRUE
[13:36:56.467] Resolving any globals that are futures ...
[13:36:56.467] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:56.467] Resolving any globals that are futures ... DONE
[13:36:56.467] Resolving futures part of globals (recursively) ...
[13:36:56.468] resolve() on list ...
[13:36:56.468]  recursive: 99
[13:36:56.468]  length: 1
[13:36:56.468]  elements: ‘ii’
[13:36:56.468]  length: 0 (resolved future 1)
[13:36:56.468] resolve() on list ... DONE
[13:36:56.468] - globals: [1] ‘ii’
[13:36:56.469] Resolving futures part of globals (recursively) ... DONE
[13:36:56.469] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:56.469] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.469] - globals: [1] ‘ii’
[13:36:56.469] 
[13:36:56.469] getGlobalsAndPackages() ... DONE
[13:36:56.470] run() for ‘Future’ ...
[13:36:56.472] - state: ‘created’
[13:36:56.472] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.477] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.477] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.477]   - Field: ‘label’
[13:36:56.477]   - Field: ‘local’
[13:36:56.477]   - Field: ‘owner’
[13:36:56.477]   - Field: ‘envir’
[13:36:56.477]   - Field: ‘workers’
[13:36:56.478]   - Field: ‘packages’
[13:36:56.478]   - Field: ‘gc’
[13:36:56.478]   - Field: ‘job’
[13:36:56.478]   - Field: ‘conditions’
[13:36:56.478]   - Field: ‘expr’
[13:36:56.478]   - Field: ‘uuid’
[13:36:56.478]   - Field: ‘seed’
[13:36:56.478]   - Field: ‘version’
[13:36:56.478]   - Field: ‘result’
[13:36:56.479]   - Field: ‘asynchronous’
[13:36:56.479]   - Field: ‘calls’
[13:36:56.479]   - Field: ‘globals’
[13:36:56.479]   - Field: ‘stdout’
[13:36:56.479]   - Field: ‘earlySignal’
[13:36:56.479]   - Field: ‘lazy’
[13:36:56.479]   - Field: ‘state’
[13:36:56.479] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.479] - Launch lazy future ...
[13:36:56.480] Packages needed by the future expression (n = 0): <none>
[13:36:56.480] Packages needed by future strategies (n = 0): <none>
[13:36:56.480] {
[13:36:56.480]     {
[13:36:56.480]         {
[13:36:56.480]             ...future.startTime <- base::Sys.time()
[13:36:56.480]             {
[13:36:56.480]                 {
[13:36:56.480]                   {
[13:36:56.480]                     {
[13:36:56.480]                       base::local({
[13:36:56.480]                         has_future <- base::requireNamespace("future", 
[13:36:56.480]                           quietly = TRUE)
[13:36:56.480]                         if (has_future) {
[13:36:56.480]                           ns <- base::getNamespace("future")
[13:36:56.480]                           version <- ns[[".package"]][["version"]]
[13:36:56.480]                           if (is.null(version)) 
[13:36:56.480]                             version <- utils::packageVersion("future")
[13:36:56.480]                         }
[13:36:56.480]                         else {
[13:36:56.480]                           version <- NULL
[13:36:56.480]                         }
[13:36:56.480]                         if (!has_future || version < "1.8.0") {
[13:36:56.480]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.480]                             "", base::R.version$version.string), 
[13:36:56.480]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.480]                               "release", "version")], collapse = " "), 
[13:36:56.480]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.480]                             info)
[13:36:56.480]                           info <- base::paste(info, collapse = "; ")
[13:36:56.480]                           if (!has_future) {
[13:36:56.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.480]                               info)
[13:36:56.480]                           }
[13:36:56.480]                           else {
[13:36:56.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.480]                               info, version)
[13:36:56.480]                           }
[13:36:56.480]                           base::stop(msg)
[13:36:56.480]                         }
[13:36:56.480]                       })
[13:36:56.480]                     }
[13:36:56.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.480]                     base::options(mc.cores = 1L)
[13:36:56.480]                   }
[13:36:56.480]                   ...future.strategy.old <- future::plan("list")
[13:36:56.480]                   options(future.plan = NULL)
[13:36:56.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.480]                 }
[13:36:56.480]                 ...future.workdir <- getwd()
[13:36:56.480]             }
[13:36:56.480]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.480]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.480]         }
[13:36:56.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.480]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.480]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.480]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.480]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.480]             base::names(...future.oldOptions))
[13:36:56.480]     }
[13:36:56.480]     if (FALSE) {
[13:36:56.480]     }
[13:36:56.480]     else {
[13:36:56.480]         if (TRUE) {
[13:36:56.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.480]                 open = "w")
[13:36:56.480]         }
[13:36:56.480]         else {
[13:36:56.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.480]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.480]         }
[13:36:56.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.480]             base::sink(type = "output", split = FALSE)
[13:36:56.480]             base::close(...future.stdout)
[13:36:56.480]         }, add = TRUE)
[13:36:56.480]     }
[13:36:56.480]     ...future.frame <- base::sys.nframe()
[13:36:56.480]     ...future.conditions <- base::list()
[13:36:56.480]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.480]     if (FALSE) {
[13:36:56.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.480]     }
[13:36:56.480]     ...future.result <- base::tryCatch({
[13:36:56.480]         base::withCallingHandlers({
[13:36:56.480]             ...future.value <- base::withVisible(base::local({
[13:36:56.480]                 withCallingHandlers({
[13:36:56.480]                   {
[13:36:56.480]                     b <- a * ii
[13:36:56.480]                     a <- 0
[13:36:56.480]                     b
[13:36:56.480]                   }
[13:36:56.480]                 }, immediateCondition = function(cond) {
[13:36:56.480]                   save_rds <- function (object, pathname, ...) 
[13:36:56.480]                   {
[13:36:56.480]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.480]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.480]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.480]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.480]                         fi_tmp[["mtime"]])
[13:36:56.480]                     }
[13:36:56.480]                     tryCatch({
[13:36:56.480]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.480]                     }, error = function(ex) {
[13:36:56.480]                       msg <- conditionMessage(ex)
[13:36:56.480]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.480]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.480]                         fi_tmp[["mtime"]], msg)
[13:36:56.480]                       ex$message <- msg
[13:36:56.480]                       stop(ex)
[13:36:56.480]                     })
[13:36:56.480]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.480]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.480]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.480]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.480]                       fi <- file.info(pathname)
[13:36:56.480]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.480]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.480]                         fi[["size"]], fi[["mtime"]])
[13:36:56.480]                       stop(msg)
[13:36:56.480]                     }
[13:36:56.480]                     invisible(pathname)
[13:36:56.480]                   }
[13:36:56.480]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.480]                     rootPath = tempdir()) 
[13:36:56.480]                   {
[13:36:56.480]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.480]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.480]                       tmpdir = path, fileext = ".rds")
[13:36:56.480]                     save_rds(obj, file)
[13:36:56.480]                   }
[13:36:56.480]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.480]                   {
[13:36:56.480]                     inherits <- base::inherits
[13:36:56.480]                     invokeRestart <- base::invokeRestart
[13:36:56.480]                     is.null <- base::is.null
[13:36:56.480]                     muffled <- FALSE
[13:36:56.480]                     if (inherits(cond, "message")) {
[13:36:56.480]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.480]                       if (muffled) 
[13:36:56.480]                         invokeRestart("muffleMessage")
[13:36:56.480]                     }
[13:36:56.480]                     else if (inherits(cond, "warning")) {
[13:36:56.480]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.480]                       if (muffled) 
[13:36:56.480]                         invokeRestart("muffleWarning")
[13:36:56.480]                     }
[13:36:56.480]                     else if (inherits(cond, "condition")) {
[13:36:56.480]                       if (!is.null(pattern)) {
[13:36:56.480]                         computeRestarts <- base::computeRestarts
[13:36:56.480]                         grepl <- base::grepl
[13:36:56.480]                         restarts <- computeRestarts(cond)
[13:36:56.480]                         for (restart in restarts) {
[13:36:56.480]                           name <- restart$name
[13:36:56.480]                           if (is.null(name)) 
[13:36:56.480]                             next
[13:36:56.480]                           if (!grepl(pattern, name)) 
[13:36:56.480]                             next
[13:36:56.480]                           invokeRestart(restart)
[13:36:56.480]                           muffled <- TRUE
[13:36:56.480]                           break
[13:36:56.480]                         }
[13:36:56.480]                       }
[13:36:56.480]                     }
[13:36:56.480]                     invisible(muffled)
[13:36:56.480]                   }
[13:36:56.480]                   muffleCondition(cond)
[13:36:56.480]                 })
[13:36:56.480]             }))
[13:36:56.480]             future::FutureResult(value = ...future.value$value, 
[13:36:56.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.480]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.480]                     ...future.globalenv.names))
[13:36:56.480]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.480]         }, condition = base::local({
[13:36:56.480]             c <- base::c
[13:36:56.480]             inherits <- base::inherits
[13:36:56.480]             invokeRestart <- base::invokeRestart
[13:36:56.480]             length <- base::length
[13:36:56.480]             list <- base::list
[13:36:56.480]             seq.int <- base::seq.int
[13:36:56.480]             signalCondition <- base::signalCondition
[13:36:56.480]             sys.calls <- base::sys.calls
[13:36:56.480]             `[[` <- base::`[[`
[13:36:56.480]             `+` <- base::`+`
[13:36:56.480]             `<<-` <- base::`<<-`
[13:36:56.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.480]                   3L)]
[13:36:56.480]             }
[13:36:56.480]             function(cond) {
[13:36:56.480]                 is_error <- inherits(cond, "error")
[13:36:56.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.480]                   NULL)
[13:36:56.480]                 if (is_error) {
[13:36:56.480]                   sessionInformation <- function() {
[13:36:56.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.480]                       search = base::search(), system = base::Sys.info())
[13:36:56.480]                   }
[13:36:56.480]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.480]                     cond$call), session = sessionInformation(), 
[13:36:56.480]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.480]                   signalCondition(cond)
[13:36:56.480]                 }
[13:36:56.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.480]                 "immediateCondition"))) {
[13:36:56.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.480]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.480]                   if (TRUE && !signal) {
[13:36:56.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.480]                     {
[13:36:56.480]                       inherits <- base::inherits
[13:36:56.480]                       invokeRestart <- base::invokeRestart
[13:36:56.480]                       is.null <- base::is.null
[13:36:56.480]                       muffled <- FALSE
[13:36:56.480]                       if (inherits(cond, "message")) {
[13:36:56.480]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.480]                         if (muffled) 
[13:36:56.480]                           invokeRestart("muffleMessage")
[13:36:56.480]                       }
[13:36:56.480]                       else if (inherits(cond, "warning")) {
[13:36:56.480]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.480]                         if (muffled) 
[13:36:56.480]                           invokeRestart("muffleWarning")
[13:36:56.480]                       }
[13:36:56.480]                       else if (inherits(cond, "condition")) {
[13:36:56.480]                         if (!is.null(pattern)) {
[13:36:56.480]                           computeRestarts <- base::computeRestarts
[13:36:56.480]                           grepl <- base::grepl
[13:36:56.480]                           restarts <- computeRestarts(cond)
[13:36:56.480]                           for (restart in restarts) {
[13:36:56.480]                             name <- restart$name
[13:36:56.480]                             if (is.null(name)) 
[13:36:56.480]                               next
[13:36:56.480]                             if (!grepl(pattern, name)) 
[13:36:56.480]                               next
[13:36:56.480]                             invokeRestart(restart)
[13:36:56.480]                             muffled <- TRUE
[13:36:56.480]                             break
[13:36:56.480]                           }
[13:36:56.480]                         }
[13:36:56.480]                       }
[13:36:56.480]                       invisible(muffled)
[13:36:56.480]                     }
[13:36:56.480]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.480]                   }
[13:36:56.480]                 }
[13:36:56.480]                 else {
[13:36:56.480]                   if (TRUE) {
[13:36:56.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.480]                     {
[13:36:56.480]                       inherits <- base::inherits
[13:36:56.480]                       invokeRestart <- base::invokeRestart
[13:36:56.480]                       is.null <- base::is.null
[13:36:56.480]                       muffled <- FALSE
[13:36:56.480]                       if (inherits(cond, "message")) {
[13:36:56.480]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.480]                         if (muffled) 
[13:36:56.480]                           invokeRestart("muffleMessage")
[13:36:56.480]                       }
[13:36:56.480]                       else if (inherits(cond, "warning")) {
[13:36:56.480]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.480]                         if (muffled) 
[13:36:56.480]                           invokeRestart("muffleWarning")
[13:36:56.480]                       }
[13:36:56.480]                       else if (inherits(cond, "condition")) {
[13:36:56.480]                         if (!is.null(pattern)) {
[13:36:56.480]                           computeRestarts <- base::computeRestarts
[13:36:56.480]                           grepl <- base::grepl
[13:36:56.480]                           restarts <- computeRestarts(cond)
[13:36:56.480]                           for (restart in restarts) {
[13:36:56.480]                             name <- restart$name
[13:36:56.480]                             if (is.null(name)) 
[13:36:56.480]                               next
[13:36:56.480]                             if (!grepl(pattern, name)) 
[13:36:56.480]                               next
[13:36:56.480]                             invokeRestart(restart)
[13:36:56.480]                             muffled <- TRUE
[13:36:56.480]                             break
[13:36:56.480]                           }
[13:36:56.480]                         }
[13:36:56.480]                       }
[13:36:56.480]                       invisible(muffled)
[13:36:56.480]                     }
[13:36:56.480]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.480]                   }
[13:36:56.480]                 }
[13:36:56.480]             }
[13:36:56.480]         }))
[13:36:56.480]     }, error = function(ex) {
[13:36:56.480]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.480]                 ...future.rng), started = ...future.startTime, 
[13:36:56.480]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.480]             version = "1.8"), class = "FutureResult")
[13:36:56.480]     }, finally = {
[13:36:56.480]         if (!identical(...future.workdir, getwd())) 
[13:36:56.480]             setwd(...future.workdir)
[13:36:56.480]         {
[13:36:56.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.480]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.480]             }
[13:36:56.480]             base::options(...future.oldOptions)
[13:36:56.480]             if (.Platform$OS.type == "windows") {
[13:36:56.480]                 old_names <- names(...future.oldEnvVars)
[13:36:56.480]                 envs <- base::Sys.getenv()
[13:36:56.480]                 names <- names(envs)
[13:36:56.480]                 common <- intersect(names, old_names)
[13:36:56.480]                 added <- setdiff(names, old_names)
[13:36:56.480]                 removed <- setdiff(old_names, names)
[13:36:56.480]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.480]                   envs[common]]
[13:36:56.480]                 NAMES <- toupper(changed)
[13:36:56.480]                 args <- list()
[13:36:56.480]                 for (kk in seq_along(NAMES)) {
[13:36:56.480]                   name <- changed[[kk]]
[13:36:56.480]                   NAME <- NAMES[[kk]]
[13:36:56.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.480]                     next
[13:36:56.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.480]                 }
[13:36:56.480]                 NAMES <- toupper(added)
[13:36:56.480]                 for (kk in seq_along(NAMES)) {
[13:36:56.480]                   name <- added[[kk]]
[13:36:56.480]                   NAME <- NAMES[[kk]]
[13:36:56.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.480]                     next
[13:36:56.480]                   args[[name]] <- ""
[13:36:56.480]                 }
[13:36:56.480]                 NAMES <- toupper(removed)
[13:36:56.480]                 for (kk in seq_along(NAMES)) {
[13:36:56.480]                   name <- removed[[kk]]
[13:36:56.480]                   NAME <- NAMES[[kk]]
[13:36:56.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.480]                     next
[13:36:56.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.480]                 }
[13:36:56.480]                 if (length(args) > 0) 
[13:36:56.480]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.480]             }
[13:36:56.480]             else {
[13:36:56.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.480]             }
[13:36:56.480]             {
[13:36:56.480]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.480]                   0L) {
[13:36:56.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.480]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.480]                   base::options(opts)
[13:36:56.480]                 }
[13:36:56.480]                 {
[13:36:56.480]                   {
[13:36:56.480]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.480]                     NULL
[13:36:56.480]                   }
[13:36:56.480]                   options(future.plan = NULL)
[13:36:56.480]                   if (is.na(NA_character_)) 
[13:36:56.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.480]                     .init = FALSE)
[13:36:56.480]                 }
[13:36:56.480]             }
[13:36:56.480]         }
[13:36:56.480]     })
[13:36:56.480]     if (TRUE) {
[13:36:56.480]         base::sink(type = "output", split = FALSE)
[13:36:56.480]         if (TRUE) {
[13:36:56.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.480]         }
[13:36:56.480]         else {
[13:36:56.480]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.480]         }
[13:36:56.480]         base::close(...future.stdout)
[13:36:56.480]         ...future.stdout <- NULL
[13:36:56.480]     }
[13:36:56.480]     ...future.result$conditions <- ...future.conditions
[13:36:56.480]     ...future.result$finished <- base::Sys.time()
[13:36:56.480]     ...future.result
[13:36:56.480] }
[13:36:56.483] assign_globals() ...
[13:36:56.483] List of 1
[13:36:56.483]  $ ii: int 1
[13:36:56.483]  - attr(*, "where")=List of 1
[13:36:56.483]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.483]  - attr(*, "resolved")= logi TRUE
[13:36:56.483]  - attr(*, "total_size")= num 56
[13:36:56.483]  - attr(*, "already-done")= logi TRUE
[13:36:56.485] - copied ‘ii’ to environment
[13:36:56.486] assign_globals() ... done
[13:36:56.486] requestCore(): workers = 2
[13:36:56.487] MulticoreFuture started
[13:36:56.488] - Launch lazy future ... done
[13:36:56.488] run() for ‘MulticoreFuture’ ... done
[13:36:56.488] result() for MulticoreFuture ...
[13:36:56.489] plan(): Setting new future strategy stack:
[13:36:56.489] List of future strategies:
[13:36:56.489] 1. sequential:
[13:36:56.489]    - args: function (..., envir = parent.frame())
[13:36:56.489]    - tweaked: FALSE
[13:36:56.489]    - call: NULL
[13:36:56.490] plan(): nbrOfWorkers() = 1
[13:36:56.492] plan(): Setting new future strategy stack:
[13:36:56.492] List of future strategies:
[13:36:56.492] 1. multicore:
[13:36:56.492]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.492]    - tweaked: FALSE
[13:36:56.492]    - call: plan(strategy)
[13:36:56.497] plan(): nbrOfWorkers() = 2
[13:36:56.504] result() for MulticoreFuture ...
[13:36:56.504] result() for MulticoreFuture ... done
[13:36:56.504] signalConditions() ...
[13:36:56.504]  - include = ‘immediateCondition’
[13:36:56.505]  - exclude = 
[13:36:56.505]  - resignal = FALSE
[13:36:56.505]  - Number of conditions: 1
[13:36:56.505] signalConditions() ... done
[13:36:56.505] result() for MulticoreFuture ... done
[13:36:56.505] result() for MulticoreFuture ...
[13:36:56.506] result() for MulticoreFuture ... done
[13:36:56.506] signalConditions() ...
[13:36:56.506]  - include = ‘immediateCondition’
[13:36:56.506]  - exclude = 
[13:36:56.506]  - resignal = FALSE
[13:36:56.506]  - Number of conditions: 1
[13:36:56.507] signalConditions() ... done
[13:36:56.507] Future state: ‘finished’
[13:36:56.507] result() for MulticoreFuture ...
[13:36:56.507] result() for MulticoreFuture ... done
[13:36:56.507] signalConditions() ...
[13:36:56.507]  - include = ‘condition’
[13:36:56.507]  - exclude = ‘immediateCondition’
[13:36:56.507]  - resignal = TRUE
[13:36:56.508]  - Number of conditions: 1
[13:36:56.508]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:56.508] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "57e9b94e809f" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:36:56"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.539] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.539] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.540] 
[13:36:56.540] Searching for globals ... DONE
[13:36:56.540] - globals: [0] <none>
[13:36:56.540] getGlobalsAndPackages() ... DONE
[13:36:56.540] run() for ‘Future’ ...
[13:36:56.541] - state: ‘created’
[13:36:56.541] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.544] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.545]   - Field: ‘label’
[13:36:56.545]   - Field: ‘local’
[13:36:56.545]   - Field: ‘owner’
[13:36:56.545]   - Field: ‘envir’
[13:36:56.545]   - Field: ‘workers’
[13:36:56.545]   - Field: ‘packages’
[13:36:56.545]   - Field: ‘gc’
[13:36:56.545]   - Field: ‘job’
[13:36:56.545]   - Field: ‘conditions’
[13:36:56.546]   - Field: ‘expr’
[13:36:56.546]   - Field: ‘uuid’
[13:36:56.546]   - Field: ‘seed’
[13:36:56.546]   - Field: ‘version’
[13:36:56.546]   - Field: ‘result’
[13:36:56.546]   - Field: ‘asynchronous’
[13:36:56.546]   - Field: ‘calls’
[13:36:56.546]   - Field: ‘globals’
[13:36:56.546]   - Field: ‘stdout’
[13:36:56.546]   - Field: ‘earlySignal’
[13:36:56.546]   - Field: ‘lazy’
[13:36:56.547]   - Field: ‘state’
[13:36:56.547] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.547] - Launch lazy future ...
[13:36:56.547] Packages needed by the future expression (n = 0): <none>
[13:36:56.547] Packages needed by future strategies (n = 0): <none>
[13:36:56.548] {
[13:36:56.548]     {
[13:36:56.548]         {
[13:36:56.548]             ...future.startTime <- base::Sys.time()
[13:36:56.548]             {
[13:36:56.548]                 {
[13:36:56.548]                   {
[13:36:56.548]                     {
[13:36:56.548]                       base::local({
[13:36:56.548]                         has_future <- base::requireNamespace("future", 
[13:36:56.548]                           quietly = TRUE)
[13:36:56.548]                         if (has_future) {
[13:36:56.548]                           ns <- base::getNamespace("future")
[13:36:56.548]                           version <- ns[[".package"]][["version"]]
[13:36:56.548]                           if (is.null(version)) 
[13:36:56.548]                             version <- utils::packageVersion("future")
[13:36:56.548]                         }
[13:36:56.548]                         else {
[13:36:56.548]                           version <- NULL
[13:36:56.548]                         }
[13:36:56.548]                         if (!has_future || version < "1.8.0") {
[13:36:56.548]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.548]                             "", base::R.version$version.string), 
[13:36:56.548]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.548]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.548]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.548]                               "release", "version")], collapse = " "), 
[13:36:56.548]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.548]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.548]                             info)
[13:36:56.548]                           info <- base::paste(info, collapse = "; ")
[13:36:56.548]                           if (!has_future) {
[13:36:56.548]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.548]                               info)
[13:36:56.548]                           }
[13:36:56.548]                           else {
[13:36:56.548]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.548]                               info, version)
[13:36:56.548]                           }
[13:36:56.548]                           base::stop(msg)
[13:36:56.548]                         }
[13:36:56.548]                       })
[13:36:56.548]                     }
[13:36:56.548]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.548]                     base::options(mc.cores = 1L)
[13:36:56.548]                   }
[13:36:56.548]                   ...future.strategy.old <- future::plan("list")
[13:36:56.548]                   options(future.plan = NULL)
[13:36:56.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.548]                 }
[13:36:56.548]                 ...future.workdir <- getwd()
[13:36:56.548]             }
[13:36:56.548]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.548]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.548]         }
[13:36:56.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.548]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.548]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.548]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.548]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.548]             base::names(...future.oldOptions))
[13:36:56.548]     }
[13:36:56.548]     if (FALSE) {
[13:36:56.548]     }
[13:36:56.548]     else {
[13:36:56.548]         if (TRUE) {
[13:36:56.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.548]                 open = "w")
[13:36:56.548]         }
[13:36:56.548]         else {
[13:36:56.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.548]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.548]         }
[13:36:56.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.548]             base::sink(type = "output", split = FALSE)
[13:36:56.548]             base::close(...future.stdout)
[13:36:56.548]         }, add = TRUE)
[13:36:56.548]     }
[13:36:56.548]     ...future.frame <- base::sys.nframe()
[13:36:56.548]     ...future.conditions <- base::list()
[13:36:56.548]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.548]     if (FALSE) {
[13:36:56.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.548]     }
[13:36:56.548]     ...future.result <- base::tryCatch({
[13:36:56.548]         base::withCallingHandlers({
[13:36:56.548]             ...future.value <- base::withVisible(base::local({
[13:36:56.548]                 withCallingHandlers({
[13:36:56.548]                   1
[13:36:56.548]                 }, immediateCondition = function(cond) {
[13:36:56.548]                   save_rds <- function (object, pathname, ...) 
[13:36:56.548]                   {
[13:36:56.548]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.548]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.548]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.548]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.548]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.548]                         fi_tmp[["mtime"]])
[13:36:56.548]                     }
[13:36:56.548]                     tryCatch({
[13:36:56.548]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.548]                     }, error = function(ex) {
[13:36:56.548]                       msg <- conditionMessage(ex)
[13:36:56.548]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.548]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.548]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.548]                         fi_tmp[["mtime"]], msg)
[13:36:56.548]                       ex$message <- msg
[13:36:56.548]                       stop(ex)
[13:36:56.548]                     })
[13:36:56.548]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.548]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.548]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.548]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.548]                       fi <- file.info(pathname)
[13:36:56.548]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.548]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.548]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.548]                         fi[["size"]], fi[["mtime"]])
[13:36:56.548]                       stop(msg)
[13:36:56.548]                     }
[13:36:56.548]                     invisible(pathname)
[13:36:56.548]                   }
[13:36:56.548]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.548]                     rootPath = tempdir()) 
[13:36:56.548]                   {
[13:36:56.548]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.548]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.548]                       tmpdir = path, fileext = ".rds")
[13:36:56.548]                     save_rds(obj, file)
[13:36:56.548]                   }
[13:36:56.548]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.548]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.548]                   {
[13:36:56.548]                     inherits <- base::inherits
[13:36:56.548]                     invokeRestart <- base::invokeRestart
[13:36:56.548]                     is.null <- base::is.null
[13:36:56.548]                     muffled <- FALSE
[13:36:56.548]                     if (inherits(cond, "message")) {
[13:36:56.548]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.548]                       if (muffled) 
[13:36:56.548]                         invokeRestart("muffleMessage")
[13:36:56.548]                     }
[13:36:56.548]                     else if (inherits(cond, "warning")) {
[13:36:56.548]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.548]                       if (muffled) 
[13:36:56.548]                         invokeRestart("muffleWarning")
[13:36:56.548]                     }
[13:36:56.548]                     else if (inherits(cond, "condition")) {
[13:36:56.548]                       if (!is.null(pattern)) {
[13:36:56.548]                         computeRestarts <- base::computeRestarts
[13:36:56.548]                         grepl <- base::grepl
[13:36:56.548]                         restarts <- computeRestarts(cond)
[13:36:56.548]                         for (restart in restarts) {
[13:36:56.548]                           name <- restart$name
[13:36:56.548]                           if (is.null(name)) 
[13:36:56.548]                             next
[13:36:56.548]                           if (!grepl(pattern, name)) 
[13:36:56.548]                             next
[13:36:56.548]                           invokeRestart(restart)
[13:36:56.548]                           muffled <- TRUE
[13:36:56.548]                           break
[13:36:56.548]                         }
[13:36:56.548]                       }
[13:36:56.548]                     }
[13:36:56.548]                     invisible(muffled)
[13:36:56.548]                   }
[13:36:56.548]                   muffleCondition(cond)
[13:36:56.548]                 })
[13:36:56.548]             }))
[13:36:56.548]             future::FutureResult(value = ...future.value$value, 
[13:36:56.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.548]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.548]                     ...future.globalenv.names))
[13:36:56.548]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.548]         }, condition = base::local({
[13:36:56.548]             c <- base::c
[13:36:56.548]             inherits <- base::inherits
[13:36:56.548]             invokeRestart <- base::invokeRestart
[13:36:56.548]             length <- base::length
[13:36:56.548]             list <- base::list
[13:36:56.548]             seq.int <- base::seq.int
[13:36:56.548]             signalCondition <- base::signalCondition
[13:36:56.548]             sys.calls <- base::sys.calls
[13:36:56.548]             `[[` <- base::`[[`
[13:36:56.548]             `+` <- base::`+`
[13:36:56.548]             `<<-` <- base::`<<-`
[13:36:56.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.548]                   3L)]
[13:36:56.548]             }
[13:36:56.548]             function(cond) {
[13:36:56.548]                 is_error <- inherits(cond, "error")
[13:36:56.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.548]                   NULL)
[13:36:56.548]                 if (is_error) {
[13:36:56.548]                   sessionInformation <- function() {
[13:36:56.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.548]                       search = base::search(), system = base::Sys.info())
[13:36:56.548]                   }
[13:36:56.548]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.548]                     cond$call), session = sessionInformation(), 
[13:36:56.548]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.548]                   signalCondition(cond)
[13:36:56.548]                 }
[13:36:56.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.548]                 "immediateCondition"))) {
[13:36:56.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.548]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.548]                   if (TRUE && !signal) {
[13:36:56.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.548]                     {
[13:36:56.548]                       inherits <- base::inherits
[13:36:56.548]                       invokeRestart <- base::invokeRestart
[13:36:56.548]                       is.null <- base::is.null
[13:36:56.548]                       muffled <- FALSE
[13:36:56.548]                       if (inherits(cond, "message")) {
[13:36:56.548]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.548]                         if (muffled) 
[13:36:56.548]                           invokeRestart("muffleMessage")
[13:36:56.548]                       }
[13:36:56.548]                       else if (inherits(cond, "warning")) {
[13:36:56.548]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.548]                         if (muffled) 
[13:36:56.548]                           invokeRestart("muffleWarning")
[13:36:56.548]                       }
[13:36:56.548]                       else if (inherits(cond, "condition")) {
[13:36:56.548]                         if (!is.null(pattern)) {
[13:36:56.548]                           computeRestarts <- base::computeRestarts
[13:36:56.548]                           grepl <- base::grepl
[13:36:56.548]                           restarts <- computeRestarts(cond)
[13:36:56.548]                           for (restart in restarts) {
[13:36:56.548]                             name <- restart$name
[13:36:56.548]                             if (is.null(name)) 
[13:36:56.548]                               next
[13:36:56.548]                             if (!grepl(pattern, name)) 
[13:36:56.548]                               next
[13:36:56.548]                             invokeRestart(restart)
[13:36:56.548]                             muffled <- TRUE
[13:36:56.548]                             break
[13:36:56.548]                           }
[13:36:56.548]                         }
[13:36:56.548]                       }
[13:36:56.548]                       invisible(muffled)
[13:36:56.548]                     }
[13:36:56.548]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.548]                   }
[13:36:56.548]                 }
[13:36:56.548]                 else {
[13:36:56.548]                   if (TRUE) {
[13:36:56.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.548]                     {
[13:36:56.548]                       inherits <- base::inherits
[13:36:56.548]                       invokeRestart <- base::invokeRestart
[13:36:56.548]                       is.null <- base::is.null
[13:36:56.548]                       muffled <- FALSE
[13:36:56.548]                       if (inherits(cond, "message")) {
[13:36:56.548]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.548]                         if (muffled) 
[13:36:56.548]                           invokeRestart("muffleMessage")
[13:36:56.548]                       }
[13:36:56.548]                       else if (inherits(cond, "warning")) {
[13:36:56.548]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.548]                         if (muffled) 
[13:36:56.548]                           invokeRestart("muffleWarning")
[13:36:56.548]                       }
[13:36:56.548]                       else if (inherits(cond, "condition")) {
[13:36:56.548]                         if (!is.null(pattern)) {
[13:36:56.548]                           computeRestarts <- base::computeRestarts
[13:36:56.548]                           grepl <- base::grepl
[13:36:56.548]                           restarts <- computeRestarts(cond)
[13:36:56.548]                           for (restart in restarts) {
[13:36:56.548]                             name <- restart$name
[13:36:56.548]                             if (is.null(name)) 
[13:36:56.548]                               next
[13:36:56.548]                             if (!grepl(pattern, name)) 
[13:36:56.548]                               next
[13:36:56.548]                             invokeRestart(restart)
[13:36:56.548]                             muffled <- TRUE
[13:36:56.548]                             break
[13:36:56.548]                           }
[13:36:56.548]                         }
[13:36:56.548]                       }
[13:36:56.548]                       invisible(muffled)
[13:36:56.548]                     }
[13:36:56.548]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.548]                   }
[13:36:56.548]                 }
[13:36:56.548]             }
[13:36:56.548]         }))
[13:36:56.548]     }, error = function(ex) {
[13:36:56.548]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.548]                 ...future.rng), started = ...future.startTime, 
[13:36:56.548]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.548]             version = "1.8"), class = "FutureResult")
[13:36:56.548]     }, finally = {
[13:36:56.548]         if (!identical(...future.workdir, getwd())) 
[13:36:56.548]             setwd(...future.workdir)
[13:36:56.548]         {
[13:36:56.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.548]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.548]             }
[13:36:56.548]             base::options(...future.oldOptions)
[13:36:56.548]             if (.Platform$OS.type == "windows") {
[13:36:56.548]                 old_names <- names(...future.oldEnvVars)
[13:36:56.548]                 envs <- base::Sys.getenv()
[13:36:56.548]                 names <- names(envs)
[13:36:56.548]                 common <- intersect(names, old_names)
[13:36:56.548]                 added <- setdiff(names, old_names)
[13:36:56.548]                 removed <- setdiff(old_names, names)
[13:36:56.548]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.548]                   envs[common]]
[13:36:56.548]                 NAMES <- toupper(changed)
[13:36:56.548]                 args <- list()
[13:36:56.548]                 for (kk in seq_along(NAMES)) {
[13:36:56.548]                   name <- changed[[kk]]
[13:36:56.548]                   NAME <- NAMES[[kk]]
[13:36:56.548]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.548]                     next
[13:36:56.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.548]                 }
[13:36:56.548]                 NAMES <- toupper(added)
[13:36:56.548]                 for (kk in seq_along(NAMES)) {
[13:36:56.548]                   name <- added[[kk]]
[13:36:56.548]                   NAME <- NAMES[[kk]]
[13:36:56.548]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.548]                     next
[13:36:56.548]                   args[[name]] <- ""
[13:36:56.548]                 }
[13:36:56.548]                 NAMES <- toupper(removed)
[13:36:56.548]                 for (kk in seq_along(NAMES)) {
[13:36:56.548]                   name <- removed[[kk]]
[13:36:56.548]                   NAME <- NAMES[[kk]]
[13:36:56.548]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.548]                     next
[13:36:56.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.548]                 }
[13:36:56.548]                 if (length(args) > 0) 
[13:36:56.548]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.548]             }
[13:36:56.548]             else {
[13:36:56.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.548]             }
[13:36:56.548]             {
[13:36:56.548]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.548]                   0L) {
[13:36:56.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.548]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.548]                   base::options(opts)
[13:36:56.548]                 }
[13:36:56.548]                 {
[13:36:56.548]                   {
[13:36:56.548]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.548]                     NULL
[13:36:56.548]                   }
[13:36:56.548]                   options(future.plan = NULL)
[13:36:56.548]                   if (is.na(NA_character_)) 
[13:36:56.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.548]                     .init = FALSE)
[13:36:56.548]                 }
[13:36:56.548]             }
[13:36:56.548]         }
[13:36:56.548]     })
[13:36:56.548]     if (TRUE) {
[13:36:56.548]         base::sink(type = "output", split = FALSE)
[13:36:56.548]         if (TRUE) {
[13:36:56.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.548]         }
[13:36:56.548]         else {
[13:36:56.548]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.548]         }
[13:36:56.548]         base::close(...future.stdout)
[13:36:56.548]         ...future.stdout <- NULL
[13:36:56.548]     }
[13:36:56.548]     ...future.result$conditions <- ...future.conditions
[13:36:56.548]     ...future.result$finished <- base::Sys.time()
[13:36:56.548]     ...future.result
[13:36:56.548] }
[13:36:56.550] requestCore(): workers = 2
[13:36:56.552] MulticoreFuture started
[13:36:56.552] - Launch lazy future ... done
[13:36:56.552] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.553] getGlobalsAndPackages() ...
[13:36:56.553] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.553] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.553] List of future strategies:
[13:36:56.553] 1. sequential:
[13:36:56.553]    - args: function (..., envir = parent.frame())
[13:36:56.553]    - tweaked: FALSE
[13:36:56.553]    - call: NULL
[13:36:56.554] plan(): nbrOfWorkers() = 1
[13:36:56.555] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:56.555] Searching for globals ... DONE
[13:36:56.556] Resolving globals: TRUE
[13:36:56.556] plan(): Setting new future strategy stack:
[13:36:56.556] Resolving any globals that are futures ...
[13:36:56.556] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:56.556] Resolving any globals that are futures ... DONE
[13:36:56.556] List of future strategies:
[13:36:56.556] 1. multicore:
[13:36:56.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.556]    - tweaked: FALSE
[13:36:56.556]    - call: plan(strategy)
[13:36:56.557] Resolving futures part of globals (recursively) ...
[13:36:56.557] resolve() on list ...
[13:36:56.557]  recursive: 99
[13:36:56.558]  length: 1
[13:36:56.558]  elements: ‘a’
[13:36:56.561] plan(): nbrOfWorkers() = 2
[13:36:56.561] Future #1
[13:36:56.561] result() for MulticoreFuture ...
[13:36:56.562] result() for MulticoreFuture ...
[13:36:56.562] result() for MulticoreFuture ... done
[13:36:56.563] result() for MulticoreFuture ... done
[13:36:56.563] result() for MulticoreFuture ...
[13:36:56.563] result() for MulticoreFuture ... done
[13:36:56.563] A MulticoreFuture was resolved
[13:36:56.563]  length: 0 (resolved future 1)
[13:36:56.563] resolve() on list ... DONE
[13:36:56.563] - globals: [1] ‘a’
[13:36:56.564] Resolving futures part of globals (recursively) ... DONE
[13:36:56.565] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[13:36:56.565] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[13:36:56.565] - globals: [1] ‘a’
[13:36:56.566] - packages: [1] ‘future’
[13:36:56.566] getGlobalsAndPackages() ... DONE
[13:36:56.566] run() for ‘Future’ ...
[13:36:56.566] - state: ‘created’
[13:36:56.566] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.570] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.571]   - Field: ‘label’
[13:36:56.571]   - Field: ‘local’
[13:36:56.571]   - Field: ‘owner’
[13:36:56.571]   - Field: ‘envir’
[13:36:56.571]   - Field: ‘workers’
[13:36:56.571]   - Field: ‘packages’
[13:36:56.571]   - Field: ‘gc’
[13:36:56.571]   - Field: ‘job’
[13:36:56.571]   - Field: ‘conditions’
[13:36:56.572]   - Field: ‘expr’
[13:36:56.572]   - Field: ‘uuid’
[13:36:56.572]   - Field: ‘seed’
[13:36:56.572]   - Field: ‘version’
[13:36:56.572]   - Field: ‘result’
[13:36:56.572]   - Field: ‘asynchronous’
[13:36:56.572]   - Field: ‘calls’
[13:36:56.572]   - Field: ‘globals’
[13:36:56.572]   - Field: ‘stdout’
[13:36:56.573]   - Field: ‘earlySignal’
[13:36:56.573]   - Field: ‘lazy’
[13:36:56.573]   - Field: ‘state’
[13:36:56.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.573] - Launch lazy future ...
[13:36:56.575] Packages needed by the future expression (n = 1): ‘future’
[13:36:56.576] Packages needed by future strategies (n = 0): <none>
[13:36:56.576] {
[13:36:56.576]     {
[13:36:56.576]         {
[13:36:56.576]             ...future.startTime <- base::Sys.time()
[13:36:56.576]             {
[13:36:56.576]                 {
[13:36:56.576]                   {
[13:36:56.576]                     {
[13:36:56.576]                       {
[13:36:56.576]                         base::local({
[13:36:56.576]                           has_future <- base::requireNamespace("future", 
[13:36:56.576]                             quietly = TRUE)
[13:36:56.576]                           if (has_future) {
[13:36:56.576]                             ns <- base::getNamespace("future")
[13:36:56.576]                             version <- ns[[".package"]][["version"]]
[13:36:56.576]                             if (is.null(version)) 
[13:36:56.576]                               version <- utils::packageVersion("future")
[13:36:56.576]                           }
[13:36:56.576]                           else {
[13:36:56.576]                             version <- NULL
[13:36:56.576]                           }
[13:36:56.576]                           if (!has_future || version < "1.8.0") {
[13:36:56.576]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.576]                               "", base::R.version$version.string), 
[13:36:56.576]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:56.576]                                 base::R.version$platform, 8 * 
[13:36:56.576]                                   base::.Machine$sizeof.pointer), 
[13:36:56.576]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.576]                                 "release", "version")], collapse = " "), 
[13:36:56.576]                               hostname = base::Sys.info()[["nodename"]])
[13:36:56.576]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.576]                               info)
[13:36:56.576]                             info <- base::paste(info, collapse = "; ")
[13:36:56.576]                             if (!has_future) {
[13:36:56.576]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.576]                                 info)
[13:36:56.576]                             }
[13:36:56.576]                             else {
[13:36:56.576]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.576]                                 info, version)
[13:36:56.576]                             }
[13:36:56.576]                             base::stop(msg)
[13:36:56.576]                           }
[13:36:56.576]                         })
[13:36:56.576]                       }
[13:36:56.576]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.576]                       base::options(mc.cores = 1L)
[13:36:56.576]                     }
[13:36:56.576]                     base::local({
[13:36:56.576]                       for (pkg in "future") {
[13:36:56.576]                         base::loadNamespace(pkg)
[13:36:56.576]                         base::library(pkg, character.only = TRUE)
[13:36:56.576]                       }
[13:36:56.576]                     })
[13:36:56.576]                   }
[13:36:56.576]                   ...future.strategy.old <- future::plan("list")
[13:36:56.576]                   options(future.plan = NULL)
[13:36:56.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.576]                 }
[13:36:56.576]                 ...future.workdir <- getwd()
[13:36:56.576]             }
[13:36:56.576]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.576]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.576]         }
[13:36:56.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.576]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.576]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.576]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.576]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.576]             base::names(...future.oldOptions))
[13:36:56.576]     }
[13:36:56.576]     if (FALSE) {
[13:36:56.576]     }
[13:36:56.576]     else {
[13:36:56.576]         if (TRUE) {
[13:36:56.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.576]                 open = "w")
[13:36:56.576]         }
[13:36:56.576]         else {
[13:36:56.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.576]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.576]         }
[13:36:56.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.576]             base::sink(type = "output", split = FALSE)
[13:36:56.576]             base::close(...future.stdout)
[13:36:56.576]         }, add = TRUE)
[13:36:56.576]     }
[13:36:56.576]     ...future.frame <- base::sys.nframe()
[13:36:56.576]     ...future.conditions <- base::list()
[13:36:56.576]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.576]     if (FALSE) {
[13:36:56.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.576]     }
[13:36:56.576]     ...future.result <- base::tryCatch({
[13:36:56.576]         base::withCallingHandlers({
[13:36:56.576]             ...future.value <- base::withVisible(base::local({
[13:36:56.576]                 withCallingHandlers({
[13:36:56.576]                   value(a) + 1
[13:36:56.576]                 }, immediateCondition = function(cond) {
[13:36:56.576]                   save_rds <- function (object, pathname, ...) 
[13:36:56.576]                   {
[13:36:56.576]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.576]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.576]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.576]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.576]                         fi_tmp[["mtime"]])
[13:36:56.576]                     }
[13:36:56.576]                     tryCatch({
[13:36:56.576]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.576]                     }, error = function(ex) {
[13:36:56.576]                       msg <- conditionMessage(ex)
[13:36:56.576]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.576]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.576]                         fi_tmp[["mtime"]], msg)
[13:36:56.576]                       ex$message <- msg
[13:36:56.576]                       stop(ex)
[13:36:56.576]                     })
[13:36:56.576]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.576]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.576]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.576]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.576]                       fi <- file.info(pathname)
[13:36:56.576]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.576]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.576]                         fi[["size"]], fi[["mtime"]])
[13:36:56.576]                       stop(msg)
[13:36:56.576]                     }
[13:36:56.576]                     invisible(pathname)
[13:36:56.576]                   }
[13:36:56.576]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.576]                     rootPath = tempdir()) 
[13:36:56.576]                   {
[13:36:56.576]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.576]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.576]                       tmpdir = path, fileext = ".rds")
[13:36:56.576]                     save_rds(obj, file)
[13:36:56.576]                   }
[13:36:56.576]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.576]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.576]                   {
[13:36:56.576]                     inherits <- base::inherits
[13:36:56.576]                     invokeRestart <- base::invokeRestart
[13:36:56.576]                     is.null <- base::is.null
[13:36:56.576]                     muffled <- FALSE
[13:36:56.576]                     if (inherits(cond, "message")) {
[13:36:56.576]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.576]                       if (muffled) 
[13:36:56.576]                         invokeRestart("muffleMessage")
[13:36:56.576]                     }
[13:36:56.576]                     else if (inherits(cond, "warning")) {
[13:36:56.576]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.576]                       if (muffled) 
[13:36:56.576]                         invokeRestart("muffleWarning")
[13:36:56.576]                     }
[13:36:56.576]                     else if (inherits(cond, "condition")) {
[13:36:56.576]                       if (!is.null(pattern)) {
[13:36:56.576]                         computeRestarts <- base::computeRestarts
[13:36:56.576]                         grepl <- base::grepl
[13:36:56.576]                         restarts <- computeRestarts(cond)
[13:36:56.576]                         for (restart in restarts) {
[13:36:56.576]                           name <- restart$name
[13:36:56.576]                           if (is.null(name)) 
[13:36:56.576]                             next
[13:36:56.576]                           if (!grepl(pattern, name)) 
[13:36:56.576]                             next
[13:36:56.576]                           invokeRestart(restart)
[13:36:56.576]                           muffled <- TRUE
[13:36:56.576]                           break
[13:36:56.576]                         }
[13:36:56.576]                       }
[13:36:56.576]                     }
[13:36:56.576]                     invisible(muffled)
[13:36:56.576]                   }
[13:36:56.576]                   muffleCondition(cond)
[13:36:56.576]                 })
[13:36:56.576]             }))
[13:36:56.576]             future::FutureResult(value = ...future.value$value, 
[13:36:56.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.576]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.576]                     ...future.globalenv.names))
[13:36:56.576]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.576]         }, condition = base::local({
[13:36:56.576]             c <- base::c
[13:36:56.576]             inherits <- base::inherits
[13:36:56.576]             invokeRestart <- base::invokeRestart
[13:36:56.576]             length <- base::length
[13:36:56.576]             list <- base::list
[13:36:56.576]             seq.int <- base::seq.int
[13:36:56.576]             signalCondition <- base::signalCondition
[13:36:56.576]             sys.calls <- base::sys.calls
[13:36:56.576]             `[[` <- base::`[[`
[13:36:56.576]             `+` <- base::`+`
[13:36:56.576]             `<<-` <- base::`<<-`
[13:36:56.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.576]                   3L)]
[13:36:56.576]             }
[13:36:56.576]             function(cond) {
[13:36:56.576]                 is_error <- inherits(cond, "error")
[13:36:56.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.576]                   NULL)
[13:36:56.576]                 if (is_error) {
[13:36:56.576]                   sessionInformation <- function() {
[13:36:56.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.576]                       search = base::search(), system = base::Sys.info())
[13:36:56.576]                   }
[13:36:56.576]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.576]                     cond$call), session = sessionInformation(), 
[13:36:56.576]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.576]                   signalCondition(cond)
[13:36:56.576]                 }
[13:36:56.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.576]                 "immediateCondition"))) {
[13:36:56.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.576]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.576]                   if (TRUE && !signal) {
[13:36:56.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.576]                     {
[13:36:56.576]                       inherits <- base::inherits
[13:36:56.576]                       invokeRestart <- base::invokeRestart
[13:36:56.576]                       is.null <- base::is.null
[13:36:56.576]                       muffled <- FALSE
[13:36:56.576]                       if (inherits(cond, "message")) {
[13:36:56.576]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.576]                         if (muffled) 
[13:36:56.576]                           invokeRestart("muffleMessage")
[13:36:56.576]                       }
[13:36:56.576]                       else if (inherits(cond, "warning")) {
[13:36:56.576]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.576]                         if (muffled) 
[13:36:56.576]                           invokeRestart("muffleWarning")
[13:36:56.576]                       }
[13:36:56.576]                       else if (inherits(cond, "condition")) {
[13:36:56.576]                         if (!is.null(pattern)) {
[13:36:56.576]                           computeRestarts <- base::computeRestarts
[13:36:56.576]                           grepl <- base::grepl
[13:36:56.576]                           restarts <- computeRestarts(cond)
[13:36:56.576]                           for (restart in restarts) {
[13:36:56.576]                             name <- restart$name
[13:36:56.576]                             if (is.null(name)) 
[13:36:56.576]                               next
[13:36:56.576]                             if (!grepl(pattern, name)) 
[13:36:56.576]                               next
[13:36:56.576]                             invokeRestart(restart)
[13:36:56.576]                             muffled <- TRUE
[13:36:56.576]                             break
[13:36:56.576]                           }
[13:36:56.576]                         }
[13:36:56.576]                       }
[13:36:56.576]                       invisible(muffled)
[13:36:56.576]                     }
[13:36:56.576]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.576]                   }
[13:36:56.576]                 }
[13:36:56.576]                 else {
[13:36:56.576]                   if (TRUE) {
[13:36:56.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.576]                     {
[13:36:56.576]                       inherits <- base::inherits
[13:36:56.576]                       invokeRestart <- base::invokeRestart
[13:36:56.576]                       is.null <- base::is.null
[13:36:56.576]                       muffled <- FALSE
[13:36:56.576]                       if (inherits(cond, "message")) {
[13:36:56.576]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.576]                         if (muffled) 
[13:36:56.576]                           invokeRestart("muffleMessage")
[13:36:56.576]                       }
[13:36:56.576]                       else if (inherits(cond, "warning")) {
[13:36:56.576]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.576]                         if (muffled) 
[13:36:56.576]                           invokeRestart("muffleWarning")
[13:36:56.576]                       }
[13:36:56.576]                       else if (inherits(cond, "condition")) {
[13:36:56.576]                         if (!is.null(pattern)) {
[13:36:56.576]                           computeRestarts <- base::computeRestarts
[13:36:56.576]                           grepl <- base::grepl
[13:36:56.576]                           restarts <- computeRestarts(cond)
[13:36:56.576]                           for (restart in restarts) {
[13:36:56.576]                             name <- restart$name
[13:36:56.576]                             if (is.null(name)) 
[13:36:56.576]                               next
[13:36:56.576]                             if (!grepl(pattern, name)) 
[13:36:56.576]                               next
[13:36:56.576]                             invokeRestart(restart)
[13:36:56.576]                             muffled <- TRUE
[13:36:56.576]                             break
[13:36:56.576]                           }
[13:36:56.576]                         }
[13:36:56.576]                       }
[13:36:56.576]                       invisible(muffled)
[13:36:56.576]                     }
[13:36:56.576]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.576]                   }
[13:36:56.576]                 }
[13:36:56.576]             }
[13:36:56.576]         }))
[13:36:56.576]     }, error = function(ex) {
[13:36:56.576]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.576]                 ...future.rng), started = ...future.startTime, 
[13:36:56.576]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.576]             version = "1.8"), class = "FutureResult")
[13:36:56.576]     }, finally = {
[13:36:56.576]         if (!identical(...future.workdir, getwd())) 
[13:36:56.576]             setwd(...future.workdir)
[13:36:56.576]         {
[13:36:56.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.576]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.576]             }
[13:36:56.576]             base::options(...future.oldOptions)
[13:36:56.576]             if (.Platform$OS.type == "windows") {
[13:36:56.576]                 old_names <- names(...future.oldEnvVars)
[13:36:56.576]                 envs <- base::Sys.getenv()
[13:36:56.576]                 names <- names(envs)
[13:36:56.576]                 common <- intersect(names, old_names)
[13:36:56.576]                 added <- setdiff(names, old_names)
[13:36:56.576]                 removed <- setdiff(old_names, names)
[13:36:56.576]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.576]                   envs[common]]
[13:36:56.576]                 NAMES <- toupper(changed)
[13:36:56.576]                 args <- list()
[13:36:56.576]                 for (kk in seq_along(NAMES)) {
[13:36:56.576]                   name <- changed[[kk]]
[13:36:56.576]                   NAME <- NAMES[[kk]]
[13:36:56.576]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.576]                     next
[13:36:56.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.576]                 }
[13:36:56.576]                 NAMES <- toupper(added)
[13:36:56.576]                 for (kk in seq_along(NAMES)) {
[13:36:56.576]                   name <- added[[kk]]
[13:36:56.576]                   NAME <- NAMES[[kk]]
[13:36:56.576]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.576]                     next
[13:36:56.576]                   args[[name]] <- ""
[13:36:56.576]                 }
[13:36:56.576]                 NAMES <- toupper(removed)
[13:36:56.576]                 for (kk in seq_along(NAMES)) {
[13:36:56.576]                   name <- removed[[kk]]
[13:36:56.576]                   NAME <- NAMES[[kk]]
[13:36:56.576]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.576]                     next
[13:36:56.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.576]                 }
[13:36:56.576]                 if (length(args) > 0) 
[13:36:56.576]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.576]             }
[13:36:56.576]             else {
[13:36:56.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.576]             }
[13:36:56.576]             {
[13:36:56.576]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.576]                   0L) {
[13:36:56.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.576]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.576]                   base::options(opts)
[13:36:56.576]                 }
[13:36:56.576]                 {
[13:36:56.576]                   {
[13:36:56.576]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.576]                     NULL
[13:36:56.576]                   }
[13:36:56.576]                   options(future.plan = NULL)
[13:36:56.576]                   if (is.na(NA_character_)) 
[13:36:56.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.576]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.576]                     .init = FALSE)
[13:36:56.576]                 }
[13:36:56.576]             }
[13:36:56.576]         }
[13:36:56.576]     })
[13:36:56.576]     if (TRUE) {
[13:36:56.576]         base::sink(type = "output", split = FALSE)
[13:36:56.576]         if (TRUE) {
[13:36:56.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.576]         }
[13:36:56.576]         else {
[13:36:56.576]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.576]         }
[13:36:56.576]         base::close(...future.stdout)
[13:36:56.576]         ...future.stdout <- NULL
[13:36:56.576]     }
[13:36:56.576]     ...future.result$conditions <- ...future.conditions
[13:36:56.576]     ...future.result$finished <- base::Sys.time()
[13:36:56.576]     ...future.result
[13:36:56.576] }
[13:36:56.579] assign_globals() ...
[13:36:56.579] List of 1
[13:36:56.579]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c6dbd9aef0> 
[13:36:56.579]  - attr(*, "where")=List of 1
[13:36:56.579]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.579]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.579]  - attr(*, "resolved")= logi TRUE
[13:36:56.579]  - attr(*, "total_size")= num 10816
[13:36:56.579]  - attr(*, "already-done")= logi TRUE
[13:36:56.582] - copied ‘a’ to environment
[13:36:56.583] assign_globals() ... done
[13:36:56.583] requestCore(): workers = 2
[13:36:56.585] MulticoreFuture started
[13:36:56.585] - Launch lazy future ... done
[13:36:56.585] run() for ‘MulticoreFuture’ ... done
[13:36:56.586] result() for MulticoreFuture ...
[13:36:56.586] plan(): Setting new future strategy stack:
[13:36:56.587] List of future strategies:
[13:36:56.587] 1. sequential:
[13:36:56.587]    - args: function (..., envir = parent.frame())
[13:36:56.587]    - tweaked: FALSE
[13:36:56.587]    - call: NULL
[13:36:56.588] plan(): nbrOfWorkers() = 1
[13:36:56.591] plan(): Setting new future strategy stack:
[13:36:56.591] List of future strategies:
[13:36:56.591] 1. multicore:
[13:36:56.591]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.591]    - tweaked: FALSE
[13:36:56.591]    - call: plan(strategy)
[13:36:56.596] plan(): nbrOfWorkers() = 2
[13:36:56.597] result() for MulticoreFuture ...
[13:36:56.597] result() for MulticoreFuture ... done
[13:36:56.597] signalConditions() ...
[13:36:56.598]  - include = ‘immediateCondition’
[13:36:56.598]  - exclude = 
[13:36:56.598]  - resignal = FALSE
[13:36:56.598]  - Number of conditions: 4
[13:36:56.598] signalConditions() ... done
[13:36:56.599] result() for MulticoreFuture ... done
[13:36:56.599] result() for MulticoreFuture ...
[13:36:56.599] result() for MulticoreFuture ... done
[13:36:56.599] signalConditions() ...
[13:36:56.599]  - include = ‘immediateCondition’
[13:36:56.599]  - exclude = 
[13:36:56.600]  - resignal = FALSE
[13:36:56.600]  - Number of conditions: 4
[13:36:56.600] signalConditions() ... done
[13:36:56.600] Future state: ‘finished’
[13:36:56.600] result() for MulticoreFuture ...
[13:36:56.600] result() for MulticoreFuture ... done
[13:36:56.600] signalConditions() ...
[13:36:56.600]  - include = ‘condition’
[13:36:56.601]  - exclude = ‘immediateCondition’
[13:36:56.601]  - resignal = TRUE
[13:36:56.601]  - Number of conditions: 4
[13:36:56.601]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.589] result() for MulticoreFuture ...
[13:36:56.601]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.589] result() for MulticoreFuture ... done
[13:36:56.601]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.590] result() for MulticoreFuture ...
[13:36:56.601]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.590] result() for MulticoreFuture ... done
[13:36:56.602] signalConditions() ... done
value(b) = 2
[13:36:56.602] result() for MulticoreFuture ...
[13:36:56.602] result() for MulticoreFuture ... done
[13:36:56.602] result() for MulticoreFuture ...
[13:36:56.602] result() for MulticoreFuture ... done
[13:36:56.602] signalConditions() ...
[13:36:56.602]  - include = ‘immediateCondition’
[13:36:56.603]  - exclude = 
[13:36:56.603]  - resignal = FALSE
[13:36:56.603]  - Number of conditions: 4
[13:36:56.603] signalConditions() ... done
[13:36:56.603] Future state: ‘finished’
[13:36:56.603] result() for MulticoreFuture ...
[13:36:56.603] result() for MulticoreFuture ... done
[13:36:56.603] signalConditions() ...
[13:36:56.603]  - include = ‘condition’
[13:36:56.604]  - exclude = ‘immediateCondition’
[13:36:56.604]  - resignal = TRUE
[13:36:56.604]  - Number of conditions: 4
[13:36:56.604]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.589] result() for MulticoreFuture ...
[13:36:56.604]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.589] result() for MulticoreFuture ... done
[13:36:56.604]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.590] result() for MulticoreFuture ...
[13:36:56.604]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.590] result() for MulticoreFuture ... done
[13:36:56.605] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.605] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.605] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.606] 
[13:36:56.606] Searching for globals ... DONE
[13:36:56.606] - globals: [0] <none>
[13:36:56.606] getGlobalsAndPackages() ... DONE
[13:36:56.606] run() for ‘Future’ ...
[13:36:56.607] - state: ‘created’
[13:36:56.607] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.611] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.611]   - Field: ‘label’
[13:36:56.611]   - Field: ‘local’
[13:36:56.611]   - Field: ‘owner’
[13:36:56.611]   - Field: ‘envir’
[13:36:56.612]   - Field: ‘workers’
[13:36:56.612]   - Field: ‘packages’
[13:36:56.612]   - Field: ‘gc’
[13:36:56.612]   - Field: ‘job’
[13:36:56.612]   - Field: ‘conditions’
[13:36:56.612]   - Field: ‘expr’
[13:36:56.612]   - Field: ‘uuid’
[13:36:56.612]   - Field: ‘seed’
[13:36:56.612]   - Field: ‘version’
[13:36:56.613]   - Field: ‘result’
[13:36:56.613]   - Field: ‘asynchronous’
[13:36:56.613]   - Field: ‘calls’
[13:36:56.613]   - Field: ‘globals’
[13:36:56.613]   - Field: ‘stdout’
[13:36:56.613]   - Field: ‘earlySignal’
[13:36:56.613]   - Field: ‘lazy’
[13:36:56.613]   - Field: ‘state’
[13:36:56.613] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.613] - Launch lazy future ...
[13:36:56.614] Packages needed by the future expression (n = 0): <none>
[13:36:56.614] Packages needed by future strategies (n = 0): <none>
[13:36:56.614] {
[13:36:56.614]     {
[13:36:56.614]         {
[13:36:56.614]             ...future.startTime <- base::Sys.time()
[13:36:56.614]             {
[13:36:56.614]                 {
[13:36:56.614]                   {
[13:36:56.614]                     {
[13:36:56.614]                       base::local({
[13:36:56.614]                         has_future <- base::requireNamespace("future", 
[13:36:56.614]                           quietly = TRUE)
[13:36:56.614]                         if (has_future) {
[13:36:56.614]                           ns <- base::getNamespace("future")
[13:36:56.614]                           version <- ns[[".package"]][["version"]]
[13:36:56.614]                           if (is.null(version)) 
[13:36:56.614]                             version <- utils::packageVersion("future")
[13:36:56.614]                         }
[13:36:56.614]                         else {
[13:36:56.614]                           version <- NULL
[13:36:56.614]                         }
[13:36:56.614]                         if (!has_future || version < "1.8.0") {
[13:36:56.614]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.614]                             "", base::R.version$version.string), 
[13:36:56.614]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.614]                               "release", "version")], collapse = " "), 
[13:36:56.614]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.614]                             info)
[13:36:56.614]                           info <- base::paste(info, collapse = "; ")
[13:36:56.614]                           if (!has_future) {
[13:36:56.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.614]                               info)
[13:36:56.614]                           }
[13:36:56.614]                           else {
[13:36:56.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.614]                               info, version)
[13:36:56.614]                           }
[13:36:56.614]                           base::stop(msg)
[13:36:56.614]                         }
[13:36:56.614]                       })
[13:36:56.614]                     }
[13:36:56.614]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.614]                     base::options(mc.cores = 1L)
[13:36:56.614]                   }
[13:36:56.614]                   ...future.strategy.old <- future::plan("list")
[13:36:56.614]                   options(future.plan = NULL)
[13:36:56.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.614]                 }
[13:36:56.614]                 ...future.workdir <- getwd()
[13:36:56.614]             }
[13:36:56.614]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.614]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.614]         }
[13:36:56.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.614]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.614]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.614]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.614]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.614]             base::names(...future.oldOptions))
[13:36:56.614]     }
[13:36:56.614]     if (FALSE) {
[13:36:56.614]     }
[13:36:56.614]     else {
[13:36:56.614]         if (TRUE) {
[13:36:56.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.614]                 open = "w")
[13:36:56.614]         }
[13:36:56.614]         else {
[13:36:56.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.614]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.614]         }
[13:36:56.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.614]             base::sink(type = "output", split = FALSE)
[13:36:56.614]             base::close(...future.stdout)
[13:36:56.614]         }, add = TRUE)
[13:36:56.614]     }
[13:36:56.614]     ...future.frame <- base::sys.nframe()
[13:36:56.614]     ...future.conditions <- base::list()
[13:36:56.614]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.614]     if (FALSE) {
[13:36:56.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.614]     }
[13:36:56.614]     ...future.result <- base::tryCatch({
[13:36:56.614]         base::withCallingHandlers({
[13:36:56.614]             ...future.value <- base::withVisible(base::local({
[13:36:56.614]                 withCallingHandlers({
[13:36:56.614]                   1
[13:36:56.614]                 }, immediateCondition = function(cond) {
[13:36:56.614]                   save_rds <- function (object, pathname, ...) 
[13:36:56.614]                   {
[13:36:56.614]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.614]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.614]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.614]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.614]                         fi_tmp[["mtime"]])
[13:36:56.614]                     }
[13:36:56.614]                     tryCatch({
[13:36:56.614]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.614]                     }, error = function(ex) {
[13:36:56.614]                       msg <- conditionMessage(ex)
[13:36:56.614]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.614]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.614]                         fi_tmp[["mtime"]], msg)
[13:36:56.614]                       ex$message <- msg
[13:36:56.614]                       stop(ex)
[13:36:56.614]                     })
[13:36:56.614]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.614]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.614]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.614]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.614]                       fi <- file.info(pathname)
[13:36:56.614]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.614]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.614]                         fi[["size"]], fi[["mtime"]])
[13:36:56.614]                       stop(msg)
[13:36:56.614]                     }
[13:36:56.614]                     invisible(pathname)
[13:36:56.614]                   }
[13:36:56.614]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.614]                     rootPath = tempdir()) 
[13:36:56.614]                   {
[13:36:56.614]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.614]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.614]                       tmpdir = path, fileext = ".rds")
[13:36:56.614]                     save_rds(obj, file)
[13:36:56.614]                   }
[13:36:56.614]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.614]                   {
[13:36:56.614]                     inherits <- base::inherits
[13:36:56.614]                     invokeRestart <- base::invokeRestart
[13:36:56.614]                     is.null <- base::is.null
[13:36:56.614]                     muffled <- FALSE
[13:36:56.614]                     if (inherits(cond, "message")) {
[13:36:56.614]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.614]                       if (muffled) 
[13:36:56.614]                         invokeRestart("muffleMessage")
[13:36:56.614]                     }
[13:36:56.614]                     else if (inherits(cond, "warning")) {
[13:36:56.614]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.614]                       if (muffled) 
[13:36:56.614]                         invokeRestart("muffleWarning")
[13:36:56.614]                     }
[13:36:56.614]                     else if (inherits(cond, "condition")) {
[13:36:56.614]                       if (!is.null(pattern)) {
[13:36:56.614]                         computeRestarts <- base::computeRestarts
[13:36:56.614]                         grepl <- base::grepl
[13:36:56.614]                         restarts <- computeRestarts(cond)
[13:36:56.614]                         for (restart in restarts) {
[13:36:56.614]                           name <- restart$name
[13:36:56.614]                           if (is.null(name)) 
[13:36:56.614]                             next
[13:36:56.614]                           if (!grepl(pattern, name)) 
[13:36:56.614]                             next
[13:36:56.614]                           invokeRestart(restart)
[13:36:56.614]                           muffled <- TRUE
[13:36:56.614]                           break
[13:36:56.614]                         }
[13:36:56.614]                       }
[13:36:56.614]                     }
[13:36:56.614]                     invisible(muffled)
[13:36:56.614]                   }
[13:36:56.614]                   muffleCondition(cond)
[13:36:56.614]                 })
[13:36:56.614]             }))
[13:36:56.614]             future::FutureResult(value = ...future.value$value, 
[13:36:56.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.614]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.614]                     ...future.globalenv.names))
[13:36:56.614]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.614]         }, condition = base::local({
[13:36:56.614]             c <- base::c
[13:36:56.614]             inherits <- base::inherits
[13:36:56.614]             invokeRestart <- base::invokeRestart
[13:36:56.614]             length <- base::length
[13:36:56.614]             list <- base::list
[13:36:56.614]             seq.int <- base::seq.int
[13:36:56.614]             signalCondition <- base::signalCondition
[13:36:56.614]             sys.calls <- base::sys.calls
[13:36:56.614]             `[[` <- base::`[[`
[13:36:56.614]             `+` <- base::`+`
[13:36:56.614]             `<<-` <- base::`<<-`
[13:36:56.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.614]                   3L)]
[13:36:56.614]             }
[13:36:56.614]             function(cond) {
[13:36:56.614]                 is_error <- inherits(cond, "error")
[13:36:56.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.614]                   NULL)
[13:36:56.614]                 if (is_error) {
[13:36:56.614]                   sessionInformation <- function() {
[13:36:56.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.614]                       search = base::search(), system = base::Sys.info())
[13:36:56.614]                   }
[13:36:56.614]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.614]                     cond$call), session = sessionInformation(), 
[13:36:56.614]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.614]                   signalCondition(cond)
[13:36:56.614]                 }
[13:36:56.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.614]                 "immediateCondition"))) {
[13:36:56.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.614]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.614]                   if (TRUE && !signal) {
[13:36:56.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.614]                     {
[13:36:56.614]                       inherits <- base::inherits
[13:36:56.614]                       invokeRestart <- base::invokeRestart
[13:36:56.614]                       is.null <- base::is.null
[13:36:56.614]                       muffled <- FALSE
[13:36:56.614]                       if (inherits(cond, "message")) {
[13:36:56.614]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.614]                         if (muffled) 
[13:36:56.614]                           invokeRestart("muffleMessage")
[13:36:56.614]                       }
[13:36:56.614]                       else if (inherits(cond, "warning")) {
[13:36:56.614]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.614]                         if (muffled) 
[13:36:56.614]                           invokeRestart("muffleWarning")
[13:36:56.614]                       }
[13:36:56.614]                       else if (inherits(cond, "condition")) {
[13:36:56.614]                         if (!is.null(pattern)) {
[13:36:56.614]                           computeRestarts <- base::computeRestarts
[13:36:56.614]                           grepl <- base::grepl
[13:36:56.614]                           restarts <- computeRestarts(cond)
[13:36:56.614]                           for (restart in restarts) {
[13:36:56.614]                             name <- restart$name
[13:36:56.614]                             if (is.null(name)) 
[13:36:56.614]                               next
[13:36:56.614]                             if (!grepl(pattern, name)) 
[13:36:56.614]                               next
[13:36:56.614]                             invokeRestart(restart)
[13:36:56.614]                             muffled <- TRUE
[13:36:56.614]                             break
[13:36:56.614]                           }
[13:36:56.614]                         }
[13:36:56.614]                       }
[13:36:56.614]                       invisible(muffled)
[13:36:56.614]                     }
[13:36:56.614]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.614]                   }
[13:36:56.614]                 }
[13:36:56.614]                 else {
[13:36:56.614]                   if (TRUE) {
[13:36:56.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.614]                     {
[13:36:56.614]                       inherits <- base::inherits
[13:36:56.614]                       invokeRestart <- base::invokeRestart
[13:36:56.614]                       is.null <- base::is.null
[13:36:56.614]                       muffled <- FALSE
[13:36:56.614]                       if (inherits(cond, "message")) {
[13:36:56.614]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.614]                         if (muffled) 
[13:36:56.614]                           invokeRestart("muffleMessage")
[13:36:56.614]                       }
[13:36:56.614]                       else if (inherits(cond, "warning")) {
[13:36:56.614]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.614]                         if (muffled) 
[13:36:56.614]                           invokeRestart("muffleWarning")
[13:36:56.614]                       }
[13:36:56.614]                       else if (inherits(cond, "condition")) {
[13:36:56.614]                         if (!is.null(pattern)) {
[13:36:56.614]                           computeRestarts <- base::computeRestarts
[13:36:56.614]                           grepl <- base::grepl
[13:36:56.614]                           restarts <- computeRestarts(cond)
[13:36:56.614]                           for (restart in restarts) {
[13:36:56.614]                             name <- restart$name
[13:36:56.614]                             if (is.null(name)) 
[13:36:56.614]                               next
[13:36:56.614]                             if (!grepl(pattern, name)) 
[13:36:56.614]                               next
[13:36:56.614]                             invokeRestart(restart)
[13:36:56.614]                             muffled <- TRUE
[13:36:56.614]                             break
[13:36:56.614]                           }
[13:36:56.614]                         }
[13:36:56.614]                       }
[13:36:56.614]                       invisible(muffled)
[13:36:56.614]                     }
[13:36:56.614]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.614]                   }
[13:36:56.614]                 }
[13:36:56.614]             }
[13:36:56.614]         }))
[13:36:56.614]     }, error = function(ex) {
[13:36:56.614]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.614]                 ...future.rng), started = ...future.startTime, 
[13:36:56.614]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.614]             version = "1.8"), class = "FutureResult")
[13:36:56.614]     }, finally = {
[13:36:56.614]         if (!identical(...future.workdir, getwd())) 
[13:36:56.614]             setwd(...future.workdir)
[13:36:56.614]         {
[13:36:56.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.614]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.614]             }
[13:36:56.614]             base::options(...future.oldOptions)
[13:36:56.614]             if (.Platform$OS.type == "windows") {
[13:36:56.614]                 old_names <- names(...future.oldEnvVars)
[13:36:56.614]                 envs <- base::Sys.getenv()
[13:36:56.614]                 names <- names(envs)
[13:36:56.614]                 common <- intersect(names, old_names)
[13:36:56.614]                 added <- setdiff(names, old_names)
[13:36:56.614]                 removed <- setdiff(old_names, names)
[13:36:56.614]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.614]                   envs[common]]
[13:36:56.614]                 NAMES <- toupper(changed)
[13:36:56.614]                 args <- list()
[13:36:56.614]                 for (kk in seq_along(NAMES)) {
[13:36:56.614]                   name <- changed[[kk]]
[13:36:56.614]                   NAME <- NAMES[[kk]]
[13:36:56.614]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.614]                     next
[13:36:56.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.614]                 }
[13:36:56.614]                 NAMES <- toupper(added)
[13:36:56.614]                 for (kk in seq_along(NAMES)) {
[13:36:56.614]                   name <- added[[kk]]
[13:36:56.614]                   NAME <- NAMES[[kk]]
[13:36:56.614]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.614]                     next
[13:36:56.614]                   args[[name]] <- ""
[13:36:56.614]                 }
[13:36:56.614]                 NAMES <- toupper(removed)
[13:36:56.614]                 for (kk in seq_along(NAMES)) {
[13:36:56.614]                   name <- removed[[kk]]
[13:36:56.614]                   NAME <- NAMES[[kk]]
[13:36:56.614]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.614]                     next
[13:36:56.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.614]                 }
[13:36:56.614]                 if (length(args) > 0) 
[13:36:56.614]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.614]             }
[13:36:56.614]             else {
[13:36:56.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.614]             }
[13:36:56.614]             {
[13:36:56.614]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.614]                   0L) {
[13:36:56.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.614]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.614]                   base::options(opts)
[13:36:56.614]                 }
[13:36:56.614]                 {
[13:36:56.614]                   {
[13:36:56.614]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.614]                     NULL
[13:36:56.614]                   }
[13:36:56.614]                   options(future.plan = NULL)
[13:36:56.614]                   if (is.na(NA_character_)) 
[13:36:56.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.614]                     .init = FALSE)
[13:36:56.614]                 }
[13:36:56.614]             }
[13:36:56.614]         }
[13:36:56.614]     })
[13:36:56.614]     if (TRUE) {
[13:36:56.614]         base::sink(type = "output", split = FALSE)
[13:36:56.614]         if (TRUE) {
[13:36:56.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.614]         }
[13:36:56.614]         else {
[13:36:56.614]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.614]         }
[13:36:56.614]         base::close(...future.stdout)
[13:36:56.614]         ...future.stdout <- NULL
[13:36:56.614]     }
[13:36:56.614]     ...future.result$conditions <- ...future.conditions
[13:36:56.614]     ...future.result$finished <- base::Sys.time()
[13:36:56.614]     ...future.result
[13:36:56.614] }
[13:36:56.617] requestCore(): workers = 2
[13:36:56.619] MulticoreFuture started
[13:36:56.619] - Launch lazy future ... done
[13:36:56.619] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.620] getGlobalsAndPackages() ...
[13:36:56.620] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.620] List of future strategies:
[13:36:56.620] 1. sequential:
[13:36:56.620]    - args: function (..., envir = parent.frame())
[13:36:56.620]    - tweaked: FALSE
[13:36:56.620]    - call: NULL
[13:36:56.621] plan(): nbrOfWorkers() = 1
[13:36:56.620] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.627] plan(): Setting new future strategy stack:
[13:36:56.628] List of future strategies:
[13:36:56.628] 1. multicore:
[13:36:56.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.628]    - tweaked: FALSE
[13:36:56.628]    - call: plan(strategy)
[13:36:56.629] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:56.629] Searching for globals ... DONE
[13:36:56.630] Resolving globals: TRUE
[13:36:56.630] Resolving any globals that are futures ...
[13:36:56.630] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:56.631] Resolving any globals that are futures ... DONE
[13:36:56.631] Resolving futures part of globals (recursively) ...
[13:36:56.632] resolve() on list ...
[13:36:56.632]  recursive: 99
[13:36:56.632]  length: 1
[13:36:56.632]  elements: ‘a’
[13:36:56.633] plan(): nbrOfWorkers() = 2
[13:36:56.634] Future #1
[13:36:56.634] result() for MulticoreFuture ...
[13:36:56.635] result() for MulticoreFuture ...
[13:36:56.635] result() for MulticoreFuture ... done
[13:36:56.635] result() for MulticoreFuture ... done
[13:36:56.636] result() for MulticoreFuture ...
[13:36:56.636] result() for MulticoreFuture ... done
[13:36:56.636] A MulticoreFuture was resolved
[13:36:56.636]  length: 0 (resolved future 1)
[13:36:56.636] resolve() on list ... DONE
[13:36:56.637] - globals: [1] ‘a’
[13:36:56.637] Resolving futures part of globals (recursively) ... DONE
[13:36:56.638] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[13:36:56.638] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[13:36:56.639] - globals: [1] ‘a’
[13:36:56.639] - packages: [1] ‘future’
[13:36:56.639] getGlobalsAndPackages() ... DONE
[13:36:56.639] run() for ‘Future’ ...
[13:36:56.639] - state: ‘created’
[13:36:56.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.644] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.644]   - Field: ‘label’
[13:36:56.645]   - Field: ‘local’
[13:36:56.645]   - Field: ‘owner’
[13:36:56.645]   - Field: ‘envir’
[13:36:56.645]   - Field: ‘workers’
[13:36:56.645]   - Field: ‘packages’
[13:36:56.645]   - Field: ‘gc’
[13:36:56.645]   - Field: ‘job’
[13:36:56.646]   - Field: ‘conditions’
[13:36:56.646]   - Field: ‘expr’
[13:36:56.646]   - Field: ‘uuid’
[13:36:56.646]   - Field: ‘seed’
[13:36:56.646]   - Field: ‘version’
[13:36:56.646]   - Field: ‘result’
[13:36:56.646]   - Field: ‘asynchronous’
[13:36:56.647]   - Field: ‘calls’
[13:36:56.647]   - Field: ‘globals’
[13:36:56.647]   - Field: ‘stdout’
[13:36:56.647]   - Field: ‘earlySignal’
[13:36:56.647]   - Field: ‘lazy’
[13:36:56.647]   - Field: ‘state’
[13:36:56.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.647] - Launch lazy future ...
[13:36:56.648] Packages needed by the future expression (n = 1): ‘future’
[13:36:56.648] Packages needed by future strategies (n = 0): <none>
[13:36:56.648] {
[13:36:56.648]     {
[13:36:56.648]         {
[13:36:56.648]             ...future.startTime <- base::Sys.time()
[13:36:56.648]             {
[13:36:56.648]                 {
[13:36:56.648]                   {
[13:36:56.648]                     {
[13:36:56.648]                       {
[13:36:56.648]                         base::local({
[13:36:56.648]                           has_future <- base::requireNamespace("future", 
[13:36:56.648]                             quietly = TRUE)
[13:36:56.648]                           if (has_future) {
[13:36:56.648]                             ns <- base::getNamespace("future")
[13:36:56.648]                             version <- ns[[".package"]][["version"]]
[13:36:56.648]                             if (is.null(version)) 
[13:36:56.648]                               version <- utils::packageVersion("future")
[13:36:56.648]                           }
[13:36:56.648]                           else {
[13:36:56.648]                             version <- NULL
[13:36:56.648]                           }
[13:36:56.648]                           if (!has_future || version < "1.8.0") {
[13:36:56.648]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.648]                               "", base::R.version$version.string), 
[13:36:56.648]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:56.648]                                 base::R.version$platform, 8 * 
[13:36:56.648]                                   base::.Machine$sizeof.pointer), 
[13:36:56.648]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.648]                                 "release", "version")], collapse = " "), 
[13:36:56.648]                               hostname = base::Sys.info()[["nodename"]])
[13:36:56.648]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.648]                               info)
[13:36:56.648]                             info <- base::paste(info, collapse = "; ")
[13:36:56.648]                             if (!has_future) {
[13:36:56.648]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.648]                                 info)
[13:36:56.648]                             }
[13:36:56.648]                             else {
[13:36:56.648]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.648]                                 info, version)
[13:36:56.648]                             }
[13:36:56.648]                             base::stop(msg)
[13:36:56.648]                           }
[13:36:56.648]                         })
[13:36:56.648]                       }
[13:36:56.648]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.648]                       base::options(mc.cores = 1L)
[13:36:56.648]                     }
[13:36:56.648]                     base::local({
[13:36:56.648]                       for (pkg in "future") {
[13:36:56.648]                         base::loadNamespace(pkg)
[13:36:56.648]                         base::library(pkg, character.only = TRUE)
[13:36:56.648]                       }
[13:36:56.648]                     })
[13:36:56.648]                   }
[13:36:56.648]                   ...future.strategy.old <- future::plan("list")
[13:36:56.648]                   options(future.plan = NULL)
[13:36:56.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.648]                 }
[13:36:56.648]                 ...future.workdir <- getwd()
[13:36:56.648]             }
[13:36:56.648]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.648]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.648]         }
[13:36:56.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.648]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.648]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.648]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.648]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.648]             base::names(...future.oldOptions))
[13:36:56.648]     }
[13:36:56.648]     if (FALSE) {
[13:36:56.648]     }
[13:36:56.648]     else {
[13:36:56.648]         if (TRUE) {
[13:36:56.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.648]                 open = "w")
[13:36:56.648]         }
[13:36:56.648]         else {
[13:36:56.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.648]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.648]         }
[13:36:56.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.648]             base::sink(type = "output", split = FALSE)
[13:36:56.648]             base::close(...future.stdout)
[13:36:56.648]         }, add = TRUE)
[13:36:56.648]     }
[13:36:56.648]     ...future.frame <- base::sys.nframe()
[13:36:56.648]     ...future.conditions <- base::list()
[13:36:56.648]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.648]     if (FALSE) {
[13:36:56.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.648]     }
[13:36:56.648]     ...future.result <- base::tryCatch({
[13:36:56.648]         base::withCallingHandlers({
[13:36:56.648]             ...future.value <- base::withVisible(base::local({
[13:36:56.648]                 withCallingHandlers({
[13:36:56.648]                   value(a) + 1
[13:36:56.648]                 }, immediateCondition = function(cond) {
[13:36:56.648]                   save_rds <- function (object, pathname, ...) 
[13:36:56.648]                   {
[13:36:56.648]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.648]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.648]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.648]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.648]                         fi_tmp[["mtime"]])
[13:36:56.648]                     }
[13:36:56.648]                     tryCatch({
[13:36:56.648]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.648]                     }, error = function(ex) {
[13:36:56.648]                       msg <- conditionMessage(ex)
[13:36:56.648]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.648]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.648]                         fi_tmp[["mtime"]], msg)
[13:36:56.648]                       ex$message <- msg
[13:36:56.648]                       stop(ex)
[13:36:56.648]                     })
[13:36:56.648]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.648]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.648]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.648]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.648]                       fi <- file.info(pathname)
[13:36:56.648]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.648]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.648]                         fi[["size"]], fi[["mtime"]])
[13:36:56.648]                       stop(msg)
[13:36:56.648]                     }
[13:36:56.648]                     invisible(pathname)
[13:36:56.648]                   }
[13:36:56.648]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.648]                     rootPath = tempdir()) 
[13:36:56.648]                   {
[13:36:56.648]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.648]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.648]                       tmpdir = path, fileext = ".rds")
[13:36:56.648]                     save_rds(obj, file)
[13:36:56.648]                   }
[13:36:56.648]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.648]                   {
[13:36:56.648]                     inherits <- base::inherits
[13:36:56.648]                     invokeRestart <- base::invokeRestart
[13:36:56.648]                     is.null <- base::is.null
[13:36:56.648]                     muffled <- FALSE
[13:36:56.648]                     if (inherits(cond, "message")) {
[13:36:56.648]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.648]                       if (muffled) 
[13:36:56.648]                         invokeRestart("muffleMessage")
[13:36:56.648]                     }
[13:36:56.648]                     else if (inherits(cond, "warning")) {
[13:36:56.648]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.648]                       if (muffled) 
[13:36:56.648]                         invokeRestart("muffleWarning")
[13:36:56.648]                     }
[13:36:56.648]                     else if (inherits(cond, "condition")) {
[13:36:56.648]                       if (!is.null(pattern)) {
[13:36:56.648]                         computeRestarts <- base::computeRestarts
[13:36:56.648]                         grepl <- base::grepl
[13:36:56.648]                         restarts <- computeRestarts(cond)
[13:36:56.648]                         for (restart in restarts) {
[13:36:56.648]                           name <- restart$name
[13:36:56.648]                           if (is.null(name)) 
[13:36:56.648]                             next
[13:36:56.648]                           if (!grepl(pattern, name)) 
[13:36:56.648]                             next
[13:36:56.648]                           invokeRestart(restart)
[13:36:56.648]                           muffled <- TRUE
[13:36:56.648]                           break
[13:36:56.648]                         }
[13:36:56.648]                       }
[13:36:56.648]                     }
[13:36:56.648]                     invisible(muffled)
[13:36:56.648]                   }
[13:36:56.648]                   muffleCondition(cond)
[13:36:56.648]                 })
[13:36:56.648]             }))
[13:36:56.648]             future::FutureResult(value = ...future.value$value, 
[13:36:56.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.648]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.648]                     ...future.globalenv.names))
[13:36:56.648]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.648]         }, condition = base::local({
[13:36:56.648]             c <- base::c
[13:36:56.648]             inherits <- base::inherits
[13:36:56.648]             invokeRestart <- base::invokeRestart
[13:36:56.648]             length <- base::length
[13:36:56.648]             list <- base::list
[13:36:56.648]             seq.int <- base::seq.int
[13:36:56.648]             signalCondition <- base::signalCondition
[13:36:56.648]             sys.calls <- base::sys.calls
[13:36:56.648]             `[[` <- base::`[[`
[13:36:56.648]             `+` <- base::`+`
[13:36:56.648]             `<<-` <- base::`<<-`
[13:36:56.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.648]                   3L)]
[13:36:56.648]             }
[13:36:56.648]             function(cond) {
[13:36:56.648]                 is_error <- inherits(cond, "error")
[13:36:56.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.648]                   NULL)
[13:36:56.648]                 if (is_error) {
[13:36:56.648]                   sessionInformation <- function() {
[13:36:56.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.648]                       search = base::search(), system = base::Sys.info())
[13:36:56.648]                   }
[13:36:56.648]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.648]                     cond$call), session = sessionInformation(), 
[13:36:56.648]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.648]                   signalCondition(cond)
[13:36:56.648]                 }
[13:36:56.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.648]                 "immediateCondition"))) {
[13:36:56.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.648]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.648]                   if (TRUE && !signal) {
[13:36:56.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.648]                     {
[13:36:56.648]                       inherits <- base::inherits
[13:36:56.648]                       invokeRestart <- base::invokeRestart
[13:36:56.648]                       is.null <- base::is.null
[13:36:56.648]                       muffled <- FALSE
[13:36:56.648]                       if (inherits(cond, "message")) {
[13:36:56.648]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.648]                         if (muffled) 
[13:36:56.648]                           invokeRestart("muffleMessage")
[13:36:56.648]                       }
[13:36:56.648]                       else if (inherits(cond, "warning")) {
[13:36:56.648]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.648]                         if (muffled) 
[13:36:56.648]                           invokeRestart("muffleWarning")
[13:36:56.648]                       }
[13:36:56.648]                       else if (inherits(cond, "condition")) {
[13:36:56.648]                         if (!is.null(pattern)) {
[13:36:56.648]                           computeRestarts <- base::computeRestarts
[13:36:56.648]                           grepl <- base::grepl
[13:36:56.648]                           restarts <- computeRestarts(cond)
[13:36:56.648]                           for (restart in restarts) {
[13:36:56.648]                             name <- restart$name
[13:36:56.648]                             if (is.null(name)) 
[13:36:56.648]                               next
[13:36:56.648]                             if (!grepl(pattern, name)) 
[13:36:56.648]                               next
[13:36:56.648]                             invokeRestart(restart)
[13:36:56.648]                             muffled <- TRUE
[13:36:56.648]                             break
[13:36:56.648]                           }
[13:36:56.648]                         }
[13:36:56.648]                       }
[13:36:56.648]                       invisible(muffled)
[13:36:56.648]                     }
[13:36:56.648]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.648]                   }
[13:36:56.648]                 }
[13:36:56.648]                 else {
[13:36:56.648]                   if (TRUE) {
[13:36:56.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.648]                     {
[13:36:56.648]                       inherits <- base::inherits
[13:36:56.648]                       invokeRestart <- base::invokeRestart
[13:36:56.648]                       is.null <- base::is.null
[13:36:56.648]                       muffled <- FALSE
[13:36:56.648]                       if (inherits(cond, "message")) {
[13:36:56.648]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.648]                         if (muffled) 
[13:36:56.648]                           invokeRestart("muffleMessage")
[13:36:56.648]                       }
[13:36:56.648]                       else if (inherits(cond, "warning")) {
[13:36:56.648]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.648]                         if (muffled) 
[13:36:56.648]                           invokeRestart("muffleWarning")
[13:36:56.648]                       }
[13:36:56.648]                       else if (inherits(cond, "condition")) {
[13:36:56.648]                         if (!is.null(pattern)) {
[13:36:56.648]                           computeRestarts <- base::computeRestarts
[13:36:56.648]                           grepl <- base::grepl
[13:36:56.648]                           restarts <- computeRestarts(cond)
[13:36:56.648]                           for (restart in restarts) {
[13:36:56.648]                             name <- restart$name
[13:36:56.648]                             if (is.null(name)) 
[13:36:56.648]                               next
[13:36:56.648]                             if (!grepl(pattern, name)) 
[13:36:56.648]                               next
[13:36:56.648]                             invokeRestart(restart)
[13:36:56.648]                             muffled <- TRUE
[13:36:56.648]                             break
[13:36:56.648]                           }
[13:36:56.648]                         }
[13:36:56.648]                       }
[13:36:56.648]                       invisible(muffled)
[13:36:56.648]                     }
[13:36:56.648]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.648]                   }
[13:36:56.648]                 }
[13:36:56.648]             }
[13:36:56.648]         }))
[13:36:56.648]     }, error = function(ex) {
[13:36:56.648]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.648]                 ...future.rng), started = ...future.startTime, 
[13:36:56.648]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.648]             version = "1.8"), class = "FutureResult")
[13:36:56.648]     }, finally = {
[13:36:56.648]         if (!identical(...future.workdir, getwd())) 
[13:36:56.648]             setwd(...future.workdir)
[13:36:56.648]         {
[13:36:56.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.648]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.648]             }
[13:36:56.648]             base::options(...future.oldOptions)
[13:36:56.648]             if (.Platform$OS.type == "windows") {
[13:36:56.648]                 old_names <- names(...future.oldEnvVars)
[13:36:56.648]                 envs <- base::Sys.getenv()
[13:36:56.648]                 names <- names(envs)
[13:36:56.648]                 common <- intersect(names, old_names)
[13:36:56.648]                 added <- setdiff(names, old_names)
[13:36:56.648]                 removed <- setdiff(old_names, names)
[13:36:56.648]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.648]                   envs[common]]
[13:36:56.648]                 NAMES <- toupper(changed)
[13:36:56.648]                 args <- list()
[13:36:56.648]                 for (kk in seq_along(NAMES)) {
[13:36:56.648]                   name <- changed[[kk]]
[13:36:56.648]                   NAME <- NAMES[[kk]]
[13:36:56.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.648]                     next
[13:36:56.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.648]                 }
[13:36:56.648]                 NAMES <- toupper(added)
[13:36:56.648]                 for (kk in seq_along(NAMES)) {
[13:36:56.648]                   name <- added[[kk]]
[13:36:56.648]                   NAME <- NAMES[[kk]]
[13:36:56.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.648]                     next
[13:36:56.648]                   args[[name]] <- ""
[13:36:56.648]                 }
[13:36:56.648]                 NAMES <- toupper(removed)
[13:36:56.648]                 for (kk in seq_along(NAMES)) {
[13:36:56.648]                   name <- removed[[kk]]
[13:36:56.648]                   NAME <- NAMES[[kk]]
[13:36:56.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.648]                     next
[13:36:56.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.648]                 }
[13:36:56.648]                 if (length(args) > 0) 
[13:36:56.648]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.648]             }
[13:36:56.648]             else {
[13:36:56.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.648]             }
[13:36:56.648]             {
[13:36:56.648]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.648]                   0L) {
[13:36:56.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.648]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.648]                   base::options(opts)
[13:36:56.648]                 }
[13:36:56.648]                 {
[13:36:56.648]                   {
[13:36:56.648]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.648]                     NULL
[13:36:56.648]                   }
[13:36:56.648]                   options(future.plan = NULL)
[13:36:56.648]                   if (is.na(NA_character_)) 
[13:36:56.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.648]                     .init = FALSE)
[13:36:56.648]                 }
[13:36:56.648]             }
[13:36:56.648]         }
[13:36:56.648]     })
[13:36:56.648]     if (TRUE) {
[13:36:56.648]         base::sink(type = "output", split = FALSE)
[13:36:56.648]         if (TRUE) {
[13:36:56.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.648]         }
[13:36:56.648]         else {
[13:36:56.648]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.648]         }
[13:36:56.648]         base::close(...future.stdout)
[13:36:56.648]         ...future.stdout <- NULL
[13:36:56.648]     }
[13:36:56.648]     ...future.result$conditions <- ...future.conditions
[13:36:56.648]     ...future.result$finished <- base::Sys.time()
[13:36:56.648]     ...future.result
[13:36:56.648] }
[13:36:56.651] assign_globals() ...
[13:36:56.651] List of 1
[13:36:56.651]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c6dc7e8010> 
[13:36:56.651]  - attr(*, "where")=List of 1
[13:36:56.651]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.651]  - attr(*, "resolved")= logi TRUE
[13:36:56.651]  - attr(*, "total_size")= num 10816
[13:36:56.651]  - attr(*, "already-done")= logi TRUE
[13:36:56.654] - copied ‘a’ to environment
[13:36:56.654] assign_globals() ... done
[13:36:56.654] requestCore(): workers = 2
[13:36:56.656] MulticoreFuture started
[13:36:56.656] - Launch lazy future ... done
[13:36:56.657] run() for ‘MulticoreFuture’ ... done
[13:36:56.657] result() for MulticoreFuture ...
[13:36:56.658] plan(): Setting new future strategy stack:
[13:36:56.658] List of future strategies:
[13:36:56.658] 1. sequential:
[13:36:56.658]    - args: function (..., envir = parent.frame())
[13:36:56.658]    - tweaked: FALSE
[13:36:56.658]    - call: NULL
[13:36:56.659] plan(): nbrOfWorkers() = 1
[13:36:56.662] plan(): Setting new future strategy stack:
[13:36:56.662] List of future strategies:
[13:36:56.662] 1. multicore:
[13:36:56.662]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.662]    - tweaked: FALSE
[13:36:56.662]    - call: plan(strategy)
[13:36:56.667] plan(): nbrOfWorkers() = 2
[13:36:56.668] result() for MulticoreFuture ...
[13:36:56.668] result() for MulticoreFuture ... done
[13:36:56.668] signalConditions() ...
[13:36:56.669]  - include = ‘immediateCondition’
[13:36:56.669]  - exclude = 
[13:36:56.669]  - resignal = FALSE
[13:36:56.669]  - Number of conditions: 4
[13:36:56.669] signalConditions() ... done
[13:36:56.669] result() for MulticoreFuture ... done
[13:36:56.670] result() for MulticoreFuture ...
[13:36:56.670] result() for MulticoreFuture ... done
[13:36:56.670] signalConditions() ...
[13:36:56.670]  - include = ‘immediateCondition’
[13:36:56.670]  - exclude = 
[13:36:56.670]  - resignal = FALSE
[13:36:56.671]  - Number of conditions: 4
[13:36:56.671] signalConditions() ... done
[13:36:56.671] Future state: ‘finished’
[13:36:56.671] result() for MulticoreFuture ...
[13:36:56.671] result() for MulticoreFuture ... done
[13:36:56.671] signalConditions() ...
[13:36:56.671]  - include = ‘condition’
[13:36:56.671]  - exclude = ‘immediateCondition’
[13:36:56.672]  - resignal = TRUE
[13:36:56.672]  - Number of conditions: 4
[13:36:56.672]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.660] result() for MulticoreFuture ...
[13:36:56.672]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.660] result() for MulticoreFuture ... done
[13:36:56.672]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.661] result() for MulticoreFuture ...
[13:36:56.675]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.661] result() for MulticoreFuture ... done
[13:36:56.675] signalConditions() ... done
value(b) = 2
[13:36:56.676] result() for MulticoreFuture ...
[13:36:56.676] result() for MulticoreFuture ... done
[13:36:56.676] result() for MulticoreFuture ...
[13:36:56.676] result() for MulticoreFuture ... done
[13:36:56.677] signalConditions() ...
[13:36:56.677]  - include = ‘immediateCondition’
[13:36:56.677]  - exclude = 
[13:36:56.677]  - resignal = FALSE
[13:36:56.677]  - Number of conditions: 4
[13:36:56.677] signalConditions() ... done
[13:36:56.678] Future state: ‘finished’
[13:36:56.678] result() for MulticoreFuture ...
[13:36:56.678] result() for MulticoreFuture ... done
[13:36:56.678] signalConditions() ...
[13:36:56.678]  - include = ‘condition’
[13:36:56.678]  - exclude = ‘immediateCondition’
[13:36:56.678]  - resignal = TRUE
[13:36:56.679]  - Number of conditions: 4
[13:36:56.679]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.660] result() for MulticoreFuture ...
[13:36:56.679]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.660] result() for MulticoreFuture ... done
[13:36:56.679]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.661] result() for MulticoreFuture ...
[13:36:56.679]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.661] result() for MulticoreFuture ... done
[13:36:56.679] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.680] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.680] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.681] 
[13:36:56.681] Searching for globals ... DONE
[13:36:56.681] - globals: [0] <none>
[13:36:56.681] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.682] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.682] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.683] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:56.683] Searching for globals ... DONE
[13:36:56.683] Resolving globals: TRUE
[13:36:56.683] Resolving any globals that are futures ...
[13:36:56.684] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:56.684] Resolving any globals that are futures ... DONE
[13:36:56.684] Resolving futures part of globals (recursively) ...
[13:36:56.684] resolve() on list ...
[13:36:56.684]  recursive: 99
[13:36:56.684]  length: 1
[13:36:56.685]  elements: ‘a’
[13:36:56.685] run() for ‘Future’ ...
[13:36:56.685] - state: ‘created’
[13:36:56.685] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.689] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.689] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.689]   - Field: ‘label’
[13:36:56.689]   - Field: ‘local’
[13:36:56.689]   - Field: ‘owner’
[13:36:56.689]   - Field: ‘envir’
[13:36:56.690]   - Field: ‘workers’
[13:36:56.690]   - Field: ‘packages’
[13:36:56.690]   - Field: ‘gc’
[13:36:56.690]   - Field: ‘job’
[13:36:56.690]   - Field: ‘conditions’
[13:36:56.690]   - Field: ‘expr’
[13:36:56.690]   - Field: ‘uuid’
[13:36:56.690]   - Field: ‘seed’
[13:36:56.690]   - Field: ‘version’
[13:36:56.691]   - Field: ‘result’
[13:36:56.691]   - Field: ‘asynchronous’
[13:36:56.691]   - Field: ‘calls’
[13:36:56.691]   - Field: ‘globals’
[13:36:56.691]   - Field: ‘stdout’
[13:36:56.691]   - Field: ‘earlySignal’
[13:36:56.691]   - Field: ‘lazy’
[13:36:56.691]   - Field: ‘state’
[13:36:56.691] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.692] - Launch lazy future ...
[13:36:56.692] Packages needed by the future expression (n = 0): <none>
[13:36:56.692] Packages needed by future strategies (n = 0): <none>
[13:36:56.692] {
[13:36:56.692]     {
[13:36:56.692]         {
[13:36:56.692]             ...future.startTime <- base::Sys.time()
[13:36:56.692]             {
[13:36:56.692]                 {
[13:36:56.692]                   {
[13:36:56.692]                     {
[13:36:56.692]                       base::local({
[13:36:56.692]                         has_future <- base::requireNamespace("future", 
[13:36:56.692]                           quietly = TRUE)
[13:36:56.692]                         if (has_future) {
[13:36:56.692]                           ns <- base::getNamespace("future")
[13:36:56.692]                           version <- ns[[".package"]][["version"]]
[13:36:56.692]                           if (is.null(version)) 
[13:36:56.692]                             version <- utils::packageVersion("future")
[13:36:56.692]                         }
[13:36:56.692]                         else {
[13:36:56.692]                           version <- NULL
[13:36:56.692]                         }
[13:36:56.692]                         if (!has_future || version < "1.8.0") {
[13:36:56.692]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.692]                             "", base::R.version$version.string), 
[13:36:56.692]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.692]                               "release", "version")], collapse = " "), 
[13:36:56.692]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.692]                             info)
[13:36:56.692]                           info <- base::paste(info, collapse = "; ")
[13:36:56.692]                           if (!has_future) {
[13:36:56.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.692]                               info)
[13:36:56.692]                           }
[13:36:56.692]                           else {
[13:36:56.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.692]                               info, version)
[13:36:56.692]                           }
[13:36:56.692]                           base::stop(msg)
[13:36:56.692]                         }
[13:36:56.692]                       })
[13:36:56.692]                     }
[13:36:56.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.692]                     base::options(mc.cores = 1L)
[13:36:56.692]                   }
[13:36:56.692]                   ...future.strategy.old <- future::plan("list")
[13:36:56.692]                   options(future.plan = NULL)
[13:36:56.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.692]                 }
[13:36:56.692]                 ...future.workdir <- getwd()
[13:36:56.692]             }
[13:36:56.692]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.692]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.692]         }
[13:36:56.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.692]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.692]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.692]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.692]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.692]             base::names(...future.oldOptions))
[13:36:56.692]     }
[13:36:56.692]     if (FALSE) {
[13:36:56.692]     }
[13:36:56.692]     else {
[13:36:56.692]         if (TRUE) {
[13:36:56.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.692]                 open = "w")
[13:36:56.692]         }
[13:36:56.692]         else {
[13:36:56.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.692]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.692]         }
[13:36:56.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.692]             base::sink(type = "output", split = FALSE)
[13:36:56.692]             base::close(...future.stdout)
[13:36:56.692]         }, add = TRUE)
[13:36:56.692]     }
[13:36:56.692]     ...future.frame <- base::sys.nframe()
[13:36:56.692]     ...future.conditions <- base::list()
[13:36:56.692]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.692]     if (FALSE) {
[13:36:56.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.692]     }
[13:36:56.692]     ...future.result <- base::tryCatch({
[13:36:56.692]         base::withCallingHandlers({
[13:36:56.692]             ...future.value <- base::withVisible(base::local({
[13:36:56.692]                 withCallingHandlers({
[13:36:56.692]                   1
[13:36:56.692]                 }, immediateCondition = function(cond) {
[13:36:56.692]                   save_rds <- function (object, pathname, ...) 
[13:36:56.692]                   {
[13:36:56.692]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.692]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.692]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.692]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.692]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.692]                         fi_tmp[["mtime"]])
[13:36:56.692]                     }
[13:36:56.692]                     tryCatch({
[13:36:56.692]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.692]                     }, error = function(ex) {
[13:36:56.692]                       msg <- conditionMessage(ex)
[13:36:56.692]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.692]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.692]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.692]                         fi_tmp[["mtime"]], msg)
[13:36:56.692]                       ex$message <- msg
[13:36:56.692]                       stop(ex)
[13:36:56.692]                     })
[13:36:56.692]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.692]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.692]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.692]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.692]                       fi <- file.info(pathname)
[13:36:56.692]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.692]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.692]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.692]                         fi[["size"]], fi[["mtime"]])
[13:36:56.692]                       stop(msg)
[13:36:56.692]                     }
[13:36:56.692]                     invisible(pathname)
[13:36:56.692]                   }
[13:36:56.692]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.692]                     rootPath = tempdir()) 
[13:36:56.692]                   {
[13:36:56.692]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.692]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.692]                       tmpdir = path, fileext = ".rds")
[13:36:56.692]                     save_rds(obj, file)
[13:36:56.692]                   }
[13:36:56.692]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.692]                   {
[13:36:56.692]                     inherits <- base::inherits
[13:36:56.692]                     invokeRestart <- base::invokeRestart
[13:36:56.692]                     is.null <- base::is.null
[13:36:56.692]                     muffled <- FALSE
[13:36:56.692]                     if (inherits(cond, "message")) {
[13:36:56.692]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.692]                       if (muffled) 
[13:36:56.692]                         invokeRestart("muffleMessage")
[13:36:56.692]                     }
[13:36:56.692]                     else if (inherits(cond, "warning")) {
[13:36:56.692]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.692]                       if (muffled) 
[13:36:56.692]                         invokeRestart("muffleWarning")
[13:36:56.692]                     }
[13:36:56.692]                     else if (inherits(cond, "condition")) {
[13:36:56.692]                       if (!is.null(pattern)) {
[13:36:56.692]                         computeRestarts <- base::computeRestarts
[13:36:56.692]                         grepl <- base::grepl
[13:36:56.692]                         restarts <- computeRestarts(cond)
[13:36:56.692]                         for (restart in restarts) {
[13:36:56.692]                           name <- restart$name
[13:36:56.692]                           if (is.null(name)) 
[13:36:56.692]                             next
[13:36:56.692]                           if (!grepl(pattern, name)) 
[13:36:56.692]                             next
[13:36:56.692]                           invokeRestart(restart)
[13:36:56.692]                           muffled <- TRUE
[13:36:56.692]                           break
[13:36:56.692]                         }
[13:36:56.692]                       }
[13:36:56.692]                     }
[13:36:56.692]                     invisible(muffled)
[13:36:56.692]                   }
[13:36:56.692]                   muffleCondition(cond)
[13:36:56.692]                 })
[13:36:56.692]             }))
[13:36:56.692]             future::FutureResult(value = ...future.value$value, 
[13:36:56.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.692]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.692]                     ...future.globalenv.names))
[13:36:56.692]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.692]         }, condition = base::local({
[13:36:56.692]             c <- base::c
[13:36:56.692]             inherits <- base::inherits
[13:36:56.692]             invokeRestart <- base::invokeRestart
[13:36:56.692]             length <- base::length
[13:36:56.692]             list <- base::list
[13:36:56.692]             seq.int <- base::seq.int
[13:36:56.692]             signalCondition <- base::signalCondition
[13:36:56.692]             sys.calls <- base::sys.calls
[13:36:56.692]             `[[` <- base::`[[`
[13:36:56.692]             `+` <- base::`+`
[13:36:56.692]             `<<-` <- base::`<<-`
[13:36:56.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.692]                   3L)]
[13:36:56.692]             }
[13:36:56.692]             function(cond) {
[13:36:56.692]                 is_error <- inherits(cond, "error")
[13:36:56.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.692]                   NULL)
[13:36:56.692]                 if (is_error) {
[13:36:56.692]                   sessionInformation <- function() {
[13:36:56.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.692]                       search = base::search(), system = base::Sys.info())
[13:36:56.692]                   }
[13:36:56.692]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.692]                     cond$call), session = sessionInformation(), 
[13:36:56.692]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.692]                   signalCondition(cond)
[13:36:56.692]                 }
[13:36:56.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.692]                 "immediateCondition"))) {
[13:36:56.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.692]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.692]                   if (TRUE && !signal) {
[13:36:56.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.692]                     {
[13:36:56.692]                       inherits <- base::inherits
[13:36:56.692]                       invokeRestart <- base::invokeRestart
[13:36:56.692]                       is.null <- base::is.null
[13:36:56.692]                       muffled <- FALSE
[13:36:56.692]                       if (inherits(cond, "message")) {
[13:36:56.692]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.692]                         if (muffled) 
[13:36:56.692]                           invokeRestart("muffleMessage")
[13:36:56.692]                       }
[13:36:56.692]                       else if (inherits(cond, "warning")) {
[13:36:56.692]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.692]                         if (muffled) 
[13:36:56.692]                           invokeRestart("muffleWarning")
[13:36:56.692]                       }
[13:36:56.692]                       else if (inherits(cond, "condition")) {
[13:36:56.692]                         if (!is.null(pattern)) {
[13:36:56.692]                           computeRestarts <- base::computeRestarts
[13:36:56.692]                           grepl <- base::grepl
[13:36:56.692]                           restarts <- computeRestarts(cond)
[13:36:56.692]                           for (restart in restarts) {
[13:36:56.692]                             name <- restart$name
[13:36:56.692]                             if (is.null(name)) 
[13:36:56.692]                               next
[13:36:56.692]                             if (!grepl(pattern, name)) 
[13:36:56.692]                               next
[13:36:56.692]                             invokeRestart(restart)
[13:36:56.692]                             muffled <- TRUE
[13:36:56.692]                             break
[13:36:56.692]                           }
[13:36:56.692]                         }
[13:36:56.692]                       }
[13:36:56.692]                       invisible(muffled)
[13:36:56.692]                     }
[13:36:56.692]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.692]                   }
[13:36:56.692]                 }
[13:36:56.692]                 else {
[13:36:56.692]                   if (TRUE) {
[13:36:56.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.692]                     {
[13:36:56.692]                       inherits <- base::inherits
[13:36:56.692]                       invokeRestart <- base::invokeRestart
[13:36:56.692]                       is.null <- base::is.null
[13:36:56.692]                       muffled <- FALSE
[13:36:56.692]                       if (inherits(cond, "message")) {
[13:36:56.692]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.692]                         if (muffled) 
[13:36:56.692]                           invokeRestart("muffleMessage")
[13:36:56.692]                       }
[13:36:56.692]                       else if (inherits(cond, "warning")) {
[13:36:56.692]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.692]                         if (muffled) 
[13:36:56.692]                           invokeRestart("muffleWarning")
[13:36:56.692]                       }
[13:36:56.692]                       else if (inherits(cond, "condition")) {
[13:36:56.692]                         if (!is.null(pattern)) {
[13:36:56.692]                           computeRestarts <- base::computeRestarts
[13:36:56.692]                           grepl <- base::grepl
[13:36:56.692]                           restarts <- computeRestarts(cond)
[13:36:56.692]                           for (restart in restarts) {
[13:36:56.692]                             name <- restart$name
[13:36:56.692]                             if (is.null(name)) 
[13:36:56.692]                               next
[13:36:56.692]                             if (!grepl(pattern, name)) 
[13:36:56.692]                               next
[13:36:56.692]                             invokeRestart(restart)
[13:36:56.692]                             muffled <- TRUE
[13:36:56.692]                             break
[13:36:56.692]                           }
[13:36:56.692]                         }
[13:36:56.692]                       }
[13:36:56.692]                       invisible(muffled)
[13:36:56.692]                     }
[13:36:56.692]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.692]                   }
[13:36:56.692]                 }
[13:36:56.692]             }
[13:36:56.692]         }))
[13:36:56.692]     }, error = function(ex) {
[13:36:56.692]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.692]                 ...future.rng), started = ...future.startTime, 
[13:36:56.692]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.692]             version = "1.8"), class = "FutureResult")
[13:36:56.692]     }, finally = {
[13:36:56.692]         if (!identical(...future.workdir, getwd())) 
[13:36:56.692]             setwd(...future.workdir)
[13:36:56.692]         {
[13:36:56.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.692]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.692]             }
[13:36:56.692]             base::options(...future.oldOptions)
[13:36:56.692]             if (.Platform$OS.type == "windows") {
[13:36:56.692]                 old_names <- names(...future.oldEnvVars)
[13:36:56.692]                 envs <- base::Sys.getenv()
[13:36:56.692]                 names <- names(envs)
[13:36:56.692]                 common <- intersect(names, old_names)
[13:36:56.692]                 added <- setdiff(names, old_names)
[13:36:56.692]                 removed <- setdiff(old_names, names)
[13:36:56.692]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.692]                   envs[common]]
[13:36:56.692]                 NAMES <- toupper(changed)
[13:36:56.692]                 args <- list()
[13:36:56.692]                 for (kk in seq_along(NAMES)) {
[13:36:56.692]                   name <- changed[[kk]]
[13:36:56.692]                   NAME <- NAMES[[kk]]
[13:36:56.692]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.692]                     next
[13:36:56.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.692]                 }
[13:36:56.692]                 NAMES <- toupper(added)
[13:36:56.692]                 for (kk in seq_along(NAMES)) {
[13:36:56.692]                   name <- added[[kk]]
[13:36:56.692]                   NAME <- NAMES[[kk]]
[13:36:56.692]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.692]                     next
[13:36:56.692]                   args[[name]] <- ""
[13:36:56.692]                 }
[13:36:56.692]                 NAMES <- toupper(removed)
[13:36:56.692]                 for (kk in seq_along(NAMES)) {
[13:36:56.692]                   name <- removed[[kk]]
[13:36:56.692]                   NAME <- NAMES[[kk]]
[13:36:56.692]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.692]                     next
[13:36:56.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.692]                 }
[13:36:56.692]                 if (length(args) > 0) 
[13:36:56.692]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.692]             }
[13:36:56.692]             else {
[13:36:56.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.692]             }
[13:36:56.692]             {
[13:36:56.692]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.692]                   0L) {
[13:36:56.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.692]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.692]                   base::options(opts)
[13:36:56.692]                 }
[13:36:56.692]                 {
[13:36:56.692]                   {
[13:36:56.692]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.692]                     NULL
[13:36:56.692]                   }
[13:36:56.692]                   options(future.plan = NULL)
[13:36:56.692]                   if (is.na(NA_character_)) 
[13:36:56.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.692]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.692]                     .init = FALSE)
[13:36:56.692]                 }
[13:36:56.692]             }
[13:36:56.692]         }
[13:36:56.692]     })
[13:36:56.692]     if (TRUE) {
[13:36:56.692]         base::sink(type = "output", split = FALSE)
[13:36:56.692]         if (TRUE) {
[13:36:56.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.692]         }
[13:36:56.692]         else {
[13:36:56.692]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.692]         }
[13:36:56.692]         base::close(...future.stdout)
[13:36:56.692]         ...future.stdout <- NULL
[13:36:56.692]     }
[13:36:56.692]     ...future.result$conditions <- ...future.conditions
[13:36:56.692]     ...future.result$finished <- base::Sys.time()
[13:36:56.692]     ...future.result
[13:36:56.692] }
[13:36:56.695] requestCore(): workers = 2
[13:36:56.696] MulticoreFuture started
[13:36:56.697] - Launch lazy future ... done
[13:36:56.697] run() for ‘MulticoreFuture’ ... done
[13:36:56.698] plan(): Setting new future strategy stack:
[13:36:56.698] List of future strategies:
[13:36:56.698] 1. sequential:
[13:36:56.698]    - args: function (..., envir = parent.frame())
[13:36:56.698]    - tweaked: FALSE
[13:36:56.698]    - call: NULL
[13:36:56.699] plan(): nbrOfWorkers() = 1
[13:36:56.701] plan(): Setting new future strategy stack:
[13:36:56.701] List of future strategies:
[13:36:56.701] 1. multicore:
[13:36:56.701]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.701]    - tweaked: FALSE
[13:36:56.701]    - call: plan(strategy)
[13:36:56.706] plan(): nbrOfWorkers() = 2
[13:36:56.706] Future #1
[13:36:56.707] result() for MulticoreFuture ...
[13:36:56.708] result() for MulticoreFuture ...
[13:36:56.708] result() for MulticoreFuture ... done
[13:36:56.708] result() for MulticoreFuture ... done
[13:36:56.708] result() for MulticoreFuture ...
[13:36:56.708] result() for MulticoreFuture ... done
[13:36:56.709] A MulticoreFuture was resolved
[13:36:56.709]  length: 0 (resolved future 1)
[13:36:56.709] resolve() on list ... DONE
[13:36:56.709] - globals: [1] ‘a’
[13:36:56.709] Resolving futures part of globals (recursively) ... DONE
[13:36:56.711] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[13:36:56.711] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[13:36:56.711] - globals: [1] ‘a’
[13:36:56.712] - packages: [1] ‘future’
[13:36:56.712] getGlobalsAndPackages() ... DONE
[13:36:56.712] run() for ‘Future’ ...
[13:36:56.712] - state: ‘created’
[13:36:56.712] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.718] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.719]   - Field: ‘label’
[13:36:56.719]   - Field: ‘local’
[13:36:56.719]   - Field: ‘owner’
[13:36:56.720]   - Field: ‘envir’
[13:36:56.720]   - Field: ‘workers’
[13:36:56.720]   - Field: ‘packages’
[13:36:56.720]   - Field: ‘gc’
[13:36:56.720]   - Field: ‘job’
[13:36:56.720]   - Field: ‘conditions’
[13:36:56.720]   - Field: ‘expr’
[13:36:56.721]   - Field: ‘uuid’
[13:36:56.721]   - Field: ‘seed’
[13:36:56.721]   - Field: ‘version’
[13:36:56.721]   - Field: ‘result’
[13:36:56.721]   - Field: ‘asynchronous’
[13:36:56.721]   - Field: ‘calls’
[13:36:56.721]   - Field: ‘globals’
[13:36:56.722]   - Field: ‘stdout’
[13:36:56.722]   - Field: ‘earlySignal’
[13:36:56.722]   - Field: ‘lazy’
[13:36:56.722]   - Field: ‘state’
[13:36:56.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.722] - Launch lazy future ...
[13:36:56.723] Packages needed by the future expression (n = 1): ‘future’
[13:36:56.723] Packages needed by future strategies (n = 0): <none>
[13:36:56.723] {
[13:36:56.723]     {
[13:36:56.723]         {
[13:36:56.723]             ...future.startTime <- base::Sys.time()
[13:36:56.723]             {
[13:36:56.723]                 {
[13:36:56.723]                   {
[13:36:56.723]                     {
[13:36:56.723]                       {
[13:36:56.723]                         base::local({
[13:36:56.723]                           has_future <- base::requireNamespace("future", 
[13:36:56.723]                             quietly = TRUE)
[13:36:56.723]                           if (has_future) {
[13:36:56.723]                             ns <- base::getNamespace("future")
[13:36:56.723]                             version <- ns[[".package"]][["version"]]
[13:36:56.723]                             if (is.null(version)) 
[13:36:56.723]                               version <- utils::packageVersion("future")
[13:36:56.723]                           }
[13:36:56.723]                           else {
[13:36:56.723]                             version <- NULL
[13:36:56.723]                           }
[13:36:56.723]                           if (!has_future || version < "1.8.0") {
[13:36:56.723]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.723]                               "", base::R.version$version.string), 
[13:36:56.723]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:56.723]                                 base::R.version$platform, 8 * 
[13:36:56.723]                                   base::.Machine$sizeof.pointer), 
[13:36:56.723]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.723]                                 "release", "version")], collapse = " "), 
[13:36:56.723]                               hostname = base::Sys.info()[["nodename"]])
[13:36:56.723]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.723]                               info)
[13:36:56.723]                             info <- base::paste(info, collapse = "; ")
[13:36:56.723]                             if (!has_future) {
[13:36:56.723]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.723]                                 info)
[13:36:56.723]                             }
[13:36:56.723]                             else {
[13:36:56.723]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.723]                                 info, version)
[13:36:56.723]                             }
[13:36:56.723]                             base::stop(msg)
[13:36:56.723]                           }
[13:36:56.723]                         })
[13:36:56.723]                       }
[13:36:56.723]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.723]                       base::options(mc.cores = 1L)
[13:36:56.723]                     }
[13:36:56.723]                     base::local({
[13:36:56.723]                       for (pkg in "future") {
[13:36:56.723]                         base::loadNamespace(pkg)
[13:36:56.723]                         base::library(pkg, character.only = TRUE)
[13:36:56.723]                       }
[13:36:56.723]                     })
[13:36:56.723]                   }
[13:36:56.723]                   ...future.strategy.old <- future::plan("list")
[13:36:56.723]                   options(future.plan = NULL)
[13:36:56.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.723]                 }
[13:36:56.723]                 ...future.workdir <- getwd()
[13:36:56.723]             }
[13:36:56.723]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.723]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.723]         }
[13:36:56.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.723]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.723]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.723]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.723]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.723]             base::names(...future.oldOptions))
[13:36:56.723]     }
[13:36:56.723]     if (FALSE) {
[13:36:56.723]     }
[13:36:56.723]     else {
[13:36:56.723]         if (TRUE) {
[13:36:56.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.723]                 open = "w")
[13:36:56.723]         }
[13:36:56.723]         else {
[13:36:56.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.723]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.723]         }
[13:36:56.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.723]             base::sink(type = "output", split = FALSE)
[13:36:56.723]             base::close(...future.stdout)
[13:36:56.723]         }, add = TRUE)
[13:36:56.723]     }
[13:36:56.723]     ...future.frame <- base::sys.nframe()
[13:36:56.723]     ...future.conditions <- base::list()
[13:36:56.723]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.723]     if (FALSE) {
[13:36:56.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.723]     }
[13:36:56.723]     ...future.result <- base::tryCatch({
[13:36:56.723]         base::withCallingHandlers({
[13:36:56.723]             ...future.value <- base::withVisible(base::local({
[13:36:56.723]                 withCallingHandlers({
[13:36:56.723]                   value(a) + 1
[13:36:56.723]                 }, immediateCondition = function(cond) {
[13:36:56.723]                   save_rds <- function (object, pathname, ...) 
[13:36:56.723]                   {
[13:36:56.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.723]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.723]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.723]                         fi_tmp[["mtime"]])
[13:36:56.723]                     }
[13:36:56.723]                     tryCatch({
[13:36:56.723]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.723]                     }, error = function(ex) {
[13:36:56.723]                       msg <- conditionMessage(ex)
[13:36:56.723]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.723]                         fi_tmp[["mtime"]], msg)
[13:36:56.723]                       ex$message <- msg
[13:36:56.723]                       stop(ex)
[13:36:56.723]                     })
[13:36:56.723]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.723]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.723]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.723]                       fi <- file.info(pathname)
[13:36:56.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.723]                         fi[["size"]], fi[["mtime"]])
[13:36:56.723]                       stop(msg)
[13:36:56.723]                     }
[13:36:56.723]                     invisible(pathname)
[13:36:56.723]                   }
[13:36:56.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.723]                     rootPath = tempdir()) 
[13:36:56.723]                   {
[13:36:56.723]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.723]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.723]                       tmpdir = path, fileext = ".rds")
[13:36:56.723]                     save_rds(obj, file)
[13:36:56.723]                   }
[13:36:56.723]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.723]                   {
[13:36:56.723]                     inherits <- base::inherits
[13:36:56.723]                     invokeRestart <- base::invokeRestart
[13:36:56.723]                     is.null <- base::is.null
[13:36:56.723]                     muffled <- FALSE
[13:36:56.723]                     if (inherits(cond, "message")) {
[13:36:56.723]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.723]                       if (muffled) 
[13:36:56.723]                         invokeRestart("muffleMessage")
[13:36:56.723]                     }
[13:36:56.723]                     else if (inherits(cond, "warning")) {
[13:36:56.723]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.723]                       if (muffled) 
[13:36:56.723]                         invokeRestart("muffleWarning")
[13:36:56.723]                     }
[13:36:56.723]                     else if (inherits(cond, "condition")) {
[13:36:56.723]                       if (!is.null(pattern)) {
[13:36:56.723]                         computeRestarts <- base::computeRestarts
[13:36:56.723]                         grepl <- base::grepl
[13:36:56.723]                         restarts <- computeRestarts(cond)
[13:36:56.723]                         for (restart in restarts) {
[13:36:56.723]                           name <- restart$name
[13:36:56.723]                           if (is.null(name)) 
[13:36:56.723]                             next
[13:36:56.723]                           if (!grepl(pattern, name)) 
[13:36:56.723]                             next
[13:36:56.723]                           invokeRestart(restart)
[13:36:56.723]                           muffled <- TRUE
[13:36:56.723]                           break
[13:36:56.723]                         }
[13:36:56.723]                       }
[13:36:56.723]                     }
[13:36:56.723]                     invisible(muffled)
[13:36:56.723]                   }
[13:36:56.723]                   muffleCondition(cond)
[13:36:56.723]                 })
[13:36:56.723]             }))
[13:36:56.723]             future::FutureResult(value = ...future.value$value, 
[13:36:56.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.723]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.723]                     ...future.globalenv.names))
[13:36:56.723]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.723]         }, condition = base::local({
[13:36:56.723]             c <- base::c
[13:36:56.723]             inherits <- base::inherits
[13:36:56.723]             invokeRestart <- base::invokeRestart
[13:36:56.723]             length <- base::length
[13:36:56.723]             list <- base::list
[13:36:56.723]             seq.int <- base::seq.int
[13:36:56.723]             signalCondition <- base::signalCondition
[13:36:56.723]             sys.calls <- base::sys.calls
[13:36:56.723]             `[[` <- base::`[[`
[13:36:56.723]             `+` <- base::`+`
[13:36:56.723]             `<<-` <- base::`<<-`
[13:36:56.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.723]                   3L)]
[13:36:56.723]             }
[13:36:56.723]             function(cond) {
[13:36:56.723]                 is_error <- inherits(cond, "error")
[13:36:56.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.723]                   NULL)
[13:36:56.723]                 if (is_error) {
[13:36:56.723]                   sessionInformation <- function() {
[13:36:56.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.723]                       search = base::search(), system = base::Sys.info())
[13:36:56.723]                   }
[13:36:56.723]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.723]                     cond$call), session = sessionInformation(), 
[13:36:56.723]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.723]                   signalCondition(cond)
[13:36:56.723]                 }
[13:36:56.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.723]                 "immediateCondition"))) {
[13:36:56.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.723]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.723]                   if (TRUE && !signal) {
[13:36:56.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.723]                     {
[13:36:56.723]                       inherits <- base::inherits
[13:36:56.723]                       invokeRestart <- base::invokeRestart
[13:36:56.723]                       is.null <- base::is.null
[13:36:56.723]                       muffled <- FALSE
[13:36:56.723]                       if (inherits(cond, "message")) {
[13:36:56.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.723]                         if (muffled) 
[13:36:56.723]                           invokeRestart("muffleMessage")
[13:36:56.723]                       }
[13:36:56.723]                       else if (inherits(cond, "warning")) {
[13:36:56.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.723]                         if (muffled) 
[13:36:56.723]                           invokeRestart("muffleWarning")
[13:36:56.723]                       }
[13:36:56.723]                       else if (inherits(cond, "condition")) {
[13:36:56.723]                         if (!is.null(pattern)) {
[13:36:56.723]                           computeRestarts <- base::computeRestarts
[13:36:56.723]                           grepl <- base::grepl
[13:36:56.723]                           restarts <- computeRestarts(cond)
[13:36:56.723]                           for (restart in restarts) {
[13:36:56.723]                             name <- restart$name
[13:36:56.723]                             if (is.null(name)) 
[13:36:56.723]                               next
[13:36:56.723]                             if (!grepl(pattern, name)) 
[13:36:56.723]                               next
[13:36:56.723]                             invokeRestart(restart)
[13:36:56.723]                             muffled <- TRUE
[13:36:56.723]                             break
[13:36:56.723]                           }
[13:36:56.723]                         }
[13:36:56.723]                       }
[13:36:56.723]                       invisible(muffled)
[13:36:56.723]                     }
[13:36:56.723]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.723]                   }
[13:36:56.723]                 }
[13:36:56.723]                 else {
[13:36:56.723]                   if (TRUE) {
[13:36:56.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.723]                     {
[13:36:56.723]                       inherits <- base::inherits
[13:36:56.723]                       invokeRestart <- base::invokeRestart
[13:36:56.723]                       is.null <- base::is.null
[13:36:56.723]                       muffled <- FALSE
[13:36:56.723]                       if (inherits(cond, "message")) {
[13:36:56.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.723]                         if (muffled) 
[13:36:56.723]                           invokeRestart("muffleMessage")
[13:36:56.723]                       }
[13:36:56.723]                       else if (inherits(cond, "warning")) {
[13:36:56.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.723]                         if (muffled) 
[13:36:56.723]                           invokeRestart("muffleWarning")
[13:36:56.723]                       }
[13:36:56.723]                       else if (inherits(cond, "condition")) {
[13:36:56.723]                         if (!is.null(pattern)) {
[13:36:56.723]                           computeRestarts <- base::computeRestarts
[13:36:56.723]                           grepl <- base::grepl
[13:36:56.723]                           restarts <- computeRestarts(cond)
[13:36:56.723]                           for (restart in restarts) {
[13:36:56.723]                             name <- restart$name
[13:36:56.723]                             if (is.null(name)) 
[13:36:56.723]                               next
[13:36:56.723]                             if (!grepl(pattern, name)) 
[13:36:56.723]                               next
[13:36:56.723]                             invokeRestart(restart)
[13:36:56.723]                             muffled <- TRUE
[13:36:56.723]                             break
[13:36:56.723]                           }
[13:36:56.723]                         }
[13:36:56.723]                       }
[13:36:56.723]                       invisible(muffled)
[13:36:56.723]                     }
[13:36:56.723]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.723]                   }
[13:36:56.723]                 }
[13:36:56.723]             }
[13:36:56.723]         }))
[13:36:56.723]     }, error = function(ex) {
[13:36:56.723]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.723]                 ...future.rng), started = ...future.startTime, 
[13:36:56.723]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.723]             version = "1.8"), class = "FutureResult")
[13:36:56.723]     }, finally = {
[13:36:56.723]         if (!identical(...future.workdir, getwd())) 
[13:36:56.723]             setwd(...future.workdir)
[13:36:56.723]         {
[13:36:56.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.723]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.723]             }
[13:36:56.723]             base::options(...future.oldOptions)
[13:36:56.723]             if (.Platform$OS.type == "windows") {
[13:36:56.723]                 old_names <- names(...future.oldEnvVars)
[13:36:56.723]                 envs <- base::Sys.getenv()
[13:36:56.723]                 names <- names(envs)
[13:36:56.723]                 common <- intersect(names, old_names)
[13:36:56.723]                 added <- setdiff(names, old_names)
[13:36:56.723]                 removed <- setdiff(old_names, names)
[13:36:56.723]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.723]                   envs[common]]
[13:36:56.723]                 NAMES <- toupper(changed)
[13:36:56.723]                 args <- list()
[13:36:56.723]                 for (kk in seq_along(NAMES)) {
[13:36:56.723]                   name <- changed[[kk]]
[13:36:56.723]                   NAME <- NAMES[[kk]]
[13:36:56.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.723]                     next
[13:36:56.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.723]                 }
[13:36:56.723]                 NAMES <- toupper(added)
[13:36:56.723]                 for (kk in seq_along(NAMES)) {
[13:36:56.723]                   name <- added[[kk]]
[13:36:56.723]                   NAME <- NAMES[[kk]]
[13:36:56.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.723]                     next
[13:36:56.723]                   args[[name]] <- ""
[13:36:56.723]                 }
[13:36:56.723]                 NAMES <- toupper(removed)
[13:36:56.723]                 for (kk in seq_along(NAMES)) {
[13:36:56.723]                   name <- removed[[kk]]
[13:36:56.723]                   NAME <- NAMES[[kk]]
[13:36:56.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.723]                     next
[13:36:56.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.723]                 }
[13:36:56.723]                 if (length(args) > 0) 
[13:36:56.723]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.723]             }
[13:36:56.723]             else {
[13:36:56.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.723]             }
[13:36:56.723]             {
[13:36:56.723]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.723]                   0L) {
[13:36:56.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.723]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.723]                   base::options(opts)
[13:36:56.723]                 }
[13:36:56.723]                 {
[13:36:56.723]                   {
[13:36:56.723]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.723]                     NULL
[13:36:56.723]                   }
[13:36:56.723]                   options(future.plan = NULL)
[13:36:56.723]                   if (is.na(NA_character_)) 
[13:36:56.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.723]                     .init = FALSE)
[13:36:56.723]                 }
[13:36:56.723]             }
[13:36:56.723]         }
[13:36:56.723]     })
[13:36:56.723]     if (TRUE) {
[13:36:56.723]         base::sink(type = "output", split = FALSE)
[13:36:56.723]         if (TRUE) {
[13:36:56.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.723]         }
[13:36:56.723]         else {
[13:36:56.723]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.723]         }
[13:36:56.723]         base::close(...future.stdout)
[13:36:56.723]         ...future.stdout <- NULL
[13:36:56.723]     }
[13:36:56.723]     ...future.result$conditions <- ...future.conditions
[13:36:56.723]     ...future.result$finished <- base::Sys.time()
[13:36:56.723]     ...future.result
[13:36:56.723] }
[13:36:56.726] assign_globals() ...
[13:36:56.726] List of 1
[13:36:56.726]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c6dac43c10> 
[13:36:56.726]  - attr(*, "where")=List of 1
[13:36:56.726]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.726]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.726]  - attr(*, "resolved")= logi TRUE
[13:36:56.726]  - attr(*, "total_size")= num 10984
[13:36:56.726]  - attr(*, "already-done")= logi TRUE
[13:36:56.729] - copied ‘a’ to environment
[13:36:56.729] assign_globals() ... done
[13:36:56.729] requestCore(): workers = 2
[13:36:56.731] MulticoreFuture started
[13:36:56.731] - Launch lazy future ... done
[13:36:56.731] run() for ‘MulticoreFuture’ ... done
[13:36:56.732] result() for MulticoreFuture ...
[13:36:56.732] plan(): Setting new future strategy stack:
[13:36:56.733] List of future strategies:
[13:36:56.733] 1. sequential:
[13:36:56.733]    - args: function (..., envir = parent.frame())
[13:36:56.733]    - tweaked: FALSE
[13:36:56.733]    - call: NULL
[13:36:56.733] plan(): nbrOfWorkers() = 1
[13:36:56.737] plan(): Setting new future strategy stack:
[13:36:56.737] List of future strategies:
[13:36:56.737] 1. multicore:
[13:36:56.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.737]    - tweaked: FALSE
[13:36:56.737]    - call: plan(strategy)
[13:36:56.742] plan(): nbrOfWorkers() = 2
[13:36:56.743] result() for MulticoreFuture ...
[13:36:56.743] result() for MulticoreFuture ... done
[13:36:56.743] signalConditions() ...
[13:36:56.743]  - include = ‘immediateCondition’
[13:36:56.744]  - exclude = 
[13:36:56.744]  - resignal = FALSE
[13:36:56.744]  - Number of conditions: 4
[13:36:56.744] signalConditions() ... done
[13:36:56.744] result() for MulticoreFuture ... done
[13:36:56.744] result() for MulticoreFuture ...
[13:36:56.745] result() for MulticoreFuture ... done
[13:36:56.745] signalConditions() ...
[13:36:56.745]  - include = ‘immediateCondition’
[13:36:56.745]  - exclude = 
[13:36:56.745]  - resignal = FALSE
[13:36:56.745]  - Number of conditions: 4
[13:36:56.745] signalConditions() ... done
[13:36:56.746] Future state: ‘finished’
[13:36:56.746] result() for MulticoreFuture ...
[13:36:56.746] result() for MulticoreFuture ... done
[13:36:56.746] signalConditions() ...
[13:36:56.746]  - include = ‘condition’
[13:36:56.746]  - exclude = ‘immediateCondition’
[13:36:56.746]  - resignal = TRUE
[13:36:56.746]  - Number of conditions: 4
[13:36:56.747]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.735] result() for MulticoreFuture ...
[13:36:56.747]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.735] result() for MulticoreFuture ... done
[13:36:56.747]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.735] result() for MulticoreFuture ...
[13:36:56.747]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.736] result() for MulticoreFuture ... done
[13:36:56.747] signalConditions() ... done
value(b) = 2
[13:36:56.748] result() for MulticoreFuture ...
[13:36:56.748] result() for MulticoreFuture ... done
[13:36:56.748] result() for MulticoreFuture ...
[13:36:56.748] result() for MulticoreFuture ... done
[13:36:56.748] signalConditions() ...
[13:36:56.748]  - include = ‘immediateCondition’
[13:36:56.748]  - exclude = 
[13:36:56.748]  - resignal = FALSE
[13:36:56.748]  - Number of conditions: 4
[13:36:56.748] signalConditions() ... done
[13:36:56.749] Future state: ‘finished’
[13:36:56.749] result() for MulticoreFuture ...
[13:36:56.749] result() for MulticoreFuture ... done
[13:36:56.749] signalConditions() ...
[13:36:56.749]  - include = ‘condition’
[13:36:56.749]  - exclude = ‘immediateCondition’
[13:36:56.749]  - resignal = TRUE
[13:36:56.749]  - Number of conditions: 4
[13:36:56.749]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.735] result() for MulticoreFuture ...
[13:36:56.750]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.735] result() for MulticoreFuture ... done
[13:36:56.750]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.735] result() for MulticoreFuture ...
[13:36:56.750]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.736] result() for MulticoreFuture ... done
[13:36:56.750] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.750] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.751] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.751] 
[13:36:56.751] Searching for globals ... DONE
[13:36:56.752] - globals: [0] <none>
[13:36:56.752] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.752] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.752] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.753] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:56.754] Searching for globals ... DONE
[13:36:56.754] Resolving globals: TRUE
[13:36:56.754] Resolving any globals that are futures ...
[13:36:56.754] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:56.754] Resolving any globals that are futures ... DONE
[13:36:56.754] Resolving futures part of globals (recursively) ...
[13:36:56.755] resolve() on list ...
[13:36:56.755]  recursive: 99
[13:36:56.755]  length: 1
[13:36:56.755]  elements: ‘a’
[13:36:56.755] run() for ‘Future’ ...
[13:36:56.757] - state: ‘created’
[13:36:56.758] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.763]   - Field: ‘label’
[13:36:56.763]   - Field: ‘local’
[13:36:56.763]   - Field: ‘owner’
[13:36:56.763]   - Field: ‘envir’
[13:36:56.763]   - Field: ‘workers’
[13:36:56.763]   - Field: ‘packages’
[13:36:56.763]   - Field: ‘gc’
[13:36:56.763]   - Field: ‘job’
[13:36:56.764]   - Field: ‘conditions’
[13:36:56.764]   - Field: ‘expr’
[13:36:56.764]   - Field: ‘uuid’
[13:36:56.764]   - Field: ‘seed’
[13:36:56.764]   - Field: ‘version’
[13:36:56.764]   - Field: ‘result’
[13:36:56.764]   - Field: ‘asynchronous’
[13:36:56.764]   - Field: ‘calls’
[13:36:56.765]   - Field: ‘globals’
[13:36:56.765]   - Field: ‘stdout’
[13:36:56.765]   - Field: ‘earlySignal’
[13:36:56.765]   - Field: ‘lazy’
[13:36:56.765]   - Field: ‘state’
[13:36:56.765] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.765] - Launch lazy future ...
[13:36:56.766] Packages needed by the future expression (n = 0): <none>
[13:36:56.766] Packages needed by future strategies (n = 0): <none>
[13:36:56.766] {
[13:36:56.766]     {
[13:36:56.766]         {
[13:36:56.766]             ...future.startTime <- base::Sys.time()
[13:36:56.766]             {
[13:36:56.766]                 {
[13:36:56.766]                   {
[13:36:56.766]                     {
[13:36:56.766]                       base::local({
[13:36:56.766]                         has_future <- base::requireNamespace("future", 
[13:36:56.766]                           quietly = TRUE)
[13:36:56.766]                         if (has_future) {
[13:36:56.766]                           ns <- base::getNamespace("future")
[13:36:56.766]                           version <- ns[[".package"]][["version"]]
[13:36:56.766]                           if (is.null(version)) 
[13:36:56.766]                             version <- utils::packageVersion("future")
[13:36:56.766]                         }
[13:36:56.766]                         else {
[13:36:56.766]                           version <- NULL
[13:36:56.766]                         }
[13:36:56.766]                         if (!has_future || version < "1.8.0") {
[13:36:56.766]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.766]                             "", base::R.version$version.string), 
[13:36:56.766]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.766]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.766]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.766]                               "release", "version")], collapse = " "), 
[13:36:56.766]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.766]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.766]                             info)
[13:36:56.766]                           info <- base::paste(info, collapse = "; ")
[13:36:56.766]                           if (!has_future) {
[13:36:56.766]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.766]                               info)
[13:36:56.766]                           }
[13:36:56.766]                           else {
[13:36:56.766]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.766]                               info, version)
[13:36:56.766]                           }
[13:36:56.766]                           base::stop(msg)
[13:36:56.766]                         }
[13:36:56.766]                       })
[13:36:56.766]                     }
[13:36:56.766]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.766]                     base::options(mc.cores = 1L)
[13:36:56.766]                   }
[13:36:56.766]                   ...future.strategy.old <- future::plan("list")
[13:36:56.766]                   options(future.plan = NULL)
[13:36:56.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.766]                 }
[13:36:56.766]                 ...future.workdir <- getwd()
[13:36:56.766]             }
[13:36:56.766]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.766]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.766]         }
[13:36:56.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.766]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.766]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.766]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.766]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.766]             base::names(...future.oldOptions))
[13:36:56.766]     }
[13:36:56.766]     if (FALSE) {
[13:36:56.766]     }
[13:36:56.766]     else {
[13:36:56.766]         if (TRUE) {
[13:36:56.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.766]                 open = "w")
[13:36:56.766]         }
[13:36:56.766]         else {
[13:36:56.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.766]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.766]         }
[13:36:56.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.766]             base::sink(type = "output", split = FALSE)
[13:36:56.766]             base::close(...future.stdout)
[13:36:56.766]         }, add = TRUE)
[13:36:56.766]     }
[13:36:56.766]     ...future.frame <- base::sys.nframe()
[13:36:56.766]     ...future.conditions <- base::list()
[13:36:56.766]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.766]     if (FALSE) {
[13:36:56.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.766]     }
[13:36:56.766]     ...future.result <- base::tryCatch({
[13:36:56.766]         base::withCallingHandlers({
[13:36:56.766]             ...future.value <- base::withVisible(base::local({
[13:36:56.766]                 withCallingHandlers({
[13:36:56.766]                   1
[13:36:56.766]                 }, immediateCondition = function(cond) {
[13:36:56.766]                   save_rds <- function (object, pathname, ...) 
[13:36:56.766]                   {
[13:36:56.766]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.766]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.766]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.766]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.766]                         fi_tmp[["mtime"]])
[13:36:56.766]                     }
[13:36:56.766]                     tryCatch({
[13:36:56.766]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.766]                     }, error = function(ex) {
[13:36:56.766]                       msg <- conditionMessage(ex)
[13:36:56.766]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.766]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.766]                         fi_tmp[["mtime"]], msg)
[13:36:56.766]                       ex$message <- msg
[13:36:56.766]                       stop(ex)
[13:36:56.766]                     })
[13:36:56.766]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.766]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.766]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.766]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.766]                       fi <- file.info(pathname)
[13:36:56.766]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.766]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.766]                         fi[["size"]], fi[["mtime"]])
[13:36:56.766]                       stop(msg)
[13:36:56.766]                     }
[13:36:56.766]                     invisible(pathname)
[13:36:56.766]                   }
[13:36:56.766]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.766]                     rootPath = tempdir()) 
[13:36:56.766]                   {
[13:36:56.766]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.766]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.766]                       tmpdir = path, fileext = ".rds")
[13:36:56.766]                     save_rds(obj, file)
[13:36:56.766]                   }
[13:36:56.766]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.766]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.766]                   {
[13:36:56.766]                     inherits <- base::inherits
[13:36:56.766]                     invokeRestart <- base::invokeRestart
[13:36:56.766]                     is.null <- base::is.null
[13:36:56.766]                     muffled <- FALSE
[13:36:56.766]                     if (inherits(cond, "message")) {
[13:36:56.766]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.766]                       if (muffled) 
[13:36:56.766]                         invokeRestart("muffleMessage")
[13:36:56.766]                     }
[13:36:56.766]                     else if (inherits(cond, "warning")) {
[13:36:56.766]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.766]                       if (muffled) 
[13:36:56.766]                         invokeRestart("muffleWarning")
[13:36:56.766]                     }
[13:36:56.766]                     else if (inherits(cond, "condition")) {
[13:36:56.766]                       if (!is.null(pattern)) {
[13:36:56.766]                         computeRestarts <- base::computeRestarts
[13:36:56.766]                         grepl <- base::grepl
[13:36:56.766]                         restarts <- computeRestarts(cond)
[13:36:56.766]                         for (restart in restarts) {
[13:36:56.766]                           name <- restart$name
[13:36:56.766]                           if (is.null(name)) 
[13:36:56.766]                             next
[13:36:56.766]                           if (!grepl(pattern, name)) 
[13:36:56.766]                             next
[13:36:56.766]                           invokeRestart(restart)
[13:36:56.766]                           muffled <- TRUE
[13:36:56.766]                           break
[13:36:56.766]                         }
[13:36:56.766]                       }
[13:36:56.766]                     }
[13:36:56.766]                     invisible(muffled)
[13:36:56.766]                   }
[13:36:56.766]                   muffleCondition(cond)
[13:36:56.766]                 })
[13:36:56.766]             }))
[13:36:56.766]             future::FutureResult(value = ...future.value$value, 
[13:36:56.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.766]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.766]                     ...future.globalenv.names))
[13:36:56.766]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.766]         }, condition = base::local({
[13:36:56.766]             c <- base::c
[13:36:56.766]             inherits <- base::inherits
[13:36:56.766]             invokeRestart <- base::invokeRestart
[13:36:56.766]             length <- base::length
[13:36:56.766]             list <- base::list
[13:36:56.766]             seq.int <- base::seq.int
[13:36:56.766]             signalCondition <- base::signalCondition
[13:36:56.766]             sys.calls <- base::sys.calls
[13:36:56.766]             `[[` <- base::`[[`
[13:36:56.766]             `+` <- base::`+`
[13:36:56.766]             `<<-` <- base::`<<-`
[13:36:56.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.766]                   3L)]
[13:36:56.766]             }
[13:36:56.766]             function(cond) {
[13:36:56.766]                 is_error <- inherits(cond, "error")
[13:36:56.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.766]                   NULL)
[13:36:56.766]                 if (is_error) {
[13:36:56.766]                   sessionInformation <- function() {
[13:36:56.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.766]                       search = base::search(), system = base::Sys.info())
[13:36:56.766]                   }
[13:36:56.766]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.766]                     cond$call), session = sessionInformation(), 
[13:36:56.766]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.766]                   signalCondition(cond)
[13:36:56.766]                 }
[13:36:56.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.766]                 "immediateCondition"))) {
[13:36:56.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.766]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.766]                   if (TRUE && !signal) {
[13:36:56.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.766]                     {
[13:36:56.766]                       inherits <- base::inherits
[13:36:56.766]                       invokeRestart <- base::invokeRestart
[13:36:56.766]                       is.null <- base::is.null
[13:36:56.766]                       muffled <- FALSE
[13:36:56.766]                       if (inherits(cond, "message")) {
[13:36:56.766]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.766]                         if (muffled) 
[13:36:56.766]                           invokeRestart("muffleMessage")
[13:36:56.766]                       }
[13:36:56.766]                       else if (inherits(cond, "warning")) {
[13:36:56.766]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.766]                         if (muffled) 
[13:36:56.766]                           invokeRestart("muffleWarning")
[13:36:56.766]                       }
[13:36:56.766]                       else if (inherits(cond, "condition")) {
[13:36:56.766]                         if (!is.null(pattern)) {
[13:36:56.766]                           computeRestarts <- base::computeRestarts
[13:36:56.766]                           grepl <- base::grepl
[13:36:56.766]                           restarts <- computeRestarts(cond)
[13:36:56.766]                           for (restart in restarts) {
[13:36:56.766]                             name <- restart$name
[13:36:56.766]                             if (is.null(name)) 
[13:36:56.766]                               next
[13:36:56.766]                             if (!grepl(pattern, name)) 
[13:36:56.766]                               next
[13:36:56.766]                             invokeRestart(restart)
[13:36:56.766]                             muffled <- TRUE
[13:36:56.766]                             break
[13:36:56.766]                           }
[13:36:56.766]                         }
[13:36:56.766]                       }
[13:36:56.766]                       invisible(muffled)
[13:36:56.766]                     }
[13:36:56.766]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.766]                   }
[13:36:56.766]                 }
[13:36:56.766]                 else {
[13:36:56.766]                   if (TRUE) {
[13:36:56.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.766]                     {
[13:36:56.766]                       inherits <- base::inherits
[13:36:56.766]                       invokeRestart <- base::invokeRestart
[13:36:56.766]                       is.null <- base::is.null
[13:36:56.766]                       muffled <- FALSE
[13:36:56.766]                       if (inherits(cond, "message")) {
[13:36:56.766]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.766]                         if (muffled) 
[13:36:56.766]                           invokeRestart("muffleMessage")
[13:36:56.766]                       }
[13:36:56.766]                       else if (inherits(cond, "warning")) {
[13:36:56.766]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.766]                         if (muffled) 
[13:36:56.766]                           invokeRestart("muffleWarning")
[13:36:56.766]                       }
[13:36:56.766]                       else if (inherits(cond, "condition")) {
[13:36:56.766]                         if (!is.null(pattern)) {
[13:36:56.766]                           computeRestarts <- base::computeRestarts
[13:36:56.766]                           grepl <- base::grepl
[13:36:56.766]                           restarts <- computeRestarts(cond)
[13:36:56.766]                           for (restart in restarts) {
[13:36:56.766]                             name <- restart$name
[13:36:56.766]                             if (is.null(name)) 
[13:36:56.766]                               next
[13:36:56.766]                             if (!grepl(pattern, name)) 
[13:36:56.766]                               next
[13:36:56.766]                             invokeRestart(restart)
[13:36:56.766]                             muffled <- TRUE
[13:36:56.766]                             break
[13:36:56.766]                           }
[13:36:56.766]                         }
[13:36:56.766]                       }
[13:36:56.766]                       invisible(muffled)
[13:36:56.766]                     }
[13:36:56.766]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.766]                   }
[13:36:56.766]                 }
[13:36:56.766]             }
[13:36:56.766]         }))
[13:36:56.766]     }, error = function(ex) {
[13:36:56.766]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.766]                 ...future.rng), started = ...future.startTime, 
[13:36:56.766]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.766]             version = "1.8"), class = "FutureResult")
[13:36:56.766]     }, finally = {
[13:36:56.766]         if (!identical(...future.workdir, getwd())) 
[13:36:56.766]             setwd(...future.workdir)
[13:36:56.766]         {
[13:36:56.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.766]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.766]             }
[13:36:56.766]             base::options(...future.oldOptions)
[13:36:56.766]             if (.Platform$OS.type == "windows") {
[13:36:56.766]                 old_names <- names(...future.oldEnvVars)
[13:36:56.766]                 envs <- base::Sys.getenv()
[13:36:56.766]                 names <- names(envs)
[13:36:56.766]                 common <- intersect(names, old_names)
[13:36:56.766]                 added <- setdiff(names, old_names)
[13:36:56.766]                 removed <- setdiff(old_names, names)
[13:36:56.766]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.766]                   envs[common]]
[13:36:56.766]                 NAMES <- toupper(changed)
[13:36:56.766]                 args <- list()
[13:36:56.766]                 for (kk in seq_along(NAMES)) {
[13:36:56.766]                   name <- changed[[kk]]
[13:36:56.766]                   NAME <- NAMES[[kk]]
[13:36:56.766]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.766]                     next
[13:36:56.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.766]                 }
[13:36:56.766]                 NAMES <- toupper(added)
[13:36:56.766]                 for (kk in seq_along(NAMES)) {
[13:36:56.766]                   name <- added[[kk]]
[13:36:56.766]                   NAME <- NAMES[[kk]]
[13:36:56.766]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.766]                     next
[13:36:56.766]                   args[[name]] <- ""
[13:36:56.766]                 }
[13:36:56.766]                 NAMES <- toupper(removed)
[13:36:56.766]                 for (kk in seq_along(NAMES)) {
[13:36:56.766]                   name <- removed[[kk]]
[13:36:56.766]                   NAME <- NAMES[[kk]]
[13:36:56.766]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.766]                     next
[13:36:56.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.766]                 }
[13:36:56.766]                 if (length(args) > 0) 
[13:36:56.766]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.766]             }
[13:36:56.766]             else {
[13:36:56.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.766]             }
[13:36:56.766]             {
[13:36:56.766]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.766]                   0L) {
[13:36:56.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.766]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.766]                   base::options(opts)
[13:36:56.766]                 }
[13:36:56.766]                 {
[13:36:56.766]                   {
[13:36:56.766]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.766]                     NULL
[13:36:56.766]                   }
[13:36:56.766]                   options(future.plan = NULL)
[13:36:56.766]                   if (is.na(NA_character_)) 
[13:36:56.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.766]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.766]                     .init = FALSE)
[13:36:56.766]                 }
[13:36:56.766]             }
[13:36:56.766]         }
[13:36:56.766]     })
[13:36:56.766]     if (TRUE) {
[13:36:56.766]         base::sink(type = "output", split = FALSE)
[13:36:56.766]         if (TRUE) {
[13:36:56.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.766]         }
[13:36:56.766]         else {
[13:36:56.766]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.766]         }
[13:36:56.766]         base::close(...future.stdout)
[13:36:56.766]         ...future.stdout <- NULL
[13:36:56.766]     }
[13:36:56.766]     ...future.result$conditions <- ...future.conditions
[13:36:56.766]     ...future.result$finished <- base::Sys.time()
[13:36:56.766]     ...future.result
[13:36:56.766] }
[13:36:56.769] requestCore(): workers = 2
[13:36:56.770] MulticoreFuture started
[13:36:56.771] - Launch lazy future ... done
[13:36:56.771] run() for ‘MulticoreFuture’ ... done
[13:36:56.771] plan(): Setting new future strategy stack:
[13:36:56.772] List of future strategies:
[13:36:56.772] 1. sequential:
[13:36:56.772]    - args: function (..., envir = parent.frame())
[13:36:56.772]    - tweaked: FALSE
[13:36:56.772]    - call: NULL
[13:36:56.773] plan(): nbrOfWorkers() = 1
[13:36:56.775] plan(): Setting new future strategy stack:
[13:36:56.775] List of future strategies:
[13:36:56.775] 1. multicore:
[13:36:56.775]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.775]    - tweaked: FALSE
[13:36:56.775]    - call: plan(strategy)
[13:36:56.780] plan(): nbrOfWorkers() = 2
[13:36:56.780] Future #1
[13:36:56.781] result() for MulticoreFuture ...
[13:36:56.781] result() for MulticoreFuture ...
[13:36:56.782] result() for MulticoreFuture ... done
[13:36:56.782] result() for MulticoreFuture ... done
[13:36:56.782] result() for MulticoreFuture ...
[13:36:56.782] result() for MulticoreFuture ... done
[13:36:56.782] A MulticoreFuture was resolved
[13:36:56.782]  length: 0 (resolved future 1)
[13:36:56.782] resolve() on list ... DONE
[13:36:56.783] - globals: [1] ‘a’
[13:36:56.783] Resolving futures part of globals (recursively) ... DONE
[13:36:56.784] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[13:36:56.785] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[13:36:56.785] - globals: [1] ‘a’
[13:36:56.785] - packages: [1] ‘future’
[13:36:56.785] getGlobalsAndPackages() ... DONE
[13:36:56.785] run() for ‘Future’ ...
[13:36:56.786] - state: ‘created’
[13:36:56.786] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.790] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.790]   - Field: ‘label’
[13:36:56.790]   - Field: ‘local’
[13:36:56.790]   - Field: ‘owner’
[13:36:56.790]   - Field: ‘envir’
[13:36:56.790]   - Field: ‘workers’
[13:36:56.791]   - Field: ‘packages’
[13:36:56.791]   - Field: ‘gc’
[13:36:56.791]   - Field: ‘job’
[13:36:56.791]   - Field: ‘conditions’
[13:36:56.791]   - Field: ‘expr’
[13:36:56.791]   - Field: ‘uuid’
[13:36:56.791]   - Field: ‘seed’
[13:36:56.791]   - Field: ‘version’
[13:36:56.791]   - Field: ‘result’
[13:36:56.792]   - Field: ‘asynchronous’
[13:36:56.792]   - Field: ‘calls’
[13:36:56.792]   - Field: ‘globals’
[13:36:56.792]   - Field: ‘stdout’
[13:36:56.792]   - Field: ‘earlySignal’
[13:36:56.792]   - Field: ‘lazy’
[13:36:56.792]   - Field: ‘state’
[13:36:56.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.792] - Launch lazy future ...
[13:36:56.793] Packages needed by the future expression (n = 1): ‘future’
[13:36:56.793] Packages needed by future strategies (n = 0): <none>
[13:36:56.794] {
[13:36:56.794]     {
[13:36:56.794]         {
[13:36:56.794]             ...future.startTime <- base::Sys.time()
[13:36:56.794]             {
[13:36:56.794]                 {
[13:36:56.794]                   {
[13:36:56.794]                     {
[13:36:56.794]                       {
[13:36:56.794]                         base::local({
[13:36:56.794]                           has_future <- base::requireNamespace("future", 
[13:36:56.794]                             quietly = TRUE)
[13:36:56.794]                           if (has_future) {
[13:36:56.794]                             ns <- base::getNamespace("future")
[13:36:56.794]                             version <- ns[[".package"]][["version"]]
[13:36:56.794]                             if (is.null(version)) 
[13:36:56.794]                               version <- utils::packageVersion("future")
[13:36:56.794]                           }
[13:36:56.794]                           else {
[13:36:56.794]                             version <- NULL
[13:36:56.794]                           }
[13:36:56.794]                           if (!has_future || version < "1.8.0") {
[13:36:56.794]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.794]                               "", base::R.version$version.string), 
[13:36:56.794]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:56.794]                                 base::R.version$platform, 8 * 
[13:36:56.794]                                   base::.Machine$sizeof.pointer), 
[13:36:56.794]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.794]                                 "release", "version")], collapse = " "), 
[13:36:56.794]                               hostname = base::Sys.info()[["nodename"]])
[13:36:56.794]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.794]                               info)
[13:36:56.794]                             info <- base::paste(info, collapse = "; ")
[13:36:56.794]                             if (!has_future) {
[13:36:56.794]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.794]                                 info)
[13:36:56.794]                             }
[13:36:56.794]                             else {
[13:36:56.794]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.794]                                 info, version)
[13:36:56.794]                             }
[13:36:56.794]                             base::stop(msg)
[13:36:56.794]                           }
[13:36:56.794]                         })
[13:36:56.794]                       }
[13:36:56.794]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.794]                       base::options(mc.cores = 1L)
[13:36:56.794]                     }
[13:36:56.794]                     base::local({
[13:36:56.794]                       for (pkg in "future") {
[13:36:56.794]                         base::loadNamespace(pkg)
[13:36:56.794]                         base::library(pkg, character.only = TRUE)
[13:36:56.794]                       }
[13:36:56.794]                     })
[13:36:56.794]                   }
[13:36:56.794]                   ...future.strategy.old <- future::plan("list")
[13:36:56.794]                   options(future.plan = NULL)
[13:36:56.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.794]                 }
[13:36:56.794]                 ...future.workdir <- getwd()
[13:36:56.794]             }
[13:36:56.794]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.794]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.794]         }
[13:36:56.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.794]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.794]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.794]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.794]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.794]             base::names(...future.oldOptions))
[13:36:56.794]     }
[13:36:56.794]     if (FALSE) {
[13:36:56.794]     }
[13:36:56.794]     else {
[13:36:56.794]         if (TRUE) {
[13:36:56.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.794]                 open = "w")
[13:36:56.794]         }
[13:36:56.794]         else {
[13:36:56.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.794]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.794]         }
[13:36:56.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.794]             base::sink(type = "output", split = FALSE)
[13:36:56.794]             base::close(...future.stdout)
[13:36:56.794]         }, add = TRUE)
[13:36:56.794]     }
[13:36:56.794]     ...future.frame <- base::sys.nframe()
[13:36:56.794]     ...future.conditions <- base::list()
[13:36:56.794]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.794]     if (FALSE) {
[13:36:56.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.794]     }
[13:36:56.794]     ...future.result <- base::tryCatch({
[13:36:56.794]         base::withCallingHandlers({
[13:36:56.794]             ...future.value <- base::withVisible(base::local({
[13:36:56.794]                 withCallingHandlers({
[13:36:56.794]                   value(a) + 1
[13:36:56.794]                 }, immediateCondition = function(cond) {
[13:36:56.794]                   save_rds <- function (object, pathname, ...) 
[13:36:56.794]                   {
[13:36:56.794]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.794]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.794]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.794]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.794]                         fi_tmp[["mtime"]])
[13:36:56.794]                     }
[13:36:56.794]                     tryCatch({
[13:36:56.794]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.794]                     }, error = function(ex) {
[13:36:56.794]                       msg <- conditionMessage(ex)
[13:36:56.794]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.794]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.794]                         fi_tmp[["mtime"]], msg)
[13:36:56.794]                       ex$message <- msg
[13:36:56.794]                       stop(ex)
[13:36:56.794]                     })
[13:36:56.794]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.794]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.794]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.794]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.794]                       fi <- file.info(pathname)
[13:36:56.794]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.794]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.794]                         fi[["size"]], fi[["mtime"]])
[13:36:56.794]                       stop(msg)
[13:36:56.794]                     }
[13:36:56.794]                     invisible(pathname)
[13:36:56.794]                   }
[13:36:56.794]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.794]                     rootPath = tempdir()) 
[13:36:56.794]                   {
[13:36:56.794]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.794]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.794]                       tmpdir = path, fileext = ".rds")
[13:36:56.794]                     save_rds(obj, file)
[13:36:56.794]                   }
[13:36:56.794]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.794]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.794]                   {
[13:36:56.794]                     inherits <- base::inherits
[13:36:56.794]                     invokeRestart <- base::invokeRestart
[13:36:56.794]                     is.null <- base::is.null
[13:36:56.794]                     muffled <- FALSE
[13:36:56.794]                     if (inherits(cond, "message")) {
[13:36:56.794]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.794]                       if (muffled) 
[13:36:56.794]                         invokeRestart("muffleMessage")
[13:36:56.794]                     }
[13:36:56.794]                     else if (inherits(cond, "warning")) {
[13:36:56.794]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.794]                       if (muffled) 
[13:36:56.794]                         invokeRestart("muffleWarning")
[13:36:56.794]                     }
[13:36:56.794]                     else if (inherits(cond, "condition")) {
[13:36:56.794]                       if (!is.null(pattern)) {
[13:36:56.794]                         computeRestarts <- base::computeRestarts
[13:36:56.794]                         grepl <- base::grepl
[13:36:56.794]                         restarts <- computeRestarts(cond)
[13:36:56.794]                         for (restart in restarts) {
[13:36:56.794]                           name <- restart$name
[13:36:56.794]                           if (is.null(name)) 
[13:36:56.794]                             next
[13:36:56.794]                           if (!grepl(pattern, name)) 
[13:36:56.794]                             next
[13:36:56.794]                           invokeRestart(restart)
[13:36:56.794]                           muffled <- TRUE
[13:36:56.794]                           break
[13:36:56.794]                         }
[13:36:56.794]                       }
[13:36:56.794]                     }
[13:36:56.794]                     invisible(muffled)
[13:36:56.794]                   }
[13:36:56.794]                   muffleCondition(cond)
[13:36:56.794]                 })
[13:36:56.794]             }))
[13:36:56.794]             future::FutureResult(value = ...future.value$value, 
[13:36:56.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.794]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.794]                     ...future.globalenv.names))
[13:36:56.794]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.794]         }, condition = base::local({
[13:36:56.794]             c <- base::c
[13:36:56.794]             inherits <- base::inherits
[13:36:56.794]             invokeRestart <- base::invokeRestart
[13:36:56.794]             length <- base::length
[13:36:56.794]             list <- base::list
[13:36:56.794]             seq.int <- base::seq.int
[13:36:56.794]             signalCondition <- base::signalCondition
[13:36:56.794]             sys.calls <- base::sys.calls
[13:36:56.794]             `[[` <- base::`[[`
[13:36:56.794]             `+` <- base::`+`
[13:36:56.794]             `<<-` <- base::`<<-`
[13:36:56.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.794]                   3L)]
[13:36:56.794]             }
[13:36:56.794]             function(cond) {
[13:36:56.794]                 is_error <- inherits(cond, "error")
[13:36:56.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.794]                   NULL)
[13:36:56.794]                 if (is_error) {
[13:36:56.794]                   sessionInformation <- function() {
[13:36:56.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.794]                       search = base::search(), system = base::Sys.info())
[13:36:56.794]                   }
[13:36:56.794]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.794]                     cond$call), session = sessionInformation(), 
[13:36:56.794]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.794]                   signalCondition(cond)
[13:36:56.794]                 }
[13:36:56.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.794]                 "immediateCondition"))) {
[13:36:56.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.794]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.794]                   if (TRUE && !signal) {
[13:36:56.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.794]                     {
[13:36:56.794]                       inherits <- base::inherits
[13:36:56.794]                       invokeRestart <- base::invokeRestart
[13:36:56.794]                       is.null <- base::is.null
[13:36:56.794]                       muffled <- FALSE
[13:36:56.794]                       if (inherits(cond, "message")) {
[13:36:56.794]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.794]                         if (muffled) 
[13:36:56.794]                           invokeRestart("muffleMessage")
[13:36:56.794]                       }
[13:36:56.794]                       else if (inherits(cond, "warning")) {
[13:36:56.794]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.794]                         if (muffled) 
[13:36:56.794]                           invokeRestart("muffleWarning")
[13:36:56.794]                       }
[13:36:56.794]                       else if (inherits(cond, "condition")) {
[13:36:56.794]                         if (!is.null(pattern)) {
[13:36:56.794]                           computeRestarts <- base::computeRestarts
[13:36:56.794]                           grepl <- base::grepl
[13:36:56.794]                           restarts <- computeRestarts(cond)
[13:36:56.794]                           for (restart in restarts) {
[13:36:56.794]                             name <- restart$name
[13:36:56.794]                             if (is.null(name)) 
[13:36:56.794]                               next
[13:36:56.794]                             if (!grepl(pattern, name)) 
[13:36:56.794]                               next
[13:36:56.794]                             invokeRestart(restart)
[13:36:56.794]                             muffled <- TRUE
[13:36:56.794]                             break
[13:36:56.794]                           }
[13:36:56.794]                         }
[13:36:56.794]                       }
[13:36:56.794]                       invisible(muffled)
[13:36:56.794]                     }
[13:36:56.794]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.794]                   }
[13:36:56.794]                 }
[13:36:56.794]                 else {
[13:36:56.794]                   if (TRUE) {
[13:36:56.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.794]                     {
[13:36:56.794]                       inherits <- base::inherits
[13:36:56.794]                       invokeRestart <- base::invokeRestart
[13:36:56.794]                       is.null <- base::is.null
[13:36:56.794]                       muffled <- FALSE
[13:36:56.794]                       if (inherits(cond, "message")) {
[13:36:56.794]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.794]                         if (muffled) 
[13:36:56.794]                           invokeRestart("muffleMessage")
[13:36:56.794]                       }
[13:36:56.794]                       else if (inherits(cond, "warning")) {
[13:36:56.794]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.794]                         if (muffled) 
[13:36:56.794]                           invokeRestart("muffleWarning")
[13:36:56.794]                       }
[13:36:56.794]                       else if (inherits(cond, "condition")) {
[13:36:56.794]                         if (!is.null(pattern)) {
[13:36:56.794]                           computeRestarts <- base::computeRestarts
[13:36:56.794]                           grepl <- base::grepl
[13:36:56.794]                           restarts <- computeRestarts(cond)
[13:36:56.794]                           for (restart in restarts) {
[13:36:56.794]                             name <- restart$name
[13:36:56.794]                             if (is.null(name)) 
[13:36:56.794]                               next
[13:36:56.794]                             if (!grepl(pattern, name)) 
[13:36:56.794]                               next
[13:36:56.794]                             invokeRestart(restart)
[13:36:56.794]                             muffled <- TRUE
[13:36:56.794]                             break
[13:36:56.794]                           }
[13:36:56.794]                         }
[13:36:56.794]                       }
[13:36:56.794]                       invisible(muffled)
[13:36:56.794]                     }
[13:36:56.794]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.794]                   }
[13:36:56.794]                 }
[13:36:56.794]             }
[13:36:56.794]         }))
[13:36:56.794]     }, error = function(ex) {
[13:36:56.794]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.794]                 ...future.rng), started = ...future.startTime, 
[13:36:56.794]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.794]             version = "1.8"), class = "FutureResult")
[13:36:56.794]     }, finally = {
[13:36:56.794]         if (!identical(...future.workdir, getwd())) 
[13:36:56.794]             setwd(...future.workdir)
[13:36:56.794]         {
[13:36:56.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.794]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.794]             }
[13:36:56.794]             base::options(...future.oldOptions)
[13:36:56.794]             if (.Platform$OS.type == "windows") {
[13:36:56.794]                 old_names <- names(...future.oldEnvVars)
[13:36:56.794]                 envs <- base::Sys.getenv()
[13:36:56.794]                 names <- names(envs)
[13:36:56.794]                 common <- intersect(names, old_names)
[13:36:56.794]                 added <- setdiff(names, old_names)
[13:36:56.794]                 removed <- setdiff(old_names, names)
[13:36:56.794]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.794]                   envs[common]]
[13:36:56.794]                 NAMES <- toupper(changed)
[13:36:56.794]                 args <- list()
[13:36:56.794]                 for (kk in seq_along(NAMES)) {
[13:36:56.794]                   name <- changed[[kk]]
[13:36:56.794]                   NAME <- NAMES[[kk]]
[13:36:56.794]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.794]                     next
[13:36:56.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.794]                 }
[13:36:56.794]                 NAMES <- toupper(added)
[13:36:56.794]                 for (kk in seq_along(NAMES)) {
[13:36:56.794]                   name <- added[[kk]]
[13:36:56.794]                   NAME <- NAMES[[kk]]
[13:36:56.794]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.794]                     next
[13:36:56.794]                   args[[name]] <- ""
[13:36:56.794]                 }
[13:36:56.794]                 NAMES <- toupper(removed)
[13:36:56.794]                 for (kk in seq_along(NAMES)) {
[13:36:56.794]                   name <- removed[[kk]]
[13:36:56.794]                   NAME <- NAMES[[kk]]
[13:36:56.794]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.794]                     next
[13:36:56.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.794]                 }
[13:36:56.794]                 if (length(args) > 0) 
[13:36:56.794]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.794]             }
[13:36:56.794]             else {
[13:36:56.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.794]             }
[13:36:56.794]             {
[13:36:56.794]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.794]                   0L) {
[13:36:56.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.794]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.794]                   base::options(opts)
[13:36:56.794]                 }
[13:36:56.794]                 {
[13:36:56.794]                   {
[13:36:56.794]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.794]                     NULL
[13:36:56.794]                   }
[13:36:56.794]                   options(future.plan = NULL)
[13:36:56.794]                   if (is.na(NA_character_)) 
[13:36:56.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.794]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.794]                     .init = FALSE)
[13:36:56.794]                 }
[13:36:56.794]             }
[13:36:56.794]         }
[13:36:56.794]     })
[13:36:56.794]     if (TRUE) {
[13:36:56.794]         base::sink(type = "output", split = FALSE)
[13:36:56.794]         if (TRUE) {
[13:36:56.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.794]         }
[13:36:56.794]         else {
[13:36:56.794]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.794]         }
[13:36:56.794]         base::close(...future.stdout)
[13:36:56.794]         ...future.stdout <- NULL
[13:36:56.794]     }
[13:36:56.794]     ...future.result$conditions <- ...future.conditions
[13:36:56.794]     ...future.result$finished <- base::Sys.time()
[13:36:56.794]     ...future.result
[13:36:56.794] }
[13:36:56.796] assign_globals() ...
[13:36:56.796] List of 1
[13:36:56.796]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c6dca89338> 
[13:36:56.796]  - attr(*, "where")=List of 1
[13:36:56.796]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.796]  - attr(*, "resolved")= logi TRUE
[13:36:56.796]  - attr(*, "total_size")= num 10984
[13:36:56.796]  - attr(*, "already-done")= logi TRUE
[13:36:56.799] - copied ‘a’ to environment
[13:36:56.799] assign_globals() ... done
[13:36:56.800] requestCore(): workers = 2
[13:36:56.806] MulticoreFuture started
[13:36:56.806] - Launch lazy future ... done
[13:36:56.807] run() for ‘MulticoreFuture’ ... done
[13:36:56.807] result() for MulticoreFuture ...
[13:36:56.807] plan(): Setting new future strategy stack:
[13:36:56.808] List of future strategies:
[13:36:56.808] 1. sequential:
[13:36:56.808]    - args: function (..., envir = parent.frame())
[13:36:56.808]    - tweaked: FALSE
[13:36:56.808]    - call: NULL
[13:36:56.809] plan(): nbrOfWorkers() = 1
[13:36:56.813] plan(): Setting new future strategy stack:
[13:36:56.814] List of future strategies:
[13:36:56.814] 1. multicore:
[13:36:56.814]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.814]    - tweaked: FALSE
[13:36:56.814]    - call: plan(strategy)
[13:36:56.819] plan(): nbrOfWorkers() = 2
[13:36:56.820] result() for MulticoreFuture ...
[13:36:56.820] result() for MulticoreFuture ... done
[13:36:56.821] signalConditions() ...
[13:36:56.821]  - include = ‘immediateCondition’
[13:36:56.821]  - exclude = 
[13:36:56.821]  - resignal = FALSE
[13:36:56.821]  - Number of conditions: 4
[13:36:56.822] signalConditions() ... done
[13:36:56.822] result() for MulticoreFuture ... done
[13:36:56.822] result() for MulticoreFuture ...
[13:36:56.822] result() for MulticoreFuture ... done
[13:36:56.823] signalConditions() ...
[13:36:56.823]  - include = ‘immediateCondition’
[13:36:56.823]  - exclude = 
[13:36:56.823]  - resignal = FALSE
[13:36:56.823]  - Number of conditions: 4
[13:36:56.823] signalConditions() ... done
[13:36:56.824] Future state: ‘finished’
[13:36:56.824] result() for MulticoreFuture ...
[13:36:56.824] result() for MulticoreFuture ... done
[13:36:56.824] signalConditions() ...
[13:36:56.824]  - include = ‘condition’
[13:36:56.824]  - exclude = ‘immediateCondition’
[13:36:56.824]  - resignal = TRUE
[13:36:56.824]  - Number of conditions: 4
[13:36:56.825]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.811] result() for MulticoreFuture ...
[13:36:56.825]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.811] result() for MulticoreFuture ... done
[13:36:56.825]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.812] result() for MulticoreFuture ...
[13:36:56.825]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.812] result() for MulticoreFuture ... done
[13:36:56.825] signalConditions() ... done
value(b) = 2
[13:36:56.826] result() for MulticoreFuture ...
[13:36:56.826] result() for MulticoreFuture ... done
[13:36:56.826] result() for MulticoreFuture ...
[13:36:56.826] result() for MulticoreFuture ... done
[13:36:56.826] signalConditions() ...
[13:36:56.826]  - include = ‘immediateCondition’
[13:36:56.826]  - exclude = 
[13:36:56.826]  - resignal = FALSE
[13:36:56.827]  - Number of conditions: 4
[13:36:56.827] signalConditions() ... done
[13:36:56.827] Future state: ‘finished’
[13:36:56.827] result() for MulticoreFuture ...
[13:36:56.827] result() for MulticoreFuture ... done
[13:36:56.827] signalConditions() ...
[13:36:56.827]  - include = ‘condition’
[13:36:56.827]  - exclude = ‘immediateCondition’
[13:36:56.827]  - resignal = TRUE
[13:36:56.828]  - Number of conditions: 4
[13:36:56.828]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.811] result() for MulticoreFuture ...
[13:36:56.828]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.811] result() for MulticoreFuture ... done
[13:36:56.828]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.812] result() for MulticoreFuture ...
[13:36:56.828]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:56.812] result() for MulticoreFuture ... done
[13:36:56.828] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.829] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.829] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:56.830] - globals found: [2] ‘{’, ‘pkg’
[13:36:56.830] Searching for globals ... DONE
[13:36:56.830] Resolving globals: TRUE
[13:36:56.830] Resolving any globals that are futures ...
[13:36:56.830] - globals: [2] ‘{’, ‘pkg’
[13:36:56.831] Resolving any globals that are futures ... DONE
[13:36:56.831] Resolving futures part of globals (recursively) ...
[13:36:56.831] resolve() on list ...
[13:36:56.831]  recursive: 99
[13:36:56.831]  length: 1
[13:36:56.831]  elements: ‘pkg’
[13:36:56.832]  length: 0 (resolved future 1)
[13:36:56.832] resolve() on list ... DONE
[13:36:56.832] - globals: [1] ‘pkg’
[13:36:56.832] Resolving futures part of globals (recursively) ... DONE
[13:36:56.832] The total size of the 1 globals is 112 bytes (112 bytes)
[13:36:56.832] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:36:56.833] - globals: [1] ‘pkg’
[13:36:56.833] 
[13:36:56.833] getGlobalsAndPackages() ... DONE
[13:36:56.833] Packages needed by the future expression (n = 0): <none>
[13:36:56.833] Packages needed by future strategies (n = 0): <none>
[13:36:56.834] {
[13:36:56.834]     {
[13:36:56.834]         {
[13:36:56.834]             ...future.startTime <- base::Sys.time()
[13:36:56.834]             {
[13:36:56.834]                 {
[13:36:56.834]                   {
[13:36:56.834]                     base::local({
[13:36:56.834]                       has_future <- base::requireNamespace("future", 
[13:36:56.834]                         quietly = TRUE)
[13:36:56.834]                       if (has_future) {
[13:36:56.834]                         ns <- base::getNamespace("future")
[13:36:56.834]                         version <- ns[[".package"]][["version"]]
[13:36:56.834]                         if (is.null(version)) 
[13:36:56.834]                           version <- utils::packageVersion("future")
[13:36:56.834]                       }
[13:36:56.834]                       else {
[13:36:56.834]                         version <- NULL
[13:36:56.834]                       }
[13:36:56.834]                       if (!has_future || version < "1.8.0") {
[13:36:56.834]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.834]                           "", base::R.version$version.string), 
[13:36:56.834]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:56.834]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.834]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.834]                             "release", "version")], collapse = " "), 
[13:36:56.834]                           hostname = base::Sys.info()[["nodename"]])
[13:36:56.834]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.834]                           info)
[13:36:56.834]                         info <- base::paste(info, collapse = "; ")
[13:36:56.834]                         if (!has_future) {
[13:36:56.834]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.834]                             info)
[13:36:56.834]                         }
[13:36:56.834]                         else {
[13:36:56.834]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.834]                             info, version)
[13:36:56.834]                         }
[13:36:56.834]                         base::stop(msg)
[13:36:56.834]                       }
[13:36:56.834]                     })
[13:36:56.834]                   }
[13:36:56.834]                   ...future.strategy.old <- future::plan("list")
[13:36:56.834]                   options(future.plan = NULL)
[13:36:56.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.834]                 }
[13:36:56.834]                 ...future.workdir <- getwd()
[13:36:56.834]             }
[13:36:56.834]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.834]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.834]         }
[13:36:56.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.834]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:56.834]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.834]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.834]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.834]             base::names(...future.oldOptions))
[13:36:56.834]     }
[13:36:56.834]     if (FALSE) {
[13:36:56.834]     }
[13:36:56.834]     else {
[13:36:56.834]         if (TRUE) {
[13:36:56.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.834]                 open = "w")
[13:36:56.834]         }
[13:36:56.834]         else {
[13:36:56.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.834]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.834]         }
[13:36:56.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.834]             base::sink(type = "output", split = FALSE)
[13:36:56.834]             base::close(...future.stdout)
[13:36:56.834]         }, add = TRUE)
[13:36:56.834]     }
[13:36:56.834]     ...future.frame <- base::sys.nframe()
[13:36:56.834]     ...future.conditions <- base::list()
[13:36:56.834]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.834]     if (FALSE) {
[13:36:56.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.834]     }
[13:36:56.834]     ...future.result <- base::tryCatch({
[13:36:56.834]         base::withCallingHandlers({
[13:36:56.834]             ...future.value <- base::withVisible(base::local({
[13:36:56.834]                 pkg
[13:36:56.834]             }))
[13:36:56.834]             future::FutureResult(value = ...future.value$value, 
[13:36:56.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.834]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.834]                     ...future.globalenv.names))
[13:36:56.834]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.834]         }, condition = base::local({
[13:36:56.834]             c <- base::c
[13:36:56.834]             inherits <- base::inherits
[13:36:56.834]             invokeRestart <- base::invokeRestart
[13:36:56.834]             length <- base::length
[13:36:56.834]             list <- base::list
[13:36:56.834]             seq.int <- base::seq.int
[13:36:56.834]             signalCondition <- base::signalCondition
[13:36:56.834]             sys.calls <- base::sys.calls
[13:36:56.834]             `[[` <- base::`[[`
[13:36:56.834]             `+` <- base::`+`
[13:36:56.834]             `<<-` <- base::`<<-`
[13:36:56.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.834]                   3L)]
[13:36:56.834]             }
[13:36:56.834]             function(cond) {
[13:36:56.834]                 is_error <- inherits(cond, "error")
[13:36:56.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.834]                   NULL)
[13:36:56.834]                 if (is_error) {
[13:36:56.834]                   sessionInformation <- function() {
[13:36:56.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.834]                       search = base::search(), system = base::Sys.info())
[13:36:56.834]                   }
[13:36:56.834]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.834]                     cond$call), session = sessionInformation(), 
[13:36:56.834]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.834]                   signalCondition(cond)
[13:36:56.834]                 }
[13:36:56.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.834]                 "immediateCondition"))) {
[13:36:56.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.834]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.834]                   if (TRUE && !signal) {
[13:36:56.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.834]                     {
[13:36:56.834]                       inherits <- base::inherits
[13:36:56.834]                       invokeRestart <- base::invokeRestart
[13:36:56.834]                       is.null <- base::is.null
[13:36:56.834]                       muffled <- FALSE
[13:36:56.834]                       if (inherits(cond, "message")) {
[13:36:56.834]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.834]                         if (muffled) 
[13:36:56.834]                           invokeRestart("muffleMessage")
[13:36:56.834]                       }
[13:36:56.834]                       else if (inherits(cond, "warning")) {
[13:36:56.834]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.834]                         if (muffled) 
[13:36:56.834]                           invokeRestart("muffleWarning")
[13:36:56.834]                       }
[13:36:56.834]                       else if (inherits(cond, "condition")) {
[13:36:56.834]                         if (!is.null(pattern)) {
[13:36:56.834]                           computeRestarts <- base::computeRestarts
[13:36:56.834]                           grepl <- base::grepl
[13:36:56.834]                           restarts <- computeRestarts(cond)
[13:36:56.834]                           for (restart in restarts) {
[13:36:56.834]                             name <- restart$name
[13:36:56.834]                             if (is.null(name)) 
[13:36:56.834]                               next
[13:36:56.834]                             if (!grepl(pattern, name)) 
[13:36:56.834]                               next
[13:36:56.834]                             invokeRestart(restart)
[13:36:56.834]                             muffled <- TRUE
[13:36:56.834]                             break
[13:36:56.834]                           }
[13:36:56.834]                         }
[13:36:56.834]                       }
[13:36:56.834]                       invisible(muffled)
[13:36:56.834]                     }
[13:36:56.834]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.834]                   }
[13:36:56.834]                 }
[13:36:56.834]                 else {
[13:36:56.834]                   if (TRUE) {
[13:36:56.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.834]                     {
[13:36:56.834]                       inherits <- base::inherits
[13:36:56.834]                       invokeRestart <- base::invokeRestart
[13:36:56.834]                       is.null <- base::is.null
[13:36:56.834]                       muffled <- FALSE
[13:36:56.834]                       if (inherits(cond, "message")) {
[13:36:56.834]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.834]                         if (muffled) 
[13:36:56.834]                           invokeRestart("muffleMessage")
[13:36:56.834]                       }
[13:36:56.834]                       else if (inherits(cond, "warning")) {
[13:36:56.834]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.834]                         if (muffled) 
[13:36:56.834]                           invokeRestart("muffleWarning")
[13:36:56.834]                       }
[13:36:56.834]                       else if (inherits(cond, "condition")) {
[13:36:56.834]                         if (!is.null(pattern)) {
[13:36:56.834]                           computeRestarts <- base::computeRestarts
[13:36:56.834]                           grepl <- base::grepl
[13:36:56.834]                           restarts <- computeRestarts(cond)
[13:36:56.834]                           for (restart in restarts) {
[13:36:56.834]                             name <- restart$name
[13:36:56.834]                             if (is.null(name)) 
[13:36:56.834]                               next
[13:36:56.834]                             if (!grepl(pattern, name)) 
[13:36:56.834]                               next
[13:36:56.834]                             invokeRestart(restart)
[13:36:56.834]                             muffled <- TRUE
[13:36:56.834]                             break
[13:36:56.834]                           }
[13:36:56.834]                         }
[13:36:56.834]                       }
[13:36:56.834]                       invisible(muffled)
[13:36:56.834]                     }
[13:36:56.834]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.834]                   }
[13:36:56.834]                 }
[13:36:56.834]             }
[13:36:56.834]         }))
[13:36:56.834]     }, error = function(ex) {
[13:36:56.834]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.834]                 ...future.rng), started = ...future.startTime, 
[13:36:56.834]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.834]             version = "1.8"), class = "FutureResult")
[13:36:56.834]     }, finally = {
[13:36:56.834]         if (!identical(...future.workdir, getwd())) 
[13:36:56.834]             setwd(...future.workdir)
[13:36:56.834]         {
[13:36:56.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.834]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.834]             }
[13:36:56.834]             base::options(...future.oldOptions)
[13:36:56.834]             if (.Platform$OS.type == "windows") {
[13:36:56.834]                 old_names <- names(...future.oldEnvVars)
[13:36:56.834]                 envs <- base::Sys.getenv()
[13:36:56.834]                 names <- names(envs)
[13:36:56.834]                 common <- intersect(names, old_names)
[13:36:56.834]                 added <- setdiff(names, old_names)
[13:36:56.834]                 removed <- setdiff(old_names, names)
[13:36:56.834]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.834]                   envs[common]]
[13:36:56.834]                 NAMES <- toupper(changed)
[13:36:56.834]                 args <- list()
[13:36:56.834]                 for (kk in seq_along(NAMES)) {
[13:36:56.834]                   name <- changed[[kk]]
[13:36:56.834]                   NAME <- NAMES[[kk]]
[13:36:56.834]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.834]                     next
[13:36:56.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.834]                 }
[13:36:56.834]                 NAMES <- toupper(added)
[13:36:56.834]                 for (kk in seq_along(NAMES)) {
[13:36:56.834]                   name <- added[[kk]]
[13:36:56.834]                   NAME <- NAMES[[kk]]
[13:36:56.834]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.834]                     next
[13:36:56.834]                   args[[name]] <- ""
[13:36:56.834]                 }
[13:36:56.834]                 NAMES <- toupper(removed)
[13:36:56.834]                 for (kk in seq_along(NAMES)) {
[13:36:56.834]                   name <- removed[[kk]]
[13:36:56.834]                   NAME <- NAMES[[kk]]
[13:36:56.834]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.834]                     next
[13:36:56.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.834]                 }
[13:36:56.834]                 if (length(args) > 0) 
[13:36:56.834]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.834]             }
[13:36:56.834]             else {
[13:36:56.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.834]             }
[13:36:56.834]             {
[13:36:56.834]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.834]                   0L) {
[13:36:56.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.834]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.834]                   base::options(opts)
[13:36:56.834]                 }
[13:36:56.834]                 {
[13:36:56.834]                   {
[13:36:56.834]                     NULL
[13:36:56.834]                     RNGkind("Mersenne-Twister")
[13:36:56.834]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:56.834]                       inherits = FALSE)
[13:36:56.834]                   }
[13:36:56.834]                   options(future.plan = NULL)
[13:36:56.834]                   if (is.na(NA_character_)) 
[13:36:56.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.834]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.834]                     .init = FALSE)
[13:36:56.834]                 }
[13:36:56.834]             }
[13:36:56.834]         }
[13:36:56.834]     })
[13:36:56.834]     if (TRUE) {
[13:36:56.834]         base::sink(type = "output", split = FALSE)
[13:36:56.834]         if (TRUE) {
[13:36:56.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.834]         }
[13:36:56.834]         else {
[13:36:56.834]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.834]         }
[13:36:56.834]         base::close(...future.stdout)
[13:36:56.834]         ...future.stdout <- NULL
[13:36:56.834]     }
[13:36:56.834]     ...future.result$conditions <- ...future.conditions
[13:36:56.834]     ...future.result$finished <- base::Sys.time()
[13:36:56.834]     ...future.result
[13:36:56.834] }
[13:36:56.836] assign_globals() ...
[13:36:56.836] List of 1
[13:36:56.836]  $ pkg: chr "foo"
[13:36:56.836]  - attr(*, "where")=List of 1
[13:36:56.836]   ..$ pkg:<environment: R_EmptyEnv> 
[13:36:56.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.836]  - attr(*, "resolved")= logi TRUE
[13:36:56.836]  - attr(*, "total_size")= num 112
[13:36:56.838] - copied ‘pkg’ to environment
[13:36:56.838] assign_globals() ... done
[13:36:56.839] plan(): Setting new future strategy stack:
[13:36:56.839] List of future strategies:
[13:36:56.839] 1. sequential:
[13:36:56.839]    - args: function (..., envir = parent.frame())
[13:36:56.839]    - tweaked: FALSE
[13:36:56.839]    - call: NULL
[13:36:56.839] plan(): nbrOfWorkers() = 1
[13:36:56.840] plan(): Setting new future strategy stack:
[13:36:56.840] List of future strategies:
[13:36:56.840] 1. multicore:
[13:36:56.840]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.840]    - tweaked: FALSE
[13:36:56.840]    - call: plan(strategy)
[13:36:56.844] plan(): nbrOfWorkers() = 2
[13:36:56.844] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.845] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.847] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.849] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:56.849] Searching for globals ... DONE
[13:36:56.849] Resolving globals: TRUE
[13:36:56.849] Resolving any globals that are futures ...
[13:36:56.849] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:56.850] Resolving any globals that are futures ... DONE
[13:36:56.850] Resolving futures part of globals (recursively) ...
[13:36:56.850] resolve() on list ...
[13:36:56.850]  recursive: 99
[13:36:56.850]  length: 1
[13:36:56.850]  elements: ‘a’
[13:36:56.851]  length: 0 (resolved future 1)
[13:36:56.851] resolve() on list ... DONE
[13:36:56.851] - globals: [1] ‘a’
[13:36:56.851] Resolving futures part of globals (recursively) ... DONE
[13:36:56.851] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:56.851] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:56.851] - globals: [1] ‘a’
[13:36:56.851] 
[13:36:56.852] getGlobalsAndPackages() ... DONE
[13:36:56.852] run() for ‘Future’ ...
[13:36:56.852] - state: ‘created’
[13:36:56.852] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.856] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.856] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.856]   - Field: ‘label’
[13:36:56.856]   - Field: ‘local’
[13:36:56.856]   - Field: ‘owner’
[13:36:56.856]   - Field: ‘envir’
[13:36:56.856]   - Field: ‘workers’
[13:36:56.856]   - Field: ‘packages’
[13:36:56.856]   - Field: ‘gc’
[13:36:56.856]   - Field: ‘job’
[13:36:56.857]   - Field: ‘conditions’
[13:36:56.857]   - Field: ‘expr’
[13:36:56.857]   - Field: ‘uuid’
[13:36:56.857]   - Field: ‘seed’
[13:36:56.857]   - Field: ‘version’
[13:36:56.857]   - Field: ‘result’
[13:36:56.857]   - Field: ‘asynchronous’
[13:36:56.857]   - Field: ‘calls’
[13:36:56.857]   - Field: ‘globals’
[13:36:56.857]   - Field: ‘stdout’
[13:36:56.857]   - Field: ‘earlySignal’
[13:36:56.858]   - Field: ‘lazy’
[13:36:56.858]   - Field: ‘state’
[13:36:56.858] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.858] - Launch lazy future ...
[13:36:56.858] Packages needed by the future expression (n = 0): <none>
[13:36:56.858] Packages needed by future strategies (n = 0): <none>
[13:36:56.859] {
[13:36:56.859]     {
[13:36:56.859]         {
[13:36:56.859]             ...future.startTime <- base::Sys.time()
[13:36:56.859]             {
[13:36:56.859]                 {
[13:36:56.859]                   {
[13:36:56.859]                     {
[13:36:56.859]                       base::local({
[13:36:56.859]                         has_future <- base::requireNamespace("future", 
[13:36:56.859]                           quietly = TRUE)
[13:36:56.859]                         if (has_future) {
[13:36:56.859]                           ns <- base::getNamespace("future")
[13:36:56.859]                           version <- ns[[".package"]][["version"]]
[13:36:56.859]                           if (is.null(version)) 
[13:36:56.859]                             version <- utils::packageVersion("future")
[13:36:56.859]                         }
[13:36:56.859]                         else {
[13:36:56.859]                           version <- NULL
[13:36:56.859]                         }
[13:36:56.859]                         if (!has_future || version < "1.8.0") {
[13:36:56.859]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.859]                             "", base::R.version$version.string), 
[13:36:56.859]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.859]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.859]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.859]                               "release", "version")], collapse = " "), 
[13:36:56.859]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.859]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.859]                             info)
[13:36:56.859]                           info <- base::paste(info, collapse = "; ")
[13:36:56.859]                           if (!has_future) {
[13:36:56.859]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.859]                               info)
[13:36:56.859]                           }
[13:36:56.859]                           else {
[13:36:56.859]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.859]                               info, version)
[13:36:56.859]                           }
[13:36:56.859]                           base::stop(msg)
[13:36:56.859]                         }
[13:36:56.859]                       })
[13:36:56.859]                     }
[13:36:56.859]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.859]                     base::options(mc.cores = 1L)
[13:36:56.859]                   }
[13:36:56.859]                   ...future.strategy.old <- future::plan("list")
[13:36:56.859]                   options(future.plan = NULL)
[13:36:56.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.859]                 }
[13:36:56.859]                 ...future.workdir <- getwd()
[13:36:56.859]             }
[13:36:56.859]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.859]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.859]         }
[13:36:56.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.859]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.859]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.859]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.859]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.859]             base::names(...future.oldOptions))
[13:36:56.859]     }
[13:36:56.859]     if (FALSE) {
[13:36:56.859]     }
[13:36:56.859]     else {
[13:36:56.859]         if (TRUE) {
[13:36:56.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.859]                 open = "w")
[13:36:56.859]         }
[13:36:56.859]         else {
[13:36:56.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.859]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.859]         }
[13:36:56.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.859]             base::sink(type = "output", split = FALSE)
[13:36:56.859]             base::close(...future.stdout)
[13:36:56.859]         }, add = TRUE)
[13:36:56.859]     }
[13:36:56.859]     ...future.frame <- base::sys.nframe()
[13:36:56.859]     ...future.conditions <- base::list()
[13:36:56.859]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.859]     if (FALSE) {
[13:36:56.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.859]     }
[13:36:56.859]     ...future.result <- base::tryCatch({
[13:36:56.859]         base::withCallingHandlers({
[13:36:56.859]             ...future.value <- base::withVisible(base::local({
[13:36:56.859]                 withCallingHandlers({
[13:36:56.859]                   {
[13:36:56.859]                     b <- a
[13:36:56.859]                     a <- 2
[13:36:56.859]                     a * b
[13:36:56.859]                   }
[13:36:56.859]                 }, immediateCondition = function(cond) {
[13:36:56.859]                   save_rds <- function (object, pathname, ...) 
[13:36:56.859]                   {
[13:36:56.859]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.859]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.859]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.859]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.859]                         fi_tmp[["mtime"]])
[13:36:56.859]                     }
[13:36:56.859]                     tryCatch({
[13:36:56.859]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.859]                     }, error = function(ex) {
[13:36:56.859]                       msg <- conditionMessage(ex)
[13:36:56.859]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.859]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.859]                         fi_tmp[["mtime"]], msg)
[13:36:56.859]                       ex$message <- msg
[13:36:56.859]                       stop(ex)
[13:36:56.859]                     })
[13:36:56.859]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.859]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.859]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.859]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.859]                       fi <- file.info(pathname)
[13:36:56.859]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.859]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.859]                         fi[["size"]], fi[["mtime"]])
[13:36:56.859]                       stop(msg)
[13:36:56.859]                     }
[13:36:56.859]                     invisible(pathname)
[13:36:56.859]                   }
[13:36:56.859]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.859]                     rootPath = tempdir()) 
[13:36:56.859]                   {
[13:36:56.859]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.859]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.859]                       tmpdir = path, fileext = ".rds")
[13:36:56.859]                     save_rds(obj, file)
[13:36:56.859]                   }
[13:36:56.859]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.859]                   {
[13:36:56.859]                     inherits <- base::inherits
[13:36:56.859]                     invokeRestart <- base::invokeRestart
[13:36:56.859]                     is.null <- base::is.null
[13:36:56.859]                     muffled <- FALSE
[13:36:56.859]                     if (inherits(cond, "message")) {
[13:36:56.859]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.859]                       if (muffled) 
[13:36:56.859]                         invokeRestart("muffleMessage")
[13:36:56.859]                     }
[13:36:56.859]                     else if (inherits(cond, "warning")) {
[13:36:56.859]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.859]                       if (muffled) 
[13:36:56.859]                         invokeRestart("muffleWarning")
[13:36:56.859]                     }
[13:36:56.859]                     else if (inherits(cond, "condition")) {
[13:36:56.859]                       if (!is.null(pattern)) {
[13:36:56.859]                         computeRestarts <- base::computeRestarts
[13:36:56.859]                         grepl <- base::grepl
[13:36:56.859]                         restarts <- computeRestarts(cond)
[13:36:56.859]                         for (restart in restarts) {
[13:36:56.859]                           name <- restart$name
[13:36:56.859]                           if (is.null(name)) 
[13:36:56.859]                             next
[13:36:56.859]                           if (!grepl(pattern, name)) 
[13:36:56.859]                             next
[13:36:56.859]                           invokeRestart(restart)
[13:36:56.859]                           muffled <- TRUE
[13:36:56.859]                           break
[13:36:56.859]                         }
[13:36:56.859]                       }
[13:36:56.859]                     }
[13:36:56.859]                     invisible(muffled)
[13:36:56.859]                   }
[13:36:56.859]                   muffleCondition(cond)
[13:36:56.859]                 })
[13:36:56.859]             }))
[13:36:56.859]             future::FutureResult(value = ...future.value$value, 
[13:36:56.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.859]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.859]                     ...future.globalenv.names))
[13:36:56.859]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.859]         }, condition = base::local({
[13:36:56.859]             c <- base::c
[13:36:56.859]             inherits <- base::inherits
[13:36:56.859]             invokeRestart <- base::invokeRestart
[13:36:56.859]             length <- base::length
[13:36:56.859]             list <- base::list
[13:36:56.859]             seq.int <- base::seq.int
[13:36:56.859]             signalCondition <- base::signalCondition
[13:36:56.859]             sys.calls <- base::sys.calls
[13:36:56.859]             `[[` <- base::`[[`
[13:36:56.859]             `+` <- base::`+`
[13:36:56.859]             `<<-` <- base::`<<-`
[13:36:56.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.859]                   3L)]
[13:36:56.859]             }
[13:36:56.859]             function(cond) {
[13:36:56.859]                 is_error <- inherits(cond, "error")
[13:36:56.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.859]                   NULL)
[13:36:56.859]                 if (is_error) {
[13:36:56.859]                   sessionInformation <- function() {
[13:36:56.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.859]                       search = base::search(), system = base::Sys.info())
[13:36:56.859]                   }
[13:36:56.859]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.859]                     cond$call), session = sessionInformation(), 
[13:36:56.859]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.859]                   signalCondition(cond)
[13:36:56.859]                 }
[13:36:56.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.859]                 "immediateCondition"))) {
[13:36:56.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.859]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.859]                   if (TRUE && !signal) {
[13:36:56.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.859]                     {
[13:36:56.859]                       inherits <- base::inherits
[13:36:56.859]                       invokeRestart <- base::invokeRestart
[13:36:56.859]                       is.null <- base::is.null
[13:36:56.859]                       muffled <- FALSE
[13:36:56.859]                       if (inherits(cond, "message")) {
[13:36:56.859]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.859]                         if (muffled) 
[13:36:56.859]                           invokeRestart("muffleMessage")
[13:36:56.859]                       }
[13:36:56.859]                       else if (inherits(cond, "warning")) {
[13:36:56.859]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.859]                         if (muffled) 
[13:36:56.859]                           invokeRestart("muffleWarning")
[13:36:56.859]                       }
[13:36:56.859]                       else if (inherits(cond, "condition")) {
[13:36:56.859]                         if (!is.null(pattern)) {
[13:36:56.859]                           computeRestarts <- base::computeRestarts
[13:36:56.859]                           grepl <- base::grepl
[13:36:56.859]                           restarts <- computeRestarts(cond)
[13:36:56.859]                           for (restart in restarts) {
[13:36:56.859]                             name <- restart$name
[13:36:56.859]                             if (is.null(name)) 
[13:36:56.859]                               next
[13:36:56.859]                             if (!grepl(pattern, name)) 
[13:36:56.859]                               next
[13:36:56.859]                             invokeRestart(restart)
[13:36:56.859]                             muffled <- TRUE
[13:36:56.859]                             break
[13:36:56.859]                           }
[13:36:56.859]                         }
[13:36:56.859]                       }
[13:36:56.859]                       invisible(muffled)
[13:36:56.859]                     }
[13:36:56.859]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.859]                   }
[13:36:56.859]                 }
[13:36:56.859]                 else {
[13:36:56.859]                   if (TRUE) {
[13:36:56.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.859]                     {
[13:36:56.859]                       inherits <- base::inherits
[13:36:56.859]                       invokeRestart <- base::invokeRestart
[13:36:56.859]                       is.null <- base::is.null
[13:36:56.859]                       muffled <- FALSE
[13:36:56.859]                       if (inherits(cond, "message")) {
[13:36:56.859]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.859]                         if (muffled) 
[13:36:56.859]                           invokeRestart("muffleMessage")
[13:36:56.859]                       }
[13:36:56.859]                       else if (inherits(cond, "warning")) {
[13:36:56.859]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.859]                         if (muffled) 
[13:36:56.859]                           invokeRestart("muffleWarning")
[13:36:56.859]                       }
[13:36:56.859]                       else if (inherits(cond, "condition")) {
[13:36:56.859]                         if (!is.null(pattern)) {
[13:36:56.859]                           computeRestarts <- base::computeRestarts
[13:36:56.859]                           grepl <- base::grepl
[13:36:56.859]                           restarts <- computeRestarts(cond)
[13:36:56.859]                           for (restart in restarts) {
[13:36:56.859]                             name <- restart$name
[13:36:56.859]                             if (is.null(name)) 
[13:36:56.859]                               next
[13:36:56.859]                             if (!grepl(pattern, name)) 
[13:36:56.859]                               next
[13:36:56.859]                             invokeRestart(restart)
[13:36:56.859]                             muffled <- TRUE
[13:36:56.859]                             break
[13:36:56.859]                           }
[13:36:56.859]                         }
[13:36:56.859]                       }
[13:36:56.859]                       invisible(muffled)
[13:36:56.859]                     }
[13:36:56.859]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.859]                   }
[13:36:56.859]                 }
[13:36:56.859]             }
[13:36:56.859]         }))
[13:36:56.859]     }, error = function(ex) {
[13:36:56.859]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.859]                 ...future.rng), started = ...future.startTime, 
[13:36:56.859]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.859]             version = "1.8"), class = "FutureResult")
[13:36:56.859]     }, finally = {
[13:36:56.859]         if (!identical(...future.workdir, getwd())) 
[13:36:56.859]             setwd(...future.workdir)
[13:36:56.859]         {
[13:36:56.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.859]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.859]             }
[13:36:56.859]             base::options(...future.oldOptions)
[13:36:56.859]             if (.Platform$OS.type == "windows") {
[13:36:56.859]                 old_names <- names(...future.oldEnvVars)
[13:36:56.859]                 envs <- base::Sys.getenv()
[13:36:56.859]                 names <- names(envs)
[13:36:56.859]                 common <- intersect(names, old_names)
[13:36:56.859]                 added <- setdiff(names, old_names)
[13:36:56.859]                 removed <- setdiff(old_names, names)
[13:36:56.859]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.859]                   envs[common]]
[13:36:56.859]                 NAMES <- toupper(changed)
[13:36:56.859]                 args <- list()
[13:36:56.859]                 for (kk in seq_along(NAMES)) {
[13:36:56.859]                   name <- changed[[kk]]
[13:36:56.859]                   NAME <- NAMES[[kk]]
[13:36:56.859]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.859]                     next
[13:36:56.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.859]                 }
[13:36:56.859]                 NAMES <- toupper(added)
[13:36:56.859]                 for (kk in seq_along(NAMES)) {
[13:36:56.859]                   name <- added[[kk]]
[13:36:56.859]                   NAME <- NAMES[[kk]]
[13:36:56.859]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.859]                     next
[13:36:56.859]                   args[[name]] <- ""
[13:36:56.859]                 }
[13:36:56.859]                 NAMES <- toupper(removed)
[13:36:56.859]                 for (kk in seq_along(NAMES)) {
[13:36:56.859]                   name <- removed[[kk]]
[13:36:56.859]                   NAME <- NAMES[[kk]]
[13:36:56.859]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.859]                     next
[13:36:56.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.859]                 }
[13:36:56.859]                 if (length(args) > 0) 
[13:36:56.859]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.859]             }
[13:36:56.859]             else {
[13:36:56.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.859]             }
[13:36:56.859]             {
[13:36:56.859]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.859]                   0L) {
[13:36:56.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.859]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.859]                   base::options(opts)
[13:36:56.859]                 }
[13:36:56.859]                 {
[13:36:56.859]                   {
[13:36:56.859]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.859]                     NULL
[13:36:56.859]                   }
[13:36:56.859]                   options(future.plan = NULL)
[13:36:56.859]                   if (is.na(NA_character_)) 
[13:36:56.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.859]                     .init = FALSE)
[13:36:56.859]                 }
[13:36:56.859]             }
[13:36:56.859]         }
[13:36:56.859]     })
[13:36:56.859]     if (TRUE) {
[13:36:56.859]         base::sink(type = "output", split = FALSE)
[13:36:56.859]         if (TRUE) {
[13:36:56.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.859]         }
[13:36:56.859]         else {
[13:36:56.859]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.859]         }
[13:36:56.859]         base::close(...future.stdout)
[13:36:56.859]         ...future.stdout <- NULL
[13:36:56.859]     }
[13:36:56.859]     ...future.result$conditions <- ...future.conditions
[13:36:56.859]     ...future.result$finished <- base::Sys.time()
[13:36:56.859]     ...future.result
[13:36:56.859] }
[13:36:56.861] assign_globals() ...
[13:36:56.861] List of 1
[13:36:56.861]  $ a: num 3
[13:36:56.861]  - attr(*, "where")=List of 1
[13:36:56.861]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.861]  - attr(*, "resolved")= logi TRUE
[13:36:56.861]  - attr(*, "total_size")= num 56
[13:36:56.861]  - attr(*, "already-done")= logi TRUE
[13:36:56.863] - copied ‘a’ to environment
[13:36:56.863] assign_globals() ... done
[13:36:56.863] requestCore(): workers = 2
[13:36:56.865] MulticoreFuture started
[13:36:56.866] - Launch lazy future ... done
[13:36:56.866] run() for ‘MulticoreFuture’ ... done
[13:36:56.866] result() for MulticoreFuture ...
[13:36:56.867] plan(): Setting new future strategy stack:
[13:36:56.867] List of future strategies:
[13:36:56.867] 1. sequential:
[13:36:56.867]    - args: function (..., envir = parent.frame())
[13:36:56.867]    - tweaked: FALSE
[13:36:56.867]    - call: NULL
[13:36:56.868] plan(): nbrOfWorkers() = 1
[13:36:56.869] plan(): Setting new future strategy stack:
[13:36:56.870] List of future strategies:
[13:36:56.870] 1. multicore:
[13:36:56.870]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.870]    - tweaked: FALSE
[13:36:56.870]    - call: plan(strategy)
[13:36:56.875] plan(): nbrOfWorkers() = 2
[13:36:56.875] result() for MulticoreFuture ...
[13:36:56.876] result() for MulticoreFuture ... done
[13:36:56.876] result() for MulticoreFuture ... done
[13:36:56.876] result() for MulticoreFuture ...
[13:36:56.876] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.877] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.877] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.887] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:56.887] Searching for globals ... DONE
[13:36:56.887] Resolving globals: TRUE
[13:36:56.887] Resolving any globals that are futures ...
[13:36:56.888] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:56.888] Resolving any globals that are futures ... DONE
[13:36:56.888] Resolving futures part of globals (recursively) ...
[13:36:56.888] resolve() on list ...
[13:36:56.888]  recursive: 99
[13:36:56.889]  length: 1
[13:36:56.889]  elements: ‘a’
[13:36:56.889]  length: 0 (resolved future 1)
[13:36:56.889] resolve() on list ... DONE
[13:36:56.889] - globals: [1] ‘a’
[13:36:56.889] Resolving futures part of globals (recursively) ... DONE
[13:36:56.889] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:56.890] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:56.890] - globals: [1] ‘a’
[13:36:56.890] 
[13:36:56.890] getGlobalsAndPackages() ... DONE
[13:36:56.890] run() for ‘Future’ ...
[13:36:56.890] - state: ‘created’
[13:36:56.891] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.894] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.894] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.895]   - Field: ‘label’
[13:36:56.895]   - Field: ‘local’
[13:36:56.895]   - Field: ‘owner’
[13:36:56.895]   - Field: ‘envir’
[13:36:56.895]   - Field: ‘workers’
[13:36:56.895]   - Field: ‘packages’
[13:36:56.895]   - Field: ‘gc’
[13:36:56.895]   - Field: ‘job’
[13:36:56.896]   - Field: ‘conditions’
[13:36:56.896]   - Field: ‘expr’
[13:36:56.896]   - Field: ‘uuid’
[13:36:56.896]   - Field: ‘seed’
[13:36:56.896]   - Field: ‘version’
[13:36:56.896]   - Field: ‘result’
[13:36:56.896]   - Field: ‘asynchronous’
[13:36:56.896]   - Field: ‘calls’
[13:36:56.897]   - Field: ‘globals’
[13:36:56.897]   - Field: ‘stdout’
[13:36:56.897]   - Field: ‘earlySignal’
[13:36:56.897]   - Field: ‘lazy’
[13:36:56.897]   - Field: ‘state’
[13:36:56.897] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.897] - Launch lazy future ...
[13:36:56.897] Packages needed by the future expression (n = 0): <none>
[13:36:56.898] Packages needed by future strategies (n = 0): <none>
[13:36:56.898] {
[13:36:56.898]     {
[13:36:56.898]         {
[13:36:56.898]             ...future.startTime <- base::Sys.time()
[13:36:56.898]             {
[13:36:56.898]                 {
[13:36:56.898]                   {
[13:36:56.898]                     {
[13:36:56.898]                       base::local({
[13:36:56.898]                         has_future <- base::requireNamespace("future", 
[13:36:56.898]                           quietly = TRUE)
[13:36:56.898]                         if (has_future) {
[13:36:56.898]                           ns <- base::getNamespace("future")
[13:36:56.898]                           version <- ns[[".package"]][["version"]]
[13:36:56.898]                           if (is.null(version)) 
[13:36:56.898]                             version <- utils::packageVersion("future")
[13:36:56.898]                         }
[13:36:56.898]                         else {
[13:36:56.898]                           version <- NULL
[13:36:56.898]                         }
[13:36:56.898]                         if (!has_future || version < "1.8.0") {
[13:36:56.898]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.898]                             "", base::R.version$version.string), 
[13:36:56.898]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.898]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.898]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.898]                               "release", "version")], collapse = " "), 
[13:36:56.898]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.898]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.898]                             info)
[13:36:56.898]                           info <- base::paste(info, collapse = "; ")
[13:36:56.898]                           if (!has_future) {
[13:36:56.898]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.898]                               info)
[13:36:56.898]                           }
[13:36:56.898]                           else {
[13:36:56.898]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.898]                               info, version)
[13:36:56.898]                           }
[13:36:56.898]                           base::stop(msg)
[13:36:56.898]                         }
[13:36:56.898]                       })
[13:36:56.898]                     }
[13:36:56.898]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.898]                     base::options(mc.cores = 1L)
[13:36:56.898]                   }
[13:36:56.898]                   ...future.strategy.old <- future::plan("list")
[13:36:56.898]                   options(future.plan = NULL)
[13:36:56.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.898]                 }
[13:36:56.898]                 ...future.workdir <- getwd()
[13:36:56.898]             }
[13:36:56.898]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.898]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.898]         }
[13:36:56.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.898]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.898]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.898]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.898]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.898]             base::names(...future.oldOptions))
[13:36:56.898]     }
[13:36:56.898]     if (FALSE) {
[13:36:56.898]     }
[13:36:56.898]     else {
[13:36:56.898]         if (TRUE) {
[13:36:56.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.898]                 open = "w")
[13:36:56.898]         }
[13:36:56.898]         else {
[13:36:56.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.898]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.898]         }
[13:36:56.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.898]             base::sink(type = "output", split = FALSE)
[13:36:56.898]             base::close(...future.stdout)
[13:36:56.898]         }, add = TRUE)
[13:36:56.898]     }
[13:36:56.898]     ...future.frame <- base::sys.nframe()
[13:36:56.898]     ...future.conditions <- base::list()
[13:36:56.898]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.898]     if (FALSE) {
[13:36:56.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.898]     }
[13:36:56.898]     ...future.result <- base::tryCatch({
[13:36:56.898]         base::withCallingHandlers({
[13:36:56.898]             ...future.value <- base::withVisible(base::local({
[13:36:56.898]                 withCallingHandlers({
[13:36:56.898]                   {
[13:36:56.898]                     b <- a
[13:36:56.898]                     a <- 2
[13:36:56.898]                     a * b
[13:36:56.898]                   }
[13:36:56.898]                 }, immediateCondition = function(cond) {
[13:36:56.898]                   save_rds <- function (object, pathname, ...) 
[13:36:56.898]                   {
[13:36:56.898]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.898]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.898]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.898]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.898]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.898]                         fi_tmp[["mtime"]])
[13:36:56.898]                     }
[13:36:56.898]                     tryCatch({
[13:36:56.898]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.898]                     }, error = function(ex) {
[13:36:56.898]                       msg <- conditionMessage(ex)
[13:36:56.898]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.898]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.898]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.898]                         fi_tmp[["mtime"]], msg)
[13:36:56.898]                       ex$message <- msg
[13:36:56.898]                       stop(ex)
[13:36:56.898]                     })
[13:36:56.898]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.898]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.898]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.898]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.898]                       fi <- file.info(pathname)
[13:36:56.898]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.898]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.898]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.898]                         fi[["size"]], fi[["mtime"]])
[13:36:56.898]                       stop(msg)
[13:36:56.898]                     }
[13:36:56.898]                     invisible(pathname)
[13:36:56.898]                   }
[13:36:56.898]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.898]                     rootPath = tempdir()) 
[13:36:56.898]                   {
[13:36:56.898]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.898]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.898]                       tmpdir = path, fileext = ".rds")
[13:36:56.898]                     save_rds(obj, file)
[13:36:56.898]                   }
[13:36:56.898]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.898]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.898]                   {
[13:36:56.898]                     inherits <- base::inherits
[13:36:56.898]                     invokeRestart <- base::invokeRestart
[13:36:56.898]                     is.null <- base::is.null
[13:36:56.898]                     muffled <- FALSE
[13:36:56.898]                     if (inherits(cond, "message")) {
[13:36:56.898]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.898]                       if (muffled) 
[13:36:56.898]                         invokeRestart("muffleMessage")
[13:36:56.898]                     }
[13:36:56.898]                     else if (inherits(cond, "warning")) {
[13:36:56.898]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.898]                       if (muffled) 
[13:36:56.898]                         invokeRestart("muffleWarning")
[13:36:56.898]                     }
[13:36:56.898]                     else if (inherits(cond, "condition")) {
[13:36:56.898]                       if (!is.null(pattern)) {
[13:36:56.898]                         computeRestarts <- base::computeRestarts
[13:36:56.898]                         grepl <- base::grepl
[13:36:56.898]                         restarts <- computeRestarts(cond)
[13:36:56.898]                         for (restart in restarts) {
[13:36:56.898]                           name <- restart$name
[13:36:56.898]                           if (is.null(name)) 
[13:36:56.898]                             next
[13:36:56.898]                           if (!grepl(pattern, name)) 
[13:36:56.898]                             next
[13:36:56.898]                           invokeRestart(restart)
[13:36:56.898]                           muffled <- TRUE
[13:36:56.898]                           break
[13:36:56.898]                         }
[13:36:56.898]                       }
[13:36:56.898]                     }
[13:36:56.898]                     invisible(muffled)
[13:36:56.898]                   }
[13:36:56.898]                   muffleCondition(cond)
[13:36:56.898]                 })
[13:36:56.898]             }))
[13:36:56.898]             future::FutureResult(value = ...future.value$value, 
[13:36:56.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.898]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.898]                     ...future.globalenv.names))
[13:36:56.898]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.898]         }, condition = base::local({
[13:36:56.898]             c <- base::c
[13:36:56.898]             inherits <- base::inherits
[13:36:56.898]             invokeRestart <- base::invokeRestart
[13:36:56.898]             length <- base::length
[13:36:56.898]             list <- base::list
[13:36:56.898]             seq.int <- base::seq.int
[13:36:56.898]             signalCondition <- base::signalCondition
[13:36:56.898]             sys.calls <- base::sys.calls
[13:36:56.898]             `[[` <- base::`[[`
[13:36:56.898]             `+` <- base::`+`
[13:36:56.898]             `<<-` <- base::`<<-`
[13:36:56.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.898]                   3L)]
[13:36:56.898]             }
[13:36:56.898]             function(cond) {
[13:36:56.898]                 is_error <- inherits(cond, "error")
[13:36:56.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.898]                   NULL)
[13:36:56.898]                 if (is_error) {
[13:36:56.898]                   sessionInformation <- function() {
[13:36:56.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.898]                       search = base::search(), system = base::Sys.info())
[13:36:56.898]                   }
[13:36:56.898]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.898]                     cond$call), session = sessionInformation(), 
[13:36:56.898]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.898]                   signalCondition(cond)
[13:36:56.898]                 }
[13:36:56.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.898]                 "immediateCondition"))) {
[13:36:56.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.898]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.898]                   if (TRUE && !signal) {
[13:36:56.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.898]                     {
[13:36:56.898]                       inherits <- base::inherits
[13:36:56.898]                       invokeRestart <- base::invokeRestart
[13:36:56.898]                       is.null <- base::is.null
[13:36:56.898]                       muffled <- FALSE
[13:36:56.898]                       if (inherits(cond, "message")) {
[13:36:56.898]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.898]                         if (muffled) 
[13:36:56.898]                           invokeRestart("muffleMessage")
[13:36:56.898]                       }
[13:36:56.898]                       else if (inherits(cond, "warning")) {
[13:36:56.898]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.898]                         if (muffled) 
[13:36:56.898]                           invokeRestart("muffleWarning")
[13:36:56.898]                       }
[13:36:56.898]                       else if (inherits(cond, "condition")) {
[13:36:56.898]                         if (!is.null(pattern)) {
[13:36:56.898]                           computeRestarts <- base::computeRestarts
[13:36:56.898]                           grepl <- base::grepl
[13:36:56.898]                           restarts <- computeRestarts(cond)
[13:36:56.898]                           for (restart in restarts) {
[13:36:56.898]                             name <- restart$name
[13:36:56.898]                             if (is.null(name)) 
[13:36:56.898]                               next
[13:36:56.898]                             if (!grepl(pattern, name)) 
[13:36:56.898]                               next
[13:36:56.898]                             invokeRestart(restart)
[13:36:56.898]                             muffled <- TRUE
[13:36:56.898]                             break
[13:36:56.898]                           }
[13:36:56.898]                         }
[13:36:56.898]                       }
[13:36:56.898]                       invisible(muffled)
[13:36:56.898]                     }
[13:36:56.898]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.898]                   }
[13:36:56.898]                 }
[13:36:56.898]                 else {
[13:36:56.898]                   if (TRUE) {
[13:36:56.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.898]                     {
[13:36:56.898]                       inherits <- base::inherits
[13:36:56.898]                       invokeRestart <- base::invokeRestart
[13:36:56.898]                       is.null <- base::is.null
[13:36:56.898]                       muffled <- FALSE
[13:36:56.898]                       if (inherits(cond, "message")) {
[13:36:56.898]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.898]                         if (muffled) 
[13:36:56.898]                           invokeRestart("muffleMessage")
[13:36:56.898]                       }
[13:36:56.898]                       else if (inherits(cond, "warning")) {
[13:36:56.898]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.898]                         if (muffled) 
[13:36:56.898]                           invokeRestart("muffleWarning")
[13:36:56.898]                       }
[13:36:56.898]                       else if (inherits(cond, "condition")) {
[13:36:56.898]                         if (!is.null(pattern)) {
[13:36:56.898]                           computeRestarts <- base::computeRestarts
[13:36:56.898]                           grepl <- base::grepl
[13:36:56.898]                           restarts <- computeRestarts(cond)
[13:36:56.898]                           for (restart in restarts) {
[13:36:56.898]                             name <- restart$name
[13:36:56.898]                             if (is.null(name)) 
[13:36:56.898]                               next
[13:36:56.898]                             if (!grepl(pattern, name)) 
[13:36:56.898]                               next
[13:36:56.898]                             invokeRestart(restart)
[13:36:56.898]                             muffled <- TRUE
[13:36:56.898]                             break
[13:36:56.898]                           }
[13:36:56.898]                         }
[13:36:56.898]                       }
[13:36:56.898]                       invisible(muffled)
[13:36:56.898]                     }
[13:36:56.898]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.898]                   }
[13:36:56.898]                 }
[13:36:56.898]             }
[13:36:56.898]         }))
[13:36:56.898]     }, error = function(ex) {
[13:36:56.898]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.898]                 ...future.rng), started = ...future.startTime, 
[13:36:56.898]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.898]             version = "1.8"), class = "FutureResult")
[13:36:56.898]     }, finally = {
[13:36:56.898]         if (!identical(...future.workdir, getwd())) 
[13:36:56.898]             setwd(...future.workdir)
[13:36:56.898]         {
[13:36:56.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.898]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.898]             }
[13:36:56.898]             base::options(...future.oldOptions)
[13:36:56.898]             if (.Platform$OS.type == "windows") {
[13:36:56.898]                 old_names <- names(...future.oldEnvVars)
[13:36:56.898]                 envs <- base::Sys.getenv()
[13:36:56.898]                 names <- names(envs)
[13:36:56.898]                 common <- intersect(names, old_names)
[13:36:56.898]                 added <- setdiff(names, old_names)
[13:36:56.898]                 removed <- setdiff(old_names, names)
[13:36:56.898]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.898]                   envs[common]]
[13:36:56.898]                 NAMES <- toupper(changed)
[13:36:56.898]                 args <- list()
[13:36:56.898]                 for (kk in seq_along(NAMES)) {
[13:36:56.898]                   name <- changed[[kk]]
[13:36:56.898]                   NAME <- NAMES[[kk]]
[13:36:56.898]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.898]                     next
[13:36:56.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.898]                 }
[13:36:56.898]                 NAMES <- toupper(added)
[13:36:56.898]                 for (kk in seq_along(NAMES)) {
[13:36:56.898]                   name <- added[[kk]]
[13:36:56.898]                   NAME <- NAMES[[kk]]
[13:36:56.898]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.898]                     next
[13:36:56.898]                   args[[name]] <- ""
[13:36:56.898]                 }
[13:36:56.898]                 NAMES <- toupper(removed)
[13:36:56.898]                 for (kk in seq_along(NAMES)) {
[13:36:56.898]                   name <- removed[[kk]]
[13:36:56.898]                   NAME <- NAMES[[kk]]
[13:36:56.898]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.898]                     next
[13:36:56.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.898]                 }
[13:36:56.898]                 if (length(args) > 0) 
[13:36:56.898]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.898]             }
[13:36:56.898]             else {
[13:36:56.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.898]             }
[13:36:56.898]             {
[13:36:56.898]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.898]                   0L) {
[13:36:56.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.898]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.898]                   base::options(opts)
[13:36:56.898]                 }
[13:36:56.898]                 {
[13:36:56.898]                   {
[13:36:56.898]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.898]                     NULL
[13:36:56.898]                   }
[13:36:56.898]                   options(future.plan = NULL)
[13:36:56.898]                   if (is.na(NA_character_)) 
[13:36:56.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.898]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.898]                     .init = FALSE)
[13:36:56.898]                 }
[13:36:56.898]             }
[13:36:56.898]         }
[13:36:56.898]     })
[13:36:56.898]     if (TRUE) {
[13:36:56.898]         base::sink(type = "output", split = FALSE)
[13:36:56.898]         if (TRUE) {
[13:36:56.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.898]         }
[13:36:56.898]         else {
[13:36:56.898]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.898]         }
[13:36:56.898]         base::close(...future.stdout)
[13:36:56.898]         ...future.stdout <- NULL
[13:36:56.898]     }
[13:36:56.898]     ...future.result$conditions <- ...future.conditions
[13:36:56.898]     ...future.result$finished <- base::Sys.time()
[13:36:56.898]     ...future.result
[13:36:56.898] }
[13:36:56.900] assign_globals() ...
[13:36:56.900] List of 1
[13:36:56.900]  $ a: num 3
[13:36:56.900]  - attr(*, "where")=List of 1
[13:36:56.900]   ..$ a:<environment: R_EmptyEnv> 
[13:36:56.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.900]  - attr(*, "resolved")= logi TRUE
[13:36:56.900]  - attr(*, "total_size")= num 56
[13:36:56.900]  - attr(*, "already-done")= logi TRUE
[13:36:56.903] - copied ‘a’ to environment
[13:36:56.904] assign_globals() ... done
[13:36:56.904] requestCore(): workers = 2
[13:36:56.905] MulticoreFuture started
[13:36:56.906] - Launch lazy future ... done
[13:36:56.906] run() for ‘MulticoreFuture’ ... done
[13:36:56.906] result() for MulticoreFuture ...
[13:36:56.907] plan(): Setting new future strategy stack:
[13:36:56.907] List of future strategies:
[13:36:56.907] 1. sequential:
[13:36:56.907]    - args: function (..., envir = parent.frame())
[13:36:56.907]    - tweaked: FALSE
[13:36:56.907]    - call: NULL
[13:36:56.908] plan(): nbrOfWorkers() = 1
[13:36:56.910] plan(): Setting new future strategy stack:
[13:36:56.910] List of future strategies:
[13:36:56.910] 1. multicore:
[13:36:56.910]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.910]    - tweaked: FALSE
[13:36:56.910]    - call: plan(strategy)
[13:36:56.916] plan(): nbrOfWorkers() = 2
[13:36:56.916] result() for MulticoreFuture ...
[13:36:56.916] result() for MulticoreFuture ... done
[13:36:56.917] result() for MulticoreFuture ... done
[13:36:56.917] result() for MulticoreFuture ...
[13:36:56.917] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.918] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.918] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.921] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.921] Searching for globals ... DONE
[13:36:56.921] Resolving globals: TRUE
[13:36:56.921] Resolving any globals that are futures ...
[13:36:56.922] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.922] Resolving any globals that are futures ... DONE
[13:36:56.922] Resolving futures part of globals (recursively) ...
[13:36:56.923] resolve() on list ...
[13:36:56.923]  recursive: 99
[13:36:56.923]  length: 2
[13:36:56.923]  elements: ‘a’, ‘ii’
[13:36:56.923]  length: 1 (resolved future 1)
[13:36:56.923]  length: 0 (resolved future 2)
[13:36:56.923] resolve() on list ... DONE
[13:36:56.923] - globals: [2] ‘a’, ‘ii’
[13:36:56.924] Resolving futures part of globals (recursively) ... DONE
[13:36:56.924] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:56.924] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.924] - globals: [2] ‘a’, ‘ii’
[13:36:56.925] 
[13:36:56.925] getGlobalsAndPackages() ... DONE
[13:36:56.925] run() for ‘Future’ ...
[13:36:56.925] - state: ‘created’
[13:36:56.925] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.929] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.930] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.930]   - Field: ‘label’
[13:36:56.930]   - Field: ‘local’
[13:36:56.930]   - Field: ‘owner’
[13:36:56.930]   - Field: ‘envir’
[13:36:56.930]   - Field: ‘workers’
[13:36:56.930]   - Field: ‘packages’
[13:36:56.930]   - Field: ‘gc’
[13:36:56.931]   - Field: ‘job’
[13:36:56.931]   - Field: ‘conditions’
[13:36:56.931]   - Field: ‘expr’
[13:36:56.931]   - Field: ‘uuid’
[13:36:56.931]   - Field: ‘seed’
[13:36:56.931]   - Field: ‘version’
[13:36:56.931]   - Field: ‘result’
[13:36:56.931]   - Field: ‘asynchronous’
[13:36:56.932]   - Field: ‘calls’
[13:36:56.932]   - Field: ‘globals’
[13:36:56.932]   - Field: ‘stdout’
[13:36:56.932]   - Field: ‘earlySignal’
[13:36:56.932]   - Field: ‘lazy’
[13:36:56.932]   - Field: ‘state’
[13:36:56.932] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.932] - Launch lazy future ...
[13:36:56.933] Packages needed by the future expression (n = 0): <none>
[13:36:56.935] Packages needed by future strategies (n = 0): <none>
[13:36:56.936] {
[13:36:56.936]     {
[13:36:56.936]         {
[13:36:56.936]             ...future.startTime <- base::Sys.time()
[13:36:56.936]             {
[13:36:56.936]                 {
[13:36:56.936]                   {
[13:36:56.936]                     {
[13:36:56.936]                       base::local({
[13:36:56.936]                         has_future <- base::requireNamespace("future", 
[13:36:56.936]                           quietly = TRUE)
[13:36:56.936]                         if (has_future) {
[13:36:56.936]                           ns <- base::getNamespace("future")
[13:36:56.936]                           version <- ns[[".package"]][["version"]]
[13:36:56.936]                           if (is.null(version)) 
[13:36:56.936]                             version <- utils::packageVersion("future")
[13:36:56.936]                         }
[13:36:56.936]                         else {
[13:36:56.936]                           version <- NULL
[13:36:56.936]                         }
[13:36:56.936]                         if (!has_future || version < "1.8.0") {
[13:36:56.936]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.936]                             "", base::R.version$version.string), 
[13:36:56.936]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.936]                               "release", "version")], collapse = " "), 
[13:36:56.936]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.936]                             info)
[13:36:56.936]                           info <- base::paste(info, collapse = "; ")
[13:36:56.936]                           if (!has_future) {
[13:36:56.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.936]                               info)
[13:36:56.936]                           }
[13:36:56.936]                           else {
[13:36:56.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.936]                               info, version)
[13:36:56.936]                           }
[13:36:56.936]                           base::stop(msg)
[13:36:56.936]                         }
[13:36:56.936]                       })
[13:36:56.936]                     }
[13:36:56.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.936]                     base::options(mc.cores = 1L)
[13:36:56.936]                   }
[13:36:56.936]                   ...future.strategy.old <- future::plan("list")
[13:36:56.936]                   options(future.plan = NULL)
[13:36:56.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.936]                 }
[13:36:56.936]                 ...future.workdir <- getwd()
[13:36:56.936]             }
[13:36:56.936]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.936]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.936]         }
[13:36:56.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.936]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.936]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.936]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.936]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.936]             base::names(...future.oldOptions))
[13:36:56.936]     }
[13:36:56.936]     if (FALSE) {
[13:36:56.936]     }
[13:36:56.936]     else {
[13:36:56.936]         if (TRUE) {
[13:36:56.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.936]                 open = "w")
[13:36:56.936]         }
[13:36:56.936]         else {
[13:36:56.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.936]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.936]         }
[13:36:56.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.936]             base::sink(type = "output", split = FALSE)
[13:36:56.936]             base::close(...future.stdout)
[13:36:56.936]         }, add = TRUE)
[13:36:56.936]     }
[13:36:56.936]     ...future.frame <- base::sys.nframe()
[13:36:56.936]     ...future.conditions <- base::list()
[13:36:56.936]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.936]     if (FALSE) {
[13:36:56.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.936]     }
[13:36:56.936]     ...future.result <- base::tryCatch({
[13:36:56.936]         base::withCallingHandlers({
[13:36:56.936]             ...future.value <- base::withVisible(base::local({
[13:36:56.936]                 withCallingHandlers({
[13:36:56.936]                   {
[13:36:56.936]                     b <- a * ii
[13:36:56.936]                     a <- 0
[13:36:56.936]                     b
[13:36:56.936]                   }
[13:36:56.936]                 }, immediateCondition = function(cond) {
[13:36:56.936]                   save_rds <- function (object, pathname, ...) 
[13:36:56.936]                   {
[13:36:56.936]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.936]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.936]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.936]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.936]                         fi_tmp[["mtime"]])
[13:36:56.936]                     }
[13:36:56.936]                     tryCatch({
[13:36:56.936]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.936]                     }, error = function(ex) {
[13:36:56.936]                       msg <- conditionMessage(ex)
[13:36:56.936]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.936]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.936]                         fi_tmp[["mtime"]], msg)
[13:36:56.936]                       ex$message <- msg
[13:36:56.936]                       stop(ex)
[13:36:56.936]                     })
[13:36:56.936]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.936]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.936]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.936]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.936]                       fi <- file.info(pathname)
[13:36:56.936]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.936]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.936]                         fi[["size"]], fi[["mtime"]])
[13:36:56.936]                       stop(msg)
[13:36:56.936]                     }
[13:36:56.936]                     invisible(pathname)
[13:36:56.936]                   }
[13:36:56.936]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.936]                     rootPath = tempdir()) 
[13:36:56.936]                   {
[13:36:56.936]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.936]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.936]                       tmpdir = path, fileext = ".rds")
[13:36:56.936]                     save_rds(obj, file)
[13:36:56.936]                   }
[13:36:56.936]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.936]                   {
[13:36:56.936]                     inherits <- base::inherits
[13:36:56.936]                     invokeRestart <- base::invokeRestart
[13:36:56.936]                     is.null <- base::is.null
[13:36:56.936]                     muffled <- FALSE
[13:36:56.936]                     if (inherits(cond, "message")) {
[13:36:56.936]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.936]                       if (muffled) 
[13:36:56.936]                         invokeRestart("muffleMessage")
[13:36:56.936]                     }
[13:36:56.936]                     else if (inherits(cond, "warning")) {
[13:36:56.936]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.936]                       if (muffled) 
[13:36:56.936]                         invokeRestart("muffleWarning")
[13:36:56.936]                     }
[13:36:56.936]                     else if (inherits(cond, "condition")) {
[13:36:56.936]                       if (!is.null(pattern)) {
[13:36:56.936]                         computeRestarts <- base::computeRestarts
[13:36:56.936]                         grepl <- base::grepl
[13:36:56.936]                         restarts <- computeRestarts(cond)
[13:36:56.936]                         for (restart in restarts) {
[13:36:56.936]                           name <- restart$name
[13:36:56.936]                           if (is.null(name)) 
[13:36:56.936]                             next
[13:36:56.936]                           if (!grepl(pattern, name)) 
[13:36:56.936]                             next
[13:36:56.936]                           invokeRestart(restart)
[13:36:56.936]                           muffled <- TRUE
[13:36:56.936]                           break
[13:36:56.936]                         }
[13:36:56.936]                       }
[13:36:56.936]                     }
[13:36:56.936]                     invisible(muffled)
[13:36:56.936]                   }
[13:36:56.936]                   muffleCondition(cond)
[13:36:56.936]                 })
[13:36:56.936]             }))
[13:36:56.936]             future::FutureResult(value = ...future.value$value, 
[13:36:56.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.936]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.936]                     ...future.globalenv.names))
[13:36:56.936]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.936]         }, condition = base::local({
[13:36:56.936]             c <- base::c
[13:36:56.936]             inherits <- base::inherits
[13:36:56.936]             invokeRestart <- base::invokeRestart
[13:36:56.936]             length <- base::length
[13:36:56.936]             list <- base::list
[13:36:56.936]             seq.int <- base::seq.int
[13:36:56.936]             signalCondition <- base::signalCondition
[13:36:56.936]             sys.calls <- base::sys.calls
[13:36:56.936]             `[[` <- base::`[[`
[13:36:56.936]             `+` <- base::`+`
[13:36:56.936]             `<<-` <- base::`<<-`
[13:36:56.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.936]                   3L)]
[13:36:56.936]             }
[13:36:56.936]             function(cond) {
[13:36:56.936]                 is_error <- inherits(cond, "error")
[13:36:56.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.936]                   NULL)
[13:36:56.936]                 if (is_error) {
[13:36:56.936]                   sessionInformation <- function() {
[13:36:56.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.936]                       search = base::search(), system = base::Sys.info())
[13:36:56.936]                   }
[13:36:56.936]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.936]                     cond$call), session = sessionInformation(), 
[13:36:56.936]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.936]                   signalCondition(cond)
[13:36:56.936]                 }
[13:36:56.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.936]                 "immediateCondition"))) {
[13:36:56.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.936]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.936]                   if (TRUE && !signal) {
[13:36:56.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.936]                     {
[13:36:56.936]                       inherits <- base::inherits
[13:36:56.936]                       invokeRestart <- base::invokeRestart
[13:36:56.936]                       is.null <- base::is.null
[13:36:56.936]                       muffled <- FALSE
[13:36:56.936]                       if (inherits(cond, "message")) {
[13:36:56.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.936]                         if (muffled) 
[13:36:56.936]                           invokeRestart("muffleMessage")
[13:36:56.936]                       }
[13:36:56.936]                       else if (inherits(cond, "warning")) {
[13:36:56.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.936]                         if (muffled) 
[13:36:56.936]                           invokeRestart("muffleWarning")
[13:36:56.936]                       }
[13:36:56.936]                       else if (inherits(cond, "condition")) {
[13:36:56.936]                         if (!is.null(pattern)) {
[13:36:56.936]                           computeRestarts <- base::computeRestarts
[13:36:56.936]                           grepl <- base::grepl
[13:36:56.936]                           restarts <- computeRestarts(cond)
[13:36:56.936]                           for (restart in restarts) {
[13:36:56.936]                             name <- restart$name
[13:36:56.936]                             if (is.null(name)) 
[13:36:56.936]                               next
[13:36:56.936]                             if (!grepl(pattern, name)) 
[13:36:56.936]                               next
[13:36:56.936]                             invokeRestart(restart)
[13:36:56.936]                             muffled <- TRUE
[13:36:56.936]                             break
[13:36:56.936]                           }
[13:36:56.936]                         }
[13:36:56.936]                       }
[13:36:56.936]                       invisible(muffled)
[13:36:56.936]                     }
[13:36:56.936]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.936]                   }
[13:36:56.936]                 }
[13:36:56.936]                 else {
[13:36:56.936]                   if (TRUE) {
[13:36:56.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.936]                     {
[13:36:56.936]                       inherits <- base::inherits
[13:36:56.936]                       invokeRestart <- base::invokeRestart
[13:36:56.936]                       is.null <- base::is.null
[13:36:56.936]                       muffled <- FALSE
[13:36:56.936]                       if (inherits(cond, "message")) {
[13:36:56.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.936]                         if (muffled) 
[13:36:56.936]                           invokeRestart("muffleMessage")
[13:36:56.936]                       }
[13:36:56.936]                       else if (inherits(cond, "warning")) {
[13:36:56.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.936]                         if (muffled) 
[13:36:56.936]                           invokeRestart("muffleWarning")
[13:36:56.936]                       }
[13:36:56.936]                       else if (inherits(cond, "condition")) {
[13:36:56.936]                         if (!is.null(pattern)) {
[13:36:56.936]                           computeRestarts <- base::computeRestarts
[13:36:56.936]                           grepl <- base::grepl
[13:36:56.936]                           restarts <- computeRestarts(cond)
[13:36:56.936]                           for (restart in restarts) {
[13:36:56.936]                             name <- restart$name
[13:36:56.936]                             if (is.null(name)) 
[13:36:56.936]                               next
[13:36:56.936]                             if (!grepl(pattern, name)) 
[13:36:56.936]                               next
[13:36:56.936]                             invokeRestart(restart)
[13:36:56.936]                             muffled <- TRUE
[13:36:56.936]                             break
[13:36:56.936]                           }
[13:36:56.936]                         }
[13:36:56.936]                       }
[13:36:56.936]                       invisible(muffled)
[13:36:56.936]                     }
[13:36:56.936]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.936]                   }
[13:36:56.936]                 }
[13:36:56.936]             }
[13:36:56.936]         }))
[13:36:56.936]     }, error = function(ex) {
[13:36:56.936]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.936]                 ...future.rng), started = ...future.startTime, 
[13:36:56.936]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.936]             version = "1.8"), class = "FutureResult")
[13:36:56.936]     }, finally = {
[13:36:56.936]         if (!identical(...future.workdir, getwd())) 
[13:36:56.936]             setwd(...future.workdir)
[13:36:56.936]         {
[13:36:56.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.936]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.936]             }
[13:36:56.936]             base::options(...future.oldOptions)
[13:36:56.936]             if (.Platform$OS.type == "windows") {
[13:36:56.936]                 old_names <- names(...future.oldEnvVars)
[13:36:56.936]                 envs <- base::Sys.getenv()
[13:36:56.936]                 names <- names(envs)
[13:36:56.936]                 common <- intersect(names, old_names)
[13:36:56.936]                 added <- setdiff(names, old_names)
[13:36:56.936]                 removed <- setdiff(old_names, names)
[13:36:56.936]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.936]                   envs[common]]
[13:36:56.936]                 NAMES <- toupper(changed)
[13:36:56.936]                 args <- list()
[13:36:56.936]                 for (kk in seq_along(NAMES)) {
[13:36:56.936]                   name <- changed[[kk]]
[13:36:56.936]                   NAME <- NAMES[[kk]]
[13:36:56.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.936]                     next
[13:36:56.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.936]                 }
[13:36:56.936]                 NAMES <- toupper(added)
[13:36:56.936]                 for (kk in seq_along(NAMES)) {
[13:36:56.936]                   name <- added[[kk]]
[13:36:56.936]                   NAME <- NAMES[[kk]]
[13:36:56.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.936]                     next
[13:36:56.936]                   args[[name]] <- ""
[13:36:56.936]                 }
[13:36:56.936]                 NAMES <- toupper(removed)
[13:36:56.936]                 for (kk in seq_along(NAMES)) {
[13:36:56.936]                   name <- removed[[kk]]
[13:36:56.936]                   NAME <- NAMES[[kk]]
[13:36:56.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.936]                     next
[13:36:56.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.936]                 }
[13:36:56.936]                 if (length(args) > 0) 
[13:36:56.936]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.936]             }
[13:36:56.936]             else {
[13:36:56.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.936]             }
[13:36:56.936]             {
[13:36:56.936]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.936]                   0L) {
[13:36:56.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.936]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.936]                   base::options(opts)
[13:36:56.936]                 }
[13:36:56.936]                 {
[13:36:56.936]                   {
[13:36:56.936]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.936]                     NULL
[13:36:56.936]                   }
[13:36:56.936]                   options(future.plan = NULL)
[13:36:56.936]                   if (is.na(NA_character_)) 
[13:36:56.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.936]                     .init = FALSE)
[13:36:56.936]                 }
[13:36:56.936]             }
[13:36:56.936]         }
[13:36:56.936]     })
[13:36:56.936]     if (TRUE) {
[13:36:56.936]         base::sink(type = "output", split = FALSE)
[13:36:56.936]         if (TRUE) {
[13:36:56.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.936]         }
[13:36:56.936]         else {
[13:36:56.936]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.936]         }
[13:36:56.936]         base::close(...future.stdout)
[13:36:56.936]         ...future.stdout <- NULL
[13:36:56.936]     }
[13:36:56.936]     ...future.result$conditions <- ...future.conditions
[13:36:56.936]     ...future.result$finished <- base::Sys.time()
[13:36:56.936]     ...future.result
[13:36:56.936] }
[13:36:56.938] assign_globals() ...
[13:36:56.938] List of 2
[13:36:56.938]  $ a : num 1
[13:36:56.938]  $ ii: int 1
[13:36:56.938]  - attr(*, "where")=List of 2
[13:36:56.938]   ..$ a :<environment: R_EmptyEnv> 
[13:36:56.938]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.938]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.938]  - attr(*, "resolved")= logi TRUE
[13:36:56.938]  - attr(*, "total_size")= num 112
[13:36:56.938]  - attr(*, "already-done")= logi TRUE
[13:36:56.943] - copied ‘a’ to environment
[13:36:56.943] - copied ‘ii’ to environment
[13:36:56.943] assign_globals() ... done
[13:36:56.943] requestCore(): workers = 2
[13:36:56.945] MulticoreFuture started
[13:36:56.946] - Launch lazy future ... done
[13:36:56.946] run() for ‘MulticoreFuture’ ... done
[13:36:56.946] plan(): Setting new future strategy stack:
[13:36:56.947] List of future strategies:
[13:36:56.947] 1. sequential:
[13:36:56.947]    - args: function (..., envir = parent.frame())
[13:36:56.947]    - tweaked: FALSE
[13:36:56.947]    - call: NULL
[13:36:56.948] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.948] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.949] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.950] plan(): Setting new future strategy stack:
[13:36:56.951] List of future strategies:
[13:36:56.951] 1. multicore:
[13:36:56.951]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.951]    - tweaked: FALSE
[13:36:56.951]    - call: plan(strategy)
[13:36:56.954] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.955] Searching for globals ... DONE
[13:36:56.955] Resolving globals: TRUE
[13:36:56.955] Resolving any globals that are futures ...
[13:36:56.955] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.955] Resolving any globals that are futures ... DONE
[13:36:56.956] plan(): nbrOfWorkers() = 2
[13:36:56.956] Resolving futures part of globals (recursively) ...
[13:36:56.957] resolve() on list ...
[13:36:56.957]  recursive: 99
[13:36:56.957]  length: 2
[13:36:56.957]  elements: ‘a’, ‘ii’
[13:36:56.957]  length: 1 (resolved future 1)
[13:36:56.958]  length: 0 (resolved future 2)
[13:36:56.958] resolve() on list ... DONE
[13:36:56.958] - globals: [2] ‘a’, ‘ii’
[13:36:56.958] Resolving futures part of globals (recursively) ... DONE
[13:36:56.959] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:56.959] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.960] - globals: [2] ‘a’, ‘ii’
[13:36:56.960] 
[13:36:56.960] getGlobalsAndPackages() ... DONE
[13:36:56.960] run() for ‘Future’ ...
[13:36:56.960] - state: ‘created’
[13:36:56.961] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:56.965] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:56.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:56.965]   - Field: ‘label’
[13:36:56.965]   - Field: ‘local’
[13:36:56.966]   - Field: ‘owner’
[13:36:56.966]   - Field: ‘envir’
[13:36:56.966]   - Field: ‘workers’
[13:36:56.966]   - Field: ‘packages’
[13:36:56.966]   - Field: ‘gc’
[13:36:56.966]   - Field: ‘job’
[13:36:56.966]   - Field: ‘conditions’
[13:36:56.967]   - Field: ‘expr’
[13:36:56.967]   - Field: ‘uuid’
[13:36:56.967]   - Field: ‘seed’
[13:36:56.967]   - Field: ‘version’
[13:36:56.967]   - Field: ‘result’
[13:36:56.967]   - Field: ‘asynchronous’
[13:36:56.967]   - Field: ‘calls’
[13:36:56.967]   - Field: ‘globals’
[13:36:56.968]   - Field: ‘stdout’
[13:36:56.968]   - Field: ‘earlySignal’
[13:36:56.968]   - Field: ‘lazy’
[13:36:56.968]   - Field: ‘state’
[13:36:56.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:56.968] - Launch lazy future ...
[13:36:56.969] Packages needed by the future expression (n = 0): <none>
[13:36:56.969] Packages needed by future strategies (n = 0): <none>
[13:36:56.969] {
[13:36:56.969]     {
[13:36:56.969]         {
[13:36:56.969]             ...future.startTime <- base::Sys.time()
[13:36:56.969]             {
[13:36:56.969]                 {
[13:36:56.969]                   {
[13:36:56.969]                     {
[13:36:56.969]                       base::local({
[13:36:56.969]                         has_future <- base::requireNamespace("future", 
[13:36:56.969]                           quietly = TRUE)
[13:36:56.969]                         if (has_future) {
[13:36:56.969]                           ns <- base::getNamespace("future")
[13:36:56.969]                           version <- ns[[".package"]][["version"]]
[13:36:56.969]                           if (is.null(version)) 
[13:36:56.969]                             version <- utils::packageVersion("future")
[13:36:56.969]                         }
[13:36:56.969]                         else {
[13:36:56.969]                           version <- NULL
[13:36:56.969]                         }
[13:36:56.969]                         if (!has_future || version < "1.8.0") {
[13:36:56.969]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:56.969]                             "", base::R.version$version.string), 
[13:36:56.969]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:56.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:56.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:56.969]                               "release", "version")], collapse = " "), 
[13:36:56.969]                             hostname = base::Sys.info()[["nodename"]])
[13:36:56.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:56.969]                             info)
[13:36:56.969]                           info <- base::paste(info, collapse = "; ")
[13:36:56.969]                           if (!has_future) {
[13:36:56.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:56.969]                               info)
[13:36:56.969]                           }
[13:36:56.969]                           else {
[13:36:56.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:56.969]                               info, version)
[13:36:56.969]                           }
[13:36:56.969]                           base::stop(msg)
[13:36:56.969]                         }
[13:36:56.969]                       })
[13:36:56.969]                     }
[13:36:56.969]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:56.969]                     base::options(mc.cores = 1L)
[13:36:56.969]                   }
[13:36:56.969]                   ...future.strategy.old <- future::plan("list")
[13:36:56.969]                   options(future.plan = NULL)
[13:36:56.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:56.969]                 }
[13:36:56.969]                 ...future.workdir <- getwd()
[13:36:56.969]             }
[13:36:56.969]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:56.969]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:56.969]         }
[13:36:56.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:56.969]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:56.969]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:56.969]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:56.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:56.969]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:56.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:56.969]             base::names(...future.oldOptions))
[13:36:56.969]     }
[13:36:56.969]     if (FALSE) {
[13:36:56.969]     }
[13:36:56.969]     else {
[13:36:56.969]         if (TRUE) {
[13:36:56.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:56.969]                 open = "w")
[13:36:56.969]         }
[13:36:56.969]         else {
[13:36:56.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:56.969]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:56.969]         }
[13:36:56.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:56.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:56.969]             base::sink(type = "output", split = FALSE)
[13:36:56.969]             base::close(...future.stdout)
[13:36:56.969]         }, add = TRUE)
[13:36:56.969]     }
[13:36:56.969]     ...future.frame <- base::sys.nframe()
[13:36:56.969]     ...future.conditions <- base::list()
[13:36:56.969]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:56.969]     if (FALSE) {
[13:36:56.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:56.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:56.969]     }
[13:36:56.969]     ...future.result <- base::tryCatch({
[13:36:56.969]         base::withCallingHandlers({
[13:36:56.969]             ...future.value <- base::withVisible(base::local({
[13:36:56.969]                 withCallingHandlers({
[13:36:56.969]                   {
[13:36:56.969]                     b <- a * ii
[13:36:56.969]                     a <- 0
[13:36:56.969]                     b
[13:36:56.969]                   }
[13:36:56.969]                 }, immediateCondition = function(cond) {
[13:36:56.969]                   save_rds <- function (object, pathname, ...) 
[13:36:56.969]                   {
[13:36:56.969]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:56.969]                     if (file_test("-f", pathname_tmp)) {
[13:36:56.969]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.969]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:56.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.969]                         fi_tmp[["mtime"]])
[13:36:56.969]                     }
[13:36:56.969]                     tryCatch({
[13:36:56.969]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:56.969]                     }, error = function(ex) {
[13:36:56.969]                       msg <- conditionMessage(ex)
[13:36:56.969]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.969]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:56.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.969]                         fi_tmp[["mtime"]], msg)
[13:36:56.969]                       ex$message <- msg
[13:36:56.969]                       stop(ex)
[13:36:56.969]                     })
[13:36:56.969]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:56.969]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:56.969]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:56.969]                       fi_tmp <- file.info(pathname_tmp)
[13:36:56.969]                       fi <- file.info(pathname)
[13:36:56.969]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:56.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:56.969]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:56.969]                         fi[["size"]], fi[["mtime"]])
[13:36:56.969]                       stop(msg)
[13:36:56.969]                     }
[13:36:56.969]                     invisible(pathname)
[13:36:56.969]                   }
[13:36:56.969]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:56.969]                     rootPath = tempdir()) 
[13:36:56.969]                   {
[13:36:56.969]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:56.969]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:56.969]                       tmpdir = path, fileext = ".rds")
[13:36:56.969]                     save_rds(obj, file)
[13:36:56.969]                   }
[13:36:56.969]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:56.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.969]                   {
[13:36:56.969]                     inherits <- base::inherits
[13:36:56.969]                     invokeRestart <- base::invokeRestart
[13:36:56.969]                     is.null <- base::is.null
[13:36:56.969]                     muffled <- FALSE
[13:36:56.969]                     if (inherits(cond, "message")) {
[13:36:56.969]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:56.969]                       if (muffled) 
[13:36:56.969]                         invokeRestart("muffleMessage")
[13:36:56.969]                     }
[13:36:56.969]                     else if (inherits(cond, "warning")) {
[13:36:56.969]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:56.969]                       if (muffled) 
[13:36:56.969]                         invokeRestart("muffleWarning")
[13:36:56.969]                     }
[13:36:56.969]                     else if (inherits(cond, "condition")) {
[13:36:56.969]                       if (!is.null(pattern)) {
[13:36:56.969]                         computeRestarts <- base::computeRestarts
[13:36:56.969]                         grepl <- base::grepl
[13:36:56.969]                         restarts <- computeRestarts(cond)
[13:36:56.969]                         for (restart in restarts) {
[13:36:56.969]                           name <- restart$name
[13:36:56.969]                           if (is.null(name)) 
[13:36:56.969]                             next
[13:36:56.969]                           if (!grepl(pattern, name)) 
[13:36:56.969]                             next
[13:36:56.969]                           invokeRestart(restart)
[13:36:56.969]                           muffled <- TRUE
[13:36:56.969]                           break
[13:36:56.969]                         }
[13:36:56.969]                       }
[13:36:56.969]                     }
[13:36:56.969]                     invisible(muffled)
[13:36:56.969]                   }
[13:36:56.969]                   muffleCondition(cond)
[13:36:56.969]                 })
[13:36:56.969]             }))
[13:36:56.969]             future::FutureResult(value = ...future.value$value, 
[13:36:56.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.969]                   ...future.rng), globalenv = if (FALSE) 
[13:36:56.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:56.969]                     ...future.globalenv.names))
[13:36:56.969]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:56.969]         }, condition = base::local({
[13:36:56.969]             c <- base::c
[13:36:56.969]             inherits <- base::inherits
[13:36:56.969]             invokeRestart <- base::invokeRestart
[13:36:56.969]             length <- base::length
[13:36:56.969]             list <- base::list
[13:36:56.969]             seq.int <- base::seq.int
[13:36:56.969]             signalCondition <- base::signalCondition
[13:36:56.969]             sys.calls <- base::sys.calls
[13:36:56.969]             `[[` <- base::`[[`
[13:36:56.969]             `+` <- base::`+`
[13:36:56.969]             `<<-` <- base::`<<-`
[13:36:56.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:56.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:56.969]                   3L)]
[13:36:56.969]             }
[13:36:56.969]             function(cond) {
[13:36:56.969]                 is_error <- inherits(cond, "error")
[13:36:56.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:56.969]                   NULL)
[13:36:56.969]                 if (is_error) {
[13:36:56.969]                   sessionInformation <- function() {
[13:36:56.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:56.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:56.969]                       search = base::search(), system = base::Sys.info())
[13:36:56.969]                   }
[13:36:56.969]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:56.969]                     cond$call), session = sessionInformation(), 
[13:36:56.969]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:56.969]                   signalCondition(cond)
[13:36:56.969]                 }
[13:36:56.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:56.969]                 "immediateCondition"))) {
[13:36:56.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:56.969]                   ...future.conditions[[length(...future.conditions) + 
[13:36:56.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:56.969]                   if (TRUE && !signal) {
[13:36:56.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.969]                     {
[13:36:56.969]                       inherits <- base::inherits
[13:36:56.969]                       invokeRestart <- base::invokeRestart
[13:36:56.969]                       is.null <- base::is.null
[13:36:56.969]                       muffled <- FALSE
[13:36:56.969]                       if (inherits(cond, "message")) {
[13:36:56.969]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.969]                         if (muffled) 
[13:36:56.969]                           invokeRestart("muffleMessage")
[13:36:56.969]                       }
[13:36:56.969]                       else if (inherits(cond, "warning")) {
[13:36:56.969]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.969]                         if (muffled) 
[13:36:56.969]                           invokeRestart("muffleWarning")
[13:36:56.969]                       }
[13:36:56.969]                       else if (inherits(cond, "condition")) {
[13:36:56.969]                         if (!is.null(pattern)) {
[13:36:56.969]                           computeRestarts <- base::computeRestarts
[13:36:56.969]                           grepl <- base::grepl
[13:36:56.969]                           restarts <- computeRestarts(cond)
[13:36:56.969]                           for (restart in restarts) {
[13:36:56.969]                             name <- restart$name
[13:36:56.969]                             if (is.null(name)) 
[13:36:56.969]                               next
[13:36:56.969]                             if (!grepl(pattern, name)) 
[13:36:56.969]                               next
[13:36:56.969]                             invokeRestart(restart)
[13:36:56.969]                             muffled <- TRUE
[13:36:56.969]                             break
[13:36:56.969]                           }
[13:36:56.969]                         }
[13:36:56.969]                       }
[13:36:56.969]                       invisible(muffled)
[13:36:56.969]                     }
[13:36:56.969]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.969]                   }
[13:36:56.969]                 }
[13:36:56.969]                 else {
[13:36:56.969]                   if (TRUE) {
[13:36:56.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:56.969]                     {
[13:36:56.969]                       inherits <- base::inherits
[13:36:56.969]                       invokeRestart <- base::invokeRestart
[13:36:56.969]                       is.null <- base::is.null
[13:36:56.969]                       muffled <- FALSE
[13:36:56.969]                       if (inherits(cond, "message")) {
[13:36:56.969]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:56.969]                         if (muffled) 
[13:36:56.969]                           invokeRestart("muffleMessage")
[13:36:56.969]                       }
[13:36:56.969]                       else if (inherits(cond, "warning")) {
[13:36:56.969]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:56.969]                         if (muffled) 
[13:36:56.969]                           invokeRestart("muffleWarning")
[13:36:56.969]                       }
[13:36:56.969]                       else if (inherits(cond, "condition")) {
[13:36:56.969]                         if (!is.null(pattern)) {
[13:36:56.969]                           computeRestarts <- base::computeRestarts
[13:36:56.969]                           grepl <- base::grepl
[13:36:56.969]                           restarts <- computeRestarts(cond)
[13:36:56.969]                           for (restart in restarts) {
[13:36:56.969]                             name <- restart$name
[13:36:56.969]                             if (is.null(name)) 
[13:36:56.969]                               next
[13:36:56.969]                             if (!grepl(pattern, name)) 
[13:36:56.969]                               next
[13:36:56.969]                             invokeRestart(restart)
[13:36:56.969]                             muffled <- TRUE
[13:36:56.969]                             break
[13:36:56.969]                           }
[13:36:56.969]                         }
[13:36:56.969]                       }
[13:36:56.969]                       invisible(muffled)
[13:36:56.969]                     }
[13:36:56.969]                     muffleCondition(cond, pattern = "^muffle")
[13:36:56.969]                   }
[13:36:56.969]                 }
[13:36:56.969]             }
[13:36:56.969]         }))
[13:36:56.969]     }, error = function(ex) {
[13:36:56.969]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:56.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:56.969]                 ...future.rng), started = ...future.startTime, 
[13:36:56.969]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:56.969]             version = "1.8"), class = "FutureResult")
[13:36:56.969]     }, finally = {
[13:36:56.969]         if (!identical(...future.workdir, getwd())) 
[13:36:56.969]             setwd(...future.workdir)
[13:36:56.969]         {
[13:36:56.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:56.969]                 ...future.oldOptions$nwarnings <- NULL
[13:36:56.969]             }
[13:36:56.969]             base::options(...future.oldOptions)
[13:36:56.969]             if (.Platform$OS.type == "windows") {
[13:36:56.969]                 old_names <- names(...future.oldEnvVars)
[13:36:56.969]                 envs <- base::Sys.getenv()
[13:36:56.969]                 names <- names(envs)
[13:36:56.969]                 common <- intersect(names, old_names)
[13:36:56.969]                 added <- setdiff(names, old_names)
[13:36:56.969]                 removed <- setdiff(old_names, names)
[13:36:56.969]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:56.969]                   envs[common]]
[13:36:56.969]                 NAMES <- toupper(changed)
[13:36:56.969]                 args <- list()
[13:36:56.969]                 for (kk in seq_along(NAMES)) {
[13:36:56.969]                   name <- changed[[kk]]
[13:36:56.969]                   NAME <- NAMES[[kk]]
[13:36:56.969]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.969]                     next
[13:36:56.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.969]                 }
[13:36:56.969]                 NAMES <- toupper(added)
[13:36:56.969]                 for (kk in seq_along(NAMES)) {
[13:36:56.969]                   name <- added[[kk]]
[13:36:56.969]                   NAME <- NAMES[[kk]]
[13:36:56.969]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.969]                     next
[13:36:56.969]                   args[[name]] <- ""
[13:36:56.969]                 }
[13:36:56.969]                 NAMES <- toupper(removed)
[13:36:56.969]                 for (kk in seq_along(NAMES)) {
[13:36:56.969]                   name <- removed[[kk]]
[13:36:56.969]                   NAME <- NAMES[[kk]]
[13:36:56.969]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:56.969]                     next
[13:36:56.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:56.969]                 }
[13:36:56.969]                 if (length(args) > 0) 
[13:36:56.969]                   base::do.call(base::Sys.setenv, args = args)
[13:36:56.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:56.969]             }
[13:36:56.969]             else {
[13:36:56.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:56.969]             }
[13:36:56.969]             {
[13:36:56.969]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:56.969]                   0L) {
[13:36:56.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:56.969]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:56.969]                   base::options(opts)
[13:36:56.969]                 }
[13:36:56.969]                 {
[13:36:56.969]                   {
[13:36:56.969]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:56.969]                     NULL
[13:36:56.969]                   }
[13:36:56.969]                   options(future.plan = NULL)
[13:36:56.969]                   if (is.na(NA_character_)) 
[13:36:56.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:56.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:56.969]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:56.969]                     .init = FALSE)
[13:36:56.969]                 }
[13:36:56.969]             }
[13:36:56.969]         }
[13:36:56.969]     })
[13:36:56.969]     if (TRUE) {
[13:36:56.969]         base::sink(type = "output", split = FALSE)
[13:36:56.969]         if (TRUE) {
[13:36:56.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:56.969]         }
[13:36:56.969]         else {
[13:36:56.969]             ...future.result["stdout"] <- base::list(NULL)
[13:36:56.969]         }
[13:36:56.969]         base::close(...future.stdout)
[13:36:56.969]         ...future.stdout <- NULL
[13:36:56.969]     }
[13:36:56.969]     ...future.result$conditions <- ...future.conditions
[13:36:56.969]     ...future.result$finished <- base::Sys.time()
[13:36:56.969]     ...future.result
[13:36:56.969] }
[13:36:56.973] assign_globals() ...
[13:36:56.973] List of 2
[13:36:56.973]  $ a : num 1
[13:36:56.973]  $ ii: int 2
[13:36:56.973]  - attr(*, "where")=List of 2
[13:36:56.973]   ..$ a :<environment: R_EmptyEnv> 
[13:36:56.973]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:56.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:56.973]  - attr(*, "resolved")= logi TRUE
[13:36:56.973]  - attr(*, "total_size")= num 112
[13:36:56.973]  - attr(*, "already-done")= logi TRUE
[13:36:56.977] - copied ‘a’ to environment
[13:36:56.977] - copied ‘ii’ to environment
[13:36:56.977] assign_globals() ... done
[13:36:56.977] requestCore(): workers = 2
[13:36:56.979] MulticoreFuture started
[13:36:56.980] - Launch lazy future ... done
[13:36:56.980] run() for ‘MulticoreFuture’ ... done
[13:36:56.981] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:56.981] getGlobalsAndPackages() ...
[13:36:56.981] List of future strategies:
[13:36:56.981] 1. sequential:
[13:36:56.981]    - args: function (..., envir = parent.frame())
[13:36:56.981]    - tweaked: FALSE
[13:36:56.981]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:56.982] plan(): nbrOfWorkers() = 1
[13:36:56.982] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:56.984] plan(): Setting new future strategy stack:
[13:36:56.984] List of future strategies:
[13:36:56.984] 1. multicore:
[13:36:56.984]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:56.984]    - tweaked: FALSE
[13:36:56.984]    - call: plan(strategy)
[13:36:56.989] plan(): nbrOfWorkers() = 2
[13:36:56.992] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.992] Searching for globals ... DONE
[13:36:56.993] Resolving globals: TRUE
[13:36:56.993] Resolving any globals that are futures ...
[13:36:56.993] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:56.993] Resolving any globals that are futures ... DONE
[13:36:56.994] Resolving futures part of globals (recursively) ...
[13:36:56.994] resolve() on list ...
[13:36:56.995]  recursive: 99
[13:36:56.995]  length: 2
[13:36:56.995]  elements: ‘a’, ‘ii’
[13:36:56.995]  length: 1 (resolved future 1)
[13:36:56.996]  length: 0 (resolved future 2)
[13:36:56.996] resolve() on list ... DONE
[13:36:56.996] - globals: [2] ‘a’, ‘ii’
[13:36:56.996] Resolving futures part of globals (recursively) ... DONE
[13:36:56.997] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:56.997] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:56.997] - globals: [2] ‘a’, ‘ii’
[13:36:56.998] 
[13:36:56.998] getGlobalsAndPackages() ... DONE
[13:36:56.998] run() for ‘Future’ ...
[13:36:56.998] - state: ‘created’
[13:36:56.999] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.004]   - Field: ‘label’
[13:36:57.004]   - Field: ‘local’
[13:36:57.004]   - Field: ‘owner’
[13:36:57.004]   - Field: ‘envir’
[13:36:57.005]   - Field: ‘workers’
[13:36:57.005]   - Field: ‘packages’
[13:36:57.005]   - Field: ‘gc’
[13:36:57.005]   - Field: ‘job’
[13:36:57.005]   - Field: ‘conditions’
[13:36:57.005]   - Field: ‘expr’
[13:36:57.006]   - Field: ‘uuid’
[13:36:57.006]   - Field: ‘seed’
[13:36:57.006]   - Field: ‘version’
[13:36:57.006]   - Field: ‘result’
[13:36:57.006]   - Field: ‘asynchronous’
[13:36:57.006]   - Field: ‘calls’
[13:36:57.007]   - Field: ‘globals’
[13:36:57.007]   - Field: ‘stdout’
[13:36:57.007]   - Field: ‘earlySignal’
[13:36:57.007]   - Field: ‘lazy’
[13:36:57.007]   - Field: ‘state’
[13:36:57.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.008] - Launch lazy future ...
[13:36:57.008] Packages needed by the future expression (n = 0): <none>
[13:36:57.008] Packages needed by future strategies (n = 0): <none>
[13:36:57.009] {
[13:36:57.009]     {
[13:36:57.009]         {
[13:36:57.009]             ...future.startTime <- base::Sys.time()
[13:36:57.009]             {
[13:36:57.009]                 {
[13:36:57.009]                   {
[13:36:57.009]                     {
[13:36:57.009]                       base::local({
[13:36:57.009]                         has_future <- base::requireNamespace("future", 
[13:36:57.009]                           quietly = TRUE)
[13:36:57.009]                         if (has_future) {
[13:36:57.009]                           ns <- base::getNamespace("future")
[13:36:57.009]                           version <- ns[[".package"]][["version"]]
[13:36:57.009]                           if (is.null(version)) 
[13:36:57.009]                             version <- utils::packageVersion("future")
[13:36:57.009]                         }
[13:36:57.009]                         else {
[13:36:57.009]                           version <- NULL
[13:36:57.009]                         }
[13:36:57.009]                         if (!has_future || version < "1.8.0") {
[13:36:57.009]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.009]                             "", base::R.version$version.string), 
[13:36:57.009]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.009]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.009]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.009]                               "release", "version")], collapse = " "), 
[13:36:57.009]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.009]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.009]                             info)
[13:36:57.009]                           info <- base::paste(info, collapse = "; ")
[13:36:57.009]                           if (!has_future) {
[13:36:57.009]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.009]                               info)
[13:36:57.009]                           }
[13:36:57.009]                           else {
[13:36:57.009]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.009]                               info, version)
[13:36:57.009]                           }
[13:36:57.009]                           base::stop(msg)
[13:36:57.009]                         }
[13:36:57.009]                       })
[13:36:57.009]                     }
[13:36:57.009]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.009]                     base::options(mc.cores = 1L)
[13:36:57.009]                   }
[13:36:57.009]                   ...future.strategy.old <- future::plan("list")
[13:36:57.009]                   options(future.plan = NULL)
[13:36:57.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.009]                 }
[13:36:57.009]                 ...future.workdir <- getwd()
[13:36:57.009]             }
[13:36:57.009]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.009]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.009]         }
[13:36:57.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.009]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.009]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.009]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.009]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.009]             base::names(...future.oldOptions))
[13:36:57.009]     }
[13:36:57.009]     if (FALSE) {
[13:36:57.009]     }
[13:36:57.009]     else {
[13:36:57.009]         if (TRUE) {
[13:36:57.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.009]                 open = "w")
[13:36:57.009]         }
[13:36:57.009]         else {
[13:36:57.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.009]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.009]         }
[13:36:57.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.009]             base::sink(type = "output", split = FALSE)
[13:36:57.009]             base::close(...future.stdout)
[13:36:57.009]         }, add = TRUE)
[13:36:57.009]     }
[13:36:57.009]     ...future.frame <- base::sys.nframe()
[13:36:57.009]     ...future.conditions <- base::list()
[13:36:57.009]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.009]     if (FALSE) {
[13:36:57.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.009]     }
[13:36:57.009]     ...future.result <- base::tryCatch({
[13:36:57.009]         base::withCallingHandlers({
[13:36:57.009]             ...future.value <- base::withVisible(base::local({
[13:36:57.009]                 withCallingHandlers({
[13:36:57.009]                   {
[13:36:57.009]                     b <- a * ii
[13:36:57.009]                     a <- 0
[13:36:57.009]                     b
[13:36:57.009]                   }
[13:36:57.009]                 }, immediateCondition = function(cond) {
[13:36:57.009]                   save_rds <- function (object, pathname, ...) 
[13:36:57.009]                   {
[13:36:57.009]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.009]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.009]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.009]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.009]                         fi_tmp[["mtime"]])
[13:36:57.009]                     }
[13:36:57.009]                     tryCatch({
[13:36:57.009]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.009]                     }, error = function(ex) {
[13:36:57.009]                       msg <- conditionMessage(ex)
[13:36:57.009]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.009]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.009]                         fi_tmp[["mtime"]], msg)
[13:36:57.009]                       ex$message <- msg
[13:36:57.009]                       stop(ex)
[13:36:57.009]                     })
[13:36:57.009]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.009]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.009]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.009]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.009]                       fi <- file.info(pathname)
[13:36:57.009]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.009]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.009]                         fi[["size"]], fi[["mtime"]])
[13:36:57.009]                       stop(msg)
[13:36:57.009]                     }
[13:36:57.009]                     invisible(pathname)
[13:36:57.009]                   }
[13:36:57.009]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.009]                     rootPath = tempdir()) 
[13:36:57.009]                   {
[13:36:57.009]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.009]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.009]                       tmpdir = path, fileext = ".rds")
[13:36:57.009]                     save_rds(obj, file)
[13:36:57.009]                   }
[13:36:57.009]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.009]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.009]                   {
[13:36:57.009]                     inherits <- base::inherits
[13:36:57.009]                     invokeRestart <- base::invokeRestart
[13:36:57.009]                     is.null <- base::is.null
[13:36:57.009]                     muffled <- FALSE
[13:36:57.009]                     if (inherits(cond, "message")) {
[13:36:57.009]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.009]                       if (muffled) 
[13:36:57.009]                         invokeRestart("muffleMessage")
[13:36:57.009]                     }
[13:36:57.009]                     else if (inherits(cond, "warning")) {
[13:36:57.009]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.009]                       if (muffled) 
[13:36:57.009]                         invokeRestart("muffleWarning")
[13:36:57.009]                     }
[13:36:57.009]                     else if (inherits(cond, "condition")) {
[13:36:57.009]                       if (!is.null(pattern)) {
[13:36:57.009]                         computeRestarts <- base::computeRestarts
[13:36:57.009]                         grepl <- base::grepl
[13:36:57.009]                         restarts <- computeRestarts(cond)
[13:36:57.009]                         for (restart in restarts) {
[13:36:57.009]                           name <- restart$name
[13:36:57.009]                           if (is.null(name)) 
[13:36:57.009]                             next
[13:36:57.009]                           if (!grepl(pattern, name)) 
[13:36:57.009]                             next
[13:36:57.009]                           invokeRestart(restart)
[13:36:57.009]                           muffled <- TRUE
[13:36:57.009]                           break
[13:36:57.009]                         }
[13:36:57.009]                       }
[13:36:57.009]                     }
[13:36:57.009]                     invisible(muffled)
[13:36:57.009]                   }
[13:36:57.009]                   muffleCondition(cond)
[13:36:57.009]                 })
[13:36:57.009]             }))
[13:36:57.009]             future::FutureResult(value = ...future.value$value, 
[13:36:57.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.009]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.009]                     ...future.globalenv.names))
[13:36:57.009]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.009]         }, condition = base::local({
[13:36:57.009]             c <- base::c
[13:36:57.009]             inherits <- base::inherits
[13:36:57.009]             invokeRestart <- base::invokeRestart
[13:36:57.009]             length <- base::length
[13:36:57.009]             list <- base::list
[13:36:57.009]             seq.int <- base::seq.int
[13:36:57.009]             signalCondition <- base::signalCondition
[13:36:57.009]             sys.calls <- base::sys.calls
[13:36:57.009]             `[[` <- base::`[[`
[13:36:57.009]             `+` <- base::`+`
[13:36:57.009]             `<<-` <- base::`<<-`
[13:36:57.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.009]                   3L)]
[13:36:57.009]             }
[13:36:57.009]             function(cond) {
[13:36:57.009]                 is_error <- inherits(cond, "error")
[13:36:57.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.009]                   NULL)
[13:36:57.009]                 if (is_error) {
[13:36:57.009]                   sessionInformation <- function() {
[13:36:57.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.009]                       search = base::search(), system = base::Sys.info())
[13:36:57.009]                   }
[13:36:57.009]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.009]                     cond$call), session = sessionInformation(), 
[13:36:57.009]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.009]                   signalCondition(cond)
[13:36:57.009]                 }
[13:36:57.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.009]                 "immediateCondition"))) {
[13:36:57.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.009]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.009]                   if (TRUE && !signal) {
[13:36:57.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.009]                     {
[13:36:57.009]                       inherits <- base::inherits
[13:36:57.009]                       invokeRestart <- base::invokeRestart
[13:36:57.009]                       is.null <- base::is.null
[13:36:57.009]                       muffled <- FALSE
[13:36:57.009]                       if (inherits(cond, "message")) {
[13:36:57.009]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.009]                         if (muffled) 
[13:36:57.009]                           invokeRestart("muffleMessage")
[13:36:57.009]                       }
[13:36:57.009]                       else if (inherits(cond, "warning")) {
[13:36:57.009]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.009]                         if (muffled) 
[13:36:57.009]                           invokeRestart("muffleWarning")
[13:36:57.009]                       }
[13:36:57.009]                       else if (inherits(cond, "condition")) {
[13:36:57.009]                         if (!is.null(pattern)) {
[13:36:57.009]                           computeRestarts <- base::computeRestarts
[13:36:57.009]                           grepl <- base::grepl
[13:36:57.009]                           restarts <- computeRestarts(cond)
[13:36:57.009]                           for (restart in restarts) {
[13:36:57.009]                             name <- restart$name
[13:36:57.009]                             if (is.null(name)) 
[13:36:57.009]                               next
[13:36:57.009]                             if (!grepl(pattern, name)) 
[13:36:57.009]                               next
[13:36:57.009]                             invokeRestart(restart)
[13:36:57.009]                             muffled <- TRUE
[13:36:57.009]                             break
[13:36:57.009]                           }
[13:36:57.009]                         }
[13:36:57.009]                       }
[13:36:57.009]                       invisible(muffled)
[13:36:57.009]                     }
[13:36:57.009]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.009]                   }
[13:36:57.009]                 }
[13:36:57.009]                 else {
[13:36:57.009]                   if (TRUE) {
[13:36:57.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.009]                     {
[13:36:57.009]                       inherits <- base::inherits
[13:36:57.009]                       invokeRestart <- base::invokeRestart
[13:36:57.009]                       is.null <- base::is.null
[13:36:57.009]                       muffled <- FALSE
[13:36:57.009]                       if (inherits(cond, "message")) {
[13:36:57.009]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.009]                         if (muffled) 
[13:36:57.009]                           invokeRestart("muffleMessage")
[13:36:57.009]                       }
[13:36:57.009]                       else if (inherits(cond, "warning")) {
[13:36:57.009]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.009]                         if (muffled) 
[13:36:57.009]                           invokeRestart("muffleWarning")
[13:36:57.009]                       }
[13:36:57.009]                       else if (inherits(cond, "condition")) {
[13:36:57.009]                         if (!is.null(pattern)) {
[13:36:57.009]                           computeRestarts <- base::computeRestarts
[13:36:57.009]                           grepl <- base::grepl
[13:36:57.009]                           restarts <- computeRestarts(cond)
[13:36:57.009]                           for (restart in restarts) {
[13:36:57.009]                             name <- restart$name
[13:36:57.009]                             if (is.null(name)) 
[13:36:57.009]                               next
[13:36:57.009]                             if (!grepl(pattern, name)) 
[13:36:57.009]                               next
[13:36:57.009]                             invokeRestart(restart)
[13:36:57.009]                             muffled <- TRUE
[13:36:57.009]                             break
[13:36:57.009]                           }
[13:36:57.009]                         }
[13:36:57.009]                       }
[13:36:57.009]                       invisible(muffled)
[13:36:57.009]                     }
[13:36:57.009]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.009]                   }
[13:36:57.009]                 }
[13:36:57.009]             }
[13:36:57.009]         }))
[13:36:57.009]     }, error = function(ex) {
[13:36:57.009]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.009]                 ...future.rng), started = ...future.startTime, 
[13:36:57.009]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.009]             version = "1.8"), class = "FutureResult")
[13:36:57.009]     }, finally = {
[13:36:57.009]         if (!identical(...future.workdir, getwd())) 
[13:36:57.009]             setwd(...future.workdir)
[13:36:57.009]         {
[13:36:57.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.009]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.009]             }
[13:36:57.009]             base::options(...future.oldOptions)
[13:36:57.009]             if (.Platform$OS.type == "windows") {
[13:36:57.009]                 old_names <- names(...future.oldEnvVars)
[13:36:57.009]                 envs <- base::Sys.getenv()
[13:36:57.009]                 names <- names(envs)
[13:36:57.009]                 common <- intersect(names, old_names)
[13:36:57.009]                 added <- setdiff(names, old_names)
[13:36:57.009]                 removed <- setdiff(old_names, names)
[13:36:57.009]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.009]                   envs[common]]
[13:36:57.009]                 NAMES <- toupper(changed)
[13:36:57.009]                 args <- list()
[13:36:57.009]                 for (kk in seq_along(NAMES)) {
[13:36:57.009]                   name <- changed[[kk]]
[13:36:57.009]                   NAME <- NAMES[[kk]]
[13:36:57.009]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.009]                     next
[13:36:57.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.009]                 }
[13:36:57.009]                 NAMES <- toupper(added)
[13:36:57.009]                 for (kk in seq_along(NAMES)) {
[13:36:57.009]                   name <- added[[kk]]
[13:36:57.009]                   NAME <- NAMES[[kk]]
[13:36:57.009]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.009]                     next
[13:36:57.009]                   args[[name]] <- ""
[13:36:57.009]                 }
[13:36:57.009]                 NAMES <- toupper(removed)
[13:36:57.009]                 for (kk in seq_along(NAMES)) {
[13:36:57.009]                   name <- removed[[kk]]
[13:36:57.009]                   NAME <- NAMES[[kk]]
[13:36:57.009]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.009]                     next
[13:36:57.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.009]                 }
[13:36:57.009]                 if (length(args) > 0) 
[13:36:57.009]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.009]             }
[13:36:57.009]             else {
[13:36:57.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.009]             }
[13:36:57.009]             {
[13:36:57.009]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.009]                   0L) {
[13:36:57.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.009]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.009]                   base::options(opts)
[13:36:57.009]                 }
[13:36:57.009]                 {
[13:36:57.009]                   {
[13:36:57.009]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.009]                     NULL
[13:36:57.009]                   }
[13:36:57.009]                   options(future.plan = NULL)
[13:36:57.009]                   if (is.na(NA_character_)) 
[13:36:57.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.009]                     .init = FALSE)
[13:36:57.009]                 }
[13:36:57.009]             }
[13:36:57.009]         }
[13:36:57.009]     })
[13:36:57.009]     if (TRUE) {
[13:36:57.009]         base::sink(type = "output", split = FALSE)
[13:36:57.009]         if (TRUE) {
[13:36:57.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.009]         }
[13:36:57.009]         else {
[13:36:57.009]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.009]         }
[13:36:57.009]         base::close(...future.stdout)
[13:36:57.009]         ...future.stdout <- NULL
[13:36:57.009]     }
[13:36:57.009]     ...future.result$conditions <- ...future.conditions
[13:36:57.009]     ...future.result$finished <- base::Sys.time()
[13:36:57.009]     ...future.result
[13:36:57.009] }
[13:36:57.011] assign_globals() ...
[13:36:57.011] List of 2
[13:36:57.011]  $ a : num 1
[13:36:57.011]  $ ii: int 3
[13:36:57.011]  - attr(*, "where")=List of 2
[13:36:57.011]   ..$ a :<environment: R_EmptyEnv> 
[13:36:57.011]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:57.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.011]  - attr(*, "resolved")= logi TRUE
[13:36:57.011]  - attr(*, "total_size")= num 112
[13:36:57.011]  - attr(*, "already-done")= logi TRUE
[13:36:57.016] - copied ‘a’ to environment
[13:36:57.016] - copied ‘ii’ to environment
[13:36:57.016] assign_globals() ... done
[13:36:57.016] requestCore(): workers = 2
[13:36:57.017] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:57.039] result() for MulticoreFuture ...
[13:36:57.040] result() for MulticoreFuture ...
[13:36:57.040] result() for MulticoreFuture ... done
[13:36:57.040] result() for MulticoreFuture ... done
[13:36:57.040] result() for MulticoreFuture ...
[13:36:57.040] result() for MulticoreFuture ... done
[13:36:57.043] MulticoreFuture started
[13:36:57.043] - Launch lazy future ... done
[13:36:57.043] run() for ‘MulticoreFuture’ ... done
[13:36:57.044] plan(): Setting new future strategy stack:
[13:36:57.045] result() for MulticoreFuture ...
[13:36:57.044] List of future strategies:
[13:36:57.044] 1. sequential:
[13:36:57.044]    - args: function (..., envir = parent.frame())
[13:36:57.044]    - tweaked: FALSE
[13:36:57.044]    - call: NULL
[13:36:57.045] result() for MulticoreFuture ... done
[13:36:57.046] plan(): nbrOfWorkers() = 1
[13:36:57.046] result() for MulticoreFuture ...
[13:36:57.046] result() for MulticoreFuture ... done
[13:36:57.047] result() for MulticoreFuture ...
[13:36:57.049] plan(): Setting new future strategy stack:
[13:36:57.049] result() for MulticoreFuture ...
[13:36:57.050] result() for MulticoreFuture ... done
[13:36:57.050] result() for MulticoreFuture ... done
[13:36:57.050] List of future strategies:
[13:36:57.050] 1. multicore:
[13:36:57.050]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.050]    - tweaked: FALSE
[13:36:57.050]    - call: plan(strategy)
[13:36:57.050] result() for MulticoreFuture ...
[13:36:57.051] result() for MulticoreFuture ... done
[13:36:57.051] result() for MulticoreFuture ...
[13:36:57.056] plan(): nbrOfWorkers() = 2
[13:36:57.057] result() for MulticoreFuture ...
[13:36:57.057] result() for MulticoreFuture ... done
[13:36:57.057] result() for MulticoreFuture ... done
[13:36:57.058] result() for MulticoreFuture ...
[13:36:57.058] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.059] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.059] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.063] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:57.063] Searching for globals ... DONE
[13:36:57.063] Resolving globals: TRUE
[13:36:57.063] Resolving any globals that are futures ...
[13:36:57.064] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:57.064] Resolving any globals that are futures ... DONE
[13:36:57.064] Resolving futures part of globals (recursively) ...
[13:36:57.065] resolve() on list ...
[13:36:57.065]  recursive: 99
[13:36:57.065]  length: 2
[13:36:57.065]  elements: ‘a’, ‘ii’
[13:36:57.065]  length: 1 (resolved future 1)
[13:36:57.065]  length: 0 (resolved future 2)
[13:36:57.065] resolve() on list ... DONE
[13:36:57.066] - globals: [2] ‘a’, ‘ii’
[13:36:57.066] Resolving futures part of globals (recursively) ... DONE
[13:36:57.066] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:57.066] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:57.067] - globals: [2] ‘a’, ‘ii’
[13:36:57.067] 
[13:36:57.067] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.068] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.068] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.070] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:57.070] Searching for globals ... DONE
[13:36:57.070] Resolving globals: TRUE
[13:36:57.070] Resolving any globals that are futures ...
[13:36:57.071] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:57.071] Resolving any globals that are futures ... DONE
[13:36:57.071] Resolving futures part of globals (recursively) ...
[13:36:57.071] resolve() on list ...
[13:36:57.071]  recursive: 99
[13:36:57.072]  length: 2
[13:36:57.072]  elements: ‘a’, ‘ii’
[13:36:57.072]  length: 1 (resolved future 1)
[13:36:57.072]  length: 0 (resolved future 2)
[13:36:57.072] resolve() on list ... DONE
[13:36:57.072] - globals: [2] ‘a’, ‘ii’
[13:36:57.072] Resolving futures part of globals (recursively) ... DONE
[13:36:57.072] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:57.073] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:57.073] - globals: [2] ‘a’, ‘ii’
[13:36:57.073] 
[13:36:57.073] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.074] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.074] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.076] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:57.076] Searching for globals ... DONE
[13:36:57.076] Resolving globals: TRUE
[13:36:57.076] Resolving any globals that are futures ...
[13:36:57.076] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:57.076] Resolving any globals that are futures ... DONE
[13:36:57.077] Resolving futures part of globals (recursively) ...
[13:36:57.077] resolve() on list ...
[13:36:57.077]  recursive: 99
[13:36:57.077]  length: 2
[13:36:57.077]  elements: ‘a’, ‘ii’
[13:36:57.077]  length: 1 (resolved future 1)
[13:36:57.078]  length: 0 (resolved future 2)
[13:36:57.078] resolve() on list ... DONE
[13:36:57.078] - globals: [2] ‘a’, ‘ii’
[13:36:57.078] Resolving futures part of globals (recursively) ... DONE
[13:36:57.078] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:57.078] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:57.079] - globals: [2] ‘a’, ‘ii’
[13:36:57.079] 
[13:36:57.079] getGlobalsAndPackages() ... DONE
[13:36:57.079] run() for ‘Future’ ...
[13:36:57.079] - state: ‘created’
[13:36:57.079] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.085] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.086] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.086]   - Field: ‘label’
[13:36:57.086]   - Field: ‘local’
[13:36:57.086]   - Field: ‘owner’
[13:36:57.086]   - Field: ‘envir’
[13:36:57.086]   - Field: ‘workers’
[13:36:57.086]   - Field: ‘packages’
[13:36:57.086]   - Field: ‘gc’
[13:36:57.087]   - Field: ‘job’
[13:36:57.087]   - Field: ‘conditions’
[13:36:57.087]   - Field: ‘expr’
[13:36:57.087]   - Field: ‘uuid’
[13:36:57.087]   - Field: ‘seed’
[13:36:57.087]   - Field: ‘version’
[13:36:57.087]   - Field: ‘result’
[13:36:57.087]   - Field: ‘asynchronous’
[13:36:57.087]   - Field: ‘calls’
[13:36:57.087]   - Field: ‘globals’
[13:36:57.088]   - Field: ‘stdout’
[13:36:57.088]   - Field: ‘earlySignal’
[13:36:57.088]   - Field: ‘lazy’
[13:36:57.088]   - Field: ‘state’
[13:36:57.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.088] - Launch lazy future ...
[13:36:57.088] Packages needed by the future expression (n = 0): <none>
[13:36:57.088] Packages needed by future strategies (n = 0): <none>
[13:36:57.089] {
[13:36:57.089]     {
[13:36:57.089]         {
[13:36:57.089]             ...future.startTime <- base::Sys.time()
[13:36:57.089]             {
[13:36:57.089]                 {
[13:36:57.089]                   {
[13:36:57.089]                     {
[13:36:57.089]                       base::local({
[13:36:57.089]                         has_future <- base::requireNamespace("future", 
[13:36:57.089]                           quietly = TRUE)
[13:36:57.089]                         if (has_future) {
[13:36:57.089]                           ns <- base::getNamespace("future")
[13:36:57.089]                           version <- ns[[".package"]][["version"]]
[13:36:57.089]                           if (is.null(version)) 
[13:36:57.089]                             version <- utils::packageVersion("future")
[13:36:57.089]                         }
[13:36:57.089]                         else {
[13:36:57.089]                           version <- NULL
[13:36:57.089]                         }
[13:36:57.089]                         if (!has_future || version < "1.8.0") {
[13:36:57.089]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.089]                             "", base::R.version$version.string), 
[13:36:57.089]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.089]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.089]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.089]                               "release", "version")], collapse = " "), 
[13:36:57.089]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.089]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.089]                             info)
[13:36:57.089]                           info <- base::paste(info, collapse = "; ")
[13:36:57.089]                           if (!has_future) {
[13:36:57.089]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.089]                               info)
[13:36:57.089]                           }
[13:36:57.089]                           else {
[13:36:57.089]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.089]                               info, version)
[13:36:57.089]                           }
[13:36:57.089]                           base::stop(msg)
[13:36:57.089]                         }
[13:36:57.089]                       })
[13:36:57.089]                     }
[13:36:57.089]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.089]                     base::options(mc.cores = 1L)
[13:36:57.089]                   }
[13:36:57.089]                   ...future.strategy.old <- future::plan("list")
[13:36:57.089]                   options(future.plan = NULL)
[13:36:57.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.089]                 }
[13:36:57.089]                 ...future.workdir <- getwd()
[13:36:57.089]             }
[13:36:57.089]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.089]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.089]         }
[13:36:57.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.089]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.089]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.089]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.089]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.089]             base::names(...future.oldOptions))
[13:36:57.089]     }
[13:36:57.089]     if (FALSE) {
[13:36:57.089]     }
[13:36:57.089]     else {
[13:36:57.089]         if (TRUE) {
[13:36:57.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.089]                 open = "w")
[13:36:57.089]         }
[13:36:57.089]         else {
[13:36:57.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.089]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.089]         }
[13:36:57.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.089]             base::sink(type = "output", split = FALSE)
[13:36:57.089]             base::close(...future.stdout)
[13:36:57.089]         }, add = TRUE)
[13:36:57.089]     }
[13:36:57.089]     ...future.frame <- base::sys.nframe()
[13:36:57.089]     ...future.conditions <- base::list()
[13:36:57.089]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.089]     if (FALSE) {
[13:36:57.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.089]     }
[13:36:57.089]     ...future.result <- base::tryCatch({
[13:36:57.089]         base::withCallingHandlers({
[13:36:57.089]             ...future.value <- base::withVisible(base::local({
[13:36:57.089]                 withCallingHandlers({
[13:36:57.089]                   {
[13:36:57.089]                     b <- a * ii
[13:36:57.089]                     a <- 0
[13:36:57.089]                     b
[13:36:57.089]                   }
[13:36:57.089]                 }, immediateCondition = function(cond) {
[13:36:57.089]                   save_rds <- function (object, pathname, ...) 
[13:36:57.089]                   {
[13:36:57.089]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.089]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.089]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.089]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.089]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.089]                         fi_tmp[["mtime"]])
[13:36:57.089]                     }
[13:36:57.089]                     tryCatch({
[13:36:57.089]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.089]                     }, error = function(ex) {
[13:36:57.089]                       msg <- conditionMessage(ex)
[13:36:57.089]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.089]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.089]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.089]                         fi_tmp[["mtime"]], msg)
[13:36:57.089]                       ex$message <- msg
[13:36:57.089]                       stop(ex)
[13:36:57.089]                     })
[13:36:57.089]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.089]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.089]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.089]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.089]                       fi <- file.info(pathname)
[13:36:57.089]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.089]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.089]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.089]                         fi[["size"]], fi[["mtime"]])
[13:36:57.089]                       stop(msg)
[13:36:57.089]                     }
[13:36:57.089]                     invisible(pathname)
[13:36:57.089]                   }
[13:36:57.089]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.089]                     rootPath = tempdir()) 
[13:36:57.089]                   {
[13:36:57.089]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.089]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.089]                       tmpdir = path, fileext = ".rds")
[13:36:57.089]                     save_rds(obj, file)
[13:36:57.089]                   }
[13:36:57.089]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.089]                   {
[13:36:57.089]                     inherits <- base::inherits
[13:36:57.089]                     invokeRestart <- base::invokeRestart
[13:36:57.089]                     is.null <- base::is.null
[13:36:57.089]                     muffled <- FALSE
[13:36:57.089]                     if (inherits(cond, "message")) {
[13:36:57.089]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.089]                       if (muffled) 
[13:36:57.089]                         invokeRestart("muffleMessage")
[13:36:57.089]                     }
[13:36:57.089]                     else if (inherits(cond, "warning")) {
[13:36:57.089]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.089]                       if (muffled) 
[13:36:57.089]                         invokeRestart("muffleWarning")
[13:36:57.089]                     }
[13:36:57.089]                     else if (inherits(cond, "condition")) {
[13:36:57.089]                       if (!is.null(pattern)) {
[13:36:57.089]                         computeRestarts <- base::computeRestarts
[13:36:57.089]                         grepl <- base::grepl
[13:36:57.089]                         restarts <- computeRestarts(cond)
[13:36:57.089]                         for (restart in restarts) {
[13:36:57.089]                           name <- restart$name
[13:36:57.089]                           if (is.null(name)) 
[13:36:57.089]                             next
[13:36:57.089]                           if (!grepl(pattern, name)) 
[13:36:57.089]                             next
[13:36:57.089]                           invokeRestart(restart)
[13:36:57.089]                           muffled <- TRUE
[13:36:57.089]                           break
[13:36:57.089]                         }
[13:36:57.089]                       }
[13:36:57.089]                     }
[13:36:57.089]                     invisible(muffled)
[13:36:57.089]                   }
[13:36:57.089]                   muffleCondition(cond)
[13:36:57.089]                 })
[13:36:57.089]             }))
[13:36:57.089]             future::FutureResult(value = ...future.value$value, 
[13:36:57.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.089]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.089]                     ...future.globalenv.names))
[13:36:57.089]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.089]         }, condition = base::local({
[13:36:57.089]             c <- base::c
[13:36:57.089]             inherits <- base::inherits
[13:36:57.089]             invokeRestart <- base::invokeRestart
[13:36:57.089]             length <- base::length
[13:36:57.089]             list <- base::list
[13:36:57.089]             seq.int <- base::seq.int
[13:36:57.089]             signalCondition <- base::signalCondition
[13:36:57.089]             sys.calls <- base::sys.calls
[13:36:57.089]             `[[` <- base::`[[`
[13:36:57.089]             `+` <- base::`+`
[13:36:57.089]             `<<-` <- base::`<<-`
[13:36:57.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.089]                   3L)]
[13:36:57.089]             }
[13:36:57.089]             function(cond) {
[13:36:57.089]                 is_error <- inherits(cond, "error")
[13:36:57.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.089]                   NULL)
[13:36:57.089]                 if (is_error) {
[13:36:57.089]                   sessionInformation <- function() {
[13:36:57.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.089]                       search = base::search(), system = base::Sys.info())
[13:36:57.089]                   }
[13:36:57.089]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.089]                     cond$call), session = sessionInformation(), 
[13:36:57.089]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.089]                   signalCondition(cond)
[13:36:57.089]                 }
[13:36:57.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.089]                 "immediateCondition"))) {
[13:36:57.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.089]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.089]                   if (TRUE && !signal) {
[13:36:57.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.089]                     {
[13:36:57.089]                       inherits <- base::inherits
[13:36:57.089]                       invokeRestart <- base::invokeRestart
[13:36:57.089]                       is.null <- base::is.null
[13:36:57.089]                       muffled <- FALSE
[13:36:57.089]                       if (inherits(cond, "message")) {
[13:36:57.089]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.089]                         if (muffled) 
[13:36:57.089]                           invokeRestart("muffleMessage")
[13:36:57.089]                       }
[13:36:57.089]                       else if (inherits(cond, "warning")) {
[13:36:57.089]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.089]                         if (muffled) 
[13:36:57.089]                           invokeRestart("muffleWarning")
[13:36:57.089]                       }
[13:36:57.089]                       else if (inherits(cond, "condition")) {
[13:36:57.089]                         if (!is.null(pattern)) {
[13:36:57.089]                           computeRestarts <- base::computeRestarts
[13:36:57.089]                           grepl <- base::grepl
[13:36:57.089]                           restarts <- computeRestarts(cond)
[13:36:57.089]                           for (restart in restarts) {
[13:36:57.089]                             name <- restart$name
[13:36:57.089]                             if (is.null(name)) 
[13:36:57.089]                               next
[13:36:57.089]                             if (!grepl(pattern, name)) 
[13:36:57.089]                               next
[13:36:57.089]                             invokeRestart(restart)
[13:36:57.089]                             muffled <- TRUE
[13:36:57.089]                             break
[13:36:57.089]                           }
[13:36:57.089]                         }
[13:36:57.089]                       }
[13:36:57.089]                       invisible(muffled)
[13:36:57.089]                     }
[13:36:57.089]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.089]                   }
[13:36:57.089]                 }
[13:36:57.089]                 else {
[13:36:57.089]                   if (TRUE) {
[13:36:57.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.089]                     {
[13:36:57.089]                       inherits <- base::inherits
[13:36:57.089]                       invokeRestart <- base::invokeRestart
[13:36:57.089]                       is.null <- base::is.null
[13:36:57.089]                       muffled <- FALSE
[13:36:57.089]                       if (inherits(cond, "message")) {
[13:36:57.089]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.089]                         if (muffled) 
[13:36:57.089]                           invokeRestart("muffleMessage")
[13:36:57.089]                       }
[13:36:57.089]                       else if (inherits(cond, "warning")) {
[13:36:57.089]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.089]                         if (muffled) 
[13:36:57.089]                           invokeRestart("muffleWarning")
[13:36:57.089]                       }
[13:36:57.089]                       else if (inherits(cond, "condition")) {
[13:36:57.089]                         if (!is.null(pattern)) {
[13:36:57.089]                           computeRestarts <- base::computeRestarts
[13:36:57.089]                           grepl <- base::grepl
[13:36:57.089]                           restarts <- computeRestarts(cond)
[13:36:57.089]                           for (restart in restarts) {
[13:36:57.089]                             name <- restart$name
[13:36:57.089]                             if (is.null(name)) 
[13:36:57.089]                               next
[13:36:57.089]                             if (!grepl(pattern, name)) 
[13:36:57.089]                               next
[13:36:57.089]                             invokeRestart(restart)
[13:36:57.089]                             muffled <- TRUE
[13:36:57.089]                             break
[13:36:57.089]                           }
[13:36:57.089]                         }
[13:36:57.089]                       }
[13:36:57.089]                       invisible(muffled)
[13:36:57.089]                     }
[13:36:57.089]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.089]                   }
[13:36:57.089]                 }
[13:36:57.089]             }
[13:36:57.089]         }))
[13:36:57.089]     }, error = function(ex) {
[13:36:57.089]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.089]                 ...future.rng), started = ...future.startTime, 
[13:36:57.089]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.089]             version = "1.8"), class = "FutureResult")
[13:36:57.089]     }, finally = {
[13:36:57.089]         if (!identical(...future.workdir, getwd())) 
[13:36:57.089]             setwd(...future.workdir)
[13:36:57.089]         {
[13:36:57.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.089]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.089]             }
[13:36:57.089]             base::options(...future.oldOptions)
[13:36:57.089]             if (.Platform$OS.type == "windows") {
[13:36:57.089]                 old_names <- names(...future.oldEnvVars)
[13:36:57.089]                 envs <- base::Sys.getenv()
[13:36:57.089]                 names <- names(envs)
[13:36:57.089]                 common <- intersect(names, old_names)
[13:36:57.089]                 added <- setdiff(names, old_names)
[13:36:57.089]                 removed <- setdiff(old_names, names)
[13:36:57.089]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.089]                   envs[common]]
[13:36:57.089]                 NAMES <- toupper(changed)
[13:36:57.089]                 args <- list()
[13:36:57.089]                 for (kk in seq_along(NAMES)) {
[13:36:57.089]                   name <- changed[[kk]]
[13:36:57.089]                   NAME <- NAMES[[kk]]
[13:36:57.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.089]                     next
[13:36:57.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.089]                 }
[13:36:57.089]                 NAMES <- toupper(added)
[13:36:57.089]                 for (kk in seq_along(NAMES)) {
[13:36:57.089]                   name <- added[[kk]]
[13:36:57.089]                   NAME <- NAMES[[kk]]
[13:36:57.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.089]                     next
[13:36:57.089]                   args[[name]] <- ""
[13:36:57.089]                 }
[13:36:57.089]                 NAMES <- toupper(removed)
[13:36:57.089]                 for (kk in seq_along(NAMES)) {
[13:36:57.089]                   name <- removed[[kk]]
[13:36:57.089]                   NAME <- NAMES[[kk]]
[13:36:57.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.089]                     next
[13:36:57.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.089]                 }
[13:36:57.089]                 if (length(args) > 0) 
[13:36:57.089]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.089]             }
[13:36:57.089]             else {
[13:36:57.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.089]             }
[13:36:57.089]             {
[13:36:57.089]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.089]                   0L) {
[13:36:57.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.089]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.089]                   base::options(opts)
[13:36:57.089]                 }
[13:36:57.089]                 {
[13:36:57.089]                   {
[13:36:57.089]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.089]                     NULL
[13:36:57.089]                   }
[13:36:57.089]                   options(future.plan = NULL)
[13:36:57.089]                   if (is.na(NA_character_)) 
[13:36:57.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.089]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.089]                     .init = FALSE)
[13:36:57.089]                 }
[13:36:57.089]             }
[13:36:57.089]         }
[13:36:57.089]     })
[13:36:57.089]     if (TRUE) {
[13:36:57.089]         base::sink(type = "output", split = FALSE)
[13:36:57.089]         if (TRUE) {
[13:36:57.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.089]         }
[13:36:57.089]         else {
[13:36:57.089]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.089]         }
[13:36:57.089]         base::close(...future.stdout)
[13:36:57.089]         ...future.stdout <- NULL
[13:36:57.089]     }
[13:36:57.089]     ...future.result$conditions <- ...future.conditions
[13:36:57.089]     ...future.result$finished <- base::Sys.time()
[13:36:57.089]     ...future.result
[13:36:57.089] }
[13:36:57.091] assign_globals() ...
[13:36:57.091] List of 2
[13:36:57.091]  $ a : num 1
[13:36:57.091]  $ ii: int 1
[13:36:57.091]  - attr(*, "where")=List of 2
[13:36:57.091]   ..$ a :<environment: R_EmptyEnv> 
[13:36:57.091]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:57.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.091]  - attr(*, "resolved")= logi TRUE
[13:36:57.091]  - attr(*, "total_size")= num 112
[13:36:57.091]  - attr(*, "already-done")= logi TRUE
[13:36:57.095] - copied ‘a’ to environment
[13:36:57.095] - copied ‘ii’ to environment
[13:36:57.095] assign_globals() ... done
[13:36:57.095] requestCore(): workers = 2
[13:36:57.097] MulticoreFuture started
[13:36:57.098] - Launch lazy future ... done
[13:36:57.098] run() for ‘MulticoreFuture’ ... done
[13:36:57.098] result() for MulticoreFuture ...
[13:36:57.098] plan(): Setting new future strategy stack:
[13:36:57.099] List of future strategies:
[13:36:57.099] 1. sequential:
[13:36:57.099]    - args: function (..., envir = parent.frame())
[13:36:57.099]    - tweaked: FALSE
[13:36:57.099]    - call: NULL
[13:36:57.100] plan(): nbrOfWorkers() = 1
[13:36:57.102] plan(): Setting new future strategy stack:
[13:36:57.102] List of future strategies:
[13:36:57.102] 1. multicore:
[13:36:57.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.102]    - tweaked: FALSE
[13:36:57.102]    - call: plan(strategy)
[13:36:57.108] plan(): nbrOfWorkers() = 2
[13:36:57.109] result() for MulticoreFuture ...
[13:36:57.109] result() for MulticoreFuture ... done
[13:36:57.109] result() for MulticoreFuture ... done
[13:36:57.110] result() for MulticoreFuture ...
[13:36:57.110] result() for MulticoreFuture ... done
[13:36:57.110] run() for ‘Future’ ...
[13:36:57.110] - state: ‘created’
[13:36:57.111] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.115] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.115] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.116]   - Field: ‘label’
[13:36:57.116]   - Field: ‘local’
[13:36:57.116]   - Field: ‘owner’
[13:36:57.116]   - Field: ‘envir’
[13:36:57.116]   - Field: ‘workers’
[13:36:57.116]   - Field: ‘packages’
[13:36:57.116]   - Field: ‘gc’
[13:36:57.116]   - Field: ‘job’
[13:36:57.117]   - Field: ‘conditions’
[13:36:57.117]   - Field: ‘expr’
[13:36:57.117]   - Field: ‘uuid’
[13:36:57.117]   - Field: ‘seed’
[13:36:57.117]   - Field: ‘version’
[13:36:57.117]   - Field: ‘result’
[13:36:57.117]   - Field: ‘asynchronous’
[13:36:57.117]   - Field: ‘calls’
[13:36:57.117]   - Field: ‘globals’
[13:36:57.118]   - Field: ‘stdout’
[13:36:57.118]   - Field: ‘earlySignal’
[13:36:57.118]   - Field: ‘lazy’
[13:36:57.118]   - Field: ‘state’
[13:36:57.118] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.118] - Launch lazy future ...
[13:36:57.118] Packages needed by the future expression (n = 0): <none>
[13:36:57.119] Packages needed by future strategies (n = 0): <none>
[13:36:57.119] {
[13:36:57.119]     {
[13:36:57.119]         {
[13:36:57.119]             ...future.startTime <- base::Sys.time()
[13:36:57.119]             {
[13:36:57.119]                 {
[13:36:57.119]                   {
[13:36:57.119]                     {
[13:36:57.119]                       base::local({
[13:36:57.119]                         has_future <- base::requireNamespace("future", 
[13:36:57.119]                           quietly = TRUE)
[13:36:57.119]                         if (has_future) {
[13:36:57.119]                           ns <- base::getNamespace("future")
[13:36:57.119]                           version <- ns[[".package"]][["version"]]
[13:36:57.119]                           if (is.null(version)) 
[13:36:57.119]                             version <- utils::packageVersion("future")
[13:36:57.119]                         }
[13:36:57.119]                         else {
[13:36:57.119]                           version <- NULL
[13:36:57.119]                         }
[13:36:57.119]                         if (!has_future || version < "1.8.0") {
[13:36:57.119]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.119]                             "", base::R.version$version.string), 
[13:36:57.119]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.119]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.119]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.119]                               "release", "version")], collapse = " "), 
[13:36:57.119]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.119]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.119]                             info)
[13:36:57.119]                           info <- base::paste(info, collapse = "; ")
[13:36:57.119]                           if (!has_future) {
[13:36:57.119]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.119]                               info)
[13:36:57.119]                           }
[13:36:57.119]                           else {
[13:36:57.119]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.119]                               info, version)
[13:36:57.119]                           }
[13:36:57.119]                           base::stop(msg)
[13:36:57.119]                         }
[13:36:57.119]                       })
[13:36:57.119]                     }
[13:36:57.119]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.119]                     base::options(mc.cores = 1L)
[13:36:57.119]                   }
[13:36:57.119]                   ...future.strategy.old <- future::plan("list")
[13:36:57.119]                   options(future.plan = NULL)
[13:36:57.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.119]                 }
[13:36:57.119]                 ...future.workdir <- getwd()
[13:36:57.119]             }
[13:36:57.119]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.119]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.119]         }
[13:36:57.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.119]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.119]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.119]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.119]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.119]             base::names(...future.oldOptions))
[13:36:57.119]     }
[13:36:57.119]     if (FALSE) {
[13:36:57.119]     }
[13:36:57.119]     else {
[13:36:57.119]         if (TRUE) {
[13:36:57.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.119]                 open = "w")
[13:36:57.119]         }
[13:36:57.119]         else {
[13:36:57.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.119]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.119]         }
[13:36:57.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.119]             base::sink(type = "output", split = FALSE)
[13:36:57.119]             base::close(...future.stdout)
[13:36:57.119]         }, add = TRUE)
[13:36:57.119]     }
[13:36:57.119]     ...future.frame <- base::sys.nframe()
[13:36:57.119]     ...future.conditions <- base::list()
[13:36:57.119]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.119]     if (FALSE) {
[13:36:57.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.119]     }
[13:36:57.119]     ...future.result <- base::tryCatch({
[13:36:57.119]         base::withCallingHandlers({
[13:36:57.119]             ...future.value <- base::withVisible(base::local({
[13:36:57.119]                 withCallingHandlers({
[13:36:57.119]                   {
[13:36:57.119]                     b <- a * ii
[13:36:57.119]                     a <- 0
[13:36:57.119]                     b
[13:36:57.119]                   }
[13:36:57.119]                 }, immediateCondition = function(cond) {
[13:36:57.119]                   save_rds <- function (object, pathname, ...) 
[13:36:57.119]                   {
[13:36:57.119]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.119]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.119]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.119]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.119]                         fi_tmp[["mtime"]])
[13:36:57.119]                     }
[13:36:57.119]                     tryCatch({
[13:36:57.119]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.119]                     }, error = function(ex) {
[13:36:57.119]                       msg <- conditionMessage(ex)
[13:36:57.119]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.119]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.119]                         fi_tmp[["mtime"]], msg)
[13:36:57.119]                       ex$message <- msg
[13:36:57.119]                       stop(ex)
[13:36:57.119]                     })
[13:36:57.119]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.119]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.119]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.119]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.119]                       fi <- file.info(pathname)
[13:36:57.119]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.119]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.119]                         fi[["size"]], fi[["mtime"]])
[13:36:57.119]                       stop(msg)
[13:36:57.119]                     }
[13:36:57.119]                     invisible(pathname)
[13:36:57.119]                   }
[13:36:57.119]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.119]                     rootPath = tempdir()) 
[13:36:57.119]                   {
[13:36:57.119]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.119]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.119]                       tmpdir = path, fileext = ".rds")
[13:36:57.119]                     save_rds(obj, file)
[13:36:57.119]                   }
[13:36:57.119]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.119]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.119]                   {
[13:36:57.119]                     inherits <- base::inherits
[13:36:57.119]                     invokeRestart <- base::invokeRestart
[13:36:57.119]                     is.null <- base::is.null
[13:36:57.119]                     muffled <- FALSE
[13:36:57.119]                     if (inherits(cond, "message")) {
[13:36:57.119]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.119]                       if (muffled) 
[13:36:57.119]                         invokeRestart("muffleMessage")
[13:36:57.119]                     }
[13:36:57.119]                     else if (inherits(cond, "warning")) {
[13:36:57.119]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.119]                       if (muffled) 
[13:36:57.119]                         invokeRestart("muffleWarning")
[13:36:57.119]                     }
[13:36:57.119]                     else if (inherits(cond, "condition")) {
[13:36:57.119]                       if (!is.null(pattern)) {
[13:36:57.119]                         computeRestarts <- base::computeRestarts
[13:36:57.119]                         grepl <- base::grepl
[13:36:57.119]                         restarts <- computeRestarts(cond)
[13:36:57.119]                         for (restart in restarts) {
[13:36:57.119]                           name <- restart$name
[13:36:57.119]                           if (is.null(name)) 
[13:36:57.119]                             next
[13:36:57.119]                           if (!grepl(pattern, name)) 
[13:36:57.119]                             next
[13:36:57.119]                           invokeRestart(restart)
[13:36:57.119]                           muffled <- TRUE
[13:36:57.119]                           break
[13:36:57.119]                         }
[13:36:57.119]                       }
[13:36:57.119]                     }
[13:36:57.119]                     invisible(muffled)
[13:36:57.119]                   }
[13:36:57.119]                   muffleCondition(cond)
[13:36:57.119]                 })
[13:36:57.119]             }))
[13:36:57.119]             future::FutureResult(value = ...future.value$value, 
[13:36:57.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.119]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.119]                     ...future.globalenv.names))
[13:36:57.119]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.119]         }, condition = base::local({
[13:36:57.119]             c <- base::c
[13:36:57.119]             inherits <- base::inherits
[13:36:57.119]             invokeRestart <- base::invokeRestart
[13:36:57.119]             length <- base::length
[13:36:57.119]             list <- base::list
[13:36:57.119]             seq.int <- base::seq.int
[13:36:57.119]             signalCondition <- base::signalCondition
[13:36:57.119]             sys.calls <- base::sys.calls
[13:36:57.119]             `[[` <- base::`[[`
[13:36:57.119]             `+` <- base::`+`
[13:36:57.119]             `<<-` <- base::`<<-`
[13:36:57.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.119]                   3L)]
[13:36:57.119]             }
[13:36:57.119]             function(cond) {
[13:36:57.119]                 is_error <- inherits(cond, "error")
[13:36:57.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.119]                   NULL)
[13:36:57.119]                 if (is_error) {
[13:36:57.119]                   sessionInformation <- function() {
[13:36:57.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.119]                       search = base::search(), system = base::Sys.info())
[13:36:57.119]                   }
[13:36:57.119]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.119]                     cond$call), session = sessionInformation(), 
[13:36:57.119]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.119]                   signalCondition(cond)
[13:36:57.119]                 }
[13:36:57.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.119]                 "immediateCondition"))) {
[13:36:57.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.119]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.119]                   if (TRUE && !signal) {
[13:36:57.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.119]                     {
[13:36:57.119]                       inherits <- base::inherits
[13:36:57.119]                       invokeRestart <- base::invokeRestart
[13:36:57.119]                       is.null <- base::is.null
[13:36:57.119]                       muffled <- FALSE
[13:36:57.119]                       if (inherits(cond, "message")) {
[13:36:57.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.119]                         if (muffled) 
[13:36:57.119]                           invokeRestart("muffleMessage")
[13:36:57.119]                       }
[13:36:57.119]                       else if (inherits(cond, "warning")) {
[13:36:57.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.119]                         if (muffled) 
[13:36:57.119]                           invokeRestart("muffleWarning")
[13:36:57.119]                       }
[13:36:57.119]                       else if (inherits(cond, "condition")) {
[13:36:57.119]                         if (!is.null(pattern)) {
[13:36:57.119]                           computeRestarts <- base::computeRestarts
[13:36:57.119]                           grepl <- base::grepl
[13:36:57.119]                           restarts <- computeRestarts(cond)
[13:36:57.119]                           for (restart in restarts) {
[13:36:57.119]                             name <- restart$name
[13:36:57.119]                             if (is.null(name)) 
[13:36:57.119]                               next
[13:36:57.119]                             if (!grepl(pattern, name)) 
[13:36:57.119]                               next
[13:36:57.119]                             invokeRestart(restart)
[13:36:57.119]                             muffled <- TRUE
[13:36:57.119]                             break
[13:36:57.119]                           }
[13:36:57.119]                         }
[13:36:57.119]                       }
[13:36:57.119]                       invisible(muffled)
[13:36:57.119]                     }
[13:36:57.119]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.119]                   }
[13:36:57.119]                 }
[13:36:57.119]                 else {
[13:36:57.119]                   if (TRUE) {
[13:36:57.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.119]                     {
[13:36:57.119]                       inherits <- base::inherits
[13:36:57.119]                       invokeRestart <- base::invokeRestart
[13:36:57.119]                       is.null <- base::is.null
[13:36:57.119]                       muffled <- FALSE
[13:36:57.119]                       if (inherits(cond, "message")) {
[13:36:57.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.119]                         if (muffled) 
[13:36:57.119]                           invokeRestart("muffleMessage")
[13:36:57.119]                       }
[13:36:57.119]                       else if (inherits(cond, "warning")) {
[13:36:57.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.119]                         if (muffled) 
[13:36:57.119]                           invokeRestart("muffleWarning")
[13:36:57.119]                       }
[13:36:57.119]                       else if (inherits(cond, "condition")) {
[13:36:57.119]                         if (!is.null(pattern)) {
[13:36:57.119]                           computeRestarts <- base::computeRestarts
[13:36:57.119]                           grepl <- base::grepl
[13:36:57.119]                           restarts <- computeRestarts(cond)
[13:36:57.119]                           for (restart in restarts) {
[13:36:57.119]                             name <- restart$name
[13:36:57.119]                             if (is.null(name)) 
[13:36:57.119]                               next
[13:36:57.119]                             if (!grepl(pattern, name)) 
[13:36:57.119]                               next
[13:36:57.119]                             invokeRestart(restart)
[13:36:57.119]                             muffled <- TRUE
[13:36:57.119]                             break
[13:36:57.119]                           }
[13:36:57.119]                         }
[13:36:57.119]                       }
[13:36:57.119]                       invisible(muffled)
[13:36:57.119]                     }
[13:36:57.119]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.119]                   }
[13:36:57.119]                 }
[13:36:57.119]             }
[13:36:57.119]         }))
[13:36:57.119]     }, error = function(ex) {
[13:36:57.119]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.119]                 ...future.rng), started = ...future.startTime, 
[13:36:57.119]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.119]             version = "1.8"), class = "FutureResult")
[13:36:57.119]     }, finally = {
[13:36:57.119]         if (!identical(...future.workdir, getwd())) 
[13:36:57.119]             setwd(...future.workdir)
[13:36:57.119]         {
[13:36:57.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.119]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.119]             }
[13:36:57.119]             base::options(...future.oldOptions)
[13:36:57.119]             if (.Platform$OS.type == "windows") {
[13:36:57.119]                 old_names <- names(...future.oldEnvVars)
[13:36:57.119]                 envs <- base::Sys.getenv()
[13:36:57.119]                 names <- names(envs)
[13:36:57.119]                 common <- intersect(names, old_names)
[13:36:57.119]                 added <- setdiff(names, old_names)
[13:36:57.119]                 removed <- setdiff(old_names, names)
[13:36:57.119]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.119]                   envs[common]]
[13:36:57.119]                 NAMES <- toupper(changed)
[13:36:57.119]                 args <- list()
[13:36:57.119]                 for (kk in seq_along(NAMES)) {
[13:36:57.119]                   name <- changed[[kk]]
[13:36:57.119]                   NAME <- NAMES[[kk]]
[13:36:57.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.119]                     next
[13:36:57.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.119]                 }
[13:36:57.119]                 NAMES <- toupper(added)
[13:36:57.119]                 for (kk in seq_along(NAMES)) {
[13:36:57.119]                   name <- added[[kk]]
[13:36:57.119]                   NAME <- NAMES[[kk]]
[13:36:57.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.119]                     next
[13:36:57.119]                   args[[name]] <- ""
[13:36:57.119]                 }
[13:36:57.119]                 NAMES <- toupper(removed)
[13:36:57.119]                 for (kk in seq_along(NAMES)) {
[13:36:57.119]                   name <- removed[[kk]]
[13:36:57.119]                   NAME <- NAMES[[kk]]
[13:36:57.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.119]                     next
[13:36:57.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.119]                 }
[13:36:57.119]                 if (length(args) > 0) 
[13:36:57.119]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.119]             }
[13:36:57.119]             else {
[13:36:57.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.119]             }
[13:36:57.119]             {
[13:36:57.119]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.119]                   0L) {
[13:36:57.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.119]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.119]                   base::options(opts)
[13:36:57.119]                 }
[13:36:57.119]                 {
[13:36:57.119]                   {
[13:36:57.119]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.119]                     NULL
[13:36:57.119]                   }
[13:36:57.119]                   options(future.plan = NULL)
[13:36:57.119]                   if (is.na(NA_character_)) 
[13:36:57.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.119]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.119]                     .init = FALSE)
[13:36:57.119]                 }
[13:36:57.119]             }
[13:36:57.119]         }
[13:36:57.119]     })
[13:36:57.119]     if (TRUE) {
[13:36:57.119]         base::sink(type = "output", split = FALSE)
[13:36:57.119]         if (TRUE) {
[13:36:57.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.119]         }
[13:36:57.119]         else {
[13:36:57.119]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.119]         }
[13:36:57.119]         base::close(...future.stdout)
[13:36:57.119]         ...future.stdout <- NULL
[13:36:57.119]     }
[13:36:57.119]     ...future.result$conditions <- ...future.conditions
[13:36:57.119]     ...future.result$finished <- base::Sys.time()
[13:36:57.119]     ...future.result
[13:36:57.119] }
[13:36:57.122] assign_globals() ...
[13:36:57.122] List of 2
[13:36:57.122]  $ a : num 1
[13:36:57.122]  $ ii: int 2
[13:36:57.122]  - attr(*, "where")=List of 2
[13:36:57.122]   ..$ a :<environment: R_EmptyEnv> 
[13:36:57.122]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:57.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.122]  - attr(*, "resolved")= logi TRUE
[13:36:57.122]  - attr(*, "total_size")= num 112
[13:36:57.122]  - attr(*, "already-done")= logi TRUE
[13:36:57.126] - copied ‘a’ to environment
[13:36:57.126] - copied ‘ii’ to environment
[13:36:57.126] assign_globals() ... done
[13:36:57.126] requestCore(): workers = 2
[13:36:57.128] MulticoreFuture started
[13:36:57.128] - Launch lazy future ... done
[13:36:57.129] run() for ‘MulticoreFuture’ ... done
[13:36:57.129] result() for MulticoreFuture ...
[13:36:57.129] plan(): Setting new future strategy stack:
[13:36:57.129] List of future strategies:
[13:36:57.129] 1. sequential:
[13:36:57.129]    - args: function (..., envir = parent.frame())
[13:36:57.129]    - tweaked: FALSE
[13:36:57.129]    - call: NULL
[13:36:57.130] plan(): nbrOfWorkers() = 1
[13:36:57.132] plan(): Setting new future strategy stack:
[13:36:57.133] List of future strategies:
[13:36:57.133] 1. multicore:
[13:36:57.133]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.133]    - tweaked: FALSE
[13:36:57.133]    - call: plan(strategy)
[13:36:57.138] plan(): nbrOfWorkers() = 2
[13:36:57.139] result() for MulticoreFuture ...
[13:36:57.139] result() for MulticoreFuture ... done
[13:36:57.139] result() for MulticoreFuture ... done
[13:36:57.139] result() for MulticoreFuture ...
[13:36:57.140] result() for MulticoreFuture ... done
[13:36:57.140] run() for ‘Future’ ...
[13:36:57.140] - state: ‘created’
[13:36:57.140] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.145] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.145] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.145]   - Field: ‘label’
[13:36:57.145]   - Field: ‘local’
[13:36:57.145]   - Field: ‘owner’
[13:36:57.145]   - Field: ‘envir’
[13:36:57.145]   - Field: ‘workers’
[13:36:57.145]   - Field: ‘packages’
[13:36:57.146]   - Field: ‘gc’
[13:36:57.146]   - Field: ‘job’
[13:36:57.146]   - Field: ‘conditions’
[13:36:57.149]   - Field: ‘expr’
[13:36:57.149]   - Field: ‘uuid’
[13:36:57.149]   - Field: ‘seed’
[13:36:57.150]   - Field: ‘version’
[13:36:57.150]   - Field: ‘result’
[13:36:57.150]   - Field: ‘asynchronous’
[13:36:57.150]   - Field: ‘calls’
[13:36:57.150]   - Field: ‘globals’
[13:36:57.150]   - Field: ‘stdout’
[13:36:57.150]   - Field: ‘earlySignal’
[13:36:57.151]   - Field: ‘lazy’
[13:36:57.151]   - Field: ‘state’
[13:36:57.151] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.151] - Launch lazy future ...
[13:36:57.151] Packages needed by the future expression (n = 0): <none>
[13:36:57.151] Packages needed by future strategies (n = 0): <none>
[13:36:57.152] {
[13:36:57.152]     {
[13:36:57.152]         {
[13:36:57.152]             ...future.startTime <- base::Sys.time()
[13:36:57.152]             {
[13:36:57.152]                 {
[13:36:57.152]                   {
[13:36:57.152]                     {
[13:36:57.152]                       base::local({
[13:36:57.152]                         has_future <- base::requireNamespace("future", 
[13:36:57.152]                           quietly = TRUE)
[13:36:57.152]                         if (has_future) {
[13:36:57.152]                           ns <- base::getNamespace("future")
[13:36:57.152]                           version <- ns[[".package"]][["version"]]
[13:36:57.152]                           if (is.null(version)) 
[13:36:57.152]                             version <- utils::packageVersion("future")
[13:36:57.152]                         }
[13:36:57.152]                         else {
[13:36:57.152]                           version <- NULL
[13:36:57.152]                         }
[13:36:57.152]                         if (!has_future || version < "1.8.0") {
[13:36:57.152]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.152]                             "", base::R.version$version.string), 
[13:36:57.152]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.152]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.152]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.152]                               "release", "version")], collapse = " "), 
[13:36:57.152]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.152]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.152]                             info)
[13:36:57.152]                           info <- base::paste(info, collapse = "; ")
[13:36:57.152]                           if (!has_future) {
[13:36:57.152]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.152]                               info)
[13:36:57.152]                           }
[13:36:57.152]                           else {
[13:36:57.152]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.152]                               info, version)
[13:36:57.152]                           }
[13:36:57.152]                           base::stop(msg)
[13:36:57.152]                         }
[13:36:57.152]                       })
[13:36:57.152]                     }
[13:36:57.152]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.152]                     base::options(mc.cores = 1L)
[13:36:57.152]                   }
[13:36:57.152]                   ...future.strategy.old <- future::plan("list")
[13:36:57.152]                   options(future.plan = NULL)
[13:36:57.152]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.152]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.152]                 }
[13:36:57.152]                 ...future.workdir <- getwd()
[13:36:57.152]             }
[13:36:57.152]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.152]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.152]         }
[13:36:57.152]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.152]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.152]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.152]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.152]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.152]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.152]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.152]             base::names(...future.oldOptions))
[13:36:57.152]     }
[13:36:57.152]     if (FALSE) {
[13:36:57.152]     }
[13:36:57.152]     else {
[13:36:57.152]         if (TRUE) {
[13:36:57.152]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.152]                 open = "w")
[13:36:57.152]         }
[13:36:57.152]         else {
[13:36:57.152]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.152]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.152]         }
[13:36:57.152]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.152]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.152]             base::sink(type = "output", split = FALSE)
[13:36:57.152]             base::close(...future.stdout)
[13:36:57.152]         }, add = TRUE)
[13:36:57.152]     }
[13:36:57.152]     ...future.frame <- base::sys.nframe()
[13:36:57.152]     ...future.conditions <- base::list()
[13:36:57.152]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.152]     if (FALSE) {
[13:36:57.152]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.152]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.152]     }
[13:36:57.152]     ...future.result <- base::tryCatch({
[13:36:57.152]         base::withCallingHandlers({
[13:36:57.152]             ...future.value <- base::withVisible(base::local({
[13:36:57.152]                 withCallingHandlers({
[13:36:57.152]                   {
[13:36:57.152]                     b <- a * ii
[13:36:57.152]                     a <- 0
[13:36:57.152]                     b
[13:36:57.152]                   }
[13:36:57.152]                 }, immediateCondition = function(cond) {
[13:36:57.152]                   save_rds <- function (object, pathname, ...) 
[13:36:57.152]                   {
[13:36:57.152]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.152]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.152]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.152]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.152]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.152]                         fi_tmp[["mtime"]])
[13:36:57.152]                     }
[13:36:57.152]                     tryCatch({
[13:36:57.152]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.152]                     }, error = function(ex) {
[13:36:57.152]                       msg <- conditionMessage(ex)
[13:36:57.152]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.152]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.152]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.152]                         fi_tmp[["mtime"]], msg)
[13:36:57.152]                       ex$message <- msg
[13:36:57.152]                       stop(ex)
[13:36:57.152]                     })
[13:36:57.152]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.152]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.152]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.152]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.152]                       fi <- file.info(pathname)
[13:36:57.152]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.152]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.152]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.152]                         fi[["size"]], fi[["mtime"]])
[13:36:57.152]                       stop(msg)
[13:36:57.152]                     }
[13:36:57.152]                     invisible(pathname)
[13:36:57.152]                   }
[13:36:57.152]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.152]                     rootPath = tempdir()) 
[13:36:57.152]                   {
[13:36:57.152]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.152]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.152]                       tmpdir = path, fileext = ".rds")
[13:36:57.152]                     save_rds(obj, file)
[13:36:57.152]                   }
[13:36:57.152]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.152]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.152]                   {
[13:36:57.152]                     inherits <- base::inherits
[13:36:57.152]                     invokeRestart <- base::invokeRestart
[13:36:57.152]                     is.null <- base::is.null
[13:36:57.152]                     muffled <- FALSE
[13:36:57.152]                     if (inherits(cond, "message")) {
[13:36:57.152]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.152]                       if (muffled) 
[13:36:57.152]                         invokeRestart("muffleMessage")
[13:36:57.152]                     }
[13:36:57.152]                     else if (inherits(cond, "warning")) {
[13:36:57.152]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.152]                       if (muffled) 
[13:36:57.152]                         invokeRestart("muffleWarning")
[13:36:57.152]                     }
[13:36:57.152]                     else if (inherits(cond, "condition")) {
[13:36:57.152]                       if (!is.null(pattern)) {
[13:36:57.152]                         computeRestarts <- base::computeRestarts
[13:36:57.152]                         grepl <- base::grepl
[13:36:57.152]                         restarts <- computeRestarts(cond)
[13:36:57.152]                         for (restart in restarts) {
[13:36:57.152]                           name <- restart$name
[13:36:57.152]                           if (is.null(name)) 
[13:36:57.152]                             next
[13:36:57.152]                           if (!grepl(pattern, name)) 
[13:36:57.152]                             next
[13:36:57.152]                           invokeRestart(restart)
[13:36:57.152]                           muffled <- TRUE
[13:36:57.152]                           break
[13:36:57.152]                         }
[13:36:57.152]                       }
[13:36:57.152]                     }
[13:36:57.152]                     invisible(muffled)
[13:36:57.152]                   }
[13:36:57.152]                   muffleCondition(cond)
[13:36:57.152]                 })
[13:36:57.152]             }))
[13:36:57.152]             future::FutureResult(value = ...future.value$value, 
[13:36:57.152]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.152]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.152]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.152]                     ...future.globalenv.names))
[13:36:57.152]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.152]         }, condition = base::local({
[13:36:57.152]             c <- base::c
[13:36:57.152]             inherits <- base::inherits
[13:36:57.152]             invokeRestart <- base::invokeRestart
[13:36:57.152]             length <- base::length
[13:36:57.152]             list <- base::list
[13:36:57.152]             seq.int <- base::seq.int
[13:36:57.152]             signalCondition <- base::signalCondition
[13:36:57.152]             sys.calls <- base::sys.calls
[13:36:57.152]             `[[` <- base::`[[`
[13:36:57.152]             `+` <- base::`+`
[13:36:57.152]             `<<-` <- base::`<<-`
[13:36:57.152]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.152]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.152]                   3L)]
[13:36:57.152]             }
[13:36:57.152]             function(cond) {
[13:36:57.152]                 is_error <- inherits(cond, "error")
[13:36:57.152]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.152]                   NULL)
[13:36:57.152]                 if (is_error) {
[13:36:57.152]                   sessionInformation <- function() {
[13:36:57.152]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.152]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.152]                       search = base::search(), system = base::Sys.info())
[13:36:57.152]                   }
[13:36:57.152]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.152]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.152]                     cond$call), session = sessionInformation(), 
[13:36:57.152]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.152]                   signalCondition(cond)
[13:36:57.152]                 }
[13:36:57.152]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.152]                 "immediateCondition"))) {
[13:36:57.152]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.152]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.152]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.152]                   if (TRUE && !signal) {
[13:36:57.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.152]                     {
[13:36:57.152]                       inherits <- base::inherits
[13:36:57.152]                       invokeRestart <- base::invokeRestart
[13:36:57.152]                       is.null <- base::is.null
[13:36:57.152]                       muffled <- FALSE
[13:36:57.152]                       if (inherits(cond, "message")) {
[13:36:57.152]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.152]                         if (muffled) 
[13:36:57.152]                           invokeRestart("muffleMessage")
[13:36:57.152]                       }
[13:36:57.152]                       else if (inherits(cond, "warning")) {
[13:36:57.152]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.152]                         if (muffled) 
[13:36:57.152]                           invokeRestart("muffleWarning")
[13:36:57.152]                       }
[13:36:57.152]                       else if (inherits(cond, "condition")) {
[13:36:57.152]                         if (!is.null(pattern)) {
[13:36:57.152]                           computeRestarts <- base::computeRestarts
[13:36:57.152]                           grepl <- base::grepl
[13:36:57.152]                           restarts <- computeRestarts(cond)
[13:36:57.152]                           for (restart in restarts) {
[13:36:57.152]                             name <- restart$name
[13:36:57.152]                             if (is.null(name)) 
[13:36:57.152]                               next
[13:36:57.152]                             if (!grepl(pattern, name)) 
[13:36:57.152]                               next
[13:36:57.152]                             invokeRestart(restart)
[13:36:57.152]                             muffled <- TRUE
[13:36:57.152]                             break
[13:36:57.152]                           }
[13:36:57.152]                         }
[13:36:57.152]                       }
[13:36:57.152]                       invisible(muffled)
[13:36:57.152]                     }
[13:36:57.152]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.152]                   }
[13:36:57.152]                 }
[13:36:57.152]                 else {
[13:36:57.152]                   if (TRUE) {
[13:36:57.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.152]                     {
[13:36:57.152]                       inherits <- base::inherits
[13:36:57.152]                       invokeRestart <- base::invokeRestart
[13:36:57.152]                       is.null <- base::is.null
[13:36:57.152]                       muffled <- FALSE
[13:36:57.152]                       if (inherits(cond, "message")) {
[13:36:57.152]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.152]                         if (muffled) 
[13:36:57.152]                           invokeRestart("muffleMessage")
[13:36:57.152]                       }
[13:36:57.152]                       else if (inherits(cond, "warning")) {
[13:36:57.152]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.152]                         if (muffled) 
[13:36:57.152]                           invokeRestart("muffleWarning")
[13:36:57.152]                       }
[13:36:57.152]                       else if (inherits(cond, "condition")) {
[13:36:57.152]                         if (!is.null(pattern)) {
[13:36:57.152]                           computeRestarts <- base::computeRestarts
[13:36:57.152]                           grepl <- base::grepl
[13:36:57.152]                           restarts <- computeRestarts(cond)
[13:36:57.152]                           for (restart in restarts) {
[13:36:57.152]                             name <- restart$name
[13:36:57.152]                             if (is.null(name)) 
[13:36:57.152]                               next
[13:36:57.152]                             if (!grepl(pattern, name)) 
[13:36:57.152]                               next
[13:36:57.152]                             invokeRestart(restart)
[13:36:57.152]                             muffled <- TRUE
[13:36:57.152]                             break
[13:36:57.152]                           }
[13:36:57.152]                         }
[13:36:57.152]                       }
[13:36:57.152]                       invisible(muffled)
[13:36:57.152]                     }
[13:36:57.152]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.152]                   }
[13:36:57.152]                 }
[13:36:57.152]             }
[13:36:57.152]         }))
[13:36:57.152]     }, error = function(ex) {
[13:36:57.152]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.152]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.152]                 ...future.rng), started = ...future.startTime, 
[13:36:57.152]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.152]             version = "1.8"), class = "FutureResult")
[13:36:57.152]     }, finally = {
[13:36:57.152]         if (!identical(...future.workdir, getwd())) 
[13:36:57.152]             setwd(...future.workdir)
[13:36:57.152]         {
[13:36:57.152]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.152]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.152]             }
[13:36:57.152]             base::options(...future.oldOptions)
[13:36:57.152]             if (.Platform$OS.type == "windows") {
[13:36:57.152]                 old_names <- names(...future.oldEnvVars)
[13:36:57.152]                 envs <- base::Sys.getenv()
[13:36:57.152]                 names <- names(envs)
[13:36:57.152]                 common <- intersect(names, old_names)
[13:36:57.152]                 added <- setdiff(names, old_names)
[13:36:57.152]                 removed <- setdiff(old_names, names)
[13:36:57.152]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.152]                   envs[common]]
[13:36:57.152]                 NAMES <- toupper(changed)
[13:36:57.152]                 args <- list()
[13:36:57.152]                 for (kk in seq_along(NAMES)) {
[13:36:57.152]                   name <- changed[[kk]]
[13:36:57.152]                   NAME <- NAMES[[kk]]
[13:36:57.152]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.152]                     next
[13:36:57.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.152]                 }
[13:36:57.152]                 NAMES <- toupper(added)
[13:36:57.152]                 for (kk in seq_along(NAMES)) {
[13:36:57.152]                   name <- added[[kk]]
[13:36:57.152]                   NAME <- NAMES[[kk]]
[13:36:57.152]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.152]                     next
[13:36:57.152]                   args[[name]] <- ""
[13:36:57.152]                 }
[13:36:57.152]                 NAMES <- toupper(removed)
[13:36:57.152]                 for (kk in seq_along(NAMES)) {
[13:36:57.152]                   name <- removed[[kk]]
[13:36:57.152]                   NAME <- NAMES[[kk]]
[13:36:57.152]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.152]                     next
[13:36:57.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.152]                 }
[13:36:57.152]                 if (length(args) > 0) 
[13:36:57.152]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.152]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.152]             }
[13:36:57.152]             else {
[13:36:57.152]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.152]             }
[13:36:57.152]             {
[13:36:57.152]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.152]                   0L) {
[13:36:57.152]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.152]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.152]                   base::options(opts)
[13:36:57.152]                 }
[13:36:57.152]                 {
[13:36:57.152]                   {
[13:36:57.152]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.152]                     NULL
[13:36:57.152]                   }
[13:36:57.152]                   options(future.plan = NULL)
[13:36:57.152]                   if (is.na(NA_character_)) 
[13:36:57.152]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.152]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.152]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.152]                     .init = FALSE)
[13:36:57.152]                 }
[13:36:57.152]             }
[13:36:57.152]         }
[13:36:57.152]     })
[13:36:57.152]     if (TRUE) {
[13:36:57.152]         base::sink(type = "output", split = FALSE)
[13:36:57.152]         if (TRUE) {
[13:36:57.152]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.152]         }
[13:36:57.152]         else {
[13:36:57.152]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.152]         }
[13:36:57.152]         base::close(...future.stdout)
[13:36:57.152]         ...future.stdout <- NULL
[13:36:57.152]     }
[13:36:57.152]     ...future.result$conditions <- ...future.conditions
[13:36:57.152]     ...future.result$finished <- base::Sys.time()
[13:36:57.152]     ...future.result
[13:36:57.152] }
[13:36:57.155] assign_globals() ...
[13:36:57.155] List of 2
[13:36:57.155]  $ a : num 1
[13:36:57.155]  $ ii: int 3
[13:36:57.155]  - attr(*, "where")=List of 2
[13:36:57.155]   ..$ a :<environment: R_EmptyEnv> 
[13:36:57.155]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:57.155]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.155]  - attr(*, "resolved")= logi TRUE
[13:36:57.155]  - attr(*, "total_size")= num 112
[13:36:57.155]  - attr(*, "already-done")= logi TRUE
[13:36:57.159] - copied ‘a’ to environment
[13:36:57.159] - copied ‘ii’ to environment
[13:36:57.159] assign_globals() ... done
[13:36:57.160] requestCore(): workers = 2
[13:36:57.162] MulticoreFuture started
[13:36:57.162] - Launch lazy future ... done
[13:36:57.162] run() for ‘MulticoreFuture’ ... done
[13:36:57.163] plan(): Setting new future strategy stack:
[13:36:57.163] result() for MulticoreFuture ...
[13:36:57.163] List of future strategies:
[13:36:57.163] 1. sequential:
[13:36:57.163]    - args: function (..., envir = parent.frame())
[13:36:57.163]    - tweaked: FALSE
[13:36:57.163]    - call: NULL
[13:36:57.164] plan(): nbrOfWorkers() = 1
[13:36:57.167] plan(): Setting new future strategy stack:
[13:36:57.167] List of future strategies:
[13:36:57.167] 1. multicore:
[13:36:57.167]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.167]    - tweaked: FALSE
[13:36:57.167]    - call: plan(strategy)
[13:36:57.173] plan(): nbrOfWorkers() = 2
[13:36:57.174] result() for MulticoreFuture ...
[13:36:57.174] result() for MulticoreFuture ... done
[13:36:57.174] result() for MulticoreFuture ... done
[13:36:57.174] result() for MulticoreFuture ...
[13:36:57.175] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.175] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.176] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.176] 
[13:36:57.176] Searching for globals ... DONE
[13:36:57.177] - globals: [0] <none>
[13:36:57.177] getGlobalsAndPackages() ... DONE
[13:36:57.177] run() for ‘Future’ ...
[13:36:57.177] - state: ‘created’
[13:36:57.177] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.182] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.182] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.182]   - Field: ‘label’
[13:36:57.182]   - Field: ‘local’
[13:36:57.182]   - Field: ‘owner’
[13:36:57.182]   - Field: ‘envir’
[13:36:57.183]   - Field: ‘workers’
[13:36:57.183]   - Field: ‘packages’
[13:36:57.183]   - Field: ‘gc’
[13:36:57.183]   - Field: ‘job’
[13:36:57.183]   - Field: ‘conditions’
[13:36:57.183]   - Field: ‘expr’
[13:36:57.183]   - Field: ‘uuid’
[13:36:57.183]   - Field: ‘seed’
[13:36:57.184]   - Field: ‘version’
[13:36:57.184]   - Field: ‘result’
[13:36:57.184]   - Field: ‘asynchronous’
[13:36:57.184]   - Field: ‘calls’
[13:36:57.184]   - Field: ‘globals’
[13:36:57.184]   - Field: ‘stdout’
[13:36:57.184]   - Field: ‘earlySignal’
[13:36:57.184]   - Field: ‘lazy’
[13:36:57.184]   - Field: ‘state’
[13:36:57.185] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.185] - Launch lazy future ...
[13:36:57.185] Packages needed by the future expression (n = 0): <none>
[13:36:57.185] Packages needed by future strategies (n = 0): <none>
[13:36:57.186] {
[13:36:57.186]     {
[13:36:57.186]         {
[13:36:57.186]             ...future.startTime <- base::Sys.time()
[13:36:57.186]             {
[13:36:57.186]                 {
[13:36:57.186]                   {
[13:36:57.186]                     {
[13:36:57.186]                       base::local({
[13:36:57.186]                         has_future <- base::requireNamespace("future", 
[13:36:57.186]                           quietly = TRUE)
[13:36:57.186]                         if (has_future) {
[13:36:57.186]                           ns <- base::getNamespace("future")
[13:36:57.186]                           version <- ns[[".package"]][["version"]]
[13:36:57.186]                           if (is.null(version)) 
[13:36:57.186]                             version <- utils::packageVersion("future")
[13:36:57.186]                         }
[13:36:57.186]                         else {
[13:36:57.186]                           version <- NULL
[13:36:57.186]                         }
[13:36:57.186]                         if (!has_future || version < "1.8.0") {
[13:36:57.186]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.186]                             "", base::R.version$version.string), 
[13:36:57.186]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.186]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.186]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.186]                               "release", "version")], collapse = " "), 
[13:36:57.186]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.186]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.186]                             info)
[13:36:57.186]                           info <- base::paste(info, collapse = "; ")
[13:36:57.186]                           if (!has_future) {
[13:36:57.186]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.186]                               info)
[13:36:57.186]                           }
[13:36:57.186]                           else {
[13:36:57.186]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.186]                               info, version)
[13:36:57.186]                           }
[13:36:57.186]                           base::stop(msg)
[13:36:57.186]                         }
[13:36:57.186]                       })
[13:36:57.186]                     }
[13:36:57.186]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.186]                     base::options(mc.cores = 1L)
[13:36:57.186]                   }
[13:36:57.186]                   ...future.strategy.old <- future::plan("list")
[13:36:57.186]                   options(future.plan = NULL)
[13:36:57.186]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.186]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.186]                 }
[13:36:57.186]                 ...future.workdir <- getwd()
[13:36:57.186]             }
[13:36:57.186]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.186]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.186]         }
[13:36:57.186]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.186]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.186]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.186]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.186]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.186]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.186]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.186]             base::names(...future.oldOptions))
[13:36:57.186]     }
[13:36:57.186]     if (FALSE) {
[13:36:57.186]     }
[13:36:57.186]     else {
[13:36:57.186]         if (TRUE) {
[13:36:57.186]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.186]                 open = "w")
[13:36:57.186]         }
[13:36:57.186]         else {
[13:36:57.186]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.186]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.186]         }
[13:36:57.186]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.186]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.186]             base::sink(type = "output", split = FALSE)
[13:36:57.186]             base::close(...future.stdout)
[13:36:57.186]         }, add = TRUE)
[13:36:57.186]     }
[13:36:57.186]     ...future.frame <- base::sys.nframe()
[13:36:57.186]     ...future.conditions <- base::list()
[13:36:57.186]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.186]     if (FALSE) {
[13:36:57.186]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.186]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.186]     }
[13:36:57.186]     ...future.result <- base::tryCatch({
[13:36:57.186]         base::withCallingHandlers({
[13:36:57.186]             ...future.value <- base::withVisible(base::local({
[13:36:57.186]                 withCallingHandlers({
[13:36:57.186]                   1
[13:36:57.186]                 }, immediateCondition = function(cond) {
[13:36:57.186]                   save_rds <- function (object, pathname, ...) 
[13:36:57.186]                   {
[13:36:57.186]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.186]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.186]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.186]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.186]                         fi_tmp[["mtime"]])
[13:36:57.186]                     }
[13:36:57.186]                     tryCatch({
[13:36:57.186]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.186]                     }, error = function(ex) {
[13:36:57.186]                       msg <- conditionMessage(ex)
[13:36:57.186]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.186]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.186]                         fi_tmp[["mtime"]], msg)
[13:36:57.186]                       ex$message <- msg
[13:36:57.186]                       stop(ex)
[13:36:57.186]                     })
[13:36:57.186]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.186]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.186]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.186]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.186]                       fi <- file.info(pathname)
[13:36:57.186]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.186]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.186]                         fi[["size"]], fi[["mtime"]])
[13:36:57.186]                       stop(msg)
[13:36:57.186]                     }
[13:36:57.186]                     invisible(pathname)
[13:36:57.186]                   }
[13:36:57.186]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.186]                     rootPath = tempdir()) 
[13:36:57.186]                   {
[13:36:57.186]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.186]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.186]                       tmpdir = path, fileext = ".rds")
[13:36:57.186]                     save_rds(obj, file)
[13:36:57.186]                   }
[13:36:57.186]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.186]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.186]                   {
[13:36:57.186]                     inherits <- base::inherits
[13:36:57.186]                     invokeRestart <- base::invokeRestart
[13:36:57.186]                     is.null <- base::is.null
[13:36:57.186]                     muffled <- FALSE
[13:36:57.186]                     if (inherits(cond, "message")) {
[13:36:57.186]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.186]                       if (muffled) 
[13:36:57.186]                         invokeRestart("muffleMessage")
[13:36:57.186]                     }
[13:36:57.186]                     else if (inherits(cond, "warning")) {
[13:36:57.186]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.186]                       if (muffled) 
[13:36:57.186]                         invokeRestart("muffleWarning")
[13:36:57.186]                     }
[13:36:57.186]                     else if (inherits(cond, "condition")) {
[13:36:57.186]                       if (!is.null(pattern)) {
[13:36:57.186]                         computeRestarts <- base::computeRestarts
[13:36:57.186]                         grepl <- base::grepl
[13:36:57.186]                         restarts <- computeRestarts(cond)
[13:36:57.186]                         for (restart in restarts) {
[13:36:57.186]                           name <- restart$name
[13:36:57.186]                           if (is.null(name)) 
[13:36:57.186]                             next
[13:36:57.186]                           if (!grepl(pattern, name)) 
[13:36:57.186]                             next
[13:36:57.186]                           invokeRestart(restart)
[13:36:57.186]                           muffled <- TRUE
[13:36:57.186]                           break
[13:36:57.186]                         }
[13:36:57.186]                       }
[13:36:57.186]                     }
[13:36:57.186]                     invisible(muffled)
[13:36:57.186]                   }
[13:36:57.186]                   muffleCondition(cond)
[13:36:57.186]                 })
[13:36:57.186]             }))
[13:36:57.186]             future::FutureResult(value = ...future.value$value, 
[13:36:57.186]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.186]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.186]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.186]                     ...future.globalenv.names))
[13:36:57.186]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.186]         }, condition = base::local({
[13:36:57.186]             c <- base::c
[13:36:57.186]             inherits <- base::inherits
[13:36:57.186]             invokeRestart <- base::invokeRestart
[13:36:57.186]             length <- base::length
[13:36:57.186]             list <- base::list
[13:36:57.186]             seq.int <- base::seq.int
[13:36:57.186]             signalCondition <- base::signalCondition
[13:36:57.186]             sys.calls <- base::sys.calls
[13:36:57.186]             `[[` <- base::`[[`
[13:36:57.186]             `+` <- base::`+`
[13:36:57.186]             `<<-` <- base::`<<-`
[13:36:57.186]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.186]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.186]                   3L)]
[13:36:57.186]             }
[13:36:57.186]             function(cond) {
[13:36:57.186]                 is_error <- inherits(cond, "error")
[13:36:57.186]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.186]                   NULL)
[13:36:57.186]                 if (is_error) {
[13:36:57.186]                   sessionInformation <- function() {
[13:36:57.186]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.186]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.186]                       search = base::search(), system = base::Sys.info())
[13:36:57.186]                   }
[13:36:57.186]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.186]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.186]                     cond$call), session = sessionInformation(), 
[13:36:57.186]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.186]                   signalCondition(cond)
[13:36:57.186]                 }
[13:36:57.186]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.186]                 "immediateCondition"))) {
[13:36:57.186]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.186]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.186]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.186]                   if (TRUE && !signal) {
[13:36:57.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.186]                     {
[13:36:57.186]                       inherits <- base::inherits
[13:36:57.186]                       invokeRestart <- base::invokeRestart
[13:36:57.186]                       is.null <- base::is.null
[13:36:57.186]                       muffled <- FALSE
[13:36:57.186]                       if (inherits(cond, "message")) {
[13:36:57.186]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.186]                         if (muffled) 
[13:36:57.186]                           invokeRestart("muffleMessage")
[13:36:57.186]                       }
[13:36:57.186]                       else if (inherits(cond, "warning")) {
[13:36:57.186]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.186]                         if (muffled) 
[13:36:57.186]                           invokeRestart("muffleWarning")
[13:36:57.186]                       }
[13:36:57.186]                       else if (inherits(cond, "condition")) {
[13:36:57.186]                         if (!is.null(pattern)) {
[13:36:57.186]                           computeRestarts <- base::computeRestarts
[13:36:57.186]                           grepl <- base::grepl
[13:36:57.186]                           restarts <- computeRestarts(cond)
[13:36:57.186]                           for (restart in restarts) {
[13:36:57.186]                             name <- restart$name
[13:36:57.186]                             if (is.null(name)) 
[13:36:57.186]                               next
[13:36:57.186]                             if (!grepl(pattern, name)) 
[13:36:57.186]                               next
[13:36:57.186]                             invokeRestart(restart)
[13:36:57.186]                             muffled <- TRUE
[13:36:57.186]                             break
[13:36:57.186]                           }
[13:36:57.186]                         }
[13:36:57.186]                       }
[13:36:57.186]                       invisible(muffled)
[13:36:57.186]                     }
[13:36:57.186]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.186]                   }
[13:36:57.186]                 }
[13:36:57.186]                 else {
[13:36:57.186]                   if (TRUE) {
[13:36:57.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.186]                     {
[13:36:57.186]                       inherits <- base::inherits
[13:36:57.186]                       invokeRestart <- base::invokeRestart
[13:36:57.186]                       is.null <- base::is.null
[13:36:57.186]                       muffled <- FALSE
[13:36:57.186]                       if (inherits(cond, "message")) {
[13:36:57.186]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.186]                         if (muffled) 
[13:36:57.186]                           invokeRestart("muffleMessage")
[13:36:57.186]                       }
[13:36:57.186]                       else if (inherits(cond, "warning")) {
[13:36:57.186]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.186]                         if (muffled) 
[13:36:57.186]                           invokeRestart("muffleWarning")
[13:36:57.186]                       }
[13:36:57.186]                       else if (inherits(cond, "condition")) {
[13:36:57.186]                         if (!is.null(pattern)) {
[13:36:57.186]                           computeRestarts <- base::computeRestarts
[13:36:57.186]                           grepl <- base::grepl
[13:36:57.186]                           restarts <- computeRestarts(cond)
[13:36:57.186]                           for (restart in restarts) {
[13:36:57.186]                             name <- restart$name
[13:36:57.186]                             if (is.null(name)) 
[13:36:57.186]                               next
[13:36:57.186]                             if (!grepl(pattern, name)) 
[13:36:57.186]                               next
[13:36:57.186]                             invokeRestart(restart)
[13:36:57.186]                             muffled <- TRUE
[13:36:57.186]                             break
[13:36:57.186]                           }
[13:36:57.186]                         }
[13:36:57.186]                       }
[13:36:57.186]                       invisible(muffled)
[13:36:57.186]                     }
[13:36:57.186]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.186]                   }
[13:36:57.186]                 }
[13:36:57.186]             }
[13:36:57.186]         }))
[13:36:57.186]     }, error = function(ex) {
[13:36:57.186]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.186]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.186]                 ...future.rng), started = ...future.startTime, 
[13:36:57.186]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.186]             version = "1.8"), class = "FutureResult")
[13:36:57.186]     }, finally = {
[13:36:57.186]         if (!identical(...future.workdir, getwd())) 
[13:36:57.186]             setwd(...future.workdir)
[13:36:57.186]         {
[13:36:57.186]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.186]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.186]             }
[13:36:57.186]             base::options(...future.oldOptions)
[13:36:57.186]             if (.Platform$OS.type == "windows") {
[13:36:57.186]                 old_names <- names(...future.oldEnvVars)
[13:36:57.186]                 envs <- base::Sys.getenv()
[13:36:57.186]                 names <- names(envs)
[13:36:57.186]                 common <- intersect(names, old_names)
[13:36:57.186]                 added <- setdiff(names, old_names)
[13:36:57.186]                 removed <- setdiff(old_names, names)
[13:36:57.186]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.186]                   envs[common]]
[13:36:57.186]                 NAMES <- toupper(changed)
[13:36:57.186]                 args <- list()
[13:36:57.186]                 for (kk in seq_along(NAMES)) {
[13:36:57.186]                   name <- changed[[kk]]
[13:36:57.186]                   NAME <- NAMES[[kk]]
[13:36:57.186]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.186]                     next
[13:36:57.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.186]                 }
[13:36:57.186]                 NAMES <- toupper(added)
[13:36:57.186]                 for (kk in seq_along(NAMES)) {
[13:36:57.186]                   name <- added[[kk]]
[13:36:57.186]                   NAME <- NAMES[[kk]]
[13:36:57.186]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.186]                     next
[13:36:57.186]                   args[[name]] <- ""
[13:36:57.186]                 }
[13:36:57.186]                 NAMES <- toupper(removed)
[13:36:57.186]                 for (kk in seq_along(NAMES)) {
[13:36:57.186]                   name <- removed[[kk]]
[13:36:57.186]                   NAME <- NAMES[[kk]]
[13:36:57.186]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.186]                     next
[13:36:57.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.186]                 }
[13:36:57.186]                 if (length(args) > 0) 
[13:36:57.186]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.186]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.186]             }
[13:36:57.186]             else {
[13:36:57.186]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.186]             }
[13:36:57.186]             {
[13:36:57.186]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.186]                   0L) {
[13:36:57.186]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.186]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.186]                   base::options(opts)
[13:36:57.186]                 }
[13:36:57.186]                 {
[13:36:57.186]                   {
[13:36:57.186]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.186]                     NULL
[13:36:57.186]                   }
[13:36:57.186]                   options(future.plan = NULL)
[13:36:57.186]                   if (is.na(NA_character_)) 
[13:36:57.186]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.186]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.186]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.186]                     .init = FALSE)
[13:36:57.186]                 }
[13:36:57.186]             }
[13:36:57.186]         }
[13:36:57.186]     })
[13:36:57.186]     if (TRUE) {
[13:36:57.186]         base::sink(type = "output", split = FALSE)
[13:36:57.186]         if (TRUE) {
[13:36:57.186]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.186]         }
[13:36:57.186]         else {
[13:36:57.186]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.186]         }
[13:36:57.186]         base::close(...future.stdout)
[13:36:57.186]         ...future.stdout <- NULL
[13:36:57.186]     }
[13:36:57.186]     ...future.result$conditions <- ...future.conditions
[13:36:57.186]     ...future.result$finished <- base::Sys.time()
[13:36:57.186]     ...future.result
[13:36:57.186] }
[13:36:57.189] requestCore(): workers = 2
[13:36:57.190] MulticoreFuture started
[13:36:57.191] - Launch lazy future ... done
[13:36:57.191] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.191] getGlobalsAndPackages() ...
[13:36:57.191] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.192] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.192] List of future strategies:
[13:36:57.192] 1. sequential:
[13:36:57.192]    - args: function (..., envir = parent.frame())
[13:36:57.192]    - tweaked: FALSE
[13:36:57.192]    - call: NULL
[13:36:57.193] plan(): nbrOfWorkers() = 1
[13:36:57.194] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:57.194] Searching for globals ... DONE
[13:36:57.194] Resolving globals: TRUE
[13:36:57.194] Resolving any globals that are futures ...
[13:36:57.194] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:57.194] Resolving any globals that are futures ... DONE
[13:36:57.195] plan(): Setting new future strategy stack:
[13:36:57.195] Resolving futures part of globals (recursively) ...
[13:36:57.195] List of future strategies:
[13:36:57.195] 1. multicore:
[13:36:57.195]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.195]    - tweaked: FALSE
[13:36:57.195]    - call: plan(strategy)
[13:36:57.196] resolve() on list ...
[13:36:57.196]  recursive: 99
[13:36:57.196]  length: 1
[13:36:57.196]  elements: ‘a’
[13:36:57.200] plan(): nbrOfWorkers() = 2
[13:36:57.200] Future #1
[13:36:57.200] result() for MulticoreFuture ...
[13:36:57.201] result() for MulticoreFuture ...
[13:36:57.202] result() for MulticoreFuture ... done
[13:36:57.202] result() for MulticoreFuture ... done
[13:36:57.202] result() for MulticoreFuture ...
[13:36:57.202] result() for MulticoreFuture ... done
[13:36:57.202] A MulticoreFuture was resolved
[13:36:57.202]  length: 0 (resolved future 1)
[13:36:57.203] resolve() on list ... DONE
[13:36:57.203] - globals: [1] ‘a’
[13:36:57.203] Resolving futures part of globals (recursively) ... DONE
[13:36:57.206] The total size of the 1 globals is 1.57 MiB (1647008 bytes)
[13:36:57.206] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:36:57.206] - globals: [1] ‘a’
[13:36:57.206] - packages: [1] ‘future’
[13:36:57.207] getGlobalsAndPackages() ... DONE
[13:36:57.207] run() for ‘Future’ ...
[13:36:57.207] - state: ‘created’
[13:36:57.207] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.214] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.215] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.215]   - Field: ‘label’
[13:36:57.215]   - Field: ‘local’
[13:36:57.215]   - Field: ‘owner’
[13:36:57.215]   - Field: ‘envir’
[13:36:57.215]   - Field: ‘workers’
[13:36:57.215]   - Field: ‘packages’
[13:36:57.216]   - Field: ‘gc’
[13:36:57.216]   - Field: ‘job’
[13:36:57.216]   - Field: ‘conditions’
[13:36:57.216]   - Field: ‘expr’
[13:36:57.216]   - Field: ‘uuid’
[13:36:57.216]   - Field: ‘seed’
[13:36:57.216]   - Field: ‘version’
[13:36:57.217]   - Field: ‘result’
[13:36:57.217]   - Field: ‘asynchronous’
[13:36:57.217]   - Field: ‘calls’
[13:36:57.217]   - Field: ‘globals’
[13:36:57.217]   - Field: ‘stdout’
[13:36:57.217]   - Field: ‘earlySignal’
[13:36:57.217]   - Field: ‘lazy’
[13:36:57.217]   - Field: ‘state’
[13:36:57.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.218] - Launch lazy future ...
[13:36:57.218] Packages needed by the future expression (n = 1): ‘future’
[13:36:57.218] Packages needed by future strategies (n = 0): <none>
[13:36:57.219] {
[13:36:57.219]     {
[13:36:57.219]         {
[13:36:57.219]             ...future.startTime <- base::Sys.time()
[13:36:57.219]             {
[13:36:57.219]                 {
[13:36:57.219]                   {
[13:36:57.219]                     {
[13:36:57.219]                       {
[13:36:57.219]                         base::local({
[13:36:57.219]                           has_future <- base::requireNamespace("future", 
[13:36:57.219]                             quietly = TRUE)
[13:36:57.219]                           if (has_future) {
[13:36:57.219]                             ns <- base::getNamespace("future")
[13:36:57.219]                             version <- ns[[".package"]][["version"]]
[13:36:57.219]                             if (is.null(version)) 
[13:36:57.219]                               version <- utils::packageVersion("future")
[13:36:57.219]                           }
[13:36:57.219]                           else {
[13:36:57.219]                             version <- NULL
[13:36:57.219]                           }
[13:36:57.219]                           if (!has_future || version < "1.8.0") {
[13:36:57.219]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.219]                               "", base::R.version$version.string), 
[13:36:57.219]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:57.219]                                 base::R.version$platform, 8 * 
[13:36:57.219]                                   base::.Machine$sizeof.pointer), 
[13:36:57.219]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.219]                                 "release", "version")], collapse = " "), 
[13:36:57.219]                               hostname = base::Sys.info()[["nodename"]])
[13:36:57.219]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.219]                               info)
[13:36:57.219]                             info <- base::paste(info, collapse = "; ")
[13:36:57.219]                             if (!has_future) {
[13:36:57.219]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.219]                                 info)
[13:36:57.219]                             }
[13:36:57.219]                             else {
[13:36:57.219]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.219]                                 info, version)
[13:36:57.219]                             }
[13:36:57.219]                             base::stop(msg)
[13:36:57.219]                           }
[13:36:57.219]                         })
[13:36:57.219]                       }
[13:36:57.219]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.219]                       base::options(mc.cores = 1L)
[13:36:57.219]                     }
[13:36:57.219]                     base::local({
[13:36:57.219]                       for (pkg in "future") {
[13:36:57.219]                         base::loadNamespace(pkg)
[13:36:57.219]                         base::library(pkg, character.only = TRUE)
[13:36:57.219]                       }
[13:36:57.219]                     })
[13:36:57.219]                   }
[13:36:57.219]                   ...future.strategy.old <- future::plan("list")
[13:36:57.219]                   options(future.plan = NULL)
[13:36:57.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.219]                 }
[13:36:57.219]                 ...future.workdir <- getwd()
[13:36:57.219]             }
[13:36:57.219]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.219]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.219]         }
[13:36:57.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.219]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.219]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.219]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.219]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.219]             base::names(...future.oldOptions))
[13:36:57.219]     }
[13:36:57.219]     if (FALSE) {
[13:36:57.219]     }
[13:36:57.219]     else {
[13:36:57.219]         if (TRUE) {
[13:36:57.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.219]                 open = "w")
[13:36:57.219]         }
[13:36:57.219]         else {
[13:36:57.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.219]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.219]         }
[13:36:57.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.219]             base::sink(type = "output", split = FALSE)
[13:36:57.219]             base::close(...future.stdout)
[13:36:57.219]         }, add = TRUE)
[13:36:57.219]     }
[13:36:57.219]     ...future.frame <- base::sys.nframe()
[13:36:57.219]     ...future.conditions <- base::list()
[13:36:57.219]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.219]     if (FALSE) {
[13:36:57.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.219]     }
[13:36:57.219]     ...future.result <- base::tryCatch({
[13:36:57.219]         base::withCallingHandlers({
[13:36:57.219]             ...future.value <- base::withVisible(base::local({
[13:36:57.219]                 withCallingHandlers({
[13:36:57.219]                   value(a) + 1
[13:36:57.219]                 }, immediateCondition = function(cond) {
[13:36:57.219]                   save_rds <- function (object, pathname, ...) 
[13:36:57.219]                   {
[13:36:57.219]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.219]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.219]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.219]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.219]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.219]                         fi_tmp[["mtime"]])
[13:36:57.219]                     }
[13:36:57.219]                     tryCatch({
[13:36:57.219]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.219]                     }, error = function(ex) {
[13:36:57.219]                       msg <- conditionMessage(ex)
[13:36:57.219]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.219]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.219]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.219]                         fi_tmp[["mtime"]], msg)
[13:36:57.219]                       ex$message <- msg
[13:36:57.219]                       stop(ex)
[13:36:57.219]                     })
[13:36:57.219]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.219]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.219]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.219]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.219]                       fi <- file.info(pathname)
[13:36:57.219]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.219]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.219]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.219]                         fi[["size"]], fi[["mtime"]])
[13:36:57.219]                       stop(msg)
[13:36:57.219]                     }
[13:36:57.219]                     invisible(pathname)
[13:36:57.219]                   }
[13:36:57.219]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.219]                     rootPath = tempdir()) 
[13:36:57.219]                   {
[13:36:57.219]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.219]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.219]                       tmpdir = path, fileext = ".rds")
[13:36:57.219]                     save_rds(obj, file)
[13:36:57.219]                   }
[13:36:57.219]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.219]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.219]                   {
[13:36:57.219]                     inherits <- base::inherits
[13:36:57.219]                     invokeRestart <- base::invokeRestart
[13:36:57.219]                     is.null <- base::is.null
[13:36:57.219]                     muffled <- FALSE
[13:36:57.219]                     if (inherits(cond, "message")) {
[13:36:57.219]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.219]                       if (muffled) 
[13:36:57.219]                         invokeRestart("muffleMessage")
[13:36:57.219]                     }
[13:36:57.219]                     else if (inherits(cond, "warning")) {
[13:36:57.219]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.219]                       if (muffled) 
[13:36:57.219]                         invokeRestart("muffleWarning")
[13:36:57.219]                     }
[13:36:57.219]                     else if (inherits(cond, "condition")) {
[13:36:57.219]                       if (!is.null(pattern)) {
[13:36:57.219]                         computeRestarts <- base::computeRestarts
[13:36:57.219]                         grepl <- base::grepl
[13:36:57.219]                         restarts <- computeRestarts(cond)
[13:36:57.219]                         for (restart in restarts) {
[13:36:57.219]                           name <- restart$name
[13:36:57.219]                           if (is.null(name)) 
[13:36:57.219]                             next
[13:36:57.219]                           if (!grepl(pattern, name)) 
[13:36:57.219]                             next
[13:36:57.219]                           invokeRestart(restart)
[13:36:57.219]                           muffled <- TRUE
[13:36:57.219]                           break
[13:36:57.219]                         }
[13:36:57.219]                       }
[13:36:57.219]                     }
[13:36:57.219]                     invisible(muffled)
[13:36:57.219]                   }
[13:36:57.219]                   muffleCondition(cond)
[13:36:57.219]                 })
[13:36:57.219]             }))
[13:36:57.219]             future::FutureResult(value = ...future.value$value, 
[13:36:57.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.219]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.219]                     ...future.globalenv.names))
[13:36:57.219]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.219]         }, condition = base::local({
[13:36:57.219]             c <- base::c
[13:36:57.219]             inherits <- base::inherits
[13:36:57.219]             invokeRestart <- base::invokeRestart
[13:36:57.219]             length <- base::length
[13:36:57.219]             list <- base::list
[13:36:57.219]             seq.int <- base::seq.int
[13:36:57.219]             signalCondition <- base::signalCondition
[13:36:57.219]             sys.calls <- base::sys.calls
[13:36:57.219]             `[[` <- base::`[[`
[13:36:57.219]             `+` <- base::`+`
[13:36:57.219]             `<<-` <- base::`<<-`
[13:36:57.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.219]                   3L)]
[13:36:57.219]             }
[13:36:57.219]             function(cond) {
[13:36:57.219]                 is_error <- inherits(cond, "error")
[13:36:57.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.219]                   NULL)
[13:36:57.219]                 if (is_error) {
[13:36:57.219]                   sessionInformation <- function() {
[13:36:57.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.219]                       search = base::search(), system = base::Sys.info())
[13:36:57.219]                   }
[13:36:57.219]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.219]                     cond$call), session = sessionInformation(), 
[13:36:57.219]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.219]                   signalCondition(cond)
[13:36:57.219]                 }
[13:36:57.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.219]                 "immediateCondition"))) {
[13:36:57.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.219]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.219]                   if (TRUE && !signal) {
[13:36:57.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.219]                     {
[13:36:57.219]                       inherits <- base::inherits
[13:36:57.219]                       invokeRestart <- base::invokeRestart
[13:36:57.219]                       is.null <- base::is.null
[13:36:57.219]                       muffled <- FALSE
[13:36:57.219]                       if (inherits(cond, "message")) {
[13:36:57.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.219]                         if (muffled) 
[13:36:57.219]                           invokeRestart("muffleMessage")
[13:36:57.219]                       }
[13:36:57.219]                       else if (inherits(cond, "warning")) {
[13:36:57.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.219]                         if (muffled) 
[13:36:57.219]                           invokeRestart("muffleWarning")
[13:36:57.219]                       }
[13:36:57.219]                       else if (inherits(cond, "condition")) {
[13:36:57.219]                         if (!is.null(pattern)) {
[13:36:57.219]                           computeRestarts <- base::computeRestarts
[13:36:57.219]                           grepl <- base::grepl
[13:36:57.219]                           restarts <- computeRestarts(cond)
[13:36:57.219]                           for (restart in restarts) {
[13:36:57.219]                             name <- restart$name
[13:36:57.219]                             if (is.null(name)) 
[13:36:57.219]                               next
[13:36:57.219]                             if (!grepl(pattern, name)) 
[13:36:57.219]                               next
[13:36:57.219]                             invokeRestart(restart)
[13:36:57.219]                             muffled <- TRUE
[13:36:57.219]                             break
[13:36:57.219]                           }
[13:36:57.219]                         }
[13:36:57.219]                       }
[13:36:57.219]                       invisible(muffled)
[13:36:57.219]                     }
[13:36:57.219]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.219]                   }
[13:36:57.219]                 }
[13:36:57.219]                 else {
[13:36:57.219]                   if (TRUE) {
[13:36:57.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.219]                     {
[13:36:57.219]                       inherits <- base::inherits
[13:36:57.219]                       invokeRestart <- base::invokeRestart
[13:36:57.219]                       is.null <- base::is.null
[13:36:57.219]                       muffled <- FALSE
[13:36:57.219]                       if (inherits(cond, "message")) {
[13:36:57.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.219]                         if (muffled) 
[13:36:57.219]                           invokeRestart("muffleMessage")
[13:36:57.219]                       }
[13:36:57.219]                       else if (inherits(cond, "warning")) {
[13:36:57.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.219]                         if (muffled) 
[13:36:57.219]                           invokeRestart("muffleWarning")
[13:36:57.219]                       }
[13:36:57.219]                       else if (inherits(cond, "condition")) {
[13:36:57.219]                         if (!is.null(pattern)) {
[13:36:57.219]                           computeRestarts <- base::computeRestarts
[13:36:57.219]                           grepl <- base::grepl
[13:36:57.219]                           restarts <- computeRestarts(cond)
[13:36:57.219]                           for (restart in restarts) {
[13:36:57.219]                             name <- restart$name
[13:36:57.219]                             if (is.null(name)) 
[13:36:57.219]                               next
[13:36:57.219]                             if (!grepl(pattern, name)) 
[13:36:57.219]                               next
[13:36:57.219]                             invokeRestart(restart)
[13:36:57.219]                             muffled <- TRUE
[13:36:57.219]                             break
[13:36:57.219]                           }
[13:36:57.219]                         }
[13:36:57.219]                       }
[13:36:57.219]                       invisible(muffled)
[13:36:57.219]                     }
[13:36:57.219]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.219]                   }
[13:36:57.219]                 }
[13:36:57.219]             }
[13:36:57.219]         }))
[13:36:57.219]     }, error = function(ex) {
[13:36:57.219]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.219]                 ...future.rng), started = ...future.startTime, 
[13:36:57.219]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.219]             version = "1.8"), class = "FutureResult")
[13:36:57.219]     }, finally = {
[13:36:57.219]         if (!identical(...future.workdir, getwd())) 
[13:36:57.219]             setwd(...future.workdir)
[13:36:57.219]         {
[13:36:57.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.219]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.219]             }
[13:36:57.219]             base::options(...future.oldOptions)
[13:36:57.219]             if (.Platform$OS.type == "windows") {
[13:36:57.219]                 old_names <- names(...future.oldEnvVars)
[13:36:57.219]                 envs <- base::Sys.getenv()
[13:36:57.219]                 names <- names(envs)
[13:36:57.219]                 common <- intersect(names, old_names)
[13:36:57.219]                 added <- setdiff(names, old_names)
[13:36:57.219]                 removed <- setdiff(old_names, names)
[13:36:57.219]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.219]                   envs[common]]
[13:36:57.219]                 NAMES <- toupper(changed)
[13:36:57.219]                 args <- list()
[13:36:57.219]                 for (kk in seq_along(NAMES)) {
[13:36:57.219]                   name <- changed[[kk]]
[13:36:57.219]                   NAME <- NAMES[[kk]]
[13:36:57.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.219]                     next
[13:36:57.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.219]                 }
[13:36:57.219]                 NAMES <- toupper(added)
[13:36:57.219]                 for (kk in seq_along(NAMES)) {
[13:36:57.219]                   name <- added[[kk]]
[13:36:57.219]                   NAME <- NAMES[[kk]]
[13:36:57.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.219]                     next
[13:36:57.219]                   args[[name]] <- ""
[13:36:57.219]                 }
[13:36:57.219]                 NAMES <- toupper(removed)
[13:36:57.219]                 for (kk in seq_along(NAMES)) {
[13:36:57.219]                   name <- removed[[kk]]
[13:36:57.219]                   NAME <- NAMES[[kk]]
[13:36:57.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.219]                     next
[13:36:57.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.219]                 }
[13:36:57.219]                 if (length(args) > 0) 
[13:36:57.219]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.219]             }
[13:36:57.219]             else {
[13:36:57.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.219]             }
[13:36:57.219]             {
[13:36:57.219]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.219]                   0L) {
[13:36:57.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.219]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.219]                   base::options(opts)
[13:36:57.219]                 }
[13:36:57.219]                 {
[13:36:57.219]                   {
[13:36:57.219]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.219]                     NULL
[13:36:57.219]                   }
[13:36:57.219]                   options(future.plan = NULL)
[13:36:57.219]                   if (is.na(NA_character_)) 
[13:36:57.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.219]                     .init = FALSE)
[13:36:57.219]                 }
[13:36:57.219]             }
[13:36:57.219]         }
[13:36:57.219]     })
[13:36:57.219]     if (TRUE) {
[13:36:57.219]         base::sink(type = "output", split = FALSE)
[13:36:57.219]         if (TRUE) {
[13:36:57.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.219]         }
[13:36:57.219]         else {
[13:36:57.219]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.219]         }
[13:36:57.219]         base::close(...future.stdout)
[13:36:57.219]         ...future.stdout <- NULL
[13:36:57.219]     }
[13:36:57.219]     ...future.result$conditions <- ...future.conditions
[13:36:57.219]     ...future.result$finished <- base::Sys.time()
[13:36:57.219]     ...future.result
[13:36:57.219] }
[13:36:57.221] assign_globals() ...
[13:36:57.221] List of 1
[13:36:57.221]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c6daff82b8> 
[13:36:57.221]  - attr(*, "where")=List of 1
[13:36:57.221]   ..$ a:<environment: R_EmptyEnv> 
[13:36:57.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.221]  - attr(*, "resolved")= logi TRUE
[13:36:57.221]  - attr(*, "total_size")= num 1647008
[13:36:57.221]  - attr(*, "already-done")= logi TRUE
[13:36:57.225] - copied ‘a’ to environment
[13:36:57.225] assign_globals() ... done
[13:36:57.225] requestCore(): workers = 2
[13:36:57.227] MulticoreFuture started
[13:36:57.227] - Launch lazy future ... done
[13:36:57.228] run() for ‘MulticoreFuture’ ... done
[13:36:57.228] result() for MulticoreFuture ...
[13:36:57.228] plan(): Setting new future strategy stack:
[13:36:57.229] List of future strategies:
[13:36:57.229] 1. sequential:
[13:36:57.229]    - args: function (..., envir = parent.frame())
[13:36:57.229]    - tweaked: FALSE
[13:36:57.229]    - call: NULL
[13:36:57.230] plan(): nbrOfWorkers() = 1
[13:36:57.234] plan(): Setting new future strategy stack:
[13:36:57.234] List of future strategies:
[13:36:57.234] 1. multicore:
[13:36:57.234]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.234]    - tweaked: FALSE
[13:36:57.234]    - call: plan(strategy)
[13:36:57.239] plan(): nbrOfWorkers() = 2
[13:36:57.240] result() for MulticoreFuture ...
[13:36:57.240] result() for MulticoreFuture ... done
[13:36:57.240] signalConditions() ...
[13:36:57.241]  - include = ‘immediateCondition’
[13:36:57.241]  - exclude = 
[13:36:57.241]  - resignal = FALSE
[13:36:57.241]  - Number of conditions: 4
[13:36:57.242] signalConditions() ... done
[13:36:57.242] result() for MulticoreFuture ... done
[13:36:57.242] result() for MulticoreFuture ...
[13:36:57.242] result() for MulticoreFuture ... done
[13:36:57.242] signalConditions() ...
[13:36:57.243]  - include = ‘immediateCondition’
[13:36:57.243]  - exclude = 
[13:36:57.243]  - resignal = FALSE
[13:36:57.243]  - Number of conditions: 4
[13:36:57.243] signalConditions() ... done
[13:36:57.243] Future state: ‘finished’
[13:36:57.243] result() for MulticoreFuture ...
[13:36:57.244] result() for MulticoreFuture ... done
[13:36:57.244] signalConditions() ...
[13:36:57.244]  - include = ‘condition’
[13:36:57.244]  - exclude = ‘immediateCondition’
[13:36:57.244]  - resignal = TRUE
[13:36:57.244]  - Number of conditions: 4
[13:36:57.244]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.231] result() for MulticoreFuture ...
[13:36:57.244]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.232] result() for MulticoreFuture ... done
[13:36:57.245]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.232] result() for MulticoreFuture ...
[13:36:57.245]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.232] result() for MulticoreFuture ... done
[13:36:57.245] signalConditions() ... done
value(b) = 2
[13:36:57.245] result() for MulticoreFuture ...
[13:36:57.245] result() for MulticoreFuture ... done
[13:36:57.245] result() for MulticoreFuture ...
[13:36:57.245] result() for MulticoreFuture ... done
[13:36:57.246] signalConditions() ...
[13:36:57.246]  - include = ‘immediateCondition’
[13:36:57.246]  - exclude = 
[13:36:57.246]  - resignal = FALSE
[13:36:57.246]  - Number of conditions: 4
[13:36:57.246] signalConditions() ... done
[13:36:57.246] Future state: ‘finished’
[13:36:57.246] result() for MulticoreFuture ...
[13:36:57.247] result() for MulticoreFuture ... done
[13:36:57.247] signalConditions() ...
[13:36:57.247]  - include = ‘condition’
[13:36:57.247]  - exclude = ‘immediateCondition’
[13:36:57.247]  - resignal = TRUE
[13:36:57.247]  - Number of conditions: 4
[13:36:57.247]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.231] result() for MulticoreFuture ...
[13:36:57.247]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.232] result() for MulticoreFuture ... done
[13:36:57.248]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.232] result() for MulticoreFuture ...
[13:36:57.248]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.232] result() for MulticoreFuture ... done
[13:36:57.248] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.248] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.248] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.249] 
[13:36:57.249] Searching for globals ... DONE
[13:36:57.249] - globals: [0] <none>
[13:36:57.249] getGlobalsAndPackages() ... DONE
[13:36:57.250] run() for ‘Future’ ...
[13:36:57.250] - state: ‘created’
[13:36:57.250] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.254] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.254]   - Field: ‘label’
[13:36:57.254]   - Field: ‘local’
[13:36:57.255]   - Field: ‘owner’
[13:36:57.255]   - Field: ‘envir’
[13:36:57.255]   - Field: ‘workers’
[13:36:57.255]   - Field: ‘packages’
[13:36:57.255]   - Field: ‘gc’
[13:36:57.255]   - Field: ‘job’
[13:36:57.255]   - Field: ‘conditions’
[13:36:57.255]   - Field: ‘expr’
[13:36:57.255]   - Field: ‘uuid’
[13:36:57.256]   - Field: ‘seed’
[13:36:57.256]   - Field: ‘version’
[13:36:57.256]   - Field: ‘result’
[13:36:57.256]   - Field: ‘asynchronous’
[13:36:57.256]   - Field: ‘calls’
[13:36:57.256]   - Field: ‘globals’
[13:36:57.256]   - Field: ‘stdout’
[13:36:57.256]   - Field: ‘earlySignal’
[13:36:57.256]   - Field: ‘lazy’
[13:36:57.257]   - Field: ‘state’
[13:36:57.257] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.257] - Launch lazy future ...
[13:36:57.257] Packages needed by the future expression (n = 0): <none>
[13:36:57.257] Packages needed by future strategies (n = 0): <none>
[13:36:57.258] {
[13:36:57.258]     {
[13:36:57.258]         {
[13:36:57.258]             ...future.startTime <- base::Sys.time()
[13:36:57.258]             {
[13:36:57.258]                 {
[13:36:57.258]                   {
[13:36:57.258]                     {
[13:36:57.258]                       base::local({
[13:36:57.258]                         has_future <- base::requireNamespace("future", 
[13:36:57.258]                           quietly = TRUE)
[13:36:57.258]                         if (has_future) {
[13:36:57.258]                           ns <- base::getNamespace("future")
[13:36:57.258]                           version <- ns[[".package"]][["version"]]
[13:36:57.258]                           if (is.null(version)) 
[13:36:57.258]                             version <- utils::packageVersion("future")
[13:36:57.258]                         }
[13:36:57.258]                         else {
[13:36:57.258]                           version <- NULL
[13:36:57.258]                         }
[13:36:57.258]                         if (!has_future || version < "1.8.0") {
[13:36:57.258]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.258]                             "", base::R.version$version.string), 
[13:36:57.258]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.258]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.258]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.258]                               "release", "version")], collapse = " "), 
[13:36:57.258]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.258]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.258]                             info)
[13:36:57.258]                           info <- base::paste(info, collapse = "; ")
[13:36:57.258]                           if (!has_future) {
[13:36:57.258]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.258]                               info)
[13:36:57.258]                           }
[13:36:57.258]                           else {
[13:36:57.258]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.258]                               info, version)
[13:36:57.258]                           }
[13:36:57.258]                           base::stop(msg)
[13:36:57.258]                         }
[13:36:57.258]                       })
[13:36:57.258]                     }
[13:36:57.258]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.258]                     base::options(mc.cores = 1L)
[13:36:57.258]                   }
[13:36:57.258]                   ...future.strategy.old <- future::plan("list")
[13:36:57.258]                   options(future.plan = NULL)
[13:36:57.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.258]                 }
[13:36:57.258]                 ...future.workdir <- getwd()
[13:36:57.258]             }
[13:36:57.258]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.258]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.258]         }
[13:36:57.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.258]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.258]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.258]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.258]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.258]             base::names(...future.oldOptions))
[13:36:57.258]     }
[13:36:57.258]     if (FALSE) {
[13:36:57.258]     }
[13:36:57.258]     else {
[13:36:57.258]         if (TRUE) {
[13:36:57.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.258]                 open = "w")
[13:36:57.258]         }
[13:36:57.258]         else {
[13:36:57.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.258]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.258]         }
[13:36:57.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.258]             base::sink(type = "output", split = FALSE)
[13:36:57.258]             base::close(...future.stdout)
[13:36:57.258]         }, add = TRUE)
[13:36:57.258]     }
[13:36:57.258]     ...future.frame <- base::sys.nframe()
[13:36:57.258]     ...future.conditions <- base::list()
[13:36:57.258]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.258]     if (FALSE) {
[13:36:57.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.258]     }
[13:36:57.258]     ...future.result <- base::tryCatch({
[13:36:57.258]         base::withCallingHandlers({
[13:36:57.258]             ...future.value <- base::withVisible(base::local({
[13:36:57.258]                 withCallingHandlers({
[13:36:57.258]                   1
[13:36:57.258]                 }, immediateCondition = function(cond) {
[13:36:57.258]                   save_rds <- function (object, pathname, ...) 
[13:36:57.258]                   {
[13:36:57.258]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.258]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.258]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.258]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.258]                         fi_tmp[["mtime"]])
[13:36:57.258]                     }
[13:36:57.258]                     tryCatch({
[13:36:57.258]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.258]                     }, error = function(ex) {
[13:36:57.258]                       msg <- conditionMessage(ex)
[13:36:57.258]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.258]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.258]                         fi_tmp[["mtime"]], msg)
[13:36:57.258]                       ex$message <- msg
[13:36:57.258]                       stop(ex)
[13:36:57.258]                     })
[13:36:57.258]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.258]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.258]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.258]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.258]                       fi <- file.info(pathname)
[13:36:57.258]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.258]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.258]                         fi[["size"]], fi[["mtime"]])
[13:36:57.258]                       stop(msg)
[13:36:57.258]                     }
[13:36:57.258]                     invisible(pathname)
[13:36:57.258]                   }
[13:36:57.258]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.258]                     rootPath = tempdir()) 
[13:36:57.258]                   {
[13:36:57.258]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.258]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.258]                       tmpdir = path, fileext = ".rds")
[13:36:57.258]                     save_rds(obj, file)
[13:36:57.258]                   }
[13:36:57.258]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.258]                   {
[13:36:57.258]                     inherits <- base::inherits
[13:36:57.258]                     invokeRestart <- base::invokeRestart
[13:36:57.258]                     is.null <- base::is.null
[13:36:57.258]                     muffled <- FALSE
[13:36:57.258]                     if (inherits(cond, "message")) {
[13:36:57.258]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.258]                       if (muffled) 
[13:36:57.258]                         invokeRestart("muffleMessage")
[13:36:57.258]                     }
[13:36:57.258]                     else if (inherits(cond, "warning")) {
[13:36:57.258]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.258]                       if (muffled) 
[13:36:57.258]                         invokeRestart("muffleWarning")
[13:36:57.258]                     }
[13:36:57.258]                     else if (inherits(cond, "condition")) {
[13:36:57.258]                       if (!is.null(pattern)) {
[13:36:57.258]                         computeRestarts <- base::computeRestarts
[13:36:57.258]                         grepl <- base::grepl
[13:36:57.258]                         restarts <- computeRestarts(cond)
[13:36:57.258]                         for (restart in restarts) {
[13:36:57.258]                           name <- restart$name
[13:36:57.258]                           if (is.null(name)) 
[13:36:57.258]                             next
[13:36:57.258]                           if (!grepl(pattern, name)) 
[13:36:57.258]                             next
[13:36:57.258]                           invokeRestart(restart)
[13:36:57.258]                           muffled <- TRUE
[13:36:57.258]                           break
[13:36:57.258]                         }
[13:36:57.258]                       }
[13:36:57.258]                     }
[13:36:57.258]                     invisible(muffled)
[13:36:57.258]                   }
[13:36:57.258]                   muffleCondition(cond)
[13:36:57.258]                 })
[13:36:57.258]             }))
[13:36:57.258]             future::FutureResult(value = ...future.value$value, 
[13:36:57.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.258]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.258]                     ...future.globalenv.names))
[13:36:57.258]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.258]         }, condition = base::local({
[13:36:57.258]             c <- base::c
[13:36:57.258]             inherits <- base::inherits
[13:36:57.258]             invokeRestart <- base::invokeRestart
[13:36:57.258]             length <- base::length
[13:36:57.258]             list <- base::list
[13:36:57.258]             seq.int <- base::seq.int
[13:36:57.258]             signalCondition <- base::signalCondition
[13:36:57.258]             sys.calls <- base::sys.calls
[13:36:57.258]             `[[` <- base::`[[`
[13:36:57.258]             `+` <- base::`+`
[13:36:57.258]             `<<-` <- base::`<<-`
[13:36:57.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.258]                   3L)]
[13:36:57.258]             }
[13:36:57.258]             function(cond) {
[13:36:57.258]                 is_error <- inherits(cond, "error")
[13:36:57.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.258]                   NULL)
[13:36:57.258]                 if (is_error) {
[13:36:57.258]                   sessionInformation <- function() {
[13:36:57.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.258]                       search = base::search(), system = base::Sys.info())
[13:36:57.258]                   }
[13:36:57.258]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.258]                     cond$call), session = sessionInformation(), 
[13:36:57.258]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.258]                   signalCondition(cond)
[13:36:57.258]                 }
[13:36:57.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.258]                 "immediateCondition"))) {
[13:36:57.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.258]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.258]                   if (TRUE && !signal) {
[13:36:57.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.258]                     {
[13:36:57.258]                       inherits <- base::inherits
[13:36:57.258]                       invokeRestart <- base::invokeRestart
[13:36:57.258]                       is.null <- base::is.null
[13:36:57.258]                       muffled <- FALSE
[13:36:57.258]                       if (inherits(cond, "message")) {
[13:36:57.258]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.258]                         if (muffled) 
[13:36:57.258]                           invokeRestart("muffleMessage")
[13:36:57.258]                       }
[13:36:57.258]                       else if (inherits(cond, "warning")) {
[13:36:57.258]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.258]                         if (muffled) 
[13:36:57.258]                           invokeRestart("muffleWarning")
[13:36:57.258]                       }
[13:36:57.258]                       else if (inherits(cond, "condition")) {
[13:36:57.258]                         if (!is.null(pattern)) {
[13:36:57.258]                           computeRestarts <- base::computeRestarts
[13:36:57.258]                           grepl <- base::grepl
[13:36:57.258]                           restarts <- computeRestarts(cond)
[13:36:57.258]                           for (restart in restarts) {
[13:36:57.258]                             name <- restart$name
[13:36:57.258]                             if (is.null(name)) 
[13:36:57.258]                               next
[13:36:57.258]                             if (!grepl(pattern, name)) 
[13:36:57.258]                               next
[13:36:57.258]                             invokeRestart(restart)
[13:36:57.258]                             muffled <- TRUE
[13:36:57.258]                             break
[13:36:57.258]                           }
[13:36:57.258]                         }
[13:36:57.258]                       }
[13:36:57.258]                       invisible(muffled)
[13:36:57.258]                     }
[13:36:57.258]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.258]                   }
[13:36:57.258]                 }
[13:36:57.258]                 else {
[13:36:57.258]                   if (TRUE) {
[13:36:57.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.258]                     {
[13:36:57.258]                       inherits <- base::inherits
[13:36:57.258]                       invokeRestart <- base::invokeRestart
[13:36:57.258]                       is.null <- base::is.null
[13:36:57.258]                       muffled <- FALSE
[13:36:57.258]                       if (inherits(cond, "message")) {
[13:36:57.258]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.258]                         if (muffled) 
[13:36:57.258]                           invokeRestart("muffleMessage")
[13:36:57.258]                       }
[13:36:57.258]                       else if (inherits(cond, "warning")) {
[13:36:57.258]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.258]                         if (muffled) 
[13:36:57.258]                           invokeRestart("muffleWarning")
[13:36:57.258]                       }
[13:36:57.258]                       else if (inherits(cond, "condition")) {
[13:36:57.258]                         if (!is.null(pattern)) {
[13:36:57.258]                           computeRestarts <- base::computeRestarts
[13:36:57.258]                           grepl <- base::grepl
[13:36:57.258]                           restarts <- computeRestarts(cond)
[13:36:57.258]                           for (restart in restarts) {
[13:36:57.258]                             name <- restart$name
[13:36:57.258]                             if (is.null(name)) 
[13:36:57.258]                               next
[13:36:57.258]                             if (!grepl(pattern, name)) 
[13:36:57.258]                               next
[13:36:57.258]                             invokeRestart(restart)
[13:36:57.258]                             muffled <- TRUE
[13:36:57.258]                             break
[13:36:57.258]                           }
[13:36:57.258]                         }
[13:36:57.258]                       }
[13:36:57.258]                       invisible(muffled)
[13:36:57.258]                     }
[13:36:57.258]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.258]                   }
[13:36:57.258]                 }
[13:36:57.258]             }
[13:36:57.258]         }))
[13:36:57.258]     }, error = function(ex) {
[13:36:57.258]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.258]                 ...future.rng), started = ...future.startTime, 
[13:36:57.258]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.258]             version = "1.8"), class = "FutureResult")
[13:36:57.258]     }, finally = {
[13:36:57.258]         if (!identical(...future.workdir, getwd())) 
[13:36:57.258]             setwd(...future.workdir)
[13:36:57.258]         {
[13:36:57.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.258]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.258]             }
[13:36:57.258]             base::options(...future.oldOptions)
[13:36:57.258]             if (.Platform$OS.type == "windows") {
[13:36:57.258]                 old_names <- names(...future.oldEnvVars)
[13:36:57.258]                 envs <- base::Sys.getenv()
[13:36:57.258]                 names <- names(envs)
[13:36:57.258]                 common <- intersect(names, old_names)
[13:36:57.258]                 added <- setdiff(names, old_names)
[13:36:57.258]                 removed <- setdiff(old_names, names)
[13:36:57.258]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.258]                   envs[common]]
[13:36:57.258]                 NAMES <- toupper(changed)
[13:36:57.258]                 args <- list()
[13:36:57.258]                 for (kk in seq_along(NAMES)) {
[13:36:57.258]                   name <- changed[[kk]]
[13:36:57.258]                   NAME <- NAMES[[kk]]
[13:36:57.258]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.258]                     next
[13:36:57.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.258]                 }
[13:36:57.258]                 NAMES <- toupper(added)
[13:36:57.258]                 for (kk in seq_along(NAMES)) {
[13:36:57.258]                   name <- added[[kk]]
[13:36:57.258]                   NAME <- NAMES[[kk]]
[13:36:57.258]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.258]                     next
[13:36:57.258]                   args[[name]] <- ""
[13:36:57.258]                 }
[13:36:57.258]                 NAMES <- toupper(removed)
[13:36:57.258]                 for (kk in seq_along(NAMES)) {
[13:36:57.258]                   name <- removed[[kk]]
[13:36:57.258]                   NAME <- NAMES[[kk]]
[13:36:57.258]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.258]                     next
[13:36:57.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.258]                 }
[13:36:57.258]                 if (length(args) > 0) 
[13:36:57.258]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.258]             }
[13:36:57.258]             else {
[13:36:57.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.258]             }
[13:36:57.258]             {
[13:36:57.258]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.258]                   0L) {
[13:36:57.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.258]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.258]                   base::options(opts)
[13:36:57.258]                 }
[13:36:57.258]                 {
[13:36:57.258]                   {
[13:36:57.258]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.258]                     NULL
[13:36:57.258]                   }
[13:36:57.258]                   options(future.plan = NULL)
[13:36:57.258]                   if (is.na(NA_character_)) 
[13:36:57.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.258]                     .init = FALSE)
[13:36:57.258]                 }
[13:36:57.258]             }
[13:36:57.258]         }
[13:36:57.258]     })
[13:36:57.258]     if (TRUE) {
[13:36:57.258]         base::sink(type = "output", split = FALSE)
[13:36:57.258]         if (TRUE) {
[13:36:57.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.258]         }
[13:36:57.258]         else {
[13:36:57.258]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.258]         }
[13:36:57.258]         base::close(...future.stdout)
[13:36:57.258]         ...future.stdout <- NULL
[13:36:57.258]     }
[13:36:57.258]     ...future.result$conditions <- ...future.conditions
[13:36:57.258]     ...future.result$finished <- base::Sys.time()
[13:36:57.258]     ...future.result
[13:36:57.258] }
[13:36:57.261] requestCore(): workers = 2
[13:36:57.262] MulticoreFuture started
[13:36:57.263] - Launch lazy future ... done
[13:36:57.263] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.263] getGlobalsAndPackages() ...
[13:36:57.264] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.264] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.264] List of future strategies:
[13:36:57.264] 1. sequential:
[13:36:57.264]    - args: function (..., envir = parent.frame())
[13:36:57.264]    - tweaked: FALSE
[13:36:57.264]    - call: NULL
[13:36:57.265] plan(): nbrOfWorkers() = 1
[13:36:57.270] plan(): Setting new future strategy stack:
[13:36:57.270] List of future strategies:
[13:36:57.270] 1. multicore:
[13:36:57.270]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.270]    - tweaked: FALSE
[13:36:57.270]    - call: plan(strategy)
[13:36:57.271] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:57.271] Searching for globals ... DONE
[13:36:57.272] Resolving globals: TRUE
[13:36:57.272] Resolving any globals that are futures ...
[13:36:57.272] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:57.272] Resolving any globals that are futures ... DONE
[13:36:57.273] Resolving futures part of globals (recursively) ...
[13:36:57.273] resolve() on list ...
[13:36:57.273]  recursive: 99
[13:36:57.274]  length: 1
[13:36:57.274]  elements: ‘a’
[13:36:57.275] plan(): nbrOfWorkers() = 2
[13:36:57.276] Future #1
[13:36:57.276] result() for MulticoreFuture ...
[13:36:57.277] result() for MulticoreFuture ...
[13:36:57.278] result() for MulticoreFuture ... done
[13:36:57.278] result() for MulticoreFuture ... done
[13:36:57.278] result() for MulticoreFuture ...
[13:36:57.278] result() for MulticoreFuture ... done
[13:36:57.279] A MulticoreFuture was resolved
[13:36:57.279]  length: 0 (resolved future 1)
[13:36:57.279] resolve() on list ... DONE
[13:36:57.279] - globals: [1] ‘a’
[13:36:57.280] Resolving futures part of globals (recursively) ... DONE
[13:36:57.283] The total size of the 1 globals is 1.57 MiB (1647008 bytes)
[13:36:57.284] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:36:57.284] - globals: [1] ‘a’
[13:36:57.284] - packages: [1] ‘future’
[13:36:57.284] getGlobalsAndPackages() ... DONE
[13:36:57.285] run() for ‘Future’ ...
[13:36:57.285] - state: ‘created’
[13:36:57.285] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.289] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.289] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.289]   - Field: ‘label’
[13:36:57.289]   - Field: ‘local’
[13:36:57.289]   - Field: ‘owner’
[13:36:57.289]   - Field: ‘envir’
[13:36:57.290]   - Field: ‘workers’
[13:36:57.290]   - Field: ‘packages’
[13:36:57.290]   - Field: ‘gc’
[13:36:57.290]   - Field: ‘job’
[13:36:57.290]   - Field: ‘conditions’
[13:36:57.290]   - Field: ‘expr’
[13:36:57.290]   - Field: ‘uuid’
[13:36:57.290]   - Field: ‘seed’
[13:36:57.291]   - Field: ‘version’
[13:36:57.291]   - Field: ‘result’
[13:36:57.291]   - Field: ‘asynchronous’
[13:36:57.291]   - Field: ‘calls’
[13:36:57.291]   - Field: ‘globals’
[13:36:57.291]   - Field: ‘stdout’
[13:36:57.291]   - Field: ‘earlySignal’
[13:36:57.291]   - Field: ‘lazy’
[13:36:57.291]   - Field: ‘state’
[13:36:57.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.292] - Launch lazy future ...
[13:36:57.292] Packages needed by the future expression (n = 1): ‘future’
[13:36:57.292] Packages needed by future strategies (n = 0): <none>
[13:36:57.293] {
[13:36:57.293]     {
[13:36:57.293]         {
[13:36:57.293]             ...future.startTime <- base::Sys.time()
[13:36:57.293]             {
[13:36:57.293]                 {
[13:36:57.293]                   {
[13:36:57.293]                     {
[13:36:57.293]                       {
[13:36:57.293]                         base::local({
[13:36:57.293]                           has_future <- base::requireNamespace("future", 
[13:36:57.293]                             quietly = TRUE)
[13:36:57.293]                           if (has_future) {
[13:36:57.293]                             ns <- base::getNamespace("future")
[13:36:57.293]                             version <- ns[[".package"]][["version"]]
[13:36:57.293]                             if (is.null(version)) 
[13:36:57.293]                               version <- utils::packageVersion("future")
[13:36:57.293]                           }
[13:36:57.293]                           else {
[13:36:57.293]                             version <- NULL
[13:36:57.293]                           }
[13:36:57.293]                           if (!has_future || version < "1.8.0") {
[13:36:57.293]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.293]                               "", base::R.version$version.string), 
[13:36:57.293]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:57.293]                                 base::R.version$platform, 8 * 
[13:36:57.293]                                   base::.Machine$sizeof.pointer), 
[13:36:57.293]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.293]                                 "release", "version")], collapse = " "), 
[13:36:57.293]                               hostname = base::Sys.info()[["nodename"]])
[13:36:57.293]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.293]                               info)
[13:36:57.293]                             info <- base::paste(info, collapse = "; ")
[13:36:57.293]                             if (!has_future) {
[13:36:57.293]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.293]                                 info)
[13:36:57.293]                             }
[13:36:57.293]                             else {
[13:36:57.293]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.293]                                 info, version)
[13:36:57.293]                             }
[13:36:57.293]                             base::stop(msg)
[13:36:57.293]                           }
[13:36:57.293]                         })
[13:36:57.293]                       }
[13:36:57.293]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.293]                       base::options(mc.cores = 1L)
[13:36:57.293]                     }
[13:36:57.293]                     base::local({
[13:36:57.293]                       for (pkg in "future") {
[13:36:57.293]                         base::loadNamespace(pkg)
[13:36:57.293]                         base::library(pkg, character.only = TRUE)
[13:36:57.293]                       }
[13:36:57.293]                     })
[13:36:57.293]                   }
[13:36:57.293]                   ...future.strategy.old <- future::plan("list")
[13:36:57.293]                   options(future.plan = NULL)
[13:36:57.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.293]                 }
[13:36:57.293]                 ...future.workdir <- getwd()
[13:36:57.293]             }
[13:36:57.293]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.293]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.293]         }
[13:36:57.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.293]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.293]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.293]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.293]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.293]             base::names(...future.oldOptions))
[13:36:57.293]     }
[13:36:57.293]     if (FALSE) {
[13:36:57.293]     }
[13:36:57.293]     else {
[13:36:57.293]         if (TRUE) {
[13:36:57.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.293]                 open = "w")
[13:36:57.293]         }
[13:36:57.293]         else {
[13:36:57.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.293]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.293]         }
[13:36:57.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.293]             base::sink(type = "output", split = FALSE)
[13:36:57.293]             base::close(...future.stdout)
[13:36:57.293]         }, add = TRUE)
[13:36:57.293]     }
[13:36:57.293]     ...future.frame <- base::sys.nframe()
[13:36:57.293]     ...future.conditions <- base::list()
[13:36:57.293]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.293]     if (FALSE) {
[13:36:57.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.293]     }
[13:36:57.293]     ...future.result <- base::tryCatch({
[13:36:57.293]         base::withCallingHandlers({
[13:36:57.293]             ...future.value <- base::withVisible(base::local({
[13:36:57.293]                 withCallingHandlers({
[13:36:57.293]                   value(a) + 1
[13:36:57.293]                 }, immediateCondition = function(cond) {
[13:36:57.293]                   save_rds <- function (object, pathname, ...) 
[13:36:57.293]                   {
[13:36:57.293]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.293]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.293]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.293]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.293]                         fi_tmp[["mtime"]])
[13:36:57.293]                     }
[13:36:57.293]                     tryCatch({
[13:36:57.293]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.293]                     }, error = function(ex) {
[13:36:57.293]                       msg <- conditionMessage(ex)
[13:36:57.293]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.293]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.293]                         fi_tmp[["mtime"]], msg)
[13:36:57.293]                       ex$message <- msg
[13:36:57.293]                       stop(ex)
[13:36:57.293]                     })
[13:36:57.293]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.293]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.293]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.293]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.293]                       fi <- file.info(pathname)
[13:36:57.293]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.293]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.293]                         fi[["size"]], fi[["mtime"]])
[13:36:57.293]                       stop(msg)
[13:36:57.293]                     }
[13:36:57.293]                     invisible(pathname)
[13:36:57.293]                   }
[13:36:57.293]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.293]                     rootPath = tempdir()) 
[13:36:57.293]                   {
[13:36:57.293]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.293]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.293]                       tmpdir = path, fileext = ".rds")
[13:36:57.293]                     save_rds(obj, file)
[13:36:57.293]                   }
[13:36:57.293]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.293]                   {
[13:36:57.293]                     inherits <- base::inherits
[13:36:57.293]                     invokeRestart <- base::invokeRestart
[13:36:57.293]                     is.null <- base::is.null
[13:36:57.293]                     muffled <- FALSE
[13:36:57.293]                     if (inherits(cond, "message")) {
[13:36:57.293]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.293]                       if (muffled) 
[13:36:57.293]                         invokeRestart("muffleMessage")
[13:36:57.293]                     }
[13:36:57.293]                     else if (inherits(cond, "warning")) {
[13:36:57.293]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.293]                       if (muffled) 
[13:36:57.293]                         invokeRestart("muffleWarning")
[13:36:57.293]                     }
[13:36:57.293]                     else if (inherits(cond, "condition")) {
[13:36:57.293]                       if (!is.null(pattern)) {
[13:36:57.293]                         computeRestarts <- base::computeRestarts
[13:36:57.293]                         grepl <- base::grepl
[13:36:57.293]                         restarts <- computeRestarts(cond)
[13:36:57.293]                         for (restart in restarts) {
[13:36:57.293]                           name <- restart$name
[13:36:57.293]                           if (is.null(name)) 
[13:36:57.293]                             next
[13:36:57.293]                           if (!grepl(pattern, name)) 
[13:36:57.293]                             next
[13:36:57.293]                           invokeRestart(restart)
[13:36:57.293]                           muffled <- TRUE
[13:36:57.293]                           break
[13:36:57.293]                         }
[13:36:57.293]                       }
[13:36:57.293]                     }
[13:36:57.293]                     invisible(muffled)
[13:36:57.293]                   }
[13:36:57.293]                   muffleCondition(cond)
[13:36:57.293]                 })
[13:36:57.293]             }))
[13:36:57.293]             future::FutureResult(value = ...future.value$value, 
[13:36:57.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.293]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.293]                     ...future.globalenv.names))
[13:36:57.293]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.293]         }, condition = base::local({
[13:36:57.293]             c <- base::c
[13:36:57.293]             inherits <- base::inherits
[13:36:57.293]             invokeRestart <- base::invokeRestart
[13:36:57.293]             length <- base::length
[13:36:57.293]             list <- base::list
[13:36:57.293]             seq.int <- base::seq.int
[13:36:57.293]             signalCondition <- base::signalCondition
[13:36:57.293]             sys.calls <- base::sys.calls
[13:36:57.293]             `[[` <- base::`[[`
[13:36:57.293]             `+` <- base::`+`
[13:36:57.293]             `<<-` <- base::`<<-`
[13:36:57.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.293]                   3L)]
[13:36:57.293]             }
[13:36:57.293]             function(cond) {
[13:36:57.293]                 is_error <- inherits(cond, "error")
[13:36:57.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.293]                   NULL)
[13:36:57.293]                 if (is_error) {
[13:36:57.293]                   sessionInformation <- function() {
[13:36:57.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.293]                       search = base::search(), system = base::Sys.info())
[13:36:57.293]                   }
[13:36:57.293]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.293]                     cond$call), session = sessionInformation(), 
[13:36:57.293]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.293]                   signalCondition(cond)
[13:36:57.293]                 }
[13:36:57.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.293]                 "immediateCondition"))) {
[13:36:57.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.293]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.293]                   if (TRUE && !signal) {
[13:36:57.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.293]                     {
[13:36:57.293]                       inherits <- base::inherits
[13:36:57.293]                       invokeRestart <- base::invokeRestart
[13:36:57.293]                       is.null <- base::is.null
[13:36:57.293]                       muffled <- FALSE
[13:36:57.293]                       if (inherits(cond, "message")) {
[13:36:57.293]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.293]                         if (muffled) 
[13:36:57.293]                           invokeRestart("muffleMessage")
[13:36:57.293]                       }
[13:36:57.293]                       else if (inherits(cond, "warning")) {
[13:36:57.293]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.293]                         if (muffled) 
[13:36:57.293]                           invokeRestart("muffleWarning")
[13:36:57.293]                       }
[13:36:57.293]                       else if (inherits(cond, "condition")) {
[13:36:57.293]                         if (!is.null(pattern)) {
[13:36:57.293]                           computeRestarts <- base::computeRestarts
[13:36:57.293]                           grepl <- base::grepl
[13:36:57.293]                           restarts <- computeRestarts(cond)
[13:36:57.293]                           for (restart in restarts) {
[13:36:57.293]                             name <- restart$name
[13:36:57.293]                             if (is.null(name)) 
[13:36:57.293]                               next
[13:36:57.293]                             if (!grepl(pattern, name)) 
[13:36:57.293]                               next
[13:36:57.293]                             invokeRestart(restart)
[13:36:57.293]                             muffled <- TRUE
[13:36:57.293]                             break
[13:36:57.293]                           }
[13:36:57.293]                         }
[13:36:57.293]                       }
[13:36:57.293]                       invisible(muffled)
[13:36:57.293]                     }
[13:36:57.293]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.293]                   }
[13:36:57.293]                 }
[13:36:57.293]                 else {
[13:36:57.293]                   if (TRUE) {
[13:36:57.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.293]                     {
[13:36:57.293]                       inherits <- base::inherits
[13:36:57.293]                       invokeRestart <- base::invokeRestart
[13:36:57.293]                       is.null <- base::is.null
[13:36:57.293]                       muffled <- FALSE
[13:36:57.293]                       if (inherits(cond, "message")) {
[13:36:57.293]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.293]                         if (muffled) 
[13:36:57.293]                           invokeRestart("muffleMessage")
[13:36:57.293]                       }
[13:36:57.293]                       else if (inherits(cond, "warning")) {
[13:36:57.293]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.293]                         if (muffled) 
[13:36:57.293]                           invokeRestart("muffleWarning")
[13:36:57.293]                       }
[13:36:57.293]                       else if (inherits(cond, "condition")) {
[13:36:57.293]                         if (!is.null(pattern)) {
[13:36:57.293]                           computeRestarts <- base::computeRestarts
[13:36:57.293]                           grepl <- base::grepl
[13:36:57.293]                           restarts <- computeRestarts(cond)
[13:36:57.293]                           for (restart in restarts) {
[13:36:57.293]                             name <- restart$name
[13:36:57.293]                             if (is.null(name)) 
[13:36:57.293]                               next
[13:36:57.293]                             if (!grepl(pattern, name)) 
[13:36:57.293]                               next
[13:36:57.293]                             invokeRestart(restart)
[13:36:57.293]                             muffled <- TRUE
[13:36:57.293]                             break
[13:36:57.293]                           }
[13:36:57.293]                         }
[13:36:57.293]                       }
[13:36:57.293]                       invisible(muffled)
[13:36:57.293]                     }
[13:36:57.293]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.293]                   }
[13:36:57.293]                 }
[13:36:57.293]             }
[13:36:57.293]         }))
[13:36:57.293]     }, error = function(ex) {
[13:36:57.293]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.293]                 ...future.rng), started = ...future.startTime, 
[13:36:57.293]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.293]             version = "1.8"), class = "FutureResult")
[13:36:57.293]     }, finally = {
[13:36:57.293]         if (!identical(...future.workdir, getwd())) 
[13:36:57.293]             setwd(...future.workdir)
[13:36:57.293]         {
[13:36:57.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.293]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.293]             }
[13:36:57.293]             base::options(...future.oldOptions)
[13:36:57.293]             if (.Platform$OS.type == "windows") {
[13:36:57.293]                 old_names <- names(...future.oldEnvVars)
[13:36:57.293]                 envs <- base::Sys.getenv()
[13:36:57.293]                 names <- names(envs)
[13:36:57.293]                 common <- intersect(names, old_names)
[13:36:57.293]                 added <- setdiff(names, old_names)
[13:36:57.293]                 removed <- setdiff(old_names, names)
[13:36:57.293]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.293]                   envs[common]]
[13:36:57.293]                 NAMES <- toupper(changed)
[13:36:57.293]                 args <- list()
[13:36:57.293]                 for (kk in seq_along(NAMES)) {
[13:36:57.293]                   name <- changed[[kk]]
[13:36:57.293]                   NAME <- NAMES[[kk]]
[13:36:57.293]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.293]                     next
[13:36:57.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.293]                 }
[13:36:57.293]                 NAMES <- toupper(added)
[13:36:57.293]                 for (kk in seq_along(NAMES)) {
[13:36:57.293]                   name <- added[[kk]]
[13:36:57.293]                   NAME <- NAMES[[kk]]
[13:36:57.293]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.293]                     next
[13:36:57.293]                   args[[name]] <- ""
[13:36:57.293]                 }
[13:36:57.293]                 NAMES <- toupper(removed)
[13:36:57.293]                 for (kk in seq_along(NAMES)) {
[13:36:57.293]                   name <- removed[[kk]]
[13:36:57.293]                   NAME <- NAMES[[kk]]
[13:36:57.293]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.293]                     next
[13:36:57.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.293]                 }
[13:36:57.293]                 if (length(args) > 0) 
[13:36:57.293]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.293]             }
[13:36:57.293]             else {
[13:36:57.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.293]             }
[13:36:57.293]             {
[13:36:57.293]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.293]                   0L) {
[13:36:57.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.293]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.293]                   base::options(opts)
[13:36:57.293]                 }
[13:36:57.293]                 {
[13:36:57.293]                   {
[13:36:57.293]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.293]                     NULL
[13:36:57.293]                   }
[13:36:57.293]                   options(future.plan = NULL)
[13:36:57.293]                   if (is.na(NA_character_)) 
[13:36:57.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.293]                     .init = FALSE)
[13:36:57.293]                 }
[13:36:57.293]             }
[13:36:57.293]         }
[13:36:57.293]     })
[13:36:57.293]     if (TRUE) {
[13:36:57.293]         base::sink(type = "output", split = FALSE)
[13:36:57.293]         if (TRUE) {
[13:36:57.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.293]         }
[13:36:57.293]         else {
[13:36:57.293]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.293]         }
[13:36:57.293]         base::close(...future.stdout)
[13:36:57.293]         ...future.stdout <- NULL
[13:36:57.293]     }
[13:36:57.293]     ...future.result$conditions <- ...future.conditions
[13:36:57.293]     ...future.result$finished <- base::Sys.time()
[13:36:57.293]     ...future.result
[13:36:57.293] }
[13:36:57.295] assign_globals() ...
[13:36:57.295] List of 1
[13:36:57.295]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c6dc737468> 
[13:36:57.295]  - attr(*, "where")=List of 1
[13:36:57.295]   ..$ a:<environment: R_EmptyEnv> 
[13:36:57.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.295]  - attr(*, "resolved")= logi TRUE
[13:36:57.295]  - attr(*, "total_size")= num 1647008
[13:36:57.295]  - attr(*, "already-done")= logi TRUE
[13:36:57.298] - copied ‘a’ to environment
[13:36:57.298] assign_globals() ... done
[13:36:57.298] requestCore(): workers = 2
[13:36:57.300] MulticoreFuture started
[13:36:57.300] - Launch lazy future ... done
[13:36:57.301] run() for ‘MulticoreFuture’ ... done
[13:36:57.301] result() for MulticoreFuture ...
[13:36:57.302] plan(): Setting new future strategy stack:
[13:36:57.302] List of future strategies:
[13:36:57.302] 1. sequential:
[13:36:57.302]    - args: function (..., envir = parent.frame())
[13:36:57.302]    - tweaked: FALSE
[13:36:57.302]    - call: NULL
[13:36:57.303] plan(): nbrOfWorkers() = 1
[13:36:57.306] plan(): Setting new future strategy stack:
[13:36:57.306] List of future strategies:
[13:36:57.306] 1. multicore:
[13:36:57.306]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.306]    - tweaked: FALSE
[13:36:57.306]    - call: plan(strategy)
[13:36:57.312] plan(): nbrOfWorkers() = 2
[13:36:57.312] result() for MulticoreFuture ...
[13:36:57.313] result() for MulticoreFuture ... done
[13:36:57.313] signalConditions() ...
[13:36:57.313]  - include = ‘immediateCondition’
[13:36:57.313]  - exclude = 
[13:36:57.313]  - resignal = FALSE
[13:36:57.313]  - Number of conditions: 4
[13:36:57.313] signalConditions() ... done
[13:36:57.314] result() for MulticoreFuture ... done
[13:36:57.314] result() for MulticoreFuture ...
[13:36:57.314] result() for MulticoreFuture ... done
[13:36:57.314] signalConditions() ...
[13:36:57.314]  - include = ‘immediateCondition’
[13:36:57.314]  - exclude = 
[13:36:57.314]  - resignal = FALSE
[13:36:57.314]  - Number of conditions: 4
[13:36:57.315] signalConditions() ... done
[13:36:57.315] Future state: ‘finished’
[13:36:57.315] result() for MulticoreFuture ...
[13:36:57.315] result() for MulticoreFuture ... done
[13:36:57.315] signalConditions() ...
[13:36:57.315]  - include = ‘condition’
[13:36:57.315]  - exclude = ‘immediateCondition’
[13:36:57.315]  - resignal = TRUE
[13:36:57.316]  - Number of conditions: 4
[13:36:57.316]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.304] result() for MulticoreFuture ...
[13:36:57.316]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.304] result() for MulticoreFuture ... done
[13:36:57.316]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.305] result() for MulticoreFuture ...
[13:36:57.316]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.305] result() for MulticoreFuture ... done
[13:36:57.316] signalConditions() ... done
value(b) = 2
[13:36:57.317] result() for MulticoreFuture ...
[13:36:57.317] result() for MulticoreFuture ... done
[13:36:57.317] result() for MulticoreFuture ...
[13:36:57.317] result() for MulticoreFuture ... done
[13:36:57.317] signalConditions() ...
[13:36:57.317]  - include = ‘immediateCondition’
[13:36:57.317]  - exclude = 
[13:36:57.317]  - resignal = FALSE
[13:36:57.317]  - Number of conditions: 4
[13:36:57.318] signalConditions() ... done
[13:36:57.318] Future state: ‘finished’
[13:36:57.318] result() for MulticoreFuture ...
[13:36:57.318] result() for MulticoreFuture ... done
[13:36:57.318] signalConditions() ...
[13:36:57.318]  - include = ‘condition’
[13:36:57.318]  - exclude = ‘immediateCondition’
[13:36:57.318]  - resignal = TRUE
[13:36:57.319]  - Number of conditions: 4
[13:36:57.319]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.304] result() for MulticoreFuture ...
[13:36:57.319]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.304] result() for MulticoreFuture ... done
[13:36:57.319]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.305] result() for MulticoreFuture ...
[13:36:57.319]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.305] result() for MulticoreFuture ... done
[13:36:57.319] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.320] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.320] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.323] 
[13:36:57.324] Searching for globals ... DONE
[13:36:57.324] - globals: [0] <none>
[13:36:57.324] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.325] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.325] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.326] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:57.326] Searching for globals ... DONE
[13:36:57.326] Resolving globals: TRUE
[13:36:57.326] Resolving any globals that are futures ...
[13:36:57.327] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:57.327] Resolving any globals that are futures ... DONE
[13:36:57.327] Resolving futures part of globals (recursively) ...
[13:36:57.327] resolve() on list ...
[13:36:57.328]  recursive: 99
[13:36:57.328]  length: 1
[13:36:57.328]  elements: ‘a’
[13:36:57.328] run() for ‘Future’ ...
[13:36:57.328] - state: ‘created’
[13:36:57.328] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.332] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.333]   - Field: ‘label’
[13:36:57.333]   - Field: ‘local’
[13:36:57.333]   - Field: ‘owner’
[13:36:57.333]   - Field: ‘envir’
[13:36:57.333]   - Field: ‘workers’
[13:36:57.334]   - Field: ‘packages’
[13:36:57.334]   - Field: ‘gc’
[13:36:57.334]   - Field: ‘job’
[13:36:57.334]   - Field: ‘conditions’
[13:36:57.334]   - Field: ‘expr’
[13:36:57.334]   - Field: ‘uuid’
[13:36:57.334]   - Field: ‘seed’
[13:36:57.334]   - Field: ‘version’
[13:36:57.335]   - Field: ‘result’
[13:36:57.335]   - Field: ‘asynchronous’
[13:36:57.335]   - Field: ‘calls’
[13:36:57.335]   - Field: ‘globals’
[13:36:57.335]   - Field: ‘stdout’
[13:36:57.335]   - Field: ‘earlySignal’
[13:36:57.335]   - Field: ‘lazy’
[13:36:57.335]   - Field: ‘state’
[13:36:57.335] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.336] - Launch lazy future ...
[13:36:57.336] Packages needed by the future expression (n = 0): <none>
[13:36:57.336] Packages needed by future strategies (n = 0): <none>
[13:36:57.337] {
[13:36:57.337]     {
[13:36:57.337]         {
[13:36:57.337]             ...future.startTime <- base::Sys.time()
[13:36:57.337]             {
[13:36:57.337]                 {
[13:36:57.337]                   {
[13:36:57.337]                     {
[13:36:57.337]                       base::local({
[13:36:57.337]                         has_future <- base::requireNamespace("future", 
[13:36:57.337]                           quietly = TRUE)
[13:36:57.337]                         if (has_future) {
[13:36:57.337]                           ns <- base::getNamespace("future")
[13:36:57.337]                           version <- ns[[".package"]][["version"]]
[13:36:57.337]                           if (is.null(version)) 
[13:36:57.337]                             version <- utils::packageVersion("future")
[13:36:57.337]                         }
[13:36:57.337]                         else {
[13:36:57.337]                           version <- NULL
[13:36:57.337]                         }
[13:36:57.337]                         if (!has_future || version < "1.8.0") {
[13:36:57.337]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.337]                             "", base::R.version$version.string), 
[13:36:57.337]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.337]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.337]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.337]                               "release", "version")], collapse = " "), 
[13:36:57.337]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.337]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.337]                             info)
[13:36:57.337]                           info <- base::paste(info, collapse = "; ")
[13:36:57.337]                           if (!has_future) {
[13:36:57.337]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.337]                               info)
[13:36:57.337]                           }
[13:36:57.337]                           else {
[13:36:57.337]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.337]                               info, version)
[13:36:57.337]                           }
[13:36:57.337]                           base::stop(msg)
[13:36:57.337]                         }
[13:36:57.337]                       })
[13:36:57.337]                     }
[13:36:57.337]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.337]                     base::options(mc.cores = 1L)
[13:36:57.337]                   }
[13:36:57.337]                   ...future.strategy.old <- future::plan("list")
[13:36:57.337]                   options(future.plan = NULL)
[13:36:57.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.337]                 }
[13:36:57.337]                 ...future.workdir <- getwd()
[13:36:57.337]             }
[13:36:57.337]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.337]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.337]         }
[13:36:57.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.337]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.337]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.337]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.337]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.337]             base::names(...future.oldOptions))
[13:36:57.337]     }
[13:36:57.337]     if (FALSE) {
[13:36:57.337]     }
[13:36:57.337]     else {
[13:36:57.337]         if (TRUE) {
[13:36:57.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.337]                 open = "w")
[13:36:57.337]         }
[13:36:57.337]         else {
[13:36:57.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.337]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.337]         }
[13:36:57.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.337]             base::sink(type = "output", split = FALSE)
[13:36:57.337]             base::close(...future.stdout)
[13:36:57.337]         }, add = TRUE)
[13:36:57.337]     }
[13:36:57.337]     ...future.frame <- base::sys.nframe()
[13:36:57.337]     ...future.conditions <- base::list()
[13:36:57.337]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.337]     if (FALSE) {
[13:36:57.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.337]     }
[13:36:57.337]     ...future.result <- base::tryCatch({
[13:36:57.337]         base::withCallingHandlers({
[13:36:57.337]             ...future.value <- base::withVisible(base::local({
[13:36:57.337]                 withCallingHandlers({
[13:36:57.337]                   1
[13:36:57.337]                 }, immediateCondition = function(cond) {
[13:36:57.337]                   save_rds <- function (object, pathname, ...) 
[13:36:57.337]                   {
[13:36:57.337]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.337]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.337]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.337]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.337]                         fi_tmp[["mtime"]])
[13:36:57.337]                     }
[13:36:57.337]                     tryCatch({
[13:36:57.337]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.337]                     }, error = function(ex) {
[13:36:57.337]                       msg <- conditionMessage(ex)
[13:36:57.337]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.337]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.337]                         fi_tmp[["mtime"]], msg)
[13:36:57.337]                       ex$message <- msg
[13:36:57.337]                       stop(ex)
[13:36:57.337]                     })
[13:36:57.337]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.337]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.337]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.337]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.337]                       fi <- file.info(pathname)
[13:36:57.337]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.337]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.337]                         fi[["size"]], fi[["mtime"]])
[13:36:57.337]                       stop(msg)
[13:36:57.337]                     }
[13:36:57.337]                     invisible(pathname)
[13:36:57.337]                   }
[13:36:57.337]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.337]                     rootPath = tempdir()) 
[13:36:57.337]                   {
[13:36:57.337]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.337]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.337]                       tmpdir = path, fileext = ".rds")
[13:36:57.337]                     save_rds(obj, file)
[13:36:57.337]                   }
[13:36:57.337]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.337]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.337]                   {
[13:36:57.337]                     inherits <- base::inherits
[13:36:57.337]                     invokeRestart <- base::invokeRestart
[13:36:57.337]                     is.null <- base::is.null
[13:36:57.337]                     muffled <- FALSE
[13:36:57.337]                     if (inherits(cond, "message")) {
[13:36:57.337]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.337]                       if (muffled) 
[13:36:57.337]                         invokeRestart("muffleMessage")
[13:36:57.337]                     }
[13:36:57.337]                     else if (inherits(cond, "warning")) {
[13:36:57.337]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.337]                       if (muffled) 
[13:36:57.337]                         invokeRestart("muffleWarning")
[13:36:57.337]                     }
[13:36:57.337]                     else if (inherits(cond, "condition")) {
[13:36:57.337]                       if (!is.null(pattern)) {
[13:36:57.337]                         computeRestarts <- base::computeRestarts
[13:36:57.337]                         grepl <- base::grepl
[13:36:57.337]                         restarts <- computeRestarts(cond)
[13:36:57.337]                         for (restart in restarts) {
[13:36:57.337]                           name <- restart$name
[13:36:57.337]                           if (is.null(name)) 
[13:36:57.337]                             next
[13:36:57.337]                           if (!grepl(pattern, name)) 
[13:36:57.337]                             next
[13:36:57.337]                           invokeRestart(restart)
[13:36:57.337]                           muffled <- TRUE
[13:36:57.337]                           break
[13:36:57.337]                         }
[13:36:57.337]                       }
[13:36:57.337]                     }
[13:36:57.337]                     invisible(muffled)
[13:36:57.337]                   }
[13:36:57.337]                   muffleCondition(cond)
[13:36:57.337]                 })
[13:36:57.337]             }))
[13:36:57.337]             future::FutureResult(value = ...future.value$value, 
[13:36:57.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.337]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.337]                     ...future.globalenv.names))
[13:36:57.337]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.337]         }, condition = base::local({
[13:36:57.337]             c <- base::c
[13:36:57.337]             inherits <- base::inherits
[13:36:57.337]             invokeRestart <- base::invokeRestart
[13:36:57.337]             length <- base::length
[13:36:57.337]             list <- base::list
[13:36:57.337]             seq.int <- base::seq.int
[13:36:57.337]             signalCondition <- base::signalCondition
[13:36:57.337]             sys.calls <- base::sys.calls
[13:36:57.337]             `[[` <- base::`[[`
[13:36:57.337]             `+` <- base::`+`
[13:36:57.337]             `<<-` <- base::`<<-`
[13:36:57.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.337]                   3L)]
[13:36:57.337]             }
[13:36:57.337]             function(cond) {
[13:36:57.337]                 is_error <- inherits(cond, "error")
[13:36:57.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.337]                   NULL)
[13:36:57.337]                 if (is_error) {
[13:36:57.337]                   sessionInformation <- function() {
[13:36:57.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.337]                       search = base::search(), system = base::Sys.info())
[13:36:57.337]                   }
[13:36:57.337]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.337]                     cond$call), session = sessionInformation(), 
[13:36:57.337]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.337]                   signalCondition(cond)
[13:36:57.337]                 }
[13:36:57.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.337]                 "immediateCondition"))) {
[13:36:57.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.337]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.337]                   if (TRUE && !signal) {
[13:36:57.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.337]                     {
[13:36:57.337]                       inherits <- base::inherits
[13:36:57.337]                       invokeRestart <- base::invokeRestart
[13:36:57.337]                       is.null <- base::is.null
[13:36:57.337]                       muffled <- FALSE
[13:36:57.337]                       if (inherits(cond, "message")) {
[13:36:57.337]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.337]                         if (muffled) 
[13:36:57.337]                           invokeRestart("muffleMessage")
[13:36:57.337]                       }
[13:36:57.337]                       else if (inherits(cond, "warning")) {
[13:36:57.337]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.337]                         if (muffled) 
[13:36:57.337]                           invokeRestart("muffleWarning")
[13:36:57.337]                       }
[13:36:57.337]                       else if (inherits(cond, "condition")) {
[13:36:57.337]                         if (!is.null(pattern)) {
[13:36:57.337]                           computeRestarts <- base::computeRestarts
[13:36:57.337]                           grepl <- base::grepl
[13:36:57.337]                           restarts <- computeRestarts(cond)
[13:36:57.337]                           for (restart in restarts) {
[13:36:57.337]                             name <- restart$name
[13:36:57.337]                             if (is.null(name)) 
[13:36:57.337]                               next
[13:36:57.337]                             if (!grepl(pattern, name)) 
[13:36:57.337]                               next
[13:36:57.337]                             invokeRestart(restart)
[13:36:57.337]                             muffled <- TRUE
[13:36:57.337]                             break
[13:36:57.337]                           }
[13:36:57.337]                         }
[13:36:57.337]                       }
[13:36:57.337]                       invisible(muffled)
[13:36:57.337]                     }
[13:36:57.337]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.337]                   }
[13:36:57.337]                 }
[13:36:57.337]                 else {
[13:36:57.337]                   if (TRUE) {
[13:36:57.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.337]                     {
[13:36:57.337]                       inherits <- base::inherits
[13:36:57.337]                       invokeRestart <- base::invokeRestart
[13:36:57.337]                       is.null <- base::is.null
[13:36:57.337]                       muffled <- FALSE
[13:36:57.337]                       if (inherits(cond, "message")) {
[13:36:57.337]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.337]                         if (muffled) 
[13:36:57.337]                           invokeRestart("muffleMessage")
[13:36:57.337]                       }
[13:36:57.337]                       else if (inherits(cond, "warning")) {
[13:36:57.337]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.337]                         if (muffled) 
[13:36:57.337]                           invokeRestart("muffleWarning")
[13:36:57.337]                       }
[13:36:57.337]                       else if (inherits(cond, "condition")) {
[13:36:57.337]                         if (!is.null(pattern)) {
[13:36:57.337]                           computeRestarts <- base::computeRestarts
[13:36:57.337]                           grepl <- base::grepl
[13:36:57.337]                           restarts <- computeRestarts(cond)
[13:36:57.337]                           for (restart in restarts) {
[13:36:57.337]                             name <- restart$name
[13:36:57.337]                             if (is.null(name)) 
[13:36:57.337]                               next
[13:36:57.337]                             if (!grepl(pattern, name)) 
[13:36:57.337]                               next
[13:36:57.337]                             invokeRestart(restart)
[13:36:57.337]                             muffled <- TRUE
[13:36:57.337]                             break
[13:36:57.337]                           }
[13:36:57.337]                         }
[13:36:57.337]                       }
[13:36:57.337]                       invisible(muffled)
[13:36:57.337]                     }
[13:36:57.337]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.337]                   }
[13:36:57.337]                 }
[13:36:57.337]             }
[13:36:57.337]         }))
[13:36:57.337]     }, error = function(ex) {
[13:36:57.337]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.337]                 ...future.rng), started = ...future.startTime, 
[13:36:57.337]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.337]             version = "1.8"), class = "FutureResult")
[13:36:57.337]     }, finally = {
[13:36:57.337]         if (!identical(...future.workdir, getwd())) 
[13:36:57.337]             setwd(...future.workdir)
[13:36:57.337]         {
[13:36:57.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.337]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.337]             }
[13:36:57.337]             base::options(...future.oldOptions)
[13:36:57.337]             if (.Platform$OS.type == "windows") {
[13:36:57.337]                 old_names <- names(...future.oldEnvVars)
[13:36:57.337]                 envs <- base::Sys.getenv()
[13:36:57.337]                 names <- names(envs)
[13:36:57.337]                 common <- intersect(names, old_names)
[13:36:57.337]                 added <- setdiff(names, old_names)
[13:36:57.337]                 removed <- setdiff(old_names, names)
[13:36:57.337]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.337]                   envs[common]]
[13:36:57.337]                 NAMES <- toupper(changed)
[13:36:57.337]                 args <- list()
[13:36:57.337]                 for (kk in seq_along(NAMES)) {
[13:36:57.337]                   name <- changed[[kk]]
[13:36:57.337]                   NAME <- NAMES[[kk]]
[13:36:57.337]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.337]                     next
[13:36:57.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.337]                 }
[13:36:57.337]                 NAMES <- toupper(added)
[13:36:57.337]                 for (kk in seq_along(NAMES)) {
[13:36:57.337]                   name <- added[[kk]]
[13:36:57.337]                   NAME <- NAMES[[kk]]
[13:36:57.337]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.337]                     next
[13:36:57.337]                   args[[name]] <- ""
[13:36:57.337]                 }
[13:36:57.337]                 NAMES <- toupper(removed)
[13:36:57.337]                 for (kk in seq_along(NAMES)) {
[13:36:57.337]                   name <- removed[[kk]]
[13:36:57.337]                   NAME <- NAMES[[kk]]
[13:36:57.337]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.337]                     next
[13:36:57.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.337]                 }
[13:36:57.337]                 if (length(args) > 0) 
[13:36:57.337]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.337]             }
[13:36:57.337]             else {
[13:36:57.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.337]             }
[13:36:57.337]             {
[13:36:57.337]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.337]                   0L) {
[13:36:57.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.337]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.337]                   base::options(opts)
[13:36:57.337]                 }
[13:36:57.337]                 {
[13:36:57.337]                   {
[13:36:57.337]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.337]                     NULL
[13:36:57.337]                   }
[13:36:57.337]                   options(future.plan = NULL)
[13:36:57.337]                   if (is.na(NA_character_)) 
[13:36:57.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.337]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.337]                     .init = FALSE)
[13:36:57.337]                 }
[13:36:57.337]             }
[13:36:57.337]         }
[13:36:57.337]     })
[13:36:57.337]     if (TRUE) {
[13:36:57.337]         base::sink(type = "output", split = FALSE)
[13:36:57.337]         if (TRUE) {
[13:36:57.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.337]         }
[13:36:57.337]         else {
[13:36:57.337]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.337]         }
[13:36:57.337]         base::close(...future.stdout)
[13:36:57.337]         ...future.stdout <- NULL
[13:36:57.337]     }
[13:36:57.337]     ...future.result$conditions <- ...future.conditions
[13:36:57.337]     ...future.result$finished <- base::Sys.time()
[13:36:57.337]     ...future.result
[13:36:57.337] }
[13:36:57.339] requestCore(): workers = 2
[13:36:57.341] MulticoreFuture started
[13:36:57.341] - Launch lazy future ... done
[13:36:57.342] run() for ‘MulticoreFuture’ ... done
[13:36:57.342] plan(): Setting new future strategy stack:
[13:36:57.342] List of future strategies:
[13:36:57.342] 1. sequential:
[13:36:57.342]    - args: function (..., envir = parent.frame())
[13:36:57.342]    - tweaked: FALSE
[13:36:57.342]    - call: NULL
[13:36:57.343] plan(): nbrOfWorkers() = 1
[13:36:57.346] plan(): Setting new future strategy stack:
[13:36:57.346] List of future strategies:
[13:36:57.346] 1. multicore:
[13:36:57.346]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.346]    - tweaked: FALSE
[13:36:57.346]    - call: plan(strategy)
[13:36:57.351] plan(): nbrOfWorkers() = 2
[13:36:57.352] Future #1
[13:36:57.352] result() for MulticoreFuture ...
[13:36:57.353] result() for MulticoreFuture ...
[13:36:57.353] result() for MulticoreFuture ... done
[13:36:57.353] result() for MulticoreFuture ... done
[13:36:57.353] result() for MulticoreFuture ...
[13:36:57.353] result() for MulticoreFuture ... done
[13:36:57.354] A MulticoreFuture was resolved
[13:36:57.354]  length: 0 (resolved future 1)
[13:36:57.354] resolve() on list ... DONE
[13:36:57.354] - globals: [1] ‘a’
[13:36:57.354] Resolving futures part of globals (recursively) ... DONE
[13:36:57.357] The total size of the 1 globals is 1.57 MiB (1647176 bytes)
[13:36:57.358] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:36:57.358] - globals: [1] ‘a’
[13:36:57.358] - packages: [1] ‘future’
[13:36:57.358] getGlobalsAndPackages() ... DONE
[13:36:57.358] run() for ‘Future’ ...
[13:36:57.359] - state: ‘created’
[13:36:57.359] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.363]   - Field: ‘label’
[13:36:57.363]   - Field: ‘local’
[13:36:57.363]   - Field: ‘owner’
[13:36:57.363]   - Field: ‘envir’
[13:36:57.364]   - Field: ‘workers’
[13:36:57.364]   - Field: ‘packages’
[13:36:57.364]   - Field: ‘gc’
[13:36:57.364]   - Field: ‘job’
[13:36:57.364]   - Field: ‘conditions’
[13:36:57.364]   - Field: ‘expr’
[13:36:57.364]   - Field: ‘uuid’
[13:36:57.364]   - Field: ‘seed’
[13:36:57.365]   - Field: ‘version’
[13:36:57.365]   - Field: ‘result’
[13:36:57.365]   - Field: ‘asynchronous’
[13:36:57.365]   - Field: ‘calls’
[13:36:57.365]   - Field: ‘globals’
[13:36:57.365]   - Field: ‘stdout’
[13:36:57.365]   - Field: ‘earlySignal’
[13:36:57.365]   - Field: ‘lazy’
[13:36:57.365]   - Field: ‘state’
[13:36:57.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.366] - Launch lazy future ...
[13:36:57.366] Packages needed by the future expression (n = 1): ‘future’
[13:36:57.366] Packages needed by future strategies (n = 0): <none>
[13:36:57.367] {
[13:36:57.367]     {
[13:36:57.367]         {
[13:36:57.367]             ...future.startTime <- base::Sys.time()
[13:36:57.367]             {
[13:36:57.367]                 {
[13:36:57.367]                   {
[13:36:57.367]                     {
[13:36:57.367]                       {
[13:36:57.367]                         base::local({
[13:36:57.367]                           has_future <- base::requireNamespace("future", 
[13:36:57.367]                             quietly = TRUE)
[13:36:57.367]                           if (has_future) {
[13:36:57.367]                             ns <- base::getNamespace("future")
[13:36:57.367]                             version <- ns[[".package"]][["version"]]
[13:36:57.367]                             if (is.null(version)) 
[13:36:57.367]                               version <- utils::packageVersion("future")
[13:36:57.367]                           }
[13:36:57.367]                           else {
[13:36:57.367]                             version <- NULL
[13:36:57.367]                           }
[13:36:57.367]                           if (!has_future || version < "1.8.0") {
[13:36:57.367]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.367]                               "", base::R.version$version.string), 
[13:36:57.367]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:57.367]                                 base::R.version$platform, 8 * 
[13:36:57.367]                                   base::.Machine$sizeof.pointer), 
[13:36:57.367]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.367]                                 "release", "version")], collapse = " "), 
[13:36:57.367]                               hostname = base::Sys.info()[["nodename"]])
[13:36:57.367]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.367]                               info)
[13:36:57.367]                             info <- base::paste(info, collapse = "; ")
[13:36:57.367]                             if (!has_future) {
[13:36:57.367]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.367]                                 info)
[13:36:57.367]                             }
[13:36:57.367]                             else {
[13:36:57.367]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.367]                                 info, version)
[13:36:57.367]                             }
[13:36:57.367]                             base::stop(msg)
[13:36:57.367]                           }
[13:36:57.367]                         })
[13:36:57.367]                       }
[13:36:57.367]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.367]                       base::options(mc.cores = 1L)
[13:36:57.367]                     }
[13:36:57.367]                     base::local({
[13:36:57.367]                       for (pkg in "future") {
[13:36:57.367]                         base::loadNamespace(pkg)
[13:36:57.367]                         base::library(pkg, character.only = TRUE)
[13:36:57.367]                       }
[13:36:57.367]                     })
[13:36:57.367]                   }
[13:36:57.367]                   ...future.strategy.old <- future::plan("list")
[13:36:57.367]                   options(future.plan = NULL)
[13:36:57.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.367]                 }
[13:36:57.367]                 ...future.workdir <- getwd()
[13:36:57.367]             }
[13:36:57.367]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.367]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.367]         }
[13:36:57.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.367]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.367]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.367]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.367]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.367]             base::names(...future.oldOptions))
[13:36:57.367]     }
[13:36:57.367]     if (FALSE) {
[13:36:57.367]     }
[13:36:57.367]     else {
[13:36:57.367]         if (TRUE) {
[13:36:57.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.367]                 open = "w")
[13:36:57.367]         }
[13:36:57.367]         else {
[13:36:57.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.367]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.367]         }
[13:36:57.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.367]             base::sink(type = "output", split = FALSE)
[13:36:57.367]             base::close(...future.stdout)
[13:36:57.367]         }, add = TRUE)
[13:36:57.367]     }
[13:36:57.367]     ...future.frame <- base::sys.nframe()
[13:36:57.367]     ...future.conditions <- base::list()
[13:36:57.367]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.367]     if (FALSE) {
[13:36:57.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.367]     }
[13:36:57.367]     ...future.result <- base::tryCatch({
[13:36:57.367]         base::withCallingHandlers({
[13:36:57.367]             ...future.value <- base::withVisible(base::local({
[13:36:57.367]                 withCallingHandlers({
[13:36:57.367]                   value(a) + 1
[13:36:57.367]                 }, immediateCondition = function(cond) {
[13:36:57.367]                   save_rds <- function (object, pathname, ...) 
[13:36:57.367]                   {
[13:36:57.367]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.367]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.367]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.367]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.367]                         fi_tmp[["mtime"]])
[13:36:57.367]                     }
[13:36:57.367]                     tryCatch({
[13:36:57.367]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.367]                     }, error = function(ex) {
[13:36:57.367]                       msg <- conditionMessage(ex)
[13:36:57.367]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.367]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.367]                         fi_tmp[["mtime"]], msg)
[13:36:57.367]                       ex$message <- msg
[13:36:57.367]                       stop(ex)
[13:36:57.367]                     })
[13:36:57.367]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.367]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.367]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.367]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.367]                       fi <- file.info(pathname)
[13:36:57.367]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.367]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.367]                         fi[["size"]], fi[["mtime"]])
[13:36:57.367]                       stop(msg)
[13:36:57.367]                     }
[13:36:57.367]                     invisible(pathname)
[13:36:57.367]                   }
[13:36:57.367]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.367]                     rootPath = tempdir()) 
[13:36:57.367]                   {
[13:36:57.367]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.367]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.367]                       tmpdir = path, fileext = ".rds")
[13:36:57.367]                     save_rds(obj, file)
[13:36:57.367]                   }
[13:36:57.367]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.367]                   {
[13:36:57.367]                     inherits <- base::inherits
[13:36:57.367]                     invokeRestart <- base::invokeRestart
[13:36:57.367]                     is.null <- base::is.null
[13:36:57.367]                     muffled <- FALSE
[13:36:57.367]                     if (inherits(cond, "message")) {
[13:36:57.367]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.367]                       if (muffled) 
[13:36:57.367]                         invokeRestart("muffleMessage")
[13:36:57.367]                     }
[13:36:57.367]                     else if (inherits(cond, "warning")) {
[13:36:57.367]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.367]                       if (muffled) 
[13:36:57.367]                         invokeRestart("muffleWarning")
[13:36:57.367]                     }
[13:36:57.367]                     else if (inherits(cond, "condition")) {
[13:36:57.367]                       if (!is.null(pattern)) {
[13:36:57.367]                         computeRestarts <- base::computeRestarts
[13:36:57.367]                         grepl <- base::grepl
[13:36:57.367]                         restarts <- computeRestarts(cond)
[13:36:57.367]                         for (restart in restarts) {
[13:36:57.367]                           name <- restart$name
[13:36:57.367]                           if (is.null(name)) 
[13:36:57.367]                             next
[13:36:57.367]                           if (!grepl(pattern, name)) 
[13:36:57.367]                             next
[13:36:57.367]                           invokeRestart(restart)
[13:36:57.367]                           muffled <- TRUE
[13:36:57.367]                           break
[13:36:57.367]                         }
[13:36:57.367]                       }
[13:36:57.367]                     }
[13:36:57.367]                     invisible(muffled)
[13:36:57.367]                   }
[13:36:57.367]                   muffleCondition(cond)
[13:36:57.367]                 })
[13:36:57.367]             }))
[13:36:57.367]             future::FutureResult(value = ...future.value$value, 
[13:36:57.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.367]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.367]                     ...future.globalenv.names))
[13:36:57.367]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.367]         }, condition = base::local({
[13:36:57.367]             c <- base::c
[13:36:57.367]             inherits <- base::inherits
[13:36:57.367]             invokeRestart <- base::invokeRestart
[13:36:57.367]             length <- base::length
[13:36:57.367]             list <- base::list
[13:36:57.367]             seq.int <- base::seq.int
[13:36:57.367]             signalCondition <- base::signalCondition
[13:36:57.367]             sys.calls <- base::sys.calls
[13:36:57.367]             `[[` <- base::`[[`
[13:36:57.367]             `+` <- base::`+`
[13:36:57.367]             `<<-` <- base::`<<-`
[13:36:57.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.367]                   3L)]
[13:36:57.367]             }
[13:36:57.367]             function(cond) {
[13:36:57.367]                 is_error <- inherits(cond, "error")
[13:36:57.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.367]                   NULL)
[13:36:57.367]                 if (is_error) {
[13:36:57.367]                   sessionInformation <- function() {
[13:36:57.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.367]                       search = base::search(), system = base::Sys.info())
[13:36:57.367]                   }
[13:36:57.367]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.367]                     cond$call), session = sessionInformation(), 
[13:36:57.367]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.367]                   signalCondition(cond)
[13:36:57.367]                 }
[13:36:57.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.367]                 "immediateCondition"))) {
[13:36:57.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.367]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.367]                   if (TRUE && !signal) {
[13:36:57.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.367]                     {
[13:36:57.367]                       inherits <- base::inherits
[13:36:57.367]                       invokeRestart <- base::invokeRestart
[13:36:57.367]                       is.null <- base::is.null
[13:36:57.367]                       muffled <- FALSE
[13:36:57.367]                       if (inherits(cond, "message")) {
[13:36:57.367]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.367]                         if (muffled) 
[13:36:57.367]                           invokeRestart("muffleMessage")
[13:36:57.367]                       }
[13:36:57.367]                       else if (inherits(cond, "warning")) {
[13:36:57.367]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.367]                         if (muffled) 
[13:36:57.367]                           invokeRestart("muffleWarning")
[13:36:57.367]                       }
[13:36:57.367]                       else if (inherits(cond, "condition")) {
[13:36:57.367]                         if (!is.null(pattern)) {
[13:36:57.367]                           computeRestarts <- base::computeRestarts
[13:36:57.367]                           grepl <- base::grepl
[13:36:57.367]                           restarts <- computeRestarts(cond)
[13:36:57.367]                           for (restart in restarts) {
[13:36:57.367]                             name <- restart$name
[13:36:57.367]                             if (is.null(name)) 
[13:36:57.367]                               next
[13:36:57.367]                             if (!grepl(pattern, name)) 
[13:36:57.367]                               next
[13:36:57.367]                             invokeRestart(restart)
[13:36:57.367]                             muffled <- TRUE
[13:36:57.367]                             break
[13:36:57.367]                           }
[13:36:57.367]                         }
[13:36:57.367]                       }
[13:36:57.367]                       invisible(muffled)
[13:36:57.367]                     }
[13:36:57.367]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.367]                   }
[13:36:57.367]                 }
[13:36:57.367]                 else {
[13:36:57.367]                   if (TRUE) {
[13:36:57.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.367]                     {
[13:36:57.367]                       inherits <- base::inherits
[13:36:57.367]                       invokeRestart <- base::invokeRestart
[13:36:57.367]                       is.null <- base::is.null
[13:36:57.367]                       muffled <- FALSE
[13:36:57.367]                       if (inherits(cond, "message")) {
[13:36:57.367]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.367]                         if (muffled) 
[13:36:57.367]                           invokeRestart("muffleMessage")
[13:36:57.367]                       }
[13:36:57.367]                       else if (inherits(cond, "warning")) {
[13:36:57.367]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.367]                         if (muffled) 
[13:36:57.367]                           invokeRestart("muffleWarning")
[13:36:57.367]                       }
[13:36:57.367]                       else if (inherits(cond, "condition")) {
[13:36:57.367]                         if (!is.null(pattern)) {
[13:36:57.367]                           computeRestarts <- base::computeRestarts
[13:36:57.367]                           grepl <- base::grepl
[13:36:57.367]                           restarts <- computeRestarts(cond)
[13:36:57.367]                           for (restart in restarts) {
[13:36:57.367]                             name <- restart$name
[13:36:57.367]                             if (is.null(name)) 
[13:36:57.367]                               next
[13:36:57.367]                             if (!grepl(pattern, name)) 
[13:36:57.367]                               next
[13:36:57.367]                             invokeRestart(restart)
[13:36:57.367]                             muffled <- TRUE
[13:36:57.367]                             break
[13:36:57.367]                           }
[13:36:57.367]                         }
[13:36:57.367]                       }
[13:36:57.367]                       invisible(muffled)
[13:36:57.367]                     }
[13:36:57.367]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.367]                   }
[13:36:57.367]                 }
[13:36:57.367]             }
[13:36:57.367]         }))
[13:36:57.367]     }, error = function(ex) {
[13:36:57.367]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.367]                 ...future.rng), started = ...future.startTime, 
[13:36:57.367]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.367]             version = "1.8"), class = "FutureResult")
[13:36:57.367]     }, finally = {
[13:36:57.367]         if (!identical(...future.workdir, getwd())) 
[13:36:57.367]             setwd(...future.workdir)
[13:36:57.367]         {
[13:36:57.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.367]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.367]             }
[13:36:57.367]             base::options(...future.oldOptions)
[13:36:57.367]             if (.Platform$OS.type == "windows") {
[13:36:57.367]                 old_names <- names(...future.oldEnvVars)
[13:36:57.367]                 envs <- base::Sys.getenv()
[13:36:57.367]                 names <- names(envs)
[13:36:57.367]                 common <- intersect(names, old_names)
[13:36:57.367]                 added <- setdiff(names, old_names)
[13:36:57.367]                 removed <- setdiff(old_names, names)
[13:36:57.367]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.367]                   envs[common]]
[13:36:57.367]                 NAMES <- toupper(changed)
[13:36:57.367]                 args <- list()
[13:36:57.367]                 for (kk in seq_along(NAMES)) {
[13:36:57.367]                   name <- changed[[kk]]
[13:36:57.367]                   NAME <- NAMES[[kk]]
[13:36:57.367]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.367]                     next
[13:36:57.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.367]                 }
[13:36:57.367]                 NAMES <- toupper(added)
[13:36:57.367]                 for (kk in seq_along(NAMES)) {
[13:36:57.367]                   name <- added[[kk]]
[13:36:57.367]                   NAME <- NAMES[[kk]]
[13:36:57.367]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.367]                     next
[13:36:57.367]                   args[[name]] <- ""
[13:36:57.367]                 }
[13:36:57.367]                 NAMES <- toupper(removed)
[13:36:57.367]                 for (kk in seq_along(NAMES)) {
[13:36:57.367]                   name <- removed[[kk]]
[13:36:57.367]                   NAME <- NAMES[[kk]]
[13:36:57.367]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.367]                     next
[13:36:57.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.367]                 }
[13:36:57.367]                 if (length(args) > 0) 
[13:36:57.367]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.367]             }
[13:36:57.367]             else {
[13:36:57.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.367]             }
[13:36:57.367]             {
[13:36:57.367]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.367]                   0L) {
[13:36:57.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.367]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.367]                   base::options(opts)
[13:36:57.367]                 }
[13:36:57.367]                 {
[13:36:57.367]                   {
[13:36:57.367]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.367]                     NULL
[13:36:57.367]                   }
[13:36:57.367]                   options(future.plan = NULL)
[13:36:57.367]                   if (is.na(NA_character_)) 
[13:36:57.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.367]                     .init = FALSE)
[13:36:57.367]                 }
[13:36:57.367]             }
[13:36:57.367]         }
[13:36:57.367]     })
[13:36:57.367]     if (TRUE) {
[13:36:57.367]         base::sink(type = "output", split = FALSE)
[13:36:57.367]         if (TRUE) {
[13:36:57.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.367]         }
[13:36:57.367]         else {
[13:36:57.367]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.367]         }
[13:36:57.367]         base::close(...future.stdout)
[13:36:57.367]         ...future.stdout <- NULL
[13:36:57.367]     }
[13:36:57.367]     ...future.result$conditions <- ...future.conditions
[13:36:57.367]     ...future.result$finished <- base::Sys.time()
[13:36:57.367]     ...future.result
[13:36:57.367] }
[13:36:57.369] assign_globals() ...
[13:36:57.370] List of 1
[13:36:57.370]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c6dcc9d510> 
[13:36:57.370]  - attr(*, "where")=List of 1
[13:36:57.370]   ..$ a:<environment: R_EmptyEnv> 
[13:36:57.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.370]  - attr(*, "resolved")= logi TRUE
[13:36:57.370]  - attr(*, "total_size")= num 1647176
[13:36:57.370]  - attr(*, "already-done")= logi TRUE
[13:36:57.373] - copied ‘a’ to environment
[13:36:57.375] assign_globals() ... done
[13:36:57.376] requestCore(): workers = 2
[13:36:57.378] MulticoreFuture started
[13:36:57.378] - Launch lazy future ... done
[13:36:57.379] run() for ‘MulticoreFuture’ ... done
[13:36:57.379] result() for MulticoreFuture ...
[13:36:57.379] plan(): Setting new future strategy stack:
[13:36:57.380] List of future strategies:
[13:36:57.380] 1. sequential:
[13:36:57.380]    - args: function (..., envir = parent.frame())
[13:36:57.380]    - tweaked: FALSE
[13:36:57.380]    - call: NULL
[13:36:57.381] plan(): nbrOfWorkers() = 1
[13:36:57.385] plan(): Setting new future strategy stack:
[13:36:57.385] List of future strategies:
[13:36:57.385] 1. multicore:
[13:36:57.385]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.385]    - tweaked: FALSE
[13:36:57.385]    - call: plan(strategy)
[13:36:57.391] plan(): nbrOfWorkers() = 2
[13:36:57.392] result() for MulticoreFuture ...
[13:36:57.392] result() for MulticoreFuture ... done
[13:36:57.392] signalConditions() ...
[13:36:57.392]  - include = ‘immediateCondition’
[13:36:57.392]  - exclude = 
[13:36:57.392]  - resignal = FALSE
[13:36:57.393]  - Number of conditions: 4
[13:36:57.393] signalConditions() ... done
[13:36:57.393] result() for MulticoreFuture ... done
[13:36:57.393] result() for MulticoreFuture ...
[13:36:57.393] result() for MulticoreFuture ... done
[13:36:57.394] signalConditions() ...
[13:36:57.394]  - include = ‘immediateCondition’
[13:36:57.394]  - exclude = 
[13:36:57.394]  - resignal = FALSE
[13:36:57.394]  - Number of conditions: 4
[13:36:57.395] signalConditions() ... done
[13:36:57.395] Future state: ‘finished’
[13:36:57.395] result() for MulticoreFuture ...
[13:36:57.395] result() for MulticoreFuture ... done
[13:36:57.395] signalConditions() ...
[13:36:57.395]  - include = ‘condition’
[13:36:57.396]  - exclude = ‘immediateCondition’
[13:36:57.396]  - resignal = TRUE
[13:36:57.396]  - Number of conditions: 4
[13:36:57.396]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.382] result() for MulticoreFuture ...
[13:36:57.396]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.382] result() for MulticoreFuture ... done
[13:36:57.396]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.383] result() for MulticoreFuture ...
[13:36:57.396]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.383] result() for MulticoreFuture ... done
[13:36:57.397] signalConditions() ... done
value(b) = 2
[13:36:57.397] result() for MulticoreFuture ...
[13:36:57.397] result() for MulticoreFuture ... done
[13:36:57.397] result() for MulticoreFuture ...
[13:36:57.397] result() for MulticoreFuture ... done
[13:36:57.397] signalConditions() ...
[13:36:57.398]  - include = ‘immediateCondition’
[13:36:57.398]  - exclude = 
[13:36:57.398]  - resignal = FALSE
[13:36:57.398]  - Number of conditions: 4
[13:36:57.398] signalConditions() ... done
[13:36:57.399] Future state: ‘finished’
[13:36:57.399] result() for MulticoreFuture ...
[13:36:57.399] result() for MulticoreFuture ... done
[13:36:57.399] signalConditions() ...
[13:36:57.399]  - include = ‘condition’
[13:36:57.399]  - exclude = ‘immediateCondition’
[13:36:57.399]  - resignal = TRUE
[13:36:57.400]  - Number of conditions: 4
[13:36:57.400]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.382] result() for MulticoreFuture ...
[13:36:57.400]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.382] result() for MulticoreFuture ... done
[13:36:57.400]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.383] result() for MulticoreFuture ...
[13:36:57.400]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.383] result() for MulticoreFuture ... done
[13:36:57.401] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.401] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.401] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.402] 
[13:36:57.402] Searching for globals ... DONE
[13:36:57.402] - globals: [0] <none>
[13:36:57.402] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.402] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.403] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.404] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:57.404] Searching for globals ... DONE
[13:36:57.404] Resolving globals: TRUE
[13:36:57.404] Resolving any globals that are futures ...
[13:36:57.404] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:57.404] Resolving any globals that are futures ... DONE
[13:36:57.405] Resolving futures part of globals (recursively) ...
[13:36:57.405] resolve() on list ...
[13:36:57.405]  recursive: 99
[13:36:57.405]  length: 1
[13:36:57.405]  elements: ‘a’
[13:36:57.406] run() for ‘Future’ ...
[13:36:57.406] - state: ‘created’
[13:36:57.406] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.410] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.410]   - Field: ‘label’
[13:36:57.410]   - Field: ‘local’
[13:36:57.410]   - Field: ‘owner’
[13:36:57.410]   - Field: ‘envir’
[13:36:57.411]   - Field: ‘workers’
[13:36:57.411]   - Field: ‘packages’
[13:36:57.411]   - Field: ‘gc’
[13:36:57.411]   - Field: ‘job’
[13:36:57.411]   - Field: ‘conditions’
[13:36:57.411]   - Field: ‘expr’
[13:36:57.411]   - Field: ‘uuid’
[13:36:57.411]   - Field: ‘seed’
[13:36:57.411]   - Field: ‘version’
[13:36:57.412]   - Field: ‘result’
[13:36:57.412]   - Field: ‘asynchronous’
[13:36:57.412]   - Field: ‘calls’
[13:36:57.412]   - Field: ‘globals’
[13:36:57.412]   - Field: ‘stdout’
[13:36:57.412]   - Field: ‘earlySignal’
[13:36:57.412]   - Field: ‘lazy’
[13:36:57.412]   - Field: ‘state’
[13:36:57.412] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.412] - Launch lazy future ...
[13:36:57.413] Packages needed by the future expression (n = 0): <none>
[13:36:57.413] Packages needed by future strategies (n = 0): <none>
[13:36:57.413] {
[13:36:57.413]     {
[13:36:57.413]         {
[13:36:57.413]             ...future.startTime <- base::Sys.time()
[13:36:57.413]             {
[13:36:57.413]                 {
[13:36:57.413]                   {
[13:36:57.413]                     {
[13:36:57.413]                       base::local({
[13:36:57.413]                         has_future <- base::requireNamespace("future", 
[13:36:57.413]                           quietly = TRUE)
[13:36:57.413]                         if (has_future) {
[13:36:57.413]                           ns <- base::getNamespace("future")
[13:36:57.413]                           version <- ns[[".package"]][["version"]]
[13:36:57.413]                           if (is.null(version)) 
[13:36:57.413]                             version <- utils::packageVersion("future")
[13:36:57.413]                         }
[13:36:57.413]                         else {
[13:36:57.413]                           version <- NULL
[13:36:57.413]                         }
[13:36:57.413]                         if (!has_future || version < "1.8.0") {
[13:36:57.413]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.413]                             "", base::R.version$version.string), 
[13:36:57.413]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.413]                               "release", "version")], collapse = " "), 
[13:36:57.413]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.413]                             info)
[13:36:57.413]                           info <- base::paste(info, collapse = "; ")
[13:36:57.413]                           if (!has_future) {
[13:36:57.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.413]                               info)
[13:36:57.413]                           }
[13:36:57.413]                           else {
[13:36:57.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.413]                               info, version)
[13:36:57.413]                           }
[13:36:57.413]                           base::stop(msg)
[13:36:57.413]                         }
[13:36:57.413]                       })
[13:36:57.413]                     }
[13:36:57.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.413]                     base::options(mc.cores = 1L)
[13:36:57.413]                   }
[13:36:57.413]                   ...future.strategy.old <- future::plan("list")
[13:36:57.413]                   options(future.plan = NULL)
[13:36:57.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.413]                 }
[13:36:57.413]                 ...future.workdir <- getwd()
[13:36:57.413]             }
[13:36:57.413]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.413]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.413]         }
[13:36:57.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.413]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.413]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.413]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.413]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.413]             base::names(...future.oldOptions))
[13:36:57.413]     }
[13:36:57.413]     if (FALSE) {
[13:36:57.413]     }
[13:36:57.413]     else {
[13:36:57.413]         if (TRUE) {
[13:36:57.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.413]                 open = "w")
[13:36:57.413]         }
[13:36:57.413]         else {
[13:36:57.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.413]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.413]         }
[13:36:57.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.413]             base::sink(type = "output", split = FALSE)
[13:36:57.413]             base::close(...future.stdout)
[13:36:57.413]         }, add = TRUE)
[13:36:57.413]     }
[13:36:57.413]     ...future.frame <- base::sys.nframe()
[13:36:57.413]     ...future.conditions <- base::list()
[13:36:57.413]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.413]     if (FALSE) {
[13:36:57.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.413]     }
[13:36:57.413]     ...future.result <- base::tryCatch({
[13:36:57.413]         base::withCallingHandlers({
[13:36:57.413]             ...future.value <- base::withVisible(base::local({
[13:36:57.413]                 withCallingHandlers({
[13:36:57.413]                   1
[13:36:57.413]                 }, immediateCondition = function(cond) {
[13:36:57.413]                   save_rds <- function (object, pathname, ...) 
[13:36:57.413]                   {
[13:36:57.413]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.413]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.413]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.413]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.413]                         fi_tmp[["mtime"]])
[13:36:57.413]                     }
[13:36:57.413]                     tryCatch({
[13:36:57.413]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.413]                     }, error = function(ex) {
[13:36:57.413]                       msg <- conditionMessage(ex)
[13:36:57.413]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.413]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.413]                         fi_tmp[["mtime"]], msg)
[13:36:57.413]                       ex$message <- msg
[13:36:57.413]                       stop(ex)
[13:36:57.413]                     })
[13:36:57.413]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.413]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.413]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.413]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.413]                       fi <- file.info(pathname)
[13:36:57.413]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.413]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.413]                         fi[["size"]], fi[["mtime"]])
[13:36:57.413]                       stop(msg)
[13:36:57.413]                     }
[13:36:57.413]                     invisible(pathname)
[13:36:57.413]                   }
[13:36:57.413]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.413]                     rootPath = tempdir()) 
[13:36:57.413]                   {
[13:36:57.413]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.413]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.413]                       tmpdir = path, fileext = ".rds")
[13:36:57.413]                     save_rds(obj, file)
[13:36:57.413]                   }
[13:36:57.413]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.413]                   {
[13:36:57.413]                     inherits <- base::inherits
[13:36:57.413]                     invokeRestart <- base::invokeRestart
[13:36:57.413]                     is.null <- base::is.null
[13:36:57.413]                     muffled <- FALSE
[13:36:57.413]                     if (inherits(cond, "message")) {
[13:36:57.413]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.413]                       if (muffled) 
[13:36:57.413]                         invokeRestart("muffleMessage")
[13:36:57.413]                     }
[13:36:57.413]                     else if (inherits(cond, "warning")) {
[13:36:57.413]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.413]                       if (muffled) 
[13:36:57.413]                         invokeRestart("muffleWarning")
[13:36:57.413]                     }
[13:36:57.413]                     else if (inherits(cond, "condition")) {
[13:36:57.413]                       if (!is.null(pattern)) {
[13:36:57.413]                         computeRestarts <- base::computeRestarts
[13:36:57.413]                         grepl <- base::grepl
[13:36:57.413]                         restarts <- computeRestarts(cond)
[13:36:57.413]                         for (restart in restarts) {
[13:36:57.413]                           name <- restart$name
[13:36:57.413]                           if (is.null(name)) 
[13:36:57.413]                             next
[13:36:57.413]                           if (!grepl(pattern, name)) 
[13:36:57.413]                             next
[13:36:57.413]                           invokeRestart(restart)
[13:36:57.413]                           muffled <- TRUE
[13:36:57.413]                           break
[13:36:57.413]                         }
[13:36:57.413]                       }
[13:36:57.413]                     }
[13:36:57.413]                     invisible(muffled)
[13:36:57.413]                   }
[13:36:57.413]                   muffleCondition(cond)
[13:36:57.413]                 })
[13:36:57.413]             }))
[13:36:57.413]             future::FutureResult(value = ...future.value$value, 
[13:36:57.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.413]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.413]                     ...future.globalenv.names))
[13:36:57.413]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.413]         }, condition = base::local({
[13:36:57.413]             c <- base::c
[13:36:57.413]             inherits <- base::inherits
[13:36:57.413]             invokeRestart <- base::invokeRestart
[13:36:57.413]             length <- base::length
[13:36:57.413]             list <- base::list
[13:36:57.413]             seq.int <- base::seq.int
[13:36:57.413]             signalCondition <- base::signalCondition
[13:36:57.413]             sys.calls <- base::sys.calls
[13:36:57.413]             `[[` <- base::`[[`
[13:36:57.413]             `+` <- base::`+`
[13:36:57.413]             `<<-` <- base::`<<-`
[13:36:57.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.413]                   3L)]
[13:36:57.413]             }
[13:36:57.413]             function(cond) {
[13:36:57.413]                 is_error <- inherits(cond, "error")
[13:36:57.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.413]                   NULL)
[13:36:57.413]                 if (is_error) {
[13:36:57.413]                   sessionInformation <- function() {
[13:36:57.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.413]                       search = base::search(), system = base::Sys.info())
[13:36:57.413]                   }
[13:36:57.413]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.413]                     cond$call), session = sessionInformation(), 
[13:36:57.413]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.413]                   signalCondition(cond)
[13:36:57.413]                 }
[13:36:57.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.413]                 "immediateCondition"))) {
[13:36:57.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.413]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.413]                   if (TRUE && !signal) {
[13:36:57.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.413]                     {
[13:36:57.413]                       inherits <- base::inherits
[13:36:57.413]                       invokeRestart <- base::invokeRestart
[13:36:57.413]                       is.null <- base::is.null
[13:36:57.413]                       muffled <- FALSE
[13:36:57.413]                       if (inherits(cond, "message")) {
[13:36:57.413]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.413]                         if (muffled) 
[13:36:57.413]                           invokeRestart("muffleMessage")
[13:36:57.413]                       }
[13:36:57.413]                       else if (inherits(cond, "warning")) {
[13:36:57.413]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.413]                         if (muffled) 
[13:36:57.413]                           invokeRestart("muffleWarning")
[13:36:57.413]                       }
[13:36:57.413]                       else if (inherits(cond, "condition")) {
[13:36:57.413]                         if (!is.null(pattern)) {
[13:36:57.413]                           computeRestarts <- base::computeRestarts
[13:36:57.413]                           grepl <- base::grepl
[13:36:57.413]                           restarts <- computeRestarts(cond)
[13:36:57.413]                           for (restart in restarts) {
[13:36:57.413]                             name <- restart$name
[13:36:57.413]                             if (is.null(name)) 
[13:36:57.413]                               next
[13:36:57.413]                             if (!grepl(pattern, name)) 
[13:36:57.413]                               next
[13:36:57.413]                             invokeRestart(restart)
[13:36:57.413]                             muffled <- TRUE
[13:36:57.413]                             break
[13:36:57.413]                           }
[13:36:57.413]                         }
[13:36:57.413]                       }
[13:36:57.413]                       invisible(muffled)
[13:36:57.413]                     }
[13:36:57.413]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.413]                   }
[13:36:57.413]                 }
[13:36:57.413]                 else {
[13:36:57.413]                   if (TRUE) {
[13:36:57.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.413]                     {
[13:36:57.413]                       inherits <- base::inherits
[13:36:57.413]                       invokeRestart <- base::invokeRestart
[13:36:57.413]                       is.null <- base::is.null
[13:36:57.413]                       muffled <- FALSE
[13:36:57.413]                       if (inherits(cond, "message")) {
[13:36:57.413]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.413]                         if (muffled) 
[13:36:57.413]                           invokeRestart("muffleMessage")
[13:36:57.413]                       }
[13:36:57.413]                       else if (inherits(cond, "warning")) {
[13:36:57.413]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.413]                         if (muffled) 
[13:36:57.413]                           invokeRestart("muffleWarning")
[13:36:57.413]                       }
[13:36:57.413]                       else if (inherits(cond, "condition")) {
[13:36:57.413]                         if (!is.null(pattern)) {
[13:36:57.413]                           computeRestarts <- base::computeRestarts
[13:36:57.413]                           grepl <- base::grepl
[13:36:57.413]                           restarts <- computeRestarts(cond)
[13:36:57.413]                           for (restart in restarts) {
[13:36:57.413]                             name <- restart$name
[13:36:57.413]                             if (is.null(name)) 
[13:36:57.413]                               next
[13:36:57.413]                             if (!grepl(pattern, name)) 
[13:36:57.413]                               next
[13:36:57.413]                             invokeRestart(restart)
[13:36:57.413]                             muffled <- TRUE
[13:36:57.413]                             break
[13:36:57.413]                           }
[13:36:57.413]                         }
[13:36:57.413]                       }
[13:36:57.413]                       invisible(muffled)
[13:36:57.413]                     }
[13:36:57.413]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.413]                   }
[13:36:57.413]                 }
[13:36:57.413]             }
[13:36:57.413]         }))
[13:36:57.413]     }, error = function(ex) {
[13:36:57.413]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.413]                 ...future.rng), started = ...future.startTime, 
[13:36:57.413]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.413]             version = "1.8"), class = "FutureResult")
[13:36:57.413]     }, finally = {
[13:36:57.413]         if (!identical(...future.workdir, getwd())) 
[13:36:57.413]             setwd(...future.workdir)
[13:36:57.413]         {
[13:36:57.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.413]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.413]             }
[13:36:57.413]             base::options(...future.oldOptions)
[13:36:57.413]             if (.Platform$OS.type == "windows") {
[13:36:57.413]                 old_names <- names(...future.oldEnvVars)
[13:36:57.413]                 envs <- base::Sys.getenv()
[13:36:57.413]                 names <- names(envs)
[13:36:57.413]                 common <- intersect(names, old_names)
[13:36:57.413]                 added <- setdiff(names, old_names)
[13:36:57.413]                 removed <- setdiff(old_names, names)
[13:36:57.413]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.413]                   envs[common]]
[13:36:57.413]                 NAMES <- toupper(changed)
[13:36:57.413]                 args <- list()
[13:36:57.413]                 for (kk in seq_along(NAMES)) {
[13:36:57.413]                   name <- changed[[kk]]
[13:36:57.413]                   NAME <- NAMES[[kk]]
[13:36:57.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.413]                     next
[13:36:57.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.413]                 }
[13:36:57.413]                 NAMES <- toupper(added)
[13:36:57.413]                 for (kk in seq_along(NAMES)) {
[13:36:57.413]                   name <- added[[kk]]
[13:36:57.413]                   NAME <- NAMES[[kk]]
[13:36:57.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.413]                     next
[13:36:57.413]                   args[[name]] <- ""
[13:36:57.413]                 }
[13:36:57.413]                 NAMES <- toupper(removed)
[13:36:57.413]                 for (kk in seq_along(NAMES)) {
[13:36:57.413]                   name <- removed[[kk]]
[13:36:57.413]                   NAME <- NAMES[[kk]]
[13:36:57.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.413]                     next
[13:36:57.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.413]                 }
[13:36:57.413]                 if (length(args) > 0) 
[13:36:57.413]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.413]             }
[13:36:57.413]             else {
[13:36:57.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.413]             }
[13:36:57.413]             {
[13:36:57.413]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.413]                   0L) {
[13:36:57.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.413]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.413]                   base::options(opts)
[13:36:57.413]                 }
[13:36:57.413]                 {
[13:36:57.413]                   {
[13:36:57.413]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.413]                     NULL
[13:36:57.413]                   }
[13:36:57.413]                   options(future.plan = NULL)
[13:36:57.413]                   if (is.na(NA_character_)) 
[13:36:57.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.413]                     .init = FALSE)
[13:36:57.413]                 }
[13:36:57.413]             }
[13:36:57.413]         }
[13:36:57.413]     })
[13:36:57.413]     if (TRUE) {
[13:36:57.413]         base::sink(type = "output", split = FALSE)
[13:36:57.413]         if (TRUE) {
[13:36:57.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.413]         }
[13:36:57.413]         else {
[13:36:57.413]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.413]         }
[13:36:57.413]         base::close(...future.stdout)
[13:36:57.413]         ...future.stdout <- NULL
[13:36:57.413]     }
[13:36:57.413]     ...future.result$conditions <- ...future.conditions
[13:36:57.413]     ...future.result$finished <- base::Sys.time()
[13:36:57.413]     ...future.result
[13:36:57.413] }
[13:36:57.416] requestCore(): workers = 2
[13:36:57.418] MulticoreFuture started
[13:36:57.418] - Launch lazy future ... done
[13:36:57.419] run() for ‘MulticoreFuture’ ... done
[13:36:57.419] plan(): Setting new future strategy stack:
[13:36:57.419] List of future strategies:
[13:36:57.419] 1. sequential:
[13:36:57.419]    - args: function (..., envir = parent.frame())
[13:36:57.419]    - tweaked: FALSE
[13:36:57.419]    - call: NULL
[13:36:57.420] plan(): nbrOfWorkers() = 1
[13:36:57.423] plan(): Setting new future strategy stack:
[13:36:57.423] List of future strategies:
[13:36:57.423] 1. multicore:
[13:36:57.423]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.423]    - tweaked: FALSE
[13:36:57.423]    - call: plan(strategy)
[13:36:57.428] plan(): nbrOfWorkers() = 2
[13:36:57.429] Future #1
[13:36:57.429] result() for MulticoreFuture ...
[13:36:57.430] result() for MulticoreFuture ...
[13:36:57.430] result() for MulticoreFuture ... done
[13:36:57.430] result() for MulticoreFuture ... done
[13:36:57.430] result() for MulticoreFuture ...
[13:36:57.430] result() for MulticoreFuture ... done
[13:36:57.431] A MulticoreFuture was resolved
[13:36:57.431]  length: 0 (resolved future 1)
[13:36:57.431] resolve() on list ... DONE
[13:36:57.431] - globals: [1] ‘a’
[13:36:57.432] Resolving futures part of globals (recursively) ... DONE
[13:36:57.435] The total size of the 1 globals is 1.57 MiB (1647176 bytes)
[13:36:57.435] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:36:57.435] - globals: [1] ‘a’
[13:36:57.435] - packages: [1] ‘future’
[13:36:57.436] getGlobalsAndPackages() ... DONE
[13:36:57.436] run() for ‘Future’ ...
[13:36:57.436] - state: ‘created’
[13:36:57.436] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.444] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.444] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.444]   - Field: ‘label’
[13:36:57.444]   - Field: ‘local’
[13:36:57.444]   - Field: ‘owner’
[13:36:57.444]   - Field: ‘envir’
[13:36:57.445]   - Field: ‘workers’
[13:36:57.445]   - Field: ‘packages’
[13:36:57.445]   - Field: ‘gc’
[13:36:57.445]   - Field: ‘job’
[13:36:57.445]   - Field: ‘conditions’
[13:36:57.445]   - Field: ‘expr’
[13:36:57.445]   - Field: ‘uuid’
[13:36:57.446]   - Field: ‘seed’
[13:36:57.446]   - Field: ‘version’
[13:36:57.446]   - Field: ‘result’
[13:36:57.446]   - Field: ‘asynchronous’
[13:36:57.446]   - Field: ‘calls’
[13:36:57.446]   - Field: ‘globals’
[13:36:57.446]   - Field: ‘stdout’
[13:36:57.447]   - Field: ‘earlySignal’
[13:36:57.447]   - Field: ‘lazy’
[13:36:57.447]   - Field: ‘state’
[13:36:57.447] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.447] - Launch lazy future ...
[13:36:57.447] Packages needed by the future expression (n = 1): ‘future’
[13:36:57.448] Packages needed by future strategies (n = 0): <none>
[13:36:57.448] {
[13:36:57.448]     {
[13:36:57.448]         {
[13:36:57.448]             ...future.startTime <- base::Sys.time()
[13:36:57.448]             {
[13:36:57.448]                 {
[13:36:57.448]                   {
[13:36:57.448]                     {
[13:36:57.448]                       {
[13:36:57.448]                         base::local({
[13:36:57.448]                           has_future <- base::requireNamespace("future", 
[13:36:57.448]                             quietly = TRUE)
[13:36:57.448]                           if (has_future) {
[13:36:57.448]                             ns <- base::getNamespace("future")
[13:36:57.448]                             version <- ns[[".package"]][["version"]]
[13:36:57.448]                             if (is.null(version)) 
[13:36:57.448]                               version <- utils::packageVersion("future")
[13:36:57.448]                           }
[13:36:57.448]                           else {
[13:36:57.448]                             version <- NULL
[13:36:57.448]                           }
[13:36:57.448]                           if (!has_future || version < "1.8.0") {
[13:36:57.448]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.448]                               "", base::R.version$version.string), 
[13:36:57.448]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:57.448]                                 base::R.version$platform, 8 * 
[13:36:57.448]                                   base::.Machine$sizeof.pointer), 
[13:36:57.448]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.448]                                 "release", "version")], collapse = " "), 
[13:36:57.448]                               hostname = base::Sys.info()[["nodename"]])
[13:36:57.448]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.448]                               info)
[13:36:57.448]                             info <- base::paste(info, collapse = "; ")
[13:36:57.448]                             if (!has_future) {
[13:36:57.448]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.448]                                 info)
[13:36:57.448]                             }
[13:36:57.448]                             else {
[13:36:57.448]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.448]                                 info, version)
[13:36:57.448]                             }
[13:36:57.448]                             base::stop(msg)
[13:36:57.448]                           }
[13:36:57.448]                         })
[13:36:57.448]                       }
[13:36:57.448]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.448]                       base::options(mc.cores = 1L)
[13:36:57.448]                     }
[13:36:57.448]                     base::local({
[13:36:57.448]                       for (pkg in "future") {
[13:36:57.448]                         base::loadNamespace(pkg)
[13:36:57.448]                         base::library(pkg, character.only = TRUE)
[13:36:57.448]                       }
[13:36:57.448]                     })
[13:36:57.448]                   }
[13:36:57.448]                   ...future.strategy.old <- future::plan("list")
[13:36:57.448]                   options(future.plan = NULL)
[13:36:57.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.448]                 }
[13:36:57.448]                 ...future.workdir <- getwd()
[13:36:57.448]             }
[13:36:57.448]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.448]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.448]         }
[13:36:57.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.448]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.448]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.448]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.448]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.448]             base::names(...future.oldOptions))
[13:36:57.448]     }
[13:36:57.448]     if (FALSE) {
[13:36:57.448]     }
[13:36:57.448]     else {
[13:36:57.448]         if (TRUE) {
[13:36:57.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.448]                 open = "w")
[13:36:57.448]         }
[13:36:57.448]         else {
[13:36:57.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.448]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.448]         }
[13:36:57.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.448]             base::sink(type = "output", split = FALSE)
[13:36:57.448]             base::close(...future.stdout)
[13:36:57.448]         }, add = TRUE)
[13:36:57.448]     }
[13:36:57.448]     ...future.frame <- base::sys.nframe()
[13:36:57.448]     ...future.conditions <- base::list()
[13:36:57.448]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.448]     if (FALSE) {
[13:36:57.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.448]     }
[13:36:57.448]     ...future.result <- base::tryCatch({
[13:36:57.448]         base::withCallingHandlers({
[13:36:57.448]             ...future.value <- base::withVisible(base::local({
[13:36:57.448]                 withCallingHandlers({
[13:36:57.448]                   value(a) + 1
[13:36:57.448]                 }, immediateCondition = function(cond) {
[13:36:57.448]                   save_rds <- function (object, pathname, ...) 
[13:36:57.448]                   {
[13:36:57.448]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.448]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.448]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.448]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.448]                         fi_tmp[["mtime"]])
[13:36:57.448]                     }
[13:36:57.448]                     tryCatch({
[13:36:57.448]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.448]                     }, error = function(ex) {
[13:36:57.448]                       msg <- conditionMessage(ex)
[13:36:57.448]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.448]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.448]                         fi_tmp[["mtime"]], msg)
[13:36:57.448]                       ex$message <- msg
[13:36:57.448]                       stop(ex)
[13:36:57.448]                     })
[13:36:57.448]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.448]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.448]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.448]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.448]                       fi <- file.info(pathname)
[13:36:57.448]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.448]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.448]                         fi[["size"]], fi[["mtime"]])
[13:36:57.448]                       stop(msg)
[13:36:57.448]                     }
[13:36:57.448]                     invisible(pathname)
[13:36:57.448]                   }
[13:36:57.448]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.448]                     rootPath = tempdir()) 
[13:36:57.448]                   {
[13:36:57.448]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.448]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.448]                       tmpdir = path, fileext = ".rds")
[13:36:57.448]                     save_rds(obj, file)
[13:36:57.448]                   }
[13:36:57.448]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.448]                   {
[13:36:57.448]                     inherits <- base::inherits
[13:36:57.448]                     invokeRestart <- base::invokeRestart
[13:36:57.448]                     is.null <- base::is.null
[13:36:57.448]                     muffled <- FALSE
[13:36:57.448]                     if (inherits(cond, "message")) {
[13:36:57.448]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.448]                       if (muffled) 
[13:36:57.448]                         invokeRestart("muffleMessage")
[13:36:57.448]                     }
[13:36:57.448]                     else if (inherits(cond, "warning")) {
[13:36:57.448]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.448]                       if (muffled) 
[13:36:57.448]                         invokeRestart("muffleWarning")
[13:36:57.448]                     }
[13:36:57.448]                     else if (inherits(cond, "condition")) {
[13:36:57.448]                       if (!is.null(pattern)) {
[13:36:57.448]                         computeRestarts <- base::computeRestarts
[13:36:57.448]                         grepl <- base::grepl
[13:36:57.448]                         restarts <- computeRestarts(cond)
[13:36:57.448]                         for (restart in restarts) {
[13:36:57.448]                           name <- restart$name
[13:36:57.448]                           if (is.null(name)) 
[13:36:57.448]                             next
[13:36:57.448]                           if (!grepl(pattern, name)) 
[13:36:57.448]                             next
[13:36:57.448]                           invokeRestart(restart)
[13:36:57.448]                           muffled <- TRUE
[13:36:57.448]                           break
[13:36:57.448]                         }
[13:36:57.448]                       }
[13:36:57.448]                     }
[13:36:57.448]                     invisible(muffled)
[13:36:57.448]                   }
[13:36:57.448]                   muffleCondition(cond)
[13:36:57.448]                 })
[13:36:57.448]             }))
[13:36:57.448]             future::FutureResult(value = ...future.value$value, 
[13:36:57.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.448]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.448]                     ...future.globalenv.names))
[13:36:57.448]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.448]         }, condition = base::local({
[13:36:57.448]             c <- base::c
[13:36:57.448]             inherits <- base::inherits
[13:36:57.448]             invokeRestart <- base::invokeRestart
[13:36:57.448]             length <- base::length
[13:36:57.448]             list <- base::list
[13:36:57.448]             seq.int <- base::seq.int
[13:36:57.448]             signalCondition <- base::signalCondition
[13:36:57.448]             sys.calls <- base::sys.calls
[13:36:57.448]             `[[` <- base::`[[`
[13:36:57.448]             `+` <- base::`+`
[13:36:57.448]             `<<-` <- base::`<<-`
[13:36:57.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.448]                   3L)]
[13:36:57.448]             }
[13:36:57.448]             function(cond) {
[13:36:57.448]                 is_error <- inherits(cond, "error")
[13:36:57.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.448]                   NULL)
[13:36:57.448]                 if (is_error) {
[13:36:57.448]                   sessionInformation <- function() {
[13:36:57.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.448]                       search = base::search(), system = base::Sys.info())
[13:36:57.448]                   }
[13:36:57.448]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.448]                     cond$call), session = sessionInformation(), 
[13:36:57.448]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.448]                   signalCondition(cond)
[13:36:57.448]                 }
[13:36:57.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.448]                 "immediateCondition"))) {
[13:36:57.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.448]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.448]                   if (TRUE && !signal) {
[13:36:57.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.448]                     {
[13:36:57.448]                       inherits <- base::inherits
[13:36:57.448]                       invokeRestart <- base::invokeRestart
[13:36:57.448]                       is.null <- base::is.null
[13:36:57.448]                       muffled <- FALSE
[13:36:57.448]                       if (inherits(cond, "message")) {
[13:36:57.448]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.448]                         if (muffled) 
[13:36:57.448]                           invokeRestart("muffleMessage")
[13:36:57.448]                       }
[13:36:57.448]                       else if (inherits(cond, "warning")) {
[13:36:57.448]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.448]                         if (muffled) 
[13:36:57.448]                           invokeRestart("muffleWarning")
[13:36:57.448]                       }
[13:36:57.448]                       else if (inherits(cond, "condition")) {
[13:36:57.448]                         if (!is.null(pattern)) {
[13:36:57.448]                           computeRestarts <- base::computeRestarts
[13:36:57.448]                           grepl <- base::grepl
[13:36:57.448]                           restarts <- computeRestarts(cond)
[13:36:57.448]                           for (restart in restarts) {
[13:36:57.448]                             name <- restart$name
[13:36:57.448]                             if (is.null(name)) 
[13:36:57.448]                               next
[13:36:57.448]                             if (!grepl(pattern, name)) 
[13:36:57.448]                               next
[13:36:57.448]                             invokeRestart(restart)
[13:36:57.448]                             muffled <- TRUE
[13:36:57.448]                             break
[13:36:57.448]                           }
[13:36:57.448]                         }
[13:36:57.448]                       }
[13:36:57.448]                       invisible(muffled)
[13:36:57.448]                     }
[13:36:57.448]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.448]                   }
[13:36:57.448]                 }
[13:36:57.448]                 else {
[13:36:57.448]                   if (TRUE) {
[13:36:57.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.448]                     {
[13:36:57.448]                       inherits <- base::inherits
[13:36:57.448]                       invokeRestart <- base::invokeRestart
[13:36:57.448]                       is.null <- base::is.null
[13:36:57.448]                       muffled <- FALSE
[13:36:57.448]                       if (inherits(cond, "message")) {
[13:36:57.448]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.448]                         if (muffled) 
[13:36:57.448]                           invokeRestart("muffleMessage")
[13:36:57.448]                       }
[13:36:57.448]                       else if (inherits(cond, "warning")) {
[13:36:57.448]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.448]                         if (muffled) 
[13:36:57.448]                           invokeRestart("muffleWarning")
[13:36:57.448]                       }
[13:36:57.448]                       else if (inherits(cond, "condition")) {
[13:36:57.448]                         if (!is.null(pattern)) {
[13:36:57.448]                           computeRestarts <- base::computeRestarts
[13:36:57.448]                           grepl <- base::grepl
[13:36:57.448]                           restarts <- computeRestarts(cond)
[13:36:57.448]                           for (restart in restarts) {
[13:36:57.448]                             name <- restart$name
[13:36:57.448]                             if (is.null(name)) 
[13:36:57.448]                               next
[13:36:57.448]                             if (!grepl(pattern, name)) 
[13:36:57.448]                               next
[13:36:57.448]                             invokeRestart(restart)
[13:36:57.448]                             muffled <- TRUE
[13:36:57.448]                             break
[13:36:57.448]                           }
[13:36:57.448]                         }
[13:36:57.448]                       }
[13:36:57.448]                       invisible(muffled)
[13:36:57.448]                     }
[13:36:57.448]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.448]                   }
[13:36:57.448]                 }
[13:36:57.448]             }
[13:36:57.448]         }))
[13:36:57.448]     }, error = function(ex) {
[13:36:57.448]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.448]                 ...future.rng), started = ...future.startTime, 
[13:36:57.448]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.448]             version = "1.8"), class = "FutureResult")
[13:36:57.448]     }, finally = {
[13:36:57.448]         if (!identical(...future.workdir, getwd())) 
[13:36:57.448]             setwd(...future.workdir)
[13:36:57.448]         {
[13:36:57.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.448]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.448]             }
[13:36:57.448]             base::options(...future.oldOptions)
[13:36:57.448]             if (.Platform$OS.type == "windows") {
[13:36:57.448]                 old_names <- names(...future.oldEnvVars)
[13:36:57.448]                 envs <- base::Sys.getenv()
[13:36:57.448]                 names <- names(envs)
[13:36:57.448]                 common <- intersect(names, old_names)
[13:36:57.448]                 added <- setdiff(names, old_names)
[13:36:57.448]                 removed <- setdiff(old_names, names)
[13:36:57.448]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.448]                   envs[common]]
[13:36:57.448]                 NAMES <- toupper(changed)
[13:36:57.448]                 args <- list()
[13:36:57.448]                 for (kk in seq_along(NAMES)) {
[13:36:57.448]                   name <- changed[[kk]]
[13:36:57.448]                   NAME <- NAMES[[kk]]
[13:36:57.448]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.448]                     next
[13:36:57.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.448]                 }
[13:36:57.448]                 NAMES <- toupper(added)
[13:36:57.448]                 for (kk in seq_along(NAMES)) {
[13:36:57.448]                   name <- added[[kk]]
[13:36:57.448]                   NAME <- NAMES[[kk]]
[13:36:57.448]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.448]                     next
[13:36:57.448]                   args[[name]] <- ""
[13:36:57.448]                 }
[13:36:57.448]                 NAMES <- toupper(removed)
[13:36:57.448]                 for (kk in seq_along(NAMES)) {
[13:36:57.448]                   name <- removed[[kk]]
[13:36:57.448]                   NAME <- NAMES[[kk]]
[13:36:57.448]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.448]                     next
[13:36:57.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.448]                 }
[13:36:57.448]                 if (length(args) > 0) 
[13:36:57.448]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.448]             }
[13:36:57.448]             else {
[13:36:57.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.448]             }
[13:36:57.448]             {
[13:36:57.448]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.448]                   0L) {
[13:36:57.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.448]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.448]                   base::options(opts)
[13:36:57.448]                 }
[13:36:57.448]                 {
[13:36:57.448]                   {
[13:36:57.448]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.448]                     NULL
[13:36:57.448]                   }
[13:36:57.448]                   options(future.plan = NULL)
[13:36:57.448]                   if (is.na(NA_character_)) 
[13:36:57.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.448]                     .init = FALSE)
[13:36:57.448]                 }
[13:36:57.448]             }
[13:36:57.448]         }
[13:36:57.448]     })
[13:36:57.448]     if (TRUE) {
[13:36:57.448]         base::sink(type = "output", split = FALSE)
[13:36:57.448]         if (TRUE) {
[13:36:57.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.448]         }
[13:36:57.448]         else {
[13:36:57.448]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.448]         }
[13:36:57.448]         base::close(...future.stdout)
[13:36:57.448]         ...future.stdout <- NULL
[13:36:57.448]     }
[13:36:57.448]     ...future.result$conditions <- ...future.conditions
[13:36:57.448]     ...future.result$finished <- base::Sys.time()
[13:36:57.448]     ...future.result
[13:36:57.448] }
[13:36:57.451] assign_globals() ...
[13:36:57.451] List of 1
[13:36:57.451]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c6db1d0a60> 
[13:36:57.451]  - attr(*, "where")=List of 1
[13:36:57.451]   ..$ a:<environment: R_EmptyEnv> 
[13:36:57.451]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.451]  - attr(*, "resolved")= logi TRUE
[13:36:57.451]  - attr(*, "total_size")= num 1647176
[13:36:57.451]  - attr(*, "already-done")= logi TRUE
[13:36:57.454] - copied ‘a’ to environment
[13:36:57.454] assign_globals() ... done
[13:36:57.455] requestCore(): workers = 2
[13:36:57.456] MulticoreFuture started
[13:36:57.457] - Launch lazy future ... done
[13:36:57.457] run() for ‘MulticoreFuture’ ... done
[13:36:57.457] result() for MulticoreFuture ...
[13:36:57.458] plan(): Setting new future strategy stack:
[13:36:57.458] List of future strategies:
[13:36:57.458] 1. sequential:
[13:36:57.458]    - args: function (..., envir = parent.frame())
[13:36:57.458]    - tweaked: FALSE
[13:36:57.458]    - call: NULL
[13:36:57.459] plan(): nbrOfWorkers() = 1
[13:36:57.463] plan(): Setting new future strategy stack:
[13:36:57.463] List of future strategies:
[13:36:57.463] 1. multicore:
[13:36:57.463]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.463]    - tweaked: FALSE
[13:36:57.463]    - call: plan(strategy)
[13:36:57.469] plan(): nbrOfWorkers() = 2
[13:36:57.469] result() for MulticoreFuture ...
[13:36:57.470] result() for MulticoreFuture ... done
[13:36:57.470] signalConditions() ...
[13:36:57.470]  - include = ‘immediateCondition’
[13:36:57.470]  - exclude = 
[13:36:57.471]  - resignal = FALSE
[13:36:57.471]  - Number of conditions: 4
[13:36:57.471] signalConditions() ... done
[13:36:57.471] result() for MulticoreFuture ... done
[13:36:57.471] result() for MulticoreFuture ...
[13:36:57.472] result() for MulticoreFuture ... done
[13:36:57.472] signalConditions() ...
[13:36:57.472]  - include = ‘immediateCondition’
[13:36:57.472]  - exclude = 
[13:36:57.472]  - resignal = FALSE
[13:36:57.472]  - Number of conditions: 4
[13:36:57.472] signalConditions() ... done
[13:36:57.473] Future state: ‘finished’
[13:36:57.473] result() for MulticoreFuture ...
[13:36:57.473] result() for MulticoreFuture ... done
[13:36:57.473] signalConditions() ...
[13:36:57.473]  - include = ‘condition’
[13:36:57.473]  - exclude = ‘immediateCondition’
[13:36:57.473]  - resignal = TRUE
[13:36:57.473]  - Number of conditions: 4
[13:36:57.474]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.461] result() for MulticoreFuture ...
[13:36:57.474]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.461] result() for MulticoreFuture ... done
[13:36:57.474]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.461] result() for MulticoreFuture ...
[13:36:57.474]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.462] result() for MulticoreFuture ... done
[13:36:57.474] signalConditions() ... done
value(b) = 2
[13:36:57.474] result() for MulticoreFuture ...
[13:36:57.475] result() for MulticoreFuture ... done
[13:36:57.475] result() for MulticoreFuture ...
[13:36:57.475] result() for MulticoreFuture ... done
[13:36:57.475] signalConditions() ...
[13:36:57.475]  - include = ‘immediateCondition’
[13:36:57.475]  - exclude = 
[13:36:57.475]  - resignal = FALSE
[13:36:57.475]  - Number of conditions: 4
[13:36:57.475] signalConditions() ... done
[13:36:57.476] Future state: ‘finished’
[13:36:57.476] result() for MulticoreFuture ...
[13:36:57.476] result() for MulticoreFuture ... done
[13:36:57.476] signalConditions() ...
[13:36:57.476]  - include = ‘condition’
[13:36:57.476]  - exclude = ‘immediateCondition’
[13:36:57.476]  - resignal = TRUE
[13:36:57.476]  - Number of conditions: 4
[13:36:57.476]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.461] result() for MulticoreFuture ...
[13:36:57.477]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.461] result() for MulticoreFuture ... done
[13:36:57.477]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.461] result() for MulticoreFuture ...
[13:36:57.477]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:57.462] result() for MulticoreFuture ... done
[13:36:57.477] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.477] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.478] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.479] - globals found: [2] ‘{’, ‘pkg’
[13:36:57.479] Searching for globals ... DONE
[13:36:57.479] Resolving globals: TRUE
[13:36:57.479] Resolving any globals that are futures ...
[13:36:57.479] - globals: [2] ‘{’, ‘pkg’
[13:36:57.479] Resolving any globals that are futures ... DONE
[13:36:57.480] Resolving futures part of globals (recursively) ...
[13:36:57.480] resolve() on list ...
[13:36:57.480]  recursive: 99
[13:36:57.480]  length: 1
[13:36:57.480]  elements: ‘pkg’
[13:36:57.481]  length: 0 (resolved future 1)
[13:36:57.481] resolve() on list ... DONE
[13:36:57.481] - globals: [1] ‘pkg’
[13:36:57.481] Resolving futures part of globals (recursively) ... DONE
[13:36:57.481] The total size of the 1 globals is 112 bytes (112 bytes)
[13:36:57.482] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:36:57.482] - globals: [1] ‘pkg’
[13:36:57.482] 
[13:36:57.482] getGlobalsAndPackages() ... DONE
[13:36:57.482] Packages needed by the future expression (n = 0): <none>
[13:36:57.483] Packages needed by future strategies (n = 0): <none>
[13:36:57.483] {
[13:36:57.483]     {
[13:36:57.483]         {
[13:36:57.483]             ...future.startTime <- base::Sys.time()
[13:36:57.483]             {
[13:36:57.483]                 {
[13:36:57.483]                   {
[13:36:57.483]                     base::local({
[13:36:57.483]                       has_future <- base::requireNamespace("future", 
[13:36:57.483]                         quietly = TRUE)
[13:36:57.483]                       if (has_future) {
[13:36:57.483]                         ns <- base::getNamespace("future")
[13:36:57.483]                         version <- ns[[".package"]][["version"]]
[13:36:57.483]                         if (is.null(version)) 
[13:36:57.483]                           version <- utils::packageVersion("future")
[13:36:57.483]                       }
[13:36:57.483]                       else {
[13:36:57.483]                         version <- NULL
[13:36:57.483]                       }
[13:36:57.483]                       if (!has_future || version < "1.8.0") {
[13:36:57.483]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.483]                           "", base::R.version$version.string), 
[13:36:57.483]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:57.483]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.483]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.483]                             "release", "version")], collapse = " "), 
[13:36:57.483]                           hostname = base::Sys.info()[["nodename"]])
[13:36:57.483]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.483]                           info)
[13:36:57.483]                         info <- base::paste(info, collapse = "; ")
[13:36:57.483]                         if (!has_future) {
[13:36:57.483]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.483]                             info)
[13:36:57.483]                         }
[13:36:57.483]                         else {
[13:36:57.483]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.483]                             info, version)
[13:36:57.483]                         }
[13:36:57.483]                         base::stop(msg)
[13:36:57.483]                       }
[13:36:57.483]                     })
[13:36:57.483]                   }
[13:36:57.483]                   ...future.strategy.old <- future::plan("list")
[13:36:57.483]                   options(future.plan = NULL)
[13:36:57.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.483]                 }
[13:36:57.483]                 ...future.workdir <- getwd()
[13:36:57.483]             }
[13:36:57.483]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.483]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.483]         }
[13:36:57.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.483]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.483]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.483]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.483]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.483]             base::names(...future.oldOptions))
[13:36:57.483]     }
[13:36:57.483]     if (FALSE) {
[13:36:57.483]     }
[13:36:57.483]     else {
[13:36:57.483]         if (TRUE) {
[13:36:57.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.483]                 open = "w")
[13:36:57.483]         }
[13:36:57.483]         else {
[13:36:57.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.483]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.483]         }
[13:36:57.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.483]             base::sink(type = "output", split = FALSE)
[13:36:57.483]             base::close(...future.stdout)
[13:36:57.483]         }, add = TRUE)
[13:36:57.483]     }
[13:36:57.483]     ...future.frame <- base::sys.nframe()
[13:36:57.483]     ...future.conditions <- base::list()
[13:36:57.483]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.483]     if (FALSE) {
[13:36:57.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.483]     }
[13:36:57.483]     ...future.result <- base::tryCatch({
[13:36:57.483]         base::withCallingHandlers({
[13:36:57.483]             ...future.value <- base::withVisible(base::local({
[13:36:57.483]                 pkg
[13:36:57.483]             }))
[13:36:57.483]             future::FutureResult(value = ...future.value$value, 
[13:36:57.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.483]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.483]                     ...future.globalenv.names))
[13:36:57.483]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.483]         }, condition = base::local({
[13:36:57.483]             c <- base::c
[13:36:57.483]             inherits <- base::inherits
[13:36:57.483]             invokeRestart <- base::invokeRestart
[13:36:57.483]             length <- base::length
[13:36:57.483]             list <- base::list
[13:36:57.483]             seq.int <- base::seq.int
[13:36:57.483]             signalCondition <- base::signalCondition
[13:36:57.483]             sys.calls <- base::sys.calls
[13:36:57.483]             `[[` <- base::`[[`
[13:36:57.483]             `+` <- base::`+`
[13:36:57.483]             `<<-` <- base::`<<-`
[13:36:57.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.483]                   3L)]
[13:36:57.483]             }
[13:36:57.483]             function(cond) {
[13:36:57.483]                 is_error <- inherits(cond, "error")
[13:36:57.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.483]                   NULL)
[13:36:57.483]                 if (is_error) {
[13:36:57.483]                   sessionInformation <- function() {
[13:36:57.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.483]                       search = base::search(), system = base::Sys.info())
[13:36:57.483]                   }
[13:36:57.483]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.483]                     cond$call), session = sessionInformation(), 
[13:36:57.483]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.483]                   signalCondition(cond)
[13:36:57.483]                 }
[13:36:57.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.483]                 "immediateCondition"))) {
[13:36:57.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.483]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.483]                   if (TRUE && !signal) {
[13:36:57.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.483]                     {
[13:36:57.483]                       inherits <- base::inherits
[13:36:57.483]                       invokeRestart <- base::invokeRestart
[13:36:57.483]                       is.null <- base::is.null
[13:36:57.483]                       muffled <- FALSE
[13:36:57.483]                       if (inherits(cond, "message")) {
[13:36:57.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.483]                         if (muffled) 
[13:36:57.483]                           invokeRestart("muffleMessage")
[13:36:57.483]                       }
[13:36:57.483]                       else if (inherits(cond, "warning")) {
[13:36:57.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.483]                         if (muffled) 
[13:36:57.483]                           invokeRestart("muffleWarning")
[13:36:57.483]                       }
[13:36:57.483]                       else if (inherits(cond, "condition")) {
[13:36:57.483]                         if (!is.null(pattern)) {
[13:36:57.483]                           computeRestarts <- base::computeRestarts
[13:36:57.483]                           grepl <- base::grepl
[13:36:57.483]                           restarts <- computeRestarts(cond)
[13:36:57.483]                           for (restart in restarts) {
[13:36:57.483]                             name <- restart$name
[13:36:57.483]                             if (is.null(name)) 
[13:36:57.483]                               next
[13:36:57.483]                             if (!grepl(pattern, name)) 
[13:36:57.483]                               next
[13:36:57.483]                             invokeRestart(restart)
[13:36:57.483]                             muffled <- TRUE
[13:36:57.483]                             break
[13:36:57.483]                           }
[13:36:57.483]                         }
[13:36:57.483]                       }
[13:36:57.483]                       invisible(muffled)
[13:36:57.483]                     }
[13:36:57.483]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.483]                   }
[13:36:57.483]                 }
[13:36:57.483]                 else {
[13:36:57.483]                   if (TRUE) {
[13:36:57.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.483]                     {
[13:36:57.483]                       inherits <- base::inherits
[13:36:57.483]                       invokeRestart <- base::invokeRestart
[13:36:57.483]                       is.null <- base::is.null
[13:36:57.483]                       muffled <- FALSE
[13:36:57.483]                       if (inherits(cond, "message")) {
[13:36:57.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.483]                         if (muffled) 
[13:36:57.483]                           invokeRestart("muffleMessage")
[13:36:57.483]                       }
[13:36:57.483]                       else if (inherits(cond, "warning")) {
[13:36:57.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.483]                         if (muffled) 
[13:36:57.483]                           invokeRestart("muffleWarning")
[13:36:57.483]                       }
[13:36:57.483]                       else if (inherits(cond, "condition")) {
[13:36:57.483]                         if (!is.null(pattern)) {
[13:36:57.483]                           computeRestarts <- base::computeRestarts
[13:36:57.483]                           grepl <- base::grepl
[13:36:57.483]                           restarts <- computeRestarts(cond)
[13:36:57.483]                           for (restart in restarts) {
[13:36:57.483]                             name <- restart$name
[13:36:57.483]                             if (is.null(name)) 
[13:36:57.483]                               next
[13:36:57.483]                             if (!grepl(pattern, name)) 
[13:36:57.483]                               next
[13:36:57.483]                             invokeRestart(restart)
[13:36:57.483]                             muffled <- TRUE
[13:36:57.483]                             break
[13:36:57.483]                           }
[13:36:57.483]                         }
[13:36:57.483]                       }
[13:36:57.483]                       invisible(muffled)
[13:36:57.483]                     }
[13:36:57.483]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.483]                   }
[13:36:57.483]                 }
[13:36:57.483]             }
[13:36:57.483]         }))
[13:36:57.483]     }, error = function(ex) {
[13:36:57.483]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.483]                 ...future.rng), started = ...future.startTime, 
[13:36:57.483]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.483]             version = "1.8"), class = "FutureResult")
[13:36:57.483]     }, finally = {
[13:36:57.483]         if (!identical(...future.workdir, getwd())) 
[13:36:57.483]             setwd(...future.workdir)
[13:36:57.483]         {
[13:36:57.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.483]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.483]             }
[13:36:57.483]             base::options(...future.oldOptions)
[13:36:57.483]             if (.Platform$OS.type == "windows") {
[13:36:57.483]                 old_names <- names(...future.oldEnvVars)
[13:36:57.483]                 envs <- base::Sys.getenv()
[13:36:57.483]                 names <- names(envs)
[13:36:57.483]                 common <- intersect(names, old_names)
[13:36:57.483]                 added <- setdiff(names, old_names)
[13:36:57.483]                 removed <- setdiff(old_names, names)
[13:36:57.483]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.483]                   envs[common]]
[13:36:57.483]                 NAMES <- toupper(changed)
[13:36:57.483]                 args <- list()
[13:36:57.483]                 for (kk in seq_along(NAMES)) {
[13:36:57.483]                   name <- changed[[kk]]
[13:36:57.483]                   NAME <- NAMES[[kk]]
[13:36:57.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.483]                     next
[13:36:57.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.483]                 }
[13:36:57.483]                 NAMES <- toupper(added)
[13:36:57.483]                 for (kk in seq_along(NAMES)) {
[13:36:57.483]                   name <- added[[kk]]
[13:36:57.483]                   NAME <- NAMES[[kk]]
[13:36:57.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.483]                     next
[13:36:57.483]                   args[[name]] <- ""
[13:36:57.483]                 }
[13:36:57.483]                 NAMES <- toupper(removed)
[13:36:57.483]                 for (kk in seq_along(NAMES)) {
[13:36:57.483]                   name <- removed[[kk]]
[13:36:57.483]                   NAME <- NAMES[[kk]]
[13:36:57.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.483]                     next
[13:36:57.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.483]                 }
[13:36:57.483]                 if (length(args) > 0) 
[13:36:57.483]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.483]             }
[13:36:57.483]             else {
[13:36:57.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.483]             }
[13:36:57.483]             {
[13:36:57.483]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.483]                   0L) {
[13:36:57.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.483]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.483]                   base::options(opts)
[13:36:57.483]                 }
[13:36:57.483]                 {
[13:36:57.483]                   {
[13:36:57.483]                     NULL
[13:36:57.483]                     RNGkind("Mersenne-Twister")
[13:36:57.483]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:57.483]                       inherits = FALSE)
[13:36:57.483]                   }
[13:36:57.483]                   options(future.plan = NULL)
[13:36:57.483]                   if (is.na(NA_character_)) 
[13:36:57.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.483]                     .init = FALSE)
[13:36:57.483]                 }
[13:36:57.483]             }
[13:36:57.483]         }
[13:36:57.483]     })
[13:36:57.483]     if (TRUE) {
[13:36:57.483]         base::sink(type = "output", split = FALSE)
[13:36:57.483]         if (TRUE) {
[13:36:57.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.483]         }
[13:36:57.483]         else {
[13:36:57.483]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.483]         }
[13:36:57.483]         base::close(...future.stdout)
[13:36:57.483]         ...future.stdout <- NULL
[13:36:57.483]     }
[13:36:57.483]     ...future.result$conditions <- ...future.conditions
[13:36:57.483]     ...future.result$finished <- base::Sys.time()
[13:36:57.483]     ...future.result
[13:36:57.483] }
[13:36:57.485] assign_globals() ...
[13:36:57.485] List of 1
[13:36:57.485]  $ pkg: chr "foo"
[13:36:57.485]  - attr(*, "where")=List of 1
[13:36:57.485]   ..$ pkg:<environment: R_EmptyEnv> 
[13:36:57.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.485]  - attr(*, "resolved")= logi TRUE
[13:36:57.485]  - attr(*, "total_size")= num 112
[13:36:57.488] - copied ‘pkg’ to environment
[13:36:57.488] assign_globals() ... done
[13:36:57.491] plan(): Setting new future strategy stack:
[13:36:57.491] List of future strategies:
[13:36:57.491] 1. sequential:
[13:36:57.491]    - args: function (..., envir = parent.frame())
[13:36:57.491]    - tweaked: FALSE
[13:36:57.491]    - call: NULL
[13:36:57.492] plan(): nbrOfWorkers() = 1
[13:36:57.493] plan(): Setting new future strategy stack:
[13:36:57.493] List of future strategies:
[13:36:57.493] 1. multicore:
[13:36:57.493]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.493]    - tweaked: FALSE
[13:36:57.493]    - call: plan(strategy)
[13:36:57.497] plan(): nbrOfWorkers() = 2
[13:36:57.497] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.498] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.498] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.500] - globals found: [3] ‘{’, ‘<-’, ‘+’
[13:36:57.500] Searching for globals ... DONE
[13:36:57.500] Resolving globals: TRUE
[13:36:57.501] Resolving any globals that are futures ...
[13:36:57.501] - globals: [3] ‘{’, ‘<-’, ‘+’
[13:36:57.501] Resolving any globals that are futures ... DONE
[13:36:57.501] 
[13:36:57.501] 
[13:36:57.501] getGlobalsAndPackages() ... DONE
[13:36:57.502] run() for ‘Future’ ...
[13:36:57.502] - state: ‘created’
[13:36:57.502] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.505] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.506]   - Field: ‘label’
[13:36:57.506]   - Field: ‘local’
[13:36:57.506]   - Field: ‘owner’
[13:36:57.506]   - Field: ‘envir’
[13:36:57.506]   - Field: ‘workers’
[13:36:57.506]   - Field: ‘packages’
[13:36:57.506]   - Field: ‘gc’
[13:36:57.506]   - Field: ‘job’
[13:36:57.507]   - Field: ‘conditions’
[13:36:57.507]   - Field: ‘expr’
[13:36:57.507]   - Field: ‘uuid’
[13:36:57.507]   - Field: ‘seed’
[13:36:57.507]   - Field: ‘version’
[13:36:57.507]   - Field: ‘result’
[13:36:57.507]   - Field: ‘asynchronous’
[13:36:57.507]   - Field: ‘calls’
[13:36:57.507]   - Field: ‘globals’
[13:36:57.507]   - Field: ‘stdout’
[13:36:57.507]   - Field: ‘earlySignal’
[13:36:57.508]   - Field: ‘lazy’
[13:36:57.508]   - Field: ‘state’
[13:36:57.508] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.508] - Launch lazy future ...
[13:36:57.508] Packages needed by the future expression (n = 0): <none>
[13:36:57.508] Packages needed by future strategies (n = 0): <none>
[13:36:57.509] {
[13:36:57.509]     {
[13:36:57.509]         {
[13:36:57.509]             ...future.startTime <- base::Sys.time()
[13:36:57.509]             {
[13:36:57.509]                 {
[13:36:57.509]                   {
[13:36:57.509]                     {
[13:36:57.509]                       base::local({
[13:36:57.509]                         has_future <- base::requireNamespace("future", 
[13:36:57.509]                           quietly = TRUE)
[13:36:57.509]                         if (has_future) {
[13:36:57.509]                           ns <- base::getNamespace("future")
[13:36:57.509]                           version <- ns[[".package"]][["version"]]
[13:36:57.509]                           if (is.null(version)) 
[13:36:57.509]                             version <- utils::packageVersion("future")
[13:36:57.509]                         }
[13:36:57.509]                         else {
[13:36:57.509]                           version <- NULL
[13:36:57.509]                         }
[13:36:57.509]                         if (!has_future || version < "1.8.0") {
[13:36:57.509]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.509]                             "", base::R.version$version.string), 
[13:36:57.509]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.509]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.509]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.509]                               "release", "version")], collapse = " "), 
[13:36:57.509]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.509]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.509]                             info)
[13:36:57.509]                           info <- base::paste(info, collapse = "; ")
[13:36:57.509]                           if (!has_future) {
[13:36:57.509]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.509]                               info)
[13:36:57.509]                           }
[13:36:57.509]                           else {
[13:36:57.509]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.509]                               info, version)
[13:36:57.509]                           }
[13:36:57.509]                           base::stop(msg)
[13:36:57.509]                         }
[13:36:57.509]                       })
[13:36:57.509]                     }
[13:36:57.509]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.509]                     base::options(mc.cores = 1L)
[13:36:57.509]                   }
[13:36:57.509]                   ...future.strategy.old <- future::plan("list")
[13:36:57.509]                   options(future.plan = NULL)
[13:36:57.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.509]                 }
[13:36:57.509]                 ...future.workdir <- getwd()
[13:36:57.509]             }
[13:36:57.509]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.509]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.509]         }
[13:36:57.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.509]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.509]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.509]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.509]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.509]             base::names(...future.oldOptions))
[13:36:57.509]     }
[13:36:57.509]     if (FALSE) {
[13:36:57.509]     }
[13:36:57.509]     else {
[13:36:57.509]         if (TRUE) {
[13:36:57.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.509]                 open = "w")
[13:36:57.509]         }
[13:36:57.509]         else {
[13:36:57.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.509]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.509]         }
[13:36:57.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.509]             base::sink(type = "output", split = FALSE)
[13:36:57.509]             base::close(...future.stdout)
[13:36:57.509]         }, add = TRUE)
[13:36:57.509]     }
[13:36:57.509]     ...future.frame <- base::sys.nframe()
[13:36:57.509]     ...future.conditions <- base::list()
[13:36:57.509]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.509]     if (FALSE) {
[13:36:57.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.509]     }
[13:36:57.509]     ...future.result <- base::tryCatch({
[13:36:57.509]         base::withCallingHandlers({
[13:36:57.509]             ...future.value <- base::withVisible(base::local({
[13:36:57.509]                 withCallingHandlers({
[13:36:57.509]                   {
[13:36:57.509]                     x <- 0
[13:36:57.509]                     x <- x + 1
[13:36:57.509]                     x
[13:36:57.509]                   }
[13:36:57.509]                 }, immediateCondition = function(cond) {
[13:36:57.509]                   save_rds <- function (object, pathname, ...) 
[13:36:57.509]                   {
[13:36:57.509]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.509]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.509]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.509]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.509]                         fi_tmp[["mtime"]])
[13:36:57.509]                     }
[13:36:57.509]                     tryCatch({
[13:36:57.509]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.509]                     }, error = function(ex) {
[13:36:57.509]                       msg <- conditionMessage(ex)
[13:36:57.509]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.509]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.509]                         fi_tmp[["mtime"]], msg)
[13:36:57.509]                       ex$message <- msg
[13:36:57.509]                       stop(ex)
[13:36:57.509]                     })
[13:36:57.509]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.509]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.509]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.509]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.509]                       fi <- file.info(pathname)
[13:36:57.509]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.509]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.509]                         fi[["size"]], fi[["mtime"]])
[13:36:57.509]                       stop(msg)
[13:36:57.509]                     }
[13:36:57.509]                     invisible(pathname)
[13:36:57.509]                   }
[13:36:57.509]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.509]                     rootPath = tempdir()) 
[13:36:57.509]                   {
[13:36:57.509]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.509]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.509]                       tmpdir = path, fileext = ".rds")
[13:36:57.509]                     save_rds(obj, file)
[13:36:57.509]                   }
[13:36:57.509]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.509]                   {
[13:36:57.509]                     inherits <- base::inherits
[13:36:57.509]                     invokeRestart <- base::invokeRestart
[13:36:57.509]                     is.null <- base::is.null
[13:36:57.509]                     muffled <- FALSE
[13:36:57.509]                     if (inherits(cond, "message")) {
[13:36:57.509]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.509]                       if (muffled) 
[13:36:57.509]                         invokeRestart("muffleMessage")
[13:36:57.509]                     }
[13:36:57.509]                     else if (inherits(cond, "warning")) {
[13:36:57.509]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.509]                       if (muffled) 
[13:36:57.509]                         invokeRestart("muffleWarning")
[13:36:57.509]                     }
[13:36:57.509]                     else if (inherits(cond, "condition")) {
[13:36:57.509]                       if (!is.null(pattern)) {
[13:36:57.509]                         computeRestarts <- base::computeRestarts
[13:36:57.509]                         grepl <- base::grepl
[13:36:57.509]                         restarts <- computeRestarts(cond)
[13:36:57.509]                         for (restart in restarts) {
[13:36:57.509]                           name <- restart$name
[13:36:57.509]                           if (is.null(name)) 
[13:36:57.509]                             next
[13:36:57.509]                           if (!grepl(pattern, name)) 
[13:36:57.509]                             next
[13:36:57.509]                           invokeRestart(restart)
[13:36:57.509]                           muffled <- TRUE
[13:36:57.509]                           break
[13:36:57.509]                         }
[13:36:57.509]                       }
[13:36:57.509]                     }
[13:36:57.509]                     invisible(muffled)
[13:36:57.509]                   }
[13:36:57.509]                   muffleCondition(cond)
[13:36:57.509]                 })
[13:36:57.509]             }))
[13:36:57.509]             future::FutureResult(value = ...future.value$value, 
[13:36:57.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.509]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.509]                     ...future.globalenv.names))
[13:36:57.509]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.509]         }, condition = base::local({
[13:36:57.509]             c <- base::c
[13:36:57.509]             inherits <- base::inherits
[13:36:57.509]             invokeRestart <- base::invokeRestart
[13:36:57.509]             length <- base::length
[13:36:57.509]             list <- base::list
[13:36:57.509]             seq.int <- base::seq.int
[13:36:57.509]             signalCondition <- base::signalCondition
[13:36:57.509]             sys.calls <- base::sys.calls
[13:36:57.509]             `[[` <- base::`[[`
[13:36:57.509]             `+` <- base::`+`
[13:36:57.509]             `<<-` <- base::`<<-`
[13:36:57.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.509]                   3L)]
[13:36:57.509]             }
[13:36:57.509]             function(cond) {
[13:36:57.509]                 is_error <- inherits(cond, "error")
[13:36:57.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.509]                   NULL)
[13:36:57.509]                 if (is_error) {
[13:36:57.509]                   sessionInformation <- function() {
[13:36:57.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.509]                       search = base::search(), system = base::Sys.info())
[13:36:57.509]                   }
[13:36:57.509]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.509]                     cond$call), session = sessionInformation(), 
[13:36:57.509]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.509]                   signalCondition(cond)
[13:36:57.509]                 }
[13:36:57.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.509]                 "immediateCondition"))) {
[13:36:57.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.509]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.509]                   if (TRUE && !signal) {
[13:36:57.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.509]                     {
[13:36:57.509]                       inherits <- base::inherits
[13:36:57.509]                       invokeRestart <- base::invokeRestart
[13:36:57.509]                       is.null <- base::is.null
[13:36:57.509]                       muffled <- FALSE
[13:36:57.509]                       if (inherits(cond, "message")) {
[13:36:57.509]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.509]                         if (muffled) 
[13:36:57.509]                           invokeRestart("muffleMessage")
[13:36:57.509]                       }
[13:36:57.509]                       else if (inherits(cond, "warning")) {
[13:36:57.509]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.509]                         if (muffled) 
[13:36:57.509]                           invokeRestart("muffleWarning")
[13:36:57.509]                       }
[13:36:57.509]                       else if (inherits(cond, "condition")) {
[13:36:57.509]                         if (!is.null(pattern)) {
[13:36:57.509]                           computeRestarts <- base::computeRestarts
[13:36:57.509]                           grepl <- base::grepl
[13:36:57.509]                           restarts <- computeRestarts(cond)
[13:36:57.509]                           for (restart in restarts) {
[13:36:57.509]                             name <- restart$name
[13:36:57.509]                             if (is.null(name)) 
[13:36:57.509]                               next
[13:36:57.509]                             if (!grepl(pattern, name)) 
[13:36:57.509]                               next
[13:36:57.509]                             invokeRestart(restart)
[13:36:57.509]                             muffled <- TRUE
[13:36:57.509]                             break
[13:36:57.509]                           }
[13:36:57.509]                         }
[13:36:57.509]                       }
[13:36:57.509]                       invisible(muffled)
[13:36:57.509]                     }
[13:36:57.509]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.509]                   }
[13:36:57.509]                 }
[13:36:57.509]                 else {
[13:36:57.509]                   if (TRUE) {
[13:36:57.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.509]                     {
[13:36:57.509]                       inherits <- base::inherits
[13:36:57.509]                       invokeRestart <- base::invokeRestart
[13:36:57.509]                       is.null <- base::is.null
[13:36:57.509]                       muffled <- FALSE
[13:36:57.509]                       if (inherits(cond, "message")) {
[13:36:57.509]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.509]                         if (muffled) 
[13:36:57.509]                           invokeRestart("muffleMessage")
[13:36:57.509]                       }
[13:36:57.509]                       else if (inherits(cond, "warning")) {
[13:36:57.509]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.509]                         if (muffled) 
[13:36:57.509]                           invokeRestart("muffleWarning")
[13:36:57.509]                       }
[13:36:57.509]                       else if (inherits(cond, "condition")) {
[13:36:57.509]                         if (!is.null(pattern)) {
[13:36:57.509]                           computeRestarts <- base::computeRestarts
[13:36:57.509]                           grepl <- base::grepl
[13:36:57.509]                           restarts <- computeRestarts(cond)
[13:36:57.509]                           for (restart in restarts) {
[13:36:57.509]                             name <- restart$name
[13:36:57.509]                             if (is.null(name)) 
[13:36:57.509]                               next
[13:36:57.509]                             if (!grepl(pattern, name)) 
[13:36:57.509]                               next
[13:36:57.509]                             invokeRestart(restart)
[13:36:57.509]                             muffled <- TRUE
[13:36:57.509]                             break
[13:36:57.509]                           }
[13:36:57.509]                         }
[13:36:57.509]                       }
[13:36:57.509]                       invisible(muffled)
[13:36:57.509]                     }
[13:36:57.509]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.509]                   }
[13:36:57.509]                 }
[13:36:57.509]             }
[13:36:57.509]         }))
[13:36:57.509]     }, error = function(ex) {
[13:36:57.509]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.509]                 ...future.rng), started = ...future.startTime, 
[13:36:57.509]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.509]             version = "1.8"), class = "FutureResult")
[13:36:57.509]     }, finally = {
[13:36:57.509]         if (!identical(...future.workdir, getwd())) 
[13:36:57.509]             setwd(...future.workdir)
[13:36:57.509]         {
[13:36:57.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.509]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.509]             }
[13:36:57.509]             base::options(...future.oldOptions)
[13:36:57.509]             if (.Platform$OS.type == "windows") {
[13:36:57.509]                 old_names <- names(...future.oldEnvVars)
[13:36:57.509]                 envs <- base::Sys.getenv()
[13:36:57.509]                 names <- names(envs)
[13:36:57.509]                 common <- intersect(names, old_names)
[13:36:57.509]                 added <- setdiff(names, old_names)
[13:36:57.509]                 removed <- setdiff(old_names, names)
[13:36:57.509]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.509]                   envs[common]]
[13:36:57.509]                 NAMES <- toupper(changed)
[13:36:57.509]                 args <- list()
[13:36:57.509]                 for (kk in seq_along(NAMES)) {
[13:36:57.509]                   name <- changed[[kk]]
[13:36:57.509]                   NAME <- NAMES[[kk]]
[13:36:57.509]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.509]                     next
[13:36:57.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.509]                 }
[13:36:57.509]                 NAMES <- toupper(added)
[13:36:57.509]                 for (kk in seq_along(NAMES)) {
[13:36:57.509]                   name <- added[[kk]]
[13:36:57.509]                   NAME <- NAMES[[kk]]
[13:36:57.509]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.509]                     next
[13:36:57.509]                   args[[name]] <- ""
[13:36:57.509]                 }
[13:36:57.509]                 NAMES <- toupper(removed)
[13:36:57.509]                 for (kk in seq_along(NAMES)) {
[13:36:57.509]                   name <- removed[[kk]]
[13:36:57.509]                   NAME <- NAMES[[kk]]
[13:36:57.509]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.509]                     next
[13:36:57.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.509]                 }
[13:36:57.509]                 if (length(args) > 0) 
[13:36:57.509]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.509]             }
[13:36:57.509]             else {
[13:36:57.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.509]             }
[13:36:57.509]             {
[13:36:57.509]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.509]                   0L) {
[13:36:57.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.509]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.509]                   base::options(opts)
[13:36:57.509]                 }
[13:36:57.509]                 {
[13:36:57.509]                   {
[13:36:57.509]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.509]                     NULL
[13:36:57.509]                   }
[13:36:57.509]                   options(future.plan = NULL)
[13:36:57.509]                   if (is.na(NA_character_)) 
[13:36:57.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.509]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.509]                     .init = FALSE)
[13:36:57.509]                 }
[13:36:57.509]             }
[13:36:57.509]         }
[13:36:57.509]     })
[13:36:57.509]     if (TRUE) {
[13:36:57.509]         base::sink(type = "output", split = FALSE)
[13:36:57.509]         if (TRUE) {
[13:36:57.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.509]         }
[13:36:57.509]         else {
[13:36:57.509]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.509]         }
[13:36:57.509]         base::close(...future.stdout)
[13:36:57.509]         ...future.stdout <- NULL
[13:36:57.509]     }
[13:36:57.509]     ...future.result$conditions <- ...future.conditions
[13:36:57.509]     ...future.result$finished <- base::Sys.time()
[13:36:57.509]     ...future.result
[13:36:57.509] }
[13:36:57.511] requestCore(): workers = 2
[13:36:57.513] MulticoreFuture started
[13:36:57.513] - Launch lazy future ... done
[13:36:57.513] run() for ‘MulticoreFuture’ ... done
[13:36:57.513] result() for MulticoreFuture ...
[13:36:57.514] plan(): Setting new future strategy stack:
[13:36:57.514] List of future strategies:
[13:36:57.514] 1. sequential:
[13:36:57.514]    - args: function (..., envir = parent.frame())
[13:36:57.514]    - tweaked: FALSE
[13:36:57.514]    - call: NULL
[13:36:57.515] plan(): nbrOfWorkers() = 1
[13:36:57.517] plan(): Setting new future strategy stack:
[13:36:57.517] List of future strategies:
[13:36:57.517] 1. multicore:
[13:36:57.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.517]    - tweaked: FALSE
[13:36:57.517]    - call: plan(strategy)
[13:36:57.522] plan(): nbrOfWorkers() = 2
[13:36:57.523] result() for MulticoreFuture ...
[13:36:57.523] result() for MulticoreFuture ... done
[13:36:57.524] result() for MulticoreFuture ... done
[13:36:57.524] result() for MulticoreFuture ...
[13:36:57.524] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.524] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.525] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.527] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:36:57.527] Searching for globals ... DONE
[13:36:57.527] Resolving globals: TRUE
[13:36:57.527] Resolving any globals that are futures ...
[13:36:57.527] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:36:57.527] Resolving any globals that are futures ... DONE
[13:36:57.528] Resolving futures part of globals (recursively) ...
[13:36:57.528] resolve() on list ...
[13:36:57.528]  recursive: 99
[13:36:57.528]  length: 1
[13:36:57.529]  elements: ‘x’
[13:36:57.529]  length: 0 (resolved future 1)
[13:36:57.529] resolve() on list ... DONE
[13:36:57.529] - globals: [1] ‘x’
[13:36:57.529] Resolving futures part of globals (recursively) ... DONE
[13:36:57.529] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:57.530] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[13:36:57.530] - globals: [1] ‘x’
[13:36:57.530] 
[13:36:57.530] getGlobalsAndPackages() ... DONE
[13:36:57.531] run() for ‘Future’ ...
[13:36:57.531] - state: ‘created’
[13:36:57.531] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.535] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.535]   - Field: ‘label’
[13:36:57.535]   - Field: ‘local’
[13:36:57.535]   - Field: ‘owner’
[13:36:57.535]   - Field: ‘envir’
[13:36:57.536]   - Field: ‘workers’
[13:36:57.536]   - Field: ‘packages’
[13:36:57.536]   - Field: ‘gc’
[13:36:57.536]   - Field: ‘job’
[13:36:57.536]   - Field: ‘conditions’
[13:36:57.536]   - Field: ‘expr’
[13:36:57.536]   - Field: ‘uuid’
[13:36:57.536]   - Field: ‘seed’
[13:36:57.537]   - Field: ‘version’
[13:36:57.539]   - Field: ‘result’
[13:36:57.540]   - Field: ‘asynchronous’
[13:36:57.540]   - Field: ‘calls’
[13:36:57.540]   - Field: ‘globals’
[13:36:57.540]   - Field: ‘stdout’
[13:36:57.540]   - Field: ‘earlySignal’
[13:36:57.540]   - Field: ‘lazy’
[13:36:57.541]   - Field: ‘state’
[13:36:57.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.541] - Launch lazy future ...
[13:36:57.541] Packages needed by the future expression (n = 0): <none>
[13:36:57.541] Packages needed by future strategies (n = 0): <none>
[13:36:57.542] {
[13:36:57.542]     {
[13:36:57.542]         {
[13:36:57.542]             ...future.startTime <- base::Sys.time()
[13:36:57.542]             {
[13:36:57.542]                 {
[13:36:57.542]                   {
[13:36:57.542]                     {
[13:36:57.542]                       base::local({
[13:36:57.542]                         has_future <- base::requireNamespace("future", 
[13:36:57.542]                           quietly = TRUE)
[13:36:57.542]                         if (has_future) {
[13:36:57.542]                           ns <- base::getNamespace("future")
[13:36:57.542]                           version <- ns[[".package"]][["version"]]
[13:36:57.542]                           if (is.null(version)) 
[13:36:57.542]                             version <- utils::packageVersion("future")
[13:36:57.542]                         }
[13:36:57.542]                         else {
[13:36:57.542]                           version <- NULL
[13:36:57.542]                         }
[13:36:57.542]                         if (!has_future || version < "1.8.0") {
[13:36:57.542]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.542]                             "", base::R.version$version.string), 
[13:36:57.542]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.542]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.542]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.542]                               "release", "version")], collapse = " "), 
[13:36:57.542]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.542]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.542]                             info)
[13:36:57.542]                           info <- base::paste(info, collapse = "; ")
[13:36:57.542]                           if (!has_future) {
[13:36:57.542]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.542]                               info)
[13:36:57.542]                           }
[13:36:57.542]                           else {
[13:36:57.542]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.542]                               info, version)
[13:36:57.542]                           }
[13:36:57.542]                           base::stop(msg)
[13:36:57.542]                         }
[13:36:57.542]                       })
[13:36:57.542]                     }
[13:36:57.542]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.542]                     base::options(mc.cores = 1L)
[13:36:57.542]                   }
[13:36:57.542]                   ...future.strategy.old <- future::plan("list")
[13:36:57.542]                   options(future.plan = NULL)
[13:36:57.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.542]                 }
[13:36:57.542]                 ...future.workdir <- getwd()
[13:36:57.542]             }
[13:36:57.542]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.542]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.542]         }
[13:36:57.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.542]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.542]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.542]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.542]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.542]             base::names(...future.oldOptions))
[13:36:57.542]     }
[13:36:57.542]     if (FALSE) {
[13:36:57.542]     }
[13:36:57.542]     else {
[13:36:57.542]         if (TRUE) {
[13:36:57.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.542]                 open = "w")
[13:36:57.542]         }
[13:36:57.542]         else {
[13:36:57.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.542]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.542]         }
[13:36:57.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.542]             base::sink(type = "output", split = FALSE)
[13:36:57.542]             base::close(...future.stdout)
[13:36:57.542]         }, add = TRUE)
[13:36:57.542]     }
[13:36:57.542]     ...future.frame <- base::sys.nframe()
[13:36:57.542]     ...future.conditions <- base::list()
[13:36:57.542]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.542]     if (FALSE) {
[13:36:57.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.542]     }
[13:36:57.542]     ...future.result <- base::tryCatch({
[13:36:57.542]         base::withCallingHandlers({
[13:36:57.542]             ...future.value <- base::withVisible(base::local({
[13:36:57.542]                 withCallingHandlers({
[13:36:57.542]                   {
[13:36:57.542]                     x <- x + 1
[13:36:57.542]                     x
[13:36:57.542]                   }
[13:36:57.542]                 }, immediateCondition = function(cond) {
[13:36:57.542]                   save_rds <- function (object, pathname, ...) 
[13:36:57.542]                   {
[13:36:57.542]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.542]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.542]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.542]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.542]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.542]                         fi_tmp[["mtime"]])
[13:36:57.542]                     }
[13:36:57.542]                     tryCatch({
[13:36:57.542]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.542]                     }, error = function(ex) {
[13:36:57.542]                       msg <- conditionMessage(ex)
[13:36:57.542]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.542]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.542]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.542]                         fi_tmp[["mtime"]], msg)
[13:36:57.542]                       ex$message <- msg
[13:36:57.542]                       stop(ex)
[13:36:57.542]                     })
[13:36:57.542]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.542]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.542]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.542]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.542]                       fi <- file.info(pathname)
[13:36:57.542]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.542]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.542]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.542]                         fi[["size"]], fi[["mtime"]])
[13:36:57.542]                       stop(msg)
[13:36:57.542]                     }
[13:36:57.542]                     invisible(pathname)
[13:36:57.542]                   }
[13:36:57.542]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.542]                     rootPath = tempdir()) 
[13:36:57.542]                   {
[13:36:57.542]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.542]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.542]                       tmpdir = path, fileext = ".rds")
[13:36:57.542]                     save_rds(obj, file)
[13:36:57.542]                   }
[13:36:57.542]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.542]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.542]                   {
[13:36:57.542]                     inherits <- base::inherits
[13:36:57.542]                     invokeRestart <- base::invokeRestart
[13:36:57.542]                     is.null <- base::is.null
[13:36:57.542]                     muffled <- FALSE
[13:36:57.542]                     if (inherits(cond, "message")) {
[13:36:57.542]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.542]                       if (muffled) 
[13:36:57.542]                         invokeRestart("muffleMessage")
[13:36:57.542]                     }
[13:36:57.542]                     else if (inherits(cond, "warning")) {
[13:36:57.542]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.542]                       if (muffled) 
[13:36:57.542]                         invokeRestart("muffleWarning")
[13:36:57.542]                     }
[13:36:57.542]                     else if (inherits(cond, "condition")) {
[13:36:57.542]                       if (!is.null(pattern)) {
[13:36:57.542]                         computeRestarts <- base::computeRestarts
[13:36:57.542]                         grepl <- base::grepl
[13:36:57.542]                         restarts <- computeRestarts(cond)
[13:36:57.542]                         for (restart in restarts) {
[13:36:57.542]                           name <- restart$name
[13:36:57.542]                           if (is.null(name)) 
[13:36:57.542]                             next
[13:36:57.542]                           if (!grepl(pattern, name)) 
[13:36:57.542]                             next
[13:36:57.542]                           invokeRestart(restart)
[13:36:57.542]                           muffled <- TRUE
[13:36:57.542]                           break
[13:36:57.542]                         }
[13:36:57.542]                       }
[13:36:57.542]                     }
[13:36:57.542]                     invisible(muffled)
[13:36:57.542]                   }
[13:36:57.542]                   muffleCondition(cond)
[13:36:57.542]                 })
[13:36:57.542]             }))
[13:36:57.542]             future::FutureResult(value = ...future.value$value, 
[13:36:57.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.542]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.542]                     ...future.globalenv.names))
[13:36:57.542]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.542]         }, condition = base::local({
[13:36:57.542]             c <- base::c
[13:36:57.542]             inherits <- base::inherits
[13:36:57.542]             invokeRestart <- base::invokeRestart
[13:36:57.542]             length <- base::length
[13:36:57.542]             list <- base::list
[13:36:57.542]             seq.int <- base::seq.int
[13:36:57.542]             signalCondition <- base::signalCondition
[13:36:57.542]             sys.calls <- base::sys.calls
[13:36:57.542]             `[[` <- base::`[[`
[13:36:57.542]             `+` <- base::`+`
[13:36:57.542]             `<<-` <- base::`<<-`
[13:36:57.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.542]                   3L)]
[13:36:57.542]             }
[13:36:57.542]             function(cond) {
[13:36:57.542]                 is_error <- inherits(cond, "error")
[13:36:57.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.542]                   NULL)
[13:36:57.542]                 if (is_error) {
[13:36:57.542]                   sessionInformation <- function() {
[13:36:57.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.542]                       search = base::search(), system = base::Sys.info())
[13:36:57.542]                   }
[13:36:57.542]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.542]                     cond$call), session = sessionInformation(), 
[13:36:57.542]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.542]                   signalCondition(cond)
[13:36:57.542]                 }
[13:36:57.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.542]                 "immediateCondition"))) {
[13:36:57.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.542]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.542]                   if (TRUE && !signal) {
[13:36:57.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.542]                     {
[13:36:57.542]                       inherits <- base::inherits
[13:36:57.542]                       invokeRestart <- base::invokeRestart
[13:36:57.542]                       is.null <- base::is.null
[13:36:57.542]                       muffled <- FALSE
[13:36:57.542]                       if (inherits(cond, "message")) {
[13:36:57.542]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.542]                         if (muffled) 
[13:36:57.542]                           invokeRestart("muffleMessage")
[13:36:57.542]                       }
[13:36:57.542]                       else if (inherits(cond, "warning")) {
[13:36:57.542]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.542]                         if (muffled) 
[13:36:57.542]                           invokeRestart("muffleWarning")
[13:36:57.542]                       }
[13:36:57.542]                       else if (inherits(cond, "condition")) {
[13:36:57.542]                         if (!is.null(pattern)) {
[13:36:57.542]                           computeRestarts <- base::computeRestarts
[13:36:57.542]                           grepl <- base::grepl
[13:36:57.542]                           restarts <- computeRestarts(cond)
[13:36:57.542]                           for (restart in restarts) {
[13:36:57.542]                             name <- restart$name
[13:36:57.542]                             if (is.null(name)) 
[13:36:57.542]                               next
[13:36:57.542]                             if (!grepl(pattern, name)) 
[13:36:57.542]                               next
[13:36:57.542]                             invokeRestart(restart)
[13:36:57.542]                             muffled <- TRUE
[13:36:57.542]                             break
[13:36:57.542]                           }
[13:36:57.542]                         }
[13:36:57.542]                       }
[13:36:57.542]                       invisible(muffled)
[13:36:57.542]                     }
[13:36:57.542]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.542]                   }
[13:36:57.542]                 }
[13:36:57.542]                 else {
[13:36:57.542]                   if (TRUE) {
[13:36:57.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.542]                     {
[13:36:57.542]                       inherits <- base::inherits
[13:36:57.542]                       invokeRestart <- base::invokeRestart
[13:36:57.542]                       is.null <- base::is.null
[13:36:57.542]                       muffled <- FALSE
[13:36:57.542]                       if (inherits(cond, "message")) {
[13:36:57.542]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.542]                         if (muffled) 
[13:36:57.542]                           invokeRestart("muffleMessage")
[13:36:57.542]                       }
[13:36:57.542]                       else if (inherits(cond, "warning")) {
[13:36:57.542]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.542]                         if (muffled) 
[13:36:57.542]                           invokeRestart("muffleWarning")
[13:36:57.542]                       }
[13:36:57.542]                       else if (inherits(cond, "condition")) {
[13:36:57.542]                         if (!is.null(pattern)) {
[13:36:57.542]                           computeRestarts <- base::computeRestarts
[13:36:57.542]                           grepl <- base::grepl
[13:36:57.542]                           restarts <- computeRestarts(cond)
[13:36:57.542]                           for (restart in restarts) {
[13:36:57.542]                             name <- restart$name
[13:36:57.542]                             if (is.null(name)) 
[13:36:57.542]                               next
[13:36:57.542]                             if (!grepl(pattern, name)) 
[13:36:57.542]                               next
[13:36:57.542]                             invokeRestart(restart)
[13:36:57.542]                             muffled <- TRUE
[13:36:57.542]                             break
[13:36:57.542]                           }
[13:36:57.542]                         }
[13:36:57.542]                       }
[13:36:57.542]                       invisible(muffled)
[13:36:57.542]                     }
[13:36:57.542]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.542]                   }
[13:36:57.542]                 }
[13:36:57.542]             }
[13:36:57.542]         }))
[13:36:57.542]     }, error = function(ex) {
[13:36:57.542]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.542]                 ...future.rng), started = ...future.startTime, 
[13:36:57.542]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.542]             version = "1.8"), class = "FutureResult")
[13:36:57.542]     }, finally = {
[13:36:57.542]         if (!identical(...future.workdir, getwd())) 
[13:36:57.542]             setwd(...future.workdir)
[13:36:57.542]         {
[13:36:57.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.542]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.542]             }
[13:36:57.542]             base::options(...future.oldOptions)
[13:36:57.542]             if (.Platform$OS.type == "windows") {
[13:36:57.542]                 old_names <- names(...future.oldEnvVars)
[13:36:57.542]                 envs <- base::Sys.getenv()
[13:36:57.542]                 names <- names(envs)
[13:36:57.542]                 common <- intersect(names, old_names)
[13:36:57.542]                 added <- setdiff(names, old_names)
[13:36:57.542]                 removed <- setdiff(old_names, names)
[13:36:57.542]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.542]                   envs[common]]
[13:36:57.542]                 NAMES <- toupper(changed)
[13:36:57.542]                 args <- list()
[13:36:57.542]                 for (kk in seq_along(NAMES)) {
[13:36:57.542]                   name <- changed[[kk]]
[13:36:57.542]                   NAME <- NAMES[[kk]]
[13:36:57.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.542]                     next
[13:36:57.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.542]                 }
[13:36:57.542]                 NAMES <- toupper(added)
[13:36:57.542]                 for (kk in seq_along(NAMES)) {
[13:36:57.542]                   name <- added[[kk]]
[13:36:57.542]                   NAME <- NAMES[[kk]]
[13:36:57.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.542]                     next
[13:36:57.542]                   args[[name]] <- ""
[13:36:57.542]                 }
[13:36:57.542]                 NAMES <- toupper(removed)
[13:36:57.542]                 for (kk in seq_along(NAMES)) {
[13:36:57.542]                   name <- removed[[kk]]
[13:36:57.542]                   NAME <- NAMES[[kk]]
[13:36:57.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.542]                     next
[13:36:57.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.542]                 }
[13:36:57.542]                 if (length(args) > 0) 
[13:36:57.542]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.542]             }
[13:36:57.542]             else {
[13:36:57.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.542]             }
[13:36:57.542]             {
[13:36:57.542]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.542]                   0L) {
[13:36:57.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.542]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.542]                   base::options(opts)
[13:36:57.542]                 }
[13:36:57.542]                 {
[13:36:57.542]                   {
[13:36:57.542]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.542]                     NULL
[13:36:57.542]                   }
[13:36:57.542]                   options(future.plan = NULL)
[13:36:57.542]                   if (is.na(NA_character_)) 
[13:36:57.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.542]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.542]                     .init = FALSE)
[13:36:57.542]                 }
[13:36:57.542]             }
[13:36:57.542]         }
[13:36:57.542]     })
[13:36:57.542]     if (TRUE) {
[13:36:57.542]         base::sink(type = "output", split = FALSE)
[13:36:57.542]         if (TRUE) {
[13:36:57.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.542]         }
[13:36:57.542]         else {
[13:36:57.542]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.542]         }
[13:36:57.542]         base::close(...future.stdout)
[13:36:57.542]         ...future.stdout <- NULL
[13:36:57.542]     }
[13:36:57.542]     ...future.result$conditions <- ...future.conditions
[13:36:57.542]     ...future.result$finished <- base::Sys.time()
[13:36:57.542]     ...future.result
[13:36:57.542] }
[13:36:57.544] assign_globals() ...
[13:36:57.544] List of 1
[13:36:57.544]  $ x: num 1
[13:36:57.544]  - attr(*, "where")=List of 1
[13:36:57.544]   ..$ x:<environment: R_EmptyEnv> 
[13:36:57.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.544]  - attr(*, "resolved")= logi TRUE
[13:36:57.544]  - attr(*, "total_size")= num 56
[13:36:57.544]  - attr(*, "already-done")= logi TRUE
[13:36:57.548] - copied ‘x’ to environment
[13:36:57.548] assign_globals() ... done
[13:36:57.548] requestCore(): workers = 2
[13:36:57.550] MulticoreFuture started
[13:36:57.551] - Launch lazy future ... done
[13:36:57.551] run() for ‘MulticoreFuture’ ... done
[13:36:57.551] plan(): Setting new future strategy stack:
[13:36:57.552] result() for MulticoreFuture ...
[13:36:57.552] List of future strategies:
[13:36:57.552] 1. sequential:
[13:36:57.552]    - args: function (..., envir = parent.frame())
[13:36:57.552]    - tweaked: FALSE
[13:36:57.552]    - call: NULL
[13:36:57.553] plan(): nbrOfWorkers() = 1
[13:36:57.556] plan(): Setting new future strategy stack:
[13:36:57.556] List of future strategies:
[13:36:57.556] 1. multicore:
[13:36:57.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.556]    - tweaked: FALSE
[13:36:57.556]    - call: plan(strategy)
[13:36:57.562] plan(): nbrOfWorkers() = 2
[13:36:57.563] result() for MulticoreFuture ...
[13:36:57.563] result() for MulticoreFuture ... done
[13:36:57.563] result() for MulticoreFuture ... done
[13:36:57.564] result() for MulticoreFuture ...
[13:36:57.564] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.564] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.565] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:57.567] - globals found: [3] ‘{’, ‘<-’, ‘x’
[13:36:57.568] Searching for globals ... DONE
[13:36:57.568] Resolving globals: TRUE
[13:36:57.568] Resolving any globals that are futures ...
[13:36:57.568] - globals: [3] ‘{’, ‘<-’, ‘x’
[13:36:57.568] Resolving any globals that are futures ... DONE
[13:36:57.569] Resolving futures part of globals (recursively) ...
[13:36:57.569] resolve() on list ...
[13:36:57.569]  recursive: 99
[13:36:57.569]  length: 1
[13:36:57.569]  elements: ‘x’
[13:36:57.569]  length: 0 (resolved future 1)
[13:36:57.570] resolve() on list ... DONE
[13:36:57.570] - globals: [1] ‘x’
[13:36:57.570] Resolving futures part of globals (recursively) ... DONE
[13:36:57.570] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[13:36:57.570] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[13:36:57.571] - globals: [1] ‘x’
[13:36:57.571] 
[13:36:57.571] getGlobalsAndPackages() ... DONE
[13:36:57.571] run() for ‘Future’ ...
[13:36:57.571] - state: ‘created’
[13:36:57.571] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:57.575] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:57.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:57.576]   - Field: ‘label’
[13:36:57.576]   - Field: ‘local’
[13:36:57.576]   - Field: ‘owner’
[13:36:57.576]   - Field: ‘envir’
[13:36:57.576]   - Field: ‘workers’
[13:36:57.576]   - Field: ‘packages’
[13:36:57.576]   - Field: ‘gc’
[13:36:57.576]   - Field: ‘job’
[13:36:57.577]   - Field: ‘conditions’
[13:36:57.577]   - Field: ‘expr’
[13:36:57.577]   - Field: ‘uuid’
[13:36:57.577]   - Field: ‘seed’
[13:36:57.577]   - Field: ‘version’
[13:36:57.577]   - Field: ‘result’
[13:36:57.577]   - Field: ‘asynchronous’
[13:36:57.577]   - Field: ‘calls’
[13:36:57.577]   - Field: ‘globals’
[13:36:57.578]   - Field: ‘stdout’
[13:36:57.578]   - Field: ‘earlySignal’
[13:36:57.578]   - Field: ‘lazy’
[13:36:57.578]   - Field: ‘state’
[13:36:57.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:57.578] - Launch lazy future ...
[13:36:57.578] Packages needed by the future expression (n = 0): <none>
[13:36:57.579] Packages needed by future strategies (n = 0): <none>
[13:36:57.579] {
[13:36:57.579]     {
[13:36:57.579]         {
[13:36:57.579]             ...future.startTime <- base::Sys.time()
[13:36:57.579]             {
[13:36:57.579]                 {
[13:36:57.579]                   {
[13:36:57.579]                     {
[13:36:57.579]                       base::local({
[13:36:57.579]                         has_future <- base::requireNamespace("future", 
[13:36:57.579]                           quietly = TRUE)
[13:36:57.579]                         if (has_future) {
[13:36:57.579]                           ns <- base::getNamespace("future")
[13:36:57.579]                           version <- ns[[".package"]][["version"]]
[13:36:57.579]                           if (is.null(version)) 
[13:36:57.579]                             version <- utils::packageVersion("future")
[13:36:57.579]                         }
[13:36:57.579]                         else {
[13:36:57.579]                           version <- NULL
[13:36:57.579]                         }
[13:36:57.579]                         if (!has_future || version < "1.8.0") {
[13:36:57.579]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:57.579]                             "", base::R.version$version.string), 
[13:36:57.579]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:57.579]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:57.579]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:57.579]                               "release", "version")], collapse = " "), 
[13:36:57.579]                             hostname = base::Sys.info()[["nodename"]])
[13:36:57.579]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:57.579]                             info)
[13:36:57.579]                           info <- base::paste(info, collapse = "; ")
[13:36:57.579]                           if (!has_future) {
[13:36:57.579]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:57.579]                               info)
[13:36:57.579]                           }
[13:36:57.579]                           else {
[13:36:57.579]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:57.579]                               info, version)
[13:36:57.579]                           }
[13:36:57.579]                           base::stop(msg)
[13:36:57.579]                         }
[13:36:57.579]                       })
[13:36:57.579]                     }
[13:36:57.579]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:57.579]                     base::options(mc.cores = 1L)
[13:36:57.579]                   }
[13:36:57.579]                   ...future.strategy.old <- future::plan("list")
[13:36:57.579]                   options(future.plan = NULL)
[13:36:57.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:57.579]                 }
[13:36:57.579]                 ...future.workdir <- getwd()
[13:36:57.579]             }
[13:36:57.579]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:57.579]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:57.579]         }
[13:36:57.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:57.579]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:57.579]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:57.579]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:57.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:57.579]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:57.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:57.579]             base::names(...future.oldOptions))
[13:36:57.579]     }
[13:36:57.579]     if (FALSE) {
[13:36:57.579]     }
[13:36:57.579]     else {
[13:36:57.579]         if (TRUE) {
[13:36:57.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:57.579]                 open = "w")
[13:36:57.579]         }
[13:36:57.579]         else {
[13:36:57.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:57.579]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:57.579]         }
[13:36:57.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:57.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:57.579]             base::sink(type = "output", split = FALSE)
[13:36:57.579]             base::close(...future.stdout)
[13:36:57.579]         }, add = TRUE)
[13:36:57.579]     }
[13:36:57.579]     ...future.frame <- base::sys.nframe()
[13:36:57.579]     ...future.conditions <- base::list()
[13:36:57.579]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:57.579]     if (FALSE) {
[13:36:57.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:57.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:57.579]     }
[13:36:57.579]     ...future.result <- base::tryCatch({
[13:36:57.579]         base::withCallingHandlers({
[13:36:57.579]             ...future.value <- base::withVisible(base::local({
[13:36:57.579]                 withCallingHandlers({
[13:36:57.579]                   {
[13:36:57.579]                     x <- x()
[13:36:57.579]                     x
[13:36:57.579]                   }
[13:36:57.579]                 }, immediateCondition = function(cond) {
[13:36:57.579]                   save_rds <- function (object, pathname, ...) 
[13:36:57.579]                   {
[13:36:57.579]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:57.579]                     if (file_test("-f", pathname_tmp)) {
[13:36:57.579]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.579]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:57.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.579]                         fi_tmp[["mtime"]])
[13:36:57.579]                     }
[13:36:57.579]                     tryCatch({
[13:36:57.579]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:57.579]                     }, error = function(ex) {
[13:36:57.579]                       msg <- conditionMessage(ex)
[13:36:57.579]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.579]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:57.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.579]                         fi_tmp[["mtime"]], msg)
[13:36:57.579]                       ex$message <- msg
[13:36:57.579]                       stop(ex)
[13:36:57.579]                     })
[13:36:57.579]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:57.579]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:57.579]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:57.579]                       fi_tmp <- file.info(pathname_tmp)
[13:36:57.579]                       fi <- file.info(pathname)
[13:36:57.579]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:57.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:57.579]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:57.579]                         fi[["size"]], fi[["mtime"]])
[13:36:57.579]                       stop(msg)
[13:36:57.579]                     }
[13:36:57.579]                     invisible(pathname)
[13:36:57.579]                   }
[13:36:57.579]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:57.579]                     rootPath = tempdir()) 
[13:36:57.579]                   {
[13:36:57.579]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:57.579]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:57.579]                       tmpdir = path, fileext = ".rds")
[13:36:57.579]                     save_rds(obj, file)
[13:36:57.579]                   }
[13:36:57.579]                   saveImmediateCondition(cond, path = "/tmp/RtmpeUOKhS/.future/immediateConditions")
[13:36:57.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.579]                   {
[13:36:57.579]                     inherits <- base::inherits
[13:36:57.579]                     invokeRestart <- base::invokeRestart
[13:36:57.579]                     is.null <- base::is.null
[13:36:57.579]                     muffled <- FALSE
[13:36:57.579]                     if (inherits(cond, "message")) {
[13:36:57.579]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:57.579]                       if (muffled) 
[13:36:57.579]                         invokeRestart("muffleMessage")
[13:36:57.579]                     }
[13:36:57.579]                     else if (inherits(cond, "warning")) {
[13:36:57.579]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:57.579]                       if (muffled) 
[13:36:57.579]                         invokeRestart("muffleWarning")
[13:36:57.579]                     }
[13:36:57.579]                     else if (inherits(cond, "condition")) {
[13:36:57.579]                       if (!is.null(pattern)) {
[13:36:57.579]                         computeRestarts <- base::computeRestarts
[13:36:57.579]                         grepl <- base::grepl
[13:36:57.579]                         restarts <- computeRestarts(cond)
[13:36:57.579]                         for (restart in restarts) {
[13:36:57.579]                           name <- restart$name
[13:36:57.579]                           if (is.null(name)) 
[13:36:57.579]                             next
[13:36:57.579]                           if (!grepl(pattern, name)) 
[13:36:57.579]                             next
[13:36:57.579]                           invokeRestart(restart)
[13:36:57.579]                           muffled <- TRUE
[13:36:57.579]                           break
[13:36:57.579]                         }
[13:36:57.579]                       }
[13:36:57.579]                     }
[13:36:57.579]                     invisible(muffled)
[13:36:57.579]                   }
[13:36:57.579]                   muffleCondition(cond)
[13:36:57.579]                 })
[13:36:57.579]             }))
[13:36:57.579]             future::FutureResult(value = ...future.value$value, 
[13:36:57.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.579]                   ...future.rng), globalenv = if (FALSE) 
[13:36:57.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:57.579]                     ...future.globalenv.names))
[13:36:57.579]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:57.579]         }, condition = base::local({
[13:36:57.579]             c <- base::c
[13:36:57.579]             inherits <- base::inherits
[13:36:57.579]             invokeRestart <- base::invokeRestart
[13:36:57.579]             length <- base::length
[13:36:57.579]             list <- base::list
[13:36:57.579]             seq.int <- base::seq.int
[13:36:57.579]             signalCondition <- base::signalCondition
[13:36:57.579]             sys.calls <- base::sys.calls
[13:36:57.579]             `[[` <- base::`[[`
[13:36:57.579]             `+` <- base::`+`
[13:36:57.579]             `<<-` <- base::`<<-`
[13:36:57.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:57.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:57.579]                   3L)]
[13:36:57.579]             }
[13:36:57.579]             function(cond) {
[13:36:57.579]                 is_error <- inherits(cond, "error")
[13:36:57.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:57.579]                   NULL)
[13:36:57.579]                 if (is_error) {
[13:36:57.579]                   sessionInformation <- function() {
[13:36:57.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:57.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:57.579]                       search = base::search(), system = base::Sys.info())
[13:36:57.579]                   }
[13:36:57.579]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:57.579]                     cond$call), session = sessionInformation(), 
[13:36:57.579]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:57.579]                   signalCondition(cond)
[13:36:57.579]                 }
[13:36:57.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:57.579]                 "immediateCondition"))) {
[13:36:57.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:57.579]                   ...future.conditions[[length(...future.conditions) + 
[13:36:57.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:57.579]                   if (TRUE && !signal) {
[13:36:57.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.579]                     {
[13:36:57.579]                       inherits <- base::inherits
[13:36:57.579]                       invokeRestart <- base::invokeRestart
[13:36:57.579]                       is.null <- base::is.null
[13:36:57.579]                       muffled <- FALSE
[13:36:57.579]                       if (inherits(cond, "message")) {
[13:36:57.579]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.579]                         if (muffled) 
[13:36:57.579]                           invokeRestart("muffleMessage")
[13:36:57.579]                       }
[13:36:57.579]                       else if (inherits(cond, "warning")) {
[13:36:57.579]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.579]                         if (muffled) 
[13:36:57.579]                           invokeRestart("muffleWarning")
[13:36:57.579]                       }
[13:36:57.579]                       else if (inherits(cond, "condition")) {
[13:36:57.579]                         if (!is.null(pattern)) {
[13:36:57.579]                           computeRestarts <- base::computeRestarts
[13:36:57.579]                           grepl <- base::grepl
[13:36:57.579]                           restarts <- computeRestarts(cond)
[13:36:57.579]                           for (restart in restarts) {
[13:36:57.579]                             name <- restart$name
[13:36:57.579]                             if (is.null(name)) 
[13:36:57.579]                               next
[13:36:57.579]                             if (!grepl(pattern, name)) 
[13:36:57.579]                               next
[13:36:57.579]                             invokeRestart(restart)
[13:36:57.579]                             muffled <- TRUE
[13:36:57.579]                             break
[13:36:57.579]                           }
[13:36:57.579]                         }
[13:36:57.579]                       }
[13:36:57.579]                       invisible(muffled)
[13:36:57.579]                     }
[13:36:57.579]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.579]                   }
[13:36:57.579]                 }
[13:36:57.579]                 else {
[13:36:57.579]                   if (TRUE) {
[13:36:57.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:57.579]                     {
[13:36:57.579]                       inherits <- base::inherits
[13:36:57.579]                       invokeRestart <- base::invokeRestart
[13:36:57.579]                       is.null <- base::is.null
[13:36:57.579]                       muffled <- FALSE
[13:36:57.579]                       if (inherits(cond, "message")) {
[13:36:57.579]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:57.579]                         if (muffled) 
[13:36:57.579]                           invokeRestart("muffleMessage")
[13:36:57.579]                       }
[13:36:57.579]                       else if (inherits(cond, "warning")) {
[13:36:57.579]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:57.579]                         if (muffled) 
[13:36:57.579]                           invokeRestart("muffleWarning")
[13:36:57.579]                       }
[13:36:57.579]                       else if (inherits(cond, "condition")) {
[13:36:57.579]                         if (!is.null(pattern)) {
[13:36:57.579]                           computeRestarts <- base::computeRestarts
[13:36:57.579]                           grepl <- base::grepl
[13:36:57.579]                           restarts <- computeRestarts(cond)
[13:36:57.579]                           for (restart in restarts) {
[13:36:57.579]                             name <- restart$name
[13:36:57.579]                             if (is.null(name)) 
[13:36:57.579]                               next
[13:36:57.579]                             if (!grepl(pattern, name)) 
[13:36:57.579]                               next
[13:36:57.579]                             invokeRestart(restart)
[13:36:57.579]                             muffled <- TRUE
[13:36:57.579]                             break
[13:36:57.579]                           }
[13:36:57.579]                         }
[13:36:57.579]                       }
[13:36:57.579]                       invisible(muffled)
[13:36:57.579]                     }
[13:36:57.579]                     muffleCondition(cond, pattern = "^muffle")
[13:36:57.579]                   }
[13:36:57.579]                 }
[13:36:57.579]             }
[13:36:57.579]         }))
[13:36:57.579]     }, error = function(ex) {
[13:36:57.579]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:57.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:57.579]                 ...future.rng), started = ...future.startTime, 
[13:36:57.579]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:57.579]             version = "1.8"), class = "FutureResult")
[13:36:57.579]     }, finally = {
[13:36:57.579]         if (!identical(...future.workdir, getwd())) 
[13:36:57.579]             setwd(...future.workdir)
[13:36:57.579]         {
[13:36:57.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:57.579]                 ...future.oldOptions$nwarnings <- NULL
[13:36:57.579]             }
[13:36:57.579]             base::options(...future.oldOptions)
[13:36:57.579]             if (.Platform$OS.type == "windows") {
[13:36:57.579]                 old_names <- names(...future.oldEnvVars)
[13:36:57.579]                 envs <- base::Sys.getenv()
[13:36:57.579]                 names <- names(envs)
[13:36:57.579]                 common <- intersect(names, old_names)
[13:36:57.579]                 added <- setdiff(names, old_names)
[13:36:57.579]                 removed <- setdiff(old_names, names)
[13:36:57.579]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:57.579]                   envs[common]]
[13:36:57.579]                 NAMES <- toupper(changed)
[13:36:57.579]                 args <- list()
[13:36:57.579]                 for (kk in seq_along(NAMES)) {
[13:36:57.579]                   name <- changed[[kk]]
[13:36:57.579]                   NAME <- NAMES[[kk]]
[13:36:57.579]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.579]                     next
[13:36:57.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.579]                 }
[13:36:57.579]                 NAMES <- toupper(added)
[13:36:57.579]                 for (kk in seq_along(NAMES)) {
[13:36:57.579]                   name <- added[[kk]]
[13:36:57.579]                   NAME <- NAMES[[kk]]
[13:36:57.579]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.579]                     next
[13:36:57.579]                   args[[name]] <- ""
[13:36:57.579]                 }
[13:36:57.579]                 NAMES <- toupper(removed)
[13:36:57.579]                 for (kk in seq_along(NAMES)) {
[13:36:57.579]                   name <- removed[[kk]]
[13:36:57.579]                   NAME <- NAMES[[kk]]
[13:36:57.579]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:57.579]                     next
[13:36:57.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:57.579]                 }
[13:36:57.579]                 if (length(args) > 0) 
[13:36:57.579]                   base::do.call(base::Sys.setenv, args = args)
[13:36:57.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:57.579]             }
[13:36:57.579]             else {
[13:36:57.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:57.579]             }
[13:36:57.579]             {
[13:36:57.579]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:57.579]                   0L) {
[13:36:57.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:57.579]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:57.579]                   base::options(opts)
[13:36:57.579]                 }
[13:36:57.579]                 {
[13:36:57.579]                   {
[13:36:57.579]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:57.579]                     NULL
[13:36:57.579]                   }
[13:36:57.579]                   options(future.plan = NULL)
[13:36:57.579]                   if (is.na(NA_character_)) 
[13:36:57.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:57.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:57.579]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:57.579]                     .init = FALSE)
[13:36:57.579]                 }
[13:36:57.579]             }
[13:36:57.579]         }
[13:36:57.579]     })
[13:36:57.579]     if (TRUE) {
[13:36:57.579]         base::sink(type = "output", split = FALSE)
[13:36:57.579]         if (TRUE) {
[13:36:57.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:57.579]         }
[13:36:57.579]         else {
[13:36:57.579]             ...future.result["stdout"] <- base::list(NULL)
[13:36:57.579]         }
[13:36:57.579]         base::close(...future.stdout)
[13:36:57.579]         ...future.stdout <- NULL
[13:36:57.579]     }
[13:36:57.579]     ...future.result$conditions <- ...future.conditions
[13:36:57.579]     ...future.result$finished <- base::Sys.time()
[13:36:57.579]     ...future.result
[13:36:57.579] }
[13:36:57.582] assign_globals() ...
[13:36:57.582] List of 1
[13:36:57.582]  $ x:function ()  
[13:36:57.582]  - attr(*, "where")=List of 1
[13:36:57.582]   ..$ x:<environment: R_EmptyEnv> 
[13:36:57.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:57.582]  - attr(*, "resolved")= logi TRUE
[13:36:57.582]  - attr(*, "total_size")= num 1032
[13:36:57.582]  - attr(*, "already-done")= logi TRUE
[13:36:57.585] - reassign environment for ‘x’
[13:36:57.585] - copied ‘x’ to environment
[13:36:57.585] assign_globals() ... done
[13:36:57.585] requestCore(): workers = 2
[13:36:57.587] MulticoreFuture started
[13:36:57.587] - Launch lazy future ... done
[13:36:57.587] run() for ‘MulticoreFuture’ ... done
[13:36:57.588] result() for MulticoreFuture ...
[13:36:57.588] plan(): Setting new future strategy stack:
[13:36:57.588] List of future strategies:
[13:36:57.588] 1. sequential:
[13:36:57.588]    - args: function (..., envir = parent.frame())
[13:36:57.588]    - tweaked: FALSE
[13:36:57.588]    - call: NULL
[13:36:57.589] plan(): nbrOfWorkers() = 1
[13:36:57.591] plan(): Setting new future strategy stack:
[13:36:57.592] List of future strategies:
[13:36:57.592] 1. multicore:
[13:36:57.592]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:57.592]    - tweaked: FALSE
[13:36:57.592]    - call: plan(strategy)
[13:36:57.602] plan(): nbrOfWorkers() = 2
[13:36:57.603] result() for MulticoreFuture ...
[13:36:57.604] result() for MulticoreFuture ... done
[13:36:57.604] result() for MulticoreFuture ... done
[13:36:57.604] result() for MulticoreFuture ...
[13:36:57.604] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[13:36:57.609] plan(): Setting new future strategy stack:
[13:36:57.609] List of future strategies:
[13:36:57.609] 1. multisession:
[13:36:57.609]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:57.609]    - tweaked: FALSE
[13:36:57.609]    - call: plan(strategy)
[13:36:57.610] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:36:57.610] multisession:
[13:36:57.610] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:57.610] - tweaked: FALSE
[13:36:57.610] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:57.617] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:57.618] Not searching for globals
[13:36:57.618] - globals: [0] <none>
[13:36:57.618] getGlobalsAndPackages() ... DONE
[13:36:57.619] [local output] makeClusterPSOCK() ...
[13:36:57.665] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:36:57.666] [local output] Base port: 11357
[13:36:57.666] [local output] Getting setup options for 2 cluster nodes ...
[13:36:57.667] [local output]  - Node 1 of 2 ...
[13:36:57.667] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:57.668] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpeUOKhS/worker.rank=1.parallelly.parent=85251.14d031f095b13.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpeUOKhS/worker.rank=1.parallelly.parent=85251.14d031f095b13.pid")'’
[13:36:57.857] - Possible to infer worker's PID: TRUE
[13:36:57.858] [local output] Rscript port: 11357

[13:36:57.858] [local output]  - Node 2 of 2 ...
[13:36:57.859] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:57.859] [local output] Rscript port: 11357

[13:36:57.860] [local output] Getting setup options for 2 cluster nodes ... done
[13:36:57.860] [local output]  - Parallel setup requested for some PSOCK nodes
[13:36:57.860] [local output] Setting up PSOCK nodes in parallel
[13:36:57.860] List of 36
[13:36:57.860]  $ worker          : chr "localhost"
[13:36:57.860]   ..- attr(*, "localhost")= logi TRUE
[13:36:57.860]  $ master          : chr "localhost"
[13:36:57.860]  $ port            : int 11357
[13:36:57.860]  $ connectTimeout  : num 120
[13:36:57.860]  $ timeout         : num 2592000
[13:36:57.860]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:36:57.860]  $ homogeneous     : logi TRUE
[13:36:57.860]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:36:57.860]  $ rscript_envs    : NULL
[13:36:57.860]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:57.860]  $ rscript_startup : NULL
[13:36:57.860]  $ rscript_sh      : chr "sh"
[13:36:57.860]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:57.860]  $ methods         : logi TRUE
[13:36:57.860]  $ socketOptions   : chr "no-delay"
[13:36:57.860]  $ useXDR          : logi FALSE
[13:36:57.860]  $ outfile         : chr "/dev/null"
[13:36:57.860]  $ renice          : int NA
[13:36:57.860]  $ rshcmd          : NULL
[13:36:57.860]  $ user            : chr(0) 
[13:36:57.860]  $ revtunnel       : logi FALSE
[13:36:57.860]  $ rshlogfile      : NULL
[13:36:57.860]  $ rshopts         : chr(0) 
[13:36:57.860]  $ rank            : int 1
[13:36:57.860]  $ manual          : logi FALSE
[13:36:57.860]  $ dryrun          : logi FALSE
[13:36:57.860]  $ quiet           : logi FALSE
[13:36:57.860]  $ setup_strategy  : chr "parallel"
[13:36:57.860]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:57.860]  $ pidfile         : chr "/tmp/RtmpeUOKhS/worker.rank=1.parallelly.parent=85251.14d031f095b13.pid"
[13:36:57.860]  $ rshcmd_label    : NULL
[13:36:57.860]  $ rsh_call        : NULL
[13:36:57.860]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:57.860]  $ localMachine    : logi TRUE
[13:36:57.860]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:36:57.860]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:36:57.860]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:36:57.860]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:36:57.860]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:36:57.860]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:36:57.860]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:36:57.860]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:36:57.860]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:36:57.860]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:36:57.860]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:36:57.860]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:36:57.860]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:36:57.860]  $ arguments       :List of 28
[13:36:57.860]   ..$ worker          : chr "localhost"
[13:36:57.860]   ..$ master          : NULL
[13:36:57.860]   ..$ port            : int 11357
[13:36:57.860]   ..$ connectTimeout  : num 120
[13:36:57.860]   ..$ timeout         : num 2592000
[13:36:57.860]   ..$ rscript         : NULL
[13:36:57.860]   ..$ homogeneous     : NULL
[13:36:57.860]   ..$ rscript_args    : NULL
[13:36:57.860]   ..$ rscript_envs    : NULL
[13:36:57.860]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:57.860]   ..$ rscript_startup : NULL
[13:36:57.860]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:36:57.860]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:57.860]   ..$ methods         : logi TRUE
[13:36:57.860]   ..$ socketOptions   : chr "no-delay"
[13:36:57.860]   ..$ useXDR          : logi FALSE
[13:36:57.860]   ..$ outfile         : chr "/dev/null"
[13:36:57.860]   ..$ renice          : int NA
[13:36:57.860]   ..$ rshcmd          : NULL
[13:36:57.860]   ..$ user            : NULL
[13:36:57.860]   ..$ revtunnel       : logi NA
[13:36:57.860]   ..$ rshlogfile      : NULL
[13:36:57.860]   ..$ rshopts         : NULL
[13:36:57.860]   ..$ rank            : int 1
[13:36:57.860]   ..$ manual          : logi FALSE
[13:36:57.860]   ..$ dryrun          : logi FALSE
[13:36:57.860]   ..$ quiet           : logi FALSE
[13:36:57.860]   ..$ setup_strategy  : chr "parallel"
[13:36:57.860]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:36:57.877] [local output] System call to launch all workers:
[13:36:57.877] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpeUOKhS/worker.rank=1.parallelly.parent=85251.14d031f095b13.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11357 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:36:57.877] [local output] Starting PSOCK main server
[13:36:57.883] [local output] Workers launched
[13:36:57.883] [local output] Waiting for workers to connect back
[13:36:57.883]  - [local output] 0 workers out of 2 ready
[13:36:58.129]  - [local output] 0 workers out of 2 ready
[13:36:58.130]  - [local output] 1 workers out of 2 ready
[13:36:58.133]  - [local output] 1 workers out of 2 ready
[13:36:58.134]  - [local output] 2 workers out of 2 ready
[13:36:58.134] [local output] Launching of workers completed
[13:36:58.134] [local output] Collecting session information from workers
[13:36:58.135] [local output]  - Worker #1 of 2
[13:36:58.135] [local output]  - Worker #2 of 2
[13:36:58.136] [local output] makeClusterPSOCK() ... done
[13:36:58.147] Packages needed by the future expression (n = 0): <none>
[13:36:58.147] Packages needed by future strategies (n = 0): <none>
[13:36:58.148] {
[13:36:58.148]     {
[13:36:58.148]         {
[13:36:58.148]             ...future.startTime <- base::Sys.time()
[13:36:58.148]             {
[13:36:58.148]                 {
[13:36:58.148]                   {
[13:36:58.148]                     {
[13:36:58.148]                       base::local({
[13:36:58.148]                         has_future <- base::requireNamespace("future", 
[13:36:58.148]                           quietly = TRUE)
[13:36:58.148]                         if (has_future) {
[13:36:58.148]                           ns <- base::getNamespace("future")
[13:36:58.148]                           version <- ns[[".package"]][["version"]]
[13:36:58.148]                           if (is.null(version)) 
[13:36:58.148]                             version <- utils::packageVersion("future")
[13:36:58.148]                         }
[13:36:58.148]                         else {
[13:36:58.148]                           version <- NULL
[13:36:58.148]                         }
[13:36:58.148]                         if (!has_future || version < "1.8.0") {
[13:36:58.148]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.148]                             "", base::R.version$version.string), 
[13:36:58.148]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.148]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.148]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.148]                               "release", "version")], collapse = " "), 
[13:36:58.148]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.148]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.148]                             info)
[13:36:58.148]                           info <- base::paste(info, collapse = "; ")
[13:36:58.148]                           if (!has_future) {
[13:36:58.148]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.148]                               info)
[13:36:58.148]                           }
[13:36:58.148]                           else {
[13:36:58.148]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.148]                               info, version)
[13:36:58.148]                           }
[13:36:58.148]                           base::stop(msg)
[13:36:58.148]                         }
[13:36:58.148]                       })
[13:36:58.148]                     }
[13:36:58.148]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.148]                     base::options(mc.cores = 1L)
[13:36:58.148]                   }
[13:36:58.148]                   ...future.strategy.old <- future::plan("list")
[13:36:58.148]                   options(future.plan = NULL)
[13:36:58.148]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.148]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.148]                 }
[13:36:58.148]                 ...future.workdir <- getwd()
[13:36:58.148]             }
[13:36:58.148]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.148]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.148]         }
[13:36:58.148]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.148]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:58.148]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.148]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.148]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.148]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.148]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.148]             base::names(...future.oldOptions))
[13:36:58.148]     }
[13:36:58.148]     if (FALSE) {
[13:36:58.148]     }
[13:36:58.148]     else {
[13:36:58.148]         if (TRUE) {
[13:36:58.148]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.148]                 open = "w")
[13:36:58.148]         }
[13:36:58.148]         else {
[13:36:58.148]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.148]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.148]         }
[13:36:58.148]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.148]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.148]             base::sink(type = "output", split = FALSE)
[13:36:58.148]             base::close(...future.stdout)
[13:36:58.148]         }, add = TRUE)
[13:36:58.148]     }
[13:36:58.148]     ...future.frame <- base::sys.nframe()
[13:36:58.148]     ...future.conditions <- base::list()
[13:36:58.148]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.148]     if (FALSE) {
[13:36:58.148]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.148]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.148]     }
[13:36:58.148]     ...future.result <- base::tryCatch({
[13:36:58.148]         base::withCallingHandlers({
[13:36:58.148]             ...future.value <- base::withVisible(base::local({
[13:36:58.148]                 ...future.makeSendCondition <- base::local({
[13:36:58.148]                   sendCondition <- NULL
[13:36:58.148]                   function(frame = 1L) {
[13:36:58.148]                     if (is.function(sendCondition)) 
[13:36:58.148]                       return(sendCondition)
[13:36:58.148]                     ns <- getNamespace("parallel")
[13:36:58.148]                     if (exists("sendData", mode = "function", 
[13:36:58.148]                       envir = ns)) {
[13:36:58.148]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.148]                         envir = ns)
[13:36:58.148]                       envir <- sys.frame(frame)
[13:36:58.148]                       master <- NULL
[13:36:58.148]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.148]                         !identical(envir, emptyenv())) {
[13:36:58.148]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.148]                           inherits = FALSE)) {
[13:36:58.148]                           master <- get("master", mode = "list", 
[13:36:58.148]                             envir = envir, inherits = FALSE)
[13:36:58.148]                           if (inherits(master, c("SOCKnode", 
[13:36:58.148]                             "SOCK0node"))) {
[13:36:58.148]                             sendCondition <<- function(cond) {
[13:36:58.148]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.148]                                 success = TRUE)
[13:36:58.148]                               parallel_sendData(master, data)
[13:36:58.148]                             }
[13:36:58.148]                             return(sendCondition)
[13:36:58.148]                           }
[13:36:58.148]                         }
[13:36:58.148]                         frame <- frame + 1L
[13:36:58.148]                         envir <- sys.frame(frame)
[13:36:58.148]                       }
[13:36:58.148]                     }
[13:36:58.148]                     sendCondition <<- function(cond) NULL
[13:36:58.148]                   }
[13:36:58.148]                 })
[13:36:58.148]                 withCallingHandlers({
[13:36:58.148]                   NA
[13:36:58.148]                 }, immediateCondition = function(cond) {
[13:36:58.148]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.148]                   sendCondition(cond)
[13:36:58.148]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.148]                   {
[13:36:58.148]                     inherits <- base::inherits
[13:36:58.148]                     invokeRestart <- base::invokeRestart
[13:36:58.148]                     is.null <- base::is.null
[13:36:58.148]                     muffled <- FALSE
[13:36:58.148]                     if (inherits(cond, "message")) {
[13:36:58.148]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.148]                       if (muffled) 
[13:36:58.148]                         invokeRestart("muffleMessage")
[13:36:58.148]                     }
[13:36:58.148]                     else if (inherits(cond, "warning")) {
[13:36:58.148]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.148]                       if (muffled) 
[13:36:58.148]                         invokeRestart("muffleWarning")
[13:36:58.148]                     }
[13:36:58.148]                     else if (inherits(cond, "condition")) {
[13:36:58.148]                       if (!is.null(pattern)) {
[13:36:58.148]                         computeRestarts <- base::computeRestarts
[13:36:58.148]                         grepl <- base::grepl
[13:36:58.148]                         restarts <- computeRestarts(cond)
[13:36:58.148]                         for (restart in restarts) {
[13:36:58.148]                           name <- restart$name
[13:36:58.148]                           if (is.null(name)) 
[13:36:58.148]                             next
[13:36:58.148]                           if (!grepl(pattern, name)) 
[13:36:58.148]                             next
[13:36:58.148]                           invokeRestart(restart)
[13:36:58.148]                           muffled <- TRUE
[13:36:58.148]                           break
[13:36:58.148]                         }
[13:36:58.148]                       }
[13:36:58.148]                     }
[13:36:58.148]                     invisible(muffled)
[13:36:58.148]                   }
[13:36:58.148]                   muffleCondition(cond)
[13:36:58.148]                 })
[13:36:58.148]             }))
[13:36:58.148]             future::FutureResult(value = ...future.value$value, 
[13:36:58.148]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.148]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.148]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.148]                     ...future.globalenv.names))
[13:36:58.148]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.148]         }, condition = base::local({
[13:36:58.148]             c <- base::c
[13:36:58.148]             inherits <- base::inherits
[13:36:58.148]             invokeRestart <- base::invokeRestart
[13:36:58.148]             length <- base::length
[13:36:58.148]             list <- base::list
[13:36:58.148]             seq.int <- base::seq.int
[13:36:58.148]             signalCondition <- base::signalCondition
[13:36:58.148]             sys.calls <- base::sys.calls
[13:36:58.148]             `[[` <- base::`[[`
[13:36:58.148]             `+` <- base::`+`
[13:36:58.148]             `<<-` <- base::`<<-`
[13:36:58.148]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.148]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.148]                   3L)]
[13:36:58.148]             }
[13:36:58.148]             function(cond) {
[13:36:58.148]                 is_error <- inherits(cond, "error")
[13:36:58.148]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.148]                   NULL)
[13:36:58.148]                 if (is_error) {
[13:36:58.148]                   sessionInformation <- function() {
[13:36:58.148]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.148]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.148]                       search = base::search(), system = base::Sys.info())
[13:36:58.148]                   }
[13:36:58.148]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.148]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.148]                     cond$call), session = sessionInformation(), 
[13:36:58.148]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.148]                   signalCondition(cond)
[13:36:58.148]                 }
[13:36:58.148]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.148]                 "immediateCondition"))) {
[13:36:58.148]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.148]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.148]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.148]                   if (TRUE && !signal) {
[13:36:58.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.148]                     {
[13:36:58.148]                       inherits <- base::inherits
[13:36:58.148]                       invokeRestart <- base::invokeRestart
[13:36:58.148]                       is.null <- base::is.null
[13:36:58.148]                       muffled <- FALSE
[13:36:58.148]                       if (inherits(cond, "message")) {
[13:36:58.148]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.148]                         if (muffled) 
[13:36:58.148]                           invokeRestart("muffleMessage")
[13:36:58.148]                       }
[13:36:58.148]                       else if (inherits(cond, "warning")) {
[13:36:58.148]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.148]                         if (muffled) 
[13:36:58.148]                           invokeRestart("muffleWarning")
[13:36:58.148]                       }
[13:36:58.148]                       else if (inherits(cond, "condition")) {
[13:36:58.148]                         if (!is.null(pattern)) {
[13:36:58.148]                           computeRestarts <- base::computeRestarts
[13:36:58.148]                           grepl <- base::grepl
[13:36:58.148]                           restarts <- computeRestarts(cond)
[13:36:58.148]                           for (restart in restarts) {
[13:36:58.148]                             name <- restart$name
[13:36:58.148]                             if (is.null(name)) 
[13:36:58.148]                               next
[13:36:58.148]                             if (!grepl(pattern, name)) 
[13:36:58.148]                               next
[13:36:58.148]                             invokeRestart(restart)
[13:36:58.148]                             muffled <- TRUE
[13:36:58.148]                             break
[13:36:58.148]                           }
[13:36:58.148]                         }
[13:36:58.148]                       }
[13:36:58.148]                       invisible(muffled)
[13:36:58.148]                     }
[13:36:58.148]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.148]                   }
[13:36:58.148]                 }
[13:36:58.148]                 else {
[13:36:58.148]                   if (TRUE) {
[13:36:58.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.148]                     {
[13:36:58.148]                       inherits <- base::inherits
[13:36:58.148]                       invokeRestart <- base::invokeRestart
[13:36:58.148]                       is.null <- base::is.null
[13:36:58.148]                       muffled <- FALSE
[13:36:58.148]                       if (inherits(cond, "message")) {
[13:36:58.148]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.148]                         if (muffled) 
[13:36:58.148]                           invokeRestart("muffleMessage")
[13:36:58.148]                       }
[13:36:58.148]                       else if (inherits(cond, "warning")) {
[13:36:58.148]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.148]                         if (muffled) 
[13:36:58.148]                           invokeRestart("muffleWarning")
[13:36:58.148]                       }
[13:36:58.148]                       else if (inherits(cond, "condition")) {
[13:36:58.148]                         if (!is.null(pattern)) {
[13:36:58.148]                           computeRestarts <- base::computeRestarts
[13:36:58.148]                           grepl <- base::grepl
[13:36:58.148]                           restarts <- computeRestarts(cond)
[13:36:58.148]                           for (restart in restarts) {
[13:36:58.148]                             name <- restart$name
[13:36:58.148]                             if (is.null(name)) 
[13:36:58.148]                               next
[13:36:58.148]                             if (!grepl(pattern, name)) 
[13:36:58.148]                               next
[13:36:58.148]                             invokeRestart(restart)
[13:36:58.148]                             muffled <- TRUE
[13:36:58.148]                             break
[13:36:58.148]                           }
[13:36:58.148]                         }
[13:36:58.148]                       }
[13:36:58.148]                       invisible(muffled)
[13:36:58.148]                     }
[13:36:58.148]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.148]                   }
[13:36:58.148]                 }
[13:36:58.148]             }
[13:36:58.148]         }))
[13:36:58.148]     }, error = function(ex) {
[13:36:58.148]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.148]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.148]                 ...future.rng), started = ...future.startTime, 
[13:36:58.148]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.148]             version = "1.8"), class = "FutureResult")
[13:36:58.148]     }, finally = {
[13:36:58.148]         if (!identical(...future.workdir, getwd())) 
[13:36:58.148]             setwd(...future.workdir)
[13:36:58.148]         {
[13:36:58.148]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.148]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.148]             }
[13:36:58.148]             base::options(...future.oldOptions)
[13:36:58.148]             if (.Platform$OS.type == "windows") {
[13:36:58.148]                 old_names <- names(...future.oldEnvVars)
[13:36:58.148]                 envs <- base::Sys.getenv()
[13:36:58.148]                 names <- names(envs)
[13:36:58.148]                 common <- intersect(names, old_names)
[13:36:58.148]                 added <- setdiff(names, old_names)
[13:36:58.148]                 removed <- setdiff(old_names, names)
[13:36:58.148]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.148]                   envs[common]]
[13:36:58.148]                 NAMES <- toupper(changed)
[13:36:58.148]                 args <- list()
[13:36:58.148]                 for (kk in seq_along(NAMES)) {
[13:36:58.148]                   name <- changed[[kk]]
[13:36:58.148]                   NAME <- NAMES[[kk]]
[13:36:58.148]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.148]                     next
[13:36:58.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.148]                 }
[13:36:58.148]                 NAMES <- toupper(added)
[13:36:58.148]                 for (kk in seq_along(NAMES)) {
[13:36:58.148]                   name <- added[[kk]]
[13:36:58.148]                   NAME <- NAMES[[kk]]
[13:36:58.148]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.148]                     next
[13:36:58.148]                   args[[name]] <- ""
[13:36:58.148]                 }
[13:36:58.148]                 NAMES <- toupper(removed)
[13:36:58.148]                 for (kk in seq_along(NAMES)) {
[13:36:58.148]                   name <- removed[[kk]]
[13:36:58.148]                   NAME <- NAMES[[kk]]
[13:36:58.148]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.148]                     next
[13:36:58.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.148]                 }
[13:36:58.148]                 if (length(args) > 0) 
[13:36:58.148]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.148]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.148]             }
[13:36:58.148]             else {
[13:36:58.148]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.148]             }
[13:36:58.148]             {
[13:36:58.148]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.148]                   0L) {
[13:36:58.148]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.148]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.148]                   base::options(opts)
[13:36:58.148]                 }
[13:36:58.148]                 {
[13:36:58.148]                   {
[13:36:58.148]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.148]                     NULL
[13:36:58.148]                   }
[13:36:58.148]                   options(future.plan = NULL)
[13:36:58.148]                   if (is.na(NA_character_)) 
[13:36:58.148]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.148]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.148]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.148]                     .init = FALSE)
[13:36:58.148]                 }
[13:36:58.148]             }
[13:36:58.148]         }
[13:36:58.148]     })
[13:36:58.148]     if (TRUE) {
[13:36:58.148]         base::sink(type = "output", split = FALSE)
[13:36:58.148]         if (TRUE) {
[13:36:58.148]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.148]         }
[13:36:58.148]         else {
[13:36:58.148]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.148]         }
[13:36:58.148]         base::close(...future.stdout)
[13:36:58.148]         ...future.stdout <- NULL
[13:36:58.148]     }
[13:36:58.148]     ...future.result$conditions <- ...future.conditions
[13:36:58.148]     ...future.result$finished <- base::Sys.time()
[13:36:58.148]     ...future.result
[13:36:58.148] }
[13:36:58.202] MultisessionFuture started
[13:36:58.202] result() for ClusterFuture ...
[13:36:58.203] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.203] - Validating connection of MultisessionFuture
[13:36:58.235] - received message: FutureResult
[13:36:58.236] - Received FutureResult
[13:36:58.236] - Erased future from FutureRegistry
[13:36:58.236] result() for ClusterFuture ...
[13:36:58.236] - result already collected: FutureResult
[13:36:58.236] result() for ClusterFuture ... done
[13:36:58.236] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.236] result() for ClusterFuture ... done
[13:36:58.237] result() for ClusterFuture ...
[13:36:58.237] - result already collected: FutureResult
[13:36:58.237] result() for ClusterFuture ... done
[13:36:58.237] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:36:58.241] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.242] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.242] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.244] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:36:58.244] Searching for globals ... DONE
[13:36:58.245] Resolving globals: TRUE
[13:36:58.245] Resolving any globals that are futures ...
[13:36:58.245] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:36:58.245] Resolving any globals that are futures ... DONE
[13:36:58.245] 
[13:36:58.245] 
[13:36:58.246] getGlobalsAndPackages() ... DONE
[13:36:58.246] run() for ‘Future’ ...
[13:36:58.246] - state: ‘created’
[13:36:58.246] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.261]   - Field: ‘node’
[13:36:58.261]   - Field: ‘label’
[13:36:58.261]   - Field: ‘local’
[13:36:58.262]   - Field: ‘owner’
[13:36:58.262]   - Field: ‘envir’
[13:36:58.262]   - Field: ‘workers’
[13:36:58.262]   - Field: ‘packages’
[13:36:58.262]   - Field: ‘gc’
[13:36:58.262]   - Field: ‘conditions’
[13:36:58.262]   - Field: ‘persistent’
[13:36:58.262]   - Field: ‘expr’
[13:36:58.262]   - Field: ‘uuid’
[13:36:58.263]   - Field: ‘seed’
[13:36:58.263]   - Field: ‘version’
[13:36:58.263]   - Field: ‘result’
[13:36:58.263]   - Field: ‘asynchronous’
[13:36:58.263]   - Field: ‘calls’
[13:36:58.263]   - Field: ‘globals’
[13:36:58.263]   - Field: ‘stdout’
[13:36:58.263]   - Field: ‘earlySignal’
[13:36:58.263]   - Field: ‘lazy’
[13:36:58.264]   - Field: ‘state’
[13:36:58.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.264] - Launch lazy future ...
[13:36:58.264] Packages needed by the future expression (n = 0): <none>
[13:36:58.264] Packages needed by future strategies (n = 0): <none>
[13:36:58.265] {
[13:36:58.265]     {
[13:36:58.265]         {
[13:36:58.265]             ...future.startTime <- base::Sys.time()
[13:36:58.265]             {
[13:36:58.265]                 {
[13:36:58.265]                   {
[13:36:58.265]                     {
[13:36:58.265]                       base::local({
[13:36:58.265]                         has_future <- base::requireNamespace("future", 
[13:36:58.265]                           quietly = TRUE)
[13:36:58.265]                         if (has_future) {
[13:36:58.265]                           ns <- base::getNamespace("future")
[13:36:58.265]                           version <- ns[[".package"]][["version"]]
[13:36:58.265]                           if (is.null(version)) 
[13:36:58.265]                             version <- utils::packageVersion("future")
[13:36:58.265]                         }
[13:36:58.265]                         else {
[13:36:58.265]                           version <- NULL
[13:36:58.265]                         }
[13:36:58.265]                         if (!has_future || version < "1.8.0") {
[13:36:58.265]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.265]                             "", base::R.version$version.string), 
[13:36:58.265]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.265]                               "release", "version")], collapse = " "), 
[13:36:58.265]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.265]                             info)
[13:36:58.265]                           info <- base::paste(info, collapse = "; ")
[13:36:58.265]                           if (!has_future) {
[13:36:58.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.265]                               info)
[13:36:58.265]                           }
[13:36:58.265]                           else {
[13:36:58.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.265]                               info, version)
[13:36:58.265]                           }
[13:36:58.265]                           base::stop(msg)
[13:36:58.265]                         }
[13:36:58.265]                       })
[13:36:58.265]                     }
[13:36:58.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.265]                     base::options(mc.cores = 1L)
[13:36:58.265]                   }
[13:36:58.265]                   ...future.strategy.old <- future::plan("list")
[13:36:58.265]                   options(future.plan = NULL)
[13:36:58.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.265]                 }
[13:36:58.265]                 ...future.workdir <- getwd()
[13:36:58.265]             }
[13:36:58.265]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.265]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.265]         }
[13:36:58.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.265]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.265]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.265]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.265]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.265]             base::names(...future.oldOptions))
[13:36:58.265]     }
[13:36:58.265]     if (FALSE) {
[13:36:58.265]     }
[13:36:58.265]     else {
[13:36:58.265]         if (TRUE) {
[13:36:58.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.265]                 open = "w")
[13:36:58.265]         }
[13:36:58.265]         else {
[13:36:58.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.265]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.265]         }
[13:36:58.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.265]             base::sink(type = "output", split = FALSE)
[13:36:58.265]             base::close(...future.stdout)
[13:36:58.265]         }, add = TRUE)
[13:36:58.265]     }
[13:36:58.265]     ...future.frame <- base::sys.nframe()
[13:36:58.265]     ...future.conditions <- base::list()
[13:36:58.265]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.265]     if (FALSE) {
[13:36:58.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.265]     }
[13:36:58.265]     ...future.result <- base::tryCatch({
[13:36:58.265]         base::withCallingHandlers({
[13:36:58.265]             ...future.value <- base::withVisible(base::local({
[13:36:58.265]                 ...future.makeSendCondition <- base::local({
[13:36:58.265]                   sendCondition <- NULL
[13:36:58.265]                   function(frame = 1L) {
[13:36:58.265]                     if (is.function(sendCondition)) 
[13:36:58.265]                       return(sendCondition)
[13:36:58.265]                     ns <- getNamespace("parallel")
[13:36:58.265]                     if (exists("sendData", mode = "function", 
[13:36:58.265]                       envir = ns)) {
[13:36:58.265]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.265]                         envir = ns)
[13:36:58.265]                       envir <- sys.frame(frame)
[13:36:58.265]                       master <- NULL
[13:36:58.265]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.265]                         !identical(envir, emptyenv())) {
[13:36:58.265]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.265]                           inherits = FALSE)) {
[13:36:58.265]                           master <- get("master", mode = "list", 
[13:36:58.265]                             envir = envir, inherits = FALSE)
[13:36:58.265]                           if (inherits(master, c("SOCKnode", 
[13:36:58.265]                             "SOCK0node"))) {
[13:36:58.265]                             sendCondition <<- function(cond) {
[13:36:58.265]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.265]                                 success = TRUE)
[13:36:58.265]                               parallel_sendData(master, data)
[13:36:58.265]                             }
[13:36:58.265]                             return(sendCondition)
[13:36:58.265]                           }
[13:36:58.265]                         }
[13:36:58.265]                         frame <- frame + 1L
[13:36:58.265]                         envir <- sys.frame(frame)
[13:36:58.265]                       }
[13:36:58.265]                     }
[13:36:58.265]                     sendCondition <<- function(cond) NULL
[13:36:58.265]                   }
[13:36:58.265]                 })
[13:36:58.265]                 withCallingHandlers({
[13:36:58.265]                   {
[13:36:58.265]                     b <- a
[13:36:58.265]                     a <- 2
[13:36:58.265]                     a * b
[13:36:58.265]                   }
[13:36:58.265]                 }, immediateCondition = function(cond) {
[13:36:58.265]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.265]                   sendCondition(cond)
[13:36:58.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.265]                   {
[13:36:58.265]                     inherits <- base::inherits
[13:36:58.265]                     invokeRestart <- base::invokeRestart
[13:36:58.265]                     is.null <- base::is.null
[13:36:58.265]                     muffled <- FALSE
[13:36:58.265]                     if (inherits(cond, "message")) {
[13:36:58.265]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.265]                       if (muffled) 
[13:36:58.265]                         invokeRestart("muffleMessage")
[13:36:58.265]                     }
[13:36:58.265]                     else if (inherits(cond, "warning")) {
[13:36:58.265]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.265]                       if (muffled) 
[13:36:58.265]                         invokeRestart("muffleWarning")
[13:36:58.265]                     }
[13:36:58.265]                     else if (inherits(cond, "condition")) {
[13:36:58.265]                       if (!is.null(pattern)) {
[13:36:58.265]                         computeRestarts <- base::computeRestarts
[13:36:58.265]                         grepl <- base::grepl
[13:36:58.265]                         restarts <- computeRestarts(cond)
[13:36:58.265]                         for (restart in restarts) {
[13:36:58.265]                           name <- restart$name
[13:36:58.265]                           if (is.null(name)) 
[13:36:58.265]                             next
[13:36:58.265]                           if (!grepl(pattern, name)) 
[13:36:58.265]                             next
[13:36:58.265]                           invokeRestart(restart)
[13:36:58.265]                           muffled <- TRUE
[13:36:58.265]                           break
[13:36:58.265]                         }
[13:36:58.265]                       }
[13:36:58.265]                     }
[13:36:58.265]                     invisible(muffled)
[13:36:58.265]                   }
[13:36:58.265]                   muffleCondition(cond)
[13:36:58.265]                 })
[13:36:58.265]             }))
[13:36:58.265]             future::FutureResult(value = ...future.value$value, 
[13:36:58.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.265]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.265]                     ...future.globalenv.names))
[13:36:58.265]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.265]         }, condition = base::local({
[13:36:58.265]             c <- base::c
[13:36:58.265]             inherits <- base::inherits
[13:36:58.265]             invokeRestart <- base::invokeRestart
[13:36:58.265]             length <- base::length
[13:36:58.265]             list <- base::list
[13:36:58.265]             seq.int <- base::seq.int
[13:36:58.265]             signalCondition <- base::signalCondition
[13:36:58.265]             sys.calls <- base::sys.calls
[13:36:58.265]             `[[` <- base::`[[`
[13:36:58.265]             `+` <- base::`+`
[13:36:58.265]             `<<-` <- base::`<<-`
[13:36:58.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.265]                   3L)]
[13:36:58.265]             }
[13:36:58.265]             function(cond) {
[13:36:58.265]                 is_error <- inherits(cond, "error")
[13:36:58.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.265]                   NULL)
[13:36:58.265]                 if (is_error) {
[13:36:58.265]                   sessionInformation <- function() {
[13:36:58.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.265]                       search = base::search(), system = base::Sys.info())
[13:36:58.265]                   }
[13:36:58.265]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.265]                     cond$call), session = sessionInformation(), 
[13:36:58.265]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.265]                   signalCondition(cond)
[13:36:58.265]                 }
[13:36:58.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.265]                 "immediateCondition"))) {
[13:36:58.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.265]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.265]                   if (TRUE && !signal) {
[13:36:58.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.265]                     {
[13:36:58.265]                       inherits <- base::inherits
[13:36:58.265]                       invokeRestart <- base::invokeRestart
[13:36:58.265]                       is.null <- base::is.null
[13:36:58.265]                       muffled <- FALSE
[13:36:58.265]                       if (inherits(cond, "message")) {
[13:36:58.265]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.265]                         if (muffled) 
[13:36:58.265]                           invokeRestart("muffleMessage")
[13:36:58.265]                       }
[13:36:58.265]                       else if (inherits(cond, "warning")) {
[13:36:58.265]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.265]                         if (muffled) 
[13:36:58.265]                           invokeRestart("muffleWarning")
[13:36:58.265]                       }
[13:36:58.265]                       else if (inherits(cond, "condition")) {
[13:36:58.265]                         if (!is.null(pattern)) {
[13:36:58.265]                           computeRestarts <- base::computeRestarts
[13:36:58.265]                           grepl <- base::grepl
[13:36:58.265]                           restarts <- computeRestarts(cond)
[13:36:58.265]                           for (restart in restarts) {
[13:36:58.265]                             name <- restart$name
[13:36:58.265]                             if (is.null(name)) 
[13:36:58.265]                               next
[13:36:58.265]                             if (!grepl(pattern, name)) 
[13:36:58.265]                               next
[13:36:58.265]                             invokeRestart(restart)
[13:36:58.265]                             muffled <- TRUE
[13:36:58.265]                             break
[13:36:58.265]                           }
[13:36:58.265]                         }
[13:36:58.265]                       }
[13:36:58.265]                       invisible(muffled)
[13:36:58.265]                     }
[13:36:58.265]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.265]                   }
[13:36:58.265]                 }
[13:36:58.265]                 else {
[13:36:58.265]                   if (TRUE) {
[13:36:58.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.265]                     {
[13:36:58.265]                       inherits <- base::inherits
[13:36:58.265]                       invokeRestart <- base::invokeRestart
[13:36:58.265]                       is.null <- base::is.null
[13:36:58.265]                       muffled <- FALSE
[13:36:58.265]                       if (inherits(cond, "message")) {
[13:36:58.265]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.265]                         if (muffled) 
[13:36:58.265]                           invokeRestart("muffleMessage")
[13:36:58.265]                       }
[13:36:58.265]                       else if (inherits(cond, "warning")) {
[13:36:58.265]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.265]                         if (muffled) 
[13:36:58.265]                           invokeRestart("muffleWarning")
[13:36:58.265]                       }
[13:36:58.265]                       else if (inherits(cond, "condition")) {
[13:36:58.265]                         if (!is.null(pattern)) {
[13:36:58.265]                           computeRestarts <- base::computeRestarts
[13:36:58.265]                           grepl <- base::grepl
[13:36:58.265]                           restarts <- computeRestarts(cond)
[13:36:58.265]                           for (restart in restarts) {
[13:36:58.265]                             name <- restart$name
[13:36:58.265]                             if (is.null(name)) 
[13:36:58.265]                               next
[13:36:58.265]                             if (!grepl(pattern, name)) 
[13:36:58.265]                               next
[13:36:58.265]                             invokeRestart(restart)
[13:36:58.265]                             muffled <- TRUE
[13:36:58.265]                             break
[13:36:58.265]                           }
[13:36:58.265]                         }
[13:36:58.265]                       }
[13:36:58.265]                       invisible(muffled)
[13:36:58.265]                     }
[13:36:58.265]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.265]                   }
[13:36:58.265]                 }
[13:36:58.265]             }
[13:36:58.265]         }))
[13:36:58.265]     }, error = function(ex) {
[13:36:58.265]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.265]                 ...future.rng), started = ...future.startTime, 
[13:36:58.265]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.265]             version = "1.8"), class = "FutureResult")
[13:36:58.265]     }, finally = {
[13:36:58.265]         if (!identical(...future.workdir, getwd())) 
[13:36:58.265]             setwd(...future.workdir)
[13:36:58.265]         {
[13:36:58.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.265]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.265]             }
[13:36:58.265]             base::options(...future.oldOptions)
[13:36:58.265]             if (.Platform$OS.type == "windows") {
[13:36:58.265]                 old_names <- names(...future.oldEnvVars)
[13:36:58.265]                 envs <- base::Sys.getenv()
[13:36:58.265]                 names <- names(envs)
[13:36:58.265]                 common <- intersect(names, old_names)
[13:36:58.265]                 added <- setdiff(names, old_names)
[13:36:58.265]                 removed <- setdiff(old_names, names)
[13:36:58.265]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.265]                   envs[common]]
[13:36:58.265]                 NAMES <- toupper(changed)
[13:36:58.265]                 args <- list()
[13:36:58.265]                 for (kk in seq_along(NAMES)) {
[13:36:58.265]                   name <- changed[[kk]]
[13:36:58.265]                   NAME <- NAMES[[kk]]
[13:36:58.265]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.265]                     next
[13:36:58.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.265]                 }
[13:36:58.265]                 NAMES <- toupper(added)
[13:36:58.265]                 for (kk in seq_along(NAMES)) {
[13:36:58.265]                   name <- added[[kk]]
[13:36:58.265]                   NAME <- NAMES[[kk]]
[13:36:58.265]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.265]                     next
[13:36:58.265]                   args[[name]] <- ""
[13:36:58.265]                 }
[13:36:58.265]                 NAMES <- toupper(removed)
[13:36:58.265]                 for (kk in seq_along(NAMES)) {
[13:36:58.265]                   name <- removed[[kk]]
[13:36:58.265]                   NAME <- NAMES[[kk]]
[13:36:58.265]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.265]                     next
[13:36:58.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.265]                 }
[13:36:58.265]                 if (length(args) > 0) 
[13:36:58.265]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.265]             }
[13:36:58.265]             else {
[13:36:58.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.265]             }
[13:36:58.265]             {
[13:36:58.265]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.265]                   0L) {
[13:36:58.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.265]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.265]                   base::options(opts)
[13:36:58.265]                 }
[13:36:58.265]                 {
[13:36:58.265]                   {
[13:36:58.265]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.265]                     NULL
[13:36:58.265]                   }
[13:36:58.265]                   options(future.plan = NULL)
[13:36:58.265]                   if (is.na(NA_character_)) 
[13:36:58.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.265]                     .init = FALSE)
[13:36:58.265]                 }
[13:36:58.265]             }
[13:36:58.265]         }
[13:36:58.265]     })
[13:36:58.265]     if (TRUE) {
[13:36:58.265]         base::sink(type = "output", split = FALSE)
[13:36:58.265]         if (TRUE) {
[13:36:58.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.265]         }
[13:36:58.265]         else {
[13:36:58.265]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.265]         }
[13:36:58.265]         base::close(...future.stdout)
[13:36:58.265]         ...future.stdout <- NULL
[13:36:58.265]     }
[13:36:58.265]     ...future.result$conditions <- ...future.conditions
[13:36:58.265]     ...future.result$finished <- base::Sys.time()
[13:36:58.265]     ...future.result
[13:36:58.265] }
[13:36:58.268] MultisessionFuture started
[13:36:58.268] - Launch lazy future ... done
[13:36:58.268] run() for ‘MultisessionFuture’ ... done
[13:36:58.269] result() for ClusterFuture ...
[13:36:58.269] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.269] - Validating connection of MultisessionFuture
[13:36:58.274] - received message: FutureResult
[13:36:58.274] - Received FutureResult
[13:36:58.274] - Erased future from FutureRegistry
[13:36:58.275] result() for ClusterFuture ...
[13:36:58.275] - result already collected: FutureResult
[13:36:58.275] result() for ClusterFuture ... done
[13:36:58.275] signalConditions() ...
[13:36:58.275]  - include = ‘immediateCondition’
[13:36:58.275]  - exclude = 
[13:36:58.275]  - resignal = FALSE
[13:36:58.275]  - Number of conditions: 1
[13:36:58.276] signalConditions() ... done
[13:36:58.276] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.276] result() for ClusterFuture ... done
[13:36:58.276] result() for ClusterFuture ...
[13:36:58.276] - result already collected: FutureResult
[13:36:58.276] result() for ClusterFuture ... done
[13:36:58.276] signalConditions() ...
[13:36:58.276]  - include = ‘immediateCondition’
[13:36:58.276]  - exclude = 
[13:36:58.276]  - resignal = FALSE
[13:36:58.277]  - Number of conditions: 1
[13:36:58.277] signalConditions() ... done
[13:36:58.277] Future state: ‘finished’
[13:36:58.277] result() for ClusterFuture ...
[13:36:58.277] - result already collected: FutureResult
[13:36:58.277] result() for ClusterFuture ... done
[13:36:58.277] signalConditions() ...
[13:36:58.277]  - include = ‘condition’
[13:36:58.278]  - exclude = ‘immediateCondition’
[13:36:58.278]  - resignal = TRUE
[13:36:58.278]  - Number of conditions: 1
[13:36:58.278]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:58.278] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "57e9b94e809f" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:36:58"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.295] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.295] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.296] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:36:58.297] Searching for globals ... DONE
[13:36:58.297] Resolving globals: TRUE
[13:36:58.297] Resolving any globals that are futures ...
[13:36:58.297] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:36:58.297] Resolving any globals that are futures ... DONE
[13:36:58.297] 
[13:36:58.298] 
[13:36:58.298] getGlobalsAndPackages() ... DONE
[13:36:58.298] run() for ‘Future’ ...
[13:36:58.298] - state: ‘created’
[13:36:58.298] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.314]   - Field: ‘node’
[13:36:58.314]   - Field: ‘label’
[13:36:58.314]   - Field: ‘local’
[13:36:58.314]   - Field: ‘owner’
[13:36:58.314]   - Field: ‘envir’
[13:36:58.314]   - Field: ‘workers’
[13:36:58.314]   - Field: ‘packages’
[13:36:58.315]   - Field: ‘gc’
[13:36:58.315]   - Field: ‘conditions’
[13:36:58.315]   - Field: ‘persistent’
[13:36:58.315]   - Field: ‘expr’
[13:36:58.315]   - Field: ‘uuid’
[13:36:58.315]   - Field: ‘seed’
[13:36:58.315]   - Field: ‘version’
[13:36:58.315]   - Field: ‘result’
[13:36:58.315]   - Field: ‘asynchronous’
[13:36:58.316]   - Field: ‘calls’
[13:36:58.316]   - Field: ‘globals’
[13:36:58.316]   - Field: ‘stdout’
[13:36:58.316]   - Field: ‘earlySignal’
[13:36:58.316]   - Field: ‘lazy’
[13:36:58.316]   - Field: ‘state’
[13:36:58.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.316] - Launch lazy future ...
[13:36:58.317] Packages needed by the future expression (n = 0): <none>
[13:36:58.317] Packages needed by future strategies (n = 0): <none>
[13:36:58.317] {
[13:36:58.317]     {
[13:36:58.317]         {
[13:36:58.317]             ...future.startTime <- base::Sys.time()
[13:36:58.317]             {
[13:36:58.317]                 {
[13:36:58.317]                   {
[13:36:58.317]                     {
[13:36:58.317]                       base::local({
[13:36:58.317]                         has_future <- base::requireNamespace("future", 
[13:36:58.317]                           quietly = TRUE)
[13:36:58.317]                         if (has_future) {
[13:36:58.317]                           ns <- base::getNamespace("future")
[13:36:58.317]                           version <- ns[[".package"]][["version"]]
[13:36:58.317]                           if (is.null(version)) 
[13:36:58.317]                             version <- utils::packageVersion("future")
[13:36:58.317]                         }
[13:36:58.317]                         else {
[13:36:58.317]                           version <- NULL
[13:36:58.317]                         }
[13:36:58.317]                         if (!has_future || version < "1.8.0") {
[13:36:58.317]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.317]                             "", base::R.version$version.string), 
[13:36:58.317]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.317]                               "release", "version")], collapse = " "), 
[13:36:58.317]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.317]                             info)
[13:36:58.317]                           info <- base::paste(info, collapse = "; ")
[13:36:58.317]                           if (!has_future) {
[13:36:58.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.317]                               info)
[13:36:58.317]                           }
[13:36:58.317]                           else {
[13:36:58.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.317]                               info, version)
[13:36:58.317]                           }
[13:36:58.317]                           base::stop(msg)
[13:36:58.317]                         }
[13:36:58.317]                       })
[13:36:58.317]                     }
[13:36:58.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.317]                     base::options(mc.cores = 1L)
[13:36:58.317]                   }
[13:36:58.317]                   ...future.strategy.old <- future::plan("list")
[13:36:58.317]                   options(future.plan = NULL)
[13:36:58.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.317]                 }
[13:36:58.317]                 ...future.workdir <- getwd()
[13:36:58.317]             }
[13:36:58.317]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.317]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.317]         }
[13:36:58.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.317]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.317]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.317]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.317]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.317]             base::names(...future.oldOptions))
[13:36:58.317]     }
[13:36:58.317]     if (FALSE) {
[13:36:58.317]     }
[13:36:58.317]     else {
[13:36:58.317]         if (TRUE) {
[13:36:58.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.317]                 open = "w")
[13:36:58.317]         }
[13:36:58.317]         else {
[13:36:58.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.317]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.317]         }
[13:36:58.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.317]             base::sink(type = "output", split = FALSE)
[13:36:58.317]             base::close(...future.stdout)
[13:36:58.317]         }, add = TRUE)
[13:36:58.317]     }
[13:36:58.317]     ...future.frame <- base::sys.nframe()
[13:36:58.317]     ...future.conditions <- base::list()
[13:36:58.317]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.317]     if (FALSE) {
[13:36:58.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.317]     }
[13:36:58.317]     ...future.result <- base::tryCatch({
[13:36:58.317]         base::withCallingHandlers({
[13:36:58.317]             ...future.value <- base::withVisible(base::local({
[13:36:58.317]                 ...future.makeSendCondition <- base::local({
[13:36:58.317]                   sendCondition <- NULL
[13:36:58.317]                   function(frame = 1L) {
[13:36:58.317]                     if (is.function(sendCondition)) 
[13:36:58.317]                       return(sendCondition)
[13:36:58.317]                     ns <- getNamespace("parallel")
[13:36:58.317]                     if (exists("sendData", mode = "function", 
[13:36:58.317]                       envir = ns)) {
[13:36:58.317]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.317]                         envir = ns)
[13:36:58.317]                       envir <- sys.frame(frame)
[13:36:58.317]                       master <- NULL
[13:36:58.317]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.317]                         !identical(envir, emptyenv())) {
[13:36:58.317]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.317]                           inherits = FALSE)) {
[13:36:58.317]                           master <- get("master", mode = "list", 
[13:36:58.317]                             envir = envir, inherits = FALSE)
[13:36:58.317]                           if (inherits(master, c("SOCKnode", 
[13:36:58.317]                             "SOCK0node"))) {
[13:36:58.317]                             sendCondition <<- function(cond) {
[13:36:58.317]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.317]                                 success = TRUE)
[13:36:58.317]                               parallel_sendData(master, data)
[13:36:58.317]                             }
[13:36:58.317]                             return(sendCondition)
[13:36:58.317]                           }
[13:36:58.317]                         }
[13:36:58.317]                         frame <- frame + 1L
[13:36:58.317]                         envir <- sys.frame(frame)
[13:36:58.317]                       }
[13:36:58.317]                     }
[13:36:58.317]                     sendCondition <<- function(cond) NULL
[13:36:58.317]                   }
[13:36:58.317]                 })
[13:36:58.317]                 withCallingHandlers({
[13:36:58.317]                   {
[13:36:58.317]                     b <- a
[13:36:58.317]                     a <- 2
[13:36:58.317]                     a * b
[13:36:58.317]                   }
[13:36:58.317]                 }, immediateCondition = function(cond) {
[13:36:58.317]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.317]                   sendCondition(cond)
[13:36:58.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.317]                   {
[13:36:58.317]                     inherits <- base::inherits
[13:36:58.317]                     invokeRestart <- base::invokeRestart
[13:36:58.317]                     is.null <- base::is.null
[13:36:58.317]                     muffled <- FALSE
[13:36:58.317]                     if (inherits(cond, "message")) {
[13:36:58.317]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.317]                       if (muffled) 
[13:36:58.317]                         invokeRestart("muffleMessage")
[13:36:58.317]                     }
[13:36:58.317]                     else if (inherits(cond, "warning")) {
[13:36:58.317]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.317]                       if (muffled) 
[13:36:58.317]                         invokeRestart("muffleWarning")
[13:36:58.317]                     }
[13:36:58.317]                     else if (inherits(cond, "condition")) {
[13:36:58.317]                       if (!is.null(pattern)) {
[13:36:58.317]                         computeRestarts <- base::computeRestarts
[13:36:58.317]                         grepl <- base::grepl
[13:36:58.317]                         restarts <- computeRestarts(cond)
[13:36:58.317]                         for (restart in restarts) {
[13:36:58.317]                           name <- restart$name
[13:36:58.317]                           if (is.null(name)) 
[13:36:58.317]                             next
[13:36:58.317]                           if (!grepl(pattern, name)) 
[13:36:58.317]                             next
[13:36:58.317]                           invokeRestart(restart)
[13:36:58.317]                           muffled <- TRUE
[13:36:58.317]                           break
[13:36:58.317]                         }
[13:36:58.317]                       }
[13:36:58.317]                     }
[13:36:58.317]                     invisible(muffled)
[13:36:58.317]                   }
[13:36:58.317]                   muffleCondition(cond)
[13:36:58.317]                 })
[13:36:58.317]             }))
[13:36:58.317]             future::FutureResult(value = ...future.value$value, 
[13:36:58.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.317]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.317]                     ...future.globalenv.names))
[13:36:58.317]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.317]         }, condition = base::local({
[13:36:58.317]             c <- base::c
[13:36:58.317]             inherits <- base::inherits
[13:36:58.317]             invokeRestart <- base::invokeRestart
[13:36:58.317]             length <- base::length
[13:36:58.317]             list <- base::list
[13:36:58.317]             seq.int <- base::seq.int
[13:36:58.317]             signalCondition <- base::signalCondition
[13:36:58.317]             sys.calls <- base::sys.calls
[13:36:58.317]             `[[` <- base::`[[`
[13:36:58.317]             `+` <- base::`+`
[13:36:58.317]             `<<-` <- base::`<<-`
[13:36:58.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.317]                   3L)]
[13:36:58.317]             }
[13:36:58.317]             function(cond) {
[13:36:58.317]                 is_error <- inherits(cond, "error")
[13:36:58.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.317]                   NULL)
[13:36:58.317]                 if (is_error) {
[13:36:58.317]                   sessionInformation <- function() {
[13:36:58.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.317]                       search = base::search(), system = base::Sys.info())
[13:36:58.317]                   }
[13:36:58.317]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.317]                     cond$call), session = sessionInformation(), 
[13:36:58.317]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.317]                   signalCondition(cond)
[13:36:58.317]                 }
[13:36:58.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.317]                 "immediateCondition"))) {
[13:36:58.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.317]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.317]                   if (TRUE && !signal) {
[13:36:58.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.317]                     {
[13:36:58.317]                       inherits <- base::inherits
[13:36:58.317]                       invokeRestart <- base::invokeRestart
[13:36:58.317]                       is.null <- base::is.null
[13:36:58.317]                       muffled <- FALSE
[13:36:58.317]                       if (inherits(cond, "message")) {
[13:36:58.317]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.317]                         if (muffled) 
[13:36:58.317]                           invokeRestart("muffleMessage")
[13:36:58.317]                       }
[13:36:58.317]                       else if (inherits(cond, "warning")) {
[13:36:58.317]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.317]                         if (muffled) 
[13:36:58.317]                           invokeRestart("muffleWarning")
[13:36:58.317]                       }
[13:36:58.317]                       else if (inherits(cond, "condition")) {
[13:36:58.317]                         if (!is.null(pattern)) {
[13:36:58.317]                           computeRestarts <- base::computeRestarts
[13:36:58.317]                           grepl <- base::grepl
[13:36:58.317]                           restarts <- computeRestarts(cond)
[13:36:58.317]                           for (restart in restarts) {
[13:36:58.317]                             name <- restart$name
[13:36:58.317]                             if (is.null(name)) 
[13:36:58.317]                               next
[13:36:58.317]                             if (!grepl(pattern, name)) 
[13:36:58.317]                               next
[13:36:58.317]                             invokeRestart(restart)
[13:36:58.317]                             muffled <- TRUE
[13:36:58.317]                             break
[13:36:58.317]                           }
[13:36:58.317]                         }
[13:36:58.317]                       }
[13:36:58.317]                       invisible(muffled)
[13:36:58.317]                     }
[13:36:58.317]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.317]                   }
[13:36:58.317]                 }
[13:36:58.317]                 else {
[13:36:58.317]                   if (TRUE) {
[13:36:58.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.317]                     {
[13:36:58.317]                       inherits <- base::inherits
[13:36:58.317]                       invokeRestart <- base::invokeRestart
[13:36:58.317]                       is.null <- base::is.null
[13:36:58.317]                       muffled <- FALSE
[13:36:58.317]                       if (inherits(cond, "message")) {
[13:36:58.317]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.317]                         if (muffled) 
[13:36:58.317]                           invokeRestart("muffleMessage")
[13:36:58.317]                       }
[13:36:58.317]                       else if (inherits(cond, "warning")) {
[13:36:58.317]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.317]                         if (muffled) 
[13:36:58.317]                           invokeRestart("muffleWarning")
[13:36:58.317]                       }
[13:36:58.317]                       else if (inherits(cond, "condition")) {
[13:36:58.317]                         if (!is.null(pattern)) {
[13:36:58.317]                           computeRestarts <- base::computeRestarts
[13:36:58.317]                           grepl <- base::grepl
[13:36:58.317]                           restarts <- computeRestarts(cond)
[13:36:58.317]                           for (restart in restarts) {
[13:36:58.317]                             name <- restart$name
[13:36:58.317]                             if (is.null(name)) 
[13:36:58.317]                               next
[13:36:58.317]                             if (!grepl(pattern, name)) 
[13:36:58.317]                               next
[13:36:58.317]                             invokeRestart(restart)
[13:36:58.317]                             muffled <- TRUE
[13:36:58.317]                             break
[13:36:58.317]                           }
[13:36:58.317]                         }
[13:36:58.317]                       }
[13:36:58.317]                       invisible(muffled)
[13:36:58.317]                     }
[13:36:58.317]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.317]                   }
[13:36:58.317]                 }
[13:36:58.317]             }
[13:36:58.317]         }))
[13:36:58.317]     }, error = function(ex) {
[13:36:58.317]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.317]                 ...future.rng), started = ...future.startTime, 
[13:36:58.317]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.317]             version = "1.8"), class = "FutureResult")
[13:36:58.317]     }, finally = {
[13:36:58.317]         if (!identical(...future.workdir, getwd())) 
[13:36:58.317]             setwd(...future.workdir)
[13:36:58.317]         {
[13:36:58.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.317]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.317]             }
[13:36:58.317]             base::options(...future.oldOptions)
[13:36:58.317]             if (.Platform$OS.type == "windows") {
[13:36:58.317]                 old_names <- names(...future.oldEnvVars)
[13:36:58.317]                 envs <- base::Sys.getenv()
[13:36:58.317]                 names <- names(envs)
[13:36:58.317]                 common <- intersect(names, old_names)
[13:36:58.317]                 added <- setdiff(names, old_names)
[13:36:58.317]                 removed <- setdiff(old_names, names)
[13:36:58.317]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.317]                   envs[common]]
[13:36:58.317]                 NAMES <- toupper(changed)
[13:36:58.317]                 args <- list()
[13:36:58.317]                 for (kk in seq_along(NAMES)) {
[13:36:58.317]                   name <- changed[[kk]]
[13:36:58.317]                   NAME <- NAMES[[kk]]
[13:36:58.317]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.317]                     next
[13:36:58.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.317]                 }
[13:36:58.317]                 NAMES <- toupper(added)
[13:36:58.317]                 for (kk in seq_along(NAMES)) {
[13:36:58.317]                   name <- added[[kk]]
[13:36:58.317]                   NAME <- NAMES[[kk]]
[13:36:58.317]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.317]                     next
[13:36:58.317]                   args[[name]] <- ""
[13:36:58.317]                 }
[13:36:58.317]                 NAMES <- toupper(removed)
[13:36:58.317]                 for (kk in seq_along(NAMES)) {
[13:36:58.317]                   name <- removed[[kk]]
[13:36:58.317]                   NAME <- NAMES[[kk]]
[13:36:58.317]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.317]                     next
[13:36:58.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.317]                 }
[13:36:58.317]                 if (length(args) > 0) 
[13:36:58.317]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.317]             }
[13:36:58.317]             else {
[13:36:58.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.317]             }
[13:36:58.317]             {
[13:36:58.317]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.317]                   0L) {
[13:36:58.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.317]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.317]                   base::options(opts)
[13:36:58.317]                 }
[13:36:58.317]                 {
[13:36:58.317]                   {
[13:36:58.317]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.317]                     NULL
[13:36:58.317]                   }
[13:36:58.317]                   options(future.plan = NULL)
[13:36:58.317]                   if (is.na(NA_character_)) 
[13:36:58.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.317]                     .init = FALSE)
[13:36:58.317]                 }
[13:36:58.317]             }
[13:36:58.317]         }
[13:36:58.317]     })
[13:36:58.317]     if (TRUE) {
[13:36:58.317]         base::sink(type = "output", split = FALSE)
[13:36:58.317]         if (TRUE) {
[13:36:58.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.317]         }
[13:36:58.317]         else {
[13:36:58.317]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.317]         }
[13:36:58.317]         base::close(...future.stdout)
[13:36:58.317]         ...future.stdout <- NULL
[13:36:58.317]     }
[13:36:58.317]     ...future.result$conditions <- ...future.conditions
[13:36:58.317]     ...future.result$finished <- base::Sys.time()
[13:36:58.317]     ...future.result
[13:36:58.317] }
[13:36:58.321] MultisessionFuture started
[13:36:58.324] - Launch lazy future ... done
[13:36:58.325] run() for ‘MultisessionFuture’ ... done
[13:36:58.325] result() for ClusterFuture ...
[13:36:58.325] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.325] - Validating connection of MultisessionFuture
[13:36:58.325] - received message: FutureResult
[13:36:58.325] - Received FutureResult
[13:36:58.325] - Erased future from FutureRegistry
[13:36:58.326] result() for ClusterFuture ...
[13:36:58.326] - result already collected: FutureResult
[13:36:58.326] result() for ClusterFuture ... done
[13:36:58.326] signalConditions() ...
[13:36:58.326]  - include = ‘immediateCondition’
[13:36:58.326]  - exclude = 
[13:36:58.326]  - resignal = FALSE
[13:36:58.326]  - Number of conditions: 1
[13:36:58.326] signalConditions() ... done
[13:36:58.326] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.326] result() for ClusterFuture ... done
[13:36:58.327] result() for ClusterFuture ...
[13:36:58.327] - result already collected: FutureResult
[13:36:58.327] result() for ClusterFuture ... done
[13:36:58.327] signalConditions() ...
[13:36:58.327]  - include = ‘immediateCondition’
[13:36:58.327]  - exclude = 
[13:36:58.327]  - resignal = FALSE
[13:36:58.327]  - Number of conditions: 1
[13:36:58.327] signalConditions() ... done
[13:36:58.327] Future state: ‘finished’
[13:36:58.327] result() for ClusterFuture ...
[13:36:58.328] - result already collected: FutureResult
[13:36:58.328] result() for ClusterFuture ... done
[13:36:58.328] signalConditions() ...
[13:36:58.328]  - include = ‘condition’
[13:36:58.328]  - exclude = ‘immediateCondition’
[13:36:58.328]  - resignal = TRUE
[13:36:58.328]  - Number of conditions: 1
[13:36:58.328]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:58.328] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "57e9b94e809f" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:36:58"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.342] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.342] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.343] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.344] Searching for globals ... DONE
[13:36:58.344] Resolving globals: TRUE
[13:36:58.344] Resolving any globals that are futures ...
[13:36:58.344] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.344] Resolving any globals that are futures ... DONE
[13:36:58.344] Resolving futures part of globals (recursively) ...
[13:36:58.345] resolve() on list ...
[13:36:58.345]  recursive: 99
[13:36:58.345]  length: 1
[13:36:58.345]  elements: ‘ii’
[13:36:58.345]  length: 0 (resolved future 1)
[13:36:58.345] resolve() on list ... DONE
[13:36:58.345] - globals: [1] ‘ii’
[13:36:58.345] Resolving futures part of globals (recursively) ... DONE
[13:36:58.345] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:58.346] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:58.346] - globals: [1] ‘ii’
[13:36:58.346] 
[13:36:58.346] getGlobalsAndPackages() ... DONE
[13:36:58.346] run() for ‘Future’ ...
[13:36:58.346] - state: ‘created’
[13:36:58.347] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.360] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.360]   - Field: ‘node’
[13:36:58.360]   - Field: ‘label’
[13:36:58.361]   - Field: ‘local’
[13:36:58.361]   - Field: ‘owner’
[13:36:58.361]   - Field: ‘envir’
[13:36:58.361]   - Field: ‘workers’
[13:36:58.361]   - Field: ‘packages’
[13:36:58.361]   - Field: ‘gc’
[13:36:58.361]   - Field: ‘conditions’
[13:36:58.361]   - Field: ‘persistent’
[13:36:58.361]   - Field: ‘expr’
[13:36:58.361]   - Field: ‘uuid’
[13:36:58.361]   - Field: ‘seed’
[13:36:58.362]   - Field: ‘version’
[13:36:58.362]   - Field: ‘result’
[13:36:58.362]   - Field: ‘asynchronous’
[13:36:58.362]   - Field: ‘calls’
[13:36:58.362]   - Field: ‘globals’
[13:36:58.362]   - Field: ‘stdout’
[13:36:58.362]   - Field: ‘earlySignal’
[13:36:58.362]   - Field: ‘lazy’
[13:36:58.362]   - Field: ‘state’
[13:36:58.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.363] - Launch lazy future ...
[13:36:58.363] Packages needed by the future expression (n = 0): <none>
[13:36:58.363] Packages needed by future strategies (n = 0): <none>
[13:36:58.363] {
[13:36:58.363]     {
[13:36:58.363]         {
[13:36:58.363]             ...future.startTime <- base::Sys.time()
[13:36:58.363]             {
[13:36:58.363]                 {
[13:36:58.363]                   {
[13:36:58.363]                     {
[13:36:58.363]                       base::local({
[13:36:58.363]                         has_future <- base::requireNamespace("future", 
[13:36:58.363]                           quietly = TRUE)
[13:36:58.363]                         if (has_future) {
[13:36:58.363]                           ns <- base::getNamespace("future")
[13:36:58.363]                           version <- ns[[".package"]][["version"]]
[13:36:58.363]                           if (is.null(version)) 
[13:36:58.363]                             version <- utils::packageVersion("future")
[13:36:58.363]                         }
[13:36:58.363]                         else {
[13:36:58.363]                           version <- NULL
[13:36:58.363]                         }
[13:36:58.363]                         if (!has_future || version < "1.8.0") {
[13:36:58.363]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.363]                             "", base::R.version$version.string), 
[13:36:58.363]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.363]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.363]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.363]                               "release", "version")], collapse = " "), 
[13:36:58.363]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.363]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.363]                             info)
[13:36:58.363]                           info <- base::paste(info, collapse = "; ")
[13:36:58.363]                           if (!has_future) {
[13:36:58.363]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.363]                               info)
[13:36:58.363]                           }
[13:36:58.363]                           else {
[13:36:58.363]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.363]                               info, version)
[13:36:58.363]                           }
[13:36:58.363]                           base::stop(msg)
[13:36:58.363]                         }
[13:36:58.363]                       })
[13:36:58.363]                     }
[13:36:58.363]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.363]                     base::options(mc.cores = 1L)
[13:36:58.363]                   }
[13:36:58.363]                   ...future.strategy.old <- future::plan("list")
[13:36:58.363]                   options(future.plan = NULL)
[13:36:58.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.363]                 }
[13:36:58.363]                 ...future.workdir <- getwd()
[13:36:58.363]             }
[13:36:58.363]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.363]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.363]         }
[13:36:58.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.363]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.363]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.363]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.363]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.363]             base::names(...future.oldOptions))
[13:36:58.363]     }
[13:36:58.363]     if (FALSE) {
[13:36:58.363]     }
[13:36:58.363]     else {
[13:36:58.363]         if (TRUE) {
[13:36:58.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.363]                 open = "w")
[13:36:58.363]         }
[13:36:58.363]         else {
[13:36:58.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.363]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.363]         }
[13:36:58.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.363]             base::sink(type = "output", split = FALSE)
[13:36:58.363]             base::close(...future.stdout)
[13:36:58.363]         }, add = TRUE)
[13:36:58.363]     }
[13:36:58.363]     ...future.frame <- base::sys.nframe()
[13:36:58.363]     ...future.conditions <- base::list()
[13:36:58.363]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.363]     if (FALSE) {
[13:36:58.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.363]     }
[13:36:58.363]     ...future.result <- base::tryCatch({
[13:36:58.363]         base::withCallingHandlers({
[13:36:58.363]             ...future.value <- base::withVisible(base::local({
[13:36:58.363]                 ...future.makeSendCondition <- base::local({
[13:36:58.363]                   sendCondition <- NULL
[13:36:58.363]                   function(frame = 1L) {
[13:36:58.363]                     if (is.function(sendCondition)) 
[13:36:58.363]                       return(sendCondition)
[13:36:58.363]                     ns <- getNamespace("parallel")
[13:36:58.363]                     if (exists("sendData", mode = "function", 
[13:36:58.363]                       envir = ns)) {
[13:36:58.363]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.363]                         envir = ns)
[13:36:58.363]                       envir <- sys.frame(frame)
[13:36:58.363]                       master <- NULL
[13:36:58.363]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.363]                         !identical(envir, emptyenv())) {
[13:36:58.363]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.363]                           inherits = FALSE)) {
[13:36:58.363]                           master <- get("master", mode = "list", 
[13:36:58.363]                             envir = envir, inherits = FALSE)
[13:36:58.363]                           if (inherits(master, c("SOCKnode", 
[13:36:58.363]                             "SOCK0node"))) {
[13:36:58.363]                             sendCondition <<- function(cond) {
[13:36:58.363]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.363]                                 success = TRUE)
[13:36:58.363]                               parallel_sendData(master, data)
[13:36:58.363]                             }
[13:36:58.363]                             return(sendCondition)
[13:36:58.363]                           }
[13:36:58.363]                         }
[13:36:58.363]                         frame <- frame + 1L
[13:36:58.363]                         envir <- sys.frame(frame)
[13:36:58.363]                       }
[13:36:58.363]                     }
[13:36:58.363]                     sendCondition <<- function(cond) NULL
[13:36:58.363]                   }
[13:36:58.363]                 })
[13:36:58.363]                 withCallingHandlers({
[13:36:58.363]                   {
[13:36:58.363]                     b <- a * ii
[13:36:58.363]                     a <- 0
[13:36:58.363]                     b
[13:36:58.363]                   }
[13:36:58.363]                 }, immediateCondition = function(cond) {
[13:36:58.363]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.363]                   sendCondition(cond)
[13:36:58.363]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.363]                   {
[13:36:58.363]                     inherits <- base::inherits
[13:36:58.363]                     invokeRestart <- base::invokeRestart
[13:36:58.363]                     is.null <- base::is.null
[13:36:58.363]                     muffled <- FALSE
[13:36:58.363]                     if (inherits(cond, "message")) {
[13:36:58.363]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.363]                       if (muffled) 
[13:36:58.363]                         invokeRestart("muffleMessage")
[13:36:58.363]                     }
[13:36:58.363]                     else if (inherits(cond, "warning")) {
[13:36:58.363]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.363]                       if (muffled) 
[13:36:58.363]                         invokeRestart("muffleWarning")
[13:36:58.363]                     }
[13:36:58.363]                     else if (inherits(cond, "condition")) {
[13:36:58.363]                       if (!is.null(pattern)) {
[13:36:58.363]                         computeRestarts <- base::computeRestarts
[13:36:58.363]                         grepl <- base::grepl
[13:36:58.363]                         restarts <- computeRestarts(cond)
[13:36:58.363]                         for (restart in restarts) {
[13:36:58.363]                           name <- restart$name
[13:36:58.363]                           if (is.null(name)) 
[13:36:58.363]                             next
[13:36:58.363]                           if (!grepl(pattern, name)) 
[13:36:58.363]                             next
[13:36:58.363]                           invokeRestart(restart)
[13:36:58.363]                           muffled <- TRUE
[13:36:58.363]                           break
[13:36:58.363]                         }
[13:36:58.363]                       }
[13:36:58.363]                     }
[13:36:58.363]                     invisible(muffled)
[13:36:58.363]                   }
[13:36:58.363]                   muffleCondition(cond)
[13:36:58.363]                 })
[13:36:58.363]             }))
[13:36:58.363]             future::FutureResult(value = ...future.value$value, 
[13:36:58.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.363]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.363]                     ...future.globalenv.names))
[13:36:58.363]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.363]         }, condition = base::local({
[13:36:58.363]             c <- base::c
[13:36:58.363]             inherits <- base::inherits
[13:36:58.363]             invokeRestart <- base::invokeRestart
[13:36:58.363]             length <- base::length
[13:36:58.363]             list <- base::list
[13:36:58.363]             seq.int <- base::seq.int
[13:36:58.363]             signalCondition <- base::signalCondition
[13:36:58.363]             sys.calls <- base::sys.calls
[13:36:58.363]             `[[` <- base::`[[`
[13:36:58.363]             `+` <- base::`+`
[13:36:58.363]             `<<-` <- base::`<<-`
[13:36:58.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.363]                   3L)]
[13:36:58.363]             }
[13:36:58.363]             function(cond) {
[13:36:58.363]                 is_error <- inherits(cond, "error")
[13:36:58.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.363]                   NULL)
[13:36:58.363]                 if (is_error) {
[13:36:58.363]                   sessionInformation <- function() {
[13:36:58.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.363]                       search = base::search(), system = base::Sys.info())
[13:36:58.363]                   }
[13:36:58.363]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.363]                     cond$call), session = sessionInformation(), 
[13:36:58.363]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.363]                   signalCondition(cond)
[13:36:58.363]                 }
[13:36:58.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.363]                 "immediateCondition"))) {
[13:36:58.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.363]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.363]                   if (TRUE && !signal) {
[13:36:58.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.363]                     {
[13:36:58.363]                       inherits <- base::inherits
[13:36:58.363]                       invokeRestart <- base::invokeRestart
[13:36:58.363]                       is.null <- base::is.null
[13:36:58.363]                       muffled <- FALSE
[13:36:58.363]                       if (inherits(cond, "message")) {
[13:36:58.363]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.363]                         if (muffled) 
[13:36:58.363]                           invokeRestart("muffleMessage")
[13:36:58.363]                       }
[13:36:58.363]                       else if (inherits(cond, "warning")) {
[13:36:58.363]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.363]                         if (muffled) 
[13:36:58.363]                           invokeRestart("muffleWarning")
[13:36:58.363]                       }
[13:36:58.363]                       else if (inherits(cond, "condition")) {
[13:36:58.363]                         if (!is.null(pattern)) {
[13:36:58.363]                           computeRestarts <- base::computeRestarts
[13:36:58.363]                           grepl <- base::grepl
[13:36:58.363]                           restarts <- computeRestarts(cond)
[13:36:58.363]                           for (restart in restarts) {
[13:36:58.363]                             name <- restart$name
[13:36:58.363]                             if (is.null(name)) 
[13:36:58.363]                               next
[13:36:58.363]                             if (!grepl(pattern, name)) 
[13:36:58.363]                               next
[13:36:58.363]                             invokeRestart(restart)
[13:36:58.363]                             muffled <- TRUE
[13:36:58.363]                             break
[13:36:58.363]                           }
[13:36:58.363]                         }
[13:36:58.363]                       }
[13:36:58.363]                       invisible(muffled)
[13:36:58.363]                     }
[13:36:58.363]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.363]                   }
[13:36:58.363]                 }
[13:36:58.363]                 else {
[13:36:58.363]                   if (TRUE) {
[13:36:58.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.363]                     {
[13:36:58.363]                       inherits <- base::inherits
[13:36:58.363]                       invokeRestart <- base::invokeRestart
[13:36:58.363]                       is.null <- base::is.null
[13:36:58.363]                       muffled <- FALSE
[13:36:58.363]                       if (inherits(cond, "message")) {
[13:36:58.363]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.363]                         if (muffled) 
[13:36:58.363]                           invokeRestart("muffleMessage")
[13:36:58.363]                       }
[13:36:58.363]                       else if (inherits(cond, "warning")) {
[13:36:58.363]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.363]                         if (muffled) 
[13:36:58.363]                           invokeRestart("muffleWarning")
[13:36:58.363]                       }
[13:36:58.363]                       else if (inherits(cond, "condition")) {
[13:36:58.363]                         if (!is.null(pattern)) {
[13:36:58.363]                           computeRestarts <- base::computeRestarts
[13:36:58.363]                           grepl <- base::grepl
[13:36:58.363]                           restarts <- computeRestarts(cond)
[13:36:58.363]                           for (restart in restarts) {
[13:36:58.363]                             name <- restart$name
[13:36:58.363]                             if (is.null(name)) 
[13:36:58.363]                               next
[13:36:58.363]                             if (!grepl(pattern, name)) 
[13:36:58.363]                               next
[13:36:58.363]                             invokeRestart(restart)
[13:36:58.363]                             muffled <- TRUE
[13:36:58.363]                             break
[13:36:58.363]                           }
[13:36:58.363]                         }
[13:36:58.363]                       }
[13:36:58.363]                       invisible(muffled)
[13:36:58.363]                     }
[13:36:58.363]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.363]                   }
[13:36:58.363]                 }
[13:36:58.363]             }
[13:36:58.363]         }))
[13:36:58.363]     }, error = function(ex) {
[13:36:58.363]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.363]                 ...future.rng), started = ...future.startTime, 
[13:36:58.363]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.363]             version = "1.8"), class = "FutureResult")
[13:36:58.363]     }, finally = {
[13:36:58.363]         if (!identical(...future.workdir, getwd())) 
[13:36:58.363]             setwd(...future.workdir)
[13:36:58.363]         {
[13:36:58.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.363]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.363]             }
[13:36:58.363]             base::options(...future.oldOptions)
[13:36:58.363]             if (.Platform$OS.type == "windows") {
[13:36:58.363]                 old_names <- names(...future.oldEnvVars)
[13:36:58.363]                 envs <- base::Sys.getenv()
[13:36:58.363]                 names <- names(envs)
[13:36:58.363]                 common <- intersect(names, old_names)
[13:36:58.363]                 added <- setdiff(names, old_names)
[13:36:58.363]                 removed <- setdiff(old_names, names)
[13:36:58.363]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.363]                   envs[common]]
[13:36:58.363]                 NAMES <- toupper(changed)
[13:36:58.363]                 args <- list()
[13:36:58.363]                 for (kk in seq_along(NAMES)) {
[13:36:58.363]                   name <- changed[[kk]]
[13:36:58.363]                   NAME <- NAMES[[kk]]
[13:36:58.363]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.363]                     next
[13:36:58.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.363]                 }
[13:36:58.363]                 NAMES <- toupper(added)
[13:36:58.363]                 for (kk in seq_along(NAMES)) {
[13:36:58.363]                   name <- added[[kk]]
[13:36:58.363]                   NAME <- NAMES[[kk]]
[13:36:58.363]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.363]                     next
[13:36:58.363]                   args[[name]] <- ""
[13:36:58.363]                 }
[13:36:58.363]                 NAMES <- toupper(removed)
[13:36:58.363]                 for (kk in seq_along(NAMES)) {
[13:36:58.363]                   name <- removed[[kk]]
[13:36:58.363]                   NAME <- NAMES[[kk]]
[13:36:58.363]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.363]                     next
[13:36:58.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.363]                 }
[13:36:58.363]                 if (length(args) > 0) 
[13:36:58.363]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.363]             }
[13:36:58.363]             else {
[13:36:58.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.363]             }
[13:36:58.363]             {
[13:36:58.363]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.363]                   0L) {
[13:36:58.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.363]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.363]                   base::options(opts)
[13:36:58.363]                 }
[13:36:58.363]                 {
[13:36:58.363]                   {
[13:36:58.363]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.363]                     NULL
[13:36:58.363]                   }
[13:36:58.363]                   options(future.plan = NULL)
[13:36:58.363]                   if (is.na(NA_character_)) 
[13:36:58.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.363]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.363]                     .init = FALSE)
[13:36:58.363]                 }
[13:36:58.363]             }
[13:36:58.363]         }
[13:36:58.363]     })
[13:36:58.363]     if (TRUE) {
[13:36:58.363]         base::sink(type = "output", split = FALSE)
[13:36:58.363]         if (TRUE) {
[13:36:58.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.363]         }
[13:36:58.363]         else {
[13:36:58.363]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.363]         }
[13:36:58.363]         base::close(...future.stdout)
[13:36:58.363]         ...future.stdout <- NULL
[13:36:58.363]     }
[13:36:58.363]     ...future.result$conditions <- ...future.conditions
[13:36:58.363]     ...future.result$finished <- base::Sys.time()
[13:36:58.363]     ...future.result
[13:36:58.363] }
[13:36:58.366] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:36:58.366] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:36:58.366] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:36:58.366] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:36:58.367] MultisessionFuture started
[13:36:58.367] - Launch lazy future ... done
[13:36:58.367] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.368] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.368] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.370] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.370] Searching for globals ... DONE
[13:36:58.370] Resolving globals: TRUE
[13:36:58.371] Resolving any globals that are futures ...
[13:36:58.371] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.371] Resolving any globals that are futures ... DONE
[13:36:58.371] Resolving futures part of globals (recursively) ...
[13:36:58.371] resolve() on list ...
[13:36:58.371]  recursive: 99
[13:36:58.371]  length: 1
[13:36:58.372]  elements: ‘ii’
[13:36:58.372]  length: 0 (resolved future 1)
[13:36:58.372] resolve() on list ... DONE
[13:36:58.372] - globals: [1] ‘ii’
[13:36:58.372] Resolving futures part of globals (recursively) ... DONE
[13:36:58.372] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:58.372] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:58.372] - globals: [1] ‘ii’
[13:36:58.373] 
[13:36:58.373] getGlobalsAndPackages() ... DONE
[13:36:58.373] run() for ‘Future’ ...
[13:36:58.373] - state: ‘created’
[13:36:58.373] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.387] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.387]   - Field: ‘node’
[13:36:58.387]   - Field: ‘label’
[13:36:58.387]   - Field: ‘local’
[13:36:58.387]   - Field: ‘owner’
[13:36:58.387]   - Field: ‘envir’
[13:36:58.387]   - Field: ‘workers’
[13:36:58.387]   - Field: ‘packages’
[13:36:58.388]   - Field: ‘gc’
[13:36:58.388]   - Field: ‘conditions’
[13:36:58.388]   - Field: ‘persistent’
[13:36:58.388]   - Field: ‘expr’
[13:36:58.388]   - Field: ‘uuid’
[13:36:58.388]   - Field: ‘seed’
[13:36:58.388]   - Field: ‘version’
[13:36:58.388]   - Field: ‘result’
[13:36:58.388]   - Field: ‘asynchronous’
[13:36:58.388]   - Field: ‘calls’
[13:36:58.388]   - Field: ‘globals’
[13:36:58.389]   - Field: ‘stdout’
[13:36:58.389]   - Field: ‘earlySignal’
[13:36:58.389]   - Field: ‘lazy’
[13:36:58.389]   - Field: ‘state’
[13:36:58.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.389] - Launch lazy future ...
[13:36:58.389] Packages needed by the future expression (n = 0): <none>
[13:36:58.389] Packages needed by future strategies (n = 0): <none>
[13:36:58.390] {
[13:36:58.390]     {
[13:36:58.390]         {
[13:36:58.390]             ...future.startTime <- base::Sys.time()
[13:36:58.390]             {
[13:36:58.390]                 {
[13:36:58.390]                   {
[13:36:58.390]                     {
[13:36:58.390]                       base::local({
[13:36:58.390]                         has_future <- base::requireNamespace("future", 
[13:36:58.390]                           quietly = TRUE)
[13:36:58.390]                         if (has_future) {
[13:36:58.390]                           ns <- base::getNamespace("future")
[13:36:58.390]                           version <- ns[[".package"]][["version"]]
[13:36:58.390]                           if (is.null(version)) 
[13:36:58.390]                             version <- utils::packageVersion("future")
[13:36:58.390]                         }
[13:36:58.390]                         else {
[13:36:58.390]                           version <- NULL
[13:36:58.390]                         }
[13:36:58.390]                         if (!has_future || version < "1.8.0") {
[13:36:58.390]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.390]                             "", base::R.version$version.string), 
[13:36:58.390]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.390]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.390]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.390]                               "release", "version")], collapse = " "), 
[13:36:58.390]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.390]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.390]                             info)
[13:36:58.390]                           info <- base::paste(info, collapse = "; ")
[13:36:58.390]                           if (!has_future) {
[13:36:58.390]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.390]                               info)
[13:36:58.390]                           }
[13:36:58.390]                           else {
[13:36:58.390]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.390]                               info, version)
[13:36:58.390]                           }
[13:36:58.390]                           base::stop(msg)
[13:36:58.390]                         }
[13:36:58.390]                       })
[13:36:58.390]                     }
[13:36:58.390]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.390]                     base::options(mc.cores = 1L)
[13:36:58.390]                   }
[13:36:58.390]                   ...future.strategy.old <- future::plan("list")
[13:36:58.390]                   options(future.plan = NULL)
[13:36:58.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.390]                 }
[13:36:58.390]                 ...future.workdir <- getwd()
[13:36:58.390]             }
[13:36:58.390]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.390]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.390]         }
[13:36:58.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.390]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.390]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.390]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.390]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.390]             base::names(...future.oldOptions))
[13:36:58.390]     }
[13:36:58.390]     if (FALSE) {
[13:36:58.390]     }
[13:36:58.390]     else {
[13:36:58.390]         if (TRUE) {
[13:36:58.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.390]                 open = "w")
[13:36:58.390]         }
[13:36:58.390]         else {
[13:36:58.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.390]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.390]         }
[13:36:58.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.390]             base::sink(type = "output", split = FALSE)
[13:36:58.390]             base::close(...future.stdout)
[13:36:58.390]         }, add = TRUE)
[13:36:58.390]     }
[13:36:58.390]     ...future.frame <- base::sys.nframe()
[13:36:58.390]     ...future.conditions <- base::list()
[13:36:58.390]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.390]     if (FALSE) {
[13:36:58.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.390]     }
[13:36:58.390]     ...future.result <- base::tryCatch({
[13:36:58.390]         base::withCallingHandlers({
[13:36:58.390]             ...future.value <- base::withVisible(base::local({
[13:36:58.390]                 ...future.makeSendCondition <- base::local({
[13:36:58.390]                   sendCondition <- NULL
[13:36:58.390]                   function(frame = 1L) {
[13:36:58.390]                     if (is.function(sendCondition)) 
[13:36:58.390]                       return(sendCondition)
[13:36:58.390]                     ns <- getNamespace("parallel")
[13:36:58.390]                     if (exists("sendData", mode = "function", 
[13:36:58.390]                       envir = ns)) {
[13:36:58.390]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.390]                         envir = ns)
[13:36:58.390]                       envir <- sys.frame(frame)
[13:36:58.390]                       master <- NULL
[13:36:58.390]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.390]                         !identical(envir, emptyenv())) {
[13:36:58.390]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.390]                           inherits = FALSE)) {
[13:36:58.390]                           master <- get("master", mode = "list", 
[13:36:58.390]                             envir = envir, inherits = FALSE)
[13:36:58.390]                           if (inherits(master, c("SOCKnode", 
[13:36:58.390]                             "SOCK0node"))) {
[13:36:58.390]                             sendCondition <<- function(cond) {
[13:36:58.390]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.390]                                 success = TRUE)
[13:36:58.390]                               parallel_sendData(master, data)
[13:36:58.390]                             }
[13:36:58.390]                             return(sendCondition)
[13:36:58.390]                           }
[13:36:58.390]                         }
[13:36:58.390]                         frame <- frame + 1L
[13:36:58.390]                         envir <- sys.frame(frame)
[13:36:58.390]                       }
[13:36:58.390]                     }
[13:36:58.390]                     sendCondition <<- function(cond) NULL
[13:36:58.390]                   }
[13:36:58.390]                 })
[13:36:58.390]                 withCallingHandlers({
[13:36:58.390]                   {
[13:36:58.390]                     b <- a * ii
[13:36:58.390]                     a <- 0
[13:36:58.390]                     b
[13:36:58.390]                   }
[13:36:58.390]                 }, immediateCondition = function(cond) {
[13:36:58.390]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.390]                   sendCondition(cond)
[13:36:58.390]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.390]                   {
[13:36:58.390]                     inherits <- base::inherits
[13:36:58.390]                     invokeRestart <- base::invokeRestart
[13:36:58.390]                     is.null <- base::is.null
[13:36:58.390]                     muffled <- FALSE
[13:36:58.390]                     if (inherits(cond, "message")) {
[13:36:58.390]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.390]                       if (muffled) 
[13:36:58.390]                         invokeRestart("muffleMessage")
[13:36:58.390]                     }
[13:36:58.390]                     else if (inherits(cond, "warning")) {
[13:36:58.390]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.390]                       if (muffled) 
[13:36:58.390]                         invokeRestart("muffleWarning")
[13:36:58.390]                     }
[13:36:58.390]                     else if (inherits(cond, "condition")) {
[13:36:58.390]                       if (!is.null(pattern)) {
[13:36:58.390]                         computeRestarts <- base::computeRestarts
[13:36:58.390]                         grepl <- base::grepl
[13:36:58.390]                         restarts <- computeRestarts(cond)
[13:36:58.390]                         for (restart in restarts) {
[13:36:58.390]                           name <- restart$name
[13:36:58.390]                           if (is.null(name)) 
[13:36:58.390]                             next
[13:36:58.390]                           if (!grepl(pattern, name)) 
[13:36:58.390]                             next
[13:36:58.390]                           invokeRestart(restart)
[13:36:58.390]                           muffled <- TRUE
[13:36:58.390]                           break
[13:36:58.390]                         }
[13:36:58.390]                       }
[13:36:58.390]                     }
[13:36:58.390]                     invisible(muffled)
[13:36:58.390]                   }
[13:36:58.390]                   muffleCondition(cond)
[13:36:58.390]                 })
[13:36:58.390]             }))
[13:36:58.390]             future::FutureResult(value = ...future.value$value, 
[13:36:58.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.390]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.390]                     ...future.globalenv.names))
[13:36:58.390]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.390]         }, condition = base::local({
[13:36:58.390]             c <- base::c
[13:36:58.390]             inherits <- base::inherits
[13:36:58.390]             invokeRestart <- base::invokeRestart
[13:36:58.390]             length <- base::length
[13:36:58.390]             list <- base::list
[13:36:58.390]             seq.int <- base::seq.int
[13:36:58.390]             signalCondition <- base::signalCondition
[13:36:58.390]             sys.calls <- base::sys.calls
[13:36:58.390]             `[[` <- base::`[[`
[13:36:58.390]             `+` <- base::`+`
[13:36:58.390]             `<<-` <- base::`<<-`
[13:36:58.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.390]                   3L)]
[13:36:58.390]             }
[13:36:58.390]             function(cond) {
[13:36:58.390]                 is_error <- inherits(cond, "error")
[13:36:58.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.390]                   NULL)
[13:36:58.390]                 if (is_error) {
[13:36:58.390]                   sessionInformation <- function() {
[13:36:58.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.390]                       search = base::search(), system = base::Sys.info())
[13:36:58.390]                   }
[13:36:58.390]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.390]                     cond$call), session = sessionInformation(), 
[13:36:58.390]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.390]                   signalCondition(cond)
[13:36:58.390]                 }
[13:36:58.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.390]                 "immediateCondition"))) {
[13:36:58.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.390]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.390]                   if (TRUE && !signal) {
[13:36:58.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.390]                     {
[13:36:58.390]                       inherits <- base::inherits
[13:36:58.390]                       invokeRestart <- base::invokeRestart
[13:36:58.390]                       is.null <- base::is.null
[13:36:58.390]                       muffled <- FALSE
[13:36:58.390]                       if (inherits(cond, "message")) {
[13:36:58.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.390]                         if (muffled) 
[13:36:58.390]                           invokeRestart("muffleMessage")
[13:36:58.390]                       }
[13:36:58.390]                       else if (inherits(cond, "warning")) {
[13:36:58.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.390]                         if (muffled) 
[13:36:58.390]                           invokeRestart("muffleWarning")
[13:36:58.390]                       }
[13:36:58.390]                       else if (inherits(cond, "condition")) {
[13:36:58.390]                         if (!is.null(pattern)) {
[13:36:58.390]                           computeRestarts <- base::computeRestarts
[13:36:58.390]                           grepl <- base::grepl
[13:36:58.390]                           restarts <- computeRestarts(cond)
[13:36:58.390]                           for (restart in restarts) {
[13:36:58.390]                             name <- restart$name
[13:36:58.390]                             if (is.null(name)) 
[13:36:58.390]                               next
[13:36:58.390]                             if (!grepl(pattern, name)) 
[13:36:58.390]                               next
[13:36:58.390]                             invokeRestart(restart)
[13:36:58.390]                             muffled <- TRUE
[13:36:58.390]                             break
[13:36:58.390]                           }
[13:36:58.390]                         }
[13:36:58.390]                       }
[13:36:58.390]                       invisible(muffled)
[13:36:58.390]                     }
[13:36:58.390]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.390]                   }
[13:36:58.390]                 }
[13:36:58.390]                 else {
[13:36:58.390]                   if (TRUE) {
[13:36:58.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.390]                     {
[13:36:58.390]                       inherits <- base::inherits
[13:36:58.390]                       invokeRestart <- base::invokeRestart
[13:36:58.390]                       is.null <- base::is.null
[13:36:58.390]                       muffled <- FALSE
[13:36:58.390]                       if (inherits(cond, "message")) {
[13:36:58.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.390]                         if (muffled) 
[13:36:58.390]                           invokeRestart("muffleMessage")
[13:36:58.390]                       }
[13:36:58.390]                       else if (inherits(cond, "warning")) {
[13:36:58.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.390]                         if (muffled) 
[13:36:58.390]                           invokeRestart("muffleWarning")
[13:36:58.390]                       }
[13:36:58.390]                       else if (inherits(cond, "condition")) {
[13:36:58.390]                         if (!is.null(pattern)) {
[13:36:58.390]                           computeRestarts <- base::computeRestarts
[13:36:58.390]                           grepl <- base::grepl
[13:36:58.390]                           restarts <- computeRestarts(cond)
[13:36:58.390]                           for (restart in restarts) {
[13:36:58.390]                             name <- restart$name
[13:36:58.390]                             if (is.null(name)) 
[13:36:58.390]                               next
[13:36:58.390]                             if (!grepl(pattern, name)) 
[13:36:58.390]                               next
[13:36:58.390]                             invokeRestart(restart)
[13:36:58.390]                             muffled <- TRUE
[13:36:58.390]                             break
[13:36:58.390]                           }
[13:36:58.390]                         }
[13:36:58.390]                       }
[13:36:58.390]                       invisible(muffled)
[13:36:58.390]                     }
[13:36:58.390]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.390]                   }
[13:36:58.390]                 }
[13:36:58.390]             }
[13:36:58.390]         }))
[13:36:58.390]     }, error = function(ex) {
[13:36:58.390]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.390]                 ...future.rng), started = ...future.startTime, 
[13:36:58.390]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.390]             version = "1.8"), class = "FutureResult")
[13:36:58.390]     }, finally = {
[13:36:58.390]         if (!identical(...future.workdir, getwd())) 
[13:36:58.390]             setwd(...future.workdir)
[13:36:58.390]         {
[13:36:58.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.390]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.390]             }
[13:36:58.390]             base::options(...future.oldOptions)
[13:36:58.390]             if (.Platform$OS.type == "windows") {
[13:36:58.390]                 old_names <- names(...future.oldEnvVars)
[13:36:58.390]                 envs <- base::Sys.getenv()
[13:36:58.390]                 names <- names(envs)
[13:36:58.390]                 common <- intersect(names, old_names)
[13:36:58.390]                 added <- setdiff(names, old_names)
[13:36:58.390]                 removed <- setdiff(old_names, names)
[13:36:58.390]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.390]                   envs[common]]
[13:36:58.390]                 NAMES <- toupper(changed)
[13:36:58.390]                 args <- list()
[13:36:58.390]                 for (kk in seq_along(NAMES)) {
[13:36:58.390]                   name <- changed[[kk]]
[13:36:58.390]                   NAME <- NAMES[[kk]]
[13:36:58.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.390]                     next
[13:36:58.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.390]                 }
[13:36:58.390]                 NAMES <- toupper(added)
[13:36:58.390]                 for (kk in seq_along(NAMES)) {
[13:36:58.390]                   name <- added[[kk]]
[13:36:58.390]                   NAME <- NAMES[[kk]]
[13:36:58.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.390]                     next
[13:36:58.390]                   args[[name]] <- ""
[13:36:58.390]                 }
[13:36:58.390]                 NAMES <- toupper(removed)
[13:36:58.390]                 for (kk in seq_along(NAMES)) {
[13:36:58.390]                   name <- removed[[kk]]
[13:36:58.390]                   NAME <- NAMES[[kk]]
[13:36:58.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.390]                     next
[13:36:58.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.390]                 }
[13:36:58.390]                 if (length(args) > 0) 
[13:36:58.390]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.390]             }
[13:36:58.390]             else {
[13:36:58.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.390]             }
[13:36:58.390]             {
[13:36:58.390]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.390]                   0L) {
[13:36:58.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.390]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.390]                   base::options(opts)
[13:36:58.390]                 }
[13:36:58.390]                 {
[13:36:58.390]                   {
[13:36:58.390]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.390]                     NULL
[13:36:58.390]                   }
[13:36:58.390]                   options(future.plan = NULL)
[13:36:58.390]                   if (is.na(NA_character_)) 
[13:36:58.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.390]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.390]                     .init = FALSE)
[13:36:58.390]                 }
[13:36:58.390]             }
[13:36:58.390]         }
[13:36:58.390]     })
[13:36:58.390]     if (TRUE) {
[13:36:58.390]         base::sink(type = "output", split = FALSE)
[13:36:58.390]         if (TRUE) {
[13:36:58.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.390]         }
[13:36:58.390]         else {
[13:36:58.390]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.390]         }
[13:36:58.390]         base::close(...future.stdout)
[13:36:58.390]         ...future.stdout <- NULL
[13:36:58.390]     }
[13:36:58.390]     ...future.result$conditions <- ...future.conditions
[13:36:58.390]     ...future.result$finished <- base::Sys.time()
[13:36:58.390]     ...future.result
[13:36:58.390] }
[13:36:58.443] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:36:58.444] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:36:58.444] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:36:58.444] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:36:58.445] MultisessionFuture started
[13:36:58.445] - Launch lazy future ... done
[13:36:58.445] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.446] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.446] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.448] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.449] Searching for globals ... DONE
[13:36:58.449] Resolving globals: TRUE
[13:36:58.449] Resolving any globals that are futures ...
[13:36:58.449] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.449] Resolving any globals that are futures ... DONE
[13:36:58.450] Resolving futures part of globals (recursively) ...
[13:36:58.450] resolve() on list ...
[13:36:58.450]  recursive: 99
[13:36:58.451]  length: 1
[13:36:58.451]  elements: ‘ii’
[13:36:58.451]  length: 0 (resolved future 1)
[13:36:58.451] resolve() on list ... DONE
[13:36:58.451] - globals: [1] ‘ii’
[13:36:58.451] Resolving futures part of globals (recursively) ... DONE
[13:36:58.452] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:58.452] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:58.452] - globals: [1] ‘ii’
[13:36:58.452] 
[13:36:58.453] getGlobalsAndPackages() ... DONE
[13:36:58.453] run() for ‘Future’ ...
[13:36:58.453] - state: ‘created’
[13:36:58.453] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.471] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.471] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.471]   - Field: ‘node’
[13:36:58.471]   - Field: ‘label’
[13:36:58.471]   - Field: ‘local’
[13:36:58.471]   - Field: ‘owner’
[13:36:58.472]   - Field: ‘envir’
[13:36:58.472]   - Field: ‘workers’
[13:36:58.472]   - Field: ‘packages’
[13:36:58.472]   - Field: ‘gc’
[13:36:58.472]   - Field: ‘conditions’
[13:36:58.472]   - Field: ‘persistent’
[13:36:58.473]   - Field: ‘expr’
[13:36:58.473]   - Field: ‘uuid’
[13:36:58.473]   - Field: ‘seed’
[13:36:58.473]   - Field: ‘version’
[13:36:58.473]   - Field: ‘result’
[13:36:58.473]   - Field: ‘asynchronous’
[13:36:58.474]   - Field: ‘calls’
[13:36:58.474]   - Field: ‘globals’
[13:36:58.474]   - Field: ‘stdout’
[13:36:58.474]   - Field: ‘earlySignal’
[13:36:58.474]   - Field: ‘lazy’
[13:36:58.474]   - Field: ‘state’
[13:36:58.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.475] - Launch lazy future ...
[13:36:58.475] Packages needed by the future expression (n = 0): <none>
[13:36:58.475] Packages needed by future strategies (n = 0): <none>
[13:36:58.476] {
[13:36:58.476]     {
[13:36:58.476]         {
[13:36:58.476]             ...future.startTime <- base::Sys.time()
[13:36:58.476]             {
[13:36:58.476]                 {
[13:36:58.476]                   {
[13:36:58.476]                     {
[13:36:58.476]                       base::local({
[13:36:58.476]                         has_future <- base::requireNamespace("future", 
[13:36:58.476]                           quietly = TRUE)
[13:36:58.476]                         if (has_future) {
[13:36:58.476]                           ns <- base::getNamespace("future")
[13:36:58.476]                           version <- ns[[".package"]][["version"]]
[13:36:58.476]                           if (is.null(version)) 
[13:36:58.476]                             version <- utils::packageVersion("future")
[13:36:58.476]                         }
[13:36:58.476]                         else {
[13:36:58.476]                           version <- NULL
[13:36:58.476]                         }
[13:36:58.476]                         if (!has_future || version < "1.8.0") {
[13:36:58.476]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.476]                             "", base::R.version$version.string), 
[13:36:58.476]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.476]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.476]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.476]                               "release", "version")], collapse = " "), 
[13:36:58.476]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.476]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.476]                             info)
[13:36:58.476]                           info <- base::paste(info, collapse = "; ")
[13:36:58.476]                           if (!has_future) {
[13:36:58.476]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.476]                               info)
[13:36:58.476]                           }
[13:36:58.476]                           else {
[13:36:58.476]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.476]                               info, version)
[13:36:58.476]                           }
[13:36:58.476]                           base::stop(msg)
[13:36:58.476]                         }
[13:36:58.476]                       })
[13:36:58.476]                     }
[13:36:58.476]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.476]                     base::options(mc.cores = 1L)
[13:36:58.476]                   }
[13:36:58.476]                   ...future.strategy.old <- future::plan("list")
[13:36:58.476]                   options(future.plan = NULL)
[13:36:58.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.476]                 }
[13:36:58.476]                 ...future.workdir <- getwd()
[13:36:58.476]             }
[13:36:58.476]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.476]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.476]         }
[13:36:58.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.476]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.476]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.476]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.476]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.476]             base::names(...future.oldOptions))
[13:36:58.476]     }
[13:36:58.476]     if (FALSE) {
[13:36:58.476]     }
[13:36:58.476]     else {
[13:36:58.476]         if (TRUE) {
[13:36:58.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.476]                 open = "w")
[13:36:58.476]         }
[13:36:58.476]         else {
[13:36:58.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.476]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.476]         }
[13:36:58.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.476]             base::sink(type = "output", split = FALSE)
[13:36:58.476]             base::close(...future.stdout)
[13:36:58.476]         }, add = TRUE)
[13:36:58.476]     }
[13:36:58.476]     ...future.frame <- base::sys.nframe()
[13:36:58.476]     ...future.conditions <- base::list()
[13:36:58.476]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.476]     if (FALSE) {
[13:36:58.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.476]     }
[13:36:58.476]     ...future.result <- base::tryCatch({
[13:36:58.476]         base::withCallingHandlers({
[13:36:58.476]             ...future.value <- base::withVisible(base::local({
[13:36:58.476]                 ...future.makeSendCondition <- base::local({
[13:36:58.476]                   sendCondition <- NULL
[13:36:58.476]                   function(frame = 1L) {
[13:36:58.476]                     if (is.function(sendCondition)) 
[13:36:58.476]                       return(sendCondition)
[13:36:58.476]                     ns <- getNamespace("parallel")
[13:36:58.476]                     if (exists("sendData", mode = "function", 
[13:36:58.476]                       envir = ns)) {
[13:36:58.476]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.476]                         envir = ns)
[13:36:58.476]                       envir <- sys.frame(frame)
[13:36:58.476]                       master <- NULL
[13:36:58.476]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.476]                         !identical(envir, emptyenv())) {
[13:36:58.476]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.476]                           inherits = FALSE)) {
[13:36:58.476]                           master <- get("master", mode = "list", 
[13:36:58.476]                             envir = envir, inherits = FALSE)
[13:36:58.476]                           if (inherits(master, c("SOCKnode", 
[13:36:58.476]                             "SOCK0node"))) {
[13:36:58.476]                             sendCondition <<- function(cond) {
[13:36:58.476]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.476]                                 success = TRUE)
[13:36:58.476]                               parallel_sendData(master, data)
[13:36:58.476]                             }
[13:36:58.476]                             return(sendCondition)
[13:36:58.476]                           }
[13:36:58.476]                         }
[13:36:58.476]                         frame <- frame + 1L
[13:36:58.476]                         envir <- sys.frame(frame)
[13:36:58.476]                       }
[13:36:58.476]                     }
[13:36:58.476]                     sendCondition <<- function(cond) NULL
[13:36:58.476]                   }
[13:36:58.476]                 })
[13:36:58.476]                 withCallingHandlers({
[13:36:58.476]                   {
[13:36:58.476]                     b <- a * ii
[13:36:58.476]                     a <- 0
[13:36:58.476]                     b
[13:36:58.476]                   }
[13:36:58.476]                 }, immediateCondition = function(cond) {
[13:36:58.476]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.476]                   sendCondition(cond)
[13:36:58.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.476]                   {
[13:36:58.476]                     inherits <- base::inherits
[13:36:58.476]                     invokeRestart <- base::invokeRestart
[13:36:58.476]                     is.null <- base::is.null
[13:36:58.476]                     muffled <- FALSE
[13:36:58.476]                     if (inherits(cond, "message")) {
[13:36:58.476]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.476]                       if (muffled) 
[13:36:58.476]                         invokeRestart("muffleMessage")
[13:36:58.476]                     }
[13:36:58.476]                     else if (inherits(cond, "warning")) {
[13:36:58.476]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.476]                       if (muffled) 
[13:36:58.476]                         invokeRestart("muffleWarning")
[13:36:58.476]                     }
[13:36:58.476]                     else if (inherits(cond, "condition")) {
[13:36:58.476]                       if (!is.null(pattern)) {
[13:36:58.476]                         computeRestarts <- base::computeRestarts
[13:36:58.476]                         grepl <- base::grepl
[13:36:58.476]                         restarts <- computeRestarts(cond)
[13:36:58.476]                         for (restart in restarts) {
[13:36:58.476]                           name <- restart$name
[13:36:58.476]                           if (is.null(name)) 
[13:36:58.476]                             next
[13:36:58.476]                           if (!grepl(pattern, name)) 
[13:36:58.476]                             next
[13:36:58.476]                           invokeRestart(restart)
[13:36:58.476]                           muffled <- TRUE
[13:36:58.476]                           break
[13:36:58.476]                         }
[13:36:58.476]                       }
[13:36:58.476]                     }
[13:36:58.476]                     invisible(muffled)
[13:36:58.476]                   }
[13:36:58.476]                   muffleCondition(cond)
[13:36:58.476]                 })
[13:36:58.476]             }))
[13:36:58.476]             future::FutureResult(value = ...future.value$value, 
[13:36:58.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.476]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.476]                     ...future.globalenv.names))
[13:36:58.476]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.476]         }, condition = base::local({
[13:36:58.476]             c <- base::c
[13:36:58.476]             inherits <- base::inherits
[13:36:58.476]             invokeRestart <- base::invokeRestart
[13:36:58.476]             length <- base::length
[13:36:58.476]             list <- base::list
[13:36:58.476]             seq.int <- base::seq.int
[13:36:58.476]             signalCondition <- base::signalCondition
[13:36:58.476]             sys.calls <- base::sys.calls
[13:36:58.476]             `[[` <- base::`[[`
[13:36:58.476]             `+` <- base::`+`
[13:36:58.476]             `<<-` <- base::`<<-`
[13:36:58.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.476]                   3L)]
[13:36:58.476]             }
[13:36:58.476]             function(cond) {
[13:36:58.476]                 is_error <- inherits(cond, "error")
[13:36:58.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.476]                   NULL)
[13:36:58.476]                 if (is_error) {
[13:36:58.476]                   sessionInformation <- function() {
[13:36:58.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.476]                       search = base::search(), system = base::Sys.info())
[13:36:58.476]                   }
[13:36:58.476]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.476]                     cond$call), session = sessionInformation(), 
[13:36:58.476]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.476]                   signalCondition(cond)
[13:36:58.476]                 }
[13:36:58.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.476]                 "immediateCondition"))) {
[13:36:58.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.476]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.476]                   if (TRUE && !signal) {
[13:36:58.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.476]                     {
[13:36:58.476]                       inherits <- base::inherits
[13:36:58.476]                       invokeRestart <- base::invokeRestart
[13:36:58.476]                       is.null <- base::is.null
[13:36:58.476]                       muffled <- FALSE
[13:36:58.476]                       if (inherits(cond, "message")) {
[13:36:58.476]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.476]                         if (muffled) 
[13:36:58.476]                           invokeRestart("muffleMessage")
[13:36:58.476]                       }
[13:36:58.476]                       else if (inherits(cond, "warning")) {
[13:36:58.476]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.476]                         if (muffled) 
[13:36:58.476]                           invokeRestart("muffleWarning")
[13:36:58.476]                       }
[13:36:58.476]                       else if (inherits(cond, "condition")) {
[13:36:58.476]                         if (!is.null(pattern)) {
[13:36:58.476]                           computeRestarts <- base::computeRestarts
[13:36:58.476]                           grepl <- base::grepl
[13:36:58.476]                           restarts <- computeRestarts(cond)
[13:36:58.476]                           for (restart in restarts) {
[13:36:58.476]                             name <- restart$name
[13:36:58.476]                             if (is.null(name)) 
[13:36:58.476]                               next
[13:36:58.476]                             if (!grepl(pattern, name)) 
[13:36:58.476]                               next
[13:36:58.476]                             invokeRestart(restart)
[13:36:58.476]                             muffled <- TRUE
[13:36:58.476]                             break
[13:36:58.476]                           }
[13:36:58.476]                         }
[13:36:58.476]                       }
[13:36:58.476]                       invisible(muffled)
[13:36:58.476]                     }
[13:36:58.476]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.476]                   }
[13:36:58.476]                 }
[13:36:58.476]                 else {
[13:36:58.476]                   if (TRUE) {
[13:36:58.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.476]                     {
[13:36:58.476]                       inherits <- base::inherits
[13:36:58.476]                       invokeRestart <- base::invokeRestart
[13:36:58.476]                       is.null <- base::is.null
[13:36:58.476]                       muffled <- FALSE
[13:36:58.476]                       if (inherits(cond, "message")) {
[13:36:58.476]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.476]                         if (muffled) 
[13:36:58.476]                           invokeRestart("muffleMessage")
[13:36:58.476]                       }
[13:36:58.476]                       else if (inherits(cond, "warning")) {
[13:36:58.476]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.476]                         if (muffled) 
[13:36:58.476]                           invokeRestart("muffleWarning")
[13:36:58.476]                       }
[13:36:58.476]                       else if (inherits(cond, "condition")) {
[13:36:58.476]                         if (!is.null(pattern)) {
[13:36:58.476]                           computeRestarts <- base::computeRestarts
[13:36:58.476]                           grepl <- base::grepl
[13:36:58.476]                           restarts <- computeRestarts(cond)
[13:36:58.476]                           for (restart in restarts) {
[13:36:58.476]                             name <- restart$name
[13:36:58.476]                             if (is.null(name)) 
[13:36:58.476]                               next
[13:36:58.476]                             if (!grepl(pattern, name)) 
[13:36:58.476]                               next
[13:36:58.476]                             invokeRestart(restart)
[13:36:58.476]                             muffled <- TRUE
[13:36:58.476]                             break
[13:36:58.476]                           }
[13:36:58.476]                         }
[13:36:58.476]                       }
[13:36:58.476]                       invisible(muffled)
[13:36:58.476]                     }
[13:36:58.476]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.476]                   }
[13:36:58.476]                 }
[13:36:58.476]             }
[13:36:58.476]         }))
[13:36:58.476]     }, error = function(ex) {
[13:36:58.476]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.476]                 ...future.rng), started = ...future.startTime, 
[13:36:58.476]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.476]             version = "1.8"), class = "FutureResult")
[13:36:58.476]     }, finally = {
[13:36:58.476]         if (!identical(...future.workdir, getwd())) 
[13:36:58.476]             setwd(...future.workdir)
[13:36:58.476]         {
[13:36:58.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.476]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.476]             }
[13:36:58.476]             base::options(...future.oldOptions)
[13:36:58.476]             if (.Platform$OS.type == "windows") {
[13:36:58.476]                 old_names <- names(...future.oldEnvVars)
[13:36:58.476]                 envs <- base::Sys.getenv()
[13:36:58.476]                 names <- names(envs)
[13:36:58.476]                 common <- intersect(names, old_names)
[13:36:58.476]                 added <- setdiff(names, old_names)
[13:36:58.476]                 removed <- setdiff(old_names, names)
[13:36:58.476]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.476]                   envs[common]]
[13:36:58.476]                 NAMES <- toupper(changed)
[13:36:58.476]                 args <- list()
[13:36:58.476]                 for (kk in seq_along(NAMES)) {
[13:36:58.476]                   name <- changed[[kk]]
[13:36:58.476]                   NAME <- NAMES[[kk]]
[13:36:58.476]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.476]                     next
[13:36:58.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.476]                 }
[13:36:58.476]                 NAMES <- toupper(added)
[13:36:58.476]                 for (kk in seq_along(NAMES)) {
[13:36:58.476]                   name <- added[[kk]]
[13:36:58.476]                   NAME <- NAMES[[kk]]
[13:36:58.476]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.476]                     next
[13:36:58.476]                   args[[name]] <- ""
[13:36:58.476]                 }
[13:36:58.476]                 NAMES <- toupper(removed)
[13:36:58.476]                 for (kk in seq_along(NAMES)) {
[13:36:58.476]                   name <- removed[[kk]]
[13:36:58.476]                   NAME <- NAMES[[kk]]
[13:36:58.476]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.476]                     next
[13:36:58.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.476]                 }
[13:36:58.476]                 if (length(args) > 0) 
[13:36:58.476]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.476]             }
[13:36:58.476]             else {
[13:36:58.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.476]             }
[13:36:58.476]             {
[13:36:58.476]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.476]                   0L) {
[13:36:58.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.476]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.476]                   base::options(opts)
[13:36:58.476]                 }
[13:36:58.476]                 {
[13:36:58.476]                   {
[13:36:58.476]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.476]                     NULL
[13:36:58.476]                   }
[13:36:58.476]                   options(future.plan = NULL)
[13:36:58.476]                   if (is.na(NA_character_)) 
[13:36:58.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.476]                     .init = FALSE)
[13:36:58.476]                 }
[13:36:58.476]             }
[13:36:58.476]         }
[13:36:58.476]     })
[13:36:58.476]     if (TRUE) {
[13:36:58.476]         base::sink(type = "output", split = FALSE)
[13:36:58.476]         if (TRUE) {
[13:36:58.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.476]         }
[13:36:58.476]         else {
[13:36:58.476]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.476]         }
[13:36:58.476]         base::close(...future.stdout)
[13:36:58.476]         ...future.stdout <- NULL
[13:36:58.476]     }
[13:36:58.476]     ...future.result$conditions <- ...future.conditions
[13:36:58.476]     ...future.result$finished <- base::Sys.time()
[13:36:58.476]     ...future.result
[13:36:58.476] }
[13:36:58.480] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:58.491] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.491] - Validating connection of MultisessionFuture
[13:36:58.492] - received message: FutureResult
[13:36:58.492] - Received FutureResult
[13:36:58.493] - Erased future from FutureRegistry
[13:36:58.493] result() for ClusterFuture ...
[13:36:58.493] - result already collected: FutureResult
[13:36:58.493] result() for ClusterFuture ... done
[13:36:58.493] signalConditions() ...
[13:36:58.493]  - include = ‘immediateCondition’
[13:36:58.494]  - exclude = 
[13:36:58.494]  - resignal = FALSE
[13:36:58.494]  - Number of conditions: 1
[13:36:58.494] signalConditions() ... done
[13:36:58.494] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.494] result() for ClusterFuture ...
[13:36:58.495] - result already collected: FutureResult
[13:36:58.495] result() for ClusterFuture ... done
[13:36:58.495] result() for ClusterFuture ...
[13:36:58.495] - result already collected: FutureResult
[13:36:58.495] result() for ClusterFuture ... done
[13:36:58.495] signalConditions() ...
[13:36:58.496]  - include = ‘immediateCondition’
[13:36:58.496]  - exclude = 
[13:36:58.496]  - resignal = FALSE
[13:36:58.496]  - Number of conditions: 1
[13:36:58.496] signalConditions() ... done
[13:36:58.497] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:36:58.498] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:36:58.498] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:36:58.498] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:36:58.499] MultisessionFuture started
[13:36:58.499] - Launch lazy future ... done
[13:36:58.499] run() for ‘MultisessionFuture’ ... done
[13:36:58.500] result() for ClusterFuture ...
[13:36:58.500] - result already collected: FutureResult
[13:36:58.500] result() for ClusterFuture ... done
[13:36:58.500] result() for ClusterFuture ...
[13:36:58.500] - result already collected: FutureResult
[13:36:58.501] result() for ClusterFuture ... done
[13:36:58.501] signalConditions() ...
[13:36:58.501]  - include = ‘immediateCondition’
[13:36:58.501]  - exclude = 
[13:36:58.501]  - resignal = FALSE
[13:36:58.501]  - Number of conditions: 1
[13:36:58.502] signalConditions() ... done
[13:36:58.502] Future state: ‘finished’
[13:36:58.502] result() for ClusterFuture ...
[13:36:58.502] - result already collected: FutureResult
[13:36:58.502] result() for ClusterFuture ... done
[13:36:58.503] signalConditions() ...
[13:36:58.503]  - include = ‘condition’
[13:36:58.503]  - exclude = ‘immediateCondition’
[13:36:58.503]  - resignal = TRUE
[13:36:58.503]  - Number of conditions: 1
[13:36:58.503]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:58.504] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "57e9b94e809f" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:36:58"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.531] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.532] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.534] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.534] Searching for globals ... DONE
[13:36:58.534] Resolving globals: TRUE
[13:36:58.535] Resolving any globals that are futures ...
[13:36:58.535] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.535] Resolving any globals that are futures ... DONE
[13:36:58.536] Resolving futures part of globals (recursively) ...
[13:36:58.536] resolve() on list ...
[13:36:58.536]  recursive: 99
[13:36:58.536]  length: 1
[13:36:58.536]  elements: ‘ii’
[13:36:58.537]  length: 0 (resolved future 1)
[13:36:58.537] resolve() on list ... DONE
[13:36:58.537] - globals: [1] ‘ii’
[13:36:58.537] Resolving futures part of globals (recursively) ... DONE
[13:36:58.537] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:58.538] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:58.538] - globals: [1] ‘ii’
[13:36:58.538] 
[13:36:58.539] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.540] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.540] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.542] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.542] Searching for globals ... DONE
[13:36:58.543] Resolving globals: TRUE
[13:36:58.543] Resolving any globals that are futures ...
[13:36:58.543] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.543] Resolving any globals that are futures ... DONE
[13:36:58.544] Resolving futures part of globals (recursively) ...
[13:36:58.544] resolve() on list ...
[13:36:58.544]  recursive: 99
[13:36:58.544]  length: 1
[13:36:58.545]  elements: ‘ii’
[13:36:58.545]  length: 0 (resolved future 1)
[13:36:58.545] resolve() on list ... DONE
[13:36:58.545] - globals: [1] ‘ii’
[13:36:58.545] Resolving futures part of globals (recursively) ... DONE
[13:36:58.546] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:58.546] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:58.546] - globals: [1] ‘ii’
[13:36:58.546] 
[13:36:58.547] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.547] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.547] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.549] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.549] Searching for globals ... DONE
[13:36:58.549] Resolving globals: TRUE
[13:36:58.549] Resolving any globals that are futures ...
[13:36:58.549] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:36:58.549] Resolving any globals that are futures ... DONE
[13:36:58.549] Resolving futures part of globals (recursively) ...
[13:36:58.550] resolve() on list ...
[13:36:58.550]  recursive: 99
[13:36:58.550]  length: 1
[13:36:58.550]  elements: ‘ii’
[13:36:58.550]  length: 0 (resolved future 1)
[13:36:58.550] resolve() on list ... DONE
[13:36:58.550] - globals: [1] ‘ii’
[13:36:58.550] Resolving futures part of globals (recursively) ... DONE
[13:36:58.550] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:58.551] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:58.551] - globals: [1] ‘ii’
[13:36:58.551] 
[13:36:58.551] getGlobalsAndPackages() ... DONE
[13:36:58.551] run() for ‘Future’ ...
[13:36:58.551] - state: ‘created’
[13:36:58.552] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.566] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.567]   - Field: ‘node’
[13:36:58.567]   - Field: ‘label’
[13:36:58.567]   - Field: ‘local’
[13:36:58.567]   - Field: ‘owner’
[13:36:58.567]   - Field: ‘envir’
[13:36:58.567]   - Field: ‘workers’
[13:36:58.567]   - Field: ‘packages’
[13:36:58.567]   - Field: ‘gc’
[13:36:58.567]   - Field: ‘conditions’
[13:36:58.567]   - Field: ‘persistent’
[13:36:58.568]   - Field: ‘expr’
[13:36:58.568]   - Field: ‘uuid’
[13:36:58.568]   - Field: ‘seed’
[13:36:58.568]   - Field: ‘version’
[13:36:58.568]   - Field: ‘result’
[13:36:58.568]   - Field: ‘asynchronous’
[13:36:58.568]   - Field: ‘calls’
[13:36:58.568]   - Field: ‘globals’
[13:36:58.568]   - Field: ‘stdout’
[13:36:58.568]   - Field: ‘earlySignal’
[13:36:58.568]   - Field: ‘lazy’
[13:36:58.569]   - Field: ‘state’
[13:36:58.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.569] - Launch lazy future ...
[13:36:58.569] Packages needed by the future expression (n = 0): <none>
[13:36:58.569] Packages needed by future strategies (n = 0): <none>
[13:36:58.570] {
[13:36:58.570]     {
[13:36:58.570]         {
[13:36:58.570]             ...future.startTime <- base::Sys.time()
[13:36:58.570]             {
[13:36:58.570]                 {
[13:36:58.570]                   {
[13:36:58.570]                     {
[13:36:58.570]                       base::local({
[13:36:58.570]                         has_future <- base::requireNamespace("future", 
[13:36:58.570]                           quietly = TRUE)
[13:36:58.570]                         if (has_future) {
[13:36:58.570]                           ns <- base::getNamespace("future")
[13:36:58.570]                           version <- ns[[".package"]][["version"]]
[13:36:58.570]                           if (is.null(version)) 
[13:36:58.570]                             version <- utils::packageVersion("future")
[13:36:58.570]                         }
[13:36:58.570]                         else {
[13:36:58.570]                           version <- NULL
[13:36:58.570]                         }
[13:36:58.570]                         if (!has_future || version < "1.8.0") {
[13:36:58.570]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.570]                             "", base::R.version$version.string), 
[13:36:58.570]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.570]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.570]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.570]                               "release", "version")], collapse = " "), 
[13:36:58.570]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.570]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.570]                             info)
[13:36:58.570]                           info <- base::paste(info, collapse = "; ")
[13:36:58.570]                           if (!has_future) {
[13:36:58.570]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.570]                               info)
[13:36:58.570]                           }
[13:36:58.570]                           else {
[13:36:58.570]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.570]                               info, version)
[13:36:58.570]                           }
[13:36:58.570]                           base::stop(msg)
[13:36:58.570]                         }
[13:36:58.570]                       })
[13:36:58.570]                     }
[13:36:58.570]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.570]                     base::options(mc.cores = 1L)
[13:36:58.570]                   }
[13:36:58.570]                   ...future.strategy.old <- future::plan("list")
[13:36:58.570]                   options(future.plan = NULL)
[13:36:58.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.570]                 }
[13:36:58.570]                 ...future.workdir <- getwd()
[13:36:58.570]             }
[13:36:58.570]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.570]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.570]         }
[13:36:58.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.570]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.570]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.570]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.570]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.570]             base::names(...future.oldOptions))
[13:36:58.570]     }
[13:36:58.570]     if (FALSE) {
[13:36:58.570]     }
[13:36:58.570]     else {
[13:36:58.570]         if (TRUE) {
[13:36:58.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.570]                 open = "w")
[13:36:58.570]         }
[13:36:58.570]         else {
[13:36:58.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.570]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.570]         }
[13:36:58.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.570]             base::sink(type = "output", split = FALSE)
[13:36:58.570]             base::close(...future.stdout)
[13:36:58.570]         }, add = TRUE)
[13:36:58.570]     }
[13:36:58.570]     ...future.frame <- base::sys.nframe()
[13:36:58.570]     ...future.conditions <- base::list()
[13:36:58.570]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.570]     if (FALSE) {
[13:36:58.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.570]     }
[13:36:58.570]     ...future.result <- base::tryCatch({
[13:36:58.570]         base::withCallingHandlers({
[13:36:58.570]             ...future.value <- base::withVisible(base::local({
[13:36:58.570]                 ...future.makeSendCondition <- base::local({
[13:36:58.570]                   sendCondition <- NULL
[13:36:58.570]                   function(frame = 1L) {
[13:36:58.570]                     if (is.function(sendCondition)) 
[13:36:58.570]                       return(sendCondition)
[13:36:58.570]                     ns <- getNamespace("parallel")
[13:36:58.570]                     if (exists("sendData", mode = "function", 
[13:36:58.570]                       envir = ns)) {
[13:36:58.570]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.570]                         envir = ns)
[13:36:58.570]                       envir <- sys.frame(frame)
[13:36:58.570]                       master <- NULL
[13:36:58.570]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.570]                         !identical(envir, emptyenv())) {
[13:36:58.570]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.570]                           inherits = FALSE)) {
[13:36:58.570]                           master <- get("master", mode = "list", 
[13:36:58.570]                             envir = envir, inherits = FALSE)
[13:36:58.570]                           if (inherits(master, c("SOCKnode", 
[13:36:58.570]                             "SOCK0node"))) {
[13:36:58.570]                             sendCondition <<- function(cond) {
[13:36:58.570]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.570]                                 success = TRUE)
[13:36:58.570]                               parallel_sendData(master, data)
[13:36:58.570]                             }
[13:36:58.570]                             return(sendCondition)
[13:36:58.570]                           }
[13:36:58.570]                         }
[13:36:58.570]                         frame <- frame + 1L
[13:36:58.570]                         envir <- sys.frame(frame)
[13:36:58.570]                       }
[13:36:58.570]                     }
[13:36:58.570]                     sendCondition <<- function(cond) NULL
[13:36:58.570]                   }
[13:36:58.570]                 })
[13:36:58.570]                 withCallingHandlers({
[13:36:58.570]                   {
[13:36:58.570]                     b <- a * ii
[13:36:58.570]                     a <- 0
[13:36:58.570]                     b
[13:36:58.570]                   }
[13:36:58.570]                 }, immediateCondition = function(cond) {
[13:36:58.570]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.570]                   sendCondition(cond)
[13:36:58.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.570]                   {
[13:36:58.570]                     inherits <- base::inherits
[13:36:58.570]                     invokeRestart <- base::invokeRestart
[13:36:58.570]                     is.null <- base::is.null
[13:36:58.570]                     muffled <- FALSE
[13:36:58.570]                     if (inherits(cond, "message")) {
[13:36:58.570]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.570]                       if (muffled) 
[13:36:58.570]                         invokeRestart("muffleMessage")
[13:36:58.570]                     }
[13:36:58.570]                     else if (inherits(cond, "warning")) {
[13:36:58.570]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.570]                       if (muffled) 
[13:36:58.570]                         invokeRestart("muffleWarning")
[13:36:58.570]                     }
[13:36:58.570]                     else if (inherits(cond, "condition")) {
[13:36:58.570]                       if (!is.null(pattern)) {
[13:36:58.570]                         computeRestarts <- base::computeRestarts
[13:36:58.570]                         grepl <- base::grepl
[13:36:58.570]                         restarts <- computeRestarts(cond)
[13:36:58.570]                         for (restart in restarts) {
[13:36:58.570]                           name <- restart$name
[13:36:58.570]                           if (is.null(name)) 
[13:36:58.570]                             next
[13:36:58.570]                           if (!grepl(pattern, name)) 
[13:36:58.570]                             next
[13:36:58.570]                           invokeRestart(restart)
[13:36:58.570]                           muffled <- TRUE
[13:36:58.570]                           break
[13:36:58.570]                         }
[13:36:58.570]                       }
[13:36:58.570]                     }
[13:36:58.570]                     invisible(muffled)
[13:36:58.570]                   }
[13:36:58.570]                   muffleCondition(cond)
[13:36:58.570]                 })
[13:36:58.570]             }))
[13:36:58.570]             future::FutureResult(value = ...future.value$value, 
[13:36:58.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.570]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.570]                     ...future.globalenv.names))
[13:36:58.570]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.570]         }, condition = base::local({
[13:36:58.570]             c <- base::c
[13:36:58.570]             inherits <- base::inherits
[13:36:58.570]             invokeRestart <- base::invokeRestart
[13:36:58.570]             length <- base::length
[13:36:58.570]             list <- base::list
[13:36:58.570]             seq.int <- base::seq.int
[13:36:58.570]             signalCondition <- base::signalCondition
[13:36:58.570]             sys.calls <- base::sys.calls
[13:36:58.570]             `[[` <- base::`[[`
[13:36:58.570]             `+` <- base::`+`
[13:36:58.570]             `<<-` <- base::`<<-`
[13:36:58.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.570]                   3L)]
[13:36:58.570]             }
[13:36:58.570]             function(cond) {
[13:36:58.570]                 is_error <- inherits(cond, "error")
[13:36:58.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.570]                   NULL)
[13:36:58.570]                 if (is_error) {
[13:36:58.570]                   sessionInformation <- function() {
[13:36:58.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.570]                       search = base::search(), system = base::Sys.info())
[13:36:58.570]                   }
[13:36:58.570]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.570]                     cond$call), session = sessionInformation(), 
[13:36:58.570]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.570]                   signalCondition(cond)
[13:36:58.570]                 }
[13:36:58.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.570]                 "immediateCondition"))) {
[13:36:58.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.570]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.570]                   if (TRUE && !signal) {
[13:36:58.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.570]                     {
[13:36:58.570]                       inherits <- base::inherits
[13:36:58.570]                       invokeRestart <- base::invokeRestart
[13:36:58.570]                       is.null <- base::is.null
[13:36:58.570]                       muffled <- FALSE
[13:36:58.570]                       if (inherits(cond, "message")) {
[13:36:58.570]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.570]                         if (muffled) 
[13:36:58.570]                           invokeRestart("muffleMessage")
[13:36:58.570]                       }
[13:36:58.570]                       else if (inherits(cond, "warning")) {
[13:36:58.570]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.570]                         if (muffled) 
[13:36:58.570]                           invokeRestart("muffleWarning")
[13:36:58.570]                       }
[13:36:58.570]                       else if (inherits(cond, "condition")) {
[13:36:58.570]                         if (!is.null(pattern)) {
[13:36:58.570]                           computeRestarts <- base::computeRestarts
[13:36:58.570]                           grepl <- base::grepl
[13:36:58.570]                           restarts <- computeRestarts(cond)
[13:36:58.570]                           for (restart in restarts) {
[13:36:58.570]                             name <- restart$name
[13:36:58.570]                             if (is.null(name)) 
[13:36:58.570]                               next
[13:36:58.570]                             if (!grepl(pattern, name)) 
[13:36:58.570]                               next
[13:36:58.570]                             invokeRestart(restart)
[13:36:58.570]                             muffled <- TRUE
[13:36:58.570]                             break
[13:36:58.570]                           }
[13:36:58.570]                         }
[13:36:58.570]                       }
[13:36:58.570]                       invisible(muffled)
[13:36:58.570]                     }
[13:36:58.570]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.570]                   }
[13:36:58.570]                 }
[13:36:58.570]                 else {
[13:36:58.570]                   if (TRUE) {
[13:36:58.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.570]                     {
[13:36:58.570]                       inherits <- base::inherits
[13:36:58.570]                       invokeRestart <- base::invokeRestart
[13:36:58.570]                       is.null <- base::is.null
[13:36:58.570]                       muffled <- FALSE
[13:36:58.570]                       if (inherits(cond, "message")) {
[13:36:58.570]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.570]                         if (muffled) 
[13:36:58.570]                           invokeRestart("muffleMessage")
[13:36:58.570]                       }
[13:36:58.570]                       else if (inherits(cond, "warning")) {
[13:36:58.570]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.570]                         if (muffled) 
[13:36:58.570]                           invokeRestart("muffleWarning")
[13:36:58.570]                       }
[13:36:58.570]                       else if (inherits(cond, "condition")) {
[13:36:58.570]                         if (!is.null(pattern)) {
[13:36:58.570]                           computeRestarts <- base::computeRestarts
[13:36:58.570]                           grepl <- base::grepl
[13:36:58.570]                           restarts <- computeRestarts(cond)
[13:36:58.570]                           for (restart in restarts) {
[13:36:58.570]                             name <- restart$name
[13:36:58.570]                             if (is.null(name)) 
[13:36:58.570]                               next
[13:36:58.570]                             if (!grepl(pattern, name)) 
[13:36:58.570]                               next
[13:36:58.570]                             invokeRestart(restart)
[13:36:58.570]                             muffled <- TRUE
[13:36:58.570]                             break
[13:36:58.570]                           }
[13:36:58.570]                         }
[13:36:58.570]                       }
[13:36:58.570]                       invisible(muffled)
[13:36:58.570]                     }
[13:36:58.570]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.570]                   }
[13:36:58.570]                 }
[13:36:58.570]             }
[13:36:58.570]         }))
[13:36:58.570]     }, error = function(ex) {
[13:36:58.570]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.570]                 ...future.rng), started = ...future.startTime, 
[13:36:58.570]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.570]             version = "1.8"), class = "FutureResult")
[13:36:58.570]     }, finally = {
[13:36:58.570]         if (!identical(...future.workdir, getwd())) 
[13:36:58.570]             setwd(...future.workdir)
[13:36:58.570]         {
[13:36:58.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.570]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.570]             }
[13:36:58.570]             base::options(...future.oldOptions)
[13:36:58.570]             if (.Platform$OS.type == "windows") {
[13:36:58.570]                 old_names <- names(...future.oldEnvVars)
[13:36:58.570]                 envs <- base::Sys.getenv()
[13:36:58.570]                 names <- names(envs)
[13:36:58.570]                 common <- intersect(names, old_names)
[13:36:58.570]                 added <- setdiff(names, old_names)
[13:36:58.570]                 removed <- setdiff(old_names, names)
[13:36:58.570]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.570]                   envs[common]]
[13:36:58.570]                 NAMES <- toupper(changed)
[13:36:58.570]                 args <- list()
[13:36:58.570]                 for (kk in seq_along(NAMES)) {
[13:36:58.570]                   name <- changed[[kk]]
[13:36:58.570]                   NAME <- NAMES[[kk]]
[13:36:58.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.570]                     next
[13:36:58.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.570]                 }
[13:36:58.570]                 NAMES <- toupper(added)
[13:36:58.570]                 for (kk in seq_along(NAMES)) {
[13:36:58.570]                   name <- added[[kk]]
[13:36:58.570]                   NAME <- NAMES[[kk]]
[13:36:58.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.570]                     next
[13:36:58.570]                   args[[name]] <- ""
[13:36:58.570]                 }
[13:36:58.570]                 NAMES <- toupper(removed)
[13:36:58.570]                 for (kk in seq_along(NAMES)) {
[13:36:58.570]                   name <- removed[[kk]]
[13:36:58.570]                   NAME <- NAMES[[kk]]
[13:36:58.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.570]                     next
[13:36:58.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.570]                 }
[13:36:58.570]                 if (length(args) > 0) 
[13:36:58.570]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.570]             }
[13:36:58.570]             else {
[13:36:58.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.570]             }
[13:36:58.570]             {
[13:36:58.570]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.570]                   0L) {
[13:36:58.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.570]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.570]                   base::options(opts)
[13:36:58.570]                 }
[13:36:58.570]                 {
[13:36:58.570]                   {
[13:36:58.570]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.570]                     NULL
[13:36:58.570]                   }
[13:36:58.570]                   options(future.plan = NULL)
[13:36:58.570]                   if (is.na(NA_character_)) 
[13:36:58.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.570]                     .init = FALSE)
[13:36:58.570]                 }
[13:36:58.570]             }
[13:36:58.570]         }
[13:36:58.570]     })
[13:36:58.570]     if (TRUE) {
[13:36:58.570]         base::sink(type = "output", split = FALSE)
[13:36:58.570]         if (TRUE) {
[13:36:58.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.570]         }
[13:36:58.570]         else {
[13:36:58.570]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.570]         }
[13:36:58.570]         base::close(...future.stdout)
[13:36:58.570]         ...future.stdout <- NULL
[13:36:58.570]     }
[13:36:58.570]     ...future.result$conditions <- ...future.conditions
[13:36:58.570]     ...future.result$finished <- base::Sys.time()
[13:36:58.570]     ...future.result
[13:36:58.570] }
[13:36:58.572] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:58.582] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.583] - Validating connection of MultisessionFuture
[13:36:58.583] - received message: FutureResult
[13:36:58.583] - Received FutureResult
[13:36:58.583] - Erased future from FutureRegistry
[13:36:58.583] result() for ClusterFuture ...
[13:36:58.584] - result already collected: FutureResult
[13:36:58.584] result() for ClusterFuture ... done
[13:36:58.584] signalConditions() ...
[13:36:58.584]  - include = ‘immediateCondition’
[13:36:58.584]  - exclude = 
[13:36:58.584]  - resignal = FALSE
[13:36:58.584]  - Number of conditions: 1
[13:36:58.584] signalConditions() ... done
[13:36:58.584] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.584] result() for ClusterFuture ...
[13:36:58.584] - result already collected: FutureResult
[13:36:58.585] result() for ClusterFuture ... done
[13:36:58.585] result() for ClusterFuture ...
[13:36:58.585] - result already collected: FutureResult
[13:36:58.585] result() for ClusterFuture ... done
[13:36:58.585] signalConditions() ...
[13:36:58.585]  - include = ‘immediateCondition’
[13:36:58.585]  - exclude = 
[13:36:58.585]  - resignal = FALSE
[13:36:58.585]  - Number of conditions: 1
[13:36:58.585] signalConditions() ... done
[13:36:58.586] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:36:58.586] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:36:58.587] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:36:58.587] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:36:58.587] MultisessionFuture started
[13:36:58.587] - Launch lazy future ... done
[13:36:58.588] run() for ‘MultisessionFuture’ ... done
[13:36:58.588] result() for ClusterFuture ...
[13:36:58.588] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.588] - Validating connection of MultisessionFuture
[13:36:58.594] - received message: FutureResult
[13:36:58.594] - Received FutureResult
[13:36:58.594] - Erased future from FutureRegistry
[13:36:58.594] result() for ClusterFuture ...
[13:36:58.594] - result already collected: FutureResult
[13:36:58.594] result() for ClusterFuture ... done
[13:36:58.594] signalConditions() ...
[13:36:58.594]  - include = ‘immediateCondition’
[13:36:58.594]  - exclude = 
[13:36:58.595]  - resignal = FALSE
[13:36:58.595]  - Number of conditions: 1
[13:36:58.595] signalConditions() ... done
[13:36:58.595] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.595] result() for ClusterFuture ... done
[13:36:58.595] result() for ClusterFuture ...
[13:36:58.595] - result already collected: FutureResult
[13:36:58.595] result() for ClusterFuture ... done
[13:36:58.595] signalConditions() ...
[13:36:58.595]  - include = ‘immediateCondition’
[13:36:58.595]  - exclude = 
[13:36:58.596]  - resignal = FALSE
[13:36:58.596]  - Number of conditions: 1
[13:36:58.596] signalConditions() ... done
[13:36:58.596] Future state: ‘finished’
[13:36:58.596] result() for ClusterFuture ...
[13:36:58.596] - result already collected: FutureResult
[13:36:58.596] result() for ClusterFuture ... done
[13:36:58.596] signalConditions() ...
[13:36:58.596]  - include = ‘condition’
[13:36:58.596]  - exclude = ‘immediateCondition’
[13:36:58.596]  - resignal = TRUE
[13:36:58.597]  - Number of conditions: 1
[13:36:58.597]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:58.597] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "57e9b94e809f" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:36:58"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.611] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.611] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.611] 
[13:36:58.611] Searching for globals ... DONE
[13:36:58.612] - globals: [0] <none>
[13:36:58.612] getGlobalsAndPackages() ... DONE
[13:36:58.612] run() for ‘Future’ ...
[13:36:58.612] - state: ‘created’
[13:36:58.612] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.626] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.626]   - Field: ‘node’
[13:36:58.626]   - Field: ‘label’
[13:36:58.626]   - Field: ‘local’
[13:36:58.626]   - Field: ‘owner’
[13:36:58.626]   - Field: ‘envir’
[13:36:58.627]   - Field: ‘workers’
[13:36:58.627]   - Field: ‘packages’
[13:36:58.627]   - Field: ‘gc’
[13:36:58.627]   - Field: ‘conditions’
[13:36:58.627]   - Field: ‘persistent’
[13:36:58.627]   - Field: ‘expr’
[13:36:58.627]   - Field: ‘uuid’
[13:36:58.627]   - Field: ‘seed’
[13:36:58.627]   - Field: ‘version’
[13:36:58.627]   - Field: ‘result’
[13:36:58.627]   - Field: ‘asynchronous’
[13:36:58.628]   - Field: ‘calls’
[13:36:58.628]   - Field: ‘globals’
[13:36:58.628]   - Field: ‘stdout’
[13:36:58.628]   - Field: ‘earlySignal’
[13:36:58.628]   - Field: ‘lazy’
[13:36:58.628]   - Field: ‘state’
[13:36:58.628] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.628] - Launch lazy future ...
[13:36:58.628] Packages needed by the future expression (n = 0): <none>
[13:36:58.629] Packages needed by future strategies (n = 0): <none>
[13:36:58.629] {
[13:36:58.629]     {
[13:36:58.629]         {
[13:36:58.629]             ...future.startTime <- base::Sys.time()
[13:36:58.629]             {
[13:36:58.629]                 {
[13:36:58.629]                   {
[13:36:58.629]                     {
[13:36:58.629]                       base::local({
[13:36:58.629]                         has_future <- base::requireNamespace("future", 
[13:36:58.629]                           quietly = TRUE)
[13:36:58.629]                         if (has_future) {
[13:36:58.629]                           ns <- base::getNamespace("future")
[13:36:58.629]                           version <- ns[[".package"]][["version"]]
[13:36:58.629]                           if (is.null(version)) 
[13:36:58.629]                             version <- utils::packageVersion("future")
[13:36:58.629]                         }
[13:36:58.629]                         else {
[13:36:58.629]                           version <- NULL
[13:36:58.629]                         }
[13:36:58.629]                         if (!has_future || version < "1.8.0") {
[13:36:58.629]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.629]                             "", base::R.version$version.string), 
[13:36:58.629]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.629]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.629]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.629]                               "release", "version")], collapse = " "), 
[13:36:58.629]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.629]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.629]                             info)
[13:36:58.629]                           info <- base::paste(info, collapse = "; ")
[13:36:58.629]                           if (!has_future) {
[13:36:58.629]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.629]                               info)
[13:36:58.629]                           }
[13:36:58.629]                           else {
[13:36:58.629]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.629]                               info, version)
[13:36:58.629]                           }
[13:36:58.629]                           base::stop(msg)
[13:36:58.629]                         }
[13:36:58.629]                       })
[13:36:58.629]                     }
[13:36:58.629]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.629]                     base::options(mc.cores = 1L)
[13:36:58.629]                   }
[13:36:58.629]                   ...future.strategy.old <- future::plan("list")
[13:36:58.629]                   options(future.plan = NULL)
[13:36:58.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.629]                 }
[13:36:58.629]                 ...future.workdir <- getwd()
[13:36:58.629]             }
[13:36:58.629]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.629]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.629]         }
[13:36:58.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.629]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.629]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.629]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.629]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.629]             base::names(...future.oldOptions))
[13:36:58.629]     }
[13:36:58.629]     if (FALSE) {
[13:36:58.629]     }
[13:36:58.629]     else {
[13:36:58.629]         if (TRUE) {
[13:36:58.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.629]                 open = "w")
[13:36:58.629]         }
[13:36:58.629]         else {
[13:36:58.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.629]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.629]         }
[13:36:58.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.629]             base::sink(type = "output", split = FALSE)
[13:36:58.629]             base::close(...future.stdout)
[13:36:58.629]         }, add = TRUE)
[13:36:58.629]     }
[13:36:58.629]     ...future.frame <- base::sys.nframe()
[13:36:58.629]     ...future.conditions <- base::list()
[13:36:58.629]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.629]     if (FALSE) {
[13:36:58.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.629]     }
[13:36:58.629]     ...future.result <- base::tryCatch({
[13:36:58.629]         base::withCallingHandlers({
[13:36:58.629]             ...future.value <- base::withVisible(base::local({
[13:36:58.629]                 ...future.makeSendCondition <- base::local({
[13:36:58.629]                   sendCondition <- NULL
[13:36:58.629]                   function(frame = 1L) {
[13:36:58.629]                     if (is.function(sendCondition)) 
[13:36:58.629]                       return(sendCondition)
[13:36:58.629]                     ns <- getNamespace("parallel")
[13:36:58.629]                     if (exists("sendData", mode = "function", 
[13:36:58.629]                       envir = ns)) {
[13:36:58.629]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.629]                         envir = ns)
[13:36:58.629]                       envir <- sys.frame(frame)
[13:36:58.629]                       master <- NULL
[13:36:58.629]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.629]                         !identical(envir, emptyenv())) {
[13:36:58.629]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.629]                           inherits = FALSE)) {
[13:36:58.629]                           master <- get("master", mode = "list", 
[13:36:58.629]                             envir = envir, inherits = FALSE)
[13:36:58.629]                           if (inherits(master, c("SOCKnode", 
[13:36:58.629]                             "SOCK0node"))) {
[13:36:58.629]                             sendCondition <<- function(cond) {
[13:36:58.629]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.629]                                 success = TRUE)
[13:36:58.629]                               parallel_sendData(master, data)
[13:36:58.629]                             }
[13:36:58.629]                             return(sendCondition)
[13:36:58.629]                           }
[13:36:58.629]                         }
[13:36:58.629]                         frame <- frame + 1L
[13:36:58.629]                         envir <- sys.frame(frame)
[13:36:58.629]                       }
[13:36:58.629]                     }
[13:36:58.629]                     sendCondition <<- function(cond) NULL
[13:36:58.629]                   }
[13:36:58.629]                 })
[13:36:58.629]                 withCallingHandlers({
[13:36:58.629]                   1
[13:36:58.629]                 }, immediateCondition = function(cond) {
[13:36:58.629]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.629]                   sendCondition(cond)
[13:36:58.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.629]                   {
[13:36:58.629]                     inherits <- base::inherits
[13:36:58.629]                     invokeRestart <- base::invokeRestart
[13:36:58.629]                     is.null <- base::is.null
[13:36:58.629]                     muffled <- FALSE
[13:36:58.629]                     if (inherits(cond, "message")) {
[13:36:58.629]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.629]                       if (muffled) 
[13:36:58.629]                         invokeRestart("muffleMessage")
[13:36:58.629]                     }
[13:36:58.629]                     else if (inherits(cond, "warning")) {
[13:36:58.629]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.629]                       if (muffled) 
[13:36:58.629]                         invokeRestart("muffleWarning")
[13:36:58.629]                     }
[13:36:58.629]                     else if (inherits(cond, "condition")) {
[13:36:58.629]                       if (!is.null(pattern)) {
[13:36:58.629]                         computeRestarts <- base::computeRestarts
[13:36:58.629]                         grepl <- base::grepl
[13:36:58.629]                         restarts <- computeRestarts(cond)
[13:36:58.629]                         for (restart in restarts) {
[13:36:58.629]                           name <- restart$name
[13:36:58.629]                           if (is.null(name)) 
[13:36:58.629]                             next
[13:36:58.629]                           if (!grepl(pattern, name)) 
[13:36:58.629]                             next
[13:36:58.629]                           invokeRestart(restart)
[13:36:58.629]                           muffled <- TRUE
[13:36:58.629]                           break
[13:36:58.629]                         }
[13:36:58.629]                       }
[13:36:58.629]                     }
[13:36:58.629]                     invisible(muffled)
[13:36:58.629]                   }
[13:36:58.629]                   muffleCondition(cond)
[13:36:58.629]                 })
[13:36:58.629]             }))
[13:36:58.629]             future::FutureResult(value = ...future.value$value, 
[13:36:58.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.629]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.629]                     ...future.globalenv.names))
[13:36:58.629]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.629]         }, condition = base::local({
[13:36:58.629]             c <- base::c
[13:36:58.629]             inherits <- base::inherits
[13:36:58.629]             invokeRestart <- base::invokeRestart
[13:36:58.629]             length <- base::length
[13:36:58.629]             list <- base::list
[13:36:58.629]             seq.int <- base::seq.int
[13:36:58.629]             signalCondition <- base::signalCondition
[13:36:58.629]             sys.calls <- base::sys.calls
[13:36:58.629]             `[[` <- base::`[[`
[13:36:58.629]             `+` <- base::`+`
[13:36:58.629]             `<<-` <- base::`<<-`
[13:36:58.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.629]                   3L)]
[13:36:58.629]             }
[13:36:58.629]             function(cond) {
[13:36:58.629]                 is_error <- inherits(cond, "error")
[13:36:58.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.629]                   NULL)
[13:36:58.629]                 if (is_error) {
[13:36:58.629]                   sessionInformation <- function() {
[13:36:58.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.629]                       search = base::search(), system = base::Sys.info())
[13:36:58.629]                   }
[13:36:58.629]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.629]                     cond$call), session = sessionInformation(), 
[13:36:58.629]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.629]                   signalCondition(cond)
[13:36:58.629]                 }
[13:36:58.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.629]                 "immediateCondition"))) {
[13:36:58.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.629]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.629]                   if (TRUE && !signal) {
[13:36:58.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.629]                     {
[13:36:58.629]                       inherits <- base::inherits
[13:36:58.629]                       invokeRestart <- base::invokeRestart
[13:36:58.629]                       is.null <- base::is.null
[13:36:58.629]                       muffled <- FALSE
[13:36:58.629]                       if (inherits(cond, "message")) {
[13:36:58.629]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.629]                         if (muffled) 
[13:36:58.629]                           invokeRestart("muffleMessage")
[13:36:58.629]                       }
[13:36:58.629]                       else if (inherits(cond, "warning")) {
[13:36:58.629]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.629]                         if (muffled) 
[13:36:58.629]                           invokeRestart("muffleWarning")
[13:36:58.629]                       }
[13:36:58.629]                       else if (inherits(cond, "condition")) {
[13:36:58.629]                         if (!is.null(pattern)) {
[13:36:58.629]                           computeRestarts <- base::computeRestarts
[13:36:58.629]                           grepl <- base::grepl
[13:36:58.629]                           restarts <- computeRestarts(cond)
[13:36:58.629]                           for (restart in restarts) {
[13:36:58.629]                             name <- restart$name
[13:36:58.629]                             if (is.null(name)) 
[13:36:58.629]                               next
[13:36:58.629]                             if (!grepl(pattern, name)) 
[13:36:58.629]                               next
[13:36:58.629]                             invokeRestart(restart)
[13:36:58.629]                             muffled <- TRUE
[13:36:58.629]                             break
[13:36:58.629]                           }
[13:36:58.629]                         }
[13:36:58.629]                       }
[13:36:58.629]                       invisible(muffled)
[13:36:58.629]                     }
[13:36:58.629]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.629]                   }
[13:36:58.629]                 }
[13:36:58.629]                 else {
[13:36:58.629]                   if (TRUE) {
[13:36:58.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.629]                     {
[13:36:58.629]                       inherits <- base::inherits
[13:36:58.629]                       invokeRestart <- base::invokeRestart
[13:36:58.629]                       is.null <- base::is.null
[13:36:58.629]                       muffled <- FALSE
[13:36:58.629]                       if (inherits(cond, "message")) {
[13:36:58.629]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.629]                         if (muffled) 
[13:36:58.629]                           invokeRestart("muffleMessage")
[13:36:58.629]                       }
[13:36:58.629]                       else if (inherits(cond, "warning")) {
[13:36:58.629]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.629]                         if (muffled) 
[13:36:58.629]                           invokeRestart("muffleWarning")
[13:36:58.629]                       }
[13:36:58.629]                       else if (inherits(cond, "condition")) {
[13:36:58.629]                         if (!is.null(pattern)) {
[13:36:58.629]                           computeRestarts <- base::computeRestarts
[13:36:58.629]                           grepl <- base::grepl
[13:36:58.629]                           restarts <- computeRestarts(cond)
[13:36:58.629]                           for (restart in restarts) {
[13:36:58.629]                             name <- restart$name
[13:36:58.629]                             if (is.null(name)) 
[13:36:58.629]                               next
[13:36:58.629]                             if (!grepl(pattern, name)) 
[13:36:58.629]                               next
[13:36:58.629]                             invokeRestart(restart)
[13:36:58.629]                             muffled <- TRUE
[13:36:58.629]                             break
[13:36:58.629]                           }
[13:36:58.629]                         }
[13:36:58.629]                       }
[13:36:58.629]                       invisible(muffled)
[13:36:58.629]                     }
[13:36:58.629]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.629]                   }
[13:36:58.629]                 }
[13:36:58.629]             }
[13:36:58.629]         }))
[13:36:58.629]     }, error = function(ex) {
[13:36:58.629]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.629]                 ...future.rng), started = ...future.startTime, 
[13:36:58.629]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.629]             version = "1.8"), class = "FutureResult")
[13:36:58.629]     }, finally = {
[13:36:58.629]         if (!identical(...future.workdir, getwd())) 
[13:36:58.629]             setwd(...future.workdir)
[13:36:58.629]         {
[13:36:58.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.629]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.629]             }
[13:36:58.629]             base::options(...future.oldOptions)
[13:36:58.629]             if (.Platform$OS.type == "windows") {
[13:36:58.629]                 old_names <- names(...future.oldEnvVars)
[13:36:58.629]                 envs <- base::Sys.getenv()
[13:36:58.629]                 names <- names(envs)
[13:36:58.629]                 common <- intersect(names, old_names)
[13:36:58.629]                 added <- setdiff(names, old_names)
[13:36:58.629]                 removed <- setdiff(old_names, names)
[13:36:58.629]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.629]                   envs[common]]
[13:36:58.629]                 NAMES <- toupper(changed)
[13:36:58.629]                 args <- list()
[13:36:58.629]                 for (kk in seq_along(NAMES)) {
[13:36:58.629]                   name <- changed[[kk]]
[13:36:58.629]                   NAME <- NAMES[[kk]]
[13:36:58.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.629]                     next
[13:36:58.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.629]                 }
[13:36:58.629]                 NAMES <- toupper(added)
[13:36:58.629]                 for (kk in seq_along(NAMES)) {
[13:36:58.629]                   name <- added[[kk]]
[13:36:58.629]                   NAME <- NAMES[[kk]]
[13:36:58.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.629]                     next
[13:36:58.629]                   args[[name]] <- ""
[13:36:58.629]                 }
[13:36:58.629]                 NAMES <- toupper(removed)
[13:36:58.629]                 for (kk in seq_along(NAMES)) {
[13:36:58.629]                   name <- removed[[kk]]
[13:36:58.629]                   NAME <- NAMES[[kk]]
[13:36:58.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.629]                     next
[13:36:58.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.629]                 }
[13:36:58.629]                 if (length(args) > 0) 
[13:36:58.629]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.629]             }
[13:36:58.629]             else {
[13:36:58.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.629]             }
[13:36:58.629]             {
[13:36:58.629]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.629]                   0L) {
[13:36:58.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.629]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.629]                   base::options(opts)
[13:36:58.629]                 }
[13:36:58.629]                 {
[13:36:58.629]                   {
[13:36:58.629]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.629]                     NULL
[13:36:58.629]                   }
[13:36:58.629]                   options(future.plan = NULL)
[13:36:58.629]                   if (is.na(NA_character_)) 
[13:36:58.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.629]                     .init = FALSE)
[13:36:58.629]                 }
[13:36:58.629]             }
[13:36:58.629]         }
[13:36:58.629]     })
[13:36:58.629]     if (TRUE) {
[13:36:58.629]         base::sink(type = "output", split = FALSE)
[13:36:58.629]         if (TRUE) {
[13:36:58.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.629]         }
[13:36:58.629]         else {
[13:36:58.629]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.629]         }
[13:36:58.629]         base::close(...future.stdout)
[13:36:58.629]         ...future.stdout <- NULL
[13:36:58.629]     }
[13:36:58.629]     ...future.result$conditions <- ...future.conditions
[13:36:58.629]     ...future.result$finished <- base::Sys.time()
[13:36:58.629]     ...future.result
[13:36:58.629] }
[13:36:58.632] MultisessionFuture started
[13:36:58.632] - Launch lazy future ... done
[13:36:58.632] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.632] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.632] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.633] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:58.633] Searching for globals ... DONE
[13:36:58.634] Resolving globals: TRUE
[13:36:58.634] Resolving any globals that are futures ...
[13:36:58.634] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:58.634] Resolving any globals that are futures ... DONE
[13:36:58.634] Resolving futures part of globals (recursively) ...
[13:36:58.634] resolve() on list ...
[13:36:58.635]  recursive: 99
[13:36:58.635]  length: 1
[13:36:58.635]  elements: ‘a’
[13:36:58.635] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.635] - Validating connection of MultisessionFuture
[13:36:58.635] - received message: FutureResult
[13:36:58.636] - Received FutureResult
[13:36:58.636] - Erased future from FutureRegistry
[13:36:58.636] result() for ClusterFuture ...
[13:36:58.636] - result already collected: FutureResult
[13:36:58.636] result() for ClusterFuture ... done
[13:36:58.636] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.636] Future #1
[13:36:58.636] result() for ClusterFuture ...
[13:36:58.636] - result already collected: FutureResult
[13:36:58.636] result() for ClusterFuture ... done
[13:36:58.636] result() for ClusterFuture ...
[13:36:58.637] - result already collected: FutureResult
[13:36:58.637] result() for ClusterFuture ... done
[13:36:58.637] A MultisessionFuture was resolved
[13:36:58.637]  length: 0 (resolved future 1)
[13:36:58.637] resolve() on list ... DONE
[13:36:58.637] - globals: [1] ‘a’
[13:36:58.637] Resolving futures part of globals (recursively) ... DONE
[13:36:58.638] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[13:36:58.638] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[13:36:58.639] - globals: [1] ‘a’
[13:36:58.639] - packages: [1] ‘future’
[13:36:58.639] getGlobalsAndPackages() ... DONE
[13:36:58.639] run() for ‘Future’ ...
[13:36:58.639] - state: ‘created’
[13:36:58.639] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.653] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.653] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.653]   - Field: ‘node’
[13:36:58.653]   - Field: ‘label’
[13:36:58.653]   - Field: ‘local’
[13:36:58.653]   - Field: ‘owner’
[13:36:58.653]   - Field: ‘envir’
[13:36:58.654]   - Field: ‘workers’
[13:36:58.654]   - Field: ‘packages’
[13:36:58.654]   - Field: ‘gc’
[13:36:58.654]   - Field: ‘conditions’
[13:36:58.654]   - Field: ‘persistent’
[13:36:58.654]   - Field: ‘expr’
[13:36:58.654]   - Field: ‘uuid’
[13:36:58.654]   - Field: ‘seed’
[13:36:58.654]   - Field: ‘version’
[13:36:58.656]   - Field: ‘result’
[13:36:58.657]   - Field: ‘asynchronous’
[13:36:58.657]   - Field: ‘calls’
[13:36:58.657]   - Field: ‘globals’
[13:36:58.657]   - Field: ‘stdout’
[13:36:58.657]   - Field: ‘earlySignal’
[13:36:58.657]   - Field: ‘lazy’
[13:36:58.657]   - Field: ‘state’
[13:36:58.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.657] - Launch lazy future ...
[13:36:58.658] Packages needed by the future expression (n = 1): ‘future’
[13:36:58.658] Packages needed by future strategies (n = 0): <none>
[13:36:58.658] {
[13:36:58.658]     {
[13:36:58.658]         {
[13:36:58.658]             ...future.startTime <- base::Sys.time()
[13:36:58.658]             {
[13:36:58.658]                 {
[13:36:58.658]                   {
[13:36:58.658]                     {
[13:36:58.658]                       {
[13:36:58.658]                         base::local({
[13:36:58.658]                           has_future <- base::requireNamespace("future", 
[13:36:58.658]                             quietly = TRUE)
[13:36:58.658]                           if (has_future) {
[13:36:58.658]                             ns <- base::getNamespace("future")
[13:36:58.658]                             version <- ns[[".package"]][["version"]]
[13:36:58.658]                             if (is.null(version)) 
[13:36:58.658]                               version <- utils::packageVersion("future")
[13:36:58.658]                           }
[13:36:58.658]                           else {
[13:36:58.658]                             version <- NULL
[13:36:58.658]                           }
[13:36:58.658]                           if (!has_future || version < "1.8.0") {
[13:36:58.658]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.658]                               "", base::R.version$version.string), 
[13:36:58.658]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:58.658]                                 base::R.version$platform, 8 * 
[13:36:58.658]                                   base::.Machine$sizeof.pointer), 
[13:36:58.658]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.658]                                 "release", "version")], collapse = " "), 
[13:36:58.658]                               hostname = base::Sys.info()[["nodename"]])
[13:36:58.658]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.658]                               info)
[13:36:58.658]                             info <- base::paste(info, collapse = "; ")
[13:36:58.658]                             if (!has_future) {
[13:36:58.658]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.658]                                 info)
[13:36:58.658]                             }
[13:36:58.658]                             else {
[13:36:58.658]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.658]                                 info, version)
[13:36:58.658]                             }
[13:36:58.658]                             base::stop(msg)
[13:36:58.658]                           }
[13:36:58.658]                         })
[13:36:58.658]                       }
[13:36:58.658]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.658]                       base::options(mc.cores = 1L)
[13:36:58.658]                     }
[13:36:58.658]                     base::local({
[13:36:58.658]                       for (pkg in "future") {
[13:36:58.658]                         base::loadNamespace(pkg)
[13:36:58.658]                         base::library(pkg, character.only = TRUE)
[13:36:58.658]                       }
[13:36:58.658]                     })
[13:36:58.658]                   }
[13:36:58.658]                   ...future.strategy.old <- future::plan("list")
[13:36:58.658]                   options(future.plan = NULL)
[13:36:58.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.658]                 }
[13:36:58.658]                 ...future.workdir <- getwd()
[13:36:58.658]             }
[13:36:58.658]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.658]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.658]         }
[13:36:58.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.658]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.658]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.658]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.658]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.658]             base::names(...future.oldOptions))
[13:36:58.658]     }
[13:36:58.658]     if (FALSE) {
[13:36:58.658]     }
[13:36:58.658]     else {
[13:36:58.658]         if (TRUE) {
[13:36:58.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.658]                 open = "w")
[13:36:58.658]         }
[13:36:58.658]         else {
[13:36:58.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.658]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.658]         }
[13:36:58.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.658]             base::sink(type = "output", split = FALSE)
[13:36:58.658]             base::close(...future.stdout)
[13:36:58.658]         }, add = TRUE)
[13:36:58.658]     }
[13:36:58.658]     ...future.frame <- base::sys.nframe()
[13:36:58.658]     ...future.conditions <- base::list()
[13:36:58.658]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.658]     if (FALSE) {
[13:36:58.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.658]     }
[13:36:58.658]     ...future.result <- base::tryCatch({
[13:36:58.658]         base::withCallingHandlers({
[13:36:58.658]             ...future.value <- base::withVisible(base::local({
[13:36:58.658]                 ...future.makeSendCondition <- base::local({
[13:36:58.658]                   sendCondition <- NULL
[13:36:58.658]                   function(frame = 1L) {
[13:36:58.658]                     if (is.function(sendCondition)) 
[13:36:58.658]                       return(sendCondition)
[13:36:58.658]                     ns <- getNamespace("parallel")
[13:36:58.658]                     if (exists("sendData", mode = "function", 
[13:36:58.658]                       envir = ns)) {
[13:36:58.658]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.658]                         envir = ns)
[13:36:58.658]                       envir <- sys.frame(frame)
[13:36:58.658]                       master <- NULL
[13:36:58.658]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.658]                         !identical(envir, emptyenv())) {
[13:36:58.658]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.658]                           inherits = FALSE)) {
[13:36:58.658]                           master <- get("master", mode = "list", 
[13:36:58.658]                             envir = envir, inherits = FALSE)
[13:36:58.658]                           if (inherits(master, c("SOCKnode", 
[13:36:58.658]                             "SOCK0node"))) {
[13:36:58.658]                             sendCondition <<- function(cond) {
[13:36:58.658]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.658]                                 success = TRUE)
[13:36:58.658]                               parallel_sendData(master, data)
[13:36:58.658]                             }
[13:36:58.658]                             return(sendCondition)
[13:36:58.658]                           }
[13:36:58.658]                         }
[13:36:58.658]                         frame <- frame + 1L
[13:36:58.658]                         envir <- sys.frame(frame)
[13:36:58.658]                       }
[13:36:58.658]                     }
[13:36:58.658]                     sendCondition <<- function(cond) NULL
[13:36:58.658]                   }
[13:36:58.658]                 })
[13:36:58.658]                 withCallingHandlers({
[13:36:58.658]                   value(a) + 1
[13:36:58.658]                 }, immediateCondition = function(cond) {
[13:36:58.658]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.658]                   sendCondition(cond)
[13:36:58.658]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.658]                   {
[13:36:58.658]                     inherits <- base::inherits
[13:36:58.658]                     invokeRestart <- base::invokeRestart
[13:36:58.658]                     is.null <- base::is.null
[13:36:58.658]                     muffled <- FALSE
[13:36:58.658]                     if (inherits(cond, "message")) {
[13:36:58.658]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.658]                       if (muffled) 
[13:36:58.658]                         invokeRestart("muffleMessage")
[13:36:58.658]                     }
[13:36:58.658]                     else if (inherits(cond, "warning")) {
[13:36:58.658]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.658]                       if (muffled) 
[13:36:58.658]                         invokeRestart("muffleWarning")
[13:36:58.658]                     }
[13:36:58.658]                     else if (inherits(cond, "condition")) {
[13:36:58.658]                       if (!is.null(pattern)) {
[13:36:58.658]                         computeRestarts <- base::computeRestarts
[13:36:58.658]                         grepl <- base::grepl
[13:36:58.658]                         restarts <- computeRestarts(cond)
[13:36:58.658]                         for (restart in restarts) {
[13:36:58.658]                           name <- restart$name
[13:36:58.658]                           if (is.null(name)) 
[13:36:58.658]                             next
[13:36:58.658]                           if (!grepl(pattern, name)) 
[13:36:58.658]                             next
[13:36:58.658]                           invokeRestart(restart)
[13:36:58.658]                           muffled <- TRUE
[13:36:58.658]                           break
[13:36:58.658]                         }
[13:36:58.658]                       }
[13:36:58.658]                     }
[13:36:58.658]                     invisible(muffled)
[13:36:58.658]                   }
[13:36:58.658]                   muffleCondition(cond)
[13:36:58.658]                 })
[13:36:58.658]             }))
[13:36:58.658]             future::FutureResult(value = ...future.value$value, 
[13:36:58.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.658]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.658]                     ...future.globalenv.names))
[13:36:58.658]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.658]         }, condition = base::local({
[13:36:58.658]             c <- base::c
[13:36:58.658]             inherits <- base::inherits
[13:36:58.658]             invokeRestart <- base::invokeRestart
[13:36:58.658]             length <- base::length
[13:36:58.658]             list <- base::list
[13:36:58.658]             seq.int <- base::seq.int
[13:36:58.658]             signalCondition <- base::signalCondition
[13:36:58.658]             sys.calls <- base::sys.calls
[13:36:58.658]             `[[` <- base::`[[`
[13:36:58.658]             `+` <- base::`+`
[13:36:58.658]             `<<-` <- base::`<<-`
[13:36:58.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.658]                   3L)]
[13:36:58.658]             }
[13:36:58.658]             function(cond) {
[13:36:58.658]                 is_error <- inherits(cond, "error")
[13:36:58.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.658]                   NULL)
[13:36:58.658]                 if (is_error) {
[13:36:58.658]                   sessionInformation <- function() {
[13:36:58.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.658]                       search = base::search(), system = base::Sys.info())
[13:36:58.658]                   }
[13:36:58.658]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.658]                     cond$call), session = sessionInformation(), 
[13:36:58.658]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.658]                   signalCondition(cond)
[13:36:58.658]                 }
[13:36:58.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.658]                 "immediateCondition"))) {
[13:36:58.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.658]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.658]                   if (TRUE && !signal) {
[13:36:58.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.658]                     {
[13:36:58.658]                       inherits <- base::inherits
[13:36:58.658]                       invokeRestart <- base::invokeRestart
[13:36:58.658]                       is.null <- base::is.null
[13:36:58.658]                       muffled <- FALSE
[13:36:58.658]                       if (inherits(cond, "message")) {
[13:36:58.658]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.658]                         if (muffled) 
[13:36:58.658]                           invokeRestart("muffleMessage")
[13:36:58.658]                       }
[13:36:58.658]                       else if (inherits(cond, "warning")) {
[13:36:58.658]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.658]                         if (muffled) 
[13:36:58.658]                           invokeRestart("muffleWarning")
[13:36:58.658]                       }
[13:36:58.658]                       else if (inherits(cond, "condition")) {
[13:36:58.658]                         if (!is.null(pattern)) {
[13:36:58.658]                           computeRestarts <- base::computeRestarts
[13:36:58.658]                           grepl <- base::grepl
[13:36:58.658]                           restarts <- computeRestarts(cond)
[13:36:58.658]                           for (restart in restarts) {
[13:36:58.658]                             name <- restart$name
[13:36:58.658]                             if (is.null(name)) 
[13:36:58.658]                               next
[13:36:58.658]                             if (!grepl(pattern, name)) 
[13:36:58.658]                               next
[13:36:58.658]                             invokeRestart(restart)
[13:36:58.658]                             muffled <- TRUE
[13:36:58.658]                             break
[13:36:58.658]                           }
[13:36:58.658]                         }
[13:36:58.658]                       }
[13:36:58.658]                       invisible(muffled)
[13:36:58.658]                     }
[13:36:58.658]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.658]                   }
[13:36:58.658]                 }
[13:36:58.658]                 else {
[13:36:58.658]                   if (TRUE) {
[13:36:58.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.658]                     {
[13:36:58.658]                       inherits <- base::inherits
[13:36:58.658]                       invokeRestart <- base::invokeRestart
[13:36:58.658]                       is.null <- base::is.null
[13:36:58.658]                       muffled <- FALSE
[13:36:58.658]                       if (inherits(cond, "message")) {
[13:36:58.658]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.658]                         if (muffled) 
[13:36:58.658]                           invokeRestart("muffleMessage")
[13:36:58.658]                       }
[13:36:58.658]                       else if (inherits(cond, "warning")) {
[13:36:58.658]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.658]                         if (muffled) 
[13:36:58.658]                           invokeRestart("muffleWarning")
[13:36:58.658]                       }
[13:36:58.658]                       else if (inherits(cond, "condition")) {
[13:36:58.658]                         if (!is.null(pattern)) {
[13:36:58.658]                           computeRestarts <- base::computeRestarts
[13:36:58.658]                           grepl <- base::grepl
[13:36:58.658]                           restarts <- computeRestarts(cond)
[13:36:58.658]                           for (restart in restarts) {
[13:36:58.658]                             name <- restart$name
[13:36:58.658]                             if (is.null(name)) 
[13:36:58.658]                               next
[13:36:58.658]                             if (!grepl(pattern, name)) 
[13:36:58.658]                               next
[13:36:58.658]                             invokeRestart(restart)
[13:36:58.658]                             muffled <- TRUE
[13:36:58.658]                             break
[13:36:58.658]                           }
[13:36:58.658]                         }
[13:36:58.658]                       }
[13:36:58.658]                       invisible(muffled)
[13:36:58.658]                     }
[13:36:58.658]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.658]                   }
[13:36:58.658]                 }
[13:36:58.658]             }
[13:36:58.658]         }))
[13:36:58.658]     }, error = function(ex) {
[13:36:58.658]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.658]                 ...future.rng), started = ...future.startTime, 
[13:36:58.658]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.658]             version = "1.8"), class = "FutureResult")
[13:36:58.658]     }, finally = {
[13:36:58.658]         if (!identical(...future.workdir, getwd())) 
[13:36:58.658]             setwd(...future.workdir)
[13:36:58.658]         {
[13:36:58.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.658]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.658]             }
[13:36:58.658]             base::options(...future.oldOptions)
[13:36:58.658]             if (.Platform$OS.type == "windows") {
[13:36:58.658]                 old_names <- names(...future.oldEnvVars)
[13:36:58.658]                 envs <- base::Sys.getenv()
[13:36:58.658]                 names <- names(envs)
[13:36:58.658]                 common <- intersect(names, old_names)
[13:36:58.658]                 added <- setdiff(names, old_names)
[13:36:58.658]                 removed <- setdiff(old_names, names)
[13:36:58.658]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.658]                   envs[common]]
[13:36:58.658]                 NAMES <- toupper(changed)
[13:36:58.658]                 args <- list()
[13:36:58.658]                 for (kk in seq_along(NAMES)) {
[13:36:58.658]                   name <- changed[[kk]]
[13:36:58.658]                   NAME <- NAMES[[kk]]
[13:36:58.658]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.658]                     next
[13:36:58.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.658]                 }
[13:36:58.658]                 NAMES <- toupper(added)
[13:36:58.658]                 for (kk in seq_along(NAMES)) {
[13:36:58.658]                   name <- added[[kk]]
[13:36:58.658]                   NAME <- NAMES[[kk]]
[13:36:58.658]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.658]                     next
[13:36:58.658]                   args[[name]] <- ""
[13:36:58.658]                 }
[13:36:58.658]                 NAMES <- toupper(removed)
[13:36:58.658]                 for (kk in seq_along(NAMES)) {
[13:36:58.658]                   name <- removed[[kk]]
[13:36:58.658]                   NAME <- NAMES[[kk]]
[13:36:58.658]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.658]                     next
[13:36:58.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.658]                 }
[13:36:58.658]                 if (length(args) > 0) 
[13:36:58.658]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.658]             }
[13:36:58.658]             else {
[13:36:58.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.658]             }
[13:36:58.658]             {
[13:36:58.658]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.658]                   0L) {
[13:36:58.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.658]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.658]                   base::options(opts)
[13:36:58.658]                 }
[13:36:58.658]                 {
[13:36:58.658]                   {
[13:36:58.658]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.658]                     NULL
[13:36:58.658]                   }
[13:36:58.658]                   options(future.plan = NULL)
[13:36:58.658]                   if (is.na(NA_character_)) 
[13:36:58.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.658]                     .init = FALSE)
[13:36:58.658]                 }
[13:36:58.658]             }
[13:36:58.658]         }
[13:36:58.658]     })
[13:36:58.658]     if (TRUE) {
[13:36:58.658]         base::sink(type = "output", split = FALSE)
[13:36:58.658]         if (TRUE) {
[13:36:58.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.658]         }
[13:36:58.658]         else {
[13:36:58.658]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.658]         }
[13:36:58.658]         base::close(...future.stdout)
[13:36:58.658]         ...future.stdout <- NULL
[13:36:58.658]     }
[13:36:58.658]     ...future.result$conditions <- ...future.conditions
[13:36:58.658]     ...future.result$finished <- base::Sys.time()
[13:36:58.658]     ...future.result
[13:36:58.658] }
[13:36:58.661] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[13:36:58.661] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[13:36:58.715] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[13:36:58.715] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[13:36:58.715] MultisessionFuture started
[13:36:58.716] - Launch lazy future ... done
[13:36:58.716] run() for ‘MultisessionFuture’ ... done
[13:36:58.716] result() for ClusterFuture ...
[13:36:58.716] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.716] - Validating connection of MultisessionFuture
[13:36:58.764] - received message: FutureResult
[13:36:58.764] - Received FutureResult
[13:36:58.764] - Erased future from FutureRegistry
[13:36:58.764] result() for ClusterFuture ...
[13:36:58.764] - result already collected: FutureResult
[13:36:58.764] result() for ClusterFuture ... done
[13:36:58.764] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.764] result() for ClusterFuture ... done
[13:36:58.765] result() for ClusterFuture ...
[13:36:58.765] - result already collected: FutureResult
[13:36:58.765] result() for ClusterFuture ... done
value(b) = 2
[13:36:58.765] result() for ClusterFuture ...
[13:36:58.765] - result already collected: FutureResult
[13:36:58.765] result() for ClusterFuture ... done
[13:36:58.765] result() for ClusterFuture ...
[13:36:58.765] - result already collected: FutureResult
[13:36:58.765] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.766] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.766] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.766] 
[13:36:58.766] Searching for globals ... DONE
[13:36:58.766] - globals: [0] <none>
[13:36:58.767] getGlobalsAndPackages() ... DONE
[13:36:58.767] run() for ‘Future’ ...
[13:36:58.767] - state: ‘created’
[13:36:58.767] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.780] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.780] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.781]   - Field: ‘node’
[13:36:58.781]   - Field: ‘label’
[13:36:58.781]   - Field: ‘local’
[13:36:58.781]   - Field: ‘owner’
[13:36:58.781]   - Field: ‘envir’
[13:36:58.781]   - Field: ‘workers’
[13:36:58.781]   - Field: ‘packages’
[13:36:58.781]   - Field: ‘gc’
[13:36:58.781]   - Field: ‘conditions’
[13:36:58.781]   - Field: ‘persistent’
[13:36:58.781]   - Field: ‘expr’
[13:36:58.782]   - Field: ‘uuid’
[13:36:58.782]   - Field: ‘seed’
[13:36:58.782]   - Field: ‘version’
[13:36:58.782]   - Field: ‘result’
[13:36:58.782]   - Field: ‘asynchronous’
[13:36:58.782]   - Field: ‘calls’
[13:36:58.782]   - Field: ‘globals’
[13:36:58.782]   - Field: ‘stdout’
[13:36:58.782]   - Field: ‘earlySignal’
[13:36:58.782]   - Field: ‘lazy’
[13:36:58.782]   - Field: ‘state’
[13:36:58.783] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.783] - Launch lazy future ...
[13:36:58.783] Packages needed by the future expression (n = 0): <none>
[13:36:58.783] Packages needed by future strategies (n = 0): <none>
[13:36:58.783] {
[13:36:58.783]     {
[13:36:58.783]         {
[13:36:58.783]             ...future.startTime <- base::Sys.time()
[13:36:58.783]             {
[13:36:58.783]                 {
[13:36:58.783]                   {
[13:36:58.783]                     {
[13:36:58.783]                       base::local({
[13:36:58.783]                         has_future <- base::requireNamespace("future", 
[13:36:58.783]                           quietly = TRUE)
[13:36:58.783]                         if (has_future) {
[13:36:58.783]                           ns <- base::getNamespace("future")
[13:36:58.783]                           version <- ns[[".package"]][["version"]]
[13:36:58.783]                           if (is.null(version)) 
[13:36:58.783]                             version <- utils::packageVersion("future")
[13:36:58.783]                         }
[13:36:58.783]                         else {
[13:36:58.783]                           version <- NULL
[13:36:58.783]                         }
[13:36:58.783]                         if (!has_future || version < "1.8.0") {
[13:36:58.783]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.783]                             "", base::R.version$version.string), 
[13:36:58.783]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.783]                               "release", "version")], collapse = " "), 
[13:36:58.783]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.783]                             info)
[13:36:58.783]                           info <- base::paste(info, collapse = "; ")
[13:36:58.783]                           if (!has_future) {
[13:36:58.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.783]                               info)
[13:36:58.783]                           }
[13:36:58.783]                           else {
[13:36:58.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.783]                               info, version)
[13:36:58.783]                           }
[13:36:58.783]                           base::stop(msg)
[13:36:58.783]                         }
[13:36:58.783]                       })
[13:36:58.783]                     }
[13:36:58.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.783]                     base::options(mc.cores = 1L)
[13:36:58.783]                   }
[13:36:58.783]                   ...future.strategy.old <- future::plan("list")
[13:36:58.783]                   options(future.plan = NULL)
[13:36:58.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.783]                 }
[13:36:58.783]                 ...future.workdir <- getwd()
[13:36:58.783]             }
[13:36:58.783]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.783]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.783]         }
[13:36:58.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.783]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.783]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.783]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.783]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.783]             base::names(...future.oldOptions))
[13:36:58.783]     }
[13:36:58.783]     if (FALSE) {
[13:36:58.783]     }
[13:36:58.783]     else {
[13:36:58.783]         if (TRUE) {
[13:36:58.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.783]                 open = "w")
[13:36:58.783]         }
[13:36:58.783]         else {
[13:36:58.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.783]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.783]         }
[13:36:58.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.783]             base::sink(type = "output", split = FALSE)
[13:36:58.783]             base::close(...future.stdout)
[13:36:58.783]         }, add = TRUE)
[13:36:58.783]     }
[13:36:58.783]     ...future.frame <- base::sys.nframe()
[13:36:58.783]     ...future.conditions <- base::list()
[13:36:58.783]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.783]     if (FALSE) {
[13:36:58.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.783]     }
[13:36:58.783]     ...future.result <- base::tryCatch({
[13:36:58.783]         base::withCallingHandlers({
[13:36:58.783]             ...future.value <- base::withVisible(base::local({
[13:36:58.783]                 ...future.makeSendCondition <- base::local({
[13:36:58.783]                   sendCondition <- NULL
[13:36:58.783]                   function(frame = 1L) {
[13:36:58.783]                     if (is.function(sendCondition)) 
[13:36:58.783]                       return(sendCondition)
[13:36:58.783]                     ns <- getNamespace("parallel")
[13:36:58.783]                     if (exists("sendData", mode = "function", 
[13:36:58.783]                       envir = ns)) {
[13:36:58.783]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.783]                         envir = ns)
[13:36:58.783]                       envir <- sys.frame(frame)
[13:36:58.783]                       master <- NULL
[13:36:58.783]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.783]                         !identical(envir, emptyenv())) {
[13:36:58.783]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.783]                           inherits = FALSE)) {
[13:36:58.783]                           master <- get("master", mode = "list", 
[13:36:58.783]                             envir = envir, inherits = FALSE)
[13:36:58.783]                           if (inherits(master, c("SOCKnode", 
[13:36:58.783]                             "SOCK0node"))) {
[13:36:58.783]                             sendCondition <<- function(cond) {
[13:36:58.783]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.783]                                 success = TRUE)
[13:36:58.783]                               parallel_sendData(master, data)
[13:36:58.783]                             }
[13:36:58.783]                             return(sendCondition)
[13:36:58.783]                           }
[13:36:58.783]                         }
[13:36:58.783]                         frame <- frame + 1L
[13:36:58.783]                         envir <- sys.frame(frame)
[13:36:58.783]                       }
[13:36:58.783]                     }
[13:36:58.783]                     sendCondition <<- function(cond) NULL
[13:36:58.783]                   }
[13:36:58.783]                 })
[13:36:58.783]                 withCallingHandlers({
[13:36:58.783]                   1
[13:36:58.783]                 }, immediateCondition = function(cond) {
[13:36:58.783]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.783]                   sendCondition(cond)
[13:36:58.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.783]                   {
[13:36:58.783]                     inherits <- base::inherits
[13:36:58.783]                     invokeRestart <- base::invokeRestart
[13:36:58.783]                     is.null <- base::is.null
[13:36:58.783]                     muffled <- FALSE
[13:36:58.783]                     if (inherits(cond, "message")) {
[13:36:58.783]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.783]                       if (muffled) 
[13:36:58.783]                         invokeRestart("muffleMessage")
[13:36:58.783]                     }
[13:36:58.783]                     else if (inherits(cond, "warning")) {
[13:36:58.783]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.783]                       if (muffled) 
[13:36:58.783]                         invokeRestart("muffleWarning")
[13:36:58.783]                     }
[13:36:58.783]                     else if (inherits(cond, "condition")) {
[13:36:58.783]                       if (!is.null(pattern)) {
[13:36:58.783]                         computeRestarts <- base::computeRestarts
[13:36:58.783]                         grepl <- base::grepl
[13:36:58.783]                         restarts <- computeRestarts(cond)
[13:36:58.783]                         for (restart in restarts) {
[13:36:58.783]                           name <- restart$name
[13:36:58.783]                           if (is.null(name)) 
[13:36:58.783]                             next
[13:36:58.783]                           if (!grepl(pattern, name)) 
[13:36:58.783]                             next
[13:36:58.783]                           invokeRestart(restart)
[13:36:58.783]                           muffled <- TRUE
[13:36:58.783]                           break
[13:36:58.783]                         }
[13:36:58.783]                       }
[13:36:58.783]                     }
[13:36:58.783]                     invisible(muffled)
[13:36:58.783]                   }
[13:36:58.783]                   muffleCondition(cond)
[13:36:58.783]                 })
[13:36:58.783]             }))
[13:36:58.783]             future::FutureResult(value = ...future.value$value, 
[13:36:58.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.783]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.783]                     ...future.globalenv.names))
[13:36:58.783]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.783]         }, condition = base::local({
[13:36:58.783]             c <- base::c
[13:36:58.783]             inherits <- base::inherits
[13:36:58.783]             invokeRestart <- base::invokeRestart
[13:36:58.783]             length <- base::length
[13:36:58.783]             list <- base::list
[13:36:58.783]             seq.int <- base::seq.int
[13:36:58.783]             signalCondition <- base::signalCondition
[13:36:58.783]             sys.calls <- base::sys.calls
[13:36:58.783]             `[[` <- base::`[[`
[13:36:58.783]             `+` <- base::`+`
[13:36:58.783]             `<<-` <- base::`<<-`
[13:36:58.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.783]                   3L)]
[13:36:58.783]             }
[13:36:58.783]             function(cond) {
[13:36:58.783]                 is_error <- inherits(cond, "error")
[13:36:58.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.783]                   NULL)
[13:36:58.783]                 if (is_error) {
[13:36:58.783]                   sessionInformation <- function() {
[13:36:58.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.783]                       search = base::search(), system = base::Sys.info())
[13:36:58.783]                   }
[13:36:58.783]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.783]                     cond$call), session = sessionInformation(), 
[13:36:58.783]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.783]                   signalCondition(cond)
[13:36:58.783]                 }
[13:36:58.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.783]                 "immediateCondition"))) {
[13:36:58.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.783]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.783]                   if (TRUE && !signal) {
[13:36:58.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.783]                     {
[13:36:58.783]                       inherits <- base::inherits
[13:36:58.783]                       invokeRestart <- base::invokeRestart
[13:36:58.783]                       is.null <- base::is.null
[13:36:58.783]                       muffled <- FALSE
[13:36:58.783]                       if (inherits(cond, "message")) {
[13:36:58.783]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.783]                         if (muffled) 
[13:36:58.783]                           invokeRestart("muffleMessage")
[13:36:58.783]                       }
[13:36:58.783]                       else if (inherits(cond, "warning")) {
[13:36:58.783]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.783]                         if (muffled) 
[13:36:58.783]                           invokeRestart("muffleWarning")
[13:36:58.783]                       }
[13:36:58.783]                       else if (inherits(cond, "condition")) {
[13:36:58.783]                         if (!is.null(pattern)) {
[13:36:58.783]                           computeRestarts <- base::computeRestarts
[13:36:58.783]                           grepl <- base::grepl
[13:36:58.783]                           restarts <- computeRestarts(cond)
[13:36:58.783]                           for (restart in restarts) {
[13:36:58.783]                             name <- restart$name
[13:36:58.783]                             if (is.null(name)) 
[13:36:58.783]                               next
[13:36:58.783]                             if (!grepl(pattern, name)) 
[13:36:58.783]                               next
[13:36:58.783]                             invokeRestart(restart)
[13:36:58.783]                             muffled <- TRUE
[13:36:58.783]                             break
[13:36:58.783]                           }
[13:36:58.783]                         }
[13:36:58.783]                       }
[13:36:58.783]                       invisible(muffled)
[13:36:58.783]                     }
[13:36:58.783]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.783]                   }
[13:36:58.783]                 }
[13:36:58.783]                 else {
[13:36:58.783]                   if (TRUE) {
[13:36:58.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.783]                     {
[13:36:58.783]                       inherits <- base::inherits
[13:36:58.783]                       invokeRestart <- base::invokeRestart
[13:36:58.783]                       is.null <- base::is.null
[13:36:58.783]                       muffled <- FALSE
[13:36:58.783]                       if (inherits(cond, "message")) {
[13:36:58.783]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.783]                         if (muffled) 
[13:36:58.783]                           invokeRestart("muffleMessage")
[13:36:58.783]                       }
[13:36:58.783]                       else if (inherits(cond, "warning")) {
[13:36:58.783]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.783]                         if (muffled) 
[13:36:58.783]                           invokeRestart("muffleWarning")
[13:36:58.783]                       }
[13:36:58.783]                       else if (inherits(cond, "condition")) {
[13:36:58.783]                         if (!is.null(pattern)) {
[13:36:58.783]                           computeRestarts <- base::computeRestarts
[13:36:58.783]                           grepl <- base::grepl
[13:36:58.783]                           restarts <- computeRestarts(cond)
[13:36:58.783]                           for (restart in restarts) {
[13:36:58.783]                             name <- restart$name
[13:36:58.783]                             if (is.null(name)) 
[13:36:58.783]                               next
[13:36:58.783]                             if (!grepl(pattern, name)) 
[13:36:58.783]                               next
[13:36:58.783]                             invokeRestart(restart)
[13:36:58.783]                             muffled <- TRUE
[13:36:58.783]                             break
[13:36:58.783]                           }
[13:36:58.783]                         }
[13:36:58.783]                       }
[13:36:58.783]                       invisible(muffled)
[13:36:58.783]                     }
[13:36:58.783]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.783]                   }
[13:36:58.783]                 }
[13:36:58.783]             }
[13:36:58.783]         }))
[13:36:58.783]     }, error = function(ex) {
[13:36:58.783]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.783]                 ...future.rng), started = ...future.startTime, 
[13:36:58.783]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.783]             version = "1.8"), class = "FutureResult")
[13:36:58.783]     }, finally = {
[13:36:58.783]         if (!identical(...future.workdir, getwd())) 
[13:36:58.783]             setwd(...future.workdir)
[13:36:58.783]         {
[13:36:58.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.783]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.783]             }
[13:36:58.783]             base::options(...future.oldOptions)
[13:36:58.783]             if (.Platform$OS.type == "windows") {
[13:36:58.783]                 old_names <- names(...future.oldEnvVars)
[13:36:58.783]                 envs <- base::Sys.getenv()
[13:36:58.783]                 names <- names(envs)
[13:36:58.783]                 common <- intersect(names, old_names)
[13:36:58.783]                 added <- setdiff(names, old_names)
[13:36:58.783]                 removed <- setdiff(old_names, names)
[13:36:58.783]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.783]                   envs[common]]
[13:36:58.783]                 NAMES <- toupper(changed)
[13:36:58.783]                 args <- list()
[13:36:58.783]                 for (kk in seq_along(NAMES)) {
[13:36:58.783]                   name <- changed[[kk]]
[13:36:58.783]                   NAME <- NAMES[[kk]]
[13:36:58.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.783]                     next
[13:36:58.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.783]                 }
[13:36:58.783]                 NAMES <- toupper(added)
[13:36:58.783]                 for (kk in seq_along(NAMES)) {
[13:36:58.783]                   name <- added[[kk]]
[13:36:58.783]                   NAME <- NAMES[[kk]]
[13:36:58.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.783]                     next
[13:36:58.783]                   args[[name]] <- ""
[13:36:58.783]                 }
[13:36:58.783]                 NAMES <- toupper(removed)
[13:36:58.783]                 for (kk in seq_along(NAMES)) {
[13:36:58.783]                   name <- removed[[kk]]
[13:36:58.783]                   NAME <- NAMES[[kk]]
[13:36:58.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.783]                     next
[13:36:58.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.783]                 }
[13:36:58.783]                 if (length(args) > 0) 
[13:36:58.783]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.783]             }
[13:36:58.783]             else {
[13:36:58.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.783]             }
[13:36:58.783]             {
[13:36:58.783]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.783]                   0L) {
[13:36:58.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.783]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.783]                   base::options(opts)
[13:36:58.783]                 }
[13:36:58.783]                 {
[13:36:58.783]                   {
[13:36:58.783]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.783]                     NULL
[13:36:58.783]                   }
[13:36:58.783]                   options(future.plan = NULL)
[13:36:58.783]                   if (is.na(NA_character_)) 
[13:36:58.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.783]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.783]                     .init = FALSE)
[13:36:58.783]                 }
[13:36:58.783]             }
[13:36:58.783]         }
[13:36:58.783]     })
[13:36:58.783]     if (TRUE) {
[13:36:58.783]         base::sink(type = "output", split = FALSE)
[13:36:58.783]         if (TRUE) {
[13:36:58.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.783]         }
[13:36:58.783]         else {
[13:36:58.783]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.783]         }
[13:36:58.783]         base::close(...future.stdout)
[13:36:58.783]         ...future.stdout <- NULL
[13:36:58.783]     }
[13:36:58.783]     ...future.result$conditions <- ...future.conditions
[13:36:58.783]     ...future.result$finished <- base::Sys.time()
[13:36:58.783]     ...future.result
[13:36:58.783] }
[13:36:58.786] MultisessionFuture started
[13:36:58.786] - Launch lazy future ... done
[13:36:58.787] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.787] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.787] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.788] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:58.788] Searching for globals ... DONE
[13:36:58.788] Resolving globals: TRUE
[13:36:58.788] Resolving any globals that are futures ...
[13:36:58.788] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:58.788] Resolving any globals that are futures ... DONE
[13:36:58.789] Resolving futures part of globals (recursively) ...
[13:36:58.789] resolve() on list ...
[13:36:58.789]  recursive: 99
[13:36:58.789]  length: 1
[13:36:58.789]  elements: ‘a’
[13:36:58.831] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.831] - Validating connection of MultisessionFuture
[13:36:58.831] - received message: FutureResult
[13:36:58.832] - Received FutureResult
[13:36:58.832] - Erased future from FutureRegistry
[13:36:58.832] result() for ClusterFuture ...
[13:36:58.832] - result already collected: FutureResult
[13:36:58.832] result() for ClusterFuture ... done
[13:36:58.832] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.832] Future #1
[13:36:58.832] result() for ClusterFuture ...
[13:36:58.832] - result already collected: FutureResult
[13:36:58.832] result() for ClusterFuture ... done
[13:36:58.832] result() for ClusterFuture ...
[13:36:58.833] - result already collected: FutureResult
[13:36:58.833] result() for ClusterFuture ... done
[13:36:58.833] A MultisessionFuture was resolved
[13:36:58.833]  length: 0 (resolved future 1)
[13:36:58.833] resolve() on list ... DONE
[13:36:58.833] - globals: [1] ‘a’
[13:36:58.833] Resolving futures part of globals (recursively) ... DONE
[13:36:58.834] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[13:36:58.834] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[13:36:58.835] - globals: [1] ‘a’
[13:36:58.835] - packages: [1] ‘future’
[13:36:58.835] getGlobalsAndPackages() ... DONE
[13:36:58.835] run() for ‘Future’ ...
[13:36:58.835] - state: ‘created’
[13:36:58.835] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.849] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.849]   - Field: ‘node’
[13:36:58.849]   - Field: ‘label’
[13:36:58.849]   - Field: ‘local’
[13:36:58.849]   - Field: ‘owner’
[13:36:58.849]   - Field: ‘envir’
[13:36:58.850]   - Field: ‘workers’
[13:36:58.850]   - Field: ‘packages’
[13:36:58.850]   - Field: ‘gc’
[13:36:58.850]   - Field: ‘conditions’
[13:36:58.850]   - Field: ‘persistent’
[13:36:58.850]   - Field: ‘expr’
[13:36:58.850]   - Field: ‘uuid’
[13:36:58.850]   - Field: ‘seed’
[13:36:58.850]   - Field: ‘version’
[13:36:58.850]   - Field: ‘result’
[13:36:58.851]   - Field: ‘asynchronous’
[13:36:58.851]   - Field: ‘calls’
[13:36:58.851]   - Field: ‘globals’
[13:36:58.851]   - Field: ‘stdout’
[13:36:58.851]   - Field: ‘earlySignal’
[13:36:58.851]   - Field: ‘lazy’
[13:36:58.851]   - Field: ‘state’
[13:36:58.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.851] - Launch lazy future ...
[13:36:58.851] Packages needed by the future expression (n = 1): ‘future’
[13:36:58.852] Packages needed by future strategies (n = 0): <none>
[13:36:58.852] {
[13:36:58.852]     {
[13:36:58.852]         {
[13:36:58.852]             ...future.startTime <- base::Sys.time()
[13:36:58.852]             {
[13:36:58.852]                 {
[13:36:58.852]                   {
[13:36:58.852]                     {
[13:36:58.852]                       {
[13:36:58.852]                         base::local({
[13:36:58.852]                           has_future <- base::requireNamespace("future", 
[13:36:58.852]                             quietly = TRUE)
[13:36:58.852]                           if (has_future) {
[13:36:58.852]                             ns <- base::getNamespace("future")
[13:36:58.852]                             version <- ns[[".package"]][["version"]]
[13:36:58.852]                             if (is.null(version)) 
[13:36:58.852]                               version <- utils::packageVersion("future")
[13:36:58.852]                           }
[13:36:58.852]                           else {
[13:36:58.852]                             version <- NULL
[13:36:58.852]                           }
[13:36:58.852]                           if (!has_future || version < "1.8.0") {
[13:36:58.852]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.852]                               "", base::R.version$version.string), 
[13:36:58.852]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:58.852]                                 base::R.version$platform, 8 * 
[13:36:58.852]                                   base::.Machine$sizeof.pointer), 
[13:36:58.852]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.852]                                 "release", "version")], collapse = " "), 
[13:36:58.852]                               hostname = base::Sys.info()[["nodename"]])
[13:36:58.852]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.852]                               info)
[13:36:58.852]                             info <- base::paste(info, collapse = "; ")
[13:36:58.852]                             if (!has_future) {
[13:36:58.852]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.852]                                 info)
[13:36:58.852]                             }
[13:36:58.852]                             else {
[13:36:58.852]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.852]                                 info, version)
[13:36:58.852]                             }
[13:36:58.852]                             base::stop(msg)
[13:36:58.852]                           }
[13:36:58.852]                         })
[13:36:58.852]                       }
[13:36:58.852]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.852]                       base::options(mc.cores = 1L)
[13:36:58.852]                     }
[13:36:58.852]                     base::local({
[13:36:58.852]                       for (pkg in "future") {
[13:36:58.852]                         base::loadNamespace(pkg)
[13:36:58.852]                         base::library(pkg, character.only = TRUE)
[13:36:58.852]                       }
[13:36:58.852]                     })
[13:36:58.852]                   }
[13:36:58.852]                   ...future.strategy.old <- future::plan("list")
[13:36:58.852]                   options(future.plan = NULL)
[13:36:58.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.852]                 }
[13:36:58.852]                 ...future.workdir <- getwd()
[13:36:58.852]             }
[13:36:58.852]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.852]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.852]         }
[13:36:58.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.852]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.852]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.852]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.852]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.852]             base::names(...future.oldOptions))
[13:36:58.852]     }
[13:36:58.852]     if (FALSE) {
[13:36:58.852]     }
[13:36:58.852]     else {
[13:36:58.852]         if (TRUE) {
[13:36:58.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.852]                 open = "w")
[13:36:58.852]         }
[13:36:58.852]         else {
[13:36:58.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.852]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.852]         }
[13:36:58.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.852]             base::sink(type = "output", split = FALSE)
[13:36:58.852]             base::close(...future.stdout)
[13:36:58.852]         }, add = TRUE)
[13:36:58.852]     }
[13:36:58.852]     ...future.frame <- base::sys.nframe()
[13:36:58.852]     ...future.conditions <- base::list()
[13:36:58.852]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.852]     if (FALSE) {
[13:36:58.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.852]     }
[13:36:58.852]     ...future.result <- base::tryCatch({
[13:36:58.852]         base::withCallingHandlers({
[13:36:58.852]             ...future.value <- base::withVisible(base::local({
[13:36:58.852]                 ...future.makeSendCondition <- base::local({
[13:36:58.852]                   sendCondition <- NULL
[13:36:58.852]                   function(frame = 1L) {
[13:36:58.852]                     if (is.function(sendCondition)) 
[13:36:58.852]                       return(sendCondition)
[13:36:58.852]                     ns <- getNamespace("parallel")
[13:36:58.852]                     if (exists("sendData", mode = "function", 
[13:36:58.852]                       envir = ns)) {
[13:36:58.852]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.852]                         envir = ns)
[13:36:58.852]                       envir <- sys.frame(frame)
[13:36:58.852]                       master <- NULL
[13:36:58.852]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.852]                         !identical(envir, emptyenv())) {
[13:36:58.852]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.852]                           inherits = FALSE)) {
[13:36:58.852]                           master <- get("master", mode = "list", 
[13:36:58.852]                             envir = envir, inherits = FALSE)
[13:36:58.852]                           if (inherits(master, c("SOCKnode", 
[13:36:58.852]                             "SOCK0node"))) {
[13:36:58.852]                             sendCondition <<- function(cond) {
[13:36:58.852]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.852]                                 success = TRUE)
[13:36:58.852]                               parallel_sendData(master, data)
[13:36:58.852]                             }
[13:36:58.852]                             return(sendCondition)
[13:36:58.852]                           }
[13:36:58.852]                         }
[13:36:58.852]                         frame <- frame + 1L
[13:36:58.852]                         envir <- sys.frame(frame)
[13:36:58.852]                       }
[13:36:58.852]                     }
[13:36:58.852]                     sendCondition <<- function(cond) NULL
[13:36:58.852]                   }
[13:36:58.852]                 })
[13:36:58.852]                 withCallingHandlers({
[13:36:58.852]                   value(a) + 1
[13:36:58.852]                 }, immediateCondition = function(cond) {
[13:36:58.852]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.852]                   sendCondition(cond)
[13:36:58.852]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.852]                   {
[13:36:58.852]                     inherits <- base::inherits
[13:36:58.852]                     invokeRestart <- base::invokeRestart
[13:36:58.852]                     is.null <- base::is.null
[13:36:58.852]                     muffled <- FALSE
[13:36:58.852]                     if (inherits(cond, "message")) {
[13:36:58.852]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.852]                       if (muffled) 
[13:36:58.852]                         invokeRestart("muffleMessage")
[13:36:58.852]                     }
[13:36:58.852]                     else if (inherits(cond, "warning")) {
[13:36:58.852]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.852]                       if (muffled) 
[13:36:58.852]                         invokeRestart("muffleWarning")
[13:36:58.852]                     }
[13:36:58.852]                     else if (inherits(cond, "condition")) {
[13:36:58.852]                       if (!is.null(pattern)) {
[13:36:58.852]                         computeRestarts <- base::computeRestarts
[13:36:58.852]                         grepl <- base::grepl
[13:36:58.852]                         restarts <- computeRestarts(cond)
[13:36:58.852]                         for (restart in restarts) {
[13:36:58.852]                           name <- restart$name
[13:36:58.852]                           if (is.null(name)) 
[13:36:58.852]                             next
[13:36:58.852]                           if (!grepl(pattern, name)) 
[13:36:58.852]                             next
[13:36:58.852]                           invokeRestart(restart)
[13:36:58.852]                           muffled <- TRUE
[13:36:58.852]                           break
[13:36:58.852]                         }
[13:36:58.852]                       }
[13:36:58.852]                     }
[13:36:58.852]                     invisible(muffled)
[13:36:58.852]                   }
[13:36:58.852]                   muffleCondition(cond)
[13:36:58.852]                 })
[13:36:58.852]             }))
[13:36:58.852]             future::FutureResult(value = ...future.value$value, 
[13:36:58.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.852]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.852]                     ...future.globalenv.names))
[13:36:58.852]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.852]         }, condition = base::local({
[13:36:58.852]             c <- base::c
[13:36:58.852]             inherits <- base::inherits
[13:36:58.852]             invokeRestart <- base::invokeRestart
[13:36:58.852]             length <- base::length
[13:36:58.852]             list <- base::list
[13:36:58.852]             seq.int <- base::seq.int
[13:36:58.852]             signalCondition <- base::signalCondition
[13:36:58.852]             sys.calls <- base::sys.calls
[13:36:58.852]             `[[` <- base::`[[`
[13:36:58.852]             `+` <- base::`+`
[13:36:58.852]             `<<-` <- base::`<<-`
[13:36:58.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.852]                   3L)]
[13:36:58.852]             }
[13:36:58.852]             function(cond) {
[13:36:58.852]                 is_error <- inherits(cond, "error")
[13:36:58.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.852]                   NULL)
[13:36:58.852]                 if (is_error) {
[13:36:58.852]                   sessionInformation <- function() {
[13:36:58.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.852]                       search = base::search(), system = base::Sys.info())
[13:36:58.852]                   }
[13:36:58.852]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.852]                     cond$call), session = sessionInformation(), 
[13:36:58.852]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.852]                   signalCondition(cond)
[13:36:58.852]                 }
[13:36:58.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.852]                 "immediateCondition"))) {
[13:36:58.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.852]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.852]                   if (TRUE && !signal) {
[13:36:58.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.852]                     {
[13:36:58.852]                       inherits <- base::inherits
[13:36:58.852]                       invokeRestart <- base::invokeRestart
[13:36:58.852]                       is.null <- base::is.null
[13:36:58.852]                       muffled <- FALSE
[13:36:58.852]                       if (inherits(cond, "message")) {
[13:36:58.852]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.852]                         if (muffled) 
[13:36:58.852]                           invokeRestart("muffleMessage")
[13:36:58.852]                       }
[13:36:58.852]                       else if (inherits(cond, "warning")) {
[13:36:58.852]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.852]                         if (muffled) 
[13:36:58.852]                           invokeRestart("muffleWarning")
[13:36:58.852]                       }
[13:36:58.852]                       else if (inherits(cond, "condition")) {
[13:36:58.852]                         if (!is.null(pattern)) {
[13:36:58.852]                           computeRestarts <- base::computeRestarts
[13:36:58.852]                           grepl <- base::grepl
[13:36:58.852]                           restarts <- computeRestarts(cond)
[13:36:58.852]                           for (restart in restarts) {
[13:36:58.852]                             name <- restart$name
[13:36:58.852]                             if (is.null(name)) 
[13:36:58.852]                               next
[13:36:58.852]                             if (!grepl(pattern, name)) 
[13:36:58.852]                               next
[13:36:58.852]                             invokeRestart(restart)
[13:36:58.852]                             muffled <- TRUE
[13:36:58.852]                             break
[13:36:58.852]                           }
[13:36:58.852]                         }
[13:36:58.852]                       }
[13:36:58.852]                       invisible(muffled)
[13:36:58.852]                     }
[13:36:58.852]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.852]                   }
[13:36:58.852]                 }
[13:36:58.852]                 else {
[13:36:58.852]                   if (TRUE) {
[13:36:58.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.852]                     {
[13:36:58.852]                       inherits <- base::inherits
[13:36:58.852]                       invokeRestart <- base::invokeRestart
[13:36:58.852]                       is.null <- base::is.null
[13:36:58.852]                       muffled <- FALSE
[13:36:58.852]                       if (inherits(cond, "message")) {
[13:36:58.852]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.852]                         if (muffled) 
[13:36:58.852]                           invokeRestart("muffleMessage")
[13:36:58.852]                       }
[13:36:58.852]                       else if (inherits(cond, "warning")) {
[13:36:58.852]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.852]                         if (muffled) 
[13:36:58.852]                           invokeRestart("muffleWarning")
[13:36:58.852]                       }
[13:36:58.852]                       else if (inherits(cond, "condition")) {
[13:36:58.852]                         if (!is.null(pattern)) {
[13:36:58.852]                           computeRestarts <- base::computeRestarts
[13:36:58.852]                           grepl <- base::grepl
[13:36:58.852]                           restarts <- computeRestarts(cond)
[13:36:58.852]                           for (restart in restarts) {
[13:36:58.852]                             name <- restart$name
[13:36:58.852]                             if (is.null(name)) 
[13:36:58.852]                               next
[13:36:58.852]                             if (!grepl(pattern, name)) 
[13:36:58.852]                               next
[13:36:58.852]                             invokeRestart(restart)
[13:36:58.852]                             muffled <- TRUE
[13:36:58.852]                             break
[13:36:58.852]                           }
[13:36:58.852]                         }
[13:36:58.852]                       }
[13:36:58.852]                       invisible(muffled)
[13:36:58.852]                     }
[13:36:58.852]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.852]                   }
[13:36:58.852]                 }
[13:36:58.852]             }
[13:36:58.852]         }))
[13:36:58.852]     }, error = function(ex) {
[13:36:58.852]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.852]                 ...future.rng), started = ...future.startTime, 
[13:36:58.852]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.852]             version = "1.8"), class = "FutureResult")
[13:36:58.852]     }, finally = {
[13:36:58.852]         if (!identical(...future.workdir, getwd())) 
[13:36:58.852]             setwd(...future.workdir)
[13:36:58.852]         {
[13:36:58.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.852]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.852]             }
[13:36:58.852]             base::options(...future.oldOptions)
[13:36:58.852]             if (.Platform$OS.type == "windows") {
[13:36:58.852]                 old_names <- names(...future.oldEnvVars)
[13:36:58.852]                 envs <- base::Sys.getenv()
[13:36:58.852]                 names <- names(envs)
[13:36:58.852]                 common <- intersect(names, old_names)
[13:36:58.852]                 added <- setdiff(names, old_names)
[13:36:58.852]                 removed <- setdiff(old_names, names)
[13:36:58.852]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.852]                   envs[common]]
[13:36:58.852]                 NAMES <- toupper(changed)
[13:36:58.852]                 args <- list()
[13:36:58.852]                 for (kk in seq_along(NAMES)) {
[13:36:58.852]                   name <- changed[[kk]]
[13:36:58.852]                   NAME <- NAMES[[kk]]
[13:36:58.852]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.852]                     next
[13:36:58.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.852]                 }
[13:36:58.852]                 NAMES <- toupper(added)
[13:36:58.852]                 for (kk in seq_along(NAMES)) {
[13:36:58.852]                   name <- added[[kk]]
[13:36:58.852]                   NAME <- NAMES[[kk]]
[13:36:58.852]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.852]                     next
[13:36:58.852]                   args[[name]] <- ""
[13:36:58.852]                 }
[13:36:58.852]                 NAMES <- toupper(removed)
[13:36:58.852]                 for (kk in seq_along(NAMES)) {
[13:36:58.852]                   name <- removed[[kk]]
[13:36:58.852]                   NAME <- NAMES[[kk]]
[13:36:58.852]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.852]                     next
[13:36:58.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.852]                 }
[13:36:58.852]                 if (length(args) > 0) 
[13:36:58.852]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.852]             }
[13:36:58.852]             else {
[13:36:58.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.852]             }
[13:36:58.852]             {
[13:36:58.852]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.852]                   0L) {
[13:36:58.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.852]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.852]                   base::options(opts)
[13:36:58.852]                 }
[13:36:58.852]                 {
[13:36:58.852]                   {
[13:36:58.852]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.852]                     NULL
[13:36:58.852]                   }
[13:36:58.852]                   options(future.plan = NULL)
[13:36:58.852]                   if (is.na(NA_character_)) 
[13:36:58.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.852]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.852]                     .init = FALSE)
[13:36:58.852]                 }
[13:36:58.852]             }
[13:36:58.852]         }
[13:36:58.852]     })
[13:36:58.852]     if (TRUE) {
[13:36:58.852]         base::sink(type = "output", split = FALSE)
[13:36:58.852]         if (TRUE) {
[13:36:58.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.852]         }
[13:36:58.852]         else {
[13:36:58.852]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.852]         }
[13:36:58.852]         base::close(...future.stdout)
[13:36:58.852]         ...future.stdout <- NULL
[13:36:58.852]     }
[13:36:58.852]     ...future.result$conditions <- ...future.conditions
[13:36:58.852]     ...future.result$finished <- base::Sys.time()
[13:36:58.852]     ...future.result
[13:36:58.852] }
[13:36:58.855] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[13:36:58.855] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[13:36:58.906] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[13:36:58.907] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[13:36:58.907] MultisessionFuture started
[13:36:58.907] - Launch lazy future ... done
[13:36:58.907] run() for ‘MultisessionFuture’ ... done
[13:36:58.907] result() for ClusterFuture ...
[13:36:58.907] receiveMessageFromWorker() for ClusterFuture ...
[13:36:58.908] - Validating connection of MultisessionFuture
[13:36:58.952] - received message: FutureResult
[13:36:58.952] - Received FutureResult
[13:36:58.952] - Erased future from FutureRegistry
[13:36:58.952] result() for ClusterFuture ...
[13:36:58.953] - result already collected: FutureResult
[13:36:58.953] result() for ClusterFuture ... done
[13:36:58.953] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:58.953] result() for ClusterFuture ... done
[13:36:58.953] result() for ClusterFuture ...
[13:36:58.953] - result already collected: FutureResult
[13:36:58.953] result() for ClusterFuture ... done
value(b) = 2
[13:36:58.953] result() for ClusterFuture ...
[13:36:58.953] - result already collected: FutureResult
[13:36:58.954] result() for ClusterFuture ... done
[13:36:58.954] result() for ClusterFuture ...
[13:36:58.954] - result already collected: FutureResult
[13:36:58.954] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.954] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.954] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.955] 
[13:36:58.955] Searching for globals ... DONE
[13:36:58.955] - globals: [0] <none>
[13:36:58.955] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:58.955] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:58.956] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:58.956] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:58.957] Searching for globals ... DONE
[13:36:58.957] Resolving globals: TRUE
[13:36:58.957] Resolving any globals that are futures ...
[13:36:58.957] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:58.957] Resolving any globals that are futures ... DONE
[13:36:58.957] Resolving futures part of globals (recursively) ...
[13:36:58.957] resolve() on list ...
[13:36:58.958]  recursive: 99
[13:36:58.958]  length: 1
[13:36:58.958]  elements: ‘a’
[13:36:58.958] run() for ‘Future’ ...
[13:36:58.958] - state: ‘created’
[13:36:58.958] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:58.972] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:58.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:58.972]   - Field: ‘node’
[13:36:58.972]   - Field: ‘label’
[13:36:58.972]   - Field: ‘local’
[13:36:58.972]   - Field: ‘owner’
[13:36:58.973]   - Field: ‘envir’
[13:36:58.973]   - Field: ‘workers’
[13:36:58.973]   - Field: ‘packages’
[13:36:58.973]   - Field: ‘gc’
[13:36:58.973]   - Field: ‘conditions’
[13:36:58.973]   - Field: ‘persistent’
[13:36:58.973]   - Field: ‘expr’
[13:36:58.973]   - Field: ‘uuid’
[13:36:58.973]   - Field: ‘seed’
[13:36:58.973]   - Field: ‘version’
[13:36:58.973]   - Field: ‘result’
[13:36:58.974]   - Field: ‘asynchronous’
[13:36:58.974]   - Field: ‘calls’
[13:36:58.974]   - Field: ‘globals’
[13:36:58.974]   - Field: ‘stdout’
[13:36:58.974]   - Field: ‘earlySignal’
[13:36:58.974]   - Field: ‘lazy’
[13:36:58.974]   - Field: ‘state’
[13:36:58.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:58.974] - Launch lazy future ...
[13:36:58.975] Packages needed by the future expression (n = 0): <none>
[13:36:58.975] Packages needed by future strategies (n = 0): <none>
[13:36:58.975] {
[13:36:58.975]     {
[13:36:58.975]         {
[13:36:58.975]             ...future.startTime <- base::Sys.time()
[13:36:58.975]             {
[13:36:58.975]                 {
[13:36:58.975]                   {
[13:36:58.975]                     {
[13:36:58.975]                       base::local({
[13:36:58.975]                         has_future <- base::requireNamespace("future", 
[13:36:58.975]                           quietly = TRUE)
[13:36:58.975]                         if (has_future) {
[13:36:58.975]                           ns <- base::getNamespace("future")
[13:36:58.975]                           version <- ns[[".package"]][["version"]]
[13:36:58.975]                           if (is.null(version)) 
[13:36:58.975]                             version <- utils::packageVersion("future")
[13:36:58.975]                         }
[13:36:58.975]                         else {
[13:36:58.975]                           version <- NULL
[13:36:58.975]                         }
[13:36:58.975]                         if (!has_future || version < "1.8.0") {
[13:36:58.975]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:58.975]                             "", base::R.version$version.string), 
[13:36:58.975]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:58.975]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:58.975]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:58.975]                               "release", "version")], collapse = " "), 
[13:36:58.975]                             hostname = base::Sys.info()[["nodename"]])
[13:36:58.975]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:58.975]                             info)
[13:36:58.975]                           info <- base::paste(info, collapse = "; ")
[13:36:58.975]                           if (!has_future) {
[13:36:58.975]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:58.975]                               info)
[13:36:58.975]                           }
[13:36:58.975]                           else {
[13:36:58.975]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:58.975]                               info, version)
[13:36:58.975]                           }
[13:36:58.975]                           base::stop(msg)
[13:36:58.975]                         }
[13:36:58.975]                       })
[13:36:58.975]                     }
[13:36:58.975]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:58.975]                     base::options(mc.cores = 1L)
[13:36:58.975]                   }
[13:36:58.975]                   ...future.strategy.old <- future::plan("list")
[13:36:58.975]                   options(future.plan = NULL)
[13:36:58.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:58.975]                 }
[13:36:58.975]                 ...future.workdir <- getwd()
[13:36:58.975]             }
[13:36:58.975]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:58.975]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:58.975]         }
[13:36:58.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:58.975]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:58.975]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:58.975]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:58.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:58.975]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:58.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:58.975]             base::names(...future.oldOptions))
[13:36:58.975]     }
[13:36:58.975]     if (FALSE) {
[13:36:58.975]     }
[13:36:58.975]     else {
[13:36:58.975]         if (TRUE) {
[13:36:58.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:58.975]                 open = "w")
[13:36:58.975]         }
[13:36:58.975]         else {
[13:36:58.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:58.975]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:58.975]         }
[13:36:58.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:58.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:58.975]             base::sink(type = "output", split = FALSE)
[13:36:58.975]             base::close(...future.stdout)
[13:36:58.975]         }, add = TRUE)
[13:36:58.975]     }
[13:36:58.975]     ...future.frame <- base::sys.nframe()
[13:36:58.975]     ...future.conditions <- base::list()
[13:36:58.975]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:58.975]     if (FALSE) {
[13:36:58.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:58.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:58.975]     }
[13:36:58.975]     ...future.result <- base::tryCatch({
[13:36:58.975]         base::withCallingHandlers({
[13:36:58.975]             ...future.value <- base::withVisible(base::local({
[13:36:58.975]                 ...future.makeSendCondition <- base::local({
[13:36:58.975]                   sendCondition <- NULL
[13:36:58.975]                   function(frame = 1L) {
[13:36:58.975]                     if (is.function(sendCondition)) 
[13:36:58.975]                       return(sendCondition)
[13:36:58.975]                     ns <- getNamespace("parallel")
[13:36:58.975]                     if (exists("sendData", mode = "function", 
[13:36:58.975]                       envir = ns)) {
[13:36:58.975]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:58.975]                         envir = ns)
[13:36:58.975]                       envir <- sys.frame(frame)
[13:36:58.975]                       master <- NULL
[13:36:58.975]                       while (!identical(envir, .GlobalEnv) && 
[13:36:58.975]                         !identical(envir, emptyenv())) {
[13:36:58.975]                         if (exists("master", mode = "list", envir = envir, 
[13:36:58.975]                           inherits = FALSE)) {
[13:36:58.975]                           master <- get("master", mode = "list", 
[13:36:58.975]                             envir = envir, inherits = FALSE)
[13:36:58.975]                           if (inherits(master, c("SOCKnode", 
[13:36:58.975]                             "SOCK0node"))) {
[13:36:58.975]                             sendCondition <<- function(cond) {
[13:36:58.975]                               data <- list(type = "VALUE", value = cond, 
[13:36:58.975]                                 success = TRUE)
[13:36:58.975]                               parallel_sendData(master, data)
[13:36:58.975]                             }
[13:36:58.975]                             return(sendCondition)
[13:36:58.975]                           }
[13:36:58.975]                         }
[13:36:58.975]                         frame <- frame + 1L
[13:36:58.975]                         envir <- sys.frame(frame)
[13:36:58.975]                       }
[13:36:58.975]                     }
[13:36:58.975]                     sendCondition <<- function(cond) NULL
[13:36:58.975]                   }
[13:36:58.975]                 })
[13:36:58.975]                 withCallingHandlers({
[13:36:58.975]                   1
[13:36:58.975]                 }, immediateCondition = function(cond) {
[13:36:58.975]                   sendCondition <- ...future.makeSendCondition()
[13:36:58.975]                   sendCondition(cond)
[13:36:58.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.975]                   {
[13:36:58.975]                     inherits <- base::inherits
[13:36:58.975]                     invokeRestart <- base::invokeRestart
[13:36:58.975]                     is.null <- base::is.null
[13:36:58.975]                     muffled <- FALSE
[13:36:58.975]                     if (inherits(cond, "message")) {
[13:36:58.975]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:58.975]                       if (muffled) 
[13:36:58.975]                         invokeRestart("muffleMessage")
[13:36:58.975]                     }
[13:36:58.975]                     else if (inherits(cond, "warning")) {
[13:36:58.975]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:58.975]                       if (muffled) 
[13:36:58.975]                         invokeRestart("muffleWarning")
[13:36:58.975]                     }
[13:36:58.975]                     else if (inherits(cond, "condition")) {
[13:36:58.975]                       if (!is.null(pattern)) {
[13:36:58.975]                         computeRestarts <- base::computeRestarts
[13:36:58.975]                         grepl <- base::grepl
[13:36:58.975]                         restarts <- computeRestarts(cond)
[13:36:58.975]                         for (restart in restarts) {
[13:36:58.975]                           name <- restart$name
[13:36:58.975]                           if (is.null(name)) 
[13:36:58.975]                             next
[13:36:58.975]                           if (!grepl(pattern, name)) 
[13:36:58.975]                             next
[13:36:58.975]                           invokeRestart(restart)
[13:36:58.975]                           muffled <- TRUE
[13:36:58.975]                           break
[13:36:58.975]                         }
[13:36:58.975]                       }
[13:36:58.975]                     }
[13:36:58.975]                     invisible(muffled)
[13:36:58.975]                   }
[13:36:58.975]                   muffleCondition(cond)
[13:36:58.975]                 })
[13:36:58.975]             }))
[13:36:58.975]             future::FutureResult(value = ...future.value$value, 
[13:36:58.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.975]                   ...future.rng), globalenv = if (FALSE) 
[13:36:58.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:58.975]                     ...future.globalenv.names))
[13:36:58.975]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:58.975]         }, condition = base::local({
[13:36:58.975]             c <- base::c
[13:36:58.975]             inherits <- base::inherits
[13:36:58.975]             invokeRestart <- base::invokeRestart
[13:36:58.975]             length <- base::length
[13:36:58.975]             list <- base::list
[13:36:58.975]             seq.int <- base::seq.int
[13:36:58.975]             signalCondition <- base::signalCondition
[13:36:58.975]             sys.calls <- base::sys.calls
[13:36:58.975]             `[[` <- base::`[[`
[13:36:58.975]             `+` <- base::`+`
[13:36:58.975]             `<<-` <- base::`<<-`
[13:36:58.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:58.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:58.975]                   3L)]
[13:36:58.975]             }
[13:36:58.975]             function(cond) {
[13:36:58.975]                 is_error <- inherits(cond, "error")
[13:36:58.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:58.975]                   NULL)
[13:36:58.975]                 if (is_error) {
[13:36:58.975]                   sessionInformation <- function() {
[13:36:58.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:58.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:58.975]                       search = base::search(), system = base::Sys.info())
[13:36:58.975]                   }
[13:36:58.975]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:58.975]                     cond$call), session = sessionInformation(), 
[13:36:58.975]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:58.975]                   signalCondition(cond)
[13:36:58.975]                 }
[13:36:58.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:58.975]                 "immediateCondition"))) {
[13:36:58.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:58.975]                   ...future.conditions[[length(...future.conditions) + 
[13:36:58.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:58.975]                   if (TRUE && !signal) {
[13:36:58.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.975]                     {
[13:36:58.975]                       inherits <- base::inherits
[13:36:58.975]                       invokeRestart <- base::invokeRestart
[13:36:58.975]                       is.null <- base::is.null
[13:36:58.975]                       muffled <- FALSE
[13:36:58.975]                       if (inherits(cond, "message")) {
[13:36:58.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.975]                         if (muffled) 
[13:36:58.975]                           invokeRestart("muffleMessage")
[13:36:58.975]                       }
[13:36:58.975]                       else if (inherits(cond, "warning")) {
[13:36:58.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.975]                         if (muffled) 
[13:36:58.975]                           invokeRestart("muffleWarning")
[13:36:58.975]                       }
[13:36:58.975]                       else if (inherits(cond, "condition")) {
[13:36:58.975]                         if (!is.null(pattern)) {
[13:36:58.975]                           computeRestarts <- base::computeRestarts
[13:36:58.975]                           grepl <- base::grepl
[13:36:58.975]                           restarts <- computeRestarts(cond)
[13:36:58.975]                           for (restart in restarts) {
[13:36:58.975]                             name <- restart$name
[13:36:58.975]                             if (is.null(name)) 
[13:36:58.975]                               next
[13:36:58.975]                             if (!grepl(pattern, name)) 
[13:36:58.975]                               next
[13:36:58.975]                             invokeRestart(restart)
[13:36:58.975]                             muffled <- TRUE
[13:36:58.975]                             break
[13:36:58.975]                           }
[13:36:58.975]                         }
[13:36:58.975]                       }
[13:36:58.975]                       invisible(muffled)
[13:36:58.975]                     }
[13:36:58.975]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.975]                   }
[13:36:58.975]                 }
[13:36:58.975]                 else {
[13:36:58.975]                   if (TRUE) {
[13:36:58.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:58.975]                     {
[13:36:58.975]                       inherits <- base::inherits
[13:36:58.975]                       invokeRestart <- base::invokeRestart
[13:36:58.975]                       is.null <- base::is.null
[13:36:58.975]                       muffled <- FALSE
[13:36:58.975]                       if (inherits(cond, "message")) {
[13:36:58.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:58.975]                         if (muffled) 
[13:36:58.975]                           invokeRestart("muffleMessage")
[13:36:58.975]                       }
[13:36:58.975]                       else if (inherits(cond, "warning")) {
[13:36:58.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:58.975]                         if (muffled) 
[13:36:58.975]                           invokeRestart("muffleWarning")
[13:36:58.975]                       }
[13:36:58.975]                       else if (inherits(cond, "condition")) {
[13:36:58.975]                         if (!is.null(pattern)) {
[13:36:58.975]                           computeRestarts <- base::computeRestarts
[13:36:58.975]                           grepl <- base::grepl
[13:36:58.975]                           restarts <- computeRestarts(cond)
[13:36:58.975]                           for (restart in restarts) {
[13:36:58.975]                             name <- restart$name
[13:36:58.975]                             if (is.null(name)) 
[13:36:58.975]                               next
[13:36:58.975]                             if (!grepl(pattern, name)) 
[13:36:58.975]                               next
[13:36:58.975]                             invokeRestart(restart)
[13:36:58.975]                             muffled <- TRUE
[13:36:58.975]                             break
[13:36:58.975]                           }
[13:36:58.975]                         }
[13:36:58.975]                       }
[13:36:58.975]                       invisible(muffled)
[13:36:58.975]                     }
[13:36:58.975]                     muffleCondition(cond, pattern = "^muffle")
[13:36:58.975]                   }
[13:36:58.975]                 }
[13:36:58.975]             }
[13:36:58.975]         }))
[13:36:58.975]     }, error = function(ex) {
[13:36:58.975]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:58.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:58.975]                 ...future.rng), started = ...future.startTime, 
[13:36:58.975]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:58.975]             version = "1.8"), class = "FutureResult")
[13:36:58.975]     }, finally = {
[13:36:58.975]         if (!identical(...future.workdir, getwd())) 
[13:36:58.975]             setwd(...future.workdir)
[13:36:58.975]         {
[13:36:58.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:58.975]                 ...future.oldOptions$nwarnings <- NULL
[13:36:58.975]             }
[13:36:58.975]             base::options(...future.oldOptions)
[13:36:58.975]             if (.Platform$OS.type == "windows") {
[13:36:58.975]                 old_names <- names(...future.oldEnvVars)
[13:36:58.975]                 envs <- base::Sys.getenv()
[13:36:58.975]                 names <- names(envs)
[13:36:58.975]                 common <- intersect(names, old_names)
[13:36:58.975]                 added <- setdiff(names, old_names)
[13:36:58.975]                 removed <- setdiff(old_names, names)
[13:36:58.975]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:58.975]                   envs[common]]
[13:36:58.975]                 NAMES <- toupper(changed)
[13:36:58.975]                 args <- list()
[13:36:58.975]                 for (kk in seq_along(NAMES)) {
[13:36:58.975]                   name <- changed[[kk]]
[13:36:58.975]                   NAME <- NAMES[[kk]]
[13:36:58.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.975]                     next
[13:36:58.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.975]                 }
[13:36:58.975]                 NAMES <- toupper(added)
[13:36:58.975]                 for (kk in seq_along(NAMES)) {
[13:36:58.975]                   name <- added[[kk]]
[13:36:58.975]                   NAME <- NAMES[[kk]]
[13:36:58.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.975]                     next
[13:36:58.975]                   args[[name]] <- ""
[13:36:58.975]                 }
[13:36:58.975]                 NAMES <- toupper(removed)
[13:36:58.975]                 for (kk in seq_along(NAMES)) {
[13:36:58.975]                   name <- removed[[kk]]
[13:36:58.975]                   NAME <- NAMES[[kk]]
[13:36:58.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:58.975]                     next
[13:36:58.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:58.975]                 }
[13:36:58.975]                 if (length(args) > 0) 
[13:36:58.975]                   base::do.call(base::Sys.setenv, args = args)
[13:36:58.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:58.975]             }
[13:36:58.975]             else {
[13:36:58.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:58.975]             }
[13:36:58.975]             {
[13:36:58.975]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:58.975]                   0L) {
[13:36:58.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:58.975]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:58.975]                   base::options(opts)
[13:36:58.975]                 }
[13:36:58.975]                 {
[13:36:58.975]                   {
[13:36:58.975]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:58.975]                     NULL
[13:36:58.975]                   }
[13:36:58.975]                   options(future.plan = NULL)
[13:36:58.975]                   if (is.na(NA_character_)) 
[13:36:58.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:58.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:58.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:58.975]                     .init = FALSE)
[13:36:58.975]                 }
[13:36:58.975]             }
[13:36:58.975]         }
[13:36:58.975]     })
[13:36:58.975]     if (TRUE) {
[13:36:58.975]         base::sink(type = "output", split = FALSE)
[13:36:58.975]         if (TRUE) {
[13:36:58.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:58.975]         }
[13:36:58.975]         else {
[13:36:58.975]             ...future.result["stdout"] <- base::list(NULL)
[13:36:58.975]         }
[13:36:58.975]         base::close(...future.stdout)
[13:36:58.975]         ...future.stdout <- NULL
[13:36:58.975]     }
[13:36:58.975]     ...future.result$conditions <- ...future.conditions
[13:36:58.975]     ...future.result$finished <- base::Sys.time()
[13:36:58.975]     ...future.result
[13:36:58.975] }
[13:36:58.978] MultisessionFuture started
[13:36:58.978] - Launch lazy future ... done
[13:36:58.978] run() for ‘MultisessionFuture’ ... done
[13:36:59.020] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.020] - Validating connection of MultisessionFuture
[13:36:59.020] - received message: FutureResult
[13:36:59.020] - Received FutureResult
[13:36:59.020] - Erased future from FutureRegistry
[13:36:59.020] result() for ClusterFuture ...
[13:36:59.021] - result already collected: FutureResult
[13:36:59.021] result() for ClusterFuture ... done
[13:36:59.021] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.021] Future #1
[13:36:59.021] result() for ClusterFuture ...
[13:36:59.021] - result already collected: FutureResult
[13:36:59.021] result() for ClusterFuture ... done
[13:36:59.021] result() for ClusterFuture ...
[13:36:59.021] - result already collected: FutureResult
[13:36:59.021] result() for ClusterFuture ... done
[13:36:59.021] A MultisessionFuture was resolved
[13:36:59.022]  length: 0 (resolved future 1)
[13:36:59.022] resolve() on list ... DONE
[13:36:59.022] - globals: [1] ‘a’
[13:36:59.022] Resolving futures part of globals (recursively) ... DONE
[13:36:59.023] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[13:36:59.023] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[13:36:59.023] - globals: [1] ‘a’
[13:36:59.023] - packages: [1] ‘future’
[13:36:59.023] getGlobalsAndPackages() ... DONE
[13:36:59.024] run() for ‘Future’ ...
[13:36:59.024] - state: ‘created’
[13:36:59.024] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.038] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.038] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.038]   - Field: ‘node’
[13:36:59.038]   - Field: ‘label’
[13:36:59.038]   - Field: ‘local’
[13:36:59.038]   - Field: ‘owner’
[13:36:59.038]   - Field: ‘envir’
[13:36:59.038]   - Field: ‘workers’
[13:36:59.038]   - Field: ‘packages’
[13:36:59.039]   - Field: ‘gc’
[13:36:59.039]   - Field: ‘conditions’
[13:36:59.039]   - Field: ‘persistent’
[13:36:59.039]   - Field: ‘expr’
[13:36:59.039]   - Field: ‘uuid’
[13:36:59.039]   - Field: ‘seed’
[13:36:59.039]   - Field: ‘version’
[13:36:59.039]   - Field: ‘result’
[13:36:59.039]   - Field: ‘asynchronous’
[13:36:59.039]   - Field: ‘calls’
[13:36:59.039]   - Field: ‘globals’
[13:36:59.040]   - Field: ‘stdout’
[13:36:59.040]   - Field: ‘earlySignal’
[13:36:59.040]   - Field: ‘lazy’
[13:36:59.040]   - Field: ‘state’
[13:36:59.040] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.040] - Launch lazy future ...
[13:36:59.040] Packages needed by the future expression (n = 1): ‘future’
[13:36:59.040] Packages needed by future strategies (n = 0): <none>
[13:36:59.041] {
[13:36:59.041]     {
[13:36:59.041]         {
[13:36:59.041]             ...future.startTime <- base::Sys.time()
[13:36:59.041]             {
[13:36:59.041]                 {
[13:36:59.041]                   {
[13:36:59.041]                     {
[13:36:59.041]                       {
[13:36:59.041]                         base::local({
[13:36:59.041]                           has_future <- base::requireNamespace("future", 
[13:36:59.041]                             quietly = TRUE)
[13:36:59.041]                           if (has_future) {
[13:36:59.041]                             ns <- base::getNamespace("future")
[13:36:59.041]                             version <- ns[[".package"]][["version"]]
[13:36:59.041]                             if (is.null(version)) 
[13:36:59.041]                               version <- utils::packageVersion("future")
[13:36:59.041]                           }
[13:36:59.041]                           else {
[13:36:59.041]                             version <- NULL
[13:36:59.041]                           }
[13:36:59.041]                           if (!has_future || version < "1.8.0") {
[13:36:59.041]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.041]                               "", base::R.version$version.string), 
[13:36:59.041]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:59.041]                                 base::R.version$platform, 8 * 
[13:36:59.041]                                   base::.Machine$sizeof.pointer), 
[13:36:59.041]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.041]                                 "release", "version")], collapse = " "), 
[13:36:59.041]                               hostname = base::Sys.info()[["nodename"]])
[13:36:59.041]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.041]                               info)
[13:36:59.041]                             info <- base::paste(info, collapse = "; ")
[13:36:59.041]                             if (!has_future) {
[13:36:59.041]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.041]                                 info)
[13:36:59.041]                             }
[13:36:59.041]                             else {
[13:36:59.041]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.041]                                 info, version)
[13:36:59.041]                             }
[13:36:59.041]                             base::stop(msg)
[13:36:59.041]                           }
[13:36:59.041]                         })
[13:36:59.041]                       }
[13:36:59.041]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.041]                       base::options(mc.cores = 1L)
[13:36:59.041]                     }
[13:36:59.041]                     base::local({
[13:36:59.041]                       for (pkg in "future") {
[13:36:59.041]                         base::loadNamespace(pkg)
[13:36:59.041]                         base::library(pkg, character.only = TRUE)
[13:36:59.041]                       }
[13:36:59.041]                     })
[13:36:59.041]                   }
[13:36:59.041]                   ...future.strategy.old <- future::plan("list")
[13:36:59.041]                   options(future.plan = NULL)
[13:36:59.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.041]                 }
[13:36:59.041]                 ...future.workdir <- getwd()
[13:36:59.041]             }
[13:36:59.041]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.041]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.041]         }
[13:36:59.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.041]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:59.041]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.041]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.041]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.041]             base::names(...future.oldOptions))
[13:36:59.041]     }
[13:36:59.041]     if (FALSE) {
[13:36:59.041]     }
[13:36:59.041]     else {
[13:36:59.041]         if (TRUE) {
[13:36:59.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.041]                 open = "w")
[13:36:59.041]         }
[13:36:59.041]         else {
[13:36:59.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.041]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.041]         }
[13:36:59.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.041]             base::sink(type = "output", split = FALSE)
[13:36:59.041]             base::close(...future.stdout)
[13:36:59.041]         }, add = TRUE)
[13:36:59.041]     }
[13:36:59.041]     ...future.frame <- base::sys.nframe()
[13:36:59.041]     ...future.conditions <- base::list()
[13:36:59.041]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.041]     if (FALSE) {
[13:36:59.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.041]     }
[13:36:59.041]     ...future.result <- base::tryCatch({
[13:36:59.041]         base::withCallingHandlers({
[13:36:59.041]             ...future.value <- base::withVisible(base::local({
[13:36:59.041]                 ...future.makeSendCondition <- base::local({
[13:36:59.041]                   sendCondition <- NULL
[13:36:59.041]                   function(frame = 1L) {
[13:36:59.041]                     if (is.function(sendCondition)) 
[13:36:59.041]                       return(sendCondition)
[13:36:59.041]                     ns <- getNamespace("parallel")
[13:36:59.041]                     if (exists("sendData", mode = "function", 
[13:36:59.041]                       envir = ns)) {
[13:36:59.041]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.041]                         envir = ns)
[13:36:59.041]                       envir <- sys.frame(frame)
[13:36:59.041]                       master <- NULL
[13:36:59.041]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.041]                         !identical(envir, emptyenv())) {
[13:36:59.041]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.041]                           inherits = FALSE)) {
[13:36:59.041]                           master <- get("master", mode = "list", 
[13:36:59.041]                             envir = envir, inherits = FALSE)
[13:36:59.041]                           if (inherits(master, c("SOCKnode", 
[13:36:59.041]                             "SOCK0node"))) {
[13:36:59.041]                             sendCondition <<- function(cond) {
[13:36:59.041]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.041]                                 success = TRUE)
[13:36:59.041]                               parallel_sendData(master, data)
[13:36:59.041]                             }
[13:36:59.041]                             return(sendCondition)
[13:36:59.041]                           }
[13:36:59.041]                         }
[13:36:59.041]                         frame <- frame + 1L
[13:36:59.041]                         envir <- sys.frame(frame)
[13:36:59.041]                       }
[13:36:59.041]                     }
[13:36:59.041]                     sendCondition <<- function(cond) NULL
[13:36:59.041]                   }
[13:36:59.041]                 })
[13:36:59.041]                 withCallingHandlers({
[13:36:59.041]                   value(a) + 1
[13:36:59.041]                 }, immediateCondition = function(cond) {
[13:36:59.041]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.041]                   sendCondition(cond)
[13:36:59.041]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.041]                   {
[13:36:59.041]                     inherits <- base::inherits
[13:36:59.041]                     invokeRestart <- base::invokeRestart
[13:36:59.041]                     is.null <- base::is.null
[13:36:59.041]                     muffled <- FALSE
[13:36:59.041]                     if (inherits(cond, "message")) {
[13:36:59.041]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.041]                       if (muffled) 
[13:36:59.041]                         invokeRestart("muffleMessage")
[13:36:59.041]                     }
[13:36:59.041]                     else if (inherits(cond, "warning")) {
[13:36:59.041]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.041]                       if (muffled) 
[13:36:59.041]                         invokeRestart("muffleWarning")
[13:36:59.041]                     }
[13:36:59.041]                     else if (inherits(cond, "condition")) {
[13:36:59.041]                       if (!is.null(pattern)) {
[13:36:59.041]                         computeRestarts <- base::computeRestarts
[13:36:59.041]                         grepl <- base::grepl
[13:36:59.041]                         restarts <- computeRestarts(cond)
[13:36:59.041]                         for (restart in restarts) {
[13:36:59.041]                           name <- restart$name
[13:36:59.041]                           if (is.null(name)) 
[13:36:59.041]                             next
[13:36:59.041]                           if (!grepl(pattern, name)) 
[13:36:59.041]                             next
[13:36:59.041]                           invokeRestart(restart)
[13:36:59.041]                           muffled <- TRUE
[13:36:59.041]                           break
[13:36:59.041]                         }
[13:36:59.041]                       }
[13:36:59.041]                     }
[13:36:59.041]                     invisible(muffled)
[13:36:59.041]                   }
[13:36:59.041]                   muffleCondition(cond)
[13:36:59.041]                 })
[13:36:59.041]             }))
[13:36:59.041]             future::FutureResult(value = ...future.value$value, 
[13:36:59.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.041]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.041]                     ...future.globalenv.names))
[13:36:59.041]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.041]         }, condition = base::local({
[13:36:59.041]             c <- base::c
[13:36:59.041]             inherits <- base::inherits
[13:36:59.041]             invokeRestart <- base::invokeRestart
[13:36:59.041]             length <- base::length
[13:36:59.041]             list <- base::list
[13:36:59.041]             seq.int <- base::seq.int
[13:36:59.041]             signalCondition <- base::signalCondition
[13:36:59.041]             sys.calls <- base::sys.calls
[13:36:59.041]             `[[` <- base::`[[`
[13:36:59.041]             `+` <- base::`+`
[13:36:59.041]             `<<-` <- base::`<<-`
[13:36:59.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.041]                   3L)]
[13:36:59.041]             }
[13:36:59.041]             function(cond) {
[13:36:59.041]                 is_error <- inherits(cond, "error")
[13:36:59.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.041]                   NULL)
[13:36:59.041]                 if (is_error) {
[13:36:59.041]                   sessionInformation <- function() {
[13:36:59.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.041]                       search = base::search(), system = base::Sys.info())
[13:36:59.041]                   }
[13:36:59.041]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.041]                     cond$call), session = sessionInformation(), 
[13:36:59.041]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.041]                   signalCondition(cond)
[13:36:59.041]                 }
[13:36:59.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.041]                 "immediateCondition"))) {
[13:36:59.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.041]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.041]                   if (TRUE && !signal) {
[13:36:59.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.041]                     {
[13:36:59.041]                       inherits <- base::inherits
[13:36:59.041]                       invokeRestart <- base::invokeRestart
[13:36:59.041]                       is.null <- base::is.null
[13:36:59.041]                       muffled <- FALSE
[13:36:59.041]                       if (inherits(cond, "message")) {
[13:36:59.041]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.041]                         if (muffled) 
[13:36:59.041]                           invokeRestart("muffleMessage")
[13:36:59.041]                       }
[13:36:59.041]                       else if (inherits(cond, "warning")) {
[13:36:59.041]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.041]                         if (muffled) 
[13:36:59.041]                           invokeRestart("muffleWarning")
[13:36:59.041]                       }
[13:36:59.041]                       else if (inherits(cond, "condition")) {
[13:36:59.041]                         if (!is.null(pattern)) {
[13:36:59.041]                           computeRestarts <- base::computeRestarts
[13:36:59.041]                           grepl <- base::grepl
[13:36:59.041]                           restarts <- computeRestarts(cond)
[13:36:59.041]                           for (restart in restarts) {
[13:36:59.041]                             name <- restart$name
[13:36:59.041]                             if (is.null(name)) 
[13:36:59.041]                               next
[13:36:59.041]                             if (!grepl(pattern, name)) 
[13:36:59.041]                               next
[13:36:59.041]                             invokeRestart(restart)
[13:36:59.041]                             muffled <- TRUE
[13:36:59.041]                             break
[13:36:59.041]                           }
[13:36:59.041]                         }
[13:36:59.041]                       }
[13:36:59.041]                       invisible(muffled)
[13:36:59.041]                     }
[13:36:59.041]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.041]                   }
[13:36:59.041]                 }
[13:36:59.041]                 else {
[13:36:59.041]                   if (TRUE) {
[13:36:59.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.041]                     {
[13:36:59.041]                       inherits <- base::inherits
[13:36:59.041]                       invokeRestart <- base::invokeRestart
[13:36:59.041]                       is.null <- base::is.null
[13:36:59.041]                       muffled <- FALSE
[13:36:59.041]                       if (inherits(cond, "message")) {
[13:36:59.041]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.041]                         if (muffled) 
[13:36:59.041]                           invokeRestart("muffleMessage")
[13:36:59.041]                       }
[13:36:59.041]                       else if (inherits(cond, "warning")) {
[13:36:59.041]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.041]                         if (muffled) 
[13:36:59.041]                           invokeRestart("muffleWarning")
[13:36:59.041]                       }
[13:36:59.041]                       else if (inherits(cond, "condition")) {
[13:36:59.041]                         if (!is.null(pattern)) {
[13:36:59.041]                           computeRestarts <- base::computeRestarts
[13:36:59.041]                           grepl <- base::grepl
[13:36:59.041]                           restarts <- computeRestarts(cond)
[13:36:59.041]                           for (restart in restarts) {
[13:36:59.041]                             name <- restart$name
[13:36:59.041]                             if (is.null(name)) 
[13:36:59.041]                               next
[13:36:59.041]                             if (!grepl(pattern, name)) 
[13:36:59.041]                               next
[13:36:59.041]                             invokeRestart(restart)
[13:36:59.041]                             muffled <- TRUE
[13:36:59.041]                             break
[13:36:59.041]                           }
[13:36:59.041]                         }
[13:36:59.041]                       }
[13:36:59.041]                       invisible(muffled)
[13:36:59.041]                     }
[13:36:59.041]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.041]                   }
[13:36:59.041]                 }
[13:36:59.041]             }
[13:36:59.041]         }))
[13:36:59.041]     }, error = function(ex) {
[13:36:59.041]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.041]                 ...future.rng), started = ...future.startTime, 
[13:36:59.041]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.041]             version = "1.8"), class = "FutureResult")
[13:36:59.041]     }, finally = {
[13:36:59.041]         if (!identical(...future.workdir, getwd())) 
[13:36:59.041]             setwd(...future.workdir)
[13:36:59.041]         {
[13:36:59.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.041]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.041]             }
[13:36:59.041]             base::options(...future.oldOptions)
[13:36:59.041]             if (.Platform$OS.type == "windows") {
[13:36:59.041]                 old_names <- names(...future.oldEnvVars)
[13:36:59.041]                 envs <- base::Sys.getenv()
[13:36:59.041]                 names <- names(envs)
[13:36:59.041]                 common <- intersect(names, old_names)
[13:36:59.041]                 added <- setdiff(names, old_names)
[13:36:59.041]                 removed <- setdiff(old_names, names)
[13:36:59.041]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.041]                   envs[common]]
[13:36:59.041]                 NAMES <- toupper(changed)
[13:36:59.041]                 args <- list()
[13:36:59.041]                 for (kk in seq_along(NAMES)) {
[13:36:59.041]                   name <- changed[[kk]]
[13:36:59.041]                   NAME <- NAMES[[kk]]
[13:36:59.041]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.041]                     next
[13:36:59.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.041]                 }
[13:36:59.041]                 NAMES <- toupper(added)
[13:36:59.041]                 for (kk in seq_along(NAMES)) {
[13:36:59.041]                   name <- added[[kk]]
[13:36:59.041]                   NAME <- NAMES[[kk]]
[13:36:59.041]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.041]                     next
[13:36:59.041]                   args[[name]] <- ""
[13:36:59.041]                 }
[13:36:59.041]                 NAMES <- toupper(removed)
[13:36:59.041]                 for (kk in seq_along(NAMES)) {
[13:36:59.041]                   name <- removed[[kk]]
[13:36:59.041]                   NAME <- NAMES[[kk]]
[13:36:59.041]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.041]                     next
[13:36:59.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.041]                 }
[13:36:59.041]                 if (length(args) > 0) 
[13:36:59.041]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.041]             }
[13:36:59.041]             else {
[13:36:59.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.041]             }
[13:36:59.041]             {
[13:36:59.041]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.041]                   0L) {
[13:36:59.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.041]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.041]                   base::options(opts)
[13:36:59.041]                 }
[13:36:59.041]                 {
[13:36:59.041]                   {
[13:36:59.041]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.041]                     NULL
[13:36:59.041]                   }
[13:36:59.041]                   options(future.plan = NULL)
[13:36:59.041]                   if (is.na(NA_character_)) 
[13:36:59.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.041]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.041]                     .init = FALSE)
[13:36:59.041]                 }
[13:36:59.041]             }
[13:36:59.041]         }
[13:36:59.041]     })
[13:36:59.041]     if (TRUE) {
[13:36:59.041]         base::sink(type = "output", split = FALSE)
[13:36:59.041]         if (TRUE) {
[13:36:59.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.041]         }
[13:36:59.041]         else {
[13:36:59.041]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.041]         }
[13:36:59.041]         base::close(...future.stdout)
[13:36:59.041]         ...future.stdout <- NULL
[13:36:59.041]     }
[13:36:59.041]     ...future.result$conditions <- ...future.conditions
[13:36:59.041]     ...future.result$finished <- base::Sys.time()
[13:36:59.041]     ...future.result
[13:36:59.041] }
[13:36:59.044] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[13:36:59.044] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[13:36:59.095] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[13:36:59.095] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[13:36:59.095] MultisessionFuture started
[13:36:59.095] - Launch lazy future ... done
[13:36:59.096] run() for ‘MultisessionFuture’ ... done
[13:36:59.096] result() for ClusterFuture ...
[13:36:59.096] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.096] - Validating connection of MultisessionFuture
[13:36:59.140] - received message: FutureResult
[13:36:59.140] - Received FutureResult
[13:36:59.140] - Erased future from FutureRegistry
[13:36:59.141] result() for ClusterFuture ...
[13:36:59.141] - result already collected: FutureResult
[13:36:59.141] result() for ClusterFuture ... done
[13:36:59.141] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.141] result() for ClusterFuture ... done
[13:36:59.141] result() for ClusterFuture ...
[13:36:59.141] - result already collected: FutureResult
[13:36:59.141] result() for ClusterFuture ... done
value(b) = 2
[13:36:59.142] result() for ClusterFuture ...
[13:36:59.142] - result already collected: FutureResult
[13:36:59.142] result() for ClusterFuture ... done
[13:36:59.142] result() for ClusterFuture ...
[13:36:59.142] - result already collected: FutureResult
[13:36:59.142] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.142] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.142] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:59.143] 
[13:36:59.143] Searching for globals ... DONE
[13:36:59.143] - globals: [0] <none>
[13:36:59.143] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.144] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.144] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:59.145] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:59.145] Searching for globals ... DONE
[13:36:59.145] Resolving globals: TRUE
[13:36:59.145] Resolving any globals that are futures ...
[13:36:59.145] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:59.145] Resolving any globals that are futures ... DONE
[13:36:59.146] Resolving futures part of globals (recursively) ...
[13:36:59.146] resolve() on list ...
[13:36:59.146]  recursive: 99
[13:36:59.146]  length: 1
[13:36:59.146]  elements: ‘a’
[13:36:59.146] run() for ‘Future’ ...
[13:36:59.146] - state: ‘created’
[13:36:59.147] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.163] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.163]   - Field: ‘node’
[13:36:59.163]   - Field: ‘label’
[13:36:59.163]   - Field: ‘local’
[13:36:59.163]   - Field: ‘owner’
[13:36:59.163]   - Field: ‘envir’
[13:36:59.163]   - Field: ‘workers’
[13:36:59.164]   - Field: ‘packages’
[13:36:59.164]   - Field: ‘gc’
[13:36:59.164]   - Field: ‘conditions’
[13:36:59.164]   - Field: ‘persistent’
[13:36:59.164]   - Field: ‘expr’
[13:36:59.164]   - Field: ‘uuid’
[13:36:59.164]   - Field: ‘seed’
[13:36:59.164]   - Field: ‘version’
[13:36:59.164]   - Field: ‘result’
[13:36:59.164]   - Field: ‘asynchronous’
[13:36:59.164]   - Field: ‘calls’
[13:36:59.165]   - Field: ‘globals’
[13:36:59.165]   - Field: ‘stdout’
[13:36:59.165]   - Field: ‘earlySignal’
[13:36:59.165]   - Field: ‘lazy’
[13:36:59.165]   - Field: ‘state’
[13:36:59.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.165] - Launch lazy future ...
[13:36:59.165] Packages needed by the future expression (n = 0): <none>
[13:36:59.165] Packages needed by future strategies (n = 0): <none>
[13:36:59.166] {
[13:36:59.166]     {
[13:36:59.166]         {
[13:36:59.166]             ...future.startTime <- base::Sys.time()
[13:36:59.166]             {
[13:36:59.166]                 {
[13:36:59.166]                   {
[13:36:59.166]                     {
[13:36:59.166]                       base::local({
[13:36:59.166]                         has_future <- base::requireNamespace("future", 
[13:36:59.166]                           quietly = TRUE)
[13:36:59.166]                         if (has_future) {
[13:36:59.166]                           ns <- base::getNamespace("future")
[13:36:59.166]                           version <- ns[[".package"]][["version"]]
[13:36:59.166]                           if (is.null(version)) 
[13:36:59.166]                             version <- utils::packageVersion("future")
[13:36:59.166]                         }
[13:36:59.166]                         else {
[13:36:59.166]                           version <- NULL
[13:36:59.166]                         }
[13:36:59.166]                         if (!has_future || version < "1.8.0") {
[13:36:59.166]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.166]                             "", base::R.version$version.string), 
[13:36:59.166]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.166]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.166]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.166]                               "release", "version")], collapse = " "), 
[13:36:59.166]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.166]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.166]                             info)
[13:36:59.166]                           info <- base::paste(info, collapse = "; ")
[13:36:59.166]                           if (!has_future) {
[13:36:59.166]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.166]                               info)
[13:36:59.166]                           }
[13:36:59.166]                           else {
[13:36:59.166]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.166]                               info, version)
[13:36:59.166]                           }
[13:36:59.166]                           base::stop(msg)
[13:36:59.166]                         }
[13:36:59.166]                       })
[13:36:59.166]                     }
[13:36:59.166]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.166]                     base::options(mc.cores = 1L)
[13:36:59.166]                   }
[13:36:59.166]                   ...future.strategy.old <- future::plan("list")
[13:36:59.166]                   options(future.plan = NULL)
[13:36:59.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.166]                 }
[13:36:59.166]                 ...future.workdir <- getwd()
[13:36:59.166]             }
[13:36:59.166]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.166]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.166]         }
[13:36:59.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.166]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:59.166]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.166]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.166]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.166]             base::names(...future.oldOptions))
[13:36:59.166]     }
[13:36:59.166]     if (FALSE) {
[13:36:59.166]     }
[13:36:59.166]     else {
[13:36:59.166]         if (TRUE) {
[13:36:59.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.166]                 open = "w")
[13:36:59.166]         }
[13:36:59.166]         else {
[13:36:59.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.166]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.166]         }
[13:36:59.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.166]             base::sink(type = "output", split = FALSE)
[13:36:59.166]             base::close(...future.stdout)
[13:36:59.166]         }, add = TRUE)
[13:36:59.166]     }
[13:36:59.166]     ...future.frame <- base::sys.nframe()
[13:36:59.166]     ...future.conditions <- base::list()
[13:36:59.166]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.166]     if (FALSE) {
[13:36:59.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.166]     }
[13:36:59.166]     ...future.result <- base::tryCatch({
[13:36:59.166]         base::withCallingHandlers({
[13:36:59.166]             ...future.value <- base::withVisible(base::local({
[13:36:59.166]                 ...future.makeSendCondition <- base::local({
[13:36:59.166]                   sendCondition <- NULL
[13:36:59.166]                   function(frame = 1L) {
[13:36:59.166]                     if (is.function(sendCondition)) 
[13:36:59.166]                       return(sendCondition)
[13:36:59.166]                     ns <- getNamespace("parallel")
[13:36:59.166]                     if (exists("sendData", mode = "function", 
[13:36:59.166]                       envir = ns)) {
[13:36:59.166]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.166]                         envir = ns)
[13:36:59.166]                       envir <- sys.frame(frame)
[13:36:59.166]                       master <- NULL
[13:36:59.166]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.166]                         !identical(envir, emptyenv())) {
[13:36:59.166]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.166]                           inherits = FALSE)) {
[13:36:59.166]                           master <- get("master", mode = "list", 
[13:36:59.166]                             envir = envir, inherits = FALSE)
[13:36:59.166]                           if (inherits(master, c("SOCKnode", 
[13:36:59.166]                             "SOCK0node"))) {
[13:36:59.166]                             sendCondition <<- function(cond) {
[13:36:59.166]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.166]                                 success = TRUE)
[13:36:59.166]                               parallel_sendData(master, data)
[13:36:59.166]                             }
[13:36:59.166]                             return(sendCondition)
[13:36:59.166]                           }
[13:36:59.166]                         }
[13:36:59.166]                         frame <- frame + 1L
[13:36:59.166]                         envir <- sys.frame(frame)
[13:36:59.166]                       }
[13:36:59.166]                     }
[13:36:59.166]                     sendCondition <<- function(cond) NULL
[13:36:59.166]                   }
[13:36:59.166]                 })
[13:36:59.166]                 withCallingHandlers({
[13:36:59.166]                   1
[13:36:59.166]                 }, immediateCondition = function(cond) {
[13:36:59.166]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.166]                   sendCondition(cond)
[13:36:59.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.166]                   {
[13:36:59.166]                     inherits <- base::inherits
[13:36:59.166]                     invokeRestart <- base::invokeRestart
[13:36:59.166]                     is.null <- base::is.null
[13:36:59.166]                     muffled <- FALSE
[13:36:59.166]                     if (inherits(cond, "message")) {
[13:36:59.166]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.166]                       if (muffled) 
[13:36:59.166]                         invokeRestart("muffleMessage")
[13:36:59.166]                     }
[13:36:59.166]                     else if (inherits(cond, "warning")) {
[13:36:59.166]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.166]                       if (muffled) 
[13:36:59.166]                         invokeRestart("muffleWarning")
[13:36:59.166]                     }
[13:36:59.166]                     else if (inherits(cond, "condition")) {
[13:36:59.166]                       if (!is.null(pattern)) {
[13:36:59.166]                         computeRestarts <- base::computeRestarts
[13:36:59.166]                         grepl <- base::grepl
[13:36:59.166]                         restarts <- computeRestarts(cond)
[13:36:59.166]                         for (restart in restarts) {
[13:36:59.166]                           name <- restart$name
[13:36:59.166]                           if (is.null(name)) 
[13:36:59.166]                             next
[13:36:59.166]                           if (!grepl(pattern, name)) 
[13:36:59.166]                             next
[13:36:59.166]                           invokeRestart(restart)
[13:36:59.166]                           muffled <- TRUE
[13:36:59.166]                           break
[13:36:59.166]                         }
[13:36:59.166]                       }
[13:36:59.166]                     }
[13:36:59.166]                     invisible(muffled)
[13:36:59.166]                   }
[13:36:59.166]                   muffleCondition(cond)
[13:36:59.166]                 })
[13:36:59.166]             }))
[13:36:59.166]             future::FutureResult(value = ...future.value$value, 
[13:36:59.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.166]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.166]                     ...future.globalenv.names))
[13:36:59.166]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.166]         }, condition = base::local({
[13:36:59.166]             c <- base::c
[13:36:59.166]             inherits <- base::inherits
[13:36:59.166]             invokeRestart <- base::invokeRestart
[13:36:59.166]             length <- base::length
[13:36:59.166]             list <- base::list
[13:36:59.166]             seq.int <- base::seq.int
[13:36:59.166]             signalCondition <- base::signalCondition
[13:36:59.166]             sys.calls <- base::sys.calls
[13:36:59.166]             `[[` <- base::`[[`
[13:36:59.166]             `+` <- base::`+`
[13:36:59.166]             `<<-` <- base::`<<-`
[13:36:59.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.166]                   3L)]
[13:36:59.166]             }
[13:36:59.166]             function(cond) {
[13:36:59.166]                 is_error <- inherits(cond, "error")
[13:36:59.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.166]                   NULL)
[13:36:59.166]                 if (is_error) {
[13:36:59.166]                   sessionInformation <- function() {
[13:36:59.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.166]                       search = base::search(), system = base::Sys.info())
[13:36:59.166]                   }
[13:36:59.166]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.166]                     cond$call), session = sessionInformation(), 
[13:36:59.166]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.166]                   signalCondition(cond)
[13:36:59.166]                 }
[13:36:59.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.166]                 "immediateCondition"))) {
[13:36:59.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.166]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.166]                   if (TRUE && !signal) {
[13:36:59.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.166]                     {
[13:36:59.166]                       inherits <- base::inherits
[13:36:59.166]                       invokeRestart <- base::invokeRestart
[13:36:59.166]                       is.null <- base::is.null
[13:36:59.166]                       muffled <- FALSE
[13:36:59.166]                       if (inherits(cond, "message")) {
[13:36:59.166]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.166]                         if (muffled) 
[13:36:59.166]                           invokeRestart("muffleMessage")
[13:36:59.166]                       }
[13:36:59.166]                       else if (inherits(cond, "warning")) {
[13:36:59.166]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.166]                         if (muffled) 
[13:36:59.166]                           invokeRestart("muffleWarning")
[13:36:59.166]                       }
[13:36:59.166]                       else if (inherits(cond, "condition")) {
[13:36:59.166]                         if (!is.null(pattern)) {
[13:36:59.166]                           computeRestarts <- base::computeRestarts
[13:36:59.166]                           grepl <- base::grepl
[13:36:59.166]                           restarts <- computeRestarts(cond)
[13:36:59.166]                           for (restart in restarts) {
[13:36:59.166]                             name <- restart$name
[13:36:59.166]                             if (is.null(name)) 
[13:36:59.166]                               next
[13:36:59.166]                             if (!grepl(pattern, name)) 
[13:36:59.166]                               next
[13:36:59.166]                             invokeRestart(restart)
[13:36:59.166]                             muffled <- TRUE
[13:36:59.166]                             break
[13:36:59.166]                           }
[13:36:59.166]                         }
[13:36:59.166]                       }
[13:36:59.166]                       invisible(muffled)
[13:36:59.166]                     }
[13:36:59.166]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.166]                   }
[13:36:59.166]                 }
[13:36:59.166]                 else {
[13:36:59.166]                   if (TRUE) {
[13:36:59.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.166]                     {
[13:36:59.166]                       inherits <- base::inherits
[13:36:59.166]                       invokeRestart <- base::invokeRestart
[13:36:59.166]                       is.null <- base::is.null
[13:36:59.166]                       muffled <- FALSE
[13:36:59.166]                       if (inherits(cond, "message")) {
[13:36:59.166]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.166]                         if (muffled) 
[13:36:59.166]                           invokeRestart("muffleMessage")
[13:36:59.166]                       }
[13:36:59.166]                       else if (inherits(cond, "warning")) {
[13:36:59.166]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.166]                         if (muffled) 
[13:36:59.166]                           invokeRestart("muffleWarning")
[13:36:59.166]                       }
[13:36:59.166]                       else if (inherits(cond, "condition")) {
[13:36:59.166]                         if (!is.null(pattern)) {
[13:36:59.166]                           computeRestarts <- base::computeRestarts
[13:36:59.166]                           grepl <- base::grepl
[13:36:59.166]                           restarts <- computeRestarts(cond)
[13:36:59.166]                           for (restart in restarts) {
[13:36:59.166]                             name <- restart$name
[13:36:59.166]                             if (is.null(name)) 
[13:36:59.166]                               next
[13:36:59.166]                             if (!grepl(pattern, name)) 
[13:36:59.166]                               next
[13:36:59.166]                             invokeRestart(restart)
[13:36:59.166]                             muffled <- TRUE
[13:36:59.166]                             break
[13:36:59.166]                           }
[13:36:59.166]                         }
[13:36:59.166]                       }
[13:36:59.166]                       invisible(muffled)
[13:36:59.166]                     }
[13:36:59.166]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.166]                   }
[13:36:59.166]                 }
[13:36:59.166]             }
[13:36:59.166]         }))
[13:36:59.166]     }, error = function(ex) {
[13:36:59.166]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.166]                 ...future.rng), started = ...future.startTime, 
[13:36:59.166]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.166]             version = "1.8"), class = "FutureResult")
[13:36:59.166]     }, finally = {
[13:36:59.166]         if (!identical(...future.workdir, getwd())) 
[13:36:59.166]             setwd(...future.workdir)
[13:36:59.166]         {
[13:36:59.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.166]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.166]             }
[13:36:59.166]             base::options(...future.oldOptions)
[13:36:59.166]             if (.Platform$OS.type == "windows") {
[13:36:59.166]                 old_names <- names(...future.oldEnvVars)
[13:36:59.166]                 envs <- base::Sys.getenv()
[13:36:59.166]                 names <- names(envs)
[13:36:59.166]                 common <- intersect(names, old_names)
[13:36:59.166]                 added <- setdiff(names, old_names)
[13:36:59.166]                 removed <- setdiff(old_names, names)
[13:36:59.166]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.166]                   envs[common]]
[13:36:59.166]                 NAMES <- toupper(changed)
[13:36:59.166]                 args <- list()
[13:36:59.166]                 for (kk in seq_along(NAMES)) {
[13:36:59.166]                   name <- changed[[kk]]
[13:36:59.166]                   NAME <- NAMES[[kk]]
[13:36:59.166]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.166]                     next
[13:36:59.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.166]                 }
[13:36:59.166]                 NAMES <- toupper(added)
[13:36:59.166]                 for (kk in seq_along(NAMES)) {
[13:36:59.166]                   name <- added[[kk]]
[13:36:59.166]                   NAME <- NAMES[[kk]]
[13:36:59.166]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.166]                     next
[13:36:59.166]                   args[[name]] <- ""
[13:36:59.166]                 }
[13:36:59.166]                 NAMES <- toupper(removed)
[13:36:59.166]                 for (kk in seq_along(NAMES)) {
[13:36:59.166]                   name <- removed[[kk]]
[13:36:59.166]                   NAME <- NAMES[[kk]]
[13:36:59.166]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.166]                     next
[13:36:59.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.166]                 }
[13:36:59.166]                 if (length(args) > 0) 
[13:36:59.166]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.166]             }
[13:36:59.166]             else {
[13:36:59.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.166]             }
[13:36:59.166]             {
[13:36:59.166]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.166]                   0L) {
[13:36:59.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.166]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.166]                   base::options(opts)
[13:36:59.166]                 }
[13:36:59.166]                 {
[13:36:59.166]                   {
[13:36:59.166]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.166]                     NULL
[13:36:59.166]                   }
[13:36:59.166]                   options(future.plan = NULL)
[13:36:59.166]                   if (is.na(NA_character_)) 
[13:36:59.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.166]                     .init = FALSE)
[13:36:59.166]                 }
[13:36:59.166]             }
[13:36:59.166]         }
[13:36:59.166]     })
[13:36:59.166]     if (TRUE) {
[13:36:59.166]         base::sink(type = "output", split = FALSE)
[13:36:59.166]         if (TRUE) {
[13:36:59.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.166]         }
[13:36:59.166]         else {
[13:36:59.166]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.166]         }
[13:36:59.166]         base::close(...future.stdout)
[13:36:59.166]         ...future.stdout <- NULL
[13:36:59.166]     }
[13:36:59.166]     ...future.result$conditions <- ...future.conditions
[13:36:59.166]     ...future.result$finished <- base::Sys.time()
[13:36:59.166]     ...future.result
[13:36:59.166] }
[13:36:59.168] MultisessionFuture started
[13:36:59.169] - Launch lazy future ... done
[13:36:59.169] run() for ‘MultisessionFuture’ ... done
[13:36:59.212] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.212] - Validating connection of MultisessionFuture
[13:36:59.212] - received message: FutureResult
[13:36:59.212] - Received FutureResult
[13:36:59.212] - Erased future from FutureRegistry
[13:36:59.212] result() for ClusterFuture ...
[13:36:59.212] - result already collected: FutureResult
[13:36:59.213] result() for ClusterFuture ... done
[13:36:59.213] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.213] Future #1
[13:36:59.213] result() for ClusterFuture ...
[13:36:59.213] - result already collected: FutureResult
[13:36:59.213] result() for ClusterFuture ... done
[13:36:59.213] result() for ClusterFuture ...
[13:36:59.213] - result already collected: FutureResult
[13:36:59.213] result() for ClusterFuture ... done
[13:36:59.213] A MultisessionFuture was resolved
[13:36:59.214]  length: 0 (resolved future 1)
[13:36:59.214] resolve() on list ... DONE
[13:36:59.214] - globals: [1] ‘a’
[13:36:59.214] Resolving futures part of globals (recursively) ... DONE
[13:36:59.215] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[13:36:59.215] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[13:36:59.215] - globals: [1] ‘a’
[13:36:59.215] - packages: [1] ‘future’
[13:36:59.215] getGlobalsAndPackages() ... DONE
[13:36:59.216] run() for ‘Future’ ...
[13:36:59.216] - state: ‘created’
[13:36:59.216] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.229] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.230]   - Field: ‘node’
[13:36:59.230]   - Field: ‘label’
[13:36:59.230]   - Field: ‘local’
[13:36:59.230]   - Field: ‘owner’
[13:36:59.230]   - Field: ‘envir’
[13:36:59.230]   - Field: ‘workers’
[13:36:59.230]   - Field: ‘packages’
[13:36:59.230]   - Field: ‘gc’
[13:36:59.230]   - Field: ‘conditions’
[13:36:59.230]   - Field: ‘persistent’
[13:36:59.231]   - Field: ‘expr’
[13:36:59.231]   - Field: ‘uuid’
[13:36:59.231]   - Field: ‘seed’
[13:36:59.231]   - Field: ‘version’
[13:36:59.231]   - Field: ‘result’
[13:36:59.231]   - Field: ‘asynchronous’
[13:36:59.231]   - Field: ‘calls’
[13:36:59.231]   - Field: ‘globals’
[13:36:59.231]   - Field: ‘stdout’
[13:36:59.231]   - Field: ‘earlySignal’
[13:36:59.231]   - Field: ‘lazy’
[13:36:59.231]   - Field: ‘state’
[13:36:59.232] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.232] - Launch lazy future ...
[13:36:59.232] Packages needed by the future expression (n = 1): ‘future’
[13:36:59.232] Packages needed by future strategies (n = 0): <none>
[13:36:59.232] {
[13:36:59.232]     {
[13:36:59.232]         {
[13:36:59.232]             ...future.startTime <- base::Sys.time()
[13:36:59.232]             {
[13:36:59.232]                 {
[13:36:59.232]                   {
[13:36:59.232]                     {
[13:36:59.232]                       {
[13:36:59.232]                         base::local({
[13:36:59.232]                           has_future <- base::requireNamespace("future", 
[13:36:59.232]                             quietly = TRUE)
[13:36:59.232]                           if (has_future) {
[13:36:59.232]                             ns <- base::getNamespace("future")
[13:36:59.232]                             version <- ns[[".package"]][["version"]]
[13:36:59.232]                             if (is.null(version)) 
[13:36:59.232]                               version <- utils::packageVersion("future")
[13:36:59.232]                           }
[13:36:59.232]                           else {
[13:36:59.232]                             version <- NULL
[13:36:59.232]                           }
[13:36:59.232]                           if (!has_future || version < "1.8.0") {
[13:36:59.232]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.232]                               "", base::R.version$version.string), 
[13:36:59.232]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:59.232]                                 base::R.version$platform, 8 * 
[13:36:59.232]                                   base::.Machine$sizeof.pointer), 
[13:36:59.232]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.232]                                 "release", "version")], collapse = " "), 
[13:36:59.232]                               hostname = base::Sys.info()[["nodename"]])
[13:36:59.232]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.232]                               info)
[13:36:59.232]                             info <- base::paste(info, collapse = "; ")
[13:36:59.232]                             if (!has_future) {
[13:36:59.232]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.232]                                 info)
[13:36:59.232]                             }
[13:36:59.232]                             else {
[13:36:59.232]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.232]                                 info, version)
[13:36:59.232]                             }
[13:36:59.232]                             base::stop(msg)
[13:36:59.232]                           }
[13:36:59.232]                         })
[13:36:59.232]                       }
[13:36:59.232]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.232]                       base::options(mc.cores = 1L)
[13:36:59.232]                     }
[13:36:59.232]                     base::local({
[13:36:59.232]                       for (pkg in "future") {
[13:36:59.232]                         base::loadNamespace(pkg)
[13:36:59.232]                         base::library(pkg, character.only = TRUE)
[13:36:59.232]                       }
[13:36:59.232]                     })
[13:36:59.232]                   }
[13:36:59.232]                   ...future.strategy.old <- future::plan("list")
[13:36:59.232]                   options(future.plan = NULL)
[13:36:59.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.232]                 }
[13:36:59.232]                 ...future.workdir <- getwd()
[13:36:59.232]             }
[13:36:59.232]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.232]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.232]         }
[13:36:59.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.232]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:59.232]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.232]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.232]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.232]             base::names(...future.oldOptions))
[13:36:59.232]     }
[13:36:59.232]     if (FALSE) {
[13:36:59.232]     }
[13:36:59.232]     else {
[13:36:59.232]         if (TRUE) {
[13:36:59.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.232]                 open = "w")
[13:36:59.232]         }
[13:36:59.232]         else {
[13:36:59.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.232]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.232]         }
[13:36:59.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.232]             base::sink(type = "output", split = FALSE)
[13:36:59.232]             base::close(...future.stdout)
[13:36:59.232]         }, add = TRUE)
[13:36:59.232]     }
[13:36:59.232]     ...future.frame <- base::sys.nframe()
[13:36:59.232]     ...future.conditions <- base::list()
[13:36:59.232]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.232]     if (FALSE) {
[13:36:59.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.232]     }
[13:36:59.232]     ...future.result <- base::tryCatch({
[13:36:59.232]         base::withCallingHandlers({
[13:36:59.232]             ...future.value <- base::withVisible(base::local({
[13:36:59.232]                 ...future.makeSendCondition <- base::local({
[13:36:59.232]                   sendCondition <- NULL
[13:36:59.232]                   function(frame = 1L) {
[13:36:59.232]                     if (is.function(sendCondition)) 
[13:36:59.232]                       return(sendCondition)
[13:36:59.232]                     ns <- getNamespace("parallel")
[13:36:59.232]                     if (exists("sendData", mode = "function", 
[13:36:59.232]                       envir = ns)) {
[13:36:59.232]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.232]                         envir = ns)
[13:36:59.232]                       envir <- sys.frame(frame)
[13:36:59.232]                       master <- NULL
[13:36:59.232]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.232]                         !identical(envir, emptyenv())) {
[13:36:59.232]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.232]                           inherits = FALSE)) {
[13:36:59.232]                           master <- get("master", mode = "list", 
[13:36:59.232]                             envir = envir, inherits = FALSE)
[13:36:59.232]                           if (inherits(master, c("SOCKnode", 
[13:36:59.232]                             "SOCK0node"))) {
[13:36:59.232]                             sendCondition <<- function(cond) {
[13:36:59.232]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.232]                                 success = TRUE)
[13:36:59.232]                               parallel_sendData(master, data)
[13:36:59.232]                             }
[13:36:59.232]                             return(sendCondition)
[13:36:59.232]                           }
[13:36:59.232]                         }
[13:36:59.232]                         frame <- frame + 1L
[13:36:59.232]                         envir <- sys.frame(frame)
[13:36:59.232]                       }
[13:36:59.232]                     }
[13:36:59.232]                     sendCondition <<- function(cond) NULL
[13:36:59.232]                   }
[13:36:59.232]                 })
[13:36:59.232]                 withCallingHandlers({
[13:36:59.232]                   value(a) + 1
[13:36:59.232]                 }, immediateCondition = function(cond) {
[13:36:59.232]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.232]                   sendCondition(cond)
[13:36:59.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.232]                   {
[13:36:59.232]                     inherits <- base::inherits
[13:36:59.232]                     invokeRestart <- base::invokeRestart
[13:36:59.232]                     is.null <- base::is.null
[13:36:59.232]                     muffled <- FALSE
[13:36:59.232]                     if (inherits(cond, "message")) {
[13:36:59.232]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.232]                       if (muffled) 
[13:36:59.232]                         invokeRestart("muffleMessage")
[13:36:59.232]                     }
[13:36:59.232]                     else if (inherits(cond, "warning")) {
[13:36:59.232]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.232]                       if (muffled) 
[13:36:59.232]                         invokeRestart("muffleWarning")
[13:36:59.232]                     }
[13:36:59.232]                     else if (inherits(cond, "condition")) {
[13:36:59.232]                       if (!is.null(pattern)) {
[13:36:59.232]                         computeRestarts <- base::computeRestarts
[13:36:59.232]                         grepl <- base::grepl
[13:36:59.232]                         restarts <- computeRestarts(cond)
[13:36:59.232]                         for (restart in restarts) {
[13:36:59.232]                           name <- restart$name
[13:36:59.232]                           if (is.null(name)) 
[13:36:59.232]                             next
[13:36:59.232]                           if (!grepl(pattern, name)) 
[13:36:59.232]                             next
[13:36:59.232]                           invokeRestart(restart)
[13:36:59.232]                           muffled <- TRUE
[13:36:59.232]                           break
[13:36:59.232]                         }
[13:36:59.232]                       }
[13:36:59.232]                     }
[13:36:59.232]                     invisible(muffled)
[13:36:59.232]                   }
[13:36:59.232]                   muffleCondition(cond)
[13:36:59.232]                 })
[13:36:59.232]             }))
[13:36:59.232]             future::FutureResult(value = ...future.value$value, 
[13:36:59.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.232]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.232]                     ...future.globalenv.names))
[13:36:59.232]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.232]         }, condition = base::local({
[13:36:59.232]             c <- base::c
[13:36:59.232]             inherits <- base::inherits
[13:36:59.232]             invokeRestart <- base::invokeRestart
[13:36:59.232]             length <- base::length
[13:36:59.232]             list <- base::list
[13:36:59.232]             seq.int <- base::seq.int
[13:36:59.232]             signalCondition <- base::signalCondition
[13:36:59.232]             sys.calls <- base::sys.calls
[13:36:59.232]             `[[` <- base::`[[`
[13:36:59.232]             `+` <- base::`+`
[13:36:59.232]             `<<-` <- base::`<<-`
[13:36:59.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.232]                   3L)]
[13:36:59.232]             }
[13:36:59.232]             function(cond) {
[13:36:59.232]                 is_error <- inherits(cond, "error")
[13:36:59.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.232]                   NULL)
[13:36:59.232]                 if (is_error) {
[13:36:59.232]                   sessionInformation <- function() {
[13:36:59.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.232]                       search = base::search(), system = base::Sys.info())
[13:36:59.232]                   }
[13:36:59.232]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.232]                     cond$call), session = sessionInformation(), 
[13:36:59.232]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.232]                   signalCondition(cond)
[13:36:59.232]                 }
[13:36:59.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.232]                 "immediateCondition"))) {
[13:36:59.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.232]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.232]                   if (TRUE && !signal) {
[13:36:59.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.232]                     {
[13:36:59.232]                       inherits <- base::inherits
[13:36:59.232]                       invokeRestart <- base::invokeRestart
[13:36:59.232]                       is.null <- base::is.null
[13:36:59.232]                       muffled <- FALSE
[13:36:59.232]                       if (inherits(cond, "message")) {
[13:36:59.232]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.232]                         if (muffled) 
[13:36:59.232]                           invokeRestart("muffleMessage")
[13:36:59.232]                       }
[13:36:59.232]                       else if (inherits(cond, "warning")) {
[13:36:59.232]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.232]                         if (muffled) 
[13:36:59.232]                           invokeRestart("muffleWarning")
[13:36:59.232]                       }
[13:36:59.232]                       else if (inherits(cond, "condition")) {
[13:36:59.232]                         if (!is.null(pattern)) {
[13:36:59.232]                           computeRestarts <- base::computeRestarts
[13:36:59.232]                           grepl <- base::grepl
[13:36:59.232]                           restarts <- computeRestarts(cond)
[13:36:59.232]                           for (restart in restarts) {
[13:36:59.232]                             name <- restart$name
[13:36:59.232]                             if (is.null(name)) 
[13:36:59.232]                               next
[13:36:59.232]                             if (!grepl(pattern, name)) 
[13:36:59.232]                               next
[13:36:59.232]                             invokeRestart(restart)
[13:36:59.232]                             muffled <- TRUE
[13:36:59.232]                             break
[13:36:59.232]                           }
[13:36:59.232]                         }
[13:36:59.232]                       }
[13:36:59.232]                       invisible(muffled)
[13:36:59.232]                     }
[13:36:59.232]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.232]                   }
[13:36:59.232]                 }
[13:36:59.232]                 else {
[13:36:59.232]                   if (TRUE) {
[13:36:59.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.232]                     {
[13:36:59.232]                       inherits <- base::inherits
[13:36:59.232]                       invokeRestart <- base::invokeRestart
[13:36:59.232]                       is.null <- base::is.null
[13:36:59.232]                       muffled <- FALSE
[13:36:59.232]                       if (inherits(cond, "message")) {
[13:36:59.232]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.232]                         if (muffled) 
[13:36:59.232]                           invokeRestart("muffleMessage")
[13:36:59.232]                       }
[13:36:59.232]                       else if (inherits(cond, "warning")) {
[13:36:59.232]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.232]                         if (muffled) 
[13:36:59.232]                           invokeRestart("muffleWarning")
[13:36:59.232]                       }
[13:36:59.232]                       else if (inherits(cond, "condition")) {
[13:36:59.232]                         if (!is.null(pattern)) {
[13:36:59.232]                           computeRestarts <- base::computeRestarts
[13:36:59.232]                           grepl <- base::grepl
[13:36:59.232]                           restarts <- computeRestarts(cond)
[13:36:59.232]                           for (restart in restarts) {
[13:36:59.232]                             name <- restart$name
[13:36:59.232]                             if (is.null(name)) 
[13:36:59.232]                               next
[13:36:59.232]                             if (!grepl(pattern, name)) 
[13:36:59.232]                               next
[13:36:59.232]                             invokeRestart(restart)
[13:36:59.232]                             muffled <- TRUE
[13:36:59.232]                             break
[13:36:59.232]                           }
[13:36:59.232]                         }
[13:36:59.232]                       }
[13:36:59.232]                       invisible(muffled)
[13:36:59.232]                     }
[13:36:59.232]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.232]                   }
[13:36:59.232]                 }
[13:36:59.232]             }
[13:36:59.232]         }))
[13:36:59.232]     }, error = function(ex) {
[13:36:59.232]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.232]                 ...future.rng), started = ...future.startTime, 
[13:36:59.232]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.232]             version = "1.8"), class = "FutureResult")
[13:36:59.232]     }, finally = {
[13:36:59.232]         if (!identical(...future.workdir, getwd())) 
[13:36:59.232]             setwd(...future.workdir)
[13:36:59.232]         {
[13:36:59.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.232]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.232]             }
[13:36:59.232]             base::options(...future.oldOptions)
[13:36:59.232]             if (.Platform$OS.type == "windows") {
[13:36:59.232]                 old_names <- names(...future.oldEnvVars)
[13:36:59.232]                 envs <- base::Sys.getenv()
[13:36:59.232]                 names <- names(envs)
[13:36:59.232]                 common <- intersect(names, old_names)
[13:36:59.232]                 added <- setdiff(names, old_names)
[13:36:59.232]                 removed <- setdiff(old_names, names)
[13:36:59.232]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.232]                   envs[common]]
[13:36:59.232]                 NAMES <- toupper(changed)
[13:36:59.232]                 args <- list()
[13:36:59.232]                 for (kk in seq_along(NAMES)) {
[13:36:59.232]                   name <- changed[[kk]]
[13:36:59.232]                   NAME <- NAMES[[kk]]
[13:36:59.232]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.232]                     next
[13:36:59.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.232]                 }
[13:36:59.232]                 NAMES <- toupper(added)
[13:36:59.232]                 for (kk in seq_along(NAMES)) {
[13:36:59.232]                   name <- added[[kk]]
[13:36:59.232]                   NAME <- NAMES[[kk]]
[13:36:59.232]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.232]                     next
[13:36:59.232]                   args[[name]] <- ""
[13:36:59.232]                 }
[13:36:59.232]                 NAMES <- toupper(removed)
[13:36:59.232]                 for (kk in seq_along(NAMES)) {
[13:36:59.232]                   name <- removed[[kk]]
[13:36:59.232]                   NAME <- NAMES[[kk]]
[13:36:59.232]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.232]                     next
[13:36:59.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.232]                 }
[13:36:59.232]                 if (length(args) > 0) 
[13:36:59.232]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.232]             }
[13:36:59.232]             else {
[13:36:59.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.232]             }
[13:36:59.232]             {
[13:36:59.232]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.232]                   0L) {
[13:36:59.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.232]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.232]                   base::options(opts)
[13:36:59.232]                 }
[13:36:59.232]                 {
[13:36:59.232]                   {
[13:36:59.232]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.232]                     NULL
[13:36:59.232]                   }
[13:36:59.232]                   options(future.plan = NULL)
[13:36:59.232]                   if (is.na(NA_character_)) 
[13:36:59.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.232]                     .init = FALSE)
[13:36:59.232]                 }
[13:36:59.232]             }
[13:36:59.232]         }
[13:36:59.232]     })
[13:36:59.232]     if (TRUE) {
[13:36:59.232]         base::sink(type = "output", split = FALSE)
[13:36:59.232]         if (TRUE) {
[13:36:59.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.232]         }
[13:36:59.232]         else {
[13:36:59.232]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.232]         }
[13:36:59.232]         base::close(...future.stdout)
[13:36:59.232]         ...future.stdout <- NULL
[13:36:59.232]     }
[13:36:59.232]     ...future.result$conditions <- ...future.conditions
[13:36:59.232]     ...future.result$finished <- base::Sys.time()
[13:36:59.232]     ...future.result
[13:36:59.232] }
[13:36:59.235] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[13:36:59.236] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[13:36:59.291] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[13:36:59.291] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[13:36:59.291] MultisessionFuture started
[13:36:59.291] - Launch lazy future ... done
[13:36:59.291] run() for ‘MultisessionFuture’ ... done
[13:36:59.292] result() for ClusterFuture ...
[13:36:59.292] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.292] - Validating connection of MultisessionFuture
[13:36:59.336] - received message: FutureResult
[13:36:59.336] - Received FutureResult
[13:36:59.336] - Erased future from FutureRegistry
[13:36:59.336] result() for ClusterFuture ...
[13:36:59.336] - result already collected: FutureResult
[13:36:59.337] result() for ClusterFuture ... done
[13:36:59.337] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.337] result() for ClusterFuture ... done
[13:36:59.337] result() for ClusterFuture ...
[13:36:59.337] - result already collected: FutureResult
[13:36:59.337] result() for ClusterFuture ... done
value(b) = 2
[13:36:59.337] result() for ClusterFuture ...
[13:36:59.337] - result already collected: FutureResult
[13:36:59.337] result() for ClusterFuture ... done
[13:36:59.337] result() for ClusterFuture ...
[13:36:59.338] - result already collected: FutureResult
[13:36:59.338] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.338] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.338] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:36:59.339] - globals found: [2] ‘{’, ‘pkg’
[13:36:59.339] Searching for globals ... DONE
[13:36:59.339] Resolving globals: TRUE
[13:36:59.339] Resolving any globals that are futures ...
[13:36:59.339] - globals: [2] ‘{’, ‘pkg’
[13:36:59.339] Resolving any globals that are futures ... DONE
[13:36:59.340] Resolving futures part of globals (recursively) ...
[13:36:59.340] resolve() on list ...
[13:36:59.340]  recursive: 99
[13:36:59.340]  length: 1
[13:36:59.340]  elements: ‘pkg’
[13:36:59.340]  length: 0 (resolved future 1)
[13:36:59.340] resolve() on list ... DONE
[13:36:59.341] - globals: [1] ‘pkg’
[13:36:59.341] Resolving futures part of globals (recursively) ... DONE
[13:36:59.341] The total size of the 1 globals is 112 bytes (112 bytes)
[13:36:59.341] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:36:59.341] - globals: [1] ‘pkg’
[13:36:59.341] 
[13:36:59.341] getGlobalsAndPackages() ... DONE
[13:36:59.342] Packages needed by the future expression (n = 0): <none>
[13:36:59.342] Packages needed by future strategies (n = 0): <none>
[13:36:59.342] {
[13:36:59.342]     {
[13:36:59.342]         {
[13:36:59.342]             ...future.startTime <- base::Sys.time()
[13:36:59.342]             {
[13:36:59.342]                 {
[13:36:59.342]                   {
[13:36:59.342]                     base::local({
[13:36:59.342]                       has_future <- base::requireNamespace("future", 
[13:36:59.342]                         quietly = TRUE)
[13:36:59.342]                       if (has_future) {
[13:36:59.342]                         ns <- base::getNamespace("future")
[13:36:59.342]                         version <- ns[[".package"]][["version"]]
[13:36:59.342]                         if (is.null(version)) 
[13:36:59.342]                           version <- utils::packageVersion("future")
[13:36:59.342]                       }
[13:36:59.342]                       else {
[13:36:59.342]                         version <- NULL
[13:36:59.342]                       }
[13:36:59.342]                       if (!has_future || version < "1.8.0") {
[13:36:59.342]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.342]                           "", base::R.version$version.string), 
[13:36:59.342]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:59.342]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.342]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.342]                             "release", "version")], collapse = " "), 
[13:36:59.342]                           hostname = base::Sys.info()[["nodename"]])
[13:36:59.342]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.342]                           info)
[13:36:59.342]                         info <- base::paste(info, collapse = "; ")
[13:36:59.342]                         if (!has_future) {
[13:36:59.342]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.342]                             info)
[13:36:59.342]                         }
[13:36:59.342]                         else {
[13:36:59.342]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.342]                             info, version)
[13:36:59.342]                         }
[13:36:59.342]                         base::stop(msg)
[13:36:59.342]                       }
[13:36:59.342]                     })
[13:36:59.342]                   }
[13:36:59.342]                   ...future.strategy.old <- future::plan("list")
[13:36:59.342]                   options(future.plan = NULL)
[13:36:59.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.342]                 }
[13:36:59.342]                 ...future.workdir <- getwd()
[13:36:59.342]             }
[13:36:59.342]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.342]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.342]         }
[13:36:59.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.342]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:36:59.342]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.342]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.342]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.342]             base::names(...future.oldOptions))
[13:36:59.342]     }
[13:36:59.342]     if (FALSE) {
[13:36:59.342]     }
[13:36:59.342]     else {
[13:36:59.342]         if (TRUE) {
[13:36:59.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.342]                 open = "w")
[13:36:59.342]         }
[13:36:59.342]         else {
[13:36:59.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.342]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.342]         }
[13:36:59.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.342]             base::sink(type = "output", split = FALSE)
[13:36:59.342]             base::close(...future.stdout)
[13:36:59.342]         }, add = TRUE)
[13:36:59.342]     }
[13:36:59.342]     ...future.frame <- base::sys.nframe()
[13:36:59.342]     ...future.conditions <- base::list()
[13:36:59.342]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.342]     if (FALSE) {
[13:36:59.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.342]     }
[13:36:59.342]     ...future.result <- base::tryCatch({
[13:36:59.342]         base::withCallingHandlers({
[13:36:59.342]             ...future.value <- base::withVisible(base::local({
[13:36:59.342]                 pkg
[13:36:59.342]             }))
[13:36:59.342]             future::FutureResult(value = ...future.value$value, 
[13:36:59.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.342]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.342]                     ...future.globalenv.names))
[13:36:59.342]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.342]         }, condition = base::local({
[13:36:59.342]             c <- base::c
[13:36:59.342]             inherits <- base::inherits
[13:36:59.342]             invokeRestart <- base::invokeRestart
[13:36:59.342]             length <- base::length
[13:36:59.342]             list <- base::list
[13:36:59.342]             seq.int <- base::seq.int
[13:36:59.342]             signalCondition <- base::signalCondition
[13:36:59.342]             sys.calls <- base::sys.calls
[13:36:59.342]             `[[` <- base::`[[`
[13:36:59.342]             `+` <- base::`+`
[13:36:59.342]             `<<-` <- base::`<<-`
[13:36:59.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.342]                   3L)]
[13:36:59.342]             }
[13:36:59.342]             function(cond) {
[13:36:59.342]                 is_error <- inherits(cond, "error")
[13:36:59.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.342]                   NULL)
[13:36:59.342]                 if (is_error) {
[13:36:59.342]                   sessionInformation <- function() {
[13:36:59.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.342]                       search = base::search(), system = base::Sys.info())
[13:36:59.342]                   }
[13:36:59.342]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.342]                     cond$call), session = sessionInformation(), 
[13:36:59.342]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.342]                   signalCondition(cond)
[13:36:59.342]                 }
[13:36:59.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.342]                 "immediateCondition"))) {
[13:36:59.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.342]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.342]                   if (TRUE && !signal) {
[13:36:59.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.342]                     {
[13:36:59.342]                       inherits <- base::inherits
[13:36:59.342]                       invokeRestart <- base::invokeRestart
[13:36:59.342]                       is.null <- base::is.null
[13:36:59.342]                       muffled <- FALSE
[13:36:59.342]                       if (inherits(cond, "message")) {
[13:36:59.342]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.342]                         if (muffled) 
[13:36:59.342]                           invokeRestart("muffleMessage")
[13:36:59.342]                       }
[13:36:59.342]                       else if (inherits(cond, "warning")) {
[13:36:59.342]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.342]                         if (muffled) 
[13:36:59.342]                           invokeRestart("muffleWarning")
[13:36:59.342]                       }
[13:36:59.342]                       else if (inherits(cond, "condition")) {
[13:36:59.342]                         if (!is.null(pattern)) {
[13:36:59.342]                           computeRestarts <- base::computeRestarts
[13:36:59.342]                           grepl <- base::grepl
[13:36:59.342]                           restarts <- computeRestarts(cond)
[13:36:59.342]                           for (restart in restarts) {
[13:36:59.342]                             name <- restart$name
[13:36:59.342]                             if (is.null(name)) 
[13:36:59.342]                               next
[13:36:59.342]                             if (!grepl(pattern, name)) 
[13:36:59.342]                               next
[13:36:59.342]                             invokeRestart(restart)
[13:36:59.342]                             muffled <- TRUE
[13:36:59.342]                             break
[13:36:59.342]                           }
[13:36:59.342]                         }
[13:36:59.342]                       }
[13:36:59.342]                       invisible(muffled)
[13:36:59.342]                     }
[13:36:59.342]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.342]                   }
[13:36:59.342]                 }
[13:36:59.342]                 else {
[13:36:59.342]                   if (TRUE) {
[13:36:59.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.342]                     {
[13:36:59.342]                       inherits <- base::inherits
[13:36:59.342]                       invokeRestart <- base::invokeRestart
[13:36:59.342]                       is.null <- base::is.null
[13:36:59.342]                       muffled <- FALSE
[13:36:59.342]                       if (inherits(cond, "message")) {
[13:36:59.342]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.342]                         if (muffled) 
[13:36:59.342]                           invokeRestart("muffleMessage")
[13:36:59.342]                       }
[13:36:59.342]                       else if (inherits(cond, "warning")) {
[13:36:59.342]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.342]                         if (muffled) 
[13:36:59.342]                           invokeRestart("muffleWarning")
[13:36:59.342]                       }
[13:36:59.342]                       else if (inherits(cond, "condition")) {
[13:36:59.342]                         if (!is.null(pattern)) {
[13:36:59.342]                           computeRestarts <- base::computeRestarts
[13:36:59.342]                           grepl <- base::grepl
[13:36:59.342]                           restarts <- computeRestarts(cond)
[13:36:59.342]                           for (restart in restarts) {
[13:36:59.342]                             name <- restart$name
[13:36:59.342]                             if (is.null(name)) 
[13:36:59.342]                               next
[13:36:59.342]                             if (!grepl(pattern, name)) 
[13:36:59.342]                               next
[13:36:59.342]                             invokeRestart(restart)
[13:36:59.342]                             muffled <- TRUE
[13:36:59.342]                             break
[13:36:59.342]                           }
[13:36:59.342]                         }
[13:36:59.342]                       }
[13:36:59.342]                       invisible(muffled)
[13:36:59.342]                     }
[13:36:59.342]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.342]                   }
[13:36:59.342]                 }
[13:36:59.342]             }
[13:36:59.342]         }))
[13:36:59.342]     }, error = function(ex) {
[13:36:59.342]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.342]                 ...future.rng), started = ...future.startTime, 
[13:36:59.342]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.342]             version = "1.8"), class = "FutureResult")
[13:36:59.342]     }, finally = {
[13:36:59.342]         if (!identical(...future.workdir, getwd())) 
[13:36:59.342]             setwd(...future.workdir)
[13:36:59.342]         {
[13:36:59.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.342]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.342]             }
[13:36:59.342]             base::options(...future.oldOptions)
[13:36:59.342]             if (.Platform$OS.type == "windows") {
[13:36:59.342]                 old_names <- names(...future.oldEnvVars)
[13:36:59.342]                 envs <- base::Sys.getenv()
[13:36:59.342]                 names <- names(envs)
[13:36:59.342]                 common <- intersect(names, old_names)
[13:36:59.342]                 added <- setdiff(names, old_names)
[13:36:59.342]                 removed <- setdiff(old_names, names)
[13:36:59.342]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.342]                   envs[common]]
[13:36:59.342]                 NAMES <- toupper(changed)
[13:36:59.342]                 args <- list()
[13:36:59.342]                 for (kk in seq_along(NAMES)) {
[13:36:59.342]                   name <- changed[[kk]]
[13:36:59.342]                   NAME <- NAMES[[kk]]
[13:36:59.342]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.342]                     next
[13:36:59.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.342]                 }
[13:36:59.342]                 NAMES <- toupper(added)
[13:36:59.342]                 for (kk in seq_along(NAMES)) {
[13:36:59.342]                   name <- added[[kk]]
[13:36:59.342]                   NAME <- NAMES[[kk]]
[13:36:59.342]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.342]                     next
[13:36:59.342]                   args[[name]] <- ""
[13:36:59.342]                 }
[13:36:59.342]                 NAMES <- toupper(removed)
[13:36:59.342]                 for (kk in seq_along(NAMES)) {
[13:36:59.342]                   name <- removed[[kk]]
[13:36:59.342]                   NAME <- NAMES[[kk]]
[13:36:59.342]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.342]                     next
[13:36:59.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.342]                 }
[13:36:59.342]                 if (length(args) > 0) 
[13:36:59.342]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.342]             }
[13:36:59.342]             else {
[13:36:59.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.342]             }
[13:36:59.342]             {
[13:36:59.342]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.342]                   0L) {
[13:36:59.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.342]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.342]                   base::options(opts)
[13:36:59.342]                 }
[13:36:59.342]                 {
[13:36:59.342]                   {
[13:36:59.342]                     NULL
[13:36:59.342]                     RNGkind("Mersenne-Twister")
[13:36:59.342]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:59.342]                       inherits = FALSE)
[13:36:59.342]                   }
[13:36:59.342]                   options(future.plan = NULL)
[13:36:59.342]                   if (is.na(NA_character_)) 
[13:36:59.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.342]                     .init = FALSE)
[13:36:59.342]                 }
[13:36:59.342]             }
[13:36:59.342]         }
[13:36:59.342]     })
[13:36:59.342]     if (TRUE) {
[13:36:59.342]         base::sink(type = "output", split = FALSE)
[13:36:59.342]         if (TRUE) {
[13:36:59.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.342]         }
[13:36:59.342]         else {
[13:36:59.342]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.342]         }
[13:36:59.342]         base::close(...future.stdout)
[13:36:59.342]         ...future.stdout <- NULL
[13:36:59.342]     }
[13:36:59.342]     ...future.result$conditions <- ...future.conditions
[13:36:59.342]     ...future.result$finished <- base::Sys.time()
[13:36:59.342]     ...future.result
[13:36:59.342] }
[13:36:59.344] assign_globals() ...
[13:36:59.344] List of 1
[13:36:59.344]  $ pkg: chr "foo"
[13:36:59.344]  - attr(*, "where")=List of 1
[13:36:59.344]   ..$ pkg:<environment: R_EmptyEnv> 
[13:36:59.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:59.344]  - attr(*, "resolved")= logi TRUE
[13:36:59.344]  - attr(*, "total_size")= num 112
[13:36:59.346] - copied ‘pkg’ to environment
[13:36:59.346] assign_globals() ... done
[13:36:59.346] plan(): Setting new future strategy stack:
[13:36:59.346] List of future strategies:
[13:36:59.346] 1. sequential:
[13:36:59.346]    - args: function (..., envir = parent.frame())
[13:36:59.346]    - tweaked: FALSE
[13:36:59.346]    - call: NULL
[13:36:59.347] plan(): nbrOfWorkers() = 1
[13:36:59.348] plan(): Setting new future strategy stack:
[13:36:59.348] List of future strategies:
[13:36:59.348] 1. multisession:
[13:36:59.348]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:59.348]    - tweaked: FALSE
[13:36:59.348]    - call: plan(strategy)
[13:36:59.351] plan(): nbrOfWorkers() = 2
[13:36:59.351] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.352] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.352] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.354] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:59.354] Searching for globals ... DONE
[13:36:59.354] Resolving globals: TRUE
[13:36:59.354] Resolving any globals that are futures ...
[13:36:59.355] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:59.355] Resolving any globals that are futures ... DONE
[13:36:59.355] Resolving futures part of globals (recursively) ...
[13:36:59.355] resolve() on list ...
[13:36:59.355]  recursive: 99
[13:36:59.355]  length: 1
[13:36:59.355]  elements: ‘a’
[13:36:59.356]  length: 0 (resolved future 1)
[13:36:59.356] resolve() on list ... DONE
[13:36:59.356] - globals: [1] ‘a’
[13:36:59.356] Resolving futures part of globals (recursively) ... DONE
[13:36:59.356] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:59.356] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:59.356] - globals: [1] ‘a’
[13:36:59.357] 
[13:36:59.357] getGlobalsAndPackages() ... DONE
[13:36:59.357] run() for ‘Future’ ...
[13:36:59.357] - state: ‘created’
[13:36:59.357] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.371] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.371]   - Field: ‘node’
[13:36:59.371]   - Field: ‘label’
[13:36:59.371]   - Field: ‘local’
[13:36:59.371]   - Field: ‘owner’
[13:36:59.371]   - Field: ‘envir’
[13:36:59.371]   - Field: ‘workers’
[13:36:59.371]   - Field: ‘packages’
[13:36:59.371]   - Field: ‘gc’
[13:36:59.372]   - Field: ‘conditions’
[13:36:59.372]   - Field: ‘persistent’
[13:36:59.372]   - Field: ‘expr’
[13:36:59.372]   - Field: ‘uuid’
[13:36:59.372]   - Field: ‘seed’
[13:36:59.372]   - Field: ‘version’
[13:36:59.372]   - Field: ‘result’
[13:36:59.372]   - Field: ‘asynchronous’
[13:36:59.372]   - Field: ‘calls’
[13:36:59.372]   - Field: ‘globals’
[13:36:59.372]   - Field: ‘stdout’
[13:36:59.373]   - Field: ‘earlySignal’
[13:36:59.373]   - Field: ‘lazy’
[13:36:59.373]   - Field: ‘state’
[13:36:59.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.373] - Launch lazy future ...
[13:36:59.373] Packages needed by the future expression (n = 0): <none>
[13:36:59.373] Packages needed by future strategies (n = 0): <none>
[13:36:59.374] {
[13:36:59.374]     {
[13:36:59.374]         {
[13:36:59.374]             ...future.startTime <- base::Sys.time()
[13:36:59.374]             {
[13:36:59.374]                 {
[13:36:59.374]                   {
[13:36:59.374]                     {
[13:36:59.374]                       base::local({
[13:36:59.374]                         has_future <- base::requireNamespace("future", 
[13:36:59.374]                           quietly = TRUE)
[13:36:59.374]                         if (has_future) {
[13:36:59.374]                           ns <- base::getNamespace("future")
[13:36:59.374]                           version <- ns[[".package"]][["version"]]
[13:36:59.374]                           if (is.null(version)) 
[13:36:59.374]                             version <- utils::packageVersion("future")
[13:36:59.374]                         }
[13:36:59.374]                         else {
[13:36:59.374]                           version <- NULL
[13:36:59.374]                         }
[13:36:59.374]                         if (!has_future || version < "1.8.0") {
[13:36:59.374]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.374]                             "", base::R.version$version.string), 
[13:36:59.374]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.374]                               "release", "version")], collapse = " "), 
[13:36:59.374]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.374]                             info)
[13:36:59.374]                           info <- base::paste(info, collapse = "; ")
[13:36:59.374]                           if (!has_future) {
[13:36:59.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.374]                               info)
[13:36:59.374]                           }
[13:36:59.374]                           else {
[13:36:59.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.374]                               info, version)
[13:36:59.374]                           }
[13:36:59.374]                           base::stop(msg)
[13:36:59.374]                         }
[13:36:59.374]                       })
[13:36:59.374]                     }
[13:36:59.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.374]                     base::options(mc.cores = 1L)
[13:36:59.374]                   }
[13:36:59.374]                   ...future.strategy.old <- future::plan("list")
[13:36:59.374]                   options(future.plan = NULL)
[13:36:59.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.374]                 }
[13:36:59.374]                 ...future.workdir <- getwd()
[13:36:59.374]             }
[13:36:59.374]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.374]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.374]         }
[13:36:59.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.374]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.374]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.374]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.374]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.374]             base::names(...future.oldOptions))
[13:36:59.374]     }
[13:36:59.374]     if (FALSE) {
[13:36:59.374]     }
[13:36:59.374]     else {
[13:36:59.374]         if (TRUE) {
[13:36:59.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.374]                 open = "w")
[13:36:59.374]         }
[13:36:59.374]         else {
[13:36:59.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.374]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.374]         }
[13:36:59.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.374]             base::sink(type = "output", split = FALSE)
[13:36:59.374]             base::close(...future.stdout)
[13:36:59.374]         }, add = TRUE)
[13:36:59.374]     }
[13:36:59.374]     ...future.frame <- base::sys.nframe()
[13:36:59.374]     ...future.conditions <- base::list()
[13:36:59.374]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.374]     if (FALSE) {
[13:36:59.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.374]     }
[13:36:59.374]     ...future.result <- base::tryCatch({
[13:36:59.374]         base::withCallingHandlers({
[13:36:59.374]             ...future.value <- base::withVisible(base::local({
[13:36:59.374]                 ...future.makeSendCondition <- base::local({
[13:36:59.374]                   sendCondition <- NULL
[13:36:59.374]                   function(frame = 1L) {
[13:36:59.374]                     if (is.function(sendCondition)) 
[13:36:59.374]                       return(sendCondition)
[13:36:59.374]                     ns <- getNamespace("parallel")
[13:36:59.374]                     if (exists("sendData", mode = "function", 
[13:36:59.374]                       envir = ns)) {
[13:36:59.374]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.374]                         envir = ns)
[13:36:59.374]                       envir <- sys.frame(frame)
[13:36:59.374]                       master <- NULL
[13:36:59.374]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.374]                         !identical(envir, emptyenv())) {
[13:36:59.374]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.374]                           inherits = FALSE)) {
[13:36:59.374]                           master <- get("master", mode = "list", 
[13:36:59.374]                             envir = envir, inherits = FALSE)
[13:36:59.374]                           if (inherits(master, c("SOCKnode", 
[13:36:59.374]                             "SOCK0node"))) {
[13:36:59.374]                             sendCondition <<- function(cond) {
[13:36:59.374]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.374]                                 success = TRUE)
[13:36:59.374]                               parallel_sendData(master, data)
[13:36:59.374]                             }
[13:36:59.374]                             return(sendCondition)
[13:36:59.374]                           }
[13:36:59.374]                         }
[13:36:59.374]                         frame <- frame + 1L
[13:36:59.374]                         envir <- sys.frame(frame)
[13:36:59.374]                       }
[13:36:59.374]                     }
[13:36:59.374]                     sendCondition <<- function(cond) NULL
[13:36:59.374]                   }
[13:36:59.374]                 })
[13:36:59.374]                 withCallingHandlers({
[13:36:59.374]                   {
[13:36:59.374]                     b <- a
[13:36:59.374]                     a <- 2
[13:36:59.374]                     a * b
[13:36:59.374]                   }
[13:36:59.374]                 }, immediateCondition = function(cond) {
[13:36:59.374]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.374]                   sendCondition(cond)
[13:36:59.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.374]                   {
[13:36:59.374]                     inherits <- base::inherits
[13:36:59.374]                     invokeRestart <- base::invokeRestart
[13:36:59.374]                     is.null <- base::is.null
[13:36:59.374]                     muffled <- FALSE
[13:36:59.374]                     if (inherits(cond, "message")) {
[13:36:59.374]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.374]                       if (muffled) 
[13:36:59.374]                         invokeRestart("muffleMessage")
[13:36:59.374]                     }
[13:36:59.374]                     else if (inherits(cond, "warning")) {
[13:36:59.374]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.374]                       if (muffled) 
[13:36:59.374]                         invokeRestart("muffleWarning")
[13:36:59.374]                     }
[13:36:59.374]                     else if (inherits(cond, "condition")) {
[13:36:59.374]                       if (!is.null(pattern)) {
[13:36:59.374]                         computeRestarts <- base::computeRestarts
[13:36:59.374]                         grepl <- base::grepl
[13:36:59.374]                         restarts <- computeRestarts(cond)
[13:36:59.374]                         for (restart in restarts) {
[13:36:59.374]                           name <- restart$name
[13:36:59.374]                           if (is.null(name)) 
[13:36:59.374]                             next
[13:36:59.374]                           if (!grepl(pattern, name)) 
[13:36:59.374]                             next
[13:36:59.374]                           invokeRestart(restart)
[13:36:59.374]                           muffled <- TRUE
[13:36:59.374]                           break
[13:36:59.374]                         }
[13:36:59.374]                       }
[13:36:59.374]                     }
[13:36:59.374]                     invisible(muffled)
[13:36:59.374]                   }
[13:36:59.374]                   muffleCondition(cond)
[13:36:59.374]                 })
[13:36:59.374]             }))
[13:36:59.374]             future::FutureResult(value = ...future.value$value, 
[13:36:59.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.374]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.374]                     ...future.globalenv.names))
[13:36:59.374]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.374]         }, condition = base::local({
[13:36:59.374]             c <- base::c
[13:36:59.374]             inherits <- base::inherits
[13:36:59.374]             invokeRestart <- base::invokeRestart
[13:36:59.374]             length <- base::length
[13:36:59.374]             list <- base::list
[13:36:59.374]             seq.int <- base::seq.int
[13:36:59.374]             signalCondition <- base::signalCondition
[13:36:59.374]             sys.calls <- base::sys.calls
[13:36:59.374]             `[[` <- base::`[[`
[13:36:59.374]             `+` <- base::`+`
[13:36:59.374]             `<<-` <- base::`<<-`
[13:36:59.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.374]                   3L)]
[13:36:59.374]             }
[13:36:59.374]             function(cond) {
[13:36:59.374]                 is_error <- inherits(cond, "error")
[13:36:59.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.374]                   NULL)
[13:36:59.374]                 if (is_error) {
[13:36:59.374]                   sessionInformation <- function() {
[13:36:59.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.374]                       search = base::search(), system = base::Sys.info())
[13:36:59.374]                   }
[13:36:59.374]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.374]                     cond$call), session = sessionInformation(), 
[13:36:59.374]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.374]                   signalCondition(cond)
[13:36:59.374]                 }
[13:36:59.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.374]                 "immediateCondition"))) {
[13:36:59.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.374]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.374]                   if (TRUE && !signal) {
[13:36:59.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.374]                     {
[13:36:59.374]                       inherits <- base::inherits
[13:36:59.374]                       invokeRestart <- base::invokeRestart
[13:36:59.374]                       is.null <- base::is.null
[13:36:59.374]                       muffled <- FALSE
[13:36:59.374]                       if (inherits(cond, "message")) {
[13:36:59.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.374]                         if (muffled) 
[13:36:59.374]                           invokeRestart("muffleMessage")
[13:36:59.374]                       }
[13:36:59.374]                       else if (inherits(cond, "warning")) {
[13:36:59.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.374]                         if (muffled) 
[13:36:59.374]                           invokeRestart("muffleWarning")
[13:36:59.374]                       }
[13:36:59.374]                       else if (inherits(cond, "condition")) {
[13:36:59.374]                         if (!is.null(pattern)) {
[13:36:59.374]                           computeRestarts <- base::computeRestarts
[13:36:59.374]                           grepl <- base::grepl
[13:36:59.374]                           restarts <- computeRestarts(cond)
[13:36:59.374]                           for (restart in restarts) {
[13:36:59.374]                             name <- restart$name
[13:36:59.374]                             if (is.null(name)) 
[13:36:59.374]                               next
[13:36:59.374]                             if (!grepl(pattern, name)) 
[13:36:59.374]                               next
[13:36:59.374]                             invokeRestart(restart)
[13:36:59.374]                             muffled <- TRUE
[13:36:59.374]                             break
[13:36:59.374]                           }
[13:36:59.374]                         }
[13:36:59.374]                       }
[13:36:59.374]                       invisible(muffled)
[13:36:59.374]                     }
[13:36:59.374]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.374]                   }
[13:36:59.374]                 }
[13:36:59.374]                 else {
[13:36:59.374]                   if (TRUE) {
[13:36:59.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.374]                     {
[13:36:59.374]                       inherits <- base::inherits
[13:36:59.374]                       invokeRestart <- base::invokeRestart
[13:36:59.374]                       is.null <- base::is.null
[13:36:59.374]                       muffled <- FALSE
[13:36:59.374]                       if (inherits(cond, "message")) {
[13:36:59.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.374]                         if (muffled) 
[13:36:59.374]                           invokeRestart("muffleMessage")
[13:36:59.374]                       }
[13:36:59.374]                       else if (inherits(cond, "warning")) {
[13:36:59.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.374]                         if (muffled) 
[13:36:59.374]                           invokeRestart("muffleWarning")
[13:36:59.374]                       }
[13:36:59.374]                       else if (inherits(cond, "condition")) {
[13:36:59.374]                         if (!is.null(pattern)) {
[13:36:59.374]                           computeRestarts <- base::computeRestarts
[13:36:59.374]                           grepl <- base::grepl
[13:36:59.374]                           restarts <- computeRestarts(cond)
[13:36:59.374]                           for (restart in restarts) {
[13:36:59.374]                             name <- restart$name
[13:36:59.374]                             if (is.null(name)) 
[13:36:59.374]                               next
[13:36:59.374]                             if (!grepl(pattern, name)) 
[13:36:59.374]                               next
[13:36:59.374]                             invokeRestart(restart)
[13:36:59.374]                             muffled <- TRUE
[13:36:59.374]                             break
[13:36:59.374]                           }
[13:36:59.374]                         }
[13:36:59.374]                       }
[13:36:59.374]                       invisible(muffled)
[13:36:59.374]                     }
[13:36:59.374]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.374]                   }
[13:36:59.374]                 }
[13:36:59.374]             }
[13:36:59.374]         }))
[13:36:59.374]     }, error = function(ex) {
[13:36:59.374]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.374]                 ...future.rng), started = ...future.startTime, 
[13:36:59.374]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.374]             version = "1.8"), class = "FutureResult")
[13:36:59.374]     }, finally = {
[13:36:59.374]         if (!identical(...future.workdir, getwd())) 
[13:36:59.374]             setwd(...future.workdir)
[13:36:59.374]         {
[13:36:59.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.374]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.374]             }
[13:36:59.374]             base::options(...future.oldOptions)
[13:36:59.374]             if (.Platform$OS.type == "windows") {
[13:36:59.374]                 old_names <- names(...future.oldEnvVars)
[13:36:59.374]                 envs <- base::Sys.getenv()
[13:36:59.374]                 names <- names(envs)
[13:36:59.374]                 common <- intersect(names, old_names)
[13:36:59.374]                 added <- setdiff(names, old_names)
[13:36:59.374]                 removed <- setdiff(old_names, names)
[13:36:59.374]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.374]                   envs[common]]
[13:36:59.374]                 NAMES <- toupper(changed)
[13:36:59.374]                 args <- list()
[13:36:59.374]                 for (kk in seq_along(NAMES)) {
[13:36:59.374]                   name <- changed[[kk]]
[13:36:59.374]                   NAME <- NAMES[[kk]]
[13:36:59.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.374]                     next
[13:36:59.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.374]                 }
[13:36:59.374]                 NAMES <- toupper(added)
[13:36:59.374]                 for (kk in seq_along(NAMES)) {
[13:36:59.374]                   name <- added[[kk]]
[13:36:59.374]                   NAME <- NAMES[[kk]]
[13:36:59.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.374]                     next
[13:36:59.374]                   args[[name]] <- ""
[13:36:59.374]                 }
[13:36:59.374]                 NAMES <- toupper(removed)
[13:36:59.374]                 for (kk in seq_along(NAMES)) {
[13:36:59.374]                   name <- removed[[kk]]
[13:36:59.374]                   NAME <- NAMES[[kk]]
[13:36:59.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.374]                     next
[13:36:59.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.374]                 }
[13:36:59.374]                 if (length(args) > 0) 
[13:36:59.374]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.374]             }
[13:36:59.374]             else {
[13:36:59.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.374]             }
[13:36:59.374]             {
[13:36:59.374]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.374]                   0L) {
[13:36:59.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.374]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.374]                   base::options(opts)
[13:36:59.374]                 }
[13:36:59.374]                 {
[13:36:59.374]                   {
[13:36:59.374]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.374]                     NULL
[13:36:59.374]                   }
[13:36:59.374]                   options(future.plan = NULL)
[13:36:59.374]                   if (is.na(NA_character_)) 
[13:36:59.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.374]                     .init = FALSE)
[13:36:59.374]                 }
[13:36:59.374]             }
[13:36:59.374]         }
[13:36:59.374]     })
[13:36:59.374]     if (TRUE) {
[13:36:59.374]         base::sink(type = "output", split = FALSE)
[13:36:59.374]         if (TRUE) {
[13:36:59.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.374]         }
[13:36:59.374]         else {
[13:36:59.374]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.374]         }
[13:36:59.374]         base::close(...future.stdout)
[13:36:59.374]         ...future.stdout <- NULL
[13:36:59.374]     }
[13:36:59.374]     ...future.result$conditions <- ...future.conditions
[13:36:59.374]     ...future.result$finished <- base::Sys.time()
[13:36:59.374]     ...future.result
[13:36:59.374] }
[13:36:59.376] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:36:59.376] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:36:59.377] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:36:59.377] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:36:59.377] MultisessionFuture started
[13:36:59.377] - Launch lazy future ... done
[13:36:59.377] run() for ‘MultisessionFuture’ ... done
[13:36:59.378] result() for ClusterFuture ...
[13:36:59.378] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.378] - Validating connection of MultisessionFuture
[13:36:59.420] - received message: FutureResult
[13:36:59.420] - Received FutureResult
[13:36:59.420] - Erased future from FutureRegistry
[13:36:59.420] result() for ClusterFuture ...
[13:36:59.420] - result already collected: FutureResult
[13:36:59.420] result() for ClusterFuture ... done
[13:36:59.420] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.421] result() for ClusterFuture ... done
[13:36:59.421] result() for ClusterFuture ...
[13:36:59.421] - result already collected: FutureResult
[13:36:59.421] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.421] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.422] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.423] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:59.423] Searching for globals ... DONE
[13:36:59.423] Resolving globals: TRUE
[13:36:59.424] Resolving any globals that are futures ...
[13:36:59.424] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:36:59.424] Resolving any globals that are futures ... DONE
[13:36:59.424] Resolving futures part of globals (recursively) ...
[13:36:59.424] resolve() on list ...
[13:36:59.425]  recursive: 99
[13:36:59.425]  length: 1
[13:36:59.425]  elements: ‘a’
[13:36:59.425]  length: 0 (resolved future 1)
[13:36:59.425] resolve() on list ... DONE
[13:36:59.425] - globals: [1] ‘a’
[13:36:59.425] Resolving futures part of globals (recursively) ... DONE
[13:36:59.425] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:59.426] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:59.426] - globals: [1] ‘a’
[13:36:59.426] 
[13:36:59.426] getGlobalsAndPackages() ... DONE
[13:36:59.426] run() for ‘Future’ ...
[13:36:59.426] - state: ‘created’
[13:36:59.426] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.440] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.440]   - Field: ‘node’
[13:36:59.440]   - Field: ‘label’
[13:36:59.440]   - Field: ‘local’
[13:36:59.440]   - Field: ‘owner’
[13:36:59.440]   - Field: ‘envir’
[13:36:59.440]   - Field: ‘workers’
[13:36:59.441]   - Field: ‘packages’
[13:36:59.441]   - Field: ‘gc’
[13:36:59.441]   - Field: ‘conditions’
[13:36:59.441]   - Field: ‘persistent’
[13:36:59.441]   - Field: ‘expr’
[13:36:59.441]   - Field: ‘uuid’
[13:36:59.441]   - Field: ‘seed’
[13:36:59.441]   - Field: ‘version’
[13:36:59.441]   - Field: ‘result’
[13:36:59.441]   - Field: ‘asynchronous’
[13:36:59.441]   - Field: ‘calls’
[13:36:59.442]   - Field: ‘globals’
[13:36:59.442]   - Field: ‘stdout’
[13:36:59.442]   - Field: ‘earlySignal’
[13:36:59.442]   - Field: ‘lazy’
[13:36:59.442]   - Field: ‘state’
[13:36:59.442] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.442] - Launch lazy future ...
[13:36:59.442] Packages needed by the future expression (n = 0): <none>
[13:36:59.442] Packages needed by future strategies (n = 0): <none>
[13:36:59.443] {
[13:36:59.443]     {
[13:36:59.443]         {
[13:36:59.443]             ...future.startTime <- base::Sys.time()
[13:36:59.443]             {
[13:36:59.443]                 {
[13:36:59.443]                   {
[13:36:59.443]                     {
[13:36:59.443]                       base::local({
[13:36:59.443]                         has_future <- base::requireNamespace("future", 
[13:36:59.443]                           quietly = TRUE)
[13:36:59.443]                         if (has_future) {
[13:36:59.443]                           ns <- base::getNamespace("future")
[13:36:59.443]                           version <- ns[[".package"]][["version"]]
[13:36:59.443]                           if (is.null(version)) 
[13:36:59.443]                             version <- utils::packageVersion("future")
[13:36:59.443]                         }
[13:36:59.443]                         else {
[13:36:59.443]                           version <- NULL
[13:36:59.443]                         }
[13:36:59.443]                         if (!has_future || version < "1.8.0") {
[13:36:59.443]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.443]                             "", base::R.version$version.string), 
[13:36:59.443]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.443]                               "release", "version")], collapse = " "), 
[13:36:59.443]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.443]                             info)
[13:36:59.443]                           info <- base::paste(info, collapse = "; ")
[13:36:59.443]                           if (!has_future) {
[13:36:59.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.443]                               info)
[13:36:59.443]                           }
[13:36:59.443]                           else {
[13:36:59.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.443]                               info, version)
[13:36:59.443]                           }
[13:36:59.443]                           base::stop(msg)
[13:36:59.443]                         }
[13:36:59.443]                       })
[13:36:59.443]                     }
[13:36:59.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.443]                     base::options(mc.cores = 1L)
[13:36:59.443]                   }
[13:36:59.443]                   ...future.strategy.old <- future::plan("list")
[13:36:59.443]                   options(future.plan = NULL)
[13:36:59.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.443]                 }
[13:36:59.443]                 ...future.workdir <- getwd()
[13:36:59.443]             }
[13:36:59.443]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.443]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.443]         }
[13:36:59.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.443]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.443]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.443]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.443]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.443]             base::names(...future.oldOptions))
[13:36:59.443]     }
[13:36:59.443]     if (FALSE) {
[13:36:59.443]     }
[13:36:59.443]     else {
[13:36:59.443]         if (TRUE) {
[13:36:59.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.443]                 open = "w")
[13:36:59.443]         }
[13:36:59.443]         else {
[13:36:59.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.443]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.443]         }
[13:36:59.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.443]             base::sink(type = "output", split = FALSE)
[13:36:59.443]             base::close(...future.stdout)
[13:36:59.443]         }, add = TRUE)
[13:36:59.443]     }
[13:36:59.443]     ...future.frame <- base::sys.nframe()
[13:36:59.443]     ...future.conditions <- base::list()
[13:36:59.443]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.443]     if (FALSE) {
[13:36:59.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.443]     }
[13:36:59.443]     ...future.result <- base::tryCatch({
[13:36:59.443]         base::withCallingHandlers({
[13:36:59.443]             ...future.value <- base::withVisible(base::local({
[13:36:59.443]                 ...future.makeSendCondition <- base::local({
[13:36:59.443]                   sendCondition <- NULL
[13:36:59.443]                   function(frame = 1L) {
[13:36:59.443]                     if (is.function(sendCondition)) 
[13:36:59.443]                       return(sendCondition)
[13:36:59.443]                     ns <- getNamespace("parallel")
[13:36:59.443]                     if (exists("sendData", mode = "function", 
[13:36:59.443]                       envir = ns)) {
[13:36:59.443]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.443]                         envir = ns)
[13:36:59.443]                       envir <- sys.frame(frame)
[13:36:59.443]                       master <- NULL
[13:36:59.443]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.443]                         !identical(envir, emptyenv())) {
[13:36:59.443]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.443]                           inherits = FALSE)) {
[13:36:59.443]                           master <- get("master", mode = "list", 
[13:36:59.443]                             envir = envir, inherits = FALSE)
[13:36:59.443]                           if (inherits(master, c("SOCKnode", 
[13:36:59.443]                             "SOCK0node"))) {
[13:36:59.443]                             sendCondition <<- function(cond) {
[13:36:59.443]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.443]                                 success = TRUE)
[13:36:59.443]                               parallel_sendData(master, data)
[13:36:59.443]                             }
[13:36:59.443]                             return(sendCondition)
[13:36:59.443]                           }
[13:36:59.443]                         }
[13:36:59.443]                         frame <- frame + 1L
[13:36:59.443]                         envir <- sys.frame(frame)
[13:36:59.443]                       }
[13:36:59.443]                     }
[13:36:59.443]                     sendCondition <<- function(cond) NULL
[13:36:59.443]                   }
[13:36:59.443]                 })
[13:36:59.443]                 withCallingHandlers({
[13:36:59.443]                   {
[13:36:59.443]                     b <- a
[13:36:59.443]                     a <- 2
[13:36:59.443]                     a * b
[13:36:59.443]                   }
[13:36:59.443]                 }, immediateCondition = function(cond) {
[13:36:59.443]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.443]                   sendCondition(cond)
[13:36:59.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.443]                   {
[13:36:59.443]                     inherits <- base::inherits
[13:36:59.443]                     invokeRestart <- base::invokeRestart
[13:36:59.443]                     is.null <- base::is.null
[13:36:59.443]                     muffled <- FALSE
[13:36:59.443]                     if (inherits(cond, "message")) {
[13:36:59.443]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.443]                       if (muffled) 
[13:36:59.443]                         invokeRestart("muffleMessage")
[13:36:59.443]                     }
[13:36:59.443]                     else if (inherits(cond, "warning")) {
[13:36:59.443]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.443]                       if (muffled) 
[13:36:59.443]                         invokeRestart("muffleWarning")
[13:36:59.443]                     }
[13:36:59.443]                     else if (inherits(cond, "condition")) {
[13:36:59.443]                       if (!is.null(pattern)) {
[13:36:59.443]                         computeRestarts <- base::computeRestarts
[13:36:59.443]                         grepl <- base::grepl
[13:36:59.443]                         restarts <- computeRestarts(cond)
[13:36:59.443]                         for (restart in restarts) {
[13:36:59.443]                           name <- restart$name
[13:36:59.443]                           if (is.null(name)) 
[13:36:59.443]                             next
[13:36:59.443]                           if (!grepl(pattern, name)) 
[13:36:59.443]                             next
[13:36:59.443]                           invokeRestart(restart)
[13:36:59.443]                           muffled <- TRUE
[13:36:59.443]                           break
[13:36:59.443]                         }
[13:36:59.443]                       }
[13:36:59.443]                     }
[13:36:59.443]                     invisible(muffled)
[13:36:59.443]                   }
[13:36:59.443]                   muffleCondition(cond)
[13:36:59.443]                 })
[13:36:59.443]             }))
[13:36:59.443]             future::FutureResult(value = ...future.value$value, 
[13:36:59.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.443]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.443]                     ...future.globalenv.names))
[13:36:59.443]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.443]         }, condition = base::local({
[13:36:59.443]             c <- base::c
[13:36:59.443]             inherits <- base::inherits
[13:36:59.443]             invokeRestart <- base::invokeRestart
[13:36:59.443]             length <- base::length
[13:36:59.443]             list <- base::list
[13:36:59.443]             seq.int <- base::seq.int
[13:36:59.443]             signalCondition <- base::signalCondition
[13:36:59.443]             sys.calls <- base::sys.calls
[13:36:59.443]             `[[` <- base::`[[`
[13:36:59.443]             `+` <- base::`+`
[13:36:59.443]             `<<-` <- base::`<<-`
[13:36:59.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.443]                   3L)]
[13:36:59.443]             }
[13:36:59.443]             function(cond) {
[13:36:59.443]                 is_error <- inherits(cond, "error")
[13:36:59.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.443]                   NULL)
[13:36:59.443]                 if (is_error) {
[13:36:59.443]                   sessionInformation <- function() {
[13:36:59.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.443]                       search = base::search(), system = base::Sys.info())
[13:36:59.443]                   }
[13:36:59.443]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.443]                     cond$call), session = sessionInformation(), 
[13:36:59.443]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.443]                   signalCondition(cond)
[13:36:59.443]                 }
[13:36:59.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.443]                 "immediateCondition"))) {
[13:36:59.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.443]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.443]                   if (TRUE && !signal) {
[13:36:59.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.443]                     {
[13:36:59.443]                       inherits <- base::inherits
[13:36:59.443]                       invokeRestart <- base::invokeRestart
[13:36:59.443]                       is.null <- base::is.null
[13:36:59.443]                       muffled <- FALSE
[13:36:59.443]                       if (inherits(cond, "message")) {
[13:36:59.443]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.443]                         if (muffled) 
[13:36:59.443]                           invokeRestart("muffleMessage")
[13:36:59.443]                       }
[13:36:59.443]                       else if (inherits(cond, "warning")) {
[13:36:59.443]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.443]                         if (muffled) 
[13:36:59.443]                           invokeRestart("muffleWarning")
[13:36:59.443]                       }
[13:36:59.443]                       else if (inherits(cond, "condition")) {
[13:36:59.443]                         if (!is.null(pattern)) {
[13:36:59.443]                           computeRestarts <- base::computeRestarts
[13:36:59.443]                           grepl <- base::grepl
[13:36:59.443]                           restarts <- computeRestarts(cond)
[13:36:59.443]                           for (restart in restarts) {
[13:36:59.443]                             name <- restart$name
[13:36:59.443]                             if (is.null(name)) 
[13:36:59.443]                               next
[13:36:59.443]                             if (!grepl(pattern, name)) 
[13:36:59.443]                               next
[13:36:59.443]                             invokeRestart(restart)
[13:36:59.443]                             muffled <- TRUE
[13:36:59.443]                             break
[13:36:59.443]                           }
[13:36:59.443]                         }
[13:36:59.443]                       }
[13:36:59.443]                       invisible(muffled)
[13:36:59.443]                     }
[13:36:59.443]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.443]                   }
[13:36:59.443]                 }
[13:36:59.443]                 else {
[13:36:59.443]                   if (TRUE) {
[13:36:59.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.443]                     {
[13:36:59.443]                       inherits <- base::inherits
[13:36:59.443]                       invokeRestart <- base::invokeRestart
[13:36:59.443]                       is.null <- base::is.null
[13:36:59.443]                       muffled <- FALSE
[13:36:59.443]                       if (inherits(cond, "message")) {
[13:36:59.443]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.443]                         if (muffled) 
[13:36:59.443]                           invokeRestart("muffleMessage")
[13:36:59.443]                       }
[13:36:59.443]                       else if (inherits(cond, "warning")) {
[13:36:59.443]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.443]                         if (muffled) 
[13:36:59.443]                           invokeRestart("muffleWarning")
[13:36:59.443]                       }
[13:36:59.443]                       else if (inherits(cond, "condition")) {
[13:36:59.443]                         if (!is.null(pattern)) {
[13:36:59.443]                           computeRestarts <- base::computeRestarts
[13:36:59.443]                           grepl <- base::grepl
[13:36:59.443]                           restarts <- computeRestarts(cond)
[13:36:59.443]                           for (restart in restarts) {
[13:36:59.443]                             name <- restart$name
[13:36:59.443]                             if (is.null(name)) 
[13:36:59.443]                               next
[13:36:59.443]                             if (!grepl(pattern, name)) 
[13:36:59.443]                               next
[13:36:59.443]                             invokeRestart(restart)
[13:36:59.443]                             muffled <- TRUE
[13:36:59.443]                             break
[13:36:59.443]                           }
[13:36:59.443]                         }
[13:36:59.443]                       }
[13:36:59.443]                       invisible(muffled)
[13:36:59.443]                     }
[13:36:59.443]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.443]                   }
[13:36:59.443]                 }
[13:36:59.443]             }
[13:36:59.443]         }))
[13:36:59.443]     }, error = function(ex) {
[13:36:59.443]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.443]                 ...future.rng), started = ...future.startTime, 
[13:36:59.443]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.443]             version = "1.8"), class = "FutureResult")
[13:36:59.443]     }, finally = {
[13:36:59.443]         if (!identical(...future.workdir, getwd())) 
[13:36:59.443]             setwd(...future.workdir)
[13:36:59.443]         {
[13:36:59.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.443]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.443]             }
[13:36:59.443]             base::options(...future.oldOptions)
[13:36:59.443]             if (.Platform$OS.type == "windows") {
[13:36:59.443]                 old_names <- names(...future.oldEnvVars)
[13:36:59.443]                 envs <- base::Sys.getenv()
[13:36:59.443]                 names <- names(envs)
[13:36:59.443]                 common <- intersect(names, old_names)
[13:36:59.443]                 added <- setdiff(names, old_names)
[13:36:59.443]                 removed <- setdiff(old_names, names)
[13:36:59.443]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.443]                   envs[common]]
[13:36:59.443]                 NAMES <- toupper(changed)
[13:36:59.443]                 args <- list()
[13:36:59.443]                 for (kk in seq_along(NAMES)) {
[13:36:59.443]                   name <- changed[[kk]]
[13:36:59.443]                   NAME <- NAMES[[kk]]
[13:36:59.443]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.443]                     next
[13:36:59.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.443]                 }
[13:36:59.443]                 NAMES <- toupper(added)
[13:36:59.443]                 for (kk in seq_along(NAMES)) {
[13:36:59.443]                   name <- added[[kk]]
[13:36:59.443]                   NAME <- NAMES[[kk]]
[13:36:59.443]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.443]                     next
[13:36:59.443]                   args[[name]] <- ""
[13:36:59.443]                 }
[13:36:59.443]                 NAMES <- toupper(removed)
[13:36:59.443]                 for (kk in seq_along(NAMES)) {
[13:36:59.443]                   name <- removed[[kk]]
[13:36:59.443]                   NAME <- NAMES[[kk]]
[13:36:59.443]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.443]                     next
[13:36:59.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.443]                 }
[13:36:59.443]                 if (length(args) > 0) 
[13:36:59.443]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.443]             }
[13:36:59.443]             else {
[13:36:59.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.443]             }
[13:36:59.443]             {
[13:36:59.443]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.443]                   0L) {
[13:36:59.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.443]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.443]                   base::options(opts)
[13:36:59.443]                 }
[13:36:59.443]                 {
[13:36:59.443]                   {
[13:36:59.443]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.443]                     NULL
[13:36:59.443]                   }
[13:36:59.443]                   options(future.plan = NULL)
[13:36:59.443]                   if (is.na(NA_character_)) 
[13:36:59.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.443]                     .init = FALSE)
[13:36:59.443]                 }
[13:36:59.443]             }
[13:36:59.443]         }
[13:36:59.443]     })
[13:36:59.443]     if (TRUE) {
[13:36:59.443]         base::sink(type = "output", split = FALSE)
[13:36:59.443]         if (TRUE) {
[13:36:59.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.443]         }
[13:36:59.443]         else {
[13:36:59.443]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.443]         }
[13:36:59.443]         base::close(...future.stdout)
[13:36:59.443]         ...future.stdout <- NULL
[13:36:59.443]     }
[13:36:59.443]     ...future.result$conditions <- ...future.conditions
[13:36:59.443]     ...future.result$finished <- base::Sys.time()
[13:36:59.443]     ...future.result
[13:36:59.443] }
[13:36:59.445] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:36:59.445] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:36:59.446] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:36:59.446] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:36:59.446] MultisessionFuture started
[13:36:59.446] - Launch lazy future ... done
[13:36:59.447] run() for ‘MultisessionFuture’ ... done
[13:36:59.447] result() for ClusterFuture ...
[13:36:59.447] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.447] - Validating connection of MultisessionFuture
[13:36:59.488] - received message: FutureResult
[13:36:59.488] - Received FutureResult
[13:36:59.488] - Erased future from FutureRegistry
[13:36:59.488] result() for ClusterFuture ...
[13:36:59.488] - result already collected: FutureResult
[13:36:59.488] result() for ClusterFuture ... done
[13:36:59.489] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.489] result() for ClusterFuture ... done
[13:36:59.489] result() for ClusterFuture ...
[13:36:59.489] - result already collected: FutureResult
[13:36:59.489] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.490] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.490] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.491] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.492] Searching for globals ... DONE
[13:36:59.492] Resolving globals: TRUE
[13:36:59.492] Resolving any globals that are futures ...
[13:36:59.492] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.492] Resolving any globals that are futures ... DONE
[13:36:59.492] Resolving futures part of globals (recursively) ...
[13:36:59.493] resolve() on list ...
[13:36:59.493]  recursive: 99
[13:36:59.493]  length: 2
[13:36:59.493]  elements: ‘a’, ‘ii’
[13:36:59.493]  length: 1 (resolved future 1)
[13:36:59.493]  length: 0 (resolved future 2)
[13:36:59.493] resolve() on list ... DONE
[13:36:59.493] - globals: [2] ‘a’, ‘ii’
[13:36:59.493] Resolving futures part of globals (recursively) ... DONE
[13:36:59.493] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:59.494] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:59.494] - globals: [2] ‘a’, ‘ii’
[13:36:59.494] 
[13:36:59.494] getGlobalsAndPackages() ... DONE
[13:36:59.494] run() for ‘Future’ ...
[13:36:59.494] - state: ‘created’
[13:36:59.495] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.511] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.511] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.511]   - Field: ‘node’
[13:36:59.511]   - Field: ‘label’
[13:36:59.511]   - Field: ‘local’
[13:36:59.511]   - Field: ‘owner’
[13:36:59.511]   - Field: ‘envir’
[13:36:59.511]   - Field: ‘workers’
[13:36:59.511]   - Field: ‘packages’
[13:36:59.512]   - Field: ‘gc’
[13:36:59.512]   - Field: ‘conditions’
[13:36:59.512]   - Field: ‘persistent’
[13:36:59.512]   - Field: ‘expr’
[13:36:59.512]   - Field: ‘uuid’
[13:36:59.512]   - Field: ‘seed’
[13:36:59.512]   - Field: ‘version’
[13:36:59.512]   - Field: ‘result’
[13:36:59.512]   - Field: ‘asynchronous’
[13:36:59.512]   - Field: ‘calls’
[13:36:59.512]   - Field: ‘globals’
[13:36:59.512]   - Field: ‘stdout’
[13:36:59.513]   - Field: ‘earlySignal’
[13:36:59.513]   - Field: ‘lazy’
[13:36:59.513]   - Field: ‘state’
[13:36:59.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.513] - Launch lazy future ...
[13:36:59.513] Packages needed by the future expression (n = 0): <none>
[13:36:59.513] Packages needed by future strategies (n = 0): <none>
[13:36:59.514] {
[13:36:59.514]     {
[13:36:59.514]         {
[13:36:59.514]             ...future.startTime <- base::Sys.time()
[13:36:59.514]             {
[13:36:59.514]                 {
[13:36:59.514]                   {
[13:36:59.514]                     {
[13:36:59.514]                       base::local({
[13:36:59.514]                         has_future <- base::requireNamespace("future", 
[13:36:59.514]                           quietly = TRUE)
[13:36:59.514]                         if (has_future) {
[13:36:59.514]                           ns <- base::getNamespace("future")
[13:36:59.514]                           version <- ns[[".package"]][["version"]]
[13:36:59.514]                           if (is.null(version)) 
[13:36:59.514]                             version <- utils::packageVersion("future")
[13:36:59.514]                         }
[13:36:59.514]                         else {
[13:36:59.514]                           version <- NULL
[13:36:59.514]                         }
[13:36:59.514]                         if (!has_future || version < "1.8.0") {
[13:36:59.514]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.514]                             "", base::R.version$version.string), 
[13:36:59.514]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.514]                               "release", "version")], collapse = " "), 
[13:36:59.514]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.514]                             info)
[13:36:59.514]                           info <- base::paste(info, collapse = "; ")
[13:36:59.514]                           if (!has_future) {
[13:36:59.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.514]                               info)
[13:36:59.514]                           }
[13:36:59.514]                           else {
[13:36:59.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.514]                               info, version)
[13:36:59.514]                           }
[13:36:59.514]                           base::stop(msg)
[13:36:59.514]                         }
[13:36:59.514]                       })
[13:36:59.514]                     }
[13:36:59.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.514]                     base::options(mc.cores = 1L)
[13:36:59.514]                   }
[13:36:59.514]                   ...future.strategy.old <- future::plan("list")
[13:36:59.514]                   options(future.plan = NULL)
[13:36:59.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.514]                 }
[13:36:59.514]                 ...future.workdir <- getwd()
[13:36:59.514]             }
[13:36:59.514]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.514]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.514]         }
[13:36:59.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.514]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.514]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.514]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.514]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.514]             base::names(...future.oldOptions))
[13:36:59.514]     }
[13:36:59.514]     if (FALSE) {
[13:36:59.514]     }
[13:36:59.514]     else {
[13:36:59.514]         if (TRUE) {
[13:36:59.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.514]                 open = "w")
[13:36:59.514]         }
[13:36:59.514]         else {
[13:36:59.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.514]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.514]         }
[13:36:59.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.514]             base::sink(type = "output", split = FALSE)
[13:36:59.514]             base::close(...future.stdout)
[13:36:59.514]         }, add = TRUE)
[13:36:59.514]     }
[13:36:59.514]     ...future.frame <- base::sys.nframe()
[13:36:59.514]     ...future.conditions <- base::list()
[13:36:59.514]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.514]     if (FALSE) {
[13:36:59.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.514]     }
[13:36:59.514]     ...future.result <- base::tryCatch({
[13:36:59.514]         base::withCallingHandlers({
[13:36:59.514]             ...future.value <- base::withVisible(base::local({
[13:36:59.514]                 ...future.makeSendCondition <- base::local({
[13:36:59.514]                   sendCondition <- NULL
[13:36:59.514]                   function(frame = 1L) {
[13:36:59.514]                     if (is.function(sendCondition)) 
[13:36:59.514]                       return(sendCondition)
[13:36:59.514]                     ns <- getNamespace("parallel")
[13:36:59.514]                     if (exists("sendData", mode = "function", 
[13:36:59.514]                       envir = ns)) {
[13:36:59.514]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.514]                         envir = ns)
[13:36:59.514]                       envir <- sys.frame(frame)
[13:36:59.514]                       master <- NULL
[13:36:59.514]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.514]                         !identical(envir, emptyenv())) {
[13:36:59.514]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.514]                           inherits = FALSE)) {
[13:36:59.514]                           master <- get("master", mode = "list", 
[13:36:59.514]                             envir = envir, inherits = FALSE)
[13:36:59.514]                           if (inherits(master, c("SOCKnode", 
[13:36:59.514]                             "SOCK0node"))) {
[13:36:59.514]                             sendCondition <<- function(cond) {
[13:36:59.514]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.514]                                 success = TRUE)
[13:36:59.514]                               parallel_sendData(master, data)
[13:36:59.514]                             }
[13:36:59.514]                             return(sendCondition)
[13:36:59.514]                           }
[13:36:59.514]                         }
[13:36:59.514]                         frame <- frame + 1L
[13:36:59.514]                         envir <- sys.frame(frame)
[13:36:59.514]                       }
[13:36:59.514]                     }
[13:36:59.514]                     sendCondition <<- function(cond) NULL
[13:36:59.514]                   }
[13:36:59.514]                 })
[13:36:59.514]                 withCallingHandlers({
[13:36:59.514]                   {
[13:36:59.514]                     b <- a * ii
[13:36:59.514]                     a <- 0
[13:36:59.514]                     b
[13:36:59.514]                   }
[13:36:59.514]                 }, immediateCondition = function(cond) {
[13:36:59.514]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.514]                   sendCondition(cond)
[13:36:59.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.514]                   {
[13:36:59.514]                     inherits <- base::inherits
[13:36:59.514]                     invokeRestart <- base::invokeRestart
[13:36:59.514]                     is.null <- base::is.null
[13:36:59.514]                     muffled <- FALSE
[13:36:59.514]                     if (inherits(cond, "message")) {
[13:36:59.514]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.514]                       if (muffled) 
[13:36:59.514]                         invokeRestart("muffleMessage")
[13:36:59.514]                     }
[13:36:59.514]                     else if (inherits(cond, "warning")) {
[13:36:59.514]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.514]                       if (muffled) 
[13:36:59.514]                         invokeRestart("muffleWarning")
[13:36:59.514]                     }
[13:36:59.514]                     else if (inherits(cond, "condition")) {
[13:36:59.514]                       if (!is.null(pattern)) {
[13:36:59.514]                         computeRestarts <- base::computeRestarts
[13:36:59.514]                         grepl <- base::grepl
[13:36:59.514]                         restarts <- computeRestarts(cond)
[13:36:59.514]                         for (restart in restarts) {
[13:36:59.514]                           name <- restart$name
[13:36:59.514]                           if (is.null(name)) 
[13:36:59.514]                             next
[13:36:59.514]                           if (!grepl(pattern, name)) 
[13:36:59.514]                             next
[13:36:59.514]                           invokeRestart(restart)
[13:36:59.514]                           muffled <- TRUE
[13:36:59.514]                           break
[13:36:59.514]                         }
[13:36:59.514]                       }
[13:36:59.514]                     }
[13:36:59.514]                     invisible(muffled)
[13:36:59.514]                   }
[13:36:59.514]                   muffleCondition(cond)
[13:36:59.514]                 })
[13:36:59.514]             }))
[13:36:59.514]             future::FutureResult(value = ...future.value$value, 
[13:36:59.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.514]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.514]                     ...future.globalenv.names))
[13:36:59.514]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.514]         }, condition = base::local({
[13:36:59.514]             c <- base::c
[13:36:59.514]             inherits <- base::inherits
[13:36:59.514]             invokeRestart <- base::invokeRestart
[13:36:59.514]             length <- base::length
[13:36:59.514]             list <- base::list
[13:36:59.514]             seq.int <- base::seq.int
[13:36:59.514]             signalCondition <- base::signalCondition
[13:36:59.514]             sys.calls <- base::sys.calls
[13:36:59.514]             `[[` <- base::`[[`
[13:36:59.514]             `+` <- base::`+`
[13:36:59.514]             `<<-` <- base::`<<-`
[13:36:59.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.514]                   3L)]
[13:36:59.514]             }
[13:36:59.514]             function(cond) {
[13:36:59.514]                 is_error <- inherits(cond, "error")
[13:36:59.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.514]                   NULL)
[13:36:59.514]                 if (is_error) {
[13:36:59.514]                   sessionInformation <- function() {
[13:36:59.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.514]                       search = base::search(), system = base::Sys.info())
[13:36:59.514]                   }
[13:36:59.514]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.514]                     cond$call), session = sessionInformation(), 
[13:36:59.514]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.514]                   signalCondition(cond)
[13:36:59.514]                 }
[13:36:59.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.514]                 "immediateCondition"))) {
[13:36:59.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.514]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.514]                   if (TRUE && !signal) {
[13:36:59.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.514]                     {
[13:36:59.514]                       inherits <- base::inherits
[13:36:59.514]                       invokeRestart <- base::invokeRestart
[13:36:59.514]                       is.null <- base::is.null
[13:36:59.514]                       muffled <- FALSE
[13:36:59.514]                       if (inherits(cond, "message")) {
[13:36:59.514]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.514]                         if (muffled) 
[13:36:59.514]                           invokeRestart("muffleMessage")
[13:36:59.514]                       }
[13:36:59.514]                       else if (inherits(cond, "warning")) {
[13:36:59.514]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.514]                         if (muffled) 
[13:36:59.514]                           invokeRestart("muffleWarning")
[13:36:59.514]                       }
[13:36:59.514]                       else if (inherits(cond, "condition")) {
[13:36:59.514]                         if (!is.null(pattern)) {
[13:36:59.514]                           computeRestarts <- base::computeRestarts
[13:36:59.514]                           grepl <- base::grepl
[13:36:59.514]                           restarts <- computeRestarts(cond)
[13:36:59.514]                           for (restart in restarts) {
[13:36:59.514]                             name <- restart$name
[13:36:59.514]                             if (is.null(name)) 
[13:36:59.514]                               next
[13:36:59.514]                             if (!grepl(pattern, name)) 
[13:36:59.514]                               next
[13:36:59.514]                             invokeRestart(restart)
[13:36:59.514]                             muffled <- TRUE
[13:36:59.514]                             break
[13:36:59.514]                           }
[13:36:59.514]                         }
[13:36:59.514]                       }
[13:36:59.514]                       invisible(muffled)
[13:36:59.514]                     }
[13:36:59.514]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.514]                   }
[13:36:59.514]                 }
[13:36:59.514]                 else {
[13:36:59.514]                   if (TRUE) {
[13:36:59.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.514]                     {
[13:36:59.514]                       inherits <- base::inherits
[13:36:59.514]                       invokeRestart <- base::invokeRestart
[13:36:59.514]                       is.null <- base::is.null
[13:36:59.514]                       muffled <- FALSE
[13:36:59.514]                       if (inherits(cond, "message")) {
[13:36:59.514]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.514]                         if (muffled) 
[13:36:59.514]                           invokeRestart("muffleMessage")
[13:36:59.514]                       }
[13:36:59.514]                       else if (inherits(cond, "warning")) {
[13:36:59.514]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.514]                         if (muffled) 
[13:36:59.514]                           invokeRestart("muffleWarning")
[13:36:59.514]                       }
[13:36:59.514]                       else if (inherits(cond, "condition")) {
[13:36:59.514]                         if (!is.null(pattern)) {
[13:36:59.514]                           computeRestarts <- base::computeRestarts
[13:36:59.514]                           grepl <- base::grepl
[13:36:59.514]                           restarts <- computeRestarts(cond)
[13:36:59.514]                           for (restart in restarts) {
[13:36:59.514]                             name <- restart$name
[13:36:59.514]                             if (is.null(name)) 
[13:36:59.514]                               next
[13:36:59.514]                             if (!grepl(pattern, name)) 
[13:36:59.514]                               next
[13:36:59.514]                             invokeRestart(restart)
[13:36:59.514]                             muffled <- TRUE
[13:36:59.514]                             break
[13:36:59.514]                           }
[13:36:59.514]                         }
[13:36:59.514]                       }
[13:36:59.514]                       invisible(muffled)
[13:36:59.514]                     }
[13:36:59.514]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.514]                   }
[13:36:59.514]                 }
[13:36:59.514]             }
[13:36:59.514]         }))
[13:36:59.514]     }, error = function(ex) {
[13:36:59.514]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.514]                 ...future.rng), started = ...future.startTime, 
[13:36:59.514]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.514]             version = "1.8"), class = "FutureResult")
[13:36:59.514]     }, finally = {
[13:36:59.514]         if (!identical(...future.workdir, getwd())) 
[13:36:59.514]             setwd(...future.workdir)
[13:36:59.514]         {
[13:36:59.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.514]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.514]             }
[13:36:59.514]             base::options(...future.oldOptions)
[13:36:59.514]             if (.Platform$OS.type == "windows") {
[13:36:59.514]                 old_names <- names(...future.oldEnvVars)
[13:36:59.514]                 envs <- base::Sys.getenv()
[13:36:59.514]                 names <- names(envs)
[13:36:59.514]                 common <- intersect(names, old_names)
[13:36:59.514]                 added <- setdiff(names, old_names)
[13:36:59.514]                 removed <- setdiff(old_names, names)
[13:36:59.514]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.514]                   envs[common]]
[13:36:59.514]                 NAMES <- toupper(changed)
[13:36:59.514]                 args <- list()
[13:36:59.514]                 for (kk in seq_along(NAMES)) {
[13:36:59.514]                   name <- changed[[kk]]
[13:36:59.514]                   NAME <- NAMES[[kk]]
[13:36:59.514]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.514]                     next
[13:36:59.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.514]                 }
[13:36:59.514]                 NAMES <- toupper(added)
[13:36:59.514]                 for (kk in seq_along(NAMES)) {
[13:36:59.514]                   name <- added[[kk]]
[13:36:59.514]                   NAME <- NAMES[[kk]]
[13:36:59.514]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.514]                     next
[13:36:59.514]                   args[[name]] <- ""
[13:36:59.514]                 }
[13:36:59.514]                 NAMES <- toupper(removed)
[13:36:59.514]                 for (kk in seq_along(NAMES)) {
[13:36:59.514]                   name <- removed[[kk]]
[13:36:59.514]                   NAME <- NAMES[[kk]]
[13:36:59.514]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.514]                     next
[13:36:59.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.514]                 }
[13:36:59.514]                 if (length(args) > 0) 
[13:36:59.514]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.514]             }
[13:36:59.514]             else {
[13:36:59.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.514]             }
[13:36:59.514]             {
[13:36:59.514]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.514]                   0L) {
[13:36:59.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.514]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.514]                   base::options(opts)
[13:36:59.514]                 }
[13:36:59.514]                 {
[13:36:59.514]                   {
[13:36:59.514]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.514]                     NULL
[13:36:59.514]                   }
[13:36:59.514]                   options(future.plan = NULL)
[13:36:59.514]                   if (is.na(NA_character_)) 
[13:36:59.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.514]                     .init = FALSE)
[13:36:59.514]                 }
[13:36:59.514]             }
[13:36:59.514]         }
[13:36:59.514]     })
[13:36:59.514]     if (TRUE) {
[13:36:59.514]         base::sink(type = "output", split = FALSE)
[13:36:59.514]         if (TRUE) {
[13:36:59.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.514]         }
[13:36:59.514]         else {
[13:36:59.514]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.514]         }
[13:36:59.514]         base::close(...future.stdout)
[13:36:59.514]         ...future.stdout <- NULL
[13:36:59.514]     }
[13:36:59.514]     ...future.result$conditions <- ...future.conditions
[13:36:59.514]     ...future.result$finished <- base::Sys.time()
[13:36:59.514]     ...future.result
[13:36:59.514] }
[13:36:59.516] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[13:36:59.516] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:36:59.517] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:36:59.517] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:36:59.517] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:36:59.517] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[13:36:59.518] MultisessionFuture started
[13:36:59.518] - Launch lazy future ... done
[13:36:59.518] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.518] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.518] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.520] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.520] Searching for globals ... DONE
[13:36:59.520] Resolving globals: TRUE
[13:36:59.520] Resolving any globals that are futures ...
[13:36:59.521] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.521] Resolving any globals that are futures ... DONE
[13:36:59.521] Resolving futures part of globals (recursively) ...
[13:36:59.521] resolve() on list ...
[13:36:59.521]  recursive: 99
[13:36:59.521]  length: 2
[13:36:59.521]  elements: ‘a’, ‘ii’
[13:36:59.522]  length: 1 (resolved future 1)
[13:36:59.522]  length: 0 (resolved future 2)
[13:36:59.522] resolve() on list ... DONE
[13:36:59.522] - globals: [2] ‘a’, ‘ii’
[13:36:59.522] Resolving futures part of globals (recursively) ... DONE
[13:36:59.522] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:59.522] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:59.523] - globals: [2] ‘a’, ‘ii’
[13:36:59.523] 
[13:36:59.523] getGlobalsAndPackages() ... DONE
[13:36:59.523] run() for ‘Future’ ...
[13:36:59.523] - state: ‘created’
[13:36:59.523] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.537] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.537]   - Field: ‘node’
[13:36:59.537]   - Field: ‘label’
[13:36:59.537]   - Field: ‘local’
[13:36:59.538]   - Field: ‘owner’
[13:36:59.538]   - Field: ‘envir’
[13:36:59.538]   - Field: ‘workers’
[13:36:59.538]   - Field: ‘packages’
[13:36:59.538]   - Field: ‘gc’
[13:36:59.538]   - Field: ‘conditions’
[13:36:59.538]   - Field: ‘persistent’
[13:36:59.538]   - Field: ‘expr’
[13:36:59.538]   - Field: ‘uuid’
[13:36:59.538]   - Field: ‘seed’
[13:36:59.539]   - Field: ‘version’
[13:36:59.539]   - Field: ‘result’
[13:36:59.539]   - Field: ‘asynchronous’
[13:36:59.539]   - Field: ‘calls’
[13:36:59.539]   - Field: ‘globals’
[13:36:59.539]   - Field: ‘stdout’
[13:36:59.539]   - Field: ‘earlySignal’
[13:36:59.539]   - Field: ‘lazy’
[13:36:59.539]   - Field: ‘state’
[13:36:59.539] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.539] - Launch lazy future ...
[13:36:59.540] Packages needed by the future expression (n = 0): <none>
[13:36:59.540] Packages needed by future strategies (n = 0): <none>
[13:36:59.540] {
[13:36:59.540]     {
[13:36:59.540]         {
[13:36:59.540]             ...future.startTime <- base::Sys.time()
[13:36:59.540]             {
[13:36:59.540]                 {
[13:36:59.540]                   {
[13:36:59.540]                     {
[13:36:59.540]                       base::local({
[13:36:59.540]                         has_future <- base::requireNamespace("future", 
[13:36:59.540]                           quietly = TRUE)
[13:36:59.540]                         if (has_future) {
[13:36:59.540]                           ns <- base::getNamespace("future")
[13:36:59.540]                           version <- ns[[".package"]][["version"]]
[13:36:59.540]                           if (is.null(version)) 
[13:36:59.540]                             version <- utils::packageVersion("future")
[13:36:59.540]                         }
[13:36:59.540]                         else {
[13:36:59.540]                           version <- NULL
[13:36:59.540]                         }
[13:36:59.540]                         if (!has_future || version < "1.8.0") {
[13:36:59.540]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.540]                             "", base::R.version$version.string), 
[13:36:59.540]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.540]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.540]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.540]                               "release", "version")], collapse = " "), 
[13:36:59.540]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.540]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.540]                             info)
[13:36:59.540]                           info <- base::paste(info, collapse = "; ")
[13:36:59.540]                           if (!has_future) {
[13:36:59.540]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.540]                               info)
[13:36:59.540]                           }
[13:36:59.540]                           else {
[13:36:59.540]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.540]                               info, version)
[13:36:59.540]                           }
[13:36:59.540]                           base::stop(msg)
[13:36:59.540]                         }
[13:36:59.540]                       })
[13:36:59.540]                     }
[13:36:59.540]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.540]                     base::options(mc.cores = 1L)
[13:36:59.540]                   }
[13:36:59.540]                   ...future.strategy.old <- future::plan("list")
[13:36:59.540]                   options(future.plan = NULL)
[13:36:59.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.540]                 }
[13:36:59.540]                 ...future.workdir <- getwd()
[13:36:59.540]             }
[13:36:59.540]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.540]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.540]         }
[13:36:59.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.540]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.540]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.540]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.540]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.540]             base::names(...future.oldOptions))
[13:36:59.540]     }
[13:36:59.540]     if (FALSE) {
[13:36:59.540]     }
[13:36:59.540]     else {
[13:36:59.540]         if (TRUE) {
[13:36:59.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.540]                 open = "w")
[13:36:59.540]         }
[13:36:59.540]         else {
[13:36:59.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.540]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.540]         }
[13:36:59.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.540]             base::sink(type = "output", split = FALSE)
[13:36:59.540]             base::close(...future.stdout)
[13:36:59.540]         }, add = TRUE)
[13:36:59.540]     }
[13:36:59.540]     ...future.frame <- base::sys.nframe()
[13:36:59.540]     ...future.conditions <- base::list()
[13:36:59.540]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.540]     if (FALSE) {
[13:36:59.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.540]     }
[13:36:59.540]     ...future.result <- base::tryCatch({
[13:36:59.540]         base::withCallingHandlers({
[13:36:59.540]             ...future.value <- base::withVisible(base::local({
[13:36:59.540]                 ...future.makeSendCondition <- base::local({
[13:36:59.540]                   sendCondition <- NULL
[13:36:59.540]                   function(frame = 1L) {
[13:36:59.540]                     if (is.function(sendCondition)) 
[13:36:59.540]                       return(sendCondition)
[13:36:59.540]                     ns <- getNamespace("parallel")
[13:36:59.540]                     if (exists("sendData", mode = "function", 
[13:36:59.540]                       envir = ns)) {
[13:36:59.540]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.540]                         envir = ns)
[13:36:59.540]                       envir <- sys.frame(frame)
[13:36:59.540]                       master <- NULL
[13:36:59.540]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.540]                         !identical(envir, emptyenv())) {
[13:36:59.540]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.540]                           inherits = FALSE)) {
[13:36:59.540]                           master <- get("master", mode = "list", 
[13:36:59.540]                             envir = envir, inherits = FALSE)
[13:36:59.540]                           if (inherits(master, c("SOCKnode", 
[13:36:59.540]                             "SOCK0node"))) {
[13:36:59.540]                             sendCondition <<- function(cond) {
[13:36:59.540]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.540]                                 success = TRUE)
[13:36:59.540]                               parallel_sendData(master, data)
[13:36:59.540]                             }
[13:36:59.540]                             return(sendCondition)
[13:36:59.540]                           }
[13:36:59.540]                         }
[13:36:59.540]                         frame <- frame + 1L
[13:36:59.540]                         envir <- sys.frame(frame)
[13:36:59.540]                       }
[13:36:59.540]                     }
[13:36:59.540]                     sendCondition <<- function(cond) NULL
[13:36:59.540]                   }
[13:36:59.540]                 })
[13:36:59.540]                 withCallingHandlers({
[13:36:59.540]                   {
[13:36:59.540]                     b <- a * ii
[13:36:59.540]                     a <- 0
[13:36:59.540]                     b
[13:36:59.540]                   }
[13:36:59.540]                 }, immediateCondition = function(cond) {
[13:36:59.540]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.540]                   sendCondition(cond)
[13:36:59.540]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.540]                   {
[13:36:59.540]                     inherits <- base::inherits
[13:36:59.540]                     invokeRestart <- base::invokeRestart
[13:36:59.540]                     is.null <- base::is.null
[13:36:59.540]                     muffled <- FALSE
[13:36:59.540]                     if (inherits(cond, "message")) {
[13:36:59.540]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.540]                       if (muffled) 
[13:36:59.540]                         invokeRestart("muffleMessage")
[13:36:59.540]                     }
[13:36:59.540]                     else if (inherits(cond, "warning")) {
[13:36:59.540]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.540]                       if (muffled) 
[13:36:59.540]                         invokeRestart("muffleWarning")
[13:36:59.540]                     }
[13:36:59.540]                     else if (inherits(cond, "condition")) {
[13:36:59.540]                       if (!is.null(pattern)) {
[13:36:59.540]                         computeRestarts <- base::computeRestarts
[13:36:59.540]                         grepl <- base::grepl
[13:36:59.540]                         restarts <- computeRestarts(cond)
[13:36:59.540]                         for (restart in restarts) {
[13:36:59.540]                           name <- restart$name
[13:36:59.540]                           if (is.null(name)) 
[13:36:59.540]                             next
[13:36:59.540]                           if (!grepl(pattern, name)) 
[13:36:59.540]                             next
[13:36:59.540]                           invokeRestart(restart)
[13:36:59.540]                           muffled <- TRUE
[13:36:59.540]                           break
[13:36:59.540]                         }
[13:36:59.540]                       }
[13:36:59.540]                     }
[13:36:59.540]                     invisible(muffled)
[13:36:59.540]                   }
[13:36:59.540]                   muffleCondition(cond)
[13:36:59.540]                 })
[13:36:59.540]             }))
[13:36:59.540]             future::FutureResult(value = ...future.value$value, 
[13:36:59.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.540]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.540]                     ...future.globalenv.names))
[13:36:59.540]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.540]         }, condition = base::local({
[13:36:59.540]             c <- base::c
[13:36:59.540]             inherits <- base::inherits
[13:36:59.540]             invokeRestart <- base::invokeRestart
[13:36:59.540]             length <- base::length
[13:36:59.540]             list <- base::list
[13:36:59.540]             seq.int <- base::seq.int
[13:36:59.540]             signalCondition <- base::signalCondition
[13:36:59.540]             sys.calls <- base::sys.calls
[13:36:59.540]             `[[` <- base::`[[`
[13:36:59.540]             `+` <- base::`+`
[13:36:59.540]             `<<-` <- base::`<<-`
[13:36:59.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.540]                   3L)]
[13:36:59.540]             }
[13:36:59.540]             function(cond) {
[13:36:59.540]                 is_error <- inherits(cond, "error")
[13:36:59.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.540]                   NULL)
[13:36:59.540]                 if (is_error) {
[13:36:59.540]                   sessionInformation <- function() {
[13:36:59.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.540]                       search = base::search(), system = base::Sys.info())
[13:36:59.540]                   }
[13:36:59.540]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.540]                     cond$call), session = sessionInformation(), 
[13:36:59.540]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.540]                   signalCondition(cond)
[13:36:59.540]                 }
[13:36:59.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.540]                 "immediateCondition"))) {
[13:36:59.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.540]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.540]                   if (TRUE && !signal) {
[13:36:59.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.540]                     {
[13:36:59.540]                       inherits <- base::inherits
[13:36:59.540]                       invokeRestart <- base::invokeRestart
[13:36:59.540]                       is.null <- base::is.null
[13:36:59.540]                       muffled <- FALSE
[13:36:59.540]                       if (inherits(cond, "message")) {
[13:36:59.540]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.540]                         if (muffled) 
[13:36:59.540]                           invokeRestart("muffleMessage")
[13:36:59.540]                       }
[13:36:59.540]                       else if (inherits(cond, "warning")) {
[13:36:59.540]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.540]                         if (muffled) 
[13:36:59.540]                           invokeRestart("muffleWarning")
[13:36:59.540]                       }
[13:36:59.540]                       else if (inherits(cond, "condition")) {
[13:36:59.540]                         if (!is.null(pattern)) {
[13:36:59.540]                           computeRestarts <- base::computeRestarts
[13:36:59.540]                           grepl <- base::grepl
[13:36:59.540]                           restarts <- computeRestarts(cond)
[13:36:59.540]                           for (restart in restarts) {
[13:36:59.540]                             name <- restart$name
[13:36:59.540]                             if (is.null(name)) 
[13:36:59.540]                               next
[13:36:59.540]                             if (!grepl(pattern, name)) 
[13:36:59.540]                               next
[13:36:59.540]                             invokeRestart(restart)
[13:36:59.540]                             muffled <- TRUE
[13:36:59.540]                             break
[13:36:59.540]                           }
[13:36:59.540]                         }
[13:36:59.540]                       }
[13:36:59.540]                       invisible(muffled)
[13:36:59.540]                     }
[13:36:59.540]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.540]                   }
[13:36:59.540]                 }
[13:36:59.540]                 else {
[13:36:59.540]                   if (TRUE) {
[13:36:59.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.540]                     {
[13:36:59.540]                       inherits <- base::inherits
[13:36:59.540]                       invokeRestart <- base::invokeRestart
[13:36:59.540]                       is.null <- base::is.null
[13:36:59.540]                       muffled <- FALSE
[13:36:59.540]                       if (inherits(cond, "message")) {
[13:36:59.540]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.540]                         if (muffled) 
[13:36:59.540]                           invokeRestart("muffleMessage")
[13:36:59.540]                       }
[13:36:59.540]                       else if (inherits(cond, "warning")) {
[13:36:59.540]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.540]                         if (muffled) 
[13:36:59.540]                           invokeRestart("muffleWarning")
[13:36:59.540]                       }
[13:36:59.540]                       else if (inherits(cond, "condition")) {
[13:36:59.540]                         if (!is.null(pattern)) {
[13:36:59.540]                           computeRestarts <- base::computeRestarts
[13:36:59.540]                           grepl <- base::grepl
[13:36:59.540]                           restarts <- computeRestarts(cond)
[13:36:59.540]                           for (restart in restarts) {
[13:36:59.540]                             name <- restart$name
[13:36:59.540]                             if (is.null(name)) 
[13:36:59.540]                               next
[13:36:59.540]                             if (!grepl(pattern, name)) 
[13:36:59.540]                               next
[13:36:59.540]                             invokeRestart(restart)
[13:36:59.540]                             muffled <- TRUE
[13:36:59.540]                             break
[13:36:59.540]                           }
[13:36:59.540]                         }
[13:36:59.540]                       }
[13:36:59.540]                       invisible(muffled)
[13:36:59.540]                     }
[13:36:59.540]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.540]                   }
[13:36:59.540]                 }
[13:36:59.540]             }
[13:36:59.540]         }))
[13:36:59.540]     }, error = function(ex) {
[13:36:59.540]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.540]                 ...future.rng), started = ...future.startTime, 
[13:36:59.540]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.540]             version = "1.8"), class = "FutureResult")
[13:36:59.540]     }, finally = {
[13:36:59.540]         if (!identical(...future.workdir, getwd())) 
[13:36:59.540]             setwd(...future.workdir)
[13:36:59.540]         {
[13:36:59.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.540]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.540]             }
[13:36:59.540]             base::options(...future.oldOptions)
[13:36:59.540]             if (.Platform$OS.type == "windows") {
[13:36:59.540]                 old_names <- names(...future.oldEnvVars)
[13:36:59.540]                 envs <- base::Sys.getenv()
[13:36:59.540]                 names <- names(envs)
[13:36:59.540]                 common <- intersect(names, old_names)
[13:36:59.540]                 added <- setdiff(names, old_names)
[13:36:59.540]                 removed <- setdiff(old_names, names)
[13:36:59.540]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.540]                   envs[common]]
[13:36:59.540]                 NAMES <- toupper(changed)
[13:36:59.540]                 args <- list()
[13:36:59.540]                 for (kk in seq_along(NAMES)) {
[13:36:59.540]                   name <- changed[[kk]]
[13:36:59.540]                   NAME <- NAMES[[kk]]
[13:36:59.540]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.540]                     next
[13:36:59.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.540]                 }
[13:36:59.540]                 NAMES <- toupper(added)
[13:36:59.540]                 for (kk in seq_along(NAMES)) {
[13:36:59.540]                   name <- added[[kk]]
[13:36:59.540]                   NAME <- NAMES[[kk]]
[13:36:59.540]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.540]                     next
[13:36:59.540]                   args[[name]] <- ""
[13:36:59.540]                 }
[13:36:59.540]                 NAMES <- toupper(removed)
[13:36:59.540]                 for (kk in seq_along(NAMES)) {
[13:36:59.540]                   name <- removed[[kk]]
[13:36:59.540]                   NAME <- NAMES[[kk]]
[13:36:59.540]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.540]                     next
[13:36:59.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.540]                 }
[13:36:59.540]                 if (length(args) > 0) 
[13:36:59.540]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.540]             }
[13:36:59.540]             else {
[13:36:59.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.540]             }
[13:36:59.540]             {
[13:36:59.540]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.540]                   0L) {
[13:36:59.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.540]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.540]                   base::options(opts)
[13:36:59.540]                 }
[13:36:59.540]                 {
[13:36:59.540]                   {
[13:36:59.540]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.540]                     NULL
[13:36:59.540]                   }
[13:36:59.540]                   options(future.plan = NULL)
[13:36:59.540]                   if (is.na(NA_character_)) 
[13:36:59.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.540]                     .init = FALSE)
[13:36:59.540]                 }
[13:36:59.540]             }
[13:36:59.540]         }
[13:36:59.540]     })
[13:36:59.540]     if (TRUE) {
[13:36:59.540]         base::sink(type = "output", split = FALSE)
[13:36:59.540]         if (TRUE) {
[13:36:59.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.540]         }
[13:36:59.540]         else {
[13:36:59.540]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.540]         }
[13:36:59.540]         base::close(...future.stdout)
[13:36:59.540]         ...future.stdout <- NULL
[13:36:59.540]     }
[13:36:59.540]     ...future.result$conditions <- ...future.conditions
[13:36:59.540]     ...future.result$finished <- base::Sys.time()
[13:36:59.540]     ...future.result
[13:36:59.540] }
[13:36:59.542] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:59.553] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.553] - Validating connection of MultisessionFuture
[13:36:59.554] - received message: FutureResult
[13:36:59.554] - Received FutureResult
[13:36:59.554] - Erased future from FutureRegistry
[13:36:59.554] result() for ClusterFuture ...
[13:36:59.554] - result already collected: FutureResult
[13:36:59.554] result() for ClusterFuture ... done
[13:36:59.554] signalConditions() ...
[13:36:59.554]  - include = ‘immediateCondition’
[13:36:59.554]  - exclude = 
[13:36:59.554]  - resignal = FALSE
[13:36:59.555]  - Number of conditions: 1
[13:36:59.555] signalConditions() ... done
[13:36:59.555] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.555] result() for ClusterFuture ...
[13:36:59.555] - result already collected: FutureResult
[13:36:59.555] result() for ClusterFuture ... done
[13:36:59.555] result() for ClusterFuture ...
[13:36:59.555] - result already collected: FutureResult
[13:36:59.555] result() for ClusterFuture ... done
[13:36:59.555] signalConditions() ...
[13:36:59.555]  - include = ‘immediateCondition’
[13:36:59.556]  - exclude = 
[13:36:59.556]  - resignal = FALSE
[13:36:59.556]  - Number of conditions: 1
[13:36:59.556] signalConditions() ... done
[13:36:59.556] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:36:59.557] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:36:59.557] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:36:59.557] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:36:59.557] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:36:59.558] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:36:59.558] MultisessionFuture started
[13:36:59.558] - Launch lazy future ... done
[13:36:59.558] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.559] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.559] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.562] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.562] Searching for globals ... DONE
[13:36:59.562] Resolving globals: TRUE
[13:36:59.562] Resolving any globals that are futures ...
[13:36:59.562] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.562] Resolving any globals that are futures ... DONE
[13:36:59.562] Resolving futures part of globals (recursively) ...
[13:36:59.563] resolve() on list ...
[13:36:59.563]  recursive: 99
[13:36:59.563]  length: 2
[13:36:59.563]  elements: ‘a’, ‘ii’
[13:36:59.563]  length: 1 (resolved future 1)
[13:36:59.563]  length: 0 (resolved future 2)
[13:36:59.563] resolve() on list ... DONE
[13:36:59.563] - globals: [2] ‘a’, ‘ii’
[13:36:59.563] Resolving futures part of globals (recursively) ... DONE
[13:36:59.564] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:59.564] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:59.564] - globals: [2] ‘a’, ‘ii’
[13:36:59.564] 
[13:36:59.564] getGlobalsAndPackages() ... DONE
[13:36:59.565] run() for ‘Future’ ...
[13:36:59.565] - state: ‘created’
[13:36:59.565] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.578] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.578]   - Field: ‘node’
[13:36:59.579]   - Field: ‘label’
[13:36:59.579]   - Field: ‘local’
[13:36:59.579]   - Field: ‘owner’
[13:36:59.579]   - Field: ‘envir’
[13:36:59.579]   - Field: ‘workers’
[13:36:59.579]   - Field: ‘packages’
[13:36:59.579]   - Field: ‘gc’
[13:36:59.579]   - Field: ‘conditions’
[13:36:59.579]   - Field: ‘persistent’
[13:36:59.579]   - Field: ‘expr’
[13:36:59.579]   - Field: ‘uuid’
[13:36:59.580]   - Field: ‘seed’
[13:36:59.580]   - Field: ‘version’
[13:36:59.580]   - Field: ‘result’
[13:36:59.580]   - Field: ‘asynchronous’
[13:36:59.580]   - Field: ‘calls’
[13:36:59.580]   - Field: ‘globals’
[13:36:59.580]   - Field: ‘stdout’
[13:36:59.580]   - Field: ‘earlySignal’
[13:36:59.580]   - Field: ‘lazy’
[13:36:59.580]   - Field: ‘state’
[13:36:59.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.581] - Launch lazy future ...
[13:36:59.581] Packages needed by the future expression (n = 0): <none>
[13:36:59.581] Packages needed by future strategies (n = 0): <none>
[13:36:59.581] {
[13:36:59.581]     {
[13:36:59.581]         {
[13:36:59.581]             ...future.startTime <- base::Sys.time()
[13:36:59.581]             {
[13:36:59.581]                 {
[13:36:59.581]                   {
[13:36:59.581]                     {
[13:36:59.581]                       base::local({
[13:36:59.581]                         has_future <- base::requireNamespace("future", 
[13:36:59.581]                           quietly = TRUE)
[13:36:59.581]                         if (has_future) {
[13:36:59.581]                           ns <- base::getNamespace("future")
[13:36:59.581]                           version <- ns[[".package"]][["version"]]
[13:36:59.581]                           if (is.null(version)) 
[13:36:59.581]                             version <- utils::packageVersion("future")
[13:36:59.581]                         }
[13:36:59.581]                         else {
[13:36:59.581]                           version <- NULL
[13:36:59.581]                         }
[13:36:59.581]                         if (!has_future || version < "1.8.0") {
[13:36:59.581]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.581]                             "", base::R.version$version.string), 
[13:36:59.581]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.581]                               "release", "version")], collapse = " "), 
[13:36:59.581]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.581]                             info)
[13:36:59.581]                           info <- base::paste(info, collapse = "; ")
[13:36:59.581]                           if (!has_future) {
[13:36:59.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.581]                               info)
[13:36:59.581]                           }
[13:36:59.581]                           else {
[13:36:59.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.581]                               info, version)
[13:36:59.581]                           }
[13:36:59.581]                           base::stop(msg)
[13:36:59.581]                         }
[13:36:59.581]                       })
[13:36:59.581]                     }
[13:36:59.581]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.581]                     base::options(mc.cores = 1L)
[13:36:59.581]                   }
[13:36:59.581]                   ...future.strategy.old <- future::plan("list")
[13:36:59.581]                   options(future.plan = NULL)
[13:36:59.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.581]                 }
[13:36:59.581]                 ...future.workdir <- getwd()
[13:36:59.581]             }
[13:36:59.581]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.581]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.581]         }
[13:36:59.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.581]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.581]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.581]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.581]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.581]             base::names(...future.oldOptions))
[13:36:59.581]     }
[13:36:59.581]     if (FALSE) {
[13:36:59.581]     }
[13:36:59.581]     else {
[13:36:59.581]         if (TRUE) {
[13:36:59.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.581]                 open = "w")
[13:36:59.581]         }
[13:36:59.581]         else {
[13:36:59.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.581]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.581]         }
[13:36:59.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.581]             base::sink(type = "output", split = FALSE)
[13:36:59.581]             base::close(...future.stdout)
[13:36:59.581]         }, add = TRUE)
[13:36:59.581]     }
[13:36:59.581]     ...future.frame <- base::sys.nframe()
[13:36:59.581]     ...future.conditions <- base::list()
[13:36:59.581]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.581]     if (FALSE) {
[13:36:59.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.581]     }
[13:36:59.581]     ...future.result <- base::tryCatch({
[13:36:59.581]         base::withCallingHandlers({
[13:36:59.581]             ...future.value <- base::withVisible(base::local({
[13:36:59.581]                 ...future.makeSendCondition <- base::local({
[13:36:59.581]                   sendCondition <- NULL
[13:36:59.581]                   function(frame = 1L) {
[13:36:59.581]                     if (is.function(sendCondition)) 
[13:36:59.581]                       return(sendCondition)
[13:36:59.581]                     ns <- getNamespace("parallel")
[13:36:59.581]                     if (exists("sendData", mode = "function", 
[13:36:59.581]                       envir = ns)) {
[13:36:59.581]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.581]                         envir = ns)
[13:36:59.581]                       envir <- sys.frame(frame)
[13:36:59.581]                       master <- NULL
[13:36:59.581]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.581]                         !identical(envir, emptyenv())) {
[13:36:59.581]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.581]                           inherits = FALSE)) {
[13:36:59.581]                           master <- get("master", mode = "list", 
[13:36:59.581]                             envir = envir, inherits = FALSE)
[13:36:59.581]                           if (inherits(master, c("SOCKnode", 
[13:36:59.581]                             "SOCK0node"))) {
[13:36:59.581]                             sendCondition <<- function(cond) {
[13:36:59.581]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.581]                                 success = TRUE)
[13:36:59.581]                               parallel_sendData(master, data)
[13:36:59.581]                             }
[13:36:59.581]                             return(sendCondition)
[13:36:59.581]                           }
[13:36:59.581]                         }
[13:36:59.581]                         frame <- frame + 1L
[13:36:59.581]                         envir <- sys.frame(frame)
[13:36:59.581]                       }
[13:36:59.581]                     }
[13:36:59.581]                     sendCondition <<- function(cond) NULL
[13:36:59.581]                   }
[13:36:59.581]                 })
[13:36:59.581]                 withCallingHandlers({
[13:36:59.581]                   {
[13:36:59.581]                     b <- a * ii
[13:36:59.581]                     a <- 0
[13:36:59.581]                     b
[13:36:59.581]                   }
[13:36:59.581]                 }, immediateCondition = function(cond) {
[13:36:59.581]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.581]                   sendCondition(cond)
[13:36:59.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.581]                   {
[13:36:59.581]                     inherits <- base::inherits
[13:36:59.581]                     invokeRestart <- base::invokeRestart
[13:36:59.581]                     is.null <- base::is.null
[13:36:59.581]                     muffled <- FALSE
[13:36:59.581]                     if (inherits(cond, "message")) {
[13:36:59.581]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.581]                       if (muffled) 
[13:36:59.581]                         invokeRestart("muffleMessage")
[13:36:59.581]                     }
[13:36:59.581]                     else if (inherits(cond, "warning")) {
[13:36:59.581]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.581]                       if (muffled) 
[13:36:59.581]                         invokeRestart("muffleWarning")
[13:36:59.581]                     }
[13:36:59.581]                     else if (inherits(cond, "condition")) {
[13:36:59.581]                       if (!is.null(pattern)) {
[13:36:59.581]                         computeRestarts <- base::computeRestarts
[13:36:59.581]                         grepl <- base::grepl
[13:36:59.581]                         restarts <- computeRestarts(cond)
[13:36:59.581]                         for (restart in restarts) {
[13:36:59.581]                           name <- restart$name
[13:36:59.581]                           if (is.null(name)) 
[13:36:59.581]                             next
[13:36:59.581]                           if (!grepl(pattern, name)) 
[13:36:59.581]                             next
[13:36:59.581]                           invokeRestart(restart)
[13:36:59.581]                           muffled <- TRUE
[13:36:59.581]                           break
[13:36:59.581]                         }
[13:36:59.581]                       }
[13:36:59.581]                     }
[13:36:59.581]                     invisible(muffled)
[13:36:59.581]                   }
[13:36:59.581]                   muffleCondition(cond)
[13:36:59.581]                 })
[13:36:59.581]             }))
[13:36:59.581]             future::FutureResult(value = ...future.value$value, 
[13:36:59.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.581]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.581]                     ...future.globalenv.names))
[13:36:59.581]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.581]         }, condition = base::local({
[13:36:59.581]             c <- base::c
[13:36:59.581]             inherits <- base::inherits
[13:36:59.581]             invokeRestart <- base::invokeRestart
[13:36:59.581]             length <- base::length
[13:36:59.581]             list <- base::list
[13:36:59.581]             seq.int <- base::seq.int
[13:36:59.581]             signalCondition <- base::signalCondition
[13:36:59.581]             sys.calls <- base::sys.calls
[13:36:59.581]             `[[` <- base::`[[`
[13:36:59.581]             `+` <- base::`+`
[13:36:59.581]             `<<-` <- base::`<<-`
[13:36:59.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.581]                   3L)]
[13:36:59.581]             }
[13:36:59.581]             function(cond) {
[13:36:59.581]                 is_error <- inherits(cond, "error")
[13:36:59.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.581]                   NULL)
[13:36:59.581]                 if (is_error) {
[13:36:59.581]                   sessionInformation <- function() {
[13:36:59.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.581]                       search = base::search(), system = base::Sys.info())
[13:36:59.581]                   }
[13:36:59.581]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.581]                     cond$call), session = sessionInformation(), 
[13:36:59.581]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.581]                   signalCondition(cond)
[13:36:59.581]                 }
[13:36:59.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.581]                 "immediateCondition"))) {
[13:36:59.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.581]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.581]                   if (TRUE && !signal) {
[13:36:59.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.581]                     {
[13:36:59.581]                       inherits <- base::inherits
[13:36:59.581]                       invokeRestart <- base::invokeRestart
[13:36:59.581]                       is.null <- base::is.null
[13:36:59.581]                       muffled <- FALSE
[13:36:59.581]                       if (inherits(cond, "message")) {
[13:36:59.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.581]                         if (muffled) 
[13:36:59.581]                           invokeRestart("muffleMessage")
[13:36:59.581]                       }
[13:36:59.581]                       else if (inherits(cond, "warning")) {
[13:36:59.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.581]                         if (muffled) 
[13:36:59.581]                           invokeRestart("muffleWarning")
[13:36:59.581]                       }
[13:36:59.581]                       else if (inherits(cond, "condition")) {
[13:36:59.581]                         if (!is.null(pattern)) {
[13:36:59.581]                           computeRestarts <- base::computeRestarts
[13:36:59.581]                           grepl <- base::grepl
[13:36:59.581]                           restarts <- computeRestarts(cond)
[13:36:59.581]                           for (restart in restarts) {
[13:36:59.581]                             name <- restart$name
[13:36:59.581]                             if (is.null(name)) 
[13:36:59.581]                               next
[13:36:59.581]                             if (!grepl(pattern, name)) 
[13:36:59.581]                               next
[13:36:59.581]                             invokeRestart(restart)
[13:36:59.581]                             muffled <- TRUE
[13:36:59.581]                             break
[13:36:59.581]                           }
[13:36:59.581]                         }
[13:36:59.581]                       }
[13:36:59.581]                       invisible(muffled)
[13:36:59.581]                     }
[13:36:59.581]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.581]                   }
[13:36:59.581]                 }
[13:36:59.581]                 else {
[13:36:59.581]                   if (TRUE) {
[13:36:59.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.581]                     {
[13:36:59.581]                       inherits <- base::inherits
[13:36:59.581]                       invokeRestart <- base::invokeRestart
[13:36:59.581]                       is.null <- base::is.null
[13:36:59.581]                       muffled <- FALSE
[13:36:59.581]                       if (inherits(cond, "message")) {
[13:36:59.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.581]                         if (muffled) 
[13:36:59.581]                           invokeRestart("muffleMessage")
[13:36:59.581]                       }
[13:36:59.581]                       else if (inherits(cond, "warning")) {
[13:36:59.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.581]                         if (muffled) 
[13:36:59.581]                           invokeRestart("muffleWarning")
[13:36:59.581]                       }
[13:36:59.581]                       else if (inherits(cond, "condition")) {
[13:36:59.581]                         if (!is.null(pattern)) {
[13:36:59.581]                           computeRestarts <- base::computeRestarts
[13:36:59.581]                           grepl <- base::grepl
[13:36:59.581]                           restarts <- computeRestarts(cond)
[13:36:59.581]                           for (restart in restarts) {
[13:36:59.581]                             name <- restart$name
[13:36:59.581]                             if (is.null(name)) 
[13:36:59.581]                               next
[13:36:59.581]                             if (!grepl(pattern, name)) 
[13:36:59.581]                               next
[13:36:59.581]                             invokeRestart(restart)
[13:36:59.581]                             muffled <- TRUE
[13:36:59.581]                             break
[13:36:59.581]                           }
[13:36:59.581]                         }
[13:36:59.581]                       }
[13:36:59.581]                       invisible(muffled)
[13:36:59.581]                     }
[13:36:59.581]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.581]                   }
[13:36:59.581]                 }
[13:36:59.581]             }
[13:36:59.581]         }))
[13:36:59.581]     }, error = function(ex) {
[13:36:59.581]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.581]                 ...future.rng), started = ...future.startTime, 
[13:36:59.581]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.581]             version = "1.8"), class = "FutureResult")
[13:36:59.581]     }, finally = {
[13:36:59.581]         if (!identical(...future.workdir, getwd())) 
[13:36:59.581]             setwd(...future.workdir)
[13:36:59.581]         {
[13:36:59.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.581]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.581]             }
[13:36:59.581]             base::options(...future.oldOptions)
[13:36:59.581]             if (.Platform$OS.type == "windows") {
[13:36:59.581]                 old_names <- names(...future.oldEnvVars)
[13:36:59.581]                 envs <- base::Sys.getenv()
[13:36:59.581]                 names <- names(envs)
[13:36:59.581]                 common <- intersect(names, old_names)
[13:36:59.581]                 added <- setdiff(names, old_names)
[13:36:59.581]                 removed <- setdiff(old_names, names)
[13:36:59.581]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.581]                   envs[common]]
[13:36:59.581]                 NAMES <- toupper(changed)
[13:36:59.581]                 args <- list()
[13:36:59.581]                 for (kk in seq_along(NAMES)) {
[13:36:59.581]                   name <- changed[[kk]]
[13:36:59.581]                   NAME <- NAMES[[kk]]
[13:36:59.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.581]                     next
[13:36:59.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.581]                 }
[13:36:59.581]                 NAMES <- toupper(added)
[13:36:59.581]                 for (kk in seq_along(NAMES)) {
[13:36:59.581]                   name <- added[[kk]]
[13:36:59.581]                   NAME <- NAMES[[kk]]
[13:36:59.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.581]                     next
[13:36:59.581]                   args[[name]] <- ""
[13:36:59.581]                 }
[13:36:59.581]                 NAMES <- toupper(removed)
[13:36:59.581]                 for (kk in seq_along(NAMES)) {
[13:36:59.581]                   name <- removed[[kk]]
[13:36:59.581]                   NAME <- NAMES[[kk]]
[13:36:59.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.581]                     next
[13:36:59.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.581]                 }
[13:36:59.581]                 if (length(args) > 0) 
[13:36:59.581]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.581]             }
[13:36:59.581]             else {
[13:36:59.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.581]             }
[13:36:59.581]             {
[13:36:59.581]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.581]                   0L) {
[13:36:59.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.581]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.581]                   base::options(opts)
[13:36:59.581]                 }
[13:36:59.581]                 {
[13:36:59.581]                   {
[13:36:59.581]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.581]                     NULL
[13:36:59.581]                   }
[13:36:59.581]                   options(future.plan = NULL)
[13:36:59.581]                   if (is.na(NA_character_)) 
[13:36:59.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.581]                     .init = FALSE)
[13:36:59.581]                 }
[13:36:59.581]             }
[13:36:59.581]         }
[13:36:59.581]     })
[13:36:59.581]     if (TRUE) {
[13:36:59.581]         base::sink(type = "output", split = FALSE)
[13:36:59.581]         if (TRUE) {
[13:36:59.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.581]         }
[13:36:59.581]         else {
[13:36:59.581]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.581]         }
[13:36:59.581]         base::close(...future.stdout)
[13:36:59.581]         ...future.stdout <- NULL
[13:36:59.581]     }
[13:36:59.581]     ...future.result$conditions <- ...future.conditions
[13:36:59.581]     ...future.result$finished <- base::Sys.time()
[13:36:59.581]     ...future.result
[13:36:59.581] }
[13:36:59.583] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:59.594] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.594] - Validating connection of MultisessionFuture
[13:36:59.594] - received message: FutureResult
[13:36:59.595] - Received FutureResult
[13:36:59.595] - Erased future from FutureRegistry
[13:36:59.595] result() for ClusterFuture ...
[13:36:59.595] - result already collected: FutureResult
[13:36:59.595] result() for ClusterFuture ... done
[13:36:59.595] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.595] result() for ClusterFuture ...
[13:36:59.595] - result already collected: FutureResult
[13:36:59.595] result() for ClusterFuture ... done
[13:36:59.595] result() for ClusterFuture ...
[13:36:59.595] - result already collected: FutureResult
[13:36:59.596] result() for ClusterFuture ... done
[13:36:59.596] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[13:36:59.596] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:36:59.597] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:36:59.597] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:36:59.597] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:36:59.597] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[13:36:59.598] MultisessionFuture started
[13:36:59.598] - Launch lazy future ... done
[13:36:59.598] run() for ‘MultisessionFuture’ ... done
[13:36:59.598] result() for ClusterFuture ...
[13:36:59.598] - result already collected: FutureResult
[13:36:59.598] result() for ClusterFuture ... done
[13:36:59.599] result() for ClusterFuture ...
[13:36:59.599] - result already collected: FutureResult
[13:36:59.599] result() for ClusterFuture ... done
[13:36:59.599] result() for ClusterFuture ...
[13:36:59.599] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.599] - Validating connection of MultisessionFuture
[13:36:59.599] - received message: FutureResult
[13:36:59.599] - Received FutureResult
[13:36:59.599] - Erased future from FutureRegistry
[13:36:59.599] result() for ClusterFuture ...
[13:36:59.600] - result already collected: FutureResult
[13:36:59.600] result() for ClusterFuture ... done
[13:36:59.600] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.600] result() for ClusterFuture ... done
[13:36:59.600] result() for ClusterFuture ...
[13:36:59.600] - result already collected: FutureResult
[13:36:59.600] result() for ClusterFuture ... done
[13:36:59.600] result() for ClusterFuture ...
[13:36:59.600] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.600] - Validating connection of MultisessionFuture
[13:36:59.640] - received message: FutureResult
[13:36:59.640] - Received FutureResult
[13:36:59.640] - Erased future from FutureRegistry
[13:36:59.640] result() for ClusterFuture ...
[13:36:59.640] - result already collected: FutureResult
[13:36:59.641] result() for ClusterFuture ... done
[13:36:59.641] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.641] result() for ClusterFuture ... done
[13:36:59.641] result() for ClusterFuture ...
[13:36:59.641] - result already collected: FutureResult
[13:36:59.641] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.642] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.642] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.643] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.644] Searching for globals ... DONE
[13:36:59.644] Resolving globals: TRUE
[13:36:59.644] Resolving any globals that are futures ...
[13:36:59.644] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.644] Resolving any globals that are futures ... DONE
[13:36:59.644] Resolving futures part of globals (recursively) ...
[13:36:59.645] resolve() on list ...
[13:36:59.645]  recursive: 99
[13:36:59.645]  length: 2
[13:36:59.645]  elements: ‘a’, ‘ii’
[13:36:59.645]  length: 1 (resolved future 1)
[13:36:59.645]  length: 0 (resolved future 2)
[13:36:59.645] resolve() on list ... DONE
[13:36:59.645] - globals: [2] ‘a’, ‘ii’
[13:36:59.645] Resolving futures part of globals (recursively) ... DONE
[13:36:59.646] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:59.646] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:59.646] - globals: [2] ‘a’, ‘ii’
[13:36:59.646] 
[13:36:59.646] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.647] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.647] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.649] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.649] Searching for globals ... DONE
[13:36:59.649] Resolving globals: TRUE
[13:36:59.649] Resolving any globals that are futures ...
[13:36:59.649] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.649] Resolving any globals that are futures ... DONE
[13:36:59.650] Resolving futures part of globals (recursively) ...
[13:36:59.650] resolve() on list ...
[13:36:59.650]  recursive: 99
[13:36:59.650]  length: 2
[13:36:59.650]  elements: ‘a’, ‘ii’
[13:36:59.650]  length: 1 (resolved future 1)
[13:36:59.650]  length: 0 (resolved future 2)
[13:36:59.650] resolve() on list ... DONE
[13:36:59.650] - globals: [2] ‘a’, ‘ii’
[13:36:59.651] Resolving futures part of globals (recursively) ... DONE
[13:36:59.651] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:59.651] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:59.651] - globals: [2] ‘a’, ‘ii’
[13:36:59.651] 
[13:36:59.651] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.652] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.652] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.654] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.654] Searching for globals ... DONE
[13:36:59.654] Resolving globals: TRUE
[13:36:59.654] Resolving any globals that are futures ...
[13:36:59.654] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:36:59.654] Resolving any globals that are futures ... DONE
[13:36:59.655] Resolving futures part of globals (recursively) ...
[13:36:59.655] resolve() on list ...
[13:36:59.655]  recursive: 99
[13:36:59.655]  length: 2
[13:36:59.655]  elements: ‘a’, ‘ii’
[13:36:59.655]  length: 1 (resolved future 1)
[13:36:59.655]  length: 0 (resolved future 2)
[13:36:59.655] resolve() on list ... DONE
[13:36:59.655] - globals: [2] ‘a’, ‘ii’
[13:36:59.656] Resolving futures part of globals (recursively) ... DONE
[13:36:59.656] The total size of the 2 globals is 112 bytes (112 bytes)
[13:36:59.656] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:36:59.656] - globals: [2] ‘a’, ‘ii’
[13:36:59.656] 
[13:36:59.656] getGlobalsAndPackages() ... DONE
[13:36:59.657] run() for ‘Future’ ...
[13:36:59.657] - state: ‘created’
[13:36:59.657] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.671] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.671]   - Field: ‘node’
[13:36:59.671]   - Field: ‘label’
[13:36:59.671]   - Field: ‘local’
[13:36:59.671]   - Field: ‘owner’
[13:36:59.671]   - Field: ‘envir’
[13:36:59.671]   - Field: ‘workers’
[13:36:59.671]   - Field: ‘packages’
[13:36:59.671]   - Field: ‘gc’
[13:36:59.672]   - Field: ‘conditions’
[13:36:59.672]   - Field: ‘persistent’
[13:36:59.672]   - Field: ‘expr’
[13:36:59.672]   - Field: ‘uuid’
[13:36:59.672]   - Field: ‘seed’
[13:36:59.672]   - Field: ‘version’
[13:36:59.672]   - Field: ‘result’
[13:36:59.672]   - Field: ‘asynchronous’
[13:36:59.672]   - Field: ‘calls’
[13:36:59.672]   - Field: ‘globals’
[13:36:59.672]   - Field: ‘stdout’
[13:36:59.673]   - Field: ‘earlySignal’
[13:36:59.673]   - Field: ‘lazy’
[13:36:59.673]   - Field: ‘state’
[13:36:59.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.673] - Launch lazy future ...
[13:36:59.673] Packages needed by the future expression (n = 0): <none>
[13:36:59.673] Packages needed by future strategies (n = 0): <none>
[13:36:59.674] {
[13:36:59.674]     {
[13:36:59.674]         {
[13:36:59.674]             ...future.startTime <- base::Sys.time()
[13:36:59.674]             {
[13:36:59.674]                 {
[13:36:59.674]                   {
[13:36:59.674]                     {
[13:36:59.674]                       base::local({
[13:36:59.674]                         has_future <- base::requireNamespace("future", 
[13:36:59.674]                           quietly = TRUE)
[13:36:59.674]                         if (has_future) {
[13:36:59.674]                           ns <- base::getNamespace("future")
[13:36:59.674]                           version <- ns[[".package"]][["version"]]
[13:36:59.674]                           if (is.null(version)) 
[13:36:59.674]                             version <- utils::packageVersion("future")
[13:36:59.674]                         }
[13:36:59.674]                         else {
[13:36:59.674]                           version <- NULL
[13:36:59.674]                         }
[13:36:59.674]                         if (!has_future || version < "1.8.0") {
[13:36:59.674]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.674]                             "", base::R.version$version.string), 
[13:36:59.674]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.674]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.674]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.674]                               "release", "version")], collapse = " "), 
[13:36:59.674]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.674]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.674]                             info)
[13:36:59.674]                           info <- base::paste(info, collapse = "; ")
[13:36:59.674]                           if (!has_future) {
[13:36:59.674]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.674]                               info)
[13:36:59.674]                           }
[13:36:59.674]                           else {
[13:36:59.674]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.674]                               info, version)
[13:36:59.674]                           }
[13:36:59.674]                           base::stop(msg)
[13:36:59.674]                         }
[13:36:59.674]                       })
[13:36:59.674]                     }
[13:36:59.674]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.674]                     base::options(mc.cores = 1L)
[13:36:59.674]                   }
[13:36:59.674]                   ...future.strategy.old <- future::plan("list")
[13:36:59.674]                   options(future.plan = NULL)
[13:36:59.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.674]                 }
[13:36:59.674]                 ...future.workdir <- getwd()
[13:36:59.674]             }
[13:36:59.674]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.674]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.674]         }
[13:36:59.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.674]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.674]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.674]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.674]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.674]             base::names(...future.oldOptions))
[13:36:59.674]     }
[13:36:59.674]     if (FALSE) {
[13:36:59.674]     }
[13:36:59.674]     else {
[13:36:59.674]         if (TRUE) {
[13:36:59.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.674]                 open = "w")
[13:36:59.674]         }
[13:36:59.674]         else {
[13:36:59.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.674]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.674]         }
[13:36:59.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.674]             base::sink(type = "output", split = FALSE)
[13:36:59.674]             base::close(...future.stdout)
[13:36:59.674]         }, add = TRUE)
[13:36:59.674]     }
[13:36:59.674]     ...future.frame <- base::sys.nframe()
[13:36:59.674]     ...future.conditions <- base::list()
[13:36:59.674]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.674]     if (FALSE) {
[13:36:59.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.674]     }
[13:36:59.674]     ...future.result <- base::tryCatch({
[13:36:59.674]         base::withCallingHandlers({
[13:36:59.674]             ...future.value <- base::withVisible(base::local({
[13:36:59.674]                 ...future.makeSendCondition <- base::local({
[13:36:59.674]                   sendCondition <- NULL
[13:36:59.674]                   function(frame = 1L) {
[13:36:59.674]                     if (is.function(sendCondition)) 
[13:36:59.674]                       return(sendCondition)
[13:36:59.674]                     ns <- getNamespace("parallel")
[13:36:59.674]                     if (exists("sendData", mode = "function", 
[13:36:59.674]                       envir = ns)) {
[13:36:59.674]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.674]                         envir = ns)
[13:36:59.674]                       envir <- sys.frame(frame)
[13:36:59.674]                       master <- NULL
[13:36:59.674]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.674]                         !identical(envir, emptyenv())) {
[13:36:59.674]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.674]                           inherits = FALSE)) {
[13:36:59.674]                           master <- get("master", mode = "list", 
[13:36:59.674]                             envir = envir, inherits = FALSE)
[13:36:59.674]                           if (inherits(master, c("SOCKnode", 
[13:36:59.674]                             "SOCK0node"))) {
[13:36:59.674]                             sendCondition <<- function(cond) {
[13:36:59.674]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.674]                                 success = TRUE)
[13:36:59.674]                               parallel_sendData(master, data)
[13:36:59.674]                             }
[13:36:59.674]                             return(sendCondition)
[13:36:59.674]                           }
[13:36:59.674]                         }
[13:36:59.674]                         frame <- frame + 1L
[13:36:59.674]                         envir <- sys.frame(frame)
[13:36:59.674]                       }
[13:36:59.674]                     }
[13:36:59.674]                     sendCondition <<- function(cond) NULL
[13:36:59.674]                   }
[13:36:59.674]                 })
[13:36:59.674]                 withCallingHandlers({
[13:36:59.674]                   {
[13:36:59.674]                     b <- a * ii
[13:36:59.674]                     a <- 0
[13:36:59.674]                     b
[13:36:59.674]                   }
[13:36:59.674]                 }, immediateCondition = function(cond) {
[13:36:59.674]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.674]                   sendCondition(cond)
[13:36:59.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.674]                   {
[13:36:59.674]                     inherits <- base::inherits
[13:36:59.674]                     invokeRestart <- base::invokeRestart
[13:36:59.674]                     is.null <- base::is.null
[13:36:59.674]                     muffled <- FALSE
[13:36:59.674]                     if (inherits(cond, "message")) {
[13:36:59.674]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.674]                       if (muffled) 
[13:36:59.674]                         invokeRestart("muffleMessage")
[13:36:59.674]                     }
[13:36:59.674]                     else if (inherits(cond, "warning")) {
[13:36:59.674]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.674]                       if (muffled) 
[13:36:59.674]                         invokeRestart("muffleWarning")
[13:36:59.674]                     }
[13:36:59.674]                     else if (inherits(cond, "condition")) {
[13:36:59.674]                       if (!is.null(pattern)) {
[13:36:59.674]                         computeRestarts <- base::computeRestarts
[13:36:59.674]                         grepl <- base::grepl
[13:36:59.674]                         restarts <- computeRestarts(cond)
[13:36:59.674]                         for (restart in restarts) {
[13:36:59.674]                           name <- restart$name
[13:36:59.674]                           if (is.null(name)) 
[13:36:59.674]                             next
[13:36:59.674]                           if (!grepl(pattern, name)) 
[13:36:59.674]                             next
[13:36:59.674]                           invokeRestart(restart)
[13:36:59.674]                           muffled <- TRUE
[13:36:59.674]                           break
[13:36:59.674]                         }
[13:36:59.674]                       }
[13:36:59.674]                     }
[13:36:59.674]                     invisible(muffled)
[13:36:59.674]                   }
[13:36:59.674]                   muffleCondition(cond)
[13:36:59.674]                 })
[13:36:59.674]             }))
[13:36:59.674]             future::FutureResult(value = ...future.value$value, 
[13:36:59.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.674]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.674]                     ...future.globalenv.names))
[13:36:59.674]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.674]         }, condition = base::local({
[13:36:59.674]             c <- base::c
[13:36:59.674]             inherits <- base::inherits
[13:36:59.674]             invokeRestart <- base::invokeRestart
[13:36:59.674]             length <- base::length
[13:36:59.674]             list <- base::list
[13:36:59.674]             seq.int <- base::seq.int
[13:36:59.674]             signalCondition <- base::signalCondition
[13:36:59.674]             sys.calls <- base::sys.calls
[13:36:59.674]             `[[` <- base::`[[`
[13:36:59.674]             `+` <- base::`+`
[13:36:59.674]             `<<-` <- base::`<<-`
[13:36:59.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.674]                   3L)]
[13:36:59.674]             }
[13:36:59.674]             function(cond) {
[13:36:59.674]                 is_error <- inherits(cond, "error")
[13:36:59.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.674]                   NULL)
[13:36:59.674]                 if (is_error) {
[13:36:59.674]                   sessionInformation <- function() {
[13:36:59.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.674]                       search = base::search(), system = base::Sys.info())
[13:36:59.674]                   }
[13:36:59.674]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.674]                     cond$call), session = sessionInformation(), 
[13:36:59.674]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.674]                   signalCondition(cond)
[13:36:59.674]                 }
[13:36:59.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.674]                 "immediateCondition"))) {
[13:36:59.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.674]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.674]                   if (TRUE && !signal) {
[13:36:59.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.674]                     {
[13:36:59.674]                       inherits <- base::inherits
[13:36:59.674]                       invokeRestart <- base::invokeRestart
[13:36:59.674]                       is.null <- base::is.null
[13:36:59.674]                       muffled <- FALSE
[13:36:59.674]                       if (inherits(cond, "message")) {
[13:36:59.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.674]                         if (muffled) 
[13:36:59.674]                           invokeRestart("muffleMessage")
[13:36:59.674]                       }
[13:36:59.674]                       else if (inherits(cond, "warning")) {
[13:36:59.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.674]                         if (muffled) 
[13:36:59.674]                           invokeRestart("muffleWarning")
[13:36:59.674]                       }
[13:36:59.674]                       else if (inherits(cond, "condition")) {
[13:36:59.674]                         if (!is.null(pattern)) {
[13:36:59.674]                           computeRestarts <- base::computeRestarts
[13:36:59.674]                           grepl <- base::grepl
[13:36:59.674]                           restarts <- computeRestarts(cond)
[13:36:59.674]                           for (restart in restarts) {
[13:36:59.674]                             name <- restart$name
[13:36:59.674]                             if (is.null(name)) 
[13:36:59.674]                               next
[13:36:59.674]                             if (!grepl(pattern, name)) 
[13:36:59.674]                               next
[13:36:59.674]                             invokeRestart(restart)
[13:36:59.674]                             muffled <- TRUE
[13:36:59.674]                             break
[13:36:59.674]                           }
[13:36:59.674]                         }
[13:36:59.674]                       }
[13:36:59.674]                       invisible(muffled)
[13:36:59.674]                     }
[13:36:59.674]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.674]                   }
[13:36:59.674]                 }
[13:36:59.674]                 else {
[13:36:59.674]                   if (TRUE) {
[13:36:59.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.674]                     {
[13:36:59.674]                       inherits <- base::inherits
[13:36:59.674]                       invokeRestart <- base::invokeRestart
[13:36:59.674]                       is.null <- base::is.null
[13:36:59.674]                       muffled <- FALSE
[13:36:59.674]                       if (inherits(cond, "message")) {
[13:36:59.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.674]                         if (muffled) 
[13:36:59.674]                           invokeRestart("muffleMessage")
[13:36:59.674]                       }
[13:36:59.674]                       else if (inherits(cond, "warning")) {
[13:36:59.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.674]                         if (muffled) 
[13:36:59.674]                           invokeRestart("muffleWarning")
[13:36:59.674]                       }
[13:36:59.674]                       else if (inherits(cond, "condition")) {
[13:36:59.674]                         if (!is.null(pattern)) {
[13:36:59.674]                           computeRestarts <- base::computeRestarts
[13:36:59.674]                           grepl <- base::grepl
[13:36:59.674]                           restarts <- computeRestarts(cond)
[13:36:59.674]                           for (restart in restarts) {
[13:36:59.674]                             name <- restart$name
[13:36:59.674]                             if (is.null(name)) 
[13:36:59.674]                               next
[13:36:59.674]                             if (!grepl(pattern, name)) 
[13:36:59.674]                               next
[13:36:59.674]                             invokeRestart(restart)
[13:36:59.674]                             muffled <- TRUE
[13:36:59.674]                             break
[13:36:59.674]                           }
[13:36:59.674]                         }
[13:36:59.674]                       }
[13:36:59.674]                       invisible(muffled)
[13:36:59.674]                     }
[13:36:59.674]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.674]                   }
[13:36:59.674]                 }
[13:36:59.674]             }
[13:36:59.674]         }))
[13:36:59.674]     }, error = function(ex) {
[13:36:59.674]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.674]                 ...future.rng), started = ...future.startTime, 
[13:36:59.674]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.674]             version = "1.8"), class = "FutureResult")
[13:36:59.674]     }, finally = {
[13:36:59.674]         if (!identical(...future.workdir, getwd())) 
[13:36:59.674]             setwd(...future.workdir)
[13:36:59.674]         {
[13:36:59.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.674]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.674]             }
[13:36:59.674]             base::options(...future.oldOptions)
[13:36:59.674]             if (.Platform$OS.type == "windows") {
[13:36:59.674]                 old_names <- names(...future.oldEnvVars)
[13:36:59.674]                 envs <- base::Sys.getenv()
[13:36:59.674]                 names <- names(envs)
[13:36:59.674]                 common <- intersect(names, old_names)
[13:36:59.674]                 added <- setdiff(names, old_names)
[13:36:59.674]                 removed <- setdiff(old_names, names)
[13:36:59.674]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.674]                   envs[common]]
[13:36:59.674]                 NAMES <- toupper(changed)
[13:36:59.674]                 args <- list()
[13:36:59.674]                 for (kk in seq_along(NAMES)) {
[13:36:59.674]                   name <- changed[[kk]]
[13:36:59.674]                   NAME <- NAMES[[kk]]
[13:36:59.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.674]                     next
[13:36:59.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.674]                 }
[13:36:59.674]                 NAMES <- toupper(added)
[13:36:59.674]                 for (kk in seq_along(NAMES)) {
[13:36:59.674]                   name <- added[[kk]]
[13:36:59.674]                   NAME <- NAMES[[kk]]
[13:36:59.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.674]                     next
[13:36:59.674]                   args[[name]] <- ""
[13:36:59.674]                 }
[13:36:59.674]                 NAMES <- toupper(removed)
[13:36:59.674]                 for (kk in seq_along(NAMES)) {
[13:36:59.674]                   name <- removed[[kk]]
[13:36:59.674]                   NAME <- NAMES[[kk]]
[13:36:59.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.674]                     next
[13:36:59.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.674]                 }
[13:36:59.674]                 if (length(args) > 0) 
[13:36:59.674]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.674]             }
[13:36:59.674]             else {
[13:36:59.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.674]             }
[13:36:59.674]             {
[13:36:59.674]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.674]                   0L) {
[13:36:59.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.674]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.674]                   base::options(opts)
[13:36:59.674]                 }
[13:36:59.674]                 {
[13:36:59.674]                   {
[13:36:59.674]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.674]                     NULL
[13:36:59.674]                   }
[13:36:59.674]                   options(future.plan = NULL)
[13:36:59.674]                   if (is.na(NA_character_)) 
[13:36:59.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.674]                     .init = FALSE)
[13:36:59.674]                 }
[13:36:59.674]             }
[13:36:59.674]         }
[13:36:59.674]     })
[13:36:59.674]     if (TRUE) {
[13:36:59.674]         base::sink(type = "output", split = FALSE)
[13:36:59.674]         if (TRUE) {
[13:36:59.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.674]         }
[13:36:59.674]         else {
[13:36:59.674]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.674]         }
[13:36:59.674]         base::close(...future.stdout)
[13:36:59.674]         ...future.stdout <- NULL
[13:36:59.674]     }
[13:36:59.674]     ...future.result$conditions <- ...future.conditions
[13:36:59.674]     ...future.result$finished <- base::Sys.time()
[13:36:59.674]     ...future.result
[13:36:59.674] }
[13:36:59.676] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:36:59.676] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:36:59.679] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:36:59.679] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:36:59.680] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:36:59.680] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:36:59.680] MultisessionFuture started
[13:36:59.680] - Launch lazy future ... done
[13:36:59.680] run() for ‘MultisessionFuture’ ... done
[13:36:59.680] result() for ClusterFuture ...
[13:36:59.680] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.681] - Validating connection of MultisessionFuture
[13:36:59.682] - received message: FutureResult
[13:36:59.682] - Received FutureResult
[13:36:59.682] - Erased future from FutureRegistry
[13:36:59.682] result() for ClusterFuture ...
[13:36:59.682] - result already collected: FutureResult
[13:36:59.682] result() for ClusterFuture ... done
[13:36:59.682] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.682] result() for ClusterFuture ... done
[13:36:59.682] result() for ClusterFuture ...
[13:36:59.682] - result already collected: FutureResult
[13:36:59.683] result() for ClusterFuture ... done
[13:36:59.683] run() for ‘Future’ ...
[13:36:59.683] - state: ‘created’
[13:36:59.683] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.697] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.697]   - Field: ‘node’
[13:36:59.697]   - Field: ‘label’
[13:36:59.697]   - Field: ‘local’
[13:36:59.697]   - Field: ‘owner’
[13:36:59.697]   - Field: ‘envir’
[13:36:59.697]   - Field: ‘workers’
[13:36:59.698]   - Field: ‘packages’
[13:36:59.698]   - Field: ‘gc’
[13:36:59.698]   - Field: ‘conditions’
[13:36:59.698]   - Field: ‘persistent’
[13:36:59.698]   - Field: ‘expr’
[13:36:59.698]   - Field: ‘uuid’
[13:36:59.698]   - Field: ‘seed’
[13:36:59.698]   - Field: ‘version’
[13:36:59.698]   - Field: ‘result’
[13:36:59.698]   - Field: ‘asynchronous’
[13:36:59.698]   - Field: ‘calls’
[13:36:59.699]   - Field: ‘globals’
[13:36:59.699]   - Field: ‘stdout’
[13:36:59.699]   - Field: ‘earlySignal’
[13:36:59.699]   - Field: ‘lazy’
[13:36:59.699]   - Field: ‘state’
[13:36:59.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.699] - Launch lazy future ...
[13:36:59.699] Packages needed by the future expression (n = 0): <none>
[13:36:59.699] Packages needed by future strategies (n = 0): <none>
[13:36:59.700] {
[13:36:59.700]     {
[13:36:59.700]         {
[13:36:59.700]             ...future.startTime <- base::Sys.time()
[13:36:59.700]             {
[13:36:59.700]                 {
[13:36:59.700]                   {
[13:36:59.700]                     {
[13:36:59.700]                       base::local({
[13:36:59.700]                         has_future <- base::requireNamespace("future", 
[13:36:59.700]                           quietly = TRUE)
[13:36:59.700]                         if (has_future) {
[13:36:59.700]                           ns <- base::getNamespace("future")
[13:36:59.700]                           version <- ns[[".package"]][["version"]]
[13:36:59.700]                           if (is.null(version)) 
[13:36:59.700]                             version <- utils::packageVersion("future")
[13:36:59.700]                         }
[13:36:59.700]                         else {
[13:36:59.700]                           version <- NULL
[13:36:59.700]                         }
[13:36:59.700]                         if (!has_future || version < "1.8.0") {
[13:36:59.700]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.700]                             "", base::R.version$version.string), 
[13:36:59.700]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.700]                               "release", "version")], collapse = " "), 
[13:36:59.700]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.700]                             info)
[13:36:59.700]                           info <- base::paste(info, collapse = "; ")
[13:36:59.700]                           if (!has_future) {
[13:36:59.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.700]                               info)
[13:36:59.700]                           }
[13:36:59.700]                           else {
[13:36:59.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.700]                               info, version)
[13:36:59.700]                           }
[13:36:59.700]                           base::stop(msg)
[13:36:59.700]                         }
[13:36:59.700]                       })
[13:36:59.700]                     }
[13:36:59.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.700]                     base::options(mc.cores = 1L)
[13:36:59.700]                   }
[13:36:59.700]                   ...future.strategy.old <- future::plan("list")
[13:36:59.700]                   options(future.plan = NULL)
[13:36:59.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.700]                 }
[13:36:59.700]                 ...future.workdir <- getwd()
[13:36:59.700]             }
[13:36:59.700]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.700]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.700]         }
[13:36:59.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.700]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.700]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.700]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.700]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.700]             base::names(...future.oldOptions))
[13:36:59.700]     }
[13:36:59.700]     if (FALSE) {
[13:36:59.700]     }
[13:36:59.700]     else {
[13:36:59.700]         if (TRUE) {
[13:36:59.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.700]                 open = "w")
[13:36:59.700]         }
[13:36:59.700]         else {
[13:36:59.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.700]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.700]         }
[13:36:59.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.700]             base::sink(type = "output", split = FALSE)
[13:36:59.700]             base::close(...future.stdout)
[13:36:59.700]         }, add = TRUE)
[13:36:59.700]     }
[13:36:59.700]     ...future.frame <- base::sys.nframe()
[13:36:59.700]     ...future.conditions <- base::list()
[13:36:59.700]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.700]     if (FALSE) {
[13:36:59.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.700]     }
[13:36:59.700]     ...future.result <- base::tryCatch({
[13:36:59.700]         base::withCallingHandlers({
[13:36:59.700]             ...future.value <- base::withVisible(base::local({
[13:36:59.700]                 ...future.makeSendCondition <- base::local({
[13:36:59.700]                   sendCondition <- NULL
[13:36:59.700]                   function(frame = 1L) {
[13:36:59.700]                     if (is.function(sendCondition)) 
[13:36:59.700]                       return(sendCondition)
[13:36:59.700]                     ns <- getNamespace("parallel")
[13:36:59.700]                     if (exists("sendData", mode = "function", 
[13:36:59.700]                       envir = ns)) {
[13:36:59.700]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.700]                         envir = ns)
[13:36:59.700]                       envir <- sys.frame(frame)
[13:36:59.700]                       master <- NULL
[13:36:59.700]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.700]                         !identical(envir, emptyenv())) {
[13:36:59.700]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.700]                           inherits = FALSE)) {
[13:36:59.700]                           master <- get("master", mode = "list", 
[13:36:59.700]                             envir = envir, inherits = FALSE)
[13:36:59.700]                           if (inherits(master, c("SOCKnode", 
[13:36:59.700]                             "SOCK0node"))) {
[13:36:59.700]                             sendCondition <<- function(cond) {
[13:36:59.700]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.700]                                 success = TRUE)
[13:36:59.700]                               parallel_sendData(master, data)
[13:36:59.700]                             }
[13:36:59.700]                             return(sendCondition)
[13:36:59.700]                           }
[13:36:59.700]                         }
[13:36:59.700]                         frame <- frame + 1L
[13:36:59.700]                         envir <- sys.frame(frame)
[13:36:59.700]                       }
[13:36:59.700]                     }
[13:36:59.700]                     sendCondition <<- function(cond) NULL
[13:36:59.700]                   }
[13:36:59.700]                 })
[13:36:59.700]                 withCallingHandlers({
[13:36:59.700]                   {
[13:36:59.700]                     b <- a * ii
[13:36:59.700]                     a <- 0
[13:36:59.700]                     b
[13:36:59.700]                   }
[13:36:59.700]                 }, immediateCondition = function(cond) {
[13:36:59.700]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.700]                   sendCondition(cond)
[13:36:59.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.700]                   {
[13:36:59.700]                     inherits <- base::inherits
[13:36:59.700]                     invokeRestart <- base::invokeRestart
[13:36:59.700]                     is.null <- base::is.null
[13:36:59.700]                     muffled <- FALSE
[13:36:59.700]                     if (inherits(cond, "message")) {
[13:36:59.700]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.700]                       if (muffled) 
[13:36:59.700]                         invokeRestart("muffleMessage")
[13:36:59.700]                     }
[13:36:59.700]                     else if (inherits(cond, "warning")) {
[13:36:59.700]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.700]                       if (muffled) 
[13:36:59.700]                         invokeRestart("muffleWarning")
[13:36:59.700]                     }
[13:36:59.700]                     else if (inherits(cond, "condition")) {
[13:36:59.700]                       if (!is.null(pattern)) {
[13:36:59.700]                         computeRestarts <- base::computeRestarts
[13:36:59.700]                         grepl <- base::grepl
[13:36:59.700]                         restarts <- computeRestarts(cond)
[13:36:59.700]                         for (restart in restarts) {
[13:36:59.700]                           name <- restart$name
[13:36:59.700]                           if (is.null(name)) 
[13:36:59.700]                             next
[13:36:59.700]                           if (!grepl(pattern, name)) 
[13:36:59.700]                             next
[13:36:59.700]                           invokeRestart(restart)
[13:36:59.700]                           muffled <- TRUE
[13:36:59.700]                           break
[13:36:59.700]                         }
[13:36:59.700]                       }
[13:36:59.700]                     }
[13:36:59.700]                     invisible(muffled)
[13:36:59.700]                   }
[13:36:59.700]                   muffleCondition(cond)
[13:36:59.700]                 })
[13:36:59.700]             }))
[13:36:59.700]             future::FutureResult(value = ...future.value$value, 
[13:36:59.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.700]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.700]                     ...future.globalenv.names))
[13:36:59.700]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.700]         }, condition = base::local({
[13:36:59.700]             c <- base::c
[13:36:59.700]             inherits <- base::inherits
[13:36:59.700]             invokeRestart <- base::invokeRestart
[13:36:59.700]             length <- base::length
[13:36:59.700]             list <- base::list
[13:36:59.700]             seq.int <- base::seq.int
[13:36:59.700]             signalCondition <- base::signalCondition
[13:36:59.700]             sys.calls <- base::sys.calls
[13:36:59.700]             `[[` <- base::`[[`
[13:36:59.700]             `+` <- base::`+`
[13:36:59.700]             `<<-` <- base::`<<-`
[13:36:59.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.700]                   3L)]
[13:36:59.700]             }
[13:36:59.700]             function(cond) {
[13:36:59.700]                 is_error <- inherits(cond, "error")
[13:36:59.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.700]                   NULL)
[13:36:59.700]                 if (is_error) {
[13:36:59.700]                   sessionInformation <- function() {
[13:36:59.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.700]                       search = base::search(), system = base::Sys.info())
[13:36:59.700]                   }
[13:36:59.700]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.700]                     cond$call), session = sessionInformation(), 
[13:36:59.700]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.700]                   signalCondition(cond)
[13:36:59.700]                 }
[13:36:59.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.700]                 "immediateCondition"))) {
[13:36:59.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.700]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.700]                   if (TRUE && !signal) {
[13:36:59.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.700]                     {
[13:36:59.700]                       inherits <- base::inherits
[13:36:59.700]                       invokeRestart <- base::invokeRestart
[13:36:59.700]                       is.null <- base::is.null
[13:36:59.700]                       muffled <- FALSE
[13:36:59.700]                       if (inherits(cond, "message")) {
[13:36:59.700]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.700]                         if (muffled) 
[13:36:59.700]                           invokeRestart("muffleMessage")
[13:36:59.700]                       }
[13:36:59.700]                       else if (inherits(cond, "warning")) {
[13:36:59.700]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.700]                         if (muffled) 
[13:36:59.700]                           invokeRestart("muffleWarning")
[13:36:59.700]                       }
[13:36:59.700]                       else if (inherits(cond, "condition")) {
[13:36:59.700]                         if (!is.null(pattern)) {
[13:36:59.700]                           computeRestarts <- base::computeRestarts
[13:36:59.700]                           grepl <- base::grepl
[13:36:59.700]                           restarts <- computeRestarts(cond)
[13:36:59.700]                           for (restart in restarts) {
[13:36:59.700]                             name <- restart$name
[13:36:59.700]                             if (is.null(name)) 
[13:36:59.700]                               next
[13:36:59.700]                             if (!grepl(pattern, name)) 
[13:36:59.700]                               next
[13:36:59.700]                             invokeRestart(restart)
[13:36:59.700]                             muffled <- TRUE
[13:36:59.700]                             break
[13:36:59.700]                           }
[13:36:59.700]                         }
[13:36:59.700]                       }
[13:36:59.700]                       invisible(muffled)
[13:36:59.700]                     }
[13:36:59.700]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.700]                   }
[13:36:59.700]                 }
[13:36:59.700]                 else {
[13:36:59.700]                   if (TRUE) {
[13:36:59.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.700]                     {
[13:36:59.700]                       inherits <- base::inherits
[13:36:59.700]                       invokeRestart <- base::invokeRestart
[13:36:59.700]                       is.null <- base::is.null
[13:36:59.700]                       muffled <- FALSE
[13:36:59.700]                       if (inherits(cond, "message")) {
[13:36:59.700]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.700]                         if (muffled) 
[13:36:59.700]                           invokeRestart("muffleMessage")
[13:36:59.700]                       }
[13:36:59.700]                       else if (inherits(cond, "warning")) {
[13:36:59.700]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.700]                         if (muffled) 
[13:36:59.700]                           invokeRestart("muffleWarning")
[13:36:59.700]                       }
[13:36:59.700]                       else if (inherits(cond, "condition")) {
[13:36:59.700]                         if (!is.null(pattern)) {
[13:36:59.700]                           computeRestarts <- base::computeRestarts
[13:36:59.700]                           grepl <- base::grepl
[13:36:59.700]                           restarts <- computeRestarts(cond)
[13:36:59.700]                           for (restart in restarts) {
[13:36:59.700]                             name <- restart$name
[13:36:59.700]                             if (is.null(name)) 
[13:36:59.700]                               next
[13:36:59.700]                             if (!grepl(pattern, name)) 
[13:36:59.700]                               next
[13:36:59.700]                             invokeRestart(restart)
[13:36:59.700]                             muffled <- TRUE
[13:36:59.700]                             break
[13:36:59.700]                           }
[13:36:59.700]                         }
[13:36:59.700]                       }
[13:36:59.700]                       invisible(muffled)
[13:36:59.700]                     }
[13:36:59.700]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.700]                   }
[13:36:59.700]                 }
[13:36:59.700]             }
[13:36:59.700]         }))
[13:36:59.700]     }, error = function(ex) {
[13:36:59.700]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.700]                 ...future.rng), started = ...future.startTime, 
[13:36:59.700]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.700]             version = "1.8"), class = "FutureResult")
[13:36:59.700]     }, finally = {
[13:36:59.700]         if (!identical(...future.workdir, getwd())) 
[13:36:59.700]             setwd(...future.workdir)
[13:36:59.700]         {
[13:36:59.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.700]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.700]             }
[13:36:59.700]             base::options(...future.oldOptions)
[13:36:59.700]             if (.Platform$OS.type == "windows") {
[13:36:59.700]                 old_names <- names(...future.oldEnvVars)
[13:36:59.700]                 envs <- base::Sys.getenv()
[13:36:59.700]                 names <- names(envs)
[13:36:59.700]                 common <- intersect(names, old_names)
[13:36:59.700]                 added <- setdiff(names, old_names)
[13:36:59.700]                 removed <- setdiff(old_names, names)
[13:36:59.700]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.700]                   envs[common]]
[13:36:59.700]                 NAMES <- toupper(changed)
[13:36:59.700]                 args <- list()
[13:36:59.700]                 for (kk in seq_along(NAMES)) {
[13:36:59.700]                   name <- changed[[kk]]
[13:36:59.700]                   NAME <- NAMES[[kk]]
[13:36:59.700]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.700]                     next
[13:36:59.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.700]                 }
[13:36:59.700]                 NAMES <- toupper(added)
[13:36:59.700]                 for (kk in seq_along(NAMES)) {
[13:36:59.700]                   name <- added[[kk]]
[13:36:59.700]                   NAME <- NAMES[[kk]]
[13:36:59.700]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.700]                     next
[13:36:59.700]                   args[[name]] <- ""
[13:36:59.700]                 }
[13:36:59.700]                 NAMES <- toupper(removed)
[13:36:59.700]                 for (kk in seq_along(NAMES)) {
[13:36:59.700]                   name <- removed[[kk]]
[13:36:59.700]                   NAME <- NAMES[[kk]]
[13:36:59.700]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.700]                     next
[13:36:59.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.700]                 }
[13:36:59.700]                 if (length(args) > 0) 
[13:36:59.700]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.700]             }
[13:36:59.700]             else {
[13:36:59.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.700]             }
[13:36:59.700]             {
[13:36:59.700]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.700]                   0L) {
[13:36:59.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.700]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.700]                   base::options(opts)
[13:36:59.700]                 }
[13:36:59.700]                 {
[13:36:59.700]                   {
[13:36:59.700]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.700]                     NULL
[13:36:59.700]                   }
[13:36:59.700]                   options(future.plan = NULL)
[13:36:59.700]                   if (is.na(NA_character_)) 
[13:36:59.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.700]                     .init = FALSE)
[13:36:59.700]                 }
[13:36:59.700]             }
[13:36:59.700]         }
[13:36:59.700]     })
[13:36:59.700]     if (TRUE) {
[13:36:59.700]         base::sink(type = "output", split = FALSE)
[13:36:59.700]         if (TRUE) {
[13:36:59.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.700]         }
[13:36:59.700]         else {
[13:36:59.700]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.700]         }
[13:36:59.700]         base::close(...future.stdout)
[13:36:59.700]         ...future.stdout <- NULL
[13:36:59.700]     }
[13:36:59.700]     ...future.result$conditions <- ...future.conditions
[13:36:59.700]     ...future.result$finished <- base::Sys.time()
[13:36:59.700]     ...future.result
[13:36:59.700] }
[13:36:59.702] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:36:59.702] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:36:59.703] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:36:59.703] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:36:59.703] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:36:59.703] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:36:59.704] MultisessionFuture started
[13:36:59.704] - Launch lazy future ... done
[13:36:59.704] run() for ‘MultisessionFuture’ ... done
[13:36:59.704] result() for ClusterFuture ...
[13:36:59.704] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.704] - Validating connection of MultisessionFuture
[13:36:59.705] - received message: FutureResult
[13:36:59.705] - Received FutureResult
[13:36:59.705] - Erased future from FutureRegistry
[13:36:59.705] result() for ClusterFuture ...
[13:36:59.705] - result already collected: FutureResult
[13:36:59.705] result() for ClusterFuture ... done
[13:36:59.706] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.706] result() for ClusterFuture ... done
[13:36:59.706] result() for ClusterFuture ...
[13:36:59.706] - result already collected: FutureResult
[13:36:59.706] result() for ClusterFuture ... done
[13:36:59.706] run() for ‘Future’ ...
[13:36:59.706] - state: ‘created’
[13:36:59.706] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.720] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.720] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.720]   - Field: ‘node’
[13:36:59.720]   - Field: ‘label’
[13:36:59.720]   - Field: ‘local’
[13:36:59.720]   - Field: ‘owner’
[13:36:59.720]   - Field: ‘envir’
[13:36:59.721]   - Field: ‘workers’
[13:36:59.721]   - Field: ‘packages’
[13:36:59.721]   - Field: ‘gc’
[13:36:59.721]   - Field: ‘conditions’
[13:36:59.721]   - Field: ‘persistent’
[13:36:59.721]   - Field: ‘expr’
[13:36:59.721]   - Field: ‘uuid’
[13:36:59.721]   - Field: ‘seed’
[13:36:59.721]   - Field: ‘version’
[13:36:59.721]   - Field: ‘result’
[13:36:59.721]   - Field: ‘asynchronous’
[13:36:59.722]   - Field: ‘calls’
[13:36:59.722]   - Field: ‘globals’
[13:36:59.722]   - Field: ‘stdout’
[13:36:59.722]   - Field: ‘earlySignal’
[13:36:59.722]   - Field: ‘lazy’
[13:36:59.722]   - Field: ‘state’
[13:36:59.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.722] - Launch lazy future ...
[13:36:59.723] Packages needed by the future expression (n = 0): <none>
[13:36:59.723] Packages needed by future strategies (n = 0): <none>
[13:36:59.723] {
[13:36:59.723]     {
[13:36:59.723]         {
[13:36:59.723]             ...future.startTime <- base::Sys.time()
[13:36:59.723]             {
[13:36:59.723]                 {
[13:36:59.723]                   {
[13:36:59.723]                     {
[13:36:59.723]                       base::local({
[13:36:59.723]                         has_future <- base::requireNamespace("future", 
[13:36:59.723]                           quietly = TRUE)
[13:36:59.723]                         if (has_future) {
[13:36:59.723]                           ns <- base::getNamespace("future")
[13:36:59.723]                           version <- ns[[".package"]][["version"]]
[13:36:59.723]                           if (is.null(version)) 
[13:36:59.723]                             version <- utils::packageVersion("future")
[13:36:59.723]                         }
[13:36:59.723]                         else {
[13:36:59.723]                           version <- NULL
[13:36:59.723]                         }
[13:36:59.723]                         if (!has_future || version < "1.8.0") {
[13:36:59.723]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.723]                             "", base::R.version$version.string), 
[13:36:59.723]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.723]                               "release", "version")], collapse = " "), 
[13:36:59.723]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.723]                             info)
[13:36:59.723]                           info <- base::paste(info, collapse = "; ")
[13:36:59.723]                           if (!has_future) {
[13:36:59.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.723]                               info)
[13:36:59.723]                           }
[13:36:59.723]                           else {
[13:36:59.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.723]                               info, version)
[13:36:59.723]                           }
[13:36:59.723]                           base::stop(msg)
[13:36:59.723]                         }
[13:36:59.723]                       })
[13:36:59.723]                     }
[13:36:59.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.723]                     base::options(mc.cores = 1L)
[13:36:59.723]                   }
[13:36:59.723]                   ...future.strategy.old <- future::plan("list")
[13:36:59.723]                   options(future.plan = NULL)
[13:36:59.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.723]                 }
[13:36:59.723]                 ...future.workdir <- getwd()
[13:36:59.723]             }
[13:36:59.723]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.723]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.723]         }
[13:36:59.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.723]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.723]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.723]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.723]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.723]             base::names(...future.oldOptions))
[13:36:59.723]     }
[13:36:59.723]     if (FALSE) {
[13:36:59.723]     }
[13:36:59.723]     else {
[13:36:59.723]         if (TRUE) {
[13:36:59.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.723]                 open = "w")
[13:36:59.723]         }
[13:36:59.723]         else {
[13:36:59.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.723]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.723]         }
[13:36:59.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.723]             base::sink(type = "output", split = FALSE)
[13:36:59.723]             base::close(...future.stdout)
[13:36:59.723]         }, add = TRUE)
[13:36:59.723]     }
[13:36:59.723]     ...future.frame <- base::sys.nframe()
[13:36:59.723]     ...future.conditions <- base::list()
[13:36:59.723]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.723]     if (FALSE) {
[13:36:59.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.723]     }
[13:36:59.723]     ...future.result <- base::tryCatch({
[13:36:59.723]         base::withCallingHandlers({
[13:36:59.723]             ...future.value <- base::withVisible(base::local({
[13:36:59.723]                 ...future.makeSendCondition <- base::local({
[13:36:59.723]                   sendCondition <- NULL
[13:36:59.723]                   function(frame = 1L) {
[13:36:59.723]                     if (is.function(sendCondition)) 
[13:36:59.723]                       return(sendCondition)
[13:36:59.723]                     ns <- getNamespace("parallel")
[13:36:59.723]                     if (exists("sendData", mode = "function", 
[13:36:59.723]                       envir = ns)) {
[13:36:59.723]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.723]                         envir = ns)
[13:36:59.723]                       envir <- sys.frame(frame)
[13:36:59.723]                       master <- NULL
[13:36:59.723]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.723]                         !identical(envir, emptyenv())) {
[13:36:59.723]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.723]                           inherits = FALSE)) {
[13:36:59.723]                           master <- get("master", mode = "list", 
[13:36:59.723]                             envir = envir, inherits = FALSE)
[13:36:59.723]                           if (inherits(master, c("SOCKnode", 
[13:36:59.723]                             "SOCK0node"))) {
[13:36:59.723]                             sendCondition <<- function(cond) {
[13:36:59.723]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.723]                                 success = TRUE)
[13:36:59.723]                               parallel_sendData(master, data)
[13:36:59.723]                             }
[13:36:59.723]                             return(sendCondition)
[13:36:59.723]                           }
[13:36:59.723]                         }
[13:36:59.723]                         frame <- frame + 1L
[13:36:59.723]                         envir <- sys.frame(frame)
[13:36:59.723]                       }
[13:36:59.723]                     }
[13:36:59.723]                     sendCondition <<- function(cond) NULL
[13:36:59.723]                   }
[13:36:59.723]                 })
[13:36:59.723]                 withCallingHandlers({
[13:36:59.723]                   {
[13:36:59.723]                     b <- a * ii
[13:36:59.723]                     a <- 0
[13:36:59.723]                     b
[13:36:59.723]                   }
[13:36:59.723]                 }, immediateCondition = function(cond) {
[13:36:59.723]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.723]                   sendCondition(cond)
[13:36:59.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.723]                   {
[13:36:59.723]                     inherits <- base::inherits
[13:36:59.723]                     invokeRestart <- base::invokeRestart
[13:36:59.723]                     is.null <- base::is.null
[13:36:59.723]                     muffled <- FALSE
[13:36:59.723]                     if (inherits(cond, "message")) {
[13:36:59.723]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.723]                       if (muffled) 
[13:36:59.723]                         invokeRestart("muffleMessage")
[13:36:59.723]                     }
[13:36:59.723]                     else if (inherits(cond, "warning")) {
[13:36:59.723]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.723]                       if (muffled) 
[13:36:59.723]                         invokeRestart("muffleWarning")
[13:36:59.723]                     }
[13:36:59.723]                     else if (inherits(cond, "condition")) {
[13:36:59.723]                       if (!is.null(pattern)) {
[13:36:59.723]                         computeRestarts <- base::computeRestarts
[13:36:59.723]                         grepl <- base::grepl
[13:36:59.723]                         restarts <- computeRestarts(cond)
[13:36:59.723]                         for (restart in restarts) {
[13:36:59.723]                           name <- restart$name
[13:36:59.723]                           if (is.null(name)) 
[13:36:59.723]                             next
[13:36:59.723]                           if (!grepl(pattern, name)) 
[13:36:59.723]                             next
[13:36:59.723]                           invokeRestart(restart)
[13:36:59.723]                           muffled <- TRUE
[13:36:59.723]                           break
[13:36:59.723]                         }
[13:36:59.723]                       }
[13:36:59.723]                     }
[13:36:59.723]                     invisible(muffled)
[13:36:59.723]                   }
[13:36:59.723]                   muffleCondition(cond)
[13:36:59.723]                 })
[13:36:59.723]             }))
[13:36:59.723]             future::FutureResult(value = ...future.value$value, 
[13:36:59.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.723]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.723]                     ...future.globalenv.names))
[13:36:59.723]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.723]         }, condition = base::local({
[13:36:59.723]             c <- base::c
[13:36:59.723]             inherits <- base::inherits
[13:36:59.723]             invokeRestart <- base::invokeRestart
[13:36:59.723]             length <- base::length
[13:36:59.723]             list <- base::list
[13:36:59.723]             seq.int <- base::seq.int
[13:36:59.723]             signalCondition <- base::signalCondition
[13:36:59.723]             sys.calls <- base::sys.calls
[13:36:59.723]             `[[` <- base::`[[`
[13:36:59.723]             `+` <- base::`+`
[13:36:59.723]             `<<-` <- base::`<<-`
[13:36:59.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.723]                   3L)]
[13:36:59.723]             }
[13:36:59.723]             function(cond) {
[13:36:59.723]                 is_error <- inherits(cond, "error")
[13:36:59.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.723]                   NULL)
[13:36:59.723]                 if (is_error) {
[13:36:59.723]                   sessionInformation <- function() {
[13:36:59.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.723]                       search = base::search(), system = base::Sys.info())
[13:36:59.723]                   }
[13:36:59.723]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.723]                     cond$call), session = sessionInformation(), 
[13:36:59.723]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.723]                   signalCondition(cond)
[13:36:59.723]                 }
[13:36:59.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.723]                 "immediateCondition"))) {
[13:36:59.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.723]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.723]                   if (TRUE && !signal) {
[13:36:59.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.723]                     {
[13:36:59.723]                       inherits <- base::inherits
[13:36:59.723]                       invokeRestart <- base::invokeRestart
[13:36:59.723]                       is.null <- base::is.null
[13:36:59.723]                       muffled <- FALSE
[13:36:59.723]                       if (inherits(cond, "message")) {
[13:36:59.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.723]                         if (muffled) 
[13:36:59.723]                           invokeRestart("muffleMessage")
[13:36:59.723]                       }
[13:36:59.723]                       else if (inherits(cond, "warning")) {
[13:36:59.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.723]                         if (muffled) 
[13:36:59.723]                           invokeRestart("muffleWarning")
[13:36:59.723]                       }
[13:36:59.723]                       else if (inherits(cond, "condition")) {
[13:36:59.723]                         if (!is.null(pattern)) {
[13:36:59.723]                           computeRestarts <- base::computeRestarts
[13:36:59.723]                           grepl <- base::grepl
[13:36:59.723]                           restarts <- computeRestarts(cond)
[13:36:59.723]                           for (restart in restarts) {
[13:36:59.723]                             name <- restart$name
[13:36:59.723]                             if (is.null(name)) 
[13:36:59.723]                               next
[13:36:59.723]                             if (!grepl(pattern, name)) 
[13:36:59.723]                               next
[13:36:59.723]                             invokeRestart(restart)
[13:36:59.723]                             muffled <- TRUE
[13:36:59.723]                             break
[13:36:59.723]                           }
[13:36:59.723]                         }
[13:36:59.723]                       }
[13:36:59.723]                       invisible(muffled)
[13:36:59.723]                     }
[13:36:59.723]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.723]                   }
[13:36:59.723]                 }
[13:36:59.723]                 else {
[13:36:59.723]                   if (TRUE) {
[13:36:59.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.723]                     {
[13:36:59.723]                       inherits <- base::inherits
[13:36:59.723]                       invokeRestart <- base::invokeRestart
[13:36:59.723]                       is.null <- base::is.null
[13:36:59.723]                       muffled <- FALSE
[13:36:59.723]                       if (inherits(cond, "message")) {
[13:36:59.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.723]                         if (muffled) 
[13:36:59.723]                           invokeRestart("muffleMessage")
[13:36:59.723]                       }
[13:36:59.723]                       else if (inherits(cond, "warning")) {
[13:36:59.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.723]                         if (muffled) 
[13:36:59.723]                           invokeRestart("muffleWarning")
[13:36:59.723]                       }
[13:36:59.723]                       else if (inherits(cond, "condition")) {
[13:36:59.723]                         if (!is.null(pattern)) {
[13:36:59.723]                           computeRestarts <- base::computeRestarts
[13:36:59.723]                           grepl <- base::grepl
[13:36:59.723]                           restarts <- computeRestarts(cond)
[13:36:59.723]                           for (restart in restarts) {
[13:36:59.723]                             name <- restart$name
[13:36:59.723]                             if (is.null(name)) 
[13:36:59.723]                               next
[13:36:59.723]                             if (!grepl(pattern, name)) 
[13:36:59.723]                               next
[13:36:59.723]                             invokeRestart(restart)
[13:36:59.723]                             muffled <- TRUE
[13:36:59.723]                             break
[13:36:59.723]                           }
[13:36:59.723]                         }
[13:36:59.723]                       }
[13:36:59.723]                       invisible(muffled)
[13:36:59.723]                     }
[13:36:59.723]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.723]                   }
[13:36:59.723]                 }
[13:36:59.723]             }
[13:36:59.723]         }))
[13:36:59.723]     }, error = function(ex) {
[13:36:59.723]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.723]                 ...future.rng), started = ...future.startTime, 
[13:36:59.723]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.723]             version = "1.8"), class = "FutureResult")
[13:36:59.723]     }, finally = {
[13:36:59.723]         if (!identical(...future.workdir, getwd())) 
[13:36:59.723]             setwd(...future.workdir)
[13:36:59.723]         {
[13:36:59.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.723]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.723]             }
[13:36:59.723]             base::options(...future.oldOptions)
[13:36:59.723]             if (.Platform$OS.type == "windows") {
[13:36:59.723]                 old_names <- names(...future.oldEnvVars)
[13:36:59.723]                 envs <- base::Sys.getenv()
[13:36:59.723]                 names <- names(envs)
[13:36:59.723]                 common <- intersect(names, old_names)
[13:36:59.723]                 added <- setdiff(names, old_names)
[13:36:59.723]                 removed <- setdiff(old_names, names)
[13:36:59.723]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.723]                   envs[common]]
[13:36:59.723]                 NAMES <- toupper(changed)
[13:36:59.723]                 args <- list()
[13:36:59.723]                 for (kk in seq_along(NAMES)) {
[13:36:59.723]                   name <- changed[[kk]]
[13:36:59.723]                   NAME <- NAMES[[kk]]
[13:36:59.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.723]                     next
[13:36:59.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.723]                 }
[13:36:59.723]                 NAMES <- toupper(added)
[13:36:59.723]                 for (kk in seq_along(NAMES)) {
[13:36:59.723]                   name <- added[[kk]]
[13:36:59.723]                   NAME <- NAMES[[kk]]
[13:36:59.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.723]                     next
[13:36:59.723]                   args[[name]] <- ""
[13:36:59.723]                 }
[13:36:59.723]                 NAMES <- toupper(removed)
[13:36:59.723]                 for (kk in seq_along(NAMES)) {
[13:36:59.723]                   name <- removed[[kk]]
[13:36:59.723]                   NAME <- NAMES[[kk]]
[13:36:59.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.723]                     next
[13:36:59.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.723]                 }
[13:36:59.723]                 if (length(args) > 0) 
[13:36:59.723]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.723]             }
[13:36:59.723]             else {
[13:36:59.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.723]             }
[13:36:59.723]             {
[13:36:59.723]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.723]                   0L) {
[13:36:59.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.723]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.723]                   base::options(opts)
[13:36:59.723]                 }
[13:36:59.723]                 {
[13:36:59.723]                   {
[13:36:59.723]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.723]                     NULL
[13:36:59.723]                   }
[13:36:59.723]                   options(future.plan = NULL)
[13:36:59.723]                   if (is.na(NA_character_)) 
[13:36:59.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.723]                     .init = FALSE)
[13:36:59.723]                 }
[13:36:59.723]             }
[13:36:59.723]         }
[13:36:59.723]     })
[13:36:59.723]     if (TRUE) {
[13:36:59.723]         base::sink(type = "output", split = FALSE)
[13:36:59.723]         if (TRUE) {
[13:36:59.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.723]         }
[13:36:59.723]         else {
[13:36:59.723]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.723]         }
[13:36:59.723]         base::close(...future.stdout)
[13:36:59.723]         ...future.stdout <- NULL
[13:36:59.723]     }
[13:36:59.723]     ...future.result$conditions <- ...future.conditions
[13:36:59.723]     ...future.result$finished <- base::Sys.time()
[13:36:59.723]     ...future.result
[13:36:59.723] }
[13:36:59.725] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:36:59.726] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:36:59.726] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:36:59.726] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:36:59.726] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:36:59.727] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:36:59.727] MultisessionFuture started
[13:36:59.727] - Launch lazy future ... done
[13:36:59.727] run() for ‘MultisessionFuture’ ... done
[13:36:59.727] result() for ClusterFuture ...
[13:36:59.727] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.727] - Validating connection of MultisessionFuture
[13:36:59.728] - received message: FutureResult
[13:36:59.728] - Received FutureResult
[13:36:59.729] - Erased future from FutureRegistry
[13:36:59.729] result() for ClusterFuture ...
[13:36:59.729] - result already collected: FutureResult
[13:36:59.729] result() for ClusterFuture ... done
[13:36:59.729] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.729] result() for ClusterFuture ... done
[13:36:59.729] result() for ClusterFuture ...
[13:36:59.729] - result already collected: FutureResult
[13:36:59.729] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.730] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.730] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.730] 
[13:36:59.730] Searching for globals ... DONE
[13:36:59.730] - globals: [0] <none>
[13:36:59.730] getGlobalsAndPackages() ... DONE
[13:36:59.731] run() for ‘Future’ ...
[13:36:59.731] - state: ‘created’
[13:36:59.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.744] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.744]   - Field: ‘node’
[13:36:59.745]   - Field: ‘label’
[13:36:59.745]   - Field: ‘local’
[13:36:59.745]   - Field: ‘owner’
[13:36:59.745]   - Field: ‘envir’
[13:36:59.745]   - Field: ‘workers’
[13:36:59.745]   - Field: ‘packages’
[13:36:59.745]   - Field: ‘gc’
[13:36:59.745]   - Field: ‘conditions’
[13:36:59.745]   - Field: ‘persistent’
[13:36:59.745]   - Field: ‘expr’
[13:36:59.745]   - Field: ‘uuid’
[13:36:59.746]   - Field: ‘seed’
[13:36:59.746]   - Field: ‘version’
[13:36:59.746]   - Field: ‘result’
[13:36:59.746]   - Field: ‘asynchronous’
[13:36:59.746]   - Field: ‘calls’
[13:36:59.746]   - Field: ‘globals’
[13:36:59.746]   - Field: ‘stdout’
[13:36:59.746]   - Field: ‘earlySignal’
[13:36:59.746]   - Field: ‘lazy’
[13:36:59.746]   - Field: ‘state’
[13:36:59.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.747] - Launch lazy future ...
[13:36:59.747] Packages needed by the future expression (n = 0): <none>
[13:36:59.747] Packages needed by future strategies (n = 0): <none>
[13:36:59.747] {
[13:36:59.747]     {
[13:36:59.747]         {
[13:36:59.747]             ...future.startTime <- base::Sys.time()
[13:36:59.747]             {
[13:36:59.747]                 {
[13:36:59.747]                   {
[13:36:59.747]                     {
[13:36:59.747]                       base::local({
[13:36:59.747]                         has_future <- base::requireNamespace("future", 
[13:36:59.747]                           quietly = TRUE)
[13:36:59.747]                         if (has_future) {
[13:36:59.747]                           ns <- base::getNamespace("future")
[13:36:59.747]                           version <- ns[[".package"]][["version"]]
[13:36:59.747]                           if (is.null(version)) 
[13:36:59.747]                             version <- utils::packageVersion("future")
[13:36:59.747]                         }
[13:36:59.747]                         else {
[13:36:59.747]                           version <- NULL
[13:36:59.747]                         }
[13:36:59.747]                         if (!has_future || version < "1.8.0") {
[13:36:59.747]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.747]                             "", base::R.version$version.string), 
[13:36:59.747]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.747]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.747]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.747]                               "release", "version")], collapse = " "), 
[13:36:59.747]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.747]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.747]                             info)
[13:36:59.747]                           info <- base::paste(info, collapse = "; ")
[13:36:59.747]                           if (!has_future) {
[13:36:59.747]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.747]                               info)
[13:36:59.747]                           }
[13:36:59.747]                           else {
[13:36:59.747]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.747]                               info, version)
[13:36:59.747]                           }
[13:36:59.747]                           base::stop(msg)
[13:36:59.747]                         }
[13:36:59.747]                       })
[13:36:59.747]                     }
[13:36:59.747]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.747]                     base::options(mc.cores = 1L)
[13:36:59.747]                   }
[13:36:59.747]                   ...future.strategy.old <- future::plan("list")
[13:36:59.747]                   options(future.plan = NULL)
[13:36:59.747]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.747]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.747]                 }
[13:36:59.747]                 ...future.workdir <- getwd()
[13:36:59.747]             }
[13:36:59.747]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.747]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.747]         }
[13:36:59.747]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.747]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.747]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.747]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.747]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.747]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.747]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.747]             base::names(...future.oldOptions))
[13:36:59.747]     }
[13:36:59.747]     if (FALSE) {
[13:36:59.747]     }
[13:36:59.747]     else {
[13:36:59.747]         if (TRUE) {
[13:36:59.747]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.747]                 open = "w")
[13:36:59.747]         }
[13:36:59.747]         else {
[13:36:59.747]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.747]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.747]         }
[13:36:59.747]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.747]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.747]             base::sink(type = "output", split = FALSE)
[13:36:59.747]             base::close(...future.stdout)
[13:36:59.747]         }, add = TRUE)
[13:36:59.747]     }
[13:36:59.747]     ...future.frame <- base::sys.nframe()
[13:36:59.747]     ...future.conditions <- base::list()
[13:36:59.747]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.747]     if (FALSE) {
[13:36:59.747]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.747]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.747]     }
[13:36:59.747]     ...future.result <- base::tryCatch({
[13:36:59.747]         base::withCallingHandlers({
[13:36:59.747]             ...future.value <- base::withVisible(base::local({
[13:36:59.747]                 ...future.makeSendCondition <- base::local({
[13:36:59.747]                   sendCondition <- NULL
[13:36:59.747]                   function(frame = 1L) {
[13:36:59.747]                     if (is.function(sendCondition)) 
[13:36:59.747]                       return(sendCondition)
[13:36:59.747]                     ns <- getNamespace("parallel")
[13:36:59.747]                     if (exists("sendData", mode = "function", 
[13:36:59.747]                       envir = ns)) {
[13:36:59.747]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.747]                         envir = ns)
[13:36:59.747]                       envir <- sys.frame(frame)
[13:36:59.747]                       master <- NULL
[13:36:59.747]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.747]                         !identical(envir, emptyenv())) {
[13:36:59.747]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.747]                           inherits = FALSE)) {
[13:36:59.747]                           master <- get("master", mode = "list", 
[13:36:59.747]                             envir = envir, inherits = FALSE)
[13:36:59.747]                           if (inherits(master, c("SOCKnode", 
[13:36:59.747]                             "SOCK0node"))) {
[13:36:59.747]                             sendCondition <<- function(cond) {
[13:36:59.747]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.747]                                 success = TRUE)
[13:36:59.747]                               parallel_sendData(master, data)
[13:36:59.747]                             }
[13:36:59.747]                             return(sendCondition)
[13:36:59.747]                           }
[13:36:59.747]                         }
[13:36:59.747]                         frame <- frame + 1L
[13:36:59.747]                         envir <- sys.frame(frame)
[13:36:59.747]                       }
[13:36:59.747]                     }
[13:36:59.747]                     sendCondition <<- function(cond) NULL
[13:36:59.747]                   }
[13:36:59.747]                 })
[13:36:59.747]                 withCallingHandlers({
[13:36:59.747]                   1
[13:36:59.747]                 }, immediateCondition = function(cond) {
[13:36:59.747]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.747]                   sendCondition(cond)
[13:36:59.747]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.747]                   {
[13:36:59.747]                     inherits <- base::inherits
[13:36:59.747]                     invokeRestart <- base::invokeRestart
[13:36:59.747]                     is.null <- base::is.null
[13:36:59.747]                     muffled <- FALSE
[13:36:59.747]                     if (inherits(cond, "message")) {
[13:36:59.747]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.747]                       if (muffled) 
[13:36:59.747]                         invokeRestart("muffleMessage")
[13:36:59.747]                     }
[13:36:59.747]                     else if (inherits(cond, "warning")) {
[13:36:59.747]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.747]                       if (muffled) 
[13:36:59.747]                         invokeRestart("muffleWarning")
[13:36:59.747]                     }
[13:36:59.747]                     else if (inherits(cond, "condition")) {
[13:36:59.747]                       if (!is.null(pattern)) {
[13:36:59.747]                         computeRestarts <- base::computeRestarts
[13:36:59.747]                         grepl <- base::grepl
[13:36:59.747]                         restarts <- computeRestarts(cond)
[13:36:59.747]                         for (restart in restarts) {
[13:36:59.747]                           name <- restart$name
[13:36:59.747]                           if (is.null(name)) 
[13:36:59.747]                             next
[13:36:59.747]                           if (!grepl(pattern, name)) 
[13:36:59.747]                             next
[13:36:59.747]                           invokeRestart(restart)
[13:36:59.747]                           muffled <- TRUE
[13:36:59.747]                           break
[13:36:59.747]                         }
[13:36:59.747]                       }
[13:36:59.747]                     }
[13:36:59.747]                     invisible(muffled)
[13:36:59.747]                   }
[13:36:59.747]                   muffleCondition(cond)
[13:36:59.747]                 })
[13:36:59.747]             }))
[13:36:59.747]             future::FutureResult(value = ...future.value$value, 
[13:36:59.747]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.747]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.747]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.747]                     ...future.globalenv.names))
[13:36:59.747]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.747]         }, condition = base::local({
[13:36:59.747]             c <- base::c
[13:36:59.747]             inherits <- base::inherits
[13:36:59.747]             invokeRestart <- base::invokeRestart
[13:36:59.747]             length <- base::length
[13:36:59.747]             list <- base::list
[13:36:59.747]             seq.int <- base::seq.int
[13:36:59.747]             signalCondition <- base::signalCondition
[13:36:59.747]             sys.calls <- base::sys.calls
[13:36:59.747]             `[[` <- base::`[[`
[13:36:59.747]             `+` <- base::`+`
[13:36:59.747]             `<<-` <- base::`<<-`
[13:36:59.747]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.747]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.747]                   3L)]
[13:36:59.747]             }
[13:36:59.747]             function(cond) {
[13:36:59.747]                 is_error <- inherits(cond, "error")
[13:36:59.747]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.747]                   NULL)
[13:36:59.747]                 if (is_error) {
[13:36:59.747]                   sessionInformation <- function() {
[13:36:59.747]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.747]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.747]                       search = base::search(), system = base::Sys.info())
[13:36:59.747]                   }
[13:36:59.747]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.747]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.747]                     cond$call), session = sessionInformation(), 
[13:36:59.747]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.747]                   signalCondition(cond)
[13:36:59.747]                 }
[13:36:59.747]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.747]                 "immediateCondition"))) {
[13:36:59.747]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.747]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.747]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.747]                   if (TRUE && !signal) {
[13:36:59.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.747]                     {
[13:36:59.747]                       inherits <- base::inherits
[13:36:59.747]                       invokeRestart <- base::invokeRestart
[13:36:59.747]                       is.null <- base::is.null
[13:36:59.747]                       muffled <- FALSE
[13:36:59.747]                       if (inherits(cond, "message")) {
[13:36:59.747]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.747]                         if (muffled) 
[13:36:59.747]                           invokeRestart("muffleMessage")
[13:36:59.747]                       }
[13:36:59.747]                       else if (inherits(cond, "warning")) {
[13:36:59.747]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.747]                         if (muffled) 
[13:36:59.747]                           invokeRestart("muffleWarning")
[13:36:59.747]                       }
[13:36:59.747]                       else if (inherits(cond, "condition")) {
[13:36:59.747]                         if (!is.null(pattern)) {
[13:36:59.747]                           computeRestarts <- base::computeRestarts
[13:36:59.747]                           grepl <- base::grepl
[13:36:59.747]                           restarts <- computeRestarts(cond)
[13:36:59.747]                           for (restart in restarts) {
[13:36:59.747]                             name <- restart$name
[13:36:59.747]                             if (is.null(name)) 
[13:36:59.747]                               next
[13:36:59.747]                             if (!grepl(pattern, name)) 
[13:36:59.747]                               next
[13:36:59.747]                             invokeRestart(restart)
[13:36:59.747]                             muffled <- TRUE
[13:36:59.747]                             break
[13:36:59.747]                           }
[13:36:59.747]                         }
[13:36:59.747]                       }
[13:36:59.747]                       invisible(muffled)
[13:36:59.747]                     }
[13:36:59.747]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.747]                   }
[13:36:59.747]                 }
[13:36:59.747]                 else {
[13:36:59.747]                   if (TRUE) {
[13:36:59.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.747]                     {
[13:36:59.747]                       inherits <- base::inherits
[13:36:59.747]                       invokeRestart <- base::invokeRestart
[13:36:59.747]                       is.null <- base::is.null
[13:36:59.747]                       muffled <- FALSE
[13:36:59.747]                       if (inherits(cond, "message")) {
[13:36:59.747]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.747]                         if (muffled) 
[13:36:59.747]                           invokeRestart("muffleMessage")
[13:36:59.747]                       }
[13:36:59.747]                       else if (inherits(cond, "warning")) {
[13:36:59.747]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.747]                         if (muffled) 
[13:36:59.747]                           invokeRestart("muffleWarning")
[13:36:59.747]                       }
[13:36:59.747]                       else if (inherits(cond, "condition")) {
[13:36:59.747]                         if (!is.null(pattern)) {
[13:36:59.747]                           computeRestarts <- base::computeRestarts
[13:36:59.747]                           grepl <- base::grepl
[13:36:59.747]                           restarts <- computeRestarts(cond)
[13:36:59.747]                           for (restart in restarts) {
[13:36:59.747]                             name <- restart$name
[13:36:59.747]                             if (is.null(name)) 
[13:36:59.747]                               next
[13:36:59.747]                             if (!grepl(pattern, name)) 
[13:36:59.747]                               next
[13:36:59.747]                             invokeRestart(restart)
[13:36:59.747]                             muffled <- TRUE
[13:36:59.747]                             break
[13:36:59.747]                           }
[13:36:59.747]                         }
[13:36:59.747]                       }
[13:36:59.747]                       invisible(muffled)
[13:36:59.747]                     }
[13:36:59.747]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.747]                   }
[13:36:59.747]                 }
[13:36:59.747]             }
[13:36:59.747]         }))
[13:36:59.747]     }, error = function(ex) {
[13:36:59.747]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.747]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.747]                 ...future.rng), started = ...future.startTime, 
[13:36:59.747]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.747]             version = "1.8"), class = "FutureResult")
[13:36:59.747]     }, finally = {
[13:36:59.747]         if (!identical(...future.workdir, getwd())) 
[13:36:59.747]             setwd(...future.workdir)
[13:36:59.747]         {
[13:36:59.747]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.747]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.747]             }
[13:36:59.747]             base::options(...future.oldOptions)
[13:36:59.747]             if (.Platform$OS.type == "windows") {
[13:36:59.747]                 old_names <- names(...future.oldEnvVars)
[13:36:59.747]                 envs <- base::Sys.getenv()
[13:36:59.747]                 names <- names(envs)
[13:36:59.747]                 common <- intersect(names, old_names)
[13:36:59.747]                 added <- setdiff(names, old_names)
[13:36:59.747]                 removed <- setdiff(old_names, names)
[13:36:59.747]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.747]                   envs[common]]
[13:36:59.747]                 NAMES <- toupper(changed)
[13:36:59.747]                 args <- list()
[13:36:59.747]                 for (kk in seq_along(NAMES)) {
[13:36:59.747]                   name <- changed[[kk]]
[13:36:59.747]                   NAME <- NAMES[[kk]]
[13:36:59.747]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.747]                     next
[13:36:59.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.747]                 }
[13:36:59.747]                 NAMES <- toupper(added)
[13:36:59.747]                 for (kk in seq_along(NAMES)) {
[13:36:59.747]                   name <- added[[kk]]
[13:36:59.747]                   NAME <- NAMES[[kk]]
[13:36:59.747]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.747]                     next
[13:36:59.747]                   args[[name]] <- ""
[13:36:59.747]                 }
[13:36:59.747]                 NAMES <- toupper(removed)
[13:36:59.747]                 for (kk in seq_along(NAMES)) {
[13:36:59.747]                   name <- removed[[kk]]
[13:36:59.747]                   NAME <- NAMES[[kk]]
[13:36:59.747]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.747]                     next
[13:36:59.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.747]                 }
[13:36:59.747]                 if (length(args) > 0) 
[13:36:59.747]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.747]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.747]             }
[13:36:59.747]             else {
[13:36:59.747]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.747]             }
[13:36:59.747]             {
[13:36:59.747]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.747]                   0L) {
[13:36:59.747]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.747]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.747]                   base::options(opts)
[13:36:59.747]                 }
[13:36:59.747]                 {
[13:36:59.747]                   {
[13:36:59.747]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.747]                     NULL
[13:36:59.747]                   }
[13:36:59.747]                   options(future.plan = NULL)
[13:36:59.747]                   if (is.na(NA_character_)) 
[13:36:59.747]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.747]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.747]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.747]                     .init = FALSE)
[13:36:59.747]                 }
[13:36:59.747]             }
[13:36:59.747]         }
[13:36:59.747]     })
[13:36:59.747]     if (TRUE) {
[13:36:59.747]         base::sink(type = "output", split = FALSE)
[13:36:59.747]         if (TRUE) {
[13:36:59.747]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.747]         }
[13:36:59.747]         else {
[13:36:59.747]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.747]         }
[13:36:59.747]         base::close(...future.stdout)
[13:36:59.747]         ...future.stdout <- NULL
[13:36:59.747]     }
[13:36:59.747]     ...future.result$conditions <- ...future.conditions
[13:36:59.747]     ...future.result$finished <- base::Sys.time()
[13:36:59.747]     ...future.result
[13:36:59.747] }
[13:36:59.750] MultisessionFuture started
[13:36:59.750] - Launch lazy future ... done
[13:36:59.750] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.751] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.751] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.751] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:59.752] Searching for globals ... DONE
[13:36:59.752] Resolving globals: TRUE
[13:36:59.752] Resolving any globals that are futures ...
[13:36:59.752] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:59.752] Resolving any globals that are futures ... DONE
[13:36:59.752] Resolving futures part of globals (recursively) ...
[13:36:59.752] resolve() on list ...
[13:36:59.753]  recursive: 99
[13:36:59.753]  length: 1
[13:36:59.753]  elements: ‘a’
[13:36:59.753] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.753] - Validating connection of MultisessionFuture
[13:36:59.753] - received message: FutureResult
[13:36:59.754] - Received FutureResult
[13:36:59.754] - Erased future from FutureRegistry
[13:36:59.754] result() for ClusterFuture ...
[13:36:59.754] - result already collected: FutureResult
[13:36:59.754] result() for ClusterFuture ... done
[13:36:59.754] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.754] Future #1
[13:36:59.754] result() for ClusterFuture ...
[13:36:59.754] - result already collected: FutureResult
[13:36:59.754] result() for ClusterFuture ... done
[13:36:59.755] result() for ClusterFuture ...
[13:36:59.755] - result already collected: FutureResult
[13:36:59.755] result() for ClusterFuture ... done
[13:36:59.755] A MultisessionFuture was resolved
[13:36:59.755]  length: 0 (resolved future 1)
[13:36:59.755] resolve() on list ... DONE
[13:36:59.755] - globals: [1] ‘a’
[13:36:59.755] Resolving futures part of globals (recursively) ... DONE
[13:36:59.757] The total size of the 1 globals is 1.57 MiB (1646728 bytes)
[13:36:59.758] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:36:59.758] - globals: [1] ‘a’
[13:36:59.758] - packages: [1] ‘future’
[13:36:59.758] getGlobalsAndPackages() ... DONE
[13:36:59.758] run() for ‘Future’ ...
[13:36:59.758] - state: ‘created’
[13:36:59.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.772] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.772]   - Field: ‘node’
[13:36:59.772]   - Field: ‘label’
[13:36:59.772]   - Field: ‘local’
[13:36:59.772]   - Field: ‘owner’
[13:36:59.772]   - Field: ‘envir’
[13:36:59.772]   - Field: ‘workers’
[13:36:59.773]   - Field: ‘packages’
[13:36:59.773]   - Field: ‘gc’
[13:36:59.773]   - Field: ‘conditions’
[13:36:59.773]   - Field: ‘persistent’
[13:36:59.773]   - Field: ‘expr’
[13:36:59.773]   - Field: ‘uuid’
[13:36:59.773]   - Field: ‘seed’
[13:36:59.773]   - Field: ‘version’
[13:36:59.773]   - Field: ‘result’
[13:36:59.773]   - Field: ‘asynchronous’
[13:36:59.773]   - Field: ‘calls’
[13:36:59.774]   - Field: ‘globals’
[13:36:59.774]   - Field: ‘stdout’
[13:36:59.774]   - Field: ‘earlySignal’
[13:36:59.774]   - Field: ‘lazy’
[13:36:59.774]   - Field: ‘state’
[13:36:59.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.774] - Launch lazy future ...
[13:36:59.774] Packages needed by the future expression (n = 1): ‘future’
[13:36:59.774] Packages needed by future strategies (n = 0): <none>
[13:36:59.775] {
[13:36:59.775]     {
[13:36:59.775]         {
[13:36:59.775]             ...future.startTime <- base::Sys.time()
[13:36:59.775]             {
[13:36:59.775]                 {
[13:36:59.775]                   {
[13:36:59.775]                     {
[13:36:59.775]                       {
[13:36:59.775]                         base::local({
[13:36:59.775]                           has_future <- base::requireNamespace("future", 
[13:36:59.775]                             quietly = TRUE)
[13:36:59.775]                           if (has_future) {
[13:36:59.775]                             ns <- base::getNamespace("future")
[13:36:59.775]                             version <- ns[[".package"]][["version"]]
[13:36:59.775]                             if (is.null(version)) 
[13:36:59.775]                               version <- utils::packageVersion("future")
[13:36:59.775]                           }
[13:36:59.775]                           else {
[13:36:59.775]                             version <- NULL
[13:36:59.775]                           }
[13:36:59.775]                           if (!has_future || version < "1.8.0") {
[13:36:59.775]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.775]                               "", base::R.version$version.string), 
[13:36:59.775]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:59.775]                                 base::R.version$platform, 8 * 
[13:36:59.775]                                   base::.Machine$sizeof.pointer), 
[13:36:59.775]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.775]                                 "release", "version")], collapse = " "), 
[13:36:59.775]                               hostname = base::Sys.info()[["nodename"]])
[13:36:59.775]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.775]                               info)
[13:36:59.775]                             info <- base::paste(info, collapse = "; ")
[13:36:59.775]                             if (!has_future) {
[13:36:59.775]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.775]                                 info)
[13:36:59.775]                             }
[13:36:59.775]                             else {
[13:36:59.775]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.775]                                 info, version)
[13:36:59.775]                             }
[13:36:59.775]                             base::stop(msg)
[13:36:59.775]                           }
[13:36:59.775]                         })
[13:36:59.775]                       }
[13:36:59.775]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.775]                       base::options(mc.cores = 1L)
[13:36:59.775]                     }
[13:36:59.775]                     base::local({
[13:36:59.775]                       for (pkg in "future") {
[13:36:59.775]                         base::loadNamespace(pkg)
[13:36:59.775]                         base::library(pkg, character.only = TRUE)
[13:36:59.775]                       }
[13:36:59.775]                     })
[13:36:59.775]                   }
[13:36:59.775]                   ...future.strategy.old <- future::plan("list")
[13:36:59.775]                   options(future.plan = NULL)
[13:36:59.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.775]                 }
[13:36:59.775]                 ...future.workdir <- getwd()
[13:36:59.775]             }
[13:36:59.775]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.775]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.775]         }
[13:36:59.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.775]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.775]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.775]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.775]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.775]             base::names(...future.oldOptions))
[13:36:59.775]     }
[13:36:59.775]     if (FALSE) {
[13:36:59.775]     }
[13:36:59.775]     else {
[13:36:59.775]         if (TRUE) {
[13:36:59.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.775]                 open = "w")
[13:36:59.775]         }
[13:36:59.775]         else {
[13:36:59.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.775]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.775]         }
[13:36:59.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.775]             base::sink(type = "output", split = FALSE)
[13:36:59.775]             base::close(...future.stdout)
[13:36:59.775]         }, add = TRUE)
[13:36:59.775]     }
[13:36:59.775]     ...future.frame <- base::sys.nframe()
[13:36:59.775]     ...future.conditions <- base::list()
[13:36:59.775]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.775]     if (FALSE) {
[13:36:59.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.775]     }
[13:36:59.775]     ...future.result <- base::tryCatch({
[13:36:59.775]         base::withCallingHandlers({
[13:36:59.775]             ...future.value <- base::withVisible(base::local({
[13:36:59.775]                 ...future.makeSendCondition <- base::local({
[13:36:59.775]                   sendCondition <- NULL
[13:36:59.775]                   function(frame = 1L) {
[13:36:59.775]                     if (is.function(sendCondition)) 
[13:36:59.775]                       return(sendCondition)
[13:36:59.775]                     ns <- getNamespace("parallel")
[13:36:59.775]                     if (exists("sendData", mode = "function", 
[13:36:59.775]                       envir = ns)) {
[13:36:59.775]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.775]                         envir = ns)
[13:36:59.775]                       envir <- sys.frame(frame)
[13:36:59.775]                       master <- NULL
[13:36:59.775]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.775]                         !identical(envir, emptyenv())) {
[13:36:59.775]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.775]                           inherits = FALSE)) {
[13:36:59.775]                           master <- get("master", mode = "list", 
[13:36:59.775]                             envir = envir, inherits = FALSE)
[13:36:59.775]                           if (inherits(master, c("SOCKnode", 
[13:36:59.775]                             "SOCK0node"))) {
[13:36:59.775]                             sendCondition <<- function(cond) {
[13:36:59.775]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.775]                                 success = TRUE)
[13:36:59.775]                               parallel_sendData(master, data)
[13:36:59.775]                             }
[13:36:59.775]                             return(sendCondition)
[13:36:59.775]                           }
[13:36:59.775]                         }
[13:36:59.775]                         frame <- frame + 1L
[13:36:59.775]                         envir <- sys.frame(frame)
[13:36:59.775]                       }
[13:36:59.775]                     }
[13:36:59.775]                     sendCondition <<- function(cond) NULL
[13:36:59.775]                   }
[13:36:59.775]                 })
[13:36:59.775]                 withCallingHandlers({
[13:36:59.775]                   value(a) + 1
[13:36:59.775]                 }, immediateCondition = function(cond) {
[13:36:59.775]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.775]                   sendCondition(cond)
[13:36:59.775]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.775]                   {
[13:36:59.775]                     inherits <- base::inherits
[13:36:59.775]                     invokeRestart <- base::invokeRestart
[13:36:59.775]                     is.null <- base::is.null
[13:36:59.775]                     muffled <- FALSE
[13:36:59.775]                     if (inherits(cond, "message")) {
[13:36:59.775]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.775]                       if (muffled) 
[13:36:59.775]                         invokeRestart("muffleMessage")
[13:36:59.775]                     }
[13:36:59.775]                     else if (inherits(cond, "warning")) {
[13:36:59.775]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.775]                       if (muffled) 
[13:36:59.775]                         invokeRestart("muffleWarning")
[13:36:59.775]                     }
[13:36:59.775]                     else if (inherits(cond, "condition")) {
[13:36:59.775]                       if (!is.null(pattern)) {
[13:36:59.775]                         computeRestarts <- base::computeRestarts
[13:36:59.775]                         grepl <- base::grepl
[13:36:59.775]                         restarts <- computeRestarts(cond)
[13:36:59.775]                         for (restart in restarts) {
[13:36:59.775]                           name <- restart$name
[13:36:59.775]                           if (is.null(name)) 
[13:36:59.775]                             next
[13:36:59.775]                           if (!grepl(pattern, name)) 
[13:36:59.775]                             next
[13:36:59.775]                           invokeRestart(restart)
[13:36:59.775]                           muffled <- TRUE
[13:36:59.775]                           break
[13:36:59.775]                         }
[13:36:59.775]                       }
[13:36:59.775]                     }
[13:36:59.775]                     invisible(muffled)
[13:36:59.775]                   }
[13:36:59.775]                   muffleCondition(cond)
[13:36:59.775]                 })
[13:36:59.775]             }))
[13:36:59.775]             future::FutureResult(value = ...future.value$value, 
[13:36:59.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.775]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.775]                     ...future.globalenv.names))
[13:36:59.775]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.775]         }, condition = base::local({
[13:36:59.775]             c <- base::c
[13:36:59.775]             inherits <- base::inherits
[13:36:59.775]             invokeRestart <- base::invokeRestart
[13:36:59.775]             length <- base::length
[13:36:59.775]             list <- base::list
[13:36:59.775]             seq.int <- base::seq.int
[13:36:59.775]             signalCondition <- base::signalCondition
[13:36:59.775]             sys.calls <- base::sys.calls
[13:36:59.775]             `[[` <- base::`[[`
[13:36:59.775]             `+` <- base::`+`
[13:36:59.775]             `<<-` <- base::`<<-`
[13:36:59.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.775]                   3L)]
[13:36:59.775]             }
[13:36:59.775]             function(cond) {
[13:36:59.775]                 is_error <- inherits(cond, "error")
[13:36:59.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.775]                   NULL)
[13:36:59.775]                 if (is_error) {
[13:36:59.775]                   sessionInformation <- function() {
[13:36:59.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.775]                       search = base::search(), system = base::Sys.info())
[13:36:59.775]                   }
[13:36:59.775]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.775]                     cond$call), session = sessionInformation(), 
[13:36:59.775]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.775]                   signalCondition(cond)
[13:36:59.775]                 }
[13:36:59.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.775]                 "immediateCondition"))) {
[13:36:59.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.775]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.775]                   if (TRUE && !signal) {
[13:36:59.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.775]                     {
[13:36:59.775]                       inherits <- base::inherits
[13:36:59.775]                       invokeRestart <- base::invokeRestart
[13:36:59.775]                       is.null <- base::is.null
[13:36:59.775]                       muffled <- FALSE
[13:36:59.775]                       if (inherits(cond, "message")) {
[13:36:59.775]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.775]                         if (muffled) 
[13:36:59.775]                           invokeRestart("muffleMessage")
[13:36:59.775]                       }
[13:36:59.775]                       else if (inherits(cond, "warning")) {
[13:36:59.775]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.775]                         if (muffled) 
[13:36:59.775]                           invokeRestart("muffleWarning")
[13:36:59.775]                       }
[13:36:59.775]                       else if (inherits(cond, "condition")) {
[13:36:59.775]                         if (!is.null(pattern)) {
[13:36:59.775]                           computeRestarts <- base::computeRestarts
[13:36:59.775]                           grepl <- base::grepl
[13:36:59.775]                           restarts <- computeRestarts(cond)
[13:36:59.775]                           for (restart in restarts) {
[13:36:59.775]                             name <- restart$name
[13:36:59.775]                             if (is.null(name)) 
[13:36:59.775]                               next
[13:36:59.775]                             if (!grepl(pattern, name)) 
[13:36:59.775]                               next
[13:36:59.775]                             invokeRestart(restart)
[13:36:59.775]                             muffled <- TRUE
[13:36:59.775]                             break
[13:36:59.775]                           }
[13:36:59.775]                         }
[13:36:59.775]                       }
[13:36:59.775]                       invisible(muffled)
[13:36:59.775]                     }
[13:36:59.775]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.775]                   }
[13:36:59.775]                 }
[13:36:59.775]                 else {
[13:36:59.775]                   if (TRUE) {
[13:36:59.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.775]                     {
[13:36:59.775]                       inherits <- base::inherits
[13:36:59.775]                       invokeRestart <- base::invokeRestart
[13:36:59.775]                       is.null <- base::is.null
[13:36:59.775]                       muffled <- FALSE
[13:36:59.775]                       if (inherits(cond, "message")) {
[13:36:59.775]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.775]                         if (muffled) 
[13:36:59.775]                           invokeRestart("muffleMessage")
[13:36:59.775]                       }
[13:36:59.775]                       else if (inherits(cond, "warning")) {
[13:36:59.775]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.775]                         if (muffled) 
[13:36:59.775]                           invokeRestart("muffleWarning")
[13:36:59.775]                       }
[13:36:59.775]                       else if (inherits(cond, "condition")) {
[13:36:59.775]                         if (!is.null(pattern)) {
[13:36:59.775]                           computeRestarts <- base::computeRestarts
[13:36:59.775]                           grepl <- base::grepl
[13:36:59.775]                           restarts <- computeRestarts(cond)
[13:36:59.775]                           for (restart in restarts) {
[13:36:59.775]                             name <- restart$name
[13:36:59.775]                             if (is.null(name)) 
[13:36:59.775]                               next
[13:36:59.775]                             if (!grepl(pattern, name)) 
[13:36:59.775]                               next
[13:36:59.775]                             invokeRestart(restart)
[13:36:59.775]                             muffled <- TRUE
[13:36:59.775]                             break
[13:36:59.775]                           }
[13:36:59.775]                         }
[13:36:59.775]                       }
[13:36:59.775]                       invisible(muffled)
[13:36:59.775]                     }
[13:36:59.775]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.775]                   }
[13:36:59.775]                 }
[13:36:59.775]             }
[13:36:59.775]         }))
[13:36:59.775]     }, error = function(ex) {
[13:36:59.775]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.775]                 ...future.rng), started = ...future.startTime, 
[13:36:59.775]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.775]             version = "1.8"), class = "FutureResult")
[13:36:59.775]     }, finally = {
[13:36:59.775]         if (!identical(...future.workdir, getwd())) 
[13:36:59.775]             setwd(...future.workdir)
[13:36:59.775]         {
[13:36:59.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.775]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.775]             }
[13:36:59.775]             base::options(...future.oldOptions)
[13:36:59.775]             if (.Platform$OS.type == "windows") {
[13:36:59.775]                 old_names <- names(...future.oldEnvVars)
[13:36:59.775]                 envs <- base::Sys.getenv()
[13:36:59.775]                 names <- names(envs)
[13:36:59.775]                 common <- intersect(names, old_names)
[13:36:59.775]                 added <- setdiff(names, old_names)
[13:36:59.775]                 removed <- setdiff(old_names, names)
[13:36:59.775]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.775]                   envs[common]]
[13:36:59.775]                 NAMES <- toupper(changed)
[13:36:59.775]                 args <- list()
[13:36:59.775]                 for (kk in seq_along(NAMES)) {
[13:36:59.775]                   name <- changed[[kk]]
[13:36:59.775]                   NAME <- NAMES[[kk]]
[13:36:59.775]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.775]                     next
[13:36:59.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.775]                 }
[13:36:59.775]                 NAMES <- toupper(added)
[13:36:59.775]                 for (kk in seq_along(NAMES)) {
[13:36:59.775]                   name <- added[[kk]]
[13:36:59.775]                   NAME <- NAMES[[kk]]
[13:36:59.775]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.775]                     next
[13:36:59.775]                   args[[name]] <- ""
[13:36:59.775]                 }
[13:36:59.775]                 NAMES <- toupper(removed)
[13:36:59.775]                 for (kk in seq_along(NAMES)) {
[13:36:59.775]                   name <- removed[[kk]]
[13:36:59.775]                   NAME <- NAMES[[kk]]
[13:36:59.775]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.775]                     next
[13:36:59.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.775]                 }
[13:36:59.775]                 if (length(args) > 0) 
[13:36:59.775]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.775]             }
[13:36:59.775]             else {
[13:36:59.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.775]             }
[13:36:59.775]             {
[13:36:59.775]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.775]                   0L) {
[13:36:59.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.775]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.775]                   base::options(opts)
[13:36:59.775]                 }
[13:36:59.775]                 {
[13:36:59.775]                   {
[13:36:59.775]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.775]                     NULL
[13:36:59.775]                   }
[13:36:59.775]                   options(future.plan = NULL)
[13:36:59.775]                   if (is.na(NA_character_)) 
[13:36:59.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.775]                     .init = FALSE)
[13:36:59.775]                 }
[13:36:59.775]             }
[13:36:59.775]         }
[13:36:59.775]     })
[13:36:59.775]     if (TRUE) {
[13:36:59.775]         base::sink(type = "output", split = FALSE)
[13:36:59.775]         if (TRUE) {
[13:36:59.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.775]         }
[13:36:59.775]         else {
[13:36:59.775]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.775]         }
[13:36:59.775]         base::close(...future.stdout)
[13:36:59.775]         ...future.stdout <- NULL
[13:36:59.775]     }
[13:36:59.775]     ...future.result$conditions <- ...future.conditions
[13:36:59.775]     ...future.result$finished <- base::Sys.time()
[13:36:59.775]     ...future.result
[13:36:59.775] }
[13:36:59.777] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[13:36:59.779] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[13:36:59.830] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[13:36:59.831] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[13:36:59.831] MultisessionFuture started
[13:36:59.831] - Launch lazy future ... done
[13:36:59.831] run() for ‘MultisessionFuture’ ... done
[13:36:59.831] result() for ClusterFuture ...
[13:36:59.832] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.832] - Validating connection of MultisessionFuture
[13:36:59.880] - received message: FutureResult
[13:36:59.880] - Received FutureResult
[13:36:59.880] - Erased future from FutureRegistry
[13:36:59.880] result() for ClusterFuture ...
[13:36:59.880] - result already collected: FutureResult
[13:36:59.880] result() for ClusterFuture ... done
[13:36:59.880] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.880] result() for ClusterFuture ... done
[13:36:59.881] result() for ClusterFuture ...
[13:36:59.881] - result already collected: FutureResult
[13:36:59.881] result() for ClusterFuture ... done
value(b) = 2
[13:36:59.881] result() for ClusterFuture ...
[13:36:59.881] - result already collected: FutureResult
[13:36:59.881] result() for ClusterFuture ... done
[13:36:59.881] result() for ClusterFuture ...
[13:36:59.881] - result already collected: FutureResult
[13:36:59.881] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.882] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.882] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.882] 
[13:36:59.882] Searching for globals ... DONE
[13:36:59.882] - globals: [0] <none>
[13:36:59.882] getGlobalsAndPackages() ... DONE
[13:36:59.883] run() for ‘Future’ ...
[13:36:59.883] - state: ‘created’
[13:36:59.883] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.897] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.897]   - Field: ‘node’
[13:36:59.897]   - Field: ‘label’
[13:36:59.897]   - Field: ‘local’
[13:36:59.897]   - Field: ‘owner’
[13:36:59.898]   - Field: ‘envir’
[13:36:59.898]   - Field: ‘workers’
[13:36:59.898]   - Field: ‘packages’
[13:36:59.898]   - Field: ‘gc’
[13:36:59.898]   - Field: ‘conditions’
[13:36:59.898]   - Field: ‘persistent’
[13:36:59.898]   - Field: ‘expr’
[13:36:59.898]   - Field: ‘uuid’
[13:36:59.898]   - Field: ‘seed’
[13:36:59.898]   - Field: ‘version’
[13:36:59.898]   - Field: ‘result’
[13:36:59.899]   - Field: ‘asynchronous’
[13:36:59.899]   - Field: ‘calls’
[13:36:59.899]   - Field: ‘globals’
[13:36:59.899]   - Field: ‘stdout’
[13:36:59.899]   - Field: ‘earlySignal’
[13:36:59.899]   - Field: ‘lazy’
[13:36:59.899]   - Field: ‘state’
[13:36:59.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.899] - Launch lazy future ...
[13:36:59.900] Packages needed by the future expression (n = 0): <none>
[13:36:59.900] Packages needed by future strategies (n = 0): <none>
[13:36:59.900] {
[13:36:59.900]     {
[13:36:59.900]         {
[13:36:59.900]             ...future.startTime <- base::Sys.time()
[13:36:59.900]             {
[13:36:59.900]                 {
[13:36:59.900]                   {
[13:36:59.900]                     {
[13:36:59.900]                       base::local({
[13:36:59.900]                         has_future <- base::requireNamespace("future", 
[13:36:59.900]                           quietly = TRUE)
[13:36:59.900]                         if (has_future) {
[13:36:59.900]                           ns <- base::getNamespace("future")
[13:36:59.900]                           version <- ns[[".package"]][["version"]]
[13:36:59.900]                           if (is.null(version)) 
[13:36:59.900]                             version <- utils::packageVersion("future")
[13:36:59.900]                         }
[13:36:59.900]                         else {
[13:36:59.900]                           version <- NULL
[13:36:59.900]                         }
[13:36:59.900]                         if (!has_future || version < "1.8.0") {
[13:36:59.900]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.900]                             "", base::R.version$version.string), 
[13:36:59.900]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:59.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:59.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.900]                               "release", "version")], collapse = " "), 
[13:36:59.900]                             hostname = base::Sys.info()[["nodename"]])
[13:36:59.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.900]                             info)
[13:36:59.900]                           info <- base::paste(info, collapse = "; ")
[13:36:59.900]                           if (!has_future) {
[13:36:59.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.900]                               info)
[13:36:59.900]                           }
[13:36:59.900]                           else {
[13:36:59.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.900]                               info, version)
[13:36:59.900]                           }
[13:36:59.900]                           base::stop(msg)
[13:36:59.900]                         }
[13:36:59.900]                       })
[13:36:59.900]                     }
[13:36:59.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.900]                     base::options(mc.cores = 1L)
[13:36:59.900]                   }
[13:36:59.900]                   ...future.strategy.old <- future::plan("list")
[13:36:59.900]                   options(future.plan = NULL)
[13:36:59.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.900]                 }
[13:36:59.900]                 ...future.workdir <- getwd()
[13:36:59.900]             }
[13:36:59.900]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.900]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.900]         }
[13:36:59.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.900]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.900]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.900]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.900]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.900]             base::names(...future.oldOptions))
[13:36:59.900]     }
[13:36:59.900]     if (FALSE) {
[13:36:59.900]     }
[13:36:59.900]     else {
[13:36:59.900]         if (TRUE) {
[13:36:59.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.900]                 open = "w")
[13:36:59.900]         }
[13:36:59.900]         else {
[13:36:59.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.900]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.900]         }
[13:36:59.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.900]             base::sink(type = "output", split = FALSE)
[13:36:59.900]             base::close(...future.stdout)
[13:36:59.900]         }, add = TRUE)
[13:36:59.900]     }
[13:36:59.900]     ...future.frame <- base::sys.nframe()
[13:36:59.900]     ...future.conditions <- base::list()
[13:36:59.900]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.900]     if (FALSE) {
[13:36:59.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.900]     }
[13:36:59.900]     ...future.result <- base::tryCatch({
[13:36:59.900]         base::withCallingHandlers({
[13:36:59.900]             ...future.value <- base::withVisible(base::local({
[13:36:59.900]                 ...future.makeSendCondition <- base::local({
[13:36:59.900]                   sendCondition <- NULL
[13:36:59.900]                   function(frame = 1L) {
[13:36:59.900]                     if (is.function(sendCondition)) 
[13:36:59.900]                       return(sendCondition)
[13:36:59.900]                     ns <- getNamespace("parallel")
[13:36:59.900]                     if (exists("sendData", mode = "function", 
[13:36:59.900]                       envir = ns)) {
[13:36:59.900]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.900]                         envir = ns)
[13:36:59.900]                       envir <- sys.frame(frame)
[13:36:59.900]                       master <- NULL
[13:36:59.900]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.900]                         !identical(envir, emptyenv())) {
[13:36:59.900]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.900]                           inherits = FALSE)) {
[13:36:59.900]                           master <- get("master", mode = "list", 
[13:36:59.900]                             envir = envir, inherits = FALSE)
[13:36:59.900]                           if (inherits(master, c("SOCKnode", 
[13:36:59.900]                             "SOCK0node"))) {
[13:36:59.900]                             sendCondition <<- function(cond) {
[13:36:59.900]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.900]                                 success = TRUE)
[13:36:59.900]                               parallel_sendData(master, data)
[13:36:59.900]                             }
[13:36:59.900]                             return(sendCondition)
[13:36:59.900]                           }
[13:36:59.900]                         }
[13:36:59.900]                         frame <- frame + 1L
[13:36:59.900]                         envir <- sys.frame(frame)
[13:36:59.900]                       }
[13:36:59.900]                     }
[13:36:59.900]                     sendCondition <<- function(cond) NULL
[13:36:59.900]                   }
[13:36:59.900]                 })
[13:36:59.900]                 withCallingHandlers({
[13:36:59.900]                   1
[13:36:59.900]                 }, immediateCondition = function(cond) {
[13:36:59.900]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.900]                   sendCondition(cond)
[13:36:59.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.900]                   {
[13:36:59.900]                     inherits <- base::inherits
[13:36:59.900]                     invokeRestart <- base::invokeRestart
[13:36:59.900]                     is.null <- base::is.null
[13:36:59.900]                     muffled <- FALSE
[13:36:59.900]                     if (inherits(cond, "message")) {
[13:36:59.900]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.900]                       if (muffled) 
[13:36:59.900]                         invokeRestart("muffleMessage")
[13:36:59.900]                     }
[13:36:59.900]                     else if (inherits(cond, "warning")) {
[13:36:59.900]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.900]                       if (muffled) 
[13:36:59.900]                         invokeRestart("muffleWarning")
[13:36:59.900]                     }
[13:36:59.900]                     else if (inherits(cond, "condition")) {
[13:36:59.900]                       if (!is.null(pattern)) {
[13:36:59.900]                         computeRestarts <- base::computeRestarts
[13:36:59.900]                         grepl <- base::grepl
[13:36:59.900]                         restarts <- computeRestarts(cond)
[13:36:59.900]                         for (restart in restarts) {
[13:36:59.900]                           name <- restart$name
[13:36:59.900]                           if (is.null(name)) 
[13:36:59.900]                             next
[13:36:59.900]                           if (!grepl(pattern, name)) 
[13:36:59.900]                             next
[13:36:59.900]                           invokeRestart(restart)
[13:36:59.900]                           muffled <- TRUE
[13:36:59.900]                           break
[13:36:59.900]                         }
[13:36:59.900]                       }
[13:36:59.900]                     }
[13:36:59.900]                     invisible(muffled)
[13:36:59.900]                   }
[13:36:59.900]                   muffleCondition(cond)
[13:36:59.900]                 })
[13:36:59.900]             }))
[13:36:59.900]             future::FutureResult(value = ...future.value$value, 
[13:36:59.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.900]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.900]                     ...future.globalenv.names))
[13:36:59.900]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.900]         }, condition = base::local({
[13:36:59.900]             c <- base::c
[13:36:59.900]             inherits <- base::inherits
[13:36:59.900]             invokeRestart <- base::invokeRestart
[13:36:59.900]             length <- base::length
[13:36:59.900]             list <- base::list
[13:36:59.900]             seq.int <- base::seq.int
[13:36:59.900]             signalCondition <- base::signalCondition
[13:36:59.900]             sys.calls <- base::sys.calls
[13:36:59.900]             `[[` <- base::`[[`
[13:36:59.900]             `+` <- base::`+`
[13:36:59.900]             `<<-` <- base::`<<-`
[13:36:59.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.900]                   3L)]
[13:36:59.900]             }
[13:36:59.900]             function(cond) {
[13:36:59.900]                 is_error <- inherits(cond, "error")
[13:36:59.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.900]                   NULL)
[13:36:59.900]                 if (is_error) {
[13:36:59.900]                   sessionInformation <- function() {
[13:36:59.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.900]                       search = base::search(), system = base::Sys.info())
[13:36:59.900]                   }
[13:36:59.900]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.900]                     cond$call), session = sessionInformation(), 
[13:36:59.900]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.900]                   signalCondition(cond)
[13:36:59.900]                 }
[13:36:59.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.900]                 "immediateCondition"))) {
[13:36:59.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.900]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.900]                   if (TRUE && !signal) {
[13:36:59.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.900]                     {
[13:36:59.900]                       inherits <- base::inherits
[13:36:59.900]                       invokeRestart <- base::invokeRestart
[13:36:59.900]                       is.null <- base::is.null
[13:36:59.900]                       muffled <- FALSE
[13:36:59.900]                       if (inherits(cond, "message")) {
[13:36:59.900]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.900]                         if (muffled) 
[13:36:59.900]                           invokeRestart("muffleMessage")
[13:36:59.900]                       }
[13:36:59.900]                       else if (inherits(cond, "warning")) {
[13:36:59.900]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.900]                         if (muffled) 
[13:36:59.900]                           invokeRestart("muffleWarning")
[13:36:59.900]                       }
[13:36:59.900]                       else if (inherits(cond, "condition")) {
[13:36:59.900]                         if (!is.null(pattern)) {
[13:36:59.900]                           computeRestarts <- base::computeRestarts
[13:36:59.900]                           grepl <- base::grepl
[13:36:59.900]                           restarts <- computeRestarts(cond)
[13:36:59.900]                           for (restart in restarts) {
[13:36:59.900]                             name <- restart$name
[13:36:59.900]                             if (is.null(name)) 
[13:36:59.900]                               next
[13:36:59.900]                             if (!grepl(pattern, name)) 
[13:36:59.900]                               next
[13:36:59.900]                             invokeRestart(restart)
[13:36:59.900]                             muffled <- TRUE
[13:36:59.900]                             break
[13:36:59.900]                           }
[13:36:59.900]                         }
[13:36:59.900]                       }
[13:36:59.900]                       invisible(muffled)
[13:36:59.900]                     }
[13:36:59.900]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.900]                   }
[13:36:59.900]                 }
[13:36:59.900]                 else {
[13:36:59.900]                   if (TRUE) {
[13:36:59.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.900]                     {
[13:36:59.900]                       inherits <- base::inherits
[13:36:59.900]                       invokeRestart <- base::invokeRestart
[13:36:59.900]                       is.null <- base::is.null
[13:36:59.900]                       muffled <- FALSE
[13:36:59.900]                       if (inherits(cond, "message")) {
[13:36:59.900]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.900]                         if (muffled) 
[13:36:59.900]                           invokeRestart("muffleMessage")
[13:36:59.900]                       }
[13:36:59.900]                       else if (inherits(cond, "warning")) {
[13:36:59.900]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.900]                         if (muffled) 
[13:36:59.900]                           invokeRestart("muffleWarning")
[13:36:59.900]                       }
[13:36:59.900]                       else if (inherits(cond, "condition")) {
[13:36:59.900]                         if (!is.null(pattern)) {
[13:36:59.900]                           computeRestarts <- base::computeRestarts
[13:36:59.900]                           grepl <- base::grepl
[13:36:59.900]                           restarts <- computeRestarts(cond)
[13:36:59.900]                           for (restart in restarts) {
[13:36:59.900]                             name <- restart$name
[13:36:59.900]                             if (is.null(name)) 
[13:36:59.900]                               next
[13:36:59.900]                             if (!grepl(pattern, name)) 
[13:36:59.900]                               next
[13:36:59.900]                             invokeRestart(restart)
[13:36:59.900]                             muffled <- TRUE
[13:36:59.900]                             break
[13:36:59.900]                           }
[13:36:59.900]                         }
[13:36:59.900]                       }
[13:36:59.900]                       invisible(muffled)
[13:36:59.900]                     }
[13:36:59.900]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.900]                   }
[13:36:59.900]                 }
[13:36:59.900]             }
[13:36:59.900]         }))
[13:36:59.900]     }, error = function(ex) {
[13:36:59.900]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.900]                 ...future.rng), started = ...future.startTime, 
[13:36:59.900]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.900]             version = "1.8"), class = "FutureResult")
[13:36:59.900]     }, finally = {
[13:36:59.900]         if (!identical(...future.workdir, getwd())) 
[13:36:59.900]             setwd(...future.workdir)
[13:36:59.900]         {
[13:36:59.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.900]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.900]             }
[13:36:59.900]             base::options(...future.oldOptions)
[13:36:59.900]             if (.Platform$OS.type == "windows") {
[13:36:59.900]                 old_names <- names(...future.oldEnvVars)
[13:36:59.900]                 envs <- base::Sys.getenv()
[13:36:59.900]                 names <- names(envs)
[13:36:59.900]                 common <- intersect(names, old_names)
[13:36:59.900]                 added <- setdiff(names, old_names)
[13:36:59.900]                 removed <- setdiff(old_names, names)
[13:36:59.900]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.900]                   envs[common]]
[13:36:59.900]                 NAMES <- toupper(changed)
[13:36:59.900]                 args <- list()
[13:36:59.900]                 for (kk in seq_along(NAMES)) {
[13:36:59.900]                   name <- changed[[kk]]
[13:36:59.900]                   NAME <- NAMES[[kk]]
[13:36:59.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.900]                     next
[13:36:59.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.900]                 }
[13:36:59.900]                 NAMES <- toupper(added)
[13:36:59.900]                 for (kk in seq_along(NAMES)) {
[13:36:59.900]                   name <- added[[kk]]
[13:36:59.900]                   NAME <- NAMES[[kk]]
[13:36:59.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.900]                     next
[13:36:59.900]                   args[[name]] <- ""
[13:36:59.900]                 }
[13:36:59.900]                 NAMES <- toupper(removed)
[13:36:59.900]                 for (kk in seq_along(NAMES)) {
[13:36:59.900]                   name <- removed[[kk]]
[13:36:59.900]                   NAME <- NAMES[[kk]]
[13:36:59.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.900]                     next
[13:36:59.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.900]                 }
[13:36:59.900]                 if (length(args) > 0) 
[13:36:59.900]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.900]             }
[13:36:59.900]             else {
[13:36:59.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.900]             }
[13:36:59.900]             {
[13:36:59.900]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.900]                   0L) {
[13:36:59.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.900]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.900]                   base::options(opts)
[13:36:59.900]                 }
[13:36:59.900]                 {
[13:36:59.900]                   {
[13:36:59.900]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.900]                     NULL
[13:36:59.900]                   }
[13:36:59.900]                   options(future.plan = NULL)
[13:36:59.900]                   if (is.na(NA_character_)) 
[13:36:59.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.900]                     .init = FALSE)
[13:36:59.900]                 }
[13:36:59.900]             }
[13:36:59.900]         }
[13:36:59.900]     })
[13:36:59.900]     if (TRUE) {
[13:36:59.900]         base::sink(type = "output", split = FALSE)
[13:36:59.900]         if (TRUE) {
[13:36:59.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.900]         }
[13:36:59.900]         else {
[13:36:59.900]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.900]         }
[13:36:59.900]         base::close(...future.stdout)
[13:36:59.900]         ...future.stdout <- NULL
[13:36:59.900]     }
[13:36:59.900]     ...future.result$conditions <- ...future.conditions
[13:36:59.900]     ...future.result$finished <- base::Sys.time()
[13:36:59.900]     ...future.result
[13:36:59.900] }
[13:36:59.903] MultisessionFuture started
[13:36:59.903] - Launch lazy future ... done
[13:36:59.903] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:36:59.904] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:36:59.904] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:36:59.904] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:36:59.905] Searching for globals ... DONE
[13:36:59.905] Resolving globals: TRUE
[13:36:59.905] Resolving any globals that are futures ...
[13:36:59.905] - globals: [3] ‘+’, ‘value’, ‘a’
[13:36:59.905] Resolving any globals that are futures ... DONE
[13:36:59.905] Resolving futures part of globals (recursively) ...
[13:36:59.906] resolve() on list ...
[13:36:59.906]  recursive: 99
[13:36:59.906]  length: 1
[13:36:59.906]  elements: ‘a’
[13:36:59.948] receiveMessageFromWorker() for ClusterFuture ...
[13:36:59.948] - Validating connection of MultisessionFuture
[13:36:59.948] - received message: FutureResult
[13:36:59.948] - Received FutureResult
[13:36:59.948] - Erased future from FutureRegistry
[13:36:59.948] result() for ClusterFuture ...
[13:36:59.948] - result already collected: FutureResult
[13:36:59.949] result() for ClusterFuture ... done
[13:36:59.949] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:59.949] Future #1
[13:36:59.949] result() for ClusterFuture ...
[13:36:59.949] - result already collected: FutureResult
[13:36:59.949] result() for ClusterFuture ... done
[13:36:59.949] result() for ClusterFuture ...
[13:36:59.949] - result already collected: FutureResult
[13:36:59.949] result() for ClusterFuture ... done
[13:36:59.949] A MultisessionFuture was resolved
[13:36:59.950]  length: 0 (resolved future 1)
[13:36:59.950] resolve() on list ... DONE
[13:36:59.950] - globals: [1] ‘a’
[13:36:59.950] Resolving futures part of globals (recursively) ... DONE
[13:36:59.955] The total size of the 1 globals is 1.57 MiB (1646728 bytes)
[13:36:59.955] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:36:59.955] - globals: [1] ‘a’
[13:36:59.955] - packages: [1] ‘future’
[13:36:59.955] getGlobalsAndPackages() ... DONE
[13:36:59.956] run() for ‘Future’ ...
[13:36:59.956] - state: ‘created’
[13:36:59.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:59.971] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:59.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:59.971]   - Field: ‘node’
[13:36:59.971]   - Field: ‘label’
[13:36:59.971]   - Field: ‘local’
[13:36:59.971]   - Field: ‘owner’
[13:36:59.971]   - Field: ‘envir’
[13:36:59.971]   - Field: ‘workers’
[13:36:59.971]   - Field: ‘packages’
[13:36:59.972]   - Field: ‘gc’
[13:36:59.972]   - Field: ‘conditions’
[13:36:59.972]   - Field: ‘persistent’
[13:36:59.972]   - Field: ‘expr’
[13:36:59.972]   - Field: ‘uuid’
[13:36:59.972]   - Field: ‘seed’
[13:36:59.972]   - Field: ‘version’
[13:36:59.972]   - Field: ‘result’
[13:36:59.972]   - Field: ‘asynchronous’
[13:36:59.972]   - Field: ‘calls’
[13:36:59.972]   - Field: ‘globals’
[13:36:59.973]   - Field: ‘stdout’
[13:36:59.973]   - Field: ‘earlySignal’
[13:36:59.973]   - Field: ‘lazy’
[13:36:59.973]   - Field: ‘state’
[13:36:59.973] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:59.973] - Launch lazy future ...
[13:36:59.973] Packages needed by the future expression (n = 1): ‘future’
[13:36:59.973] Packages needed by future strategies (n = 0): <none>
[13:36:59.974] {
[13:36:59.974]     {
[13:36:59.974]         {
[13:36:59.974]             ...future.startTime <- base::Sys.time()
[13:36:59.974]             {
[13:36:59.974]                 {
[13:36:59.974]                   {
[13:36:59.974]                     {
[13:36:59.974]                       {
[13:36:59.974]                         base::local({
[13:36:59.974]                           has_future <- base::requireNamespace("future", 
[13:36:59.974]                             quietly = TRUE)
[13:36:59.974]                           if (has_future) {
[13:36:59.974]                             ns <- base::getNamespace("future")
[13:36:59.974]                             version <- ns[[".package"]][["version"]]
[13:36:59.974]                             if (is.null(version)) 
[13:36:59.974]                               version <- utils::packageVersion("future")
[13:36:59.974]                           }
[13:36:59.974]                           else {
[13:36:59.974]                             version <- NULL
[13:36:59.974]                           }
[13:36:59.974]                           if (!has_future || version < "1.8.0") {
[13:36:59.974]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:59.974]                               "", base::R.version$version.string), 
[13:36:59.974]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:59.974]                                 base::R.version$platform, 8 * 
[13:36:59.974]                                   base::.Machine$sizeof.pointer), 
[13:36:59.974]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:59.974]                                 "release", "version")], collapse = " "), 
[13:36:59.974]                               hostname = base::Sys.info()[["nodename"]])
[13:36:59.974]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:59.974]                               info)
[13:36:59.974]                             info <- base::paste(info, collapse = "; ")
[13:36:59.974]                             if (!has_future) {
[13:36:59.974]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:59.974]                                 info)
[13:36:59.974]                             }
[13:36:59.974]                             else {
[13:36:59.974]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:59.974]                                 info, version)
[13:36:59.974]                             }
[13:36:59.974]                             base::stop(msg)
[13:36:59.974]                           }
[13:36:59.974]                         })
[13:36:59.974]                       }
[13:36:59.974]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:59.974]                       base::options(mc.cores = 1L)
[13:36:59.974]                     }
[13:36:59.974]                     base::local({
[13:36:59.974]                       for (pkg in "future") {
[13:36:59.974]                         base::loadNamespace(pkg)
[13:36:59.974]                         base::library(pkg, character.only = TRUE)
[13:36:59.974]                       }
[13:36:59.974]                     })
[13:36:59.974]                   }
[13:36:59.974]                   ...future.strategy.old <- future::plan("list")
[13:36:59.974]                   options(future.plan = NULL)
[13:36:59.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:59.974]                 }
[13:36:59.974]                 ...future.workdir <- getwd()
[13:36:59.974]             }
[13:36:59.974]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:59.974]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:59.974]         }
[13:36:59.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:36:59.974]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:36:59.974]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:36:59.974]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:36:59.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:59.974]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:59.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:59.974]             base::names(...future.oldOptions))
[13:36:59.974]     }
[13:36:59.974]     if (FALSE) {
[13:36:59.974]     }
[13:36:59.974]     else {
[13:36:59.974]         if (TRUE) {
[13:36:59.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:59.974]                 open = "w")
[13:36:59.974]         }
[13:36:59.974]         else {
[13:36:59.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:59.974]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:59.974]         }
[13:36:59.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:59.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:59.974]             base::sink(type = "output", split = FALSE)
[13:36:59.974]             base::close(...future.stdout)
[13:36:59.974]         }, add = TRUE)
[13:36:59.974]     }
[13:36:59.974]     ...future.frame <- base::sys.nframe()
[13:36:59.974]     ...future.conditions <- base::list()
[13:36:59.974]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:59.974]     if (FALSE) {
[13:36:59.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:59.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:59.974]     }
[13:36:59.974]     ...future.result <- base::tryCatch({
[13:36:59.974]         base::withCallingHandlers({
[13:36:59.974]             ...future.value <- base::withVisible(base::local({
[13:36:59.974]                 ...future.makeSendCondition <- base::local({
[13:36:59.974]                   sendCondition <- NULL
[13:36:59.974]                   function(frame = 1L) {
[13:36:59.974]                     if (is.function(sendCondition)) 
[13:36:59.974]                       return(sendCondition)
[13:36:59.974]                     ns <- getNamespace("parallel")
[13:36:59.974]                     if (exists("sendData", mode = "function", 
[13:36:59.974]                       envir = ns)) {
[13:36:59.974]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:59.974]                         envir = ns)
[13:36:59.974]                       envir <- sys.frame(frame)
[13:36:59.974]                       master <- NULL
[13:36:59.974]                       while (!identical(envir, .GlobalEnv) && 
[13:36:59.974]                         !identical(envir, emptyenv())) {
[13:36:59.974]                         if (exists("master", mode = "list", envir = envir, 
[13:36:59.974]                           inherits = FALSE)) {
[13:36:59.974]                           master <- get("master", mode = "list", 
[13:36:59.974]                             envir = envir, inherits = FALSE)
[13:36:59.974]                           if (inherits(master, c("SOCKnode", 
[13:36:59.974]                             "SOCK0node"))) {
[13:36:59.974]                             sendCondition <<- function(cond) {
[13:36:59.974]                               data <- list(type = "VALUE", value = cond, 
[13:36:59.974]                                 success = TRUE)
[13:36:59.974]                               parallel_sendData(master, data)
[13:36:59.974]                             }
[13:36:59.974]                             return(sendCondition)
[13:36:59.974]                           }
[13:36:59.974]                         }
[13:36:59.974]                         frame <- frame + 1L
[13:36:59.974]                         envir <- sys.frame(frame)
[13:36:59.974]                       }
[13:36:59.974]                     }
[13:36:59.974]                     sendCondition <<- function(cond) NULL
[13:36:59.974]                   }
[13:36:59.974]                 })
[13:36:59.974]                 withCallingHandlers({
[13:36:59.974]                   value(a) + 1
[13:36:59.974]                 }, immediateCondition = function(cond) {
[13:36:59.974]                   sendCondition <- ...future.makeSendCondition()
[13:36:59.974]                   sendCondition(cond)
[13:36:59.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.974]                   {
[13:36:59.974]                     inherits <- base::inherits
[13:36:59.974]                     invokeRestart <- base::invokeRestart
[13:36:59.974]                     is.null <- base::is.null
[13:36:59.974]                     muffled <- FALSE
[13:36:59.974]                     if (inherits(cond, "message")) {
[13:36:59.974]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:59.974]                       if (muffled) 
[13:36:59.974]                         invokeRestart("muffleMessage")
[13:36:59.974]                     }
[13:36:59.974]                     else if (inherits(cond, "warning")) {
[13:36:59.974]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:59.974]                       if (muffled) 
[13:36:59.974]                         invokeRestart("muffleWarning")
[13:36:59.974]                     }
[13:36:59.974]                     else if (inherits(cond, "condition")) {
[13:36:59.974]                       if (!is.null(pattern)) {
[13:36:59.974]                         computeRestarts <- base::computeRestarts
[13:36:59.974]                         grepl <- base::grepl
[13:36:59.974]                         restarts <- computeRestarts(cond)
[13:36:59.974]                         for (restart in restarts) {
[13:36:59.974]                           name <- restart$name
[13:36:59.974]                           if (is.null(name)) 
[13:36:59.974]                             next
[13:36:59.974]                           if (!grepl(pattern, name)) 
[13:36:59.974]                             next
[13:36:59.974]                           invokeRestart(restart)
[13:36:59.974]                           muffled <- TRUE
[13:36:59.974]                           break
[13:36:59.974]                         }
[13:36:59.974]                       }
[13:36:59.974]                     }
[13:36:59.974]                     invisible(muffled)
[13:36:59.974]                   }
[13:36:59.974]                   muffleCondition(cond)
[13:36:59.974]                 })
[13:36:59.974]             }))
[13:36:59.974]             future::FutureResult(value = ...future.value$value, 
[13:36:59.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.974]                   ...future.rng), globalenv = if (FALSE) 
[13:36:59.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:59.974]                     ...future.globalenv.names))
[13:36:59.974]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:59.974]         }, condition = base::local({
[13:36:59.974]             c <- base::c
[13:36:59.974]             inherits <- base::inherits
[13:36:59.974]             invokeRestart <- base::invokeRestart
[13:36:59.974]             length <- base::length
[13:36:59.974]             list <- base::list
[13:36:59.974]             seq.int <- base::seq.int
[13:36:59.974]             signalCondition <- base::signalCondition
[13:36:59.974]             sys.calls <- base::sys.calls
[13:36:59.974]             `[[` <- base::`[[`
[13:36:59.974]             `+` <- base::`+`
[13:36:59.974]             `<<-` <- base::`<<-`
[13:36:59.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:59.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:59.974]                   3L)]
[13:36:59.974]             }
[13:36:59.974]             function(cond) {
[13:36:59.974]                 is_error <- inherits(cond, "error")
[13:36:59.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:59.974]                   NULL)
[13:36:59.974]                 if (is_error) {
[13:36:59.974]                   sessionInformation <- function() {
[13:36:59.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:59.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:59.974]                       search = base::search(), system = base::Sys.info())
[13:36:59.974]                   }
[13:36:59.974]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:59.974]                     cond$call), session = sessionInformation(), 
[13:36:59.974]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:59.974]                   signalCondition(cond)
[13:36:59.974]                 }
[13:36:59.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:59.974]                 "immediateCondition"))) {
[13:36:59.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:59.974]                   ...future.conditions[[length(...future.conditions) + 
[13:36:59.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:59.974]                   if (TRUE && !signal) {
[13:36:59.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.974]                     {
[13:36:59.974]                       inherits <- base::inherits
[13:36:59.974]                       invokeRestart <- base::invokeRestart
[13:36:59.974]                       is.null <- base::is.null
[13:36:59.974]                       muffled <- FALSE
[13:36:59.974]                       if (inherits(cond, "message")) {
[13:36:59.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.974]                         if (muffled) 
[13:36:59.974]                           invokeRestart("muffleMessage")
[13:36:59.974]                       }
[13:36:59.974]                       else if (inherits(cond, "warning")) {
[13:36:59.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.974]                         if (muffled) 
[13:36:59.974]                           invokeRestart("muffleWarning")
[13:36:59.974]                       }
[13:36:59.974]                       else if (inherits(cond, "condition")) {
[13:36:59.974]                         if (!is.null(pattern)) {
[13:36:59.974]                           computeRestarts <- base::computeRestarts
[13:36:59.974]                           grepl <- base::grepl
[13:36:59.974]                           restarts <- computeRestarts(cond)
[13:36:59.974]                           for (restart in restarts) {
[13:36:59.974]                             name <- restart$name
[13:36:59.974]                             if (is.null(name)) 
[13:36:59.974]                               next
[13:36:59.974]                             if (!grepl(pattern, name)) 
[13:36:59.974]                               next
[13:36:59.974]                             invokeRestart(restart)
[13:36:59.974]                             muffled <- TRUE
[13:36:59.974]                             break
[13:36:59.974]                           }
[13:36:59.974]                         }
[13:36:59.974]                       }
[13:36:59.974]                       invisible(muffled)
[13:36:59.974]                     }
[13:36:59.974]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.974]                   }
[13:36:59.974]                 }
[13:36:59.974]                 else {
[13:36:59.974]                   if (TRUE) {
[13:36:59.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:59.974]                     {
[13:36:59.974]                       inherits <- base::inherits
[13:36:59.974]                       invokeRestart <- base::invokeRestart
[13:36:59.974]                       is.null <- base::is.null
[13:36:59.974]                       muffled <- FALSE
[13:36:59.974]                       if (inherits(cond, "message")) {
[13:36:59.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:59.974]                         if (muffled) 
[13:36:59.974]                           invokeRestart("muffleMessage")
[13:36:59.974]                       }
[13:36:59.974]                       else if (inherits(cond, "warning")) {
[13:36:59.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:59.974]                         if (muffled) 
[13:36:59.974]                           invokeRestart("muffleWarning")
[13:36:59.974]                       }
[13:36:59.974]                       else if (inherits(cond, "condition")) {
[13:36:59.974]                         if (!is.null(pattern)) {
[13:36:59.974]                           computeRestarts <- base::computeRestarts
[13:36:59.974]                           grepl <- base::grepl
[13:36:59.974]                           restarts <- computeRestarts(cond)
[13:36:59.974]                           for (restart in restarts) {
[13:36:59.974]                             name <- restart$name
[13:36:59.974]                             if (is.null(name)) 
[13:36:59.974]                               next
[13:36:59.974]                             if (!grepl(pattern, name)) 
[13:36:59.974]                               next
[13:36:59.974]                             invokeRestart(restart)
[13:36:59.974]                             muffled <- TRUE
[13:36:59.974]                             break
[13:36:59.974]                           }
[13:36:59.974]                         }
[13:36:59.974]                       }
[13:36:59.974]                       invisible(muffled)
[13:36:59.974]                     }
[13:36:59.974]                     muffleCondition(cond, pattern = "^muffle")
[13:36:59.974]                   }
[13:36:59.974]                 }
[13:36:59.974]             }
[13:36:59.974]         }))
[13:36:59.974]     }, error = function(ex) {
[13:36:59.974]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:59.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:59.974]                 ...future.rng), started = ...future.startTime, 
[13:36:59.974]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:59.974]             version = "1.8"), class = "FutureResult")
[13:36:59.974]     }, finally = {
[13:36:59.974]         if (!identical(...future.workdir, getwd())) 
[13:36:59.974]             setwd(...future.workdir)
[13:36:59.974]         {
[13:36:59.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:59.974]                 ...future.oldOptions$nwarnings <- NULL
[13:36:59.974]             }
[13:36:59.974]             base::options(...future.oldOptions)
[13:36:59.974]             if (.Platform$OS.type == "windows") {
[13:36:59.974]                 old_names <- names(...future.oldEnvVars)
[13:36:59.974]                 envs <- base::Sys.getenv()
[13:36:59.974]                 names <- names(envs)
[13:36:59.974]                 common <- intersect(names, old_names)
[13:36:59.974]                 added <- setdiff(names, old_names)
[13:36:59.974]                 removed <- setdiff(old_names, names)
[13:36:59.974]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:59.974]                   envs[common]]
[13:36:59.974]                 NAMES <- toupper(changed)
[13:36:59.974]                 args <- list()
[13:36:59.974]                 for (kk in seq_along(NAMES)) {
[13:36:59.974]                   name <- changed[[kk]]
[13:36:59.974]                   NAME <- NAMES[[kk]]
[13:36:59.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.974]                     next
[13:36:59.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.974]                 }
[13:36:59.974]                 NAMES <- toupper(added)
[13:36:59.974]                 for (kk in seq_along(NAMES)) {
[13:36:59.974]                   name <- added[[kk]]
[13:36:59.974]                   NAME <- NAMES[[kk]]
[13:36:59.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.974]                     next
[13:36:59.974]                   args[[name]] <- ""
[13:36:59.974]                 }
[13:36:59.974]                 NAMES <- toupper(removed)
[13:36:59.974]                 for (kk in seq_along(NAMES)) {
[13:36:59.974]                   name <- removed[[kk]]
[13:36:59.974]                   NAME <- NAMES[[kk]]
[13:36:59.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:59.974]                     next
[13:36:59.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:59.974]                 }
[13:36:59.974]                 if (length(args) > 0) 
[13:36:59.974]                   base::do.call(base::Sys.setenv, args = args)
[13:36:59.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:59.974]             }
[13:36:59.974]             else {
[13:36:59.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:59.974]             }
[13:36:59.974]             {
[13:36:59.974]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:59.974]                   0L) {
[13:36:59.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:59.974]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:59.974]                   base::options(opts)
[13:36:59.974]                 }
[13:36:59.974]                 {
[13:36:59.974]                   {
[13:36:59.974]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:59.974]                     NULL
[13:36:59.974]                   }
[13:36:59.974]                   options(future.plan = NULL)
[13:36:59.974]                   if (is.na(NA_character_)) 
[13:36:59.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:59.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:59.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:59.974]                     .init = FALSE)
[13:36:59.974]                 }
[13:36:59.974]             }
[13:36:59.974]         }
[13:36:59.974]     })
[13:36:59.974]     if (TRUE) {
[13:36:59.974]         base::sink(type = "output", split = FALSE)
[13:36:59.974]         if (TRUE) {
[13:36:59.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:59.974]         }
[13:36:59.974]         else {
[13:36:59.974]             ...future.result["stdout"] <- base::list(NULL)
[13:36:59.974]         }
[13:36:59.974]         base::close(...future.stdout)
[13:36:59.974]         ...future.stdout <- NULL
[13:36:59.974]     }
[13:36:59.974]     ...future.result$conditions <- ...future.conditions
[13:36:59.974]     ...future.result$finished <- base::Sys.time()
[13:36:59.974]     ...future.result
[13:36:59.974] }
[13:36:59.976] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[13:36:59.978] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[13:37:00.031] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[13:37:00.031] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[13:37:00.031] MultisessionFuture started
[13:37:00.031] - Launch lazy future ... done
[13:37:00.031] run() for ‘MultisessionFuture’ ... done
[13:37:00.032] result() for ClusterFuture ...
[13:37:00.032] receiveMessageFromWorker() for ClusterFuture ...
[13:37:00.032] - Validating connection of MultisessionFuture
[13:37:00.076] - received message: FutureResult
[13:37:00.077] - Received FutureResult
[13:37:00.077] - Erased future from FutureRegistry
[13:37:00.077] result() for ClusterFuture ...
[13:37:00.077] - result already collected: FutureResult
[13:37:00.077] result() for ClusterFuture ... done
[13:37:00.077] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:00.077] result() for ClusterFuture ... done
[13:37:00.077] result() for ClusterFuture ...
[13:37:00.077] - result already collected: FutureResult
[13:37:00.077] result() for ClusterFuture ... done
value(b) = 2
[13:37:00.078] result() for ClusterFuture ...
[13:37:00.078] - result already collected: FutureResult
[13:37:00.078] result() for ClusterFuture ... done
[13:37:00.078] result() for ClusterFuture ...
[13:37:00.078] - result already collected: FutureResult
[13:37:00.078] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:37:00.078] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:37:00.079] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:37:00.079] 
[13:37:00.079] Searching for globals ... DONE
[13:37:00.079] - globals: [0] <none>
[13:37:00.079] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:37:00.080] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:37:00.080] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:37:00.081] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:37:00.081] Searching for globals ... DONE
[13:37:00.081] Resolving globals: TRUE
[13:37:00.081] Resolving any globals that are futures ...
[13:37:00.081] - globals: [3] ‘+’, ‘value’, ‘a’
[13:37:00.081] Resolving any globals that are futures ... DONE
[13:37:00.081] Resolving futures part of globals (recursively) ...
[13:37:00.082] resolve() on list ...
[13:37:00.082]  recursive: 99
[13:37:00.082]  length: 1
[13:37:00.082]  elements: ‘a’
[13:37:00.082] run() for ‘Future’ ...
[13:37:00.082] - state: ‘created’
[13:37:00.082] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:00.099] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:00.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:00.099]   - Field: ‘node’
[13:37:00.099]   - Field: ‘label’
[13:37:00.099]   - Field: ‘local’
[13:37:00.099]   - Field: ‘owner’
[13:37:00.099]   - Field: ‘envir’
[13:37:00.099]   - Field: ‘workers’
[13:37:00.099]   - Field: ‘packages’
[13:37:00.100]   - Field: ‘gc’
[13:37:00.100]   - Field: ‘conditions’
[13:37:00.100]   - Field: ‘persistent’
[13:37:00.100]   - Field: ‘expr’
[13:37:00.100]   - Field: ‘uuid’
[13:37:00.100]   - Field: ‘seed’
[13:37:00.100]   - Field: ‘version’
[13:37:00.100]   - Field: ‘result’
[13:37:00.100]   - Field: ‘asynchronous’
[13:37:00.100]   - Field: ‘calls’
[13:37:00.101]   - Field: ‘globals’
[13:37:00.101]   - Field: ‘stdout’
[13:37:00.101]   - Field: ‘earlySignal’
[13:37:00.101]   - Field: ‘lazy’
[13:37:00.101]   - Field: ‘state’
[13:37:00.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:00.101] - Launch lazy future ...
[13:37:00.101] Packages needed by the future expression (n = 0): <none>
[13:37:00.101] Packages needed by future strategies (n = 0): <none>
[13:37:00.102] {
[13:37:00.102]     {
[13:37:00.102]         {
[13:37:00.102]             ...future.startTime <- base::Sys.time()
[13:37:00.102]             {
[13:37:00.102]                 {
[13:37:00.102]                   {
[13:37:00.102]                     {
[13:37:00.102]                       base::local({
[13:37:00.102]                         has_future <- base::requireNamespace("future", 
[13:37:00.102]                           quietly = TRUE)
[13:37:00.102]                         if (has_future) {
[13:37:00.102]                           ns <- base::getNamespace("future")
[13:37:00.102]                           version <- ns[[".package"]][["version"]]
[13:37:00.102]                           if (is.null(version)) 
[13:37:00.102]                             version <- utils::packageVersion("future")
[13:37:00.102]                         }
[13:37:00.102]                         else {
[13:37:00.102]                           version <- NULL
[13:37:00.102]                         }
[13:37:00.102]                         if (!has_future || version < "1.8.0") {
[13:37:00.102]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:00.102]                             "", base::R.version$version.string), 
[13:37:00.102]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:00.102]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:00.102]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:00.102]                               "release", "version")], collapse = " "), 
[13:37:00.102]                             hostname = base::Sys.info()[["nodename"]])
[13:37:00.102]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:00.102]                             info)
[13:37:00.102]                           info <- base::paste(info, collapse = "; ")
[13:37:00.102]                           if (!has_future) {
[13:37:00.102]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:00.102]                               info)
[13:37:00.102]                           }
[13:37:00.102]                           else {
[13:37:00.102]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:00.102]                               info, version)
[13:37:00.102]                           }
[13:37:00.102]                           base::stop(msg)
[13:37:00.102]                         }
[13:37:00.102]                       })
[13:37:00.102]                     }
[13:37:00.102]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:00.102]                     base::options(mc.cores = 1L)
[13:37:00.102]                   }
[13:37:00.102]                   ...future.strategy.old <- future::plan("list")
[13:37:00.102]                   options(future.plan = NULL)
[13:37:00.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:00.102]                 }
[13:37:00.102]                 ...future.workdir <- getwd()
[13:37:00.102]             }
[13:37:00.102]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:00.102]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:00.102]         }
[13:37:00.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:37:00.102]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:37:00.102]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:37:00.102]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:37:00.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:00.102]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:00.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:00.102]             base::names(...future.oldOptions))
[13:37:00.102]     }
[13:37:00.102]     if (FALSE) {
[13:37:00.102]     }
[13:37:00.102]     else {
[13:37:00.102]         if (TRUE) {
[13:37:00.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:00.102]                 open = "w")
[13:37:00.102]         }
[13:37:00.102]         else {
[13:37:00.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:00.102]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:00.102]         }
[13:37:00.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:00.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:00.102]             base::sink(type = "output", split = FALSE)
[13:37:00.102]             base::close(...future.stdout)
[13:37:00.102]         }, add = TRUE)
[13:37:00.102]     }
[13:37:00.102]     ...future.frame <- base::sys.nframe()
[13:37:00.102]     ...future.conditions <- base::list()
[13:37:00.102]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:00.102]     if (FALSE) {
[13:37:00.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:00.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:00.102]     }
[13:37:00.102]     ...future.result <- base::tryCatch({
[13:37:00.102]         base::withCallingHandlers({
[13:37:00.102]             ...future.value <- base::withVisible(base::local({
[13:37:00.102]                 ...future.makeSendCondition <- base::local({
[13:37:00.102]                   sendCondition <- NULL
[13:37:00.102]                   function(frame = 1L) {
[13:37:00.102]                     if (is.function(sendCondition)) 
[13:37:00.102]                       return(sendCondition)
[13:37:00.102]                     ns <- getNamespace("parallel")
[13:37:00.102]                     if (exists("sendData", mode = "function", 
[13:37:00.102]                       envir = ns)) {
[13:37:00.102]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:00.102]                         envir = ns)
[13:37:00.102]                       envir <- sys.frame(frame)
[13:37:00.102]                       master <- NULL
[13:37:00.102]                       while (!identical(envir, .GlobalEnv) && 
[13:37:00.102]                         !identical(envir, emptyenv())) {
[13:37:00.102]                         if (exists("master", mode = "list", envir = envir, 
[13:37:00.102]                           inherits = FALSE)) {
[13:37:00.102]                           master <- get("master", mode = "list", 
[13:37:00.102]                             envir = envir, inherits = FALSE)
[13:37:00.102]                           if (inherits(master, c("SOCKnode", 
[13:37:00.102]                             "SOCK0node"))) {
[13:37:00.102]                             sendCondition <<- function(cond) {
[13:37:00.102]                               data <- list(type = "VALUE", value = cond, 
[13:37:00.102]                                 success = TRUE)
[13:37:00.102]                               parallel_sendData(master, data)
[13:37:00.102]                             }
[13:37:00.102]                             return(sendCondition)
[13:37:00.102]                           }
[13:37:00.102]                         }
[13:37:00.102]                         frame <- frame + 1L
[13:37:00.102]                         envir <- sys.frame(frame)
[13:37:00.102]                       }
[13:37:00.102]                     }
[13:37:00.102]                     sendCondition <<- function(cond) NULL
[13:37:00.102]                   }
[13:37:00.102]                 })
[13:37:00.102]                 withCallingHandlers({
[13:37:00.102]                   1
[13:37:00.102]                 }, immediateCondition = function(cond) {
[13:37:00.102]                   sendCondition <- ...future.makeSendCondition()
[13:37:00.102]                   sendCondition(cond)
[13:37:00.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.102]                   {
[13:37:00.102]                     inherits <- base::inherits
[13:37:00.102]                     invokeRestart <- base::invokeRestart
[13:37:00.102]                     is.null <- base::is.null
[13:37:00.102]                     muffled <- FALSE
[13:37:00.102]                     if (inherits(cond, "message")) {
[13:37:00.102]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:00.102]                       if (muffled) 
[13:37:00.102]                         invokeRestart("muffleMessage")
[13:37:00.102]                     }
[13:37:00.102]                     else if (inherits(cond, "warning")) {
[13:37:00.102]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:00.102]                       if (muffled) 
[13:37:00.102]                         invokeRestart("muffleWarning")
[13:37:00.102]                     }
[13:37:00.102]                     else if (inherits(cond, "condition")) {
[13:37:00.102]                       if (!is.null(pattern)) {
[13:37:00.102]                         computeRestarts <- base::computeRestarts
[13:37:00.102]                         grepl <- base::grepl
[13:37:00.102]                         restarts <- computeRestarts(cond)
[13:37:00.102]                         for (restart in restarts) {
[13:37:00.102]                           name <- restart$name
[13:37:00.102]                           if (is.null(name)) 
[13:37:00.102]                             next
[13:37:00.102]                           if (!grepl(pattern, name)) 
[13:37:00.102]                             next
[13:37:00.102]                           invokeRestart(restart)
[13:37:00.102]                           muffled <- TRUE
[13:37:00.102]                           break
[13:37:00.102]                         }
[13:37:00.102]                       }
[13:37:00.102]                     }
[13:37:00.102]                     invisible(muffled)
[13:37:00.102]                   }
[13:37:00.102]                   muffleCondition(cond)
[13:37:00.102]                 })
[13:37:00.102]             }))
[13:37:00.102]             future::FutureResult(value = ...future.value$value, 
[13:37:00.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.102]                   ...future.rng), globalenv = if (FALSE) 
[13:37:00.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:00.102]                     ...future.globalenv.names))
[13:37:00.102]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:00.102]         }, condition = base::local({
[13:37:00.102]             c <- base::c
[13:37:00.102]             inherits <- base::inherits
[13:37:00.102]             invokeRestart <- base::invokeRestart
[13:37:00.102]             length <- base::length
[13:37:00.102]             list <- base::list
[13:37:00.102]             seq.int <- base::seq.int
[13:37:00.102]             signalCondition <- base::signalCondition
[13:37:00.102]             sys.calls <- base::sys.calls
[13:37:00.102]             `[[` <- base::`[[`
[13:37:00.102]             `+` <- base::`+`
[13:37:00.102]             `<<-` <- base::`<<-`
[13:37:00.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:00.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:00.102]                   3L)]
[13:37:00.102]             }
[13:37:00.102]             function(cond) {
[13:37:00.102]                 is_error <- inherits(cond, "error")
[13:37:00.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:00.102]                   NULL)
[13:37:00.102]                 if (is_error) {
[13:37:00.102]                   sessionInformation <- function() {
[13:37:00.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:00.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:00.102]                       search = base::search(), system = base::Sys.info())
[13:37:00.102]                   }
[13:37:00.102]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:00.102]                     cond$call), session = sessionInformation(), 
[13:37:00.102]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:00.102]                   signalCondition(cond)
[13:37:00.102]                 }
[13:37:00.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:00.102]                 "immediateCondition"))) {
[13:37:00.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:00.102]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:00.102]                   if (TRUE && !signal) {
[13:37:00.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.102]                     {
[13:37:00.102]                       inherits <- base::inherits
[13:37:00.102]                       invokeRestart <- base::invokeRestart
[13:37:00.102]                       is.null <- base::is.null
[13:37:00.102]                       muffled <- FALSE
[13:37:00.102]                       if (inherits(cond, "message")) {
[13:37:00.102]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.102]                         if (muffled) 
[13:37:00.102]                           invokeRestart("muffleMessage")
[13:37:00.102]                       }
[13:37:00.102]                       else if (inherits(cond, "warning")) {
[13:37:00.102]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.102]                         if (muffled) 
[13:37:00.102]                           invokeRestart("muffleWarning")
[13:37:00.102]                       }
[13:37:00.102]                       else if (inherits(cond, "condition")) {
[13:37:00.102]                         if (!is.null(pattern)) {
[13:37:00.102]                           computeRestarts <- base::computeRestarts
[13:37:00.102]                           grepl <- base::grepl
[13:37:00.102]                           restarts <- computeRestarts(cond)
[13:37:00.102]                           for (restart in restarts) {
[13:37:00.102]                             name <- restart$name
[13:37:00.102]                             if (is.null(name)) 
[13:37:00.102]                               next
[13:37:00.102]                             if (!grepl(pattern, name)) 
[13:37:00.102]                               next
[13:37:00.102]                             invokeRestart(restart)
[13:37:00.102]                             muffled <- TRUE
[13:37:00.102]                             break
[13:37:00.102]                           }
[13:37:00.102]                         }
[13:37:00.102]                       }
[13:37:00.102]                       invisible(muffled)
[13:37:00.102]                     }
[13:37:00.102]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.102]                   }
[13:37:00.102]                 }
[13:37:00.102]                 else {
[13:37:00.102]                   if (TRUE) {
[13:37:00.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.102]                     {
[13:37:00.102]                       inherits <- base::inherits
[13:37:00.102]                       invokeRestart <- base::invokeRestart
[13:37:00.102]                       is.null <- base::is.null
[13:37:00.102]                       muffled <- FALSE
[13:37:00.102]                       if (inherits(cond, "message")) {
[13:37:00.102]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.102]                         if (muffled) 
[13:37:00.102]                           invokeRestart("muffleMessage")
[13:37:00.102]                       }
[13:37:00.102]                       else if (inherits(cond, "warning")) {
[13:37:00.102]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.102]                         if (muffled) 
[13:37:00.102]                           invokeRestart("muffleWarning")
[13:37:00.102]                       }
[13:37:00.102]                       else if (inherits(cond, "condition")) {
[13:37:00.102]                         if (!is.null(pattern)) {
[13:37:00.102]                           computeRestarts <- base::computeRestarts
[13:37:00.102]                           grepl <- base::grepl
[13:37:00.102]                           restarts <- computeRestarts(cond)
[13:37:00.102]                           for (restart in restarts) {
[13:37:00.102]                             name <- restart$name
[13:37:00.102]                             if (is.null(name)) 
[13:37:00.102]                               next
[13:37:00.102]                             if (!grepl(pattern, name)) 
[13:37:00.102]                               next
[13:37:00.102]                             invokeRestart(restart)
[13:37:00.102]                             muffled <- TRUE
[13:37:00.102]                             break
[13:37:00.102]                           }
[13:37:00.102]                         }
[13:37:00.102]                       }
[13:37:00.102]                       invisible(muffled)
[13:37:00.102]                     }
[13:37:00.102]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.102]                   }
[13:37:00.102]                 }
[13:37:00.102]             }
[13:37:00.102]         }))
[13:37:00.102]     }, error = function(ex) {
[13:37:00.102]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:00.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.102]                 ...future.rng), started = ...future.startTime, 
[13:37:00.102]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:00.102]             version = "1.8"), class = "FutureResult")
[13:37:00.102]     }, finally = {
[13:37:00.102]         if (!identical(...future.workdir, getwd())) 
[13:37:00.102]             setwd(...future.workdir)
[13:37:00.102]         {
[13:37:00.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:00.102]                 ...future.oldOptions$nwarnings <- NULL
[13:37:00.102]             }
[13:37:00.102]             base::options(...future.oldOptions)
[13:37:00.102]             if (.Platform$OS.type == "windows") {
[13:37:00.102]                 old_names <- names(...future.oldEnvVars)
[13:37:00.102]                 envs <- base::Sys.getenv()
[13:37:00.102]                 names <- names(envs)
[13:37:00.102]                 common <- intersect(names, old_names)
[13:37:00.102]                 added <- setdiff(names, old_names)
[13:37:00.102]                 removed <- setdiff(old_names, names)
[13:37:00.102]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:00.102]                   envs[common]]
[13:37:00.102]                 NAMES <- toupper(changed)
[13:37:00.102]                 args <- list()
[13:37:00.102]                 for (kk in seq_along(NAMES)) {
[13:37:00.102]                   name <- changed[[kk]]
[13:37:00.102]                   NAME <- NAMES[[kk]]
[13:37:00.102]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.102]                     next
[13:37:00.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.102]                 }
[13:37:00.102]                 NAMES <- toupper(added)
[13:37:00.102]                 for (kk in seq_along(NAMES)) {
[13:37:00.102]                   name <- added[[kk]]
[13:37:00.102]                   NAME <- NAMES[[kk]]
[13:37:00.102]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.102]                     next
[13:37:00.102]                   args[[name]] <- ""
[13:37:00.102]                 }
[13:37:00.102]                 NAMES <- toupper(removed)
[13:37:00.102]                 for (kk in seq_along(NAMES)) {
[13:37:00.102]                   name <- removed[[kk]]
[13:37:00.102]                   NAME <- NAMES[[kk]]
[13:37:00.102]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.102]                     next
[13:37:00.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.102]                 }
[13:37:00.102]                 if (length(args) > 0) 
[13:37:00.102]                   base::do.call(base::Sys.setenv, args = args)
[13:37:00.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:00.102]             }
[13:37:00.102]             else {
[13:37:00.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:00.102]             }
[13:37:00.102]             {
[13:37:00.102]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:00.102]                   0L) {
[13:37:00.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:00.102]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:00.102]                   base::options(opts)
[13:37:00.102]                 }
[13:37:00.102]                 {
[13:37:00.102]                   {
[13:37:00.102]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:00.102]                     NULL
[13:37:00.102]                   }
[13:37:00.102]                   options(future.plan = NULL)
[13:37:00.102]                   if (is.na(NA_character_)) 
[13:37:00.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:00.102]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:00.102]                     .init = FALSE)
[13:37:00.102]                 }
[13:37:00.102]             }
[13:37:00.102]         }
[13:37:00.102]     })
[13:37:00.102]     if (TRUE) {
[13:37:00.102]         base::sink(type = "output", split = FALSE)
[13:37:00.102]         if (TRUE) {
[13:37:00.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:00.102]         }
[13:37:00.102]         else {
[13:37:00.102]             ...future.result["stdout"] <- base::list(NULL)
[13:37:00.102]         }
[13:37:00.102]         base::close(...future.stdout)
[13:37:00.102]         ...future.stdout <- NULL
[13:37:00.102]     }
[13:37:00.102]     ...future.result$conditions <- ...future.conditions
[13:37:00.102]     ...future.result$finished <- base::Sys.time()
[13:37:00.102]     ...future.result
[13:37:00.102] }
[13:37:00.105] MultisessionFuture started
[13:37:00.105] - Launch lazy future ... done
[13:37:00.105] run() for ‘MultisessionFuture’ ... done
[13:37:00.148] receiveMessageFromWorker() for ClusterFuture ...
[13:37:00.148] - Validating connection of MultisessionFuture
[13:37:00.148] - received message: FutureResult
[13:37:00.148] - Received FutureResult
[13:37:00.148] - Erased future from FutureRegistry
[13:37:00.149] result() for ClusterFuture ...
[13:37:00.149] - result already collected: FutureResult
[13:37:00.149] result() for ClusterFuture ... done
[13:37:00.149] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:00.149] Future #1
[13:37:00.149] result() for ClusterFuture ...
[13:37:00.149] - result already collected: FutureResult
[13:37:00.149] result() for ClusterFuture ... done
[13:37:00.149] result() for ClusterFuture ...
[13:37:00.149] - result already collected: FutureResult
[13:37:00.149] result() for ClusterFuture ... done
[13:37:00.150] A MultisessionFuture was resolved
[13:37:00.150]  length: 0 (resolved future 1)
[13:37:00.150] resolve() on list ... DONE
[13:37:00.150] - globals: [1] ‘a’
[13:37:00.150] Resolving futures part of globals (recursively) ... DONE
[13:37:00.152] The total size of the 1 globals is 1.57 MiB (1646896 bytes)
[13:37:00.152] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:37:00.153] - globals: [1] ‘a’
[13:37:00.153] - packages: [1] ‘future’
[13:37:00.153] getGlobalsAndPackages() ... DONE
[13:37:00.153] run() for ‘Future’ ...
[13:37:00.153] - state: ‘created’
[13:37:00.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:00.167] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:00.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:00.167]   - Field: ‘node’
[13:37:00.167]   - Field: ‘label’
[13:37:00.167]   - Field: ‘local’
[13:37:00.167]   - Field: ‘owner’
[13:37:00.168]   - Field: ‘envir’
[13:37:00.168]   - Field: ‘workers’
[13:37:00.168]   - Field: ‘packages’
[13:37:00.168]   - Field: ‘gc’
[13:37:00.168]   - Field: ‘conditions’
[13:37:00.168]   - Field: ‘persistent’
[13:37:00.168]   - Field: ‘expr’
[13:37:00.168]   - Field: ‘uuid’
[13:37:00.168]   - Field: ‘seed’
[13:37:00.168]   - Field: ‘version’
[13:37:00.168]   - Field: ‘result’
[13:37:00.168]   - Field: ‘asynchronous’
[13:37:00.169]   - Field: ‘calls’
[13:37:00.169]   - Field: ‘globals’
[13:37:00.169]   - Field: ‘stdout’
[13:37:00.169]   - Field: ‘earlySignal’
[13:37:00.169]   - Field: ‘lazy’
[13:37:00.169]   - Field: ‘state’
[13:37:00.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:00.169] - Launch lazy future ...
[13:37:00.169] Packages needed by the future expression (n = 1): ‘future’
[13:37:00.170] Packages needed by future strategies (n = 0): <none>
[13:37:00.170] {
[13:37:00.170]     {
[13:37:00.170]         {
[13:37:00.170]             ...future.startTime <- base::Sys.time()
[13:37:00.170]             {
[13:37:00.170]                 {
[13:37:00.170]                   {
[13:37:00.170]                     {
[13:37:00.170]                       {
[13:37:00.170]                         base::local({
[13:37:00.170]                           has_future <- base::requireNamespace("future", 
[13:37:00.170]                             quietly = TRUE)
[13:37:00.170]                           if (has_future) {
[13:37:00.170]                             ns <- base::getNamespace("future")
[13:37:00.170]                             version <- ns[[".package"]][["version"]]
[13:37:00.170]                             if (is.null(version)) 
[13:37:00.170]                               version <- utils::packageVersion("future")
[13:37:00.170]                           }
[13:37:00.170]                           else {
[13:37:00.170]                             version <- NULL
[13:37:00.170]                           }
[13:37:00.170]                           if (!has_future || version < "1.8.0") {
[13:37:00.170]                             info <- base::c(r_version = base::gsub("R version ", 
[13:37:00.170]                               "", base::R.version$version.string), 
[13:37:00.170]                               platform = base::sprintf("%s (%s-bit)", 
[13:37:00.170]                                 base::R.version$platform, 8 * 
[13:37:00.170]                                   base::.Machine$sizeof.pointer), 
[13:37:00.170]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:00.170]                                 "release", "version")], collapse = " "), 
[13:37:00.170]                               hostname = base::Sys.info()[["nodename"]])
[13:37:00.170]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:37:00.170]                               info)
[13:37:00.170]                             info <- base::paste(info, collapse = "; ")
[13:37:00.170]                             if (!has_future) {
[13:37:00.170]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:00.170]                                 info)
[13:37:00.170]                             }
[13:37:00.170]                             else {
[13:37:00.170]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:00.170]                                 info, version)
[13:37:00.170]                             }
[13:37:00.170]                             base::stop(msg)
[13:37:00.170]                           }
[13:37:00.170]                         })
[13:37:00.170]                       }
[13:37:00.170]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:00.170]                       base::options(mc.cores = 1L)
[13:37:00.170]                     }
[13:37:00.170]                     base::local({
[13:37:00.170]                       for (pkg in "future") {
[13:37:00.170]                         base::loadNamespace(pkg)
[13:37:00.170]                         base::library(pkg, character.only = TRUE)
[13:37:00.170]                       }
[13:37:00.170]                     })
[13:37:00.170]                   }
[13:37:00.170]                   ...future.strategy.old <- future::plan("list")
[13:37:00.170]                   options(future.plan = NULL)
[13:37:00.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:00.170]                 }
[13:37:00.170]                 ...future.workdir <- getwd()
[13:37:00.170]             }
[13:37:00.170]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:00.170]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:00.170]         }
[13:37:00.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:37:00.170]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:37:00.170]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:37:00.170]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:37:00.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:00.170]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:00.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:00.170]             base::names(...future.oldOptions))
[13:37:00.170]     }
[13:37:00.170]     if (FALSE) {
[13:37:00.170]     }
[13:37:00.170]     else {
[13:37:00.170]         if (TRUE) {
[13:37:00.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:00.170]                 open = "w")
[13:37:00.170]         }
[13:37:00.170]         else {
[13:37:00.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:00.170]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:00.170]         }
[13:37:00.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:00.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:00.170]             base::sink(type = "output", split = FALSE)
[13:37:00.170]             base::close(...future.stdout)
[13:37:00.170]         }, add = TRUE)
[13:37:00.170]     }
[13:37:00.170]     ...future.frame <- base::sys.nframe()
[13:37:00.170]     ...future.conditions <- base::list()
[13:37:00.170]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:00.170]     if (FALSE) {
[13:37:00.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:00.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:00.170]     }
[13:37:00.170]     ...future.result <- base::tryCatch({
[13:37:00.170]         base::withCallingHandlers({
[13:37:00.170]             ...future.value <- base::withVisible(base::local({
[13:37:00.170]                 ...future.makeSendCondition <- base::local({
[13:37:00.170]                   sendCondition <- NULL
[13:37:00.170]                   function(frame = 1L) {
[13:37:00.170]                     if (is.function(sendCondition)) 
[13:37:00.170]                       return(sendCondition)
[13:37:00.170]                     ns <- getNamespace("parallel")
[13:37:00.170]                     if (exists("sendData", mode = "function", 
[13:37:00.170]                       envir = ns)) {
[13:37:00.170]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:00.170]                         envir = ns)
[13:37:00.170]                       envir <- sys.frame(frame)
[13:37:00.170]                       master <- NULL
[13:37:00.170]                       while (!identical(envir, .GlobalEnv) && 
[13:37:00.170]                         !identical(envir, emptyenv())) {
[13:37:00.170]                         if (exists("master", mode = "list", envir = envir, 
[13:37:00.170]                           inherits = FALSE)) {
[13:37:00.170]                           master <- get("master", mode = "list", 
[13:37:00.170]                             envir = envir, inherits = FALSE)
[13:37:00.170]                           if (inherits(master, c("SOCKnode", 
[13:37:00.170]                             "SOCK0node"))) {
[13:37:00.170]                             sendCondition <<- function(cond) {
[13:37:00.170]                               data <- list(type = "VALUE", value = cond, 
[13:37:00.170]                                 success = TRUE)
[13:37:00.170]                               parallel_sendData(master, data)
[13:37:00.170]                             }
[13:37:00.170]                             return(sendCondition)
[13:37:00.170]                           }
[13:37:00.170]                         }
[13:37:00.170]                         frame <- frame + 1L
[13:37:00.170]                         envir <- sys.frame(frame)
[13:37:00.170]                       }
[13:37:00.170]                     }
[13:37:00.170]                     sendCondition <<- function(cond) NULL
[13:37:00.170]                   }
[13:37:00.170]                 })
[13:37:00.170]                 withCallingHandlers({
[13:37:00.170]                   value(a) + 1
[13:37:00.170]                 }, immediateCondition = function(cond) {
[13:37:00.170]                   sendCondition <- ...future.makeSendCondition()
[13:37:00.170]                   sendCondition(cond)
[13:37:00.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.170]                   {
[13:37:00.170]                     inherits <- base::inherits
[13:37:00.170]                     invokeRestart <- base::invokeRestart
[13:37:00.170]                     is.null <- base::is.null
[13:37:00.170]                     muffled <- FALSE
[13:37:00.170]                     if (inherits(cond, "message")) {
[13:37:00.170]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:00.170]                       if (muffled) 
[13:37:00.170]                         invokeRestart("muffleMessage")
[13:37:00.170]                     }
[13:37:00.170]                     else if (inherits(cond, "warning")) {
[13:37:00.170]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:00.170]                       if (muffled) 
[13:37:00.170]                         invokeRestart("muffleWarning")
[13:37:00.170]                     }
[13:37:00.170]                     else if (inherits(cond, "condition")) {
[13:37:00.170]                       if (!is.null(pattern)) {
[13:37:00.170]                         computeRestarts <- base::computeRestarts
[13:37:00.170]                         grepl <- base::grepl
[13:37:00.170]                         restarts <- computeRestarts(cond)
[13:37:00.170]                         for (restart in restarts) {
[13:37:00.170]                           name <- restart$name
[13:37:00.170]                           if (is.null(name)) 
[13:37:00.170]                             next
[13:37:00.170]                           if (!grepl(pattern, name)) 
[13:37:00.170]                             next
[13:37:00.170]                           invokeRestart(restart)
[13:37:00.170]                           muffled <- TRUE
[13:37:00.170]                           break
[13:37:00.170]                         }
[13:37:00.170]                       }
[13:37:00.170]                     }
[13:37:00.170]                     invisible(muffled)
[13:37:00.170]                   }
[13:37:00.170]                   muffleCondition(cond)
[13:37:00.170]                 })
[13:37:00.170]             }))
[13:37:00.170]             future::FutureResult(value = ...future.value$value, 
[13:37:00.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.170]                   ...future.rng), globalenv = if (FALSE) 
[13:37:00.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:00.170]                     ...future.globalenv.names))
[13:37:00.170]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:00.170]         }, condition = base::local({
[13:37:00.170]             c <- base::c
[13:37:00.170]             inherits <- base::inherits
[13:37:00.170]             invokeRestart <- base::invokeRestart
[13:37:00.170]             length <- base::length
[13:37:00.170]             list <- base::list
[13:37:00.170]             seq.int <- base::seq.int
[13:37:00.170]             signalCondition <- base::signalCondition
[13:37:00.170]             sys.calls <- base::sys.calls
[13:37:00.170]             `[[` <- base::`[[`
[13:37:00.170]             `+` <- base::`+`
[13:37:00.170]             `<<-` <- base::`<<-`
[13:37:00.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:00.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:00.170]                   3L)]
[13:37:00.170]             }
[13:37:00.170]             function(cond) {
[13:37:00.170]                 is_error <- inherits(cond, "error")
[13:37:00.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:00.170]                   NULL)
[13:37:00.170]                 if (is_error) {
[13:37:00.170]                   sessionInformation <- function() {
[13:37:00.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:00.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:00.170]                       search = base::search(), system = base::Sys.info())
[13:37:00.170]                   }
[13:37:00.170]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:00.170]                     cond$call), session = sessionInformation(), 
[13:37:00.170]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:00.170]                   signalCondition(cond)
[13:37:00.170]                 }
[13:37:00.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:00.170]                 "immediateCondition"))) {
[13:37:00.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:00.170]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:00.170]                   if (TRUE && !signal) {
[13:37:00.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.170]                     {
[13:37:00.170]                       inherits <- base::inherits
[13:37:00.170]                       invokeRestart <- base::invokeRestart
[13:37:00.170]                       is.null <- base::is.null
[13:37:00.170]                       muffled <- FALSE
[13:37:00.170]                       if (inherits(cond, "message")) {
[13:37:00.170]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.170]                         if (muffled) 
[13:37:00.170]                           invokeRestart("muffleMessage")
[13:37:00.170]                       }
[13:37:00.170]                       else if (inherits(cond, "warning")) {
[13:37:00.170]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.170]                         if (muffled) 
[13:37:00.170]                           invokeRestart("muffleWarning")
[13:37:00.170]                       }
[13:37:00.170]                       else if (inherits(cond, "condition")) {
[13:37:00.170]                         if (!is.null(pattern)) {
[13:37:00.170]                           computeRestarts <- base::computeRestarts
[13:37:00.170]                           grepl <- base::grepl
[13:37:00.170]                           restarts <- computeRestarts(cond)
[13:37:00.170]                           for (restart in restarts) {
[13:37:00.170]                             name <- restart$name
[13:37:00.170]                             if (is.null(name)) 
[13:37:00.170]                               next
[13:37:00.170]                             if (!grepl(pattern, name)) 
[13:37:00.170]                               next
[13:37:00.170]                             invokeRestart(restart)
[13:37:00.170]                             muffled <- TRUE
[13:37:00.170]                             break
[13:37:00.170]                           }
[13:37:00.170]                         }
[13:37:00.170]                       }
[13:37:00.170]                       invisible(muffled)
[13:37:00.170]                     }
[13:37:00.170]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.170]                   }
[13:37:00.170]                 }
[13:37:00.170]                 else {
[13:37:00.170]                   if (TRUE) {
[13:37:00.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.170]                     {
[13:37:00.170]                       inherits <- base::inherits
[13:37:00.170]                       invokeRestart <- base::invokeRestart
[13:37:00.170]                       is.null <- base::is.null
[13:37:00.170]                       muffled <- FALSE
[13:37:00.170]                       if (inherits(cond, "message")) {
[13:37:00.170]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.170]                         if (muffled) 
[13:37:00.170]                           invokeRestart("muffleMessage")
[13:37:00.170]                       }
[13:37:00.170]                       else if (inherits(cond, "warning")) {
[13:37:00.170]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.170]                         if (muffled) 
[13:37:00.170]                           invokeRestart("muffleWarning")
[13:37:00.170]                       }
[13:37:00.170]                       else if (inherits(cond, "condition")) {
[13:37:00.170]                         if (!is.null(pattern)) {
[13:37:00.170]                           computeRestarts <- base::computeRestarts
[13:37:00.170]                           grepl <- base::grepl
[13:37:00.170]                           restarts <- computeRestarts(cond)
[13:37:00.170]                           for (restart in restarts) {
[13:37:00.170]                             name <- restart$name
[13:37:00.170]                             if (is.null(name)) 
[13:37:00.170]                               next
[13:37:00.170]                             if (!grepl(pattern, name)) 
[13:37:00.170]                               next
[13:37:00.170]                             invokeRestart(restart)
[13:37:00.170]                             muffled <- TRUE
[13:37:00.170]                             break
[13:37:00.170]                           }
[13:37:00.170]                         }
[13:37:00.170]                       }
[13:37:00.170]                       invisible(muffled)
[13:37:00.170]                     }
[13:37:00.170]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.170]                   }
[13:37:00.170]                 }
[13:37:00.170]             }
[13:37:00.170]         }))
[13:37:00.170]     }, error = function(ex) {
[13:37:00.170]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:00.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.170]                 ...future.rng), started = ...future.startTime, 
[13:37:00.170]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:00.170]             version = "1.8"), class = "FutureResult")
[13:37:00.170]     }, finally = {
[13:37:00.170]         if (!identical(...future.workdir, getwd())) 
[13:37:00.170]             setwd(...future.workdir)
[13:37:00.170]         {
[13:37:00.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:00.170]                 ...future.oldOptions$nwarnings <- NULL
[13:37:00.170]             }
[13:37:00.170]             base::options(...future.oldOptions)
[13:37:00.170]             if (.Platform$OS.type == "windows") {
[13:37:00.170]                 old_names <- names(...future.oldEnvVars)
[13:37:00.170]                 envs <- base::Sys.getenv()
[13:37:00.170]                 names <- names(envs)
[13:37:00.170]                 common <- intersect(names, old_names)
[13:37:00.170]                 added <- setdiff(names, old_names)
[13:37:00.170]                 removed <- setdiff(old_names, names)
[13:37:00.170]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:00.170]                   envs[common]]
[13:37:00.170]                 NAMES <- toupper(changed)
[13:37:00.170]                 args <- list()
[13:37:00.170]                 for (kk in seq_along(NAMES)) {
[13:37:00.170]                   name <- changed[[kk]]
[13:37:00.170]                   NAME <- NAMES[[kk]]
[13:37:00.170]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.170]                     next
[13:37:00.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.170]                 }
[13:37:00.170]                 NAMES <- toupper(added)
[13:37:00.170]                 for (kk in seq_along(NAMES)) {
[13:37:00.170]                   name <- added[[kk]]
[13:37:00.170]                   NAME <- NAMES[[kk]]
[13:37:00.170]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.170]                     next
[13:37:00.170]                   args[[name]] <- ""
[13:37:00.170]                 }
[13:37:00.170]                 NAMES <- toupper(removed)
[13:37:00.170]                 for (kk in seq_along(NAMES)) {
[13:37:00.170]                   name <- removed[[kk]]
[13:37:00.170]                   NAME <- NAMES[[kk]]
[13:37:00.170]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.170]                     next
[13:37:00.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.170]                 }
[13:37:00.170]                 if (length(args) > 0) 
[13:37:00.170]                   base::do.call(base::Sys.setenv, args = args)
[13:37:00.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:00.170]             }
[13:37:00.170]             else {
[13:37:00.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:00.170]             }
[13:37:00.170]             {
[13:37:00.170]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:00.170]                   0L) {
[13:37:00.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:00.170]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:00.170]                   base::options(opts)
[13:37:00.170]                 }
[13:37:00.170]                 {
[13:37:00.170]                   {
[13:37:00.170]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:00.170]                     NULL
[13:37:00.170]                   }
[13:37:00.170]                   options(future.plan = NULL)
[13:37:00.170]                   if (is.na(NA_character_)) 
[13:37:00.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:00.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:00.170]                     .init = FALSE)
[13:37:00.170]                 }
[13:37:00.170]             }
[13:37:00.170]         }
[13:37:00.170]     })
[13:37:00.170]     if (TRUE) {
[13:37:00.170]         base::sink(type = "output", split = FALSE)
[13:37:00.170]         if (TRUE) {
[13:37:00.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:00.170]         }
[13:37:00.170]         else {
[13:37:00.170]             ...future.result["stdout"] <- base::list(NULL)
[13:37:00.170]         }
[13:37:00.170]         base::close(...future.stdout)
[13:37:00.170]         ...future.stdout <- NULL
[13:37:00.170]     }
[13:37:00.170]     ...future.result$conditions <- ...future.conditions
[13:37:00.170]     ...future.result$finished <- base::Sys.time()
[13:37:00.170]     ...future.result
[13:37:00.170] }
[13:37:00.173] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[13:37:00.175] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[13:37:00.226] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[13:37:00.227] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[13:37:00.227] MultisessionFuture started
[13:37:00.227] - Launch lazy future ... done
[13:37:00.227] run() for ‘MultisessionFuture’ ... done
[13:37:00.228] result() for ClusterFuture ...
[13:37:00.228] receiveMessageFromWorker() for ClusterFuture ...
[13:37:00.228] - Validating connection of MultisessionFuture
[13:37:00.273] - received message: FutureResult
[13:37:00.273] - Received FutureResult
[13:37:00.273] - Erased future from FutureRegistry
[13:37:00.273] result() for ClusterFuture ...
[13:37:00.273] - result already collected: FutureResult
[13:37:00.273] result() for ClusterFuture ... done
[13:37:00.273] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:00.274] result() for ClusterFuture ... done
[13:37:00.274] result() for ClusterFuture ...
[13:37:00.274] - result already collected: FutureResult
[13:37:00.274] result() for ClusterFuture ... done
value(b) = 2
[13:37:00.274] result() for ClusterFuture ...
[13:37:00.274] - result already collected: FutureResult
[13:37:00.274] result() for ClusterFuture ... done
[13:37:00.274] result() for ClusterFuture ...
[13:37:00.274] - result already collected: FutureResult
[13:37:00.275] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:37:00.275] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:37:00.275] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:37:00.275] 
[13:37:00.276] Searching for globals ... DONE
[13:37:00.276] - globals: [0] <none>
[13:37:00.276] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:37:00.276] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:37:00.276] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:37:00.277] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:37:00.277] Searching for globals ... DONE
[13:37:00.277] Resolving globals: TRUE
[13:37:00.277] Resolving any globals that are futures ...
[13:37:00.277] - globals: [3] ‘+’, ‘value’, ‘a’
[13:37:00.278] Resolving any globals that are futures ... DONE
[13:37:00.278] Resolving futures part of globals (recursively) ...
[13:37:00.278] resolve() on list ...
[13:37:00.278]  recursive: 99
[13:37:00.278]  length: 1
[13:37:00.278]  elements: ‘a’
[13:37:00.279] run() for ‘Future’ ...
[13:37:00.279] - state: ‘created’
[13:37:00.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:00.293] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:00.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:00.293]   - Field: ‘node’
[13:37:00.293]   - Field: ‘label’
[13:37:00.293]   - Field: ‘local’
[13:37:00.293]   - Field: ‘owner’
[13:37:00.294]   - Field: ‘envir’
[13:37:00.294]   - Field: ‘workers’
[13:37:00.294]   - Field: ‘packages’
[13:37:00.294]   - Field: ‘gc’
[13:37:00.294]   - Field: ‘conditions’
[13:37:00.294]   - Field: ‘persistent’
[13:37:00.294]   - Field: ‘expr’
[13:37:00.294]   - Field: ‘uuid’
[13:37:00.294]   - Field: ‘seed’
[13:37:00.294]   - Field: ‘version’
[13:37:00.295]   - Field: ‘result’
[13:37:00.295]   - Field: ‘asynchronous’
[13:37:00.295]   - Field: ‘calls’
[13:37:00.295]   - Field: ‘globals’
[13:37:00.295]   - Field: ‘stdout’
[13:37:00.295]   - Field: ‘earlySignal’
[13:37:00.295]   - Field: ‘lazy’
[13:37:00.295]   - Field: ‘state’
[13:37:00.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:00.295] - Launch lazy future ...
[13:37:00.296] Packages needed by the future expression (n = 0): <none>
[13:37:00.296] Packages needed by future strategies (n = 0): <none>
[13:37:00.296] {
[13:37:00.296]     {
[13:37:00.296]         {
[13:37:00.296]             ...future.startTime <- base::Sys.time()
[13:37:00.296]             {
[13:37:00.296]                 {
[13:37:00.296]                   {
[13:37:00.296]                     {
[13:37:00.296]                       base::local({
[13:37:00.296]                         has_future <- base::requireNamespace("future", 
[13:37:00.296]                           quietly = TRUE)
[13:37:00.296]                         if (has_future) {
[13:37:00.296]                           ns <- base::getNamespace("future")
[13:37:00.296]                           version <- ns[[".package"]][["version"]]
[13:37:00.296]                           if (is.null(version)) 
[13:37:00.296]                             version <- utils::packageVersion("future")
[13:37:00.296]                         }
[13:37:00.296]                         else {
[13:37:00.296]                           version <- NULL
[13:37:00.296]                         }
[13:37:00.296]                         if (!has_future || version < "1.8.0") {
[13:37:00.296]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:00.296]                             "", base::R.version$version.string), 
[13:37:00.296]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:00.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:00.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:00.296]                               "release", "version")], collapse = " "), 
[13:37:00.296]                             hostname = base::Sys.info()[["nodename"]])
[13:37:00.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:00.296]                             info)
[13:37:00.296]                           info <- base::paste(info, collapse = "; ")
[13:37:00.296]                           if (!has_future) {
[13:37:00.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:00.296]                               info)
[13:37:00.296]                           }
[13:37:00.296]                           else {
[13:37:00.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:00.296]                               info, version)
[13:37:00.296]                           }
[13:37:00.296]                           base::stop(msg)
[13:37:00.296]                         }
[13:37:00.296]                       })
[13:37:00.296]                     }
[13:37:00.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:00.296]                     base::options(mc.cores = 1L)
[13:37:00.296]                   }
[13:37:00.296]                   ...future.strategy.old <- future::plan("list")
[13:37:00.296]                   options(future.plan = NULL)
[13:37:00.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:00.296]                 }
[13:37:00.296]                 ...future.workdir <- getwd()
[13:37:00.296]             }
[13:37:00.296]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:00.296]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:00.296]         }
[13:37:00.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:37:00.296]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:37:00.296]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:37:00.296]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:37:00.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:00.296]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:00.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:00.296]             base::names(...future.oldOptions))
[13:37:00.296]     }
[13:37:00.296]     if (FALSE) {
[13:37:00.296]     }
[13:37:00.296]     else {
[13:37:00.296]         if (TRUE) {
[13:37:00.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:00.296]                 open = "w")
[13:37:00.296]         }
[13:37:00.296]         else {
[13:37:00.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:00.296]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:00.296]         }
[13:37:00.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:00.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:00.296]             base::sink(type = "output", split = FALSE)
[13:37:00.296]             base::close(...future.stdout)
[13:37:00.296]         }, add = TRUE)
[13:37:00.296]     }
[13:37:00.296]     ...future.frame <- base::sys.nframe()
[13:37:00.296]     ...future.conditions <- base::list()
[13:37:00.296]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:00.296]     if (FALSE) {
[13:37:00.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:00.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:00.296]     }
[13:37:00.296]     ...future.result <- base::tryCatch({
[13:37:00.296]         base::withCallingHandlers({
[13:37:00.296]             ...future.value <- base::withVisible(base::local({
[13:37:00.296]                 ...future.makeSendCondition <- base::local({
[13:37:00.296]                   sendCondition <- NULL
[13:37:00.296]                   function(frame = 1L) {
[13:37:00.296]                     if (is.function(sendCondition)) 
[13:37:00.296]                       return(sendCondition)
[13:37:00.296]                     ns <- getNamespace("parallel")
[13:37:00.296]                     if (exists("sendData", mode = "function", 
[13:37:00.296]                       envir = ns)) {
[13:37:00.296]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:00.296]                         envir = ns)
[13:37:00.296]                       envir <- sys.frame(frame)
[13:37:00.296]                       master <- NULL
[13:37:00.296]                       while (!identical(envir, .GlobalEnv) && 
[13:37:00.296]                         !identical(envir, emptyenv())) {
[13:37:00.296]                         if (exists("master", mode = "list", envir = envir, 
[13:37:00.296]                           inherits = FALSE)) {
[13:37:00.296]                           master <- get("master", mode = "list", 
[13:37:00.296]                             envir = envir, inherits = FALSE)
[13:37:00.296]                           if (inherits(master, c("SOCKnode", 
[13:37:00.296]                             "SOCK0node"))) {
[13:37:00.296]                             sendCondition <<- function(cond) {
[13:37:00.296]                               data <- list(type = "VALUE", value = cond, 
[13:37:00.296]                                 success = TRUE)
[13:37:00.296]                               parallel_sendData(master, data)
[13:37:00.296]                             }
[13:37:00.296]                             return(sendCondition)
[13:37:00.296]                           }
[13:37:00.296]                         }
[13:37:00.296]                         frame <- frame + 1L
[13:37:00.296]                         envir <- sys.frame(frame)
[13:37:00.296]                       }
[13:37:00.296]                     }
[13:37:00.296]                     sendCondition <<- function(cond) NULL
[13:37:00.296]                   }
[13:37:00.296]                 })
[13:37:00.296]                 withCallingHandlers({
[13:37:00.296]                   1
[13:37:00.296]                 }, immediateCondition = function(cond) {
[13:37:00.296]                   sendCondition <- ...future.makeSendCondition()
[13:37:00.296]                   sendCondition(cond)
[13:37:00.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.296]                   {
[13:37:00.296]                     inherits <- base::inherits
[13:37:00.296]                     invokeRestart <- base::invokeRestart
[13:37:00.296]                     is.null <- base::is.null
[13:37:00.296]                     muffled <- FALSE
[13:37:00.296]                     if (inherits(cond, "message")) {
[13:37:00.296]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:00.296]                       if (muffled) 
[13:37:00.296]                         invokeRestart("muffleMessage")
[13:37:00.296]                     }
[13:37:00.296]                     else if (inherits(cond, "warning")) {
[13:37:00.296]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:00.296]                       if (muffled) 
[13:37:00.296]                         invokeRestart("muffleWarning")
[13:37:00.296]                     }
[13:37:00.296]                     else if (inherits(cond, "condition")) {
[13:37:00.296]                       if (!is.null(pattern)) {
[13:37:00.296]                         computeRestarts <- base::computeRestarts
[13:37:00.296]                         grepl <- base::grepl
[13:37:00.296]                         restarts <- computeRestarts(cond)
[13:37:00.296]                         for (restart in restarts) {
[13:37:00.296]                           name <- restart$name
[13:37:00.296]                           if (is.null(name)) 
[13:37:00.296]                             next
[13:37:00.296]                           if (!grepl(pattern, name)) 
[13:37:00.296]                             next
[13:37:00.296]                           invokeRestart(restart)
[13:37:00.296]                           muffled <- TRUE
[13:37:00.296]                           break
[13:37:00.296]                         }
[13:37:00.296]                       }
[13:37:00.296]                     }
[13:37:00.296]                     invisible(muffled)
[13:37:00.296]                   }
[13:37:00.296]                   muffleCondition(cond)
[13:37:00.296]                 })
[13:37:00.296]             }))
[13:37:00.296]             future::FutureResult(value = ...future.value$value, 
[13:37:00.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.296]                   ...future.rng), globalenv = if (FALSE) 
[13:37:00.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:00.296]                     ...future.globalenv.names))
[13:37:00.296]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:00.296]         }, condition = base::local({
[13:37:00.296]             c <- base::c
[13:37:00.296]             inherits <- base::inherits
[13:37:00.296]             invokeRestart <- base::invokeRestart
[13:37:00.296]             length <- base::length
[13:37:00.296]             list <- base::list
[13:37:00.296]             seq.int <- base::seq.int
[13:37:00.296]             signalCondition <- base::signalCondition
[13:37:00.296]             sys.calls <- base::sys.calls
[13:37:00.296]             `[[` <- base::`[[`
[13:37:00.296]             `+` <- base::`+`
[13:37:00.296]             `<<-` <- base::`<<-`
[13:37:00.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:00.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:00.296]                   3L)]
[13:37:00.296]             }
[13:37:00.296]             function(cond) {
[13:37:00.296]                 is_error <- inherits(cond, "error")
[13:37:00.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:00.296]                   NULL)
[13:37:00.296]                 if (is_error) {
[13:37:00.296]                   sessionInformation <- function() {
[13:37:00.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:00.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:00.296]                       search = base::search(), system = base::Sys.info())
[13:37:00.296]                   }
[13:37:00.296]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:00.296]                     cond$call), session = sessionInformation(), 
[13:37:00.296]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:00.296]                   signalCondition(cond)
[13:37:00.296]                 }
[13:37:00.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:00.296]                 "immediateCondition"))) {
[13:37:00.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:00.296]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:00.296]                   if (TRUE && !signal) {
[13:37:00.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.296]                     {
[13:37:00.296]                       inherits <- base::inherits
[13:37:00.296]                       invokeRestart <- base::invokeRestart
[13:37:00.296]                       is.null <- base::is.null
[13:37:00.296]                       muffled <- FALSE
[13:37:00.296]                       if (inherits(cond, "message")) {
[13:37:00.296]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.296]                         if (muffled) 
[13:37:00.296]                           invokeRestart("muffleMessage")
[13:37:00.296]                       }
[13:37:00.296]                       else if (inherits(cond, "warning")) {
[13:37:00.296]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.296]                         if (muffled) 
[13:37:00.296]                           invokeRestart("muffleWarning")
[13:37:00.296]                       }
[13:37:00.296]                       else if (inherits(cond, "condition")) {
[13:37:00.296]                         if (!is.null(pattern)) {
[13:37:00.296]                           computeRestarts <- base::computeRestarts
[13:37:00.296]                           grepl <- base::grepl
[13:37:00.296]                           restarts <- computeRestarts(cond)
[13:37:00.296]                           for (restart in restarts) {
[13:37:00.296]                             name <- restart$name
[13:37:00.296]                             if (is.null(name)) 
[13:37:00.296]                               next
[13:37:00.296]                             if (!grepl(pattern, name)) 
[13:37:00.296]                               next
[13:37:00.296]                             invokeRestart(restart)
[13:37:00.296]                             muffled <- TRUE
[13:37:00.296]                             break
[13:37:00.296]                           }
[13:37:00.296]                         }
[13:37:00.296]                       }
[13:37:00.296]                       invisible(muffled)
[13:37:00.296]                     }
[13:37:00.296]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.296]                   }
[13:37:00.296]                 }
[13:37:00.296]                 else {
[13:37:00.296]                   if (TRUE) {
[13:37:00.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.296]                     {
[13:37:00.296]                       inherits <- base::inherits
[13:37:00.296]                       invokeRestart <- base::invokeRestart
[13:37:00.296]                       is.null <- base::is.null
[13:37:00.296]                       muffled <- FALSE
[13:37:00.296]                       if (inherits(cond, "message")) {
[13:37:00.296]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.296]                         if (muffled) 
[13:37:00.296]                           invokeRestart("muffleMessage")
[13:37:00.296]                       }
[13:37:00.296]                       else if (inherits(cond, "warning")) {
[13:37:00.296]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.296]                         if (muffled) 
[13:37:00.296]                           invokeRestart("muffleWarning")
[13:37:00.296]                       }
[13:37:00.296]                       else if (inherits(cond, "condition")) {
[13:37:00.296]                         if (!is.null(pattern)) {
[13:37:00.296]                           computeRestarts <- base::computeRestarts
[13:37:00.296]                           grepl <- base::grepl
[13:37:00.296]                           restarts <- computeRestarts(cond)
[13:37:00.296]                           for (restart in restarts) {
[13:37:00.296]                             name <- restart$name
[13:37:00.296]                             if (is.null(name)) 
[13:37:00.296]                               next
[13:37:00.296]                             if (!grepl(pattern, name)) 
[13:37:00.296]                               next
[13:37:00.296]                             invokeRestart(restart)
[13:37:00.296]                             muffled <- TRUE
[13:37:00.296]                             break
[13:37:00.296]                           }
[13:37:00.296]                         }
[13:37:00.296]                       }
[13:37:00.296]                       invisible(muffled)
[13:37:00.296]                     }
[13:37:00.296]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.296]                   }
[13:37:00.296]                 }
[13:37:00.296]             }
[13:37:00.296]         }))
[13:37:00.296]     }, error = function(ex) {
[13:37:00.296]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:00.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.296]                 ...future.rng), started = ...future.startTime, 
[13:37:00.296]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:00.296]             version = "1.8"), class = "FutureResult")
[13:37:00.296]     }, finally = {
[13:37:00.296]         if (!identical(...future.workdir, getwd())) 
[13:37:00.296]             setwd(...future.workdir)
[13:37:00.296]         {
[13:37:00.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:00.296]                 ...future.oldOptions$nwarnings <- NULL
[13:37:00.296]             }
[13:37:00.296]             base::options(...future.oldOptions)
[13:37:00.296]             if (.Platform$OS.type == "windows") {
[13:37:00.296]                 old_names <- names(...future.oldEnvVars)
[13:37:00.296]                 envs <- base::Sys.getenv()
[13:37:00.296]                 names <- names(envs)
[13:37:00.296]                 common <- intersect(names, old_names)
[13:37:00.296]                 added <- setdiff(names, old_names)
[13:37:00.296]                 removed <- setdiff(old_names, names)
[13:37:00.296]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:00.296]                   envs[common]]
[13:37:00.296]                 NAMES <- toupper(changed)
[13:37:00.296]                 args <- list()
[13:37:00.296]                 for (kk in seq_along(NAMES)) {
[13:37:00.296]                   name <- changed[[kk]]
[13:37:00.296]                   NAME <- NAMES[[kk]]
[13:37:00.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.296]                     next
[13:37:00.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.296]                 }
[13:37:00.296]                 NAMES <- toupper(added)
[13:37:00.296]                 for (kk in seq_along(NAMES)) {
[13:37:00.296]                   name <- added[[kk]]
[13:37:00.296]                   NAME <- NAMES[[kk]]
[13:37:00.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.296]                     next
[13:37:00.296]                   args[[name]] <- ""
[13:37:00.296]                 }
[13:37:00.296]                 NAMES <- toupper(removed)
[13:37:00.296]                 for (kk in seq_along(NAMES)) {
[13:37:00.296]                   name <- removed[[kk]]
[13:37:00.296]                   NAME <- NAMES[[kk]]
[13:37:00.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.296]                     next
[13:37:00.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.296]                 }
[13:37:00.296]                 if (length(args) > 0) 
[13:37:00.296]                   base::do.call(base::Sys.setenv, args = args)
[13:37:00.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:00.296]             }
[13:37:00.296]             else {
[13:37:00.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:00.296]             }
[13:37:00.296]             {
[13:37:00.296]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:00.296]                   0L) {
[13:37:00.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:00.296]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:00.296]                   base::options(opts)
[13:37:00.296]                 }
[13:37:00.296]                 {
[13:37:00.296]                   {
[13:37:00.296]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:00.296]                     NULL
[13:37:00.296]                   }
[13:37:00.296]                   options(future.plan = NULL)
[13:37:00.296]                   if (is.na(NA_character_)) 
[13:37:00.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:00.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:00.296]                     .init = FALSE)
[13:37:00.296]                 }
[13:37:00.296]             }
[13:37:00.296]         }
[13:37:00.296]     })
[13:37:00.296]     if (TRUE) {
[13:37:00.296]         base::sink(type = "output", split = FALSE)
[13:37:00.296]         if (TRUE) {
[13:37:00.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:00.296]         }
[13:37:00.296]         else {
[13:37:00.296]             ...future.result["stdout"] <- base::list(NULL)
[13:37:00.296]         }
[13:37:00.296]         base::close(...future.stdout)
[13:37:00.296]         ...future.stdout <- NULL
[13:37:00.296]     }
[13:37:00.296]     ...future.result$conditions <- ...future.conditions
[13:37:00.296]     ...future.result$finished <- base::Sys.time()
[13:37:00.296]     ...future.result
[13:37:00.296] }
[13:37:00.299] MultisessionFuture started
[13:37:00.299] - Launch lazy future ... done
[13:37:00.299] run() for ‘MultisessionFuture’ ... done
[13:37:00.344] receiveMessageFromWorker() for ClusterFuture ...
[13:37:00.344] - Validating connection of MultisessionFuture
[13:37:00.344] - received message: FutureResult
[13:37:00.344] - Received FutureResult
[13:37:00.345] - Erased future from FutureRegistry
[13:37:00.345] result() for ClusterFuture ...
[13:37:00.345] - result already collected: FutureResult
[13:37:00.345] result() for ClusterFuture ... done
[13:37:00.345] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:00.345] Future #1
[13:37:00.345] result() for ClusterFuture ...
[13:37:00.345] - result already collected: FutureResult
[13:37:00.345] result() for ClusterFuture ... done
[13:37:00.345] result() for ClusterFuture ...
[13:37:00.345] - result already collected: FutureResult
[13:37:00.345] result() for ClusterFuture ... done
[13:37:00.346] A MultisessionFuture was resolved
[13:37:00.346]  length: 0 (resolved future 1)
[13:37:00.346] resolve() on list ... DONE
[13:37:00.346] - globals: [1] ‘a’
[13:37:00.346] Resolving futures part of globals (recursively) ... DONE
[13:37:00.348] The total size of the 1 globals is 1.57 MiB (1646896 bytes)
[13:37:00.348] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:37:00.349] - globals: [1] ‘a’
[13:37:00.349] - packages: [1] ‘future’
[13:37:00.349] getGlobalsAndPackages() ... DONE
[13:37:00.349] run() for ‘Future’ ...
[13:37:00.349] - state: ‘created’
[13:37:00.349] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:00.363] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:00.363] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:00.363]   - Field: ‘node’
[13:37:00.363]   - Field: ‘label’
[13:37:00.363]   - Field: ‘local’
[13:37:00.364]   - Field: ‘owner’
[13:37:00.364]   - Field: ‘envir’
[13:37:00.364]   - Field: ‘workers’
[13:37:00.364]   - Field: ‘packages’
[13:37:00.364]   - Field: ‘gc’
[13:37:00.364]   - Field: ‘conditions’
[13:37:00.364]   - Field: ‘persistent’
[13:37:00.364]   - Field: ‘expr’
[13:37:00.364]   - Field: ‘uuid’
[13:37:00.364]   - Field: ‘seed’
[13:37:00.364]   - Field: ‘version’
[13:37:00.365]   - Field: ‘result’
[13:37:00.365]   - Field: ‘asynchronous’
[13:37:00.365]   - Field: ‘calls’
[13:37:00.365]   - Field: ‘globals’
[13:37:00.365]   - Field: ‘stdout’
[13:37:00.365]   - Field: ‘earlySignal’
[13:37:00.365]   - Field: ‘lazy’
[13:37:00.368]   - Field: ‘state’
[13:37:00.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:00.368] - Launch lazy future ...
[13:37:00.368] Packages needed by the future expression (n = 1): ‘future’
[13:37:00.369] Packages needed by future strategies (n = 0): <none>
[13:37:00.369] {
[13:37:00.369]     {
[13:37:00.369]         {
[13:37:00.369]             ...future.startTime <- base::Sys.time()
[13:37:00.369]             {
[13:37:00.369]                 {
[13:37:00.369]                   {
[13:37:00.369]                     {
[13:37:00.369]                       {
[13:37:00.369]                         base::local({
[13:37:00.369]                           has_future <- base::requireNamespace("future", 
[13:37:00.369]                             quietly = TRUE)
[13:37:00.369]                           if (has_future) {
[13:37:00.369]                             ns <- base::getNamespace("future")
[13:37:00.369]                             version <- ns[[".package"]][["version"]]
[13:37:00.369]                             if (is.null(version)) 
[13:37:00.369]                               version <- utils::packageVersion("future")
[13:37:00.369]                           }
[13:37:00.369]                           else {
[13:37:00.369]                             version <- NULL
[13:37:00.369]                           }
[13:37:00.369]                           if (!has_future || version < "1.8.0") {
[13:37:00.369]                             info <- base::c(r_version = base::gsub("R version ", 
[13:37:00.369]                               "", base::R.version$version.string), 
[13:37:00.369]                               platform = base::sprintf("%s (%s-bit)", 
[13:37:00.369]                                 base::R.version$platform, 8 * 
[13:37:00.369]                                   base::.Machine$sizeof.pointer), 
[13:37:00.369]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:00.369]                                 "release", "version")], collapse = " "), 
[13:37:00.369]                               hostname = base::Sys.info()[["nodename"]])
[13:37:00.369]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:37:00.369]                               info)
[13:37:00.369]                             info <- base::paste(info, collapse = "; ")
[13:37:00.369]                             if (!has_future) {
[13:37:00.369]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:00.369]                                 info)
[13:37:00.369]                             }
[13:37:00.369]                             else {
[13:37:00.369]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:00.369]                                 info, version)
[13:37:00.369]                             }
[13:37:00.369]                             base::stop(msg)
[13:37:00.369]                           }
[13:37:00.369]                         })
[13:37:00.369]                       }
[13:37:00.369]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:00.369]                       base::options(mc.cores = 1L)
[13:37:00.369]                     }
[13:37:00.369]                     base::local({
[13:37:00.369]                       for (pkg in "future") {
[13:37:00.369]                         base::loadNamespace(pkg)
[13:37:00.369]                         base::library(pkg, character.only = TRUE)
[13:37:00.369]                       }
[13:37:00.369]                     })
[13:37:00.369]                   }
[13:37:00.369]                   ...future.strategy.old <- future::plan("list")
[13:37:00.369]                   options(future.plan = NULL)
[13:37:00.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:00.369]                 }
[13:37:00.369]                 ...future.workdir <- getwd()
[13:37:00.369]             }
[13:37:00.369]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:00.369]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:00.369]         }
[13:37:00.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:37:00.369]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:37:00.369]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:37:00.369]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:37:00.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:00.369]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:00.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:00.369]             base::names(...future.oldOptions))
[13:37:00.369]     }
[13:37:00.369]     if (FALSE) {
[13:37:00.369]     }
[13:37:00.369]     else {
[13:37:00.369]         if (TRUE) {
[13:37:00.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:00.369]                 open = "w")
[13:37:00.369]         }
[13:37:00.369]         else {
[13:37:00.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:00.369]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:00.369]         }
[13:37:00.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:00.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:00.369]             base::sink(type = "output", split = FALSE)
[13:37:00.369]             base::close(...future.stdout)
[13:37:00.369]         }, add = TRUE)
[13:37:00.369]     }
[13:37:00.369]     ...future.frame <- base::sys.nframe()
[13:37:00.369]     ...future.conditions <- base::list()
[13:37:00.369]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:00.369]     if (FALSE) {
[13:37:00.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:00.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:00.369]     }
[13:37:00.369]     ...future.result <- base::tryCatch({
[13:37:00.369]         base::withCallingHandlers({
[13:37:00.369]             ...future.value <- base::withVisible(base::local({
[13:37:00.369]                 ...future.makeSendCondition <- base::local({
[13:37:00.369]                   sendCondition <- NULL
[13:37:00.369]                   function(frame = 1L) {
[13:37:00.369]                     if (is.function(sendCondition)) 
[13:37:00.369]                       return(sendCondition)
[13:37:00.369]                     ns <- getNamespace("parallel")
[13:37:00.369]                     if (exists("sendData", mode = "function", 
[13:37:00.369]                       envir = ns)) {
[13:37:00.369]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:00.369]                         envir = ns)
[13:37:00.369]                       envir <- sys.frame(frame)
[13:37:00.369]                       master <- NULL
[13:37:00.369]                       while (!identical(envir, .GlobalEnv) && 
[13:37:00.369]                         !identical(envir, emptyenv())) {
[13:37:00.369]                         if (exists("master", mode = "list", envir = envir, 
[13:37:00.369]                           inherits = FALSE)) {
[13:37:00.369]                           master <- get("master", mode = "list", 
[13:37:00.369]                             envir = envir, inherits = FALSE)
[13:37:00.369]                           if (inherits(master, c("SOCKnode", 
[13:37:00.369]                             "SOCK0node"))) {
[13:37:00.369]                             sendCondition <<- function(cond) {
[13:37:00.369]                               data <- list(type = "VALUE", value = cond, 
[13:37:00.369]                                 success = TRUE)
[13:37:00.369]                               parallel_sendData(master, data)
[13:37:00.369]                             }
[13:37:00.369]                             return(sendCondition)
[13:37:00.369]                           }
[13:37:00.369]                         }
[13:37:00.369]                         frame <- frame + 1L
[13:37:00.369]                         envir <- sys.frame(frame)
[13:37:00.369]                       }
[13:37:00.369]                     }
[13:37:00.369]                     sendCondition <<- function(cond) NULL
[13:37:00.369]                   }
[13:37:00.369]                 })
[13:37:00.369]                 withCallingHandlers({
[13:37:00.369]                   value(a) + 1
[13:37:00.369]                 }, immediateCondition = function(cond) {
[13:37:00.369]                   sendCondition <- ...future.makeSendCondition()
[13:37:00.369]                   sendCondition(cond)
[13:37:00.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.369]                   {
[13:37:00.369]                     inherits <- base::inherits
[13:37:00.369]                     invokeRestart <- base::invokeRestart
[13:37:00.369]                     is.null <- base::is.null
[13:37:00.369]                     muffled <- FALSE
[13:37:00.369]                     if (inherits(cond, "message")) {
[13:37:00.369]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:00.369]                       if (muffled) 
[13:37:00.369]                         invokeRestart("muffleMessage")
[13:37:00.369]                     }
[13:37:00.369]                     else if (inherits(cond, "warning")) {
[13:37:00.369]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:00.369]                       if (muffled) 
[13:37:00.369]                         invokeRestart("muffleWarning")
[13:37:00.369]                     }
[13:37:00.369]                     else if (inherits(cond, "condition")) {
[13:37:00.369]                       if (!is.null(pattern)) {
[13:37:00.369]                         computeRestarts <- base::computeRestarts
[13:37:00.369]                         grepl <- base::grepl
[13:37:00.369]                         restarts <- computeRestarts(cond)
[13:37:00.369]                         for (restart in restarts) {
[13:37:00.369]                           name <- restart$name
[13:37:00.369]                           if (is.null(name)) 
[13:37:00.369]                             next
[13:37:00.369]                           if (!grepl(pattern, name)) 
[13:37:00.369]                             next
[13:37:00.369]                           invokeRestart(restart)
[13:37:00.369]                           muffled <- TRUE
[13:37:00.369]                           break
[13:37:00.369]                         }
[13:37:00.369]                       }
[13:37:00.369]                     }
[13:37:00.369]                     invisible(muffled)
[13:37:00.369]                   }
[13:37:00.369]                   muffleCondition(cond)
[13:37:00.369]                 })
[13:37:00.369]             }))
[13:37:00.369]             future::FutureResult(value = ...future.value$value, 
[13:37:00.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.369]                   ...future.rng), globalenv = if (FALSE) 
[13:37:00.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:00.369]                     ...future.globalenv.names))
[13:37:00.369]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:00.369]         }, condition = base::local({
[13:37:00.369]             c <- base::c
[13:37:00.369]             inherits <- base::inherits
[13:37:00.369]             invokeRestart <- base::invokeRestart
[13:37:00.369]             length <- base::length
[13:37:00.369]             list <- base::list
[13:37:00.369]             seq.int <- base::seq.int
[13:37:00.369]             signalCondition <- base::signalCondition
[13:37:00.369]             sys.calls <- base::sys.calls
[13:37:00.369]             `[[` <- base::`[[`
[13:37:00.369]             `+` <- base::`+`
[13:37:00.369]             `<<-` <- base::`<<-`
[13:37:00.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:00.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:00.369]                   3L)]
[13:37:00.369]             }
[13:37:00.369]             function(cond) {
[13:37:00.369]                 is_error <- inherits(cond, "error")
[13:37:00.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:00.369]                   NULL)
[13:37:00.369]                 if (is_error) {
[13:37:00.369]                   sessionInformation <- function() {
[13:37:00.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:00.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:00.369]                       search = base::search(), system = base::Sys.info())
[13:37:00.369]                   }
[13:37:00.369]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:00.369]                     cond$call), session = sessionInformation(), 
[13:37:00.369]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:00.369]                   signalCondition(cond)
[13:37:00.369]                 }
[13:37:00.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:00.369]                 "immediateCondition"))) {
[13:37:00.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:00.369]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:00.369]                   if (TRUE && !signal) {
[13:37:00.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.369]                     {
[13:37:00.369]                       inherits <- base::inherits
[13:37:00.369]                       invokeRestart <- base::invokeRestart
[13:37:00.369]                       is.null <- base::is.null
[13:37:00.369]                       muffled <- FALSE
[13:37:00.369]                       if (inherits(cond, "message")) {
[13:37:00.369]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.369]                         if (muffled) 
[13:37:00.369]                           invokeRestart("muffleMessage")
[13:37:00.369]                       }
[13:37:00.369]                       else if (inherits(cond, "warning")) {
[13:37:00.369]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.369]                         if (muffled) 
[13:37:00.369]                           invokeRestart("muffleWarning")
[13:37:00.369]                       }
[13:37:00.369]                       else if (inherits(cond, "condition")) {
[13:37:00.369]                         if (!is.null(pattern)) {
[13:37:00.369]                           computeRestarts <- base::computeRestarts
[13:37:00.369]                           grepl <- base::grepl
[13:37:00.369]                           restarts <- computeRestarts(cond)
[13:37:00.369]                           for (restart in restarts) {
[13:37:00.369]                             name <- restart$name
[13:37:00.369]                             if (is.null(name)) 
[13:37:00.369]                               next
[13:37:00.369]                             if (!grepl(pattern, name)) 
[13:37:00.369]                               next
[13:37:00.369]                             invokeRestart(restart)
[13:37:00.369]                             muffled <- TRUE
[13:37:00.369]                             break
[13:37:00.369]                           }
[13:37:00.369]                         }
[13:37:00.369]                       }
[13:37:00.369]                       invisible(muffled)
[13:37:00.369]                     }
[13:37:00.369]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.369]                   }
[13:37:00.369]                 }
[13:37:00.369]                 else {
[13:37:00.369]                   if (TRUE) {
[13:37:00.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.369]                     {
[13:37:00.369]                       inherits <- base::inherits
[13:37:00.369]                       invokeRestart <- base::invokeRestart
[13:37:00.369]                       is.null <- base::is.null
[13:37:00.369]                       muffled <- FALSE
[13:37:00.369]                       if (inherits(cond, "message")) {
[13:37:00.369]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.369]                         if (muffled) 
[13:37:00.369]                           invokeRestart("muffleMessage")
[13:37:00.369]                       }
[13:37:00.369]                       else if (inherits(cond, "warning")) {
[13:37:00.369]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.369]                         if (muffled) 
[13:37:00.369]                           invokeRestart("muffleWarning")
[13:37:00.369]                       }
[13:37:00.369]                       else if (inherits(cond, "condition")) {
[13:37:00.369]                         if (!is.null(pattern)) {
[13:37:00.369]                           computeRestarts <- base::computeRestarts
[13:37:00.369]                           grepl <- base::grepl
[13:37:00.369]                           restarts <- computeRestarts(cond)
[13:37:00.369]                           for (restart in restarts) {
[13:37:00.369]                             name <- restart$name
[13:37:00.369]                             if (is.null(name)) 
[13:37:00.369]                               next
[13:37:00.369]                             if (!grepl(pattern, name)) 
[13:37:00.369]                               next
[13:37:00.369]                             invokeRestart(restart)
[13:37:00.369]                             muffled <- TRUE
[13:37:00.369]                             break
[13:37:00.369]                           }
[13:37:00.369]                         }
[13:37:00.369]                       }
[13:37:00.369]                       invisible(muffled)
[13:37:00.369]                     }
[13:37:00.369]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.369]                   }
[13:37:00.369]                 }
[13:37:00.369]             }
[13:37:00.369]         }))
[13:37:00.369]     }, error = function(ex) {
[13:37:00.369]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:00.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.369]                 ...future.rng), started = ...future.startTime, 
[13:37:00.369]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:00.369]             version = "1.8"), class = "FutureResult")
[13:37:00.369]     }, finally = {
[13:37:00.369]         if (!identical(...future.workdir, getwd())) 
[13:37:00.369]             setwd(...future.workdir)
[13:37:00.369]         {
[13:37:00.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:00.369]                 ...future.oldOptions$nwarnings <- NULL
[13:37:00.369]             }
[13:37:00.369]             base::options(...future.oldOptions)
[13:37:00.369]             if (.Platform$OS.type == "windows") {
[13:37:00.369]                 old_names <- names(...future.oldEnvVars)
[13:37:00.369]                 envs <- base::Sys.getenv()
[13:37:00.369]                 names <- names(envs)
[13:37:00.369]                 common <- intersect(names, old_names)
[13:37:00.369]                 added <- setdiff(names, old_names)
[13:37:00.369]                 removed <- setdiff(old_names, names)
[13:37:00.369]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:00.369]                   envs[common]]
[13:37:00.369]                 NAMES <- toupper(changed)
[13:37:00.369]                 args <- list()
[13:37:00.369]                 for (kk in seq_along(NAMES)) {
[13:37:00.369]                   name <- changed[[kk]]
[13:37:00.369]                   NAME <- NAMES[[kk]]
[13:37:00.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.369]                     next
[13:37:00.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.369]                 }
[13:37:00.369]                 NAMES <- toupper(added)
[13:37:00.369]                 for (kk in seq_along(NAMES)) {
[13:37:00.369]                   name <- added[[kk]]
[13:37:00.369]                   NAME <- NAMES[[kk]]
[13:37:00.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.369]                     next
[13:37:00.369]                   args[[name]] <- ""
[13:37:00.369]                 }
[13:37:00.369]                 NAMES <- toupper(removed)
[13:37:00.369]                 for (kk in seq_along(NAMES)) {
[13:37:00.369]                   name <- removed[[kk]]
[13:37:00.369]                   NAME <- NAMES[[kk]]
[13:37:00.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.369]                     next
[13:37:00.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.369]                 }
[13:37:00.369]                 if (length(args) > 0) 
[13:37:00.369]                   base::do.call(base::Sys.setenv, args = args)
[13:37:00.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:00.369]             }
[13:37:00.369]             else {
[13:37:00.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:00.369]             }
[13:37:00.369]             {
[13:37:00.369]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:00.369]                   0L) {
[13:37:00.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:00.369]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:00.369]                   base::options(opts)
[13:37:00.369]                 }
[13:37:00.369]                 {
[13:37:00.369]                   {
[13:37:00.369]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:00.369]                     NULL
[13:37:00.369]                   }
[13:37:00.369]                   options(future.plan = NULL)
[13:37:00.369]                   if (is.na(NA_character_)) 
[13:37:00.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:00.369]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:00.369]                     .init = FALSE)
[13:37:00.369]                 }
[13:37:00.369]             }
[13:37:00.369]         }
[13:37:00.369]     })
[13:37:00.369]     if (TRUE) {
[13:37:00.369]         base::sink(type = "output", split = FALSE)
[13:37:00.369]         if (TRUE) {
[13:37:00.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:00.369]         }
[13:37:00.369]         else {
[13:37:00.369]             ...future.result["stdout"] <- base::list(NULL)
[13:37:00.369]         }
[13:37:00.369]         base::close(...future.stdout)
[13:37:00.369]         ...future.stdout <- NULL
[13:37:00.369]     }
[13:37:00.369]     ...future.result$conditions <- ...future.conditions
[13:37:00.369]     ...future.result$finished <- base::Sys.time()
[13:37:00.369]     ...future.result
[13:37:00.369] }
[13:37:00.372] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[13:37:00.373] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[13:37:00.427] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[13:37:00.427] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[13:37:00.428] MultisessionFuture started
[13:37:00.428] - Launch lazy future ... done
[13:37:00.428] run() for ‘MultisessionFuture’ ... done
[13:37:00.428] result() for ClusterFuture ...
[13:37:00.428] receiveMessageFromWorker() for ClusterFuture ...
[13:37:00.428] - Validating connection of MultisessionFuture
[13:37:00.472] - received message: FutureResult
[13:37:00.472] - Received FutureResult
[13:37:00.472] - Erased future from FutureRegistry
[13:37:00.473] result() for ClusterFuture ...
[13:37:00.473] - result already collected: FutureResult
[13:37:00.473] result() for ClusterFuture ... done
[13:37:00.473] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:00.473] result() for ClusterFuture ... done
[13:37:00.473] result() for ClusterFuture ...
[13:37:00.473] - result already collected: FutureResult
[13:37:00.473] result() for ClusterFuture ... done
value(b) = 2
[13:37:00.473] result() for ClusterFuture ...
[13:37:00.473] - result already collected: FutureResult
[13:37:00.473] result() for ClusterFuture ... done
[13:37:00.474] result() for ClusterFuture ...
[13:37:00.474] - result already collected: FutureResult
[13:37:00.474] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:37:00.474] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:37:00.474] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:37:00.475] - globals found: [2] ‘{’, ‘pkg’
[13:37:00.475] Searching for globals ... DONE
[13:37:00.475] Resolving globals: TRUE
[13:37:00.475] Resolving any globals that are futures ...
[13:37:00.475] - globals: [2] ‘{’, ‘pkg’
[13:37:00.475] Resolving any globals that are futures ... DONE
[13:37:00.476] Resolving futures part of globals (recursively) ...
[13:37:00.476] resolve() on list ...
[13:37:00.476]  recursive: 99
[13:37:00.476]  length: 1
[13:37:00.476]  elements: ‘pkg’
[13:37:00.476]  length: 0 (resolved future 1)
[13:37:00.476] resolve() on list ... DONE
[13:37:00.477] - globals: [1] ‘pkg’
[13:37:00.477] Resolving futures part of globals (recursively) ... DONE
[13:37:00.477] The total size of the 1 globals is 112 bytes (112 bytes)
[13:37:00.477] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:37:00.477] - globals: [1] ‘pkg’
[13:37:00.477] 
[13:37:00.477] getGlobalsAndPackages() ... DONE
[13:37:00.478] Packages needed by the future expression (n = 0): <none>
[13:37:00.478] Packages needed by future strategies (n = 0): <none>
[13:37:00.478] {
[13:37:00.478]     {
[13:37:00.478]         {
[13:37:00.478]             ...future.startTime <- base::Sys.time()
[13:37:00.478]             {
[13:37:00.478]                 {
[13:37:00.478]                   {
[13:37:00.478]                     base::local({
[13:37:00.478]                       has_future <- base::requireNamespace("future", 
[13:37:00.478]                         quietly = TRUE)
[13:37:00.478]                       if (has_future) {
[13:37:00.478]                         ns <- base::getNamespace("future")
[13:37:00.478]                         version <- ns[[".package"]][["version"]]
[13:37:00.478]                         if (is.null(version)) 
[13:37:00.478]                           version <- utils::packageVersion("future")
[13:37:00.478]                       }
[13:37:00.478]                       else {
[13:37:00.478]                         version <- NULL
[13:37:00.478]                       }
[13:37:00.478]                       if (!has_future || version < "1.8.0") {
[13:37:00.478]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:00.478]                           "", base::R.version$version.string), 
[13:37:00.478]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:00.478]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:00.478]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:00.478]                             "release", "version")], collapse = " "), 
[13:37:00.478]                           hostname = base::Sys.info()[["nodename"]])
[13:37:00.478]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:00.478]                           info)
[13:37:00.478]                         info <- base::paste(info, collapse = "; ")
[13:37:00.478]                         if (!has_future) {
[13:37:00.478]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:00.478]                             info)
[13:37:00.478]                         }
[13:37:00.478]                         else {
[13:37:00.478]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:00.478]                             info, version)
[13:37:00.478]                         }
[13:37:00.478]                         base::stop(msg)
[13:37:00.478]                       }
[13:37:00.478]                     })
[13:37:00.478]                   }
[13:37:00.478]                   ...future.strategy.old <- future::plan("list")
[13:37:00.478]                   options(future.plan = NULL)
[13:37:00.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:00.478]                 }
[13:37:00.478]                 ...future.workdir <- getwd()
[13:37:00.478]             }
[13:37:00.478]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:00.478]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:00.478]         }
[13:37:00.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:37:00.478]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:37:00.478]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:37:00.478]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:37:00.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:00.478]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:00.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:00.478]             base::names(...future.oldOptions))
[13:37:00.478]     }
[13:37:00.478]     if (FALSE) {
[13:37:00.478]     }
[13:37:00.478]     else {
[13:37:00.478]         if (TRUE) {
[13:37:00.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:00.478]                 open = "w")
[13:37:00.478]         }
[13:37:00.478]         else {
[13:37:00.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:00.478]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:00.478]         }
[13:37:00.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:00.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:00.478]             base::sink(type = "output", split = FALSE)
[13:37:00.478]             base::close(...future.stdout)
[13:37:00.478]         }, add = TRUE)
[13:37:00.478]     }
[13:37:00.478]     ...future.frame <- base::sys.nframe()
[13:37:00.478]     ...future.conditions <- base::list()
[13:37:00.478]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:00.478]     if (FALSE) {
[13:37:00.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:00.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:00.478]     }
[13:37:00.478]     ...future.result <- base::tryCatch({
[13:37:00.478]         base::withCallingHandlers({
[13:37:00.478]             ...future.value <- base::withVisible(base::local({
[13:37:00.478]                 pkg
[13:37:00.478]             }))
[13:37:00.478]             future::FutureResult(value = ...future.value$value, 
[13:37:00.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.478]                   ...future.rng), globalenv = if (FALSE) 
[13:37:00.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:00.478]                     ...future.globalenv.names))
[13:37:00.478]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:00.478]         }, condition = base::local({
[13:37:00.478]             c <- base::c
[13:37:00.478]             inherits <- base::inherits
[13:37:00.478]             invokeRestart <- base::invokeRestart
[13:37:00.478]             length <- base::length
[13:37:00.478]             list <- base::list
[13:37:00.478]             seq.int <- base::seq.int
[13:37:00.478]             signalCondition <- base::signalCondition
[13:37:00.478]             sys.calls <- base::sys.calls
[13:37:00.478]             `[[` <- base::`[[`
[13:37:00.478]             `+` <- base::`+`
[13:37:00.478]             `<<-` <- base::`<<-`
[13:37:00.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:00.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:00.478]                   3L)]
[13:37:00.478]             }
[13:37:00.478]             function(cond) {
[13:37:00.478]                 is_error <- inherits(cond, "error")
[13:37:00.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:00.478]                   NULL)
[13:37:00.478]                 if (is_error) {
[13:37:00.478]                   sessionInformation <- function() {
[13:37:00.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:00.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:00.478]                       search = base::search(), system = base::Sys.info())
[13:37:00.478]                   }
[13:37:00.478]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:00.478]                     cond$call), session = sessionInformation(), 
[13:37:00.478]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:00.478]                   signalCondition(cond)
[13:37:00.478]                 }
[13:37:00.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:00.478]                 "immediateCondition"))) {
[13:37:00.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:00.478]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:00.478]                   if (TRUE && !signal) {
[13:37:00.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.478]                     {
[13:37:00.478]                       inherits <- base::inherits
[13:37:00.478]                       invokeRestart <- base::invokeRestart
[13:37:00.478]                       is.null <- base::is.null
[13:37:00.478]                       muffled <- FALSE
[13:37:00.478]                       if (inherits(cond, "message")) {
[13:37:00.478]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.478]                         if (muffled) 
[13:37:00.478]                           invokeRestart("muffleMessage")
[13:37:00.478]                       }
[13:37:00.478]                       else if (inherits(cond, "warning")) {
[13:37:00.478]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.478]                         if (muffled) 
[13:37:00.478]                           invokeRestart("muffleWarning")
[13:37:00.478]                       }
[13:37:00.478]                       else if (inherits(cond, "condition")) {
[13:37:00.478]                         if (!is.null(pattern)) {
[13:37:00.478]                           computeRestarts <- base::computeRestarts
[13:37:00.478]                           grepl <- base::grepl
[13:37:00.478]                           restarts <- computeRestarts(cond)
[13:37:00.478]                           for (restart in restarts) {
[13:37:00.478]                             name <- restart$name
[13:37:00.478]                             if (is.null(name)) 
[13:37:00.478]                               next
[13:37:00.478]                             if (!grepl(pattern, name)) 
[13:37:00.478]                               next
[13:37:00.478]                             invokeRestart(restart)
[13:37:00.478]                             muffled <- TRUE
[13:37:00.478]                             break
[13:37:00.478]                           }
[13:37:00.478]                         }
[13:37:00.478]                       }
[13:37:00.478]                       invisible(muffled)
[13:37:00.478]                     }
[13:37:00.478]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.478]                   }
[13:37:00.478]                 }
[13:37:00.478]                 else {
[13:37:00.478]                   if (TRUE) {
[13:37:00.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.478]                     {
[13:37:00.478]                       inherits <- base::inherits
[13:37:00.478]                       invokeRestart <- base::invokeRestart
[13:37:00.478]                       is.null <- base::is.null
[13:37:00.478]                       muffled <- FALSE
[13:37:00.478]                       if (inherits(cond, "message")) {
[13:37:00.478]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.478]                         if (muffled) 
[13:37:00.478]                           invokeRestart("muffleMessage")
[13:37:00.478]                       }
[13:37:00.478]                       else if (inherits(cond, "warning")) {
[13:37:00.478]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.478]                         if (muffled) 
[13:37:00.478]                           invokeRestart("muffleWarning")
[13:37:00.478]                       }
[13:37:00.478]                       else if (inherits(cond, "condition")) {
[13:37:00.478]                         if (!is.null(pattern)) {
[13:37:00.478]                           computeRestarts <- base::computeRestarts
[13:37:00.478]                           grepl <- base::grepl
[13:37:00.478]                           restarts <- computeRestarts(cond)
[13:37:00.478]                           for (restart in restarts) {
[13:37:00.478]                             name <- restart$name
[13:37:00.478]                             if (is.null(name)) 
[13:37:00.478]                               next
[13:37:00.478]                             if (!grepl(pattern, name)) 
[13:37:00.478]                               next
[13:37:00.478]                             invokeRestart(restart)
[13:37:00.478]                             muffled <- TRUE
[13:37:00.478]                             break
[13:37:00.478]                           }
[13:37:00.478]                         }
[13:37:00.478]                       }
[13:37:00.478]                       invisible(muffled)
[13:37:00.478]                     }
[13:37:00.478]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.478]                   }
[13:37:00.478]                 }
[13:37:00.478]             }
[13:37:00.478]         }))
[13:37:00.478]     }, error = function(ex) {
[13:37:00.478]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:00.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.478]                 ...future.rng), started = ...future.startTime, 
[13:37:00.478]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:00.478]             version = "1.8"), class = "FutureResult")
[13:37:00.478]     }, finally = {
[13:37:00.478]         if (!identical(...future.workdir, getwd())) 
[13:37:00.478]             setwd(...future.workdir)
[13:37:00.478]         {
[13:37:00.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:00.478]                 ...future.oldOptions$nwarnings <- NULL
[13:37:00.478]             }
[13:37:00.478]             base::options(...future.oldOptions)
[13:37:00.478]             if (.Platform$OS.type == "windows") {
[13:37:00.478]                 old_names <- names(...future.oldEnvVars)
[13:37:00.478]                 envs <- base::Sys.getenv()
[13:37:00.478]                 names <- names(envs)
[13:37:00.478]                 common <- intersect(names, old_names)
[13:37:00.478]                 added <- setdiff(names, old_names)
[13:37:00.478]                 removed <- setdiff(old_names, names)
[13:37:00.478]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:00.478]                   envs[common]]
[13:37:00.478]                 NAMES <- toupper(changed)
[13:37:00.478]                 args <- list()
[13:37:00.478]                 for (kk in seq_along(NAMES)) {
[13:37:00.478]                   name <- changed[[kk]]
[13:37:00.478]                   NAME <- NAMES[[kk]]
[13:37:00.478]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.478]                     next
[13:37:00.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.478]                 }
[13:37:00.478]                 NAMES <- toupper(added)
[13:37:00.478]                 for (kk in seq_along(NAMES)) {
[13:37:00.478]                   name <- added[[kk]]
[13:37:00.478]                   NAME <- NAMES[[kk]]
[13:37:00.478]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.478]                     next
[13:37:00.478]                   args[[name]] <- ""
[13:37:00.478]                 }
[13:37:00.478]                 NAMES <- toupper(removed)
[13:37:00.478]                 for (kk in seq_along(NAMES)) {
[13:37:00.478]                   name <- removed[[kk]]
[13:37:00.478]                   NAME <- NAMES[[kk]]
[13:37:00.478]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.478]                     next
[13:37:00.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.478]                 }
[13:37:00.478]                 if (length(args) > 0) 
[13:37:00.478]                   base::do.call(base::Sys.setenv, args = args)
[13:37:00.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:00.478]             }
[13:37:00.478]             else {
[13:37:00.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:00.478]             }
[13:37:00.478]             {
[13:37:00.478]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:00.478]                   0L) {
[13:37:00.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:00.478]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:00.478]                   base::options(opts)
[13:37:00.478]                 }
[13:37:00.478]                 {
[13:37:00.478]                   {
[13:37:00.478]                     NULL
[13:37:00.478]                     RNGkind("Mersenne-Twister")
[13:37:00.478]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:00.478]                       inherits = FALSE)
[13:37:00.478]                   }
[13:37:00.478]                   options(future.plan = NULL)
[13:37:00.478]                   if (is.na(NA_character_)) 
[13:37:00.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:00.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:00.478]                     .init = FALSE)
[13:37:00.478]                 }
[13:37:00.478]             }
[13:37:00.478]         }
[13:37:00.478]     })
[13:37:00.478]     if (TRUE) {
[13:37:00.478]         base::sink(type = "output", split = FALSE)
[13:37:00.478]         if (TRUE) {
[13:37:00.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:00.478]         }
[13:37:00.478]         else {
[13:37:00.478]             ...future.result["stdout"] <- base::list(NULL)
[13:37:00.478]         }
[13:37:00.478]         base::close(...future.stdout)
[13:37:00.478]         ...future.stdout <- NULL
[13:37:00.478]     }
[13:37:00.478]     ...future.result$conditions <- ...future.conditions
[13:37:00.478]     ...future.result$finished <- base::Sys.time()
[13:37:00.478]     ...future.result
[13:37:00.478] }
[13:37:00.480] assign_globals() ...
[13:37:00.480] List of 1
[13:37:00.480]  $ pkg: chr "foo"
[13:37:00.480]  - attr(*, "where")=List of 1
[13:37:00.480]   ..$ pkg:<environment: R_EmptyEnv> 
[13:37:00.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:00.480]  - attr(*, "resolved")= logi TRUE
[13:37:00.480]  - attr(*, "total_size")= num 112
[13:37:00.482] - copied ‘pkg’ to environment
[13:37:00.482] assign_globals() ... done
[13:37:00.482] plan(): Setting new future strategy stack:
[13:37:00.482] List of future strategies:
[13:37:00.482] 1. sequential:
[13:37:00.482]    - args: function (..., envir = parent.frame())
[13:37:00.482]    - tweaked: FALSE
[13:37:00.482]    - call: NULL
[13:37:00.483] plan(): nbrOfWorkers() = 1
[13:37:00.484] plan(): Setting new future strategy stack:
[13:37:00.484] List of future strategies:
[13:37:00.484] 1. multisession:
[13:37:00.484]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:37:00.484]    - tweaked: FALSE
[13:37:00.484]    - call: plan(strategy)
[13:37:00.487] plan(): nbrOfWorkers() = 2
[13:37:00.487] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:37:00.488] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:37:00.488] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:37:00.490] - globals found: [3] ‘{’, ‘<-’, ‘+’
[13:37:00.490] Searching for globals ... DONE
[13:37:00.490] Resolving globals: TRUE
[13:37:00.490] Resolving any globals that are futures ...
[13:37:00.490] - globals: [3] ‘{’, ‘<-’, ‘+’
[13:37:00.491] Resolving any globals that are futures ... DONE
[13:37:00.491] 
[13:37:00.491] 
[13:37:00.491] getGlobalsAndPackages() ... DONE
[13:37:00.491] run() for ‘Future’ ...
[13:37:00.491] - state: ‘created’
[13:37:00.491] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:00.505] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:00.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:00.505]   - Field: ‘node’
[13:37:00.505]   - Field: ‘label’
[13:37:00.506]   - Field: ‘local’
[13:37:00.506]   - Field: ‘owner’
[13:37:00.506]   - Field: ‘envir’
[13:37:00.506]   - Field: ‘workers’
[13:37:00.506]   - Field: ‘packages’
[13:37:00.506]   - Field: ‘gc’
[13:37:00.506]   - Field: ‘conditions’
[13:37:00.506]   - Field: ‘persistent’
[13:37:00.506]   - Field: ‘expr’
[13:37:00.506]   - Field: ‘uuid’
[13:37:00.507]   - Field: ‘seed’
[13:37:00.507]   - Field: ‘version’
[13:37:00.507]   - Field: ‘result’
[13:37:00.507]   - Field: ‘asynchronous’
[13:37:00.507]   - Field: ‘calls’
[13:37:00.507]   - Field: ‘globals’
[13:37:00.507]   - Field: ‘stdout’
[13:37:00.507]   - Field: ‘earlySignal’
[13:37:00.507]   - Field: ‘lazy’
[13:37:00.507]   - Field: ‘state’
[13:37:00.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:00.508] - Launch lazy future ...
[13:37:00.508] Packages needed by the future expression (n = 0): <none>
[13:37:00.508] Packages needed by future strategies (n = 0): <none>
[13:37:00.508] {
[13:37:00.508]     {
[13:37:00.508]         {
[13:37:00.508]             ...future.startTime <- base::Sys.time()
[13:37:00.508]             {
[13:37:00.508]                 {
[13:37:00.508]                   {
[13:37:00.508]                     {
[13:37:00.508]                       base::local({
[13:37:00.508]                         has_future <- base::requireNamespace("future", 
[13:37:00.508]                           quietly = TRUE)
[13:37:00.508]                         if (has_future) {
[13:37:00.508]                           ns <- base::getNamespace("future")
[13:37:00.508]                           version <- ns[[".package"]][["version"]]
[13:37:00.508]                           if (is.null(version)) 
[13:37:00.508]                             version <- utils::packageVersion("future")
[13:37:00.508]                         }
[13:37:00.508]                         else {
[13:37:00.508]                           version <- NULL
[13:37:00.508]                         }
[13:37:00.508]                         if (!has_future || version < "1.8.0") {
[13:37:00.508]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:00.508]                             "", base::R.version$version.string), 
[13:37:00.508]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:00.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:00.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:00.508]                               "release", "version")], collapse = " "), 
[13:37:00.508]                             hostname = base::Sys.info()[["nodename"]])
[13:37:00.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:00.508]                             info)
[13:37:00.508]                           info <- base::paste(info, collapse = "; ")
[13:37:00.508]                           if (!has_future) {
[13:37:00.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:00.508]                               info)
[13:37:00.508]                           }
[13:37:00.508]                           else {
[13:37:00.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:00.508]                               info, version)
[13:37:00.508]                           }
[13:37:00.508]                           base::stop(msg)
[13:37:00.508]                         }
[13:37:00.508]                       })
[13:37:00.508]                     }
[13:37:00.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:00.508]                     base::options(mc.cores = 1L)
[13:37:00.508]                   }
[13:37:00.508]                   ...future.strategy.old <- future::plan("list")
[13:37:00.508]                   options(future.plan = NULL)
[13:37:00.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:00.508]                 }
[13:37:00.508]                 ...future.workdir <- getwd()
[13:37:00.508]             }
[13:37:00.508]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:00.508]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:00.508]         }
[13:37:00.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:37:00.508]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:37:00.508]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:37:00.508]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:37:00.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:00.508]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:00.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:00.508]             base::names(...future.oldOptions))
[13:37:00.508]     }
[13:37:00.508]     if (FALSE) {
[13:37:00.508]     }
[13:37:00.508]     else {
[13:37:00.508]         if (TRUE) {
[13:37:00.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:00.508]                 open = "w")
[13:37:00.508]         }
[13:37:00.508]         else {
[13:37:00.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:00.508]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:00.508]         }
[13:37:00.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:00.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:00.508]             base::sink(type = "output", split = FALSE)
[13:37:00.508]             base::close(...future.stdout)
[13:37:00.508]         }, add = TRUE)
[13:37:00.508]     }
[13:37:00.508]     ...future.frame <- base::sys.nframe()
[13:37:00.508]     ...future.conditions <- base::list()
[13:37:00.508]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:00.508]     if (FALSE) {
[13:37:00.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:00.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:00.508]     }
[13:37:00.508]     ...future.result <- base::tryCatch({
[13:37:00.508]         base::withCallingHandlers({
[13:37:00.508]             ...future.value <- base::withVisible(base::local({
[13:37:00.508]                 ...future.makeSendCondition <- base::local({
[13:37:00.508]                   sendCondition <- NULL
[13:37:00.508]                   function(frame = 1L) {
[13:37:00.508]                     if (is.function(sendCondition)) 
[13:37:00.508]                       return(sendCondition)
[13:37:00.508]                     ns <- getNamespace("parallel")
[13:37:00.508]                     if (exists("sendData", mode = "function", 
[13:37:00.508]                       envir = ns)) {
[13:37:00.508]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:00.508]                         envir = ns)
[13:37:00.508]                       envir <- sys.frame(frame)
[13:37:00.508]                       master <- NULL
[13:37:00.508]                       while (!identical(envir, .GlobalEnv) && 
[13:37:00.508]                         !identical(envir, emptyenv())) {
[13:37:00.508]                         if (exists("master", mode = "list", envir = envir, 
[13:37:00.508]                           inherits = FALSE)) {
[13:37:00.508]                           master <- get("master", mode = "list", 
[13:37:00.508]                             envir = envir, inherits = FALSE)
[13:37:00.508]                           if (inherits(master, c("SOCKnode", 
[13:37:00.508]                             "SOCK0node"))) {
[13:37:00.508]                             sendCondition <<- function(cond) {
[13:37:00.508]                               data <- list(type = "VALUE", value = cond, 
[13:37:00.508]                                 success = TRUE)
[13:37:00.508]                               parallel_sendData(master, data)
[13:37:00.508]                             }
[13:37:00.508]                             return(sendCondition)
[13:37:00.508]                           }
[13:37:00.508]                         }
[13:37:00.508]                         frame <- frame + 1L
[13:37:00.508]                         envir <- sys.frame(frame)
[13:37:00.508]                       }
[13:37:00.508]                     }
[13:37:00.508]                     sendCondition <<- function(cond) NULL
[13:37:00.508]                   }
[13:37:00.508]                 })
[13:37:00.508]                 withCallingHandlers({
[13:37:00.508]                   {
[13:37:00.508]                     x <- 0
[13:37:00.508]                     x <- x + 1
[13:37:00.508]                     x
[13:37:00.508]                   }
[13:37:00.508]                 }, immediateCondition = function(cond) {
[13:37:00.508]                   sendCondition <- ...future.makeSendCondition()
[13:37:00.508]                   sendCondition(cond)
[13:37:00.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.508]                   {
[13:37:00.508]                     inherits <- base::inherits
[13:37:00.508]                     invokeRestart <- base::invokeRestart
[13:37:00.508]                     is.null <- base::is.null
[13:37:00.508]                     muffled <- FALSE
[13:37:00.508]                     if (inherits(cond, "message")) {
[13:37:00.508]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:00.508]                       if (muffled) 
[13:37:00.508]                         invokeRestart("muffleMessage")
[13:37:00.508]                     }
[13:37:00.508]                     else if (inherits(cond, "warning")) {
[13:37:00.508]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:00.508]                       if (muffled) 
[13:37:00.508]                         invokeRestart("muffleWarning")
[13:37:00.508]                     }
[13:37:00.508]                     else if (inherits(cond, "condition")) {
[13:37:00.508]                       if (!is.null(pattern)) {
[13:37:00.508]                         computeRestarts <- base::computeRestarts
[13:37:00.508]                         grepl <- base::grepl
[13:37:00.508]                         restarts <- computeRestarts(cond)
[13:37:00.508]                         for (restart in restarts) {
[13:37:00.508]                           name <- restart$name
[13:37:00.508]                           if (is.null(name)) 
[13:37:00.508]                             next
[13:37:00.508]                           if (!grepl(pattern, name)) 
[13:37:00.508]                             next
[13:37:00.508]                           invokeRestart(restart)
[13:37:00.508]                           muffled <- TRUE
[13:37:00.508]                           break
[13:37:00.508]                         }
[13:37:00.508]                       }
[13:37:00.508]                     }
[13:37:00.508]                     invisible(muffled)
[13:37:00.508]                   }
[13:37:00.508]                   muffleCondition(cond)
[13:37:00.508]                 })
[13:37:00.508]             }))
[13:37:00.508]             future::FutureResult(value = ...future.value$value, 
[13:37:00.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.508]                   ...future.rng), globalenv = if (FALSE) 
[13:37:00.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:00.508]                     ...future.globalenv.names))
[13:37:00.508]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:00.508]         }, condition = base::local({
[13:37:00.508]             c <- base::c
[13:37:00.508]             inherits <- base::inherits
[13:37:00.508]             invokeRestart <- base::invokeRestart
[13:37:00.508]             length <- base::length
[13:37:00.508]             list <- base::list
[13:37:00.508]             seq.int <- base::seq.int
[13:37:00.508]             signalCondition <- base::signalCondition
[13:37:00.508]             sys.calls <- base::sys.calls
[13:37:00.508]             `[[` <- base::`[[`
[13:37:00.508]             `+` <- base::`+`
[13:37:00.508]             `<<-` <- base::`<<-`
[13:37:00.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:00.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:00.508]                   3L)]
[13:37:00.508]             }
[13:37:00.508]             function(cond) {
[13:37:00.508]                 is_error <- inherits(cond, "error")
[13:37:00.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:00.508]                   NULL)
[13:37:00.508]                 if (is_error) {
[13:37:00.508]                   sessionInformation <- function() {
[13:37:00.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:00.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:00.508]                       search = base::search(), system = base::Sys.info())
[13:37:00.508]                   }
[13:37:00.508]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:00.508]                     cond$call), session = sessionInformation(), 
[13:37:00.508]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:00.508]                   signalCondition(cond)
[13:37:00.508]                 }
[13:37:00.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:00.508]                 "immediateCondition"))) {
[13:37:00.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:00.508]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:00.508]                   if (TRUE && !signal) {
[13:37:00.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.508]                     {
[13:37:00.508]                       inherits <- base::inherits
[13:37:00.508]                       invokeRestart <- base::invokeRestart
[13:37:00.508]                       is.null <- base::is.null
[13:37:00.508]                       muffled <- FALSE
[13:37:00.508]                       if (inherits(cond, "message")) {
[13:37:00.508]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.508]                         if (muffled) 
[13:37:00.508]                           invokeRestart("muffleMessage")
[13:37:00.508]                       }
[13:37:00.508]                       else if (inherits(cond, "warning")) {
[13:37:00.508]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.508]                         if (muffled) 
[13:37:00.508]                           invokeRestart("muffleWarning")
[13:37:00.508]                       }
[13:37:00.508]                       else if (inherits(cond, "condition")) {
[13:37:00.508]                         if (!is.null(pattern)) {
[13:37:00.508]                           computeRestarts <- base::computeRestarts
[13:37:00.508]                           grepl <- base::grepl
[13:37:00.508]                           restarts <- computeRestarts(cond)
[13:37:00.508]                           for (restart in restarts) {
[13:37:00.508]                             name <- restart$name
[13:37:00.508]                             if (is.null(name)) 
[13:37:00.508]                               next
[13:37:00.508]                             if (!grepl(pattern, name)) 
[13:37:00.508]                               next
[13:37:00.508]                             invokeRestart(restart)
[13:37:00.508]                             muffled <- TRUE
[13:37:00.508]                             break
[13:37:00.508]                           }
[13:37:00.508]                         }
[13:37:00.508]                       }
[13:37:00.508]                       invisible(muffled)
[13:37:00.508]                     }
[13:37:00.508]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.508]                   }
[13:37:00.508]                 }
[13:37:00.508]                 else {
[13:37:00.508]                   if (TRUE) {
[13:37:00.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.508]                     {
[13:37:00.508]                       inherits <- base::inherits
[13:37:00.508]                       invokeRestart <- base::invokeRestart
[13:37:00.508]                       is.null <- base::is.null
[13:37:00.508]                       muffled <- FALSE
[13:37:00.508]                       if (inherits(cond, "message")) {
[13:37:00.508]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.508]                         if (muffled) 
[13:37:00.508]                           invokeRestart("muffleMessage")
[13:37:00.508]                       }
[13:37:00.508]                       else if (inherits(cond, "warning")) {
[13:37:00.508]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.508]                         if (muffled) 
[13:37:00.508]                           invokeRestart("muffleWarning")
[13:37:00.508]                       }
[13:37:00.508]                       else if (inherits(cond, "condition")) {
[13:37:00.508]                         if (!is.null(pattern)) {
[13:37:00.508]                           computeRestarts <- base::computeRestarts
[13:37:00.508]                           grepl <- base::grepl
[13:37:00.508]                           restarts <- computeRestarts(cond)
[13:37:00.508]                           for (restart in restarts) {
[13:37:00.508]                             name <- restart$name
[13:37:00.508]                             if (is.null(name)) 
[13:37:00.508]                               next
[13:37:00.508]                             if (!grepl(pattern, name)) 
[13:37:00.508]                               next
[13:37:00.508]                             invokeRestart(restart)
[13:37:00.508]                             muffled <- TRUE
[13:37:00.508]                             break
[13:37:00.508]                           }
[13:37:00.508]                         }
[13:37:00.508]                       }
[13:37:00.508]                       invisible(muffled)
[13:37:00.508]                     }
[13:37:00.508]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.508]                   }
[13:37:00.508]                 }
[13:37:00.508]             }
[13:37:00.508]         }))
[13:37:00.508]     }, error = function(ex) {
[13:37:00.508]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:00.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.508]                 ...future.rng), started = ...future.startTime, 
[13:37:00.508]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:00.508]             version = "1.8"), class = "FutureResult")
[13:37:00.508]     }, finally = {
[13:37:00.508]         if (!identical(...future.workdir, getwd())) 
[13:37:00.508]             setwd(...future.workdir)
[13:37:00.508]         {
[13:37:00.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:00.508]                 ...future.oldOptions$nwarnings <- NULL
[13:37:00.508]             }
[13:37:00.508]             base::options(...future.oldOptions)
[13:37:00.508]             if (.Platform$OS.type == "windows") {
[13:37:00.508]                 old_names <- names(...future.oldEnvVars)
[13:37:00.508]                 envs <- base::Sys.getenv()
[13:37:00.508]                 names <- names(envs)
[13:37:00.508]                 common <- intersect(names, old_names)
[13:37:00.508]                 added <- setdiff(names, old_names)
[13:37:00.508]                 removed <- setdiff(old_names, names)
[13:37:00.508]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:00.508]                   envs[common]]
[13:37:00.508]                 NAMES <- toupper(changed)
[13:37:00.508]                 args <- list()
[13:37:00.508]                 for (kk in seq_along(NAMES)) {
[13:37:00.508]                   name <- changed[[kk]]
[13:37:00.508]                   NAME <- NAMES[[kk]]
[13:37:00.508]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.508]                     next
[13:37:00.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.508]                 }
[13:37:00.508]                 NAMES <- toupper(added)
[13:37:00.508]                 for (kk in seq_along(NAMES)) {
[13:37:00.508]                   name <- added[[kk]]
[13:37:00.508]                   NAME <- NAMES[[kk]]
[13:37:00.508]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.508]                     next
[13:37:00.508]                   args[[name]] <- ""
[13:37:00.508]                 }
[13:37:00.508]                 NAMES <- toupper(removed)
[13:37:00.508]                 for (kk in seq_along(NAMES)) {
[13:37:00.508]                   name <- removed[[kk]]
[13:37:00.508]                   NAME <- NAMES[[kk]]
[13:37:00.508]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.508]                     next
[13:37:00.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.508]                 }
[13:37:00.508]                 if (length(args) > 0) 
[13:37:00.508]                   base::do.call(base::Sys.setenv, args = args)
[13:37:00.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:00.508]             }
[13:37:00.508]             else {
[13:37:00.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:00.508]             }
[13:37:00.508]             {
[13:37:00.508]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:00.508]                   0L) {
[13:37:00.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:00.508]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:00.508]                   base::options(opts)
[13:37:00.508]                 }
[13:37:00.508]                 {
[13:37:00.508]                   {
[13:37:00.508]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:00.508]                     NULL
[13:37:00.508]                   }
[13:37:00.508]                   options(future.plan = NULL)
[13:37:00.508]                   if (is.na(NA_character_)) 
[13:37:00.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:00.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:00.508]                     .init = FALSE)
[13:37:00.508]                 }
[13:37:00.508]             }
[13:37:00.508]         }
[13:37:00.508]     })
[13:37:00.508]     if (TRUE) {
[13:37:00.508]         base::sink(type = "output", split = FALSE)
[13:37:00.508]         if (TRUE) {
[13:37:00.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:00.508]         }
[13:37:00.508]         else {
[13:37:00.508]             ...future.result["stdout"] <- base::list(NULL)
[13:37:00.508]         }
[13:37:00.508]         base::close(...future.stdout)
[13:37:00.508]         ...future.stdout <- NULL
[13:37:00.508]     }
[13:37:00.508]     ...future.result$conditions <- ...future.conditions
[13:37:00.508]     ...future.result$finished <- base::Sys.time()
[13:37:00.508]     ...future.result
[13:37:00.508] }
[13:37:00.511] MultisessionFuture started
[13:37:00.511] - Launch lazy future ... done
[13:37:00.511] run() for ‘MultisessionFuture’ ... done
[13:37:00.511] result() for ClusterFuture ...
[13:37:00.511] receiveMessageFromWorker() for ClusterFuture ...
[13:37:00.512] - Validating connection of MultisessionFuture
[13:37:00.556] - received message: FutureResult
[13:37:00.556] - Received FutureResult
[13:37:00.556] - Erased future from FutureRegistry
[13:37:00.556] result() for ClusterFuture ...
[13:37:00.556] - result already collected: FutureResult
[13:37:00.556] result() for ClusterFuture ... done
[13:37:00.557] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:00.557] result() for ClusterFuture ... done
[13:37:00.557] result() for ClusterFuture ...
[13:37:00.557] - result already collected: FutureResult
[13:37:00.557] result() for ClusterFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:37:00.557] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:37:00.557] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:37:00.559] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:37:00.559] Searching for globals ... DONE
[13:37:00.559] Resolving globals: TRUE
[13:37:00.559] Resolving any globals that are futures ...
[13:37:00.559] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:37:00.559] Resolving any globals that are futures ... DONE
[13:37:00.560] Resolving futures part of globals (recursively) ...
[13:37:00.560] resolve() on list ...
[13:37:00.560]  recursive: 99
[13:37:00.560]  length: 1
[13:37:00.560]  elements: ‘x’
[13:37:00.560]  length: 0 (resolved future 1)
[13:37:00.560] resolve() on list ... DONE
[13:37:00.560] - globals: [1] ‘x’
[13:37:00.561] Resolving futures part of globals (recursively) ... DONE
[13:37:00.561] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:00.561] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[13:37:00.561] - globals: [1] ‘x’
[13:37:00.561] 
[13:37:00.561] getGlobalsAndPackages() ... DONE
[13:37:00.562] run() for ‘Future’ ...
[13:37:00.562] - state: ‘created’
[13:37:00.562] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:00.575] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:00.575] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:00.575]   - Field: ‘node’
[13:37:00.575]   - Field: ‘label’
[13:37:00.576]   - Field: ‘local’
[13:37:00.576]   - Field: ‘owner’
[13:37:00.576]   - Field: ‘envir’
[13:37:00.576]   - Field: ‘workers’
[13:37:00.576]   - Field: ‘packages’
[13:37:00.576]   - Field: ‘gc’
[13:37:00.576]   - Field: ‘conditions’
[13:37:00.576]   - Field: ‘persistent’
[13:37:00.576]   - Field: ‘expr’
[13:37:00.576]   - Field: ‘uuid’
[13:37:00.577]   - Field: ‘seed’
[13:37:00.577]   - Field: ‘version’
[13:37:00.577]   - Field: ‘result’
[13:37:00.577]   - Field: ‘asynchronous’
[13:37:00.577]   - Field: ‘calls’
[13:37:00.577]   - Field: ‘globals’
[13:37:00.577]   - Field: ‘stdout’
[13:37:00.577]   - Field: ‘earlySignal’
[13:37:00.577]   - Field: ‘lazy’
[13:37:00.577]   - Field: ‘state’
[13:37:00.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:00.577] - Launch lazy future ...
[13:37:00.578] Packages needed by the future expression (n = 0): <none>
[13:37:00.578] Packages needed by future strategies (n = 0): <none>
[13:37:00.578] {
[13:37:00.578]     {
[13:37:00.578]         {
[13:37:00.578]             ...future.startTime <- base::Sys.time()
[13:37:00.578]             {
[13:37:00.578]                 {
[13:37:00.578]                   {
[13:37:00.578]                     {
[13:37:00.578]                       base::local({
[13:37:00.578]                         has_future <- base::requireNamespace("future", 
[13:37:00.578]                           quietly = TRUE)
[13:37:00.578]                         if (has_future) {
[13:37:00.578]                           ns <- base::getNamespace("future")
[13:37:00.578]                           version <- ns[[".package"]][["version"]]
[13:37:00.578]                           if (is.null(version)) 
[13:37:00.578]                             version <- utils::packageVersion("future")
[13:37:00.578]                         }
[13:37:00.578]                         else {
[13:37:00.578]                           version <- NULL
[13:37:00.578]                         }
[13:37:00.578]                         if (!has_future || version < "1.8.0") {
[13:37:00.578]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:00.578]                             "", base::R.version$version.string), 
[13:37:00.578]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:00.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:00.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:00.578]                               "release", "version")], collapse = " "), 
[13:37:00.578]                             hostname = base::Sys.info()[["nodename"]])
[13:37:00.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:00.578]                             info)
[13:37:00.578]                           info <- base::paste(info, collapse = "; ")
[13:37:00.578]                           if (!has_future) {
[13:37:00.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:00.578]                               info)
[13:37:00.578]                           }
[13:37:00.578]                           else {
[13:37:00.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:00.578]                               info, version)
[13:37:00.578]                           }
[13:37:00.578]                           base::stop(msg)
[13:37:00.578]                         }
[13:37:00.578]                       })
[13:37:00.578]                     }
[13:37:00.578]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:00.578]                     base::options(mc.cores = 1L)
[13:37:00.578]                   }
[13:37:00.578]                   ...future.strategy.old <- future::plan("list")
[13:37:00.578]                   options(future.plan = NULL)
[13:37:00.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:00.578]                 }
[13:37:00.578]                 ...future.workdir <- getwd()
[13:37:00.578]             }
[13:37:00.578]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:00.578]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:00.578]         }
[13:37:00.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:37:00.578]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:37:00.578]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:37:00.578]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:37:00.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:00.578]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:00.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:00.578]             base::names(...future.oldOptions))
[13:37:00.578]     }
[13:37:00.578]     if (FALSE) {
[13:37:00.578]     }
[13:37:00.578]     else {
[13:37:00.578]         if (TRUE) {
[13:37:00.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:00.578]                 open = "w")
[13:37:00.578]         }
[13:37:00.578]         else {
[13:37:00.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:00.578]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:00.578]         }
[13:37:00.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:00.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:00.578]             base::sink(type = "output", split = FALSE)
[13:37:00.578]             base::close(...future.stdout)
[13:37:00.578]         }, add = TRUE)
[13:37:00.578]     }
[13:37:00.578]     ...future.frame <- base::sys.nframe()
[13:37:00.578]     ...future.conditions <- base::list()
[13:37:00.578]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:00.578]     if (FALSE) {
[13:37:00.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:00.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:00.578]     }
[13:37:00.578]     ...future.result <- base::tryCatch({
[13:37:00.578]         base::withCallingHandlers({
[13:37:00.578]             ...future.value <- base::withVisible(base::local({
[13:37:00.578]                 ...future.makeSendCondition <- base::local({
[13:37:00.578]                   sendCondition <- NULL
[13:37:00.578]                   function(frame = 1L) {
[13:37:00.578]                     if (is.function(sendCondition)) 
[13:37:00.578]                       return(sendCondition)
[13:37:00.578]                     ns <- getNamespace("parallel")
[13:37:00.578]                     if (exists("sendData", mode = "function", 
[13:37:00.578]                       envir = ns)) {
[13:37:00.578]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:00.578]                         envir = ns)
[13:37:00.578]                       envir <- sys.frame(frame)
[13:37:00.578]                       master <- NULL
[13:37:00.578]                       while (!identical(envir, .GlobalEnv) && 
[13:37:00.578]                         !identical(envir, emptyenv())) {
[13:37:00.578]                         if (exists("master", mode = "list", envir = envir, 
[13:37:00.578]                           inherits = FALSE)) {
[13:37:00.578]                           master <- get("master", mode = "list", 
[13:37:00.578]                             envir = envir, inherits = FALSE)
[13:37:00.578]                           if (inherits(master, c("SOCKnode", 
[13:37:00.578]                             "SOCK0node"))) {
[13:37:00.578]                             sendCondition <<- function(cond) {
[13:37:00.578]                               data <- list(type = "VALUE", value = cond, 
[13:37:00.578]                                 success = TRUE)
[13:37:00.578]                               parallel_sendData(master, data)
[13:37:00.578]                             }
[13:37:00.578]                             return(sendCondition)
[13:37:00.578]                           }
[13:37:00.578]                         }
[13:37:00.578]                         frame <- frame + 1L
[13:37:00.578]                         envir <- sys.frame(frame)
[13:37:00.578]                       }
[13:37:00.578]                     }
[13:37:00.578]                     sendCondition <<- function(cond) NULL
[13:37:00.578]                   }
[13:37:00.578]                 })
[13:37:00.578]                 withCallingHandlers({
[13:37:00.578]                   {
[13:37:00.578]                     x <- x + 1
[13:37:00.578]                     x
[13:37:00.578]                   }
[13:37:00.578]                 }, immediateCondition = function(cond) {
[13:37:00.578]                   sendCondition <- ...future.makeSendCondition()
[13:37:00.578]                   sendCondition(cond)
[13:37:00.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.578]                   {
[13:37:00.578]                     inherits <- base::inherits
[13:37:00.578]                     invokeRestart <- base::invokeRestart
[13:37:00.578]                     is.null <- base::is.null
[13:37:00.578]                     muffled <- FALSE
[13:37:00.578]                     if (inherits(cond, "message")) {
[13:37:00.578]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:00.578]                       if (muffled) 
[13:37:00.578]                         invokeRestart("muffleMessage")
[13:37:00.578]                     }
[13:37:00.578]                     else if (inherits(cond, "warning")) {
[13:37:00.578]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:00.578]                       if (muffled) 
[13:37:00.578]                         invokeRestart("muffleWarning")
[13:37:00.578]                     }
[13:37:00.578]                     else if (inherits(cond, "condition")) {
[13:37:00.578]                       if (!is.null(pattern)) {
[13:37:00.578]                         computeRestarts <- base::computeRestarts
[13:37:00.578]                         grepl <- base::grepl
[13:37:00.578]                         restarts <- computeRestarts(cond)
[13:37:00.578]                         for (restart in restarts) {
[13:37:00.578]                           name <- restart$name
[13:37:00.578]                           if (is.null(name)) 
[13:37:00.578]                             next
[13:37:00.578]                           if (!grepl(pattern, name)) 
[13:37:00.578]                             next
[13:37:00.578]                           invokeRestart(restart)
[13:37:00.578]                           muffled <- TRUE
[13:37:00.578]                           break
[13:37:00.578]                         }
[13:37:00.578]                       }
[13:37:00.578]                     }
[13:37:00.578]                     invisible(muffled)
[13:37:00.578]                   }
[13:37:00.578]                   muffleCondition(cond)
[13:37:00.578]                 })
[13:37:00.578]             }))
[13:37:00.578]             future::FutureResult(value = ...future.value$value, 
[13:37:00.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.578]                   ...future.rng), globalenv = if (FALSE) 
[13:37:00.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:00.578]                     ...future.globalenv.names))
[13:37:00.578]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:00.578]         }, condition = base::local({
[13:37:00.578]             c <- base::c
[13:37:00.578]             inherits <- base::inherits
[13:37:00.578]             invokeRestart <- base::invokeRestart
[13:37:00.578]             length <- base::length
[13:37:00.578]             list <- base::list
[13:37:00.578]             seq.int <- base::seq.int
[13:37:00.578]             signalCondition <- base::signalCondition
[13:37:00.578]             sys.calls <- base::sys.calls
[13:37:00.578]             `[[` <- base::`[[`
[13:37:00.578]             `+` <- base::`+`
[13:37:00.578]             `<<-` <- base::`<<-`
[13:37:00.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:00.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:00.578]                   3L)]
[13:37:00.578]             }
[13:37:00.578]             function(cond) {
[13:37:00.578]                 is_error <- inherits(cond, "error")
[13:37:00.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:00.578]                   NULL)
[13:37:00.578]                 if (is_error) {
[13:37:00.578]                   sessionInformation <- function() {
[13:37:00.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:00.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:00.578]                       search = base::search(), system = base::Sys.info())
[13:37:00.578]                   }
[13:37:00.578]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:00.578]                     cond$call), session = sessionInformation(), 
[13:37:00.578]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:00.578]                   signalCondition(cond)
[13:37:00.578]                 }
[13:37:00.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:00.578]                 "immediateCondition"))) {
[13:37:00.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:00.578]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:00.578]                   if (TRUE && !signal) {
[13:37:00.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.578]                     {
[13:37:00.578]                       inherits <- base::inherits
[13:37:00.578]                       invokeRestart <- base::invokeRestart
[13:37:00.578]                       is.null <- base::is.null
[13:37:00.578]                       muffled <- FALSE
[13:37:00.578]                       if (inherits(cond, "message")) {
[13:37:00.578]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.578]                         if (muffled) 
[13:37:00.578]                           invokeRestart("muffleMessage")
[13:37:00.578]                       }
[13:37:00.578]                       else if (inherits(cond, "warning")) {
[13:37:00.578]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.578]                         if (muffled) 
[13:37:00.578]                           invokeRestart("muffleWarning")
[13:37:00.578]                       }
[13:37:00.578]                       else if (inherits(cond, "condition")) {
[13:37:00.578]                         if (!is.null(pattern)) {
[13:37:00.578]                           computeRestarts <- base::computeRestarts
[13:37:00.578]                           grepl <- base::grepl
[13:37:00.578]                           restarts <- computeRestarts(cond)
[13:37:00.578]                           for (restart in restarts) {
[13:37:00.578]                             name <- restart$name
[13:37:00.578]                             if (is.null(name)) 
[13:37:00.578]                               next
[13:37:00.578]                             if (!grepl(pattern, name)) 
[13:37:00.578]                               next
[13:37:00.578]                             invokeRestart(restart)
[13:37:00.578]                             muffled <- TRUE
[13:37:00.578]                             break
[13:37:00.578]                           }
[13:37:00.578]                         }
[13:37:00.578]                       }
[13:37:00.578]                       invisible(muffled)
[13:37:00.578]                     }
[13:37:00.578]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.578]                   }
[13:37:00.578]                 }
[13:37:00.578]                 else {
[13:37:00.578]                   if (TRUE) {
[13:37:00.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.578]                     {
[13:37:00.578]                       inherits <- base::inherits
[13:37:00.578]                       invokeRestart <- base::invokeRestart
[13:37:00.578]                       is.null <- base::is.null
[13:37:00.578]                       muffled <- FALSE
[13:37:00.578]                       if (inherits(cond, "message")) {
[13:37:00.578]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.578]                         if (muffled) 
[13:37:00.578]                           invokeRestart("muffleMessage")
[13:37:00.578]                       }
[13:37:00.578]                       else if (inherits(cond, "warning")) {
[13:37:00.578]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.578]                         if (muffled) 
[13:37:00.578]                           invokeRestart("muffleWarning")
[13:37:00.578]                       }
[13:37:00.578]                       else if (inherits(cond, "condition")) {
[13:37:00.578]                         if (!is.null(pattern)) {
[13:37:00.578]                           computeRestarts <- base::computeRestarts
[13:37:00.578]                           grepl <- base::grepl
[13:37:00.578]                           restarts <- computeRestarts(cond)
[13:37:00.578]                           for (restart in restarts) {
[13:37:00.578]                             name <- restart$name
[13:37:00.578]                             if (is.null(name)) 
[13:37:00.578]                               next
[13:37:00.578]                             if (!grepl(pattern, name)) 
[13:37:00.578]                               next
[13:37:00.578]                             invokeRestart(restart)
[13:37:00.578]                             muffled <- TRUE
[13:37:00.578]                             break
[13:37:00.578]                           }
[13:37:00.578]                         }
[13:37:00.578]                       }
[13:37:00.578]                       invisible(muffled)
[13:37:00.578]                     }
[13:37:00.578]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.578]                   }
[13:37:00.578]                 }
[13:37:00.578]             }
[13:37:00.578]         }))
[13:37:00.578]     }, error = function(ex) {
[13:37:00.578]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:00.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.578]                 ...future.rng), started = ...future.startTime, 
[13:37:00.578]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:00.578]             version = "1.8"), class = "FutureResult")
[13:37:00.578]     }, finally = {
[13:37:00.578]         if (!identical(...future.workdir, getwd())) 
[13:37:00.578]             setwd(...future.workdir)
[13:37:00.578]         {
[13:37:00.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:00.578]                 ...future.oldOptions$nwarnings <- NULL
[13:37:00.578]             }
[13:37:00.578]             base::options(...future.oldOptions)
[13:37:00.578]             if (.Platform$OS.type == "windows") {
[13:37:00.578]                 old_names <- names(...future.oldEnvVars)
[13:37:00.578]                 envs <- base::Sys.getenv()
[13:37:00.578]                 names <- names(envs)
[13:37:00.578]                 common <- intersect(names, old_names)
[13:37:00.578]                 added <- setdiff(names, old_names)
[13:37:00.578]                 removed <- setdiff(old_names, names)
[13:37:00.578]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:00.578]                   envs[common]]
[13:37:00.578]                 NAMES <- toupper(changed)
[13:37:00.578]                 args <- list()
[13:37:00.578]                 for (kk in seq_along(NAMES)) {
[13:37:00.578]                   name <- changed[[kk]]
[13:37:00.578]                   NAME <- NAMES[[kk]]
[13:37:00.578]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.578]                     next
[13:37:00.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.578]                 }
[13:37:00.578]                 NAMES <- toupper(added)
[13:37:00.578]                 for (kk in seq_along(NAMES)) {
[13:37:00.578]                   name <- added[[kk]]
[13:37:00.578]                   NAME <- NAMES[[kk]]
[13:37:00.578]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.578]                     next
[13:37:00.578]                   args[[name]] <- ""
[13:37:00.578]                 }
[13:37:00.578]                 NAMES <- toupper(removed)
[13:37:00.578]                 for (kk in seq_along(NAMES)) {
[13:37:00.578]                   name <- removed[[kk]]
[13:37:00.578]                   NAME <- NAMES[[kk]]
[13:37:00.578]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.578]                     next
[13:37:00.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.578]                 }
[13:37:00.578]                 if (length(args) > 0) 
[13:37:00.578]                   base::do.call(base::Sys.setenv, args = args)
[13:37:00.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:00.578]             }
[13:37:00.578]             else {
[13:37:00.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:00.578]             }
[13:37:00.578]             {
[13:37:00.578]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:00.578]                   0L) {
[13:37:00.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:00.578]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:00.578]                   base::options(opts)
[13:37:00.578]                 }
[13:37:00.578]                 {
[13:37:00.578]                   {
[13:37:00.578]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:00.578]                     NULL
[13:37:00.578]                   }
[13:37:00.578]                   options(future.plan = NULL)
[13:37:00.578]                   if (is.na(NA_character_)) 
[13:37:00.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:00.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:00.578]                     .init = FALSE)
[13:37:00.578]                 }
[13:37:00.578]             }
[13:37:00.578]         }
[13:37:00.578]     })
[13:37:00.578]     if (TRUE) {
[13:37:00.578]         base::sink(type = "output", split = FALSE)
[13:37:00.578]         if (TRUE) {
[13:37:00.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:00.578]         }
[13:37:00.578]         else {
[13:37:00.578]             ...future.result["stdout"] <- base::list(NULL)
[13:37:00.578]         }
[13:37:00.578]         base::close(...future.stdout)
[13:37:00.578]         ...future.stdout <- NULL
[13:37:00.578]     }
[13:37:00.578]     ...future.result$conditions <- ...future.conditions
[13:37:00.578]     ...future.result$finished <- base::Sys.time()
[13:37:00.578]     ...future.result
[13:37:00.578] }
[13:37:00.581] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:37:00.581] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[13:37:00.581] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[13:37:00.581] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:37:00.582] MultisessionFuture started
[13:37:00.582] - Launch lazy future ... done
[13:37:00.582] run() for ‘MultisessionFuture’ ... done
[13:37:00.582] result() for ClusterFuture ...
[13:37:00.582] receiveMessageFromWorker() for ClusterFuture ...
[13:37:00.582] - Validating connection of MultisessionFuture
[13:37:00.624] - received message: FutureResult
[13:37:00.624] - Received FutureResult
[13:37:00.624] - Erased future from FutureRegistry
[13:37:00.624] result() for ClusterFuture ...
[13:37:00.625] - result already collected: FutureResult
[13:37:00.625] result() for ClusterFuture ... done
[13:37:00.625] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:00.625] result() for ClusterFuture ... done
[13:37:00.625] result() for ClusterFuture ...
[13:37:00.625] - result already collected: FutureResult
[13:37:00.625] result() for ClusterFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:37:00.625] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:37:00.626] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:37:00.627] - globals found: [3] ‘{’, ‘<-’, ‘x’
[13:37:00.628] Searching for globals ... DONE
[13:37:00.628] Resolving globals: TRUE
[13:37:00.628] Resolving any globals that are futures ...
[13:37:00.628] - globals: [3] ‘{’, ‘<-’, ‘x’
[13:37:00.628] Resolving any globals that are futures ... DONE
[13:37:00.628] Resolving futures part of globals (recursively) ...
[13:37:00.628] resolve() on list ...
[13:37:00.629]  recursive: 99
[13:37:00.629]  length: 1
[13:37:00.629]  elements: ‘x’
[13:37:00.629]  length: 0 (resolved future 1)
[13:37:00.629] resolve() on list ... DONE
[13:37:00.629] - globals: [1] ‘x’
[13:37:00.629] Resolving futures part of globals (recursively) ... DONE
[13:37:00.629] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[13:37:00.630] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[13:37:00.630] - globals: [1] ‘x’
[13:37:00.630] 
[13:37:00.630] getGlobalsAndPackages() ... DONE
[13:37:00.630] run() for ‘Future’ ...
[13:37:00.630] - state: ‘created’
[13:37:00.630] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:00.644] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:00.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:00.645]   - Field: ‘node’
[13:37:00.645]   - Field: ‘label’
[13:37:00.645]   - Field: ‘local’
[13:37:00.645]   - Field: ‘owner’
[13:37:00.645]   - Field: ‘envir’
[13:37:00.645]   - Field: ‘workers’
[13:37:00.645]   - Field: ‘packages’
[13:37:00.645]   - Field: ‘gc’
[13:37:00.645]   - Field: ‘conditions’
[13:37:00.646]   - Field: ‘persistent’
[13:37:00.646]   - Field: ‘expr’
[13:37:00.646]   - Field: ‘uuid’
[13:37:00.646]   - Field: ‘seed’
[13:37:00.646]   - Field: ‘version’
[13:37:00.646]   - Field: ‘result’
[13:37:00.646]   - Field: ‘asynchronous’
[13:37:00.646]   - Field: ‘calls’
[13:37:00.646]   - Field: ‘globals’
[13:37:00.646]   - Field: ‘stdout’
[13:37:00.646]   - Field: ‘earlySignal’
[13:37:00.647]   - Field: ‘lazy’
[13:37:00.647]   - Field: ‘state’
[13:37:00.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:00.647] - Launch lazy future ...
[13:37:00.647] Packages needed by the future expression (n = 0): <none>
[13:37:00.647] Packages needed by future strategies (n = 0): <none>
[13:37:00.648] {
[13:37:00.648]     {
[13:37:00.648]         {
[13:37:00.648]             ...future.startTime <- base::Sys.time()
[13:37:00.648]             {
[13:37:00.648]                 {
[13:37:00.648]                   {
[13:37:00.648]                     {
[13:37:00.648]                       base::local({
[13:37:00.648]                         has_future <- base::requireNamespace("future", 
[13:37:00.648]                           quietly = TRUE)
[13:37:00.648]                         if (has_future) {
[13:37:00.648]                           ns <- base::getNamespace("future")
[13:37:00.648]                           version <- ns[[".package"]][["version"]]
[13:37:00.648]                           if (is.null(version)) 
[13:37:00.648]                             version <- utils::packageVersion("future")
[13:37:00.648]                         }
[13:37:00.648]                         else {
[13:37:00.648]                           version <- NULL
[13:37:00.648]                         }
[13:37:00.648]                         if (!has_future || version < "1.8.0") {
[13:37:00.648]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:00.648]                             "", base::R.version$version.string), 
[13:37:00.648]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:00.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:00.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:00.648]                               "release", "version")], collapse = " "), 
[13:37:00.648]                             hostname = base::Sys.info()[["nodename"]])
[13:37:00.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:00.648]                             info)
[13:37:00.648]                           info <- base::paste(info, collapse = "; ")
[13:37:00.648]                           if (!has_future) {
[13:37:00.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:00.648]                               info)
[13:37:00.648]                           }
[13:37:00.648]                           else {
[13:37:00.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:00.648]                               info, version)
[13:37:00.648]                           }
[13:37:00.648]                           base::stop(msg)
[13:37:00.648]                         }
[13:37:00.648]                       })
[13:37:00.648]                     }
[13:37:00.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:00.648]                     base::options(mc.cores = 1L)
[13:37:00.648]                   }
[13:37:00.648]                   ...future.strategy.old <- future::plan("list")
[13:37:00.648]                   options(future.plan = NULL)
[13:37:00.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:00.648]                 }
[13:37:00.648]                 ...future.workdir <- getwd()
[13:37:00.648]             }
[13:37:00.648]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:00.648]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:00.648]         }
[13:37:00.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:37:00.648]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:37:00.648]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:37:00.648]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:37:00.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:00.648]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:00.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:00.648]             base::names(...future.oldOptions))
[13:37:00.648]     }
[13:37:00.648]     if (FALSE) {
[13:37:00.648]     }
[13:37:00.648]     else {
[13:37:00.648]         if (TRUE) {
[13:37:00.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:00.648]                 open = "w")
[13:37:00.648]         }
[13:37:00.648]         else {
[13:37:00.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:00.648]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:00.648]         }
[13:37:00.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:00.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:00.648]             base::sink(type = "output", split = FALSE)
[13:37:00.648]             base::close(...future.stdout)
[13:37:00.648]         }, add = TRUE)
[13:37:00.648]     }
[13:37:00.648]     ...future.frame <- base::sys.nframe()
[13:37:00.648]     ...future.conditions <- base::list()
[13:37:00.648]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:00.648]     if (FALSE) {
[13:37:00.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:00.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:00.648]     }
[13:37:00.648]     ...future.result <- base::tryCatch({
[13:37:00.648]         base::withCallingHandlers({
[13:37:00.648]             ...future.value <- base::withVisible(base::local({
[13:37:00.648]                 ...future.makeSendCondition <- base::local({
[13:37:00.648]                   sendCondition <- NULL
[13:37:00.648]                   function(frame = 1L) {
[13:37:00.648]                     if (is.function(sendCondition)) 
[13:37:00.648]                       return(sendCondition)
[13:37:00.648]                     ns <- getNamespace("parallel")
[13:37:00.648]                     if (exists("sendData", mode = "function", 
[13:37:00.648]                       envir = ns)) {
[13:37:00.648]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:00.648]                         envir = ns)
[13:37:00.648]                       envir <- sys.frame(frame)
[13:37:00.648]                       master <- NULL
[13:37:00.648]                       while (!identical(envir, .GlobalEnv) && 
[13:37:00.648]                         !identical(envir, emptyenv())) {
[13:37:00.648]                         if (exists("master", mode = "list", envir = envir, 
[13:37:00.648]                           inherits = FALSE)) {
[13:37:00.648]                           master <- get("master", mode = "list", 
[13:37:00.648]                             envir = envir, inherits = FALSE)
[13:37:00.648]                           if (inherits(master, c("SOCKnode", 
[13:37:00.648]                             "SOCK0node"))) {
[13:37:00.648]                             sendCondition <<- function(cond) {
[13:37:00.648]                               data <- list(type = "VALUE", value = cond, 
[13:37:00.648]                                 success = TRUE)
[13:37:00.648]                               parallel_sendData(master, data)
[13:37:00.648]                             }
[13:37:00.648]                             return(sendCondition)
[13:37:00.648]                           }
[13:37:00.648]                         }
[13:37:00.648]                         frame <- frame + 1L
[13:37:00.648]                         envir <- sys.frame(frame)
[13:37:00.648]                       }
[13:37:00.648]                     }
[13:37:00.648]                     sendCondition <<- function(cond) NULL
[13:37:00.648]                   }
[13:37:00.648]                 })
[13:37:00.648]                 withCallingHandlers({
[13:37:00.648]                   {
[13:37:00.648]                     x <- x()
[13:37:00.648]                     x
[13:37:00.648]                   }
[13:37:00.648]                 }, immediateCondition = function(cond) {
[13:37:00.648]                   sendCondition <- ...future.makeSendCondition()
[13:37:00.648]                   sendCondition(cond)
[13:37:00.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.648]                   {
[13:37:00.648]                     inherits <- base::inherits
[13:37:00.648]                     invokeRestart <- base::invokeRestart
[13:37:00.648]                     is.null <- base::is.null
[13:37:00.648]                     muffled <- FALSE
[13:37:00.648]                     if (inherits(cond, "message")) {
[13:37:00.648]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:00.648]                       if (muffled) 
[13:37:00.648]                         invokeRestart("muffleMessage")
[13:37:00.648]                     }
[13:37:00.648]                     else if (inherits(cond, "warning")) {
[13:37:00.648]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:00.648]                       if (muffled) 
[13:37:00.648]                         invokeRestart("muffleWarning")
[13:37:00.648]                     }
[13:37:00.648]                     else if (inherits(cond, "condition")) {
[13:37:00.648]                       if (!is.null(pattern)) {
[13:37:00.648]                         computeRestarts <- base::computeRestarts
[13:37:00.648]                         grepl <- base::grepl
[13:37:00.648]                         restarts <- computeRestarts(cond)
[13:37:00.648]                         for (restart in restarts) {
[13:37:00.648]                           name <- restart$name
[13:37:00.648]                           if (is.null(name)) 
[13:37:00.648]                             next
[13:37:00.648]                           if (!grepl(pattern, name)) 
[13:37:00.648]                             next
[13:37:00.648]                           invokeRestart(restart)
[13:37:00.648]                           muffled <- TRUE
[13:37:00.648]                           break
[13:37:00.648]                         }
[13:37:00.648]                       }
[13:37:00.648]                     }
[13:37:00.648]                     invisible(muffled)
[13:37:00.648]                   }
[13:37:00.648]                   muffleCondition(cond)
[13:37:00.648]                 })
[13:37:00.648]             }))
[13:37:00.648]             future::FutureResult(value = ...future.value$value, 
[13:37:00.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.648]                   ...future.rng), globalenv = if (FALSE) 
[13:37:00.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:00.648]                     ...future.globalenv.names))
[13:37:00.648]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:00.648]         }, condition = base::local({
[13:37:00.648]             c <- base::c
[13:37:00.648]             inherits <- base::inherits
[13:37:00.648]             invokeRestart <- base::invokeRestart
[13:37:00.648]             length <- base::length
[13:37:00.648]             list <- base::list
[13:37:00.648]             seq.int <- base::seq.int
[13:37:00.648]             signalCondition <- base::signalCondition
[13:37:00.648]             sys.calls <- base::sys.calls
[13:37:00.648]             `[[` <- base::`[[`
[13:37:00.648]             `+` <- base::`+`
[13:37:00.648]             `<<-` <- base::`<<-`
[13:37:00.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:00.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:00.648]                   3L)]
[13:37:00.648]             }
[13:37:00.648]             function(cond) {
[13:37:00.648]                 is_error <- inherits(cond, "error")
[13:37:00.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:00.648]                   NULL)
[13:37:00.648]                 if (is_error) {
[13:37:00.648]                   sessionInformation <- function() {
[13:37:00.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:00.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:00.648]                       search = base::search(), system = base::Sys.info())
[13:37:00.648]                   }
[13:37:00.648]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:00.648]                     cond$call), session = sessionInformation(), 
[13:37:00.648]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:00.648]                   signalCondition(cond)
[13:37:00.648]                 }
[13:37:00.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:00.648]                 "immediateCondition"))) {
[13:37:00.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:00.648]                   ...future.conditions[[length(...future.conditions) + 
[13:37:00.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:00.648]                   if (TRUE && !signal) {
[13:37:00.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.648]                     {
[13:37:00.648]                       inherits <- base::inherits
[13:37:00.648]                       invokeRestart <- base::invokeRestart
[13:37:00.648]                       is.null <- base::is.null
[13:37:00.648]                       muffled <- FALSE
[13:37:00.648]                       if (inherits(cond, "message")) {
[13:37:00.648]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.648]                         if (muffled) 
[13:37:00.648]                           invokeRestart("muffleMessage")
[13:37:00.648]                       }
[13:37:00.648]                       else if (inherits(cond, "warning")) {
[13:37:00.648]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.648]                         if (muffled) 
[13:37:00.648]                           invokeRestart("muffleWarning")
[13:37:00.648]                       }
[13:37:00.648]                       else if (inherits(cond, "condition")) {
[13:37:00.648]                         if (!is.null(pattern)) {
[13:37:00.648]                           computeRestarts <- base::computeRestarts
[13:37:00.648]                           grepl <- base::grepl
[13:37:00.648]                           restarts <- computeRestarts(cond)
[13:37:00.648]                           for (restart in restarts) {
[13:37:00.648]                             name <- restart$name
[13:37:00.648]                             if (is.null(name)) 
[13:37:00.648]                               next
[13:37:00.648]                             if (!grepl(pattern, name)) 
[13:37:00.648]                               next
[13:37:00.648]                             invokeRestart(restart)
[13:37:00.648]                             muffled <- TRUE
[13:37:00.648]                             break
[13:37:00.648]                           }
[13:37:00.648]                         }
[13:37:00.648]                       }
[13:37:00.648]                       invisible(muffled)
[13:37:00.648]                     }
[13:37:00.648]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.648]                   }
[13:37:00.648]                 }
[13:37:00.648]                 else {
[13:37:00.648]                   if (TRUE) {
[13:37:00.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:00.648]                     {
[13:37:00.648]                       inherits <- base::inherits
[13:37:00.648]                       invokeRestart <- base::invokeRestart
[13:37:00.648]                       is.null <- base::is.null
[13:37:00.648]                       muffled <- FALSE
[13:37:00.648]                       if (inherits(cond, "message")) {
[13:37:00.648]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:00.648]                         if (muffled) 
[13:37:00.648]                           invokeRestart("muffleMessage")
[13:37:00.648]                       }
[13:37:00.648]                       else if (inherits(cond, "warning")) {
[13:37:00.648]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:00.648]                         if (muffled) 
[13:37:00.648]                           invokeRestart("muffleWarning")
[13:37:00.648]                       }
[13:37:00.648]                       else if (inherits(cond, "condition")) {
[13:37:00.648]                         if (!is.null(pattern)) {
[13:37:00.648]                           computeRestarts <- base::computeRestarts
[13:37:00.648]                           grepl <- base::grepl
[13:37:00.648]                           restarts <- computeRestarts(cond)
[13:37:00.648]                           for (restart in restarts) {
[13:37:00.648]                             name <- restart$name
[13:37:00.648]                             if (is.null(name)) 
[13:37:00.648]                               next
[13:37:00.648]                             if (!grepl(pattern, name)) 
[13:37:00.648]                               next
[13:37:00.648]                             invokeRestart(restart)
[13:37:00.648]                             muffled <- TRUE
[13:37:00.648]                             break
[13:37:00.648]                           }
[13:37:00.648]                         }
[13:37:00.648]                       }
[13:37:00.648]                       invisible(muffled)
[13:37:00.648]                     }
[13:37:00.648]                     muffleCondition(cond, pattern = "^muffle")
[13:37:00.648]                   }
[13:37:00.648]                 }
[13:37:00.648]             }
[13:37:00.648]         }))
[13:37:00.648]     }, error = function(ex) {
[13:37:00.648]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:00.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:00.648]                 ...future.rng), started = ...future.startTime, 
[13:37:00.648]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:00.648]             version = "1.8"), class = "FutureResult")
[13:37:00.648]     }, finally = {
[13:37:00.648]         if (!identical(...future.workdir, getwd())) 
[13:37:00.648]             setwd(...future.workdir)
[13:37:00.648]         {
[13:37:00.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:00.648]                 ...future.oldOptions$nwarnings <- NULL
[13:37:00.648]             }
[13:37:00.648]             base::options(...future.oldOptions)
[13:37:00.648]             if (.Platform$OS.type == "windows") {
[13:37:00.648]                 old_names <- names(...future.oldEnvVars)
[13:37:00.648]                 envs <- base::Sys.getenv()
[13:37:00.648]                 names <- names(envs)
[13:37:00.648]                 common <- intersect(names, old_names)
[13:37:00.648]                 added <- setdiff(names, old_names)
[13:37:00.648]                 removed <- setdiff(old_names, names)
[13:37:00.648]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:00.648]                   envs[common]]
[13:37:00.648]                 NAMES <- toupper(changed)
[13:37:00.648]                 args <- list()
[13:37:00.648]                 for (kk in seq_along(NAMES)) {
[13:37:00.648]                   name <- changed[[kk]]
[13:37:00.648]                   NAME <- NAMES[[kk]]
[13:37:00.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.648]                     next
[13:37:00.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.648]                 }
[13:37:00.648]                 NAMES <- toupper(added)
[13:37:00.648]                 for (kk in seq_along(NAMES)) {
[13:37:00.648]                   name <- added[[kk]]
[13:37:00.648]                   NAME <- NAMES[[kk]]
[13:37:00.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.648]                     next
[13:37:00.648]                   args[[name]] <- ""
[13:37:00.648]                 }
[13:37:00.648]                 NAMES <- toupper(removed)
[13:37:00.648]                 for (kk in seq_along(NAMES)) {
[13:37:00.648]                   name <- removed[[kk]]
[13:37:00.648]                   NAME <- NAMES[[kk]]
[13:37:00.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:00.648]                     next
[13:37:00.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:00.648]                 }
[13:37:00.648]                 if (length(args) > 0) 
[13:37:00.648]                   base::do.call(base::Sys.setenv, args = args)
[13:37:00.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:00.648]             }
[13:37:00.648]             else {
[13:37:00.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:00.648]             }
[13:37:00.648]             {
[13:37:00.648]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:00.648]                   0L) {
[13:37:00.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:00.648]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:00.648]                   base::options(opts)
[13:37:00.648]                 }
[13:37:00.648]                 {
[13:37:00.648]                   {
[13:37:00.648]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:00.648]                     NULL
[13:37:00.648]                   }
[13:37:00.648]                   options(future.plan = NULL)
[13:37:00.648]                   if (is.na(NA_character_)) 
[13:37:00.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:00.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:00.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:00.648]                     .init = FALSE)
[13:37:00.648]                 }
[13:37:00.648]             }
[13:37:00.648]         }
[13:37:00.648]     })
[13:37:00.648]     if (TRUE) {
[13:37:00.648]         base::sink(type = "output", split = FALSE)
[13:37:00.648]         if (TRUE) {
[13:37:00.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:00.648]         }
[13:37:00.648]         else {
[13:37:00.648]             ...future.result["stdout"] <- base::list(NULL)
[13:37:00.648]         }
[13:37:00.648]         base::close(...future.stdout)
[13:37:00.648]         ...future.stdout <- NULL
[13:37:00.648]     }
[13:37:00.648]     ...future.result$conditions <- ...future.conditions
[13:37:00.648]     ...future.result$finished <- base::Sys.time()
[13:37:00.648]     ...future.result
[13:37:00.648] }
[13:37:00.650] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[13:37:00.650] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[13:37:00.651] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[13:37:00.651] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[13:37:00.651] MultisessionFuture started
[13:37:00.652] - Launch lazy future ... done
[13:37:00.652] run() for ‘MultisessionFuture’ ... done
[13:37:00.652] result() for ClusterFuture ...
[13:37:00.652] receiveMessageFromWorker() for ClusterFuture ...
[13:37:00.652] - Validating connection of MultisessionFuture
[13:37:00.696] - received message: FutureResult
[13:37:00.696] - Received FutureResult
[13:37:00.696] - Erased future from FutureRegistry
[13:37:00.696] result() for ClusterFuture ...
[13:37:00.696] - result already collected: FutureResult
[13:37:00.697] result() for ClusterFuture ... done
[13:37:00.697] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:00.697] result() for ClusterFuture ... done
[13:37:00.697] result() for ClusterFuture ...
[13:37:00.697] - result already collected: FutureResult
[13:37:00.697] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[13:37:00.698] plan(): Setting new future strategy stack:
[13:37:00.698] List of future strategies:
[13:37:00.698] 1. FutureStrategy:
[13:37:00.698]    - args: function (..., envir = parent.frame())
[13:37:00.698]    - tweaked: FALSE
[13:37:00.698]    - call: future::plan(oplan)
[13:37:00.699] plan(): nbrOfWorkers() = 1
> 
