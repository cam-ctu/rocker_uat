
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:21:03.030] plan(): Setting new future strategy stack:
[16:21:03.030] List of future strategies:
[16:21:03.030] 1. sequential:
[16:21:03.030]    - args: function (..., envir = parent.frame())
[16:21:03.030]    - tweaked: FALSE
[16:21:03.030]    - call: future::plan("sequential")
[16:21:03.045] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[16:21:03.138] plan(): Setting new future strategy stack:
[16:21:03.138] List of future strategies:
[16:21:03.138] 1. sequential:
[16:21:03.138]    - args: function (..., envir = parent.frame())
[16:21:03.138]    - tweaked: FALSE
[16:21:03.138]    - call: plan(strategy)
[16:21:03.151] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.153] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.153] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.160] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:21:03.160] Searching for globals ... DONE
[16:21:03.160] Resolving globals: TRUE
[16:21:03.160] Resolving any globals that are futures ...
[16:21:03.160] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:21:03.160] Resolving any globals that are futures ... DONE
[16:21:03.161] 
[16:21:03.161] 
[16:21:03.161] getGlobalsAndPackages() ... DONE
[16:21:03.162] run() for ‘Future’ ...
[16:21:03.162] - state: ‘created’
[16:21:03.162] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.162] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.162] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.163]   - Field: ‘label’
[16:21:03.163]   - Field: ‘local’
[16:21:03.163]   - Field: ‘owner’
[16:21:03.163]   - Field: ‘envir’
[16:21:03.163]   - Field: ‘packages’
[16:21:03.163]   - Field: ‘gc’
[16:21:03.163]   - Field: ‘conditions’
[16:21:03.163]   - Field: ‘expr’
[16:21:03.163]   - Field: ‘uuid’
[16:21:03.163]   - Field: ‘seed’
[16:21:03.164]   - Field: ‘version’
[16:21:03.164]   - Field: ‘result’
[16:21:03.164]   - Field: ‘asynchronous’
[16:21:03.164]   - Field: ‘calls’
[16:21:03.164]   - Field: ‘globals’
[16:21:03.164]   - Field: ‘stdout’
[16:21:03.164]   - Field: ‘earlySignal’
[16:21:03.164]   - Field: ‘lazy’
[16:21:03.164]   - Field: ‘state’
[16:21:03.164] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.165] - Launch lazy future ...
[16:21:03.165] Packages needed by the future expression (n = 0): <none>
[16:21:03.165] Packages needed by future strategies (n = 0): <none>
[16:21:03.166] {
[16:21:03.166]     {
[16:21:03.166]         {
[16:21:03.166]             ...future.startTime <- base::Sys.time()
[16:21:03.166]             {
[16:21:03.166]                 {
[16:21:03.166]                   {
[16:21:03.166]                     base::local({
[16:21:03.166]                       has_future <- base::requireNamespace("future", 
[16:21:03.166]                         quietly = TRUE)
[16:21:03.166]                       if (has_future) {
[16:21:03.166]                         ns <- base::getNamespace("future")
[16:21:03.166]                         version <- ns[[".package"]][["version"]]
[16:21:03.166]                         if (is.null(version)) 
[16:21:03.166]                           version <- utils::packageVersion("future")
[16:21:03.166]                       }
[16:21:03.166]                       else {
[16:21:03.166]                         version <- NULL
[16:21:03.166]                       }
[16:21:03.166]                       if (!has_future || version < "1.8.0") {
[16:21:03.166]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.166]                           "", base::R.version$version.string), 
[16:21:03.166]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.166]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.166]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.166]                             "release", "version")], collapse = " "), 
[16:21:03.166]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.166]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.166]                           info)
[16:21:03.166]                         info <- base::paste(info, collapse = "; ")
[16:21:03.166]                         if (!has_future) {
[16:21:03.166]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.166]                             info)
[16:21:03.166]                         }
[16:21:03.166]                         else {
[16:21:03.166]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.166]                             info, version)
[16:21:03.166]                         }
[16:21:03.166]                         base::stop(msg)
[16:21:03.166]                       }
[16:21:03.166]                     })
[16:21:03.166]                   }
[16:21:03.166]                   ...future.strategy.old <- future::plan("list")
[16:21:03.166]                   options(future.plan = NULL)
[16:21:03.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.166]                 }
[16:21:03.166]                 ...future.workdir <- getwd()
[16:21:03.166]             }
[16:21:03.166]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.166]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.166]         }
[16:21:03.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.166]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.166]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.166]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.166]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.166]             base::names(...future.oldOptions))
[16:21:03.166]     }
[16:21:03.166]     if (FALSE) {
[16:21:03.166]     }
[16:21:03.166]     else {
[16:21:03.166]         if (TRUE) {
[16:21:03.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.166]                 open = "w")
[16:21:03.166]         }
[16:21:03.166]         else {
[16:21:03.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.166]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.166]         }
[16:21:03.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.166]             base::sink(type = "output", split = FALSE)
[16:21:03.166]             base::close(...future.stdout)
[16:21:03.166]         }, add = TRUE)
[16:21:03.166]     }
[16:21:03.166]     ...future.frame <- base::sys.nframe()
[16:21:03.166]     ...future.conditions <- base::list()
[16:21:03.166]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.166]     if (FALSE) {
[16:21:03.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.166]     }
[16:21:03.166]     ...future.result <- base::tryCatch({
[16:21:03.166]         base::withCallingHandlers({
[16:21:03.166]             ...future.value <- base::withVisible(base::local({
[16:21:03.166]                 b <- a
[16:21:03.166]                 a <- 2
[16:21:03.166]                 a * b
[16:21:03.166]             }))
[16:21:03.166]             future::FutureResult(value = ...future.value$value, 
[16:21:03.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.166]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.166]                     ...future.globalenv.names))
[16:21:03.166]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.166]         }, condition = base::local({
[16:21:03.166]             c <- base::c
[16:21:03.166]             inherits <- base::inherits
[16:21:03.166]             invokeRestart <- base::invokeRestart
[16:21:03.166]             length <- base::length
[16:21:03.166]             list <- base::list
[16:21:03.166]             seq.int <- base::seq.int
[16:21:03.166]             signalCondition <- base::signalCondition
[16:21:03.166]             sys.calls <- base::sys.calls
[16:21:03.166]             `[[` <- base::`[[`
[16:21:03.166]             `+` <- base::`+`
[16:21:03.166]             `<<-` <- base::`<<-`
[16:21:03.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.166]                   3L)]
[16:21:03.166]             }
[16:21:03.166]             function(cond) {
[16:21:03.166]                 is_error <- inherits(cond, "error")
[16:21:03.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.166]                   NULL)
[16:21:03.166]                 if (is_error) {
[16:21:03.166]                   sessionInformation <- function() {
[16:21:03.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.166]                       search = base::search(), system = base::Sys.info())
[16:21:03.166]                   }
[16:21:03.166]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.166]                     cond$call), session = sessionInformation(), 
[16:21:03.166]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.166]                   signalCondition(cond)
[16:21:03.166]                 }
[16:21:03.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.166]                 "immediateCondition"))) {
[16:21:03.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.166]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.166]                   if (TRUE && !signal) {
[16:21:03.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.166]                     {
[16:21:03.166]                       inherits <- base::inherits
[16:21:03.166]                       invokeRestart <- base::invokeRestart
[16:21:03.166]                       is.null <- base::is.null
[16:21:03.166]                       muffled <- FALSE
[16:21:03.166]                       if (inherits(cond, "message")) {
[16:21:03.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.166]                         if (muffled) 
[16:21:03.166]                           invokeRestart("muffleMessage")
[16:21:03.166]                       }
[16:21:03.166]                       else if (inherits(cond, "warning")) {
[16:21:03.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.166]                         if (muffled) 
[16:21:03.166]                           invokeRestart("muffleWarning")
[16:21:03.166]                       }
[16:21:03.166]                       else if (inherits(cond, "condition")) {
[16:21:03.166]                         if (!is.null(pattern)) {
[16:21:03.166]                           computeRestarts <- base::computeRestarts
[16:21:03.166]                           grepl <- base::grepl
[16:21:03.166]                           restarts <- computeRestarts(cond)
[16:21:03.166]                           for (restart in restarts) {
[16:21:03.166]                             name <- restart$name
[16:21:03.166]                             if (is.null(name)) 
[16:21:03.166]                               next
[16:21:03.166]                             if (!grepl(pattern, name)) 
[16:21:03.166]                               next
[16:21:03.166]                             invokeRestart(restart)
[16:21:03.166]                             muffled <- TRUE
[16:21:03.166]                             break
[16:21:03.166]                           }
[16:21:03.166]                         }
[16:21:03.166]                       }
[16:21:03.166]                       invisible(muffled)
[16:21:03.166]                     }
[16:21:03.166]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.166]                   }
[16:21:03.166]                 }
[16:21:03.166]                 else {
[16:21:03.166]                   if (TRUE) {
[16:21:03.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.166]                     {
[16:21:03.166]                       inherits <- base::inherits
[16:21:03.166]                       invokeRestart <- base::invokeRestart
[16:21:03.166]                       is.null <- base::is.null
[16:21:03.166]                       muffled <- FALSE
[16:21:03.166]                       if (inherits(cond, "message")) {
[16:21:03.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.166]                         if (muffled) 
[16:21:03.166]                           invokeRestart("muffleMessage")
[16:21:03.166]                       }
[16:21:03.166]                       else if (inherits(cond, "warning")) {
[16:21:03.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.166]                         if (muffled) 
[16:21:03.166]                           invokeRestart("muffleWarning")
[16:21:03.166]                       }
[16:21:03.166]                       else if (inherits(cond, "condition")) {
[16:21:03.166]                         if (!is.null(pattern)) {
[16:21:03.166]                           computeRestarts <- base::computeRestarts
[16:21:03.166]                           grepl <- base::grepl
[16:21:03.166]                           restarts <- computeRestarts(cond)
[16:21:03.166]                           for (restart in restarts) {
[16:21:03.166]                             name <- restart$name
[16:21:03.166]                             if (is.null(name)) 
[16:21:03.166]                               next
[16:21:03.166]                             if (!grepl(pattern, name)) 
[16:21:03.166]                               next
[16:21:03.166]                             invokeRestart(restart)
[16:21:03.166]                             muffled <- TRUE
[16:21:03.166]                             break
[16:21:03.166]                           }
[16:21:03.166]                         }
[16:21:03.166]                       }
[16:21:03.166]                       invisible(muffled)
[16:21:03.166]                     }
[16:21:03.166]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.166]                   }
[16:21:03.166]                 }
[16:21:03.166]             }
[16:21:03.166]         }))
[16:21:03.166]     }, error = function(ex) {
[16:21:03.166]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.166]                 ...future.rng), started = ...future.startTime, 
[16:21:03.166]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.166]             version = "1.8"), class = "FutureResult")
[16:21:03.166]     }, finally = {
[16:21:03.166]         if (!identical(...future.workdir, getwd())) 
[16:21:03.166]             setwd(...future.workdir)
[16:21:03.166]         {
[16:21:03.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.166]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.166]             }
[16:21:03.166]             base::options(...future.oldOptions)
[16:21:03.166]             if (.Platform$OS.type == "windows") {
[16:21:03.166]                 old_names <- names(...future.oldEnvVars)
[16:21:03.166]                 envs <- base::Sys.getenv()
[16:21:03.166]                 names <- names(envs)
[16:21:03.166]                 common <- intersect(names, old_names)
[16:21:03.166]                 added <- setdiff(names, old_names)
[16:21:03.166]                 removed <- setdiff(old_names, names)
[16:21:03.166]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.166]                   envs[common]]
[16:21:03.166]                 NAMES <- toupper(changed)
[16:21:03.166]                 args <- list()
[16:21:03.166]                 for (kk in seq_along(NAMES)) {
[16:21:03.166]                   name <- changed[[kk]]
[16:21:03.166]                   NAME <- NAMES[[kk]]
[16:21:03.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.166]                     next
[16:21:03.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.166]                 }
[16:21:03.166]                 NAMES <- toupper(added)
[16:21:03.166]                 for (kk in seq_along(NAMES)) {
[16:21:03.166]                   name <- added[[kk]]
[16:21:03.166]                   NAME <- NAMES[[kk]]
[16:21:03.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.166]                     next
[16:21:03.166]                   args[[name]] <- ""
[16:21:03.166]                 }
[16:21:03.166]                 NAMES <- toupper(removed)
[16:21:03.166]                 for (kk in seq_along(NAMES)) {
[16:21:03.166]                   name <- removed[[kk]]
[16:21:03.166]                   NAME <- NAMES[[kk]]
[16:21:03.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.166]                     next
[16:21:03.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.166]                 }
[16:21:03.166]                 if (length(args) > 0) 
[16:21:03.166]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.166]             }
[16:21:03.166]             else {
[16:21:03.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.166]             }
[16:21:03.166]             {
[16:21:03.166]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.166]                   0L) {
[16:21:03.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.166]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.166]                   base::options(opts)
[16:21:03.166]                 }
[16:21:03.166]                 {
[16:21:03.166]                   {
[16:21:03.166]                     NULL
[16:21:03.166]                     RNGkind("Mersenne-Twister")
[16:21:03.166]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.166]                       inherits = FALSE)
[16:21:03.166]                   }
[16:21:03.166]                   options(future.plan = NULL)
[16:21:03.166]                   if (is.na(NA_character_)) 
[16:21:03.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.166]                     .init = FALSE)
[16:21:03.166]                 }
[16:21:03.166]             }
[16:21:03.166]         }
[16:21:03.166]     })
[16:21:03.166]     if (TRUE) {
[16:21:03.166]         base::sink(type = "output", split = FALSE)
[16:21:03.166]         if (TRUE) {
[16:21:03.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.166]         }
[16:21:03.166]         else {
[16:21:03.166]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.166]         }
[16:21:03.166]         base::close(...future.stdout)
[16:21:03.166]         ...future.stdout <- NULL
[16:21:03.166]     }
[16:21:03.166]     ...future.result$conditions <- ...future.conditions
[16:21:03.166]     ...future.result$finished <- base::Sys.time()
[16:21:03.166]     ...future.result
[16:21:03.166] }
[16:21:03.168] plan(): Setting new future strategy stack:
[16:21:03.168] List of future strategies:
[16:21:03.168] 1. sequential:
[16:21:03.168]    - args: function (..., envir = parent.frame())
[16:21:03.168]    - tweaked: FALSE
[16:21:03.168]    - call: NULL
[16:21:03.169] plan(): nbrOfWorkers() = 1
[16:21:03.170] plan(): Setting new future strategy stack:
[16:21:03.170] List of future strategies:
[16:21:03.170] 1. sequential:
[16:21:03.170]    - args: function (..., envir = parent.frame())
[16:21:03.170]    - tweaked: FALSE
[16:21:03.170]    - call: plan(strategy)
[16:21:03.170] plan(): nbrOfWorkers() = 1
[16:21:03.171] SequentialFuture started (and completed)
[16:21:03.171] - Launch lazy future ... done
[16:21:03.171] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.172] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.172] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.173] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:21:03.174] Searching for globals ... DONE
[16:21:03.174] Resolving globals: TRUE
[16:21:03.174] Resolving any globals that are futures ...
[16:21:03.174] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:21:03.174] Resolving any globals that are futures ... DONE
[16:21:03.174] 
[16:21:03.174] 
[16:21:03.177] getGlobalsAndPackages() ... DONE
[16:21:03.177] run() for ‘Future’ ...
[16:21:03.177] - state: ‘created’
[16:21:03.177] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.178] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.178]   - Field: ‘label’
[16:21:03.178]   - Field: ‘local’
[16:21:03.178]   - Field: ‘owner’
[16:21:03.178]   - Field: ‘envir’
[16:21:03.178]   - Field: ‘packages’
[16:21:03.178]   - Field: ‘gc’
[16:21:03.178]   - Field: ‘conditions’
[16:21:03.178]   - Field: ‘expr’
[16:21:03.179]   - Field: ‘uuid’
[16:21:03.179]   - Field: ‘seed’
[16:21:03.179]   - Field: ‘version’
[16:21:03.179]   - Field: ‘result’
[16:21:03.179]   - Field: ‘asynchronous’
[16:21:03.179]   - Field: ‘calls’
[16:21:03.179]   - Field: ‘globals’
[16:21:03.179]   - Field: ‘stdout’
[16:21:03.179]   - Field: ‘earlySignal’
[16:21:03.179]   - Field: ‘lazy’
[16:21:03.180]   - Field: ‘state’
[16:21:03.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.180] - Launch lazy future ...
[16:21:03.180] Packages needed by the future expression (n = 0): <none>
[16:21:03.180] Packages needed by future strategies (n = 0): <none>
[16:21:03.180] {
[16:21:03.180]     {
[16:21:03.180]         {
[16:21:03.180]             ...future.startTime <- base::Sys.time()
[16:21:03.180]             {
[16:21:03.180]                 {
[16:21:03.180]                   {
[16:21:03.180]                     base::local({
[16:21:03.180]                       has_future <- base::requireNamespace("future", 
[16:21:03.180]                         quietly = TRUE)
[16:21:03.180]                       if (has_future) {
[16:21:03.180]                         ns <- base::getNamespace("future")
[16:21:03.180]                         version <- ns[[".package"]][["version"]]
[16:21:03.180]                         if (is.null(version)) 
[16:21:03.180]                           version <- utils::packageVersion("future")
[16:21:03.180]                       }
[16:21:03.180]                       else {
[16:21:03.180]                         version <- NULL
[16:21:03.180]                       }
[16:21:03.180]                       if (!has_future || version < "1.8.0") {
[16:21:03.180]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.180]                           "", base::R.version$version.string), 
[16:21:03.180]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.180]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.180]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.180]                             "release", "version")], collapse = " "), 
[16:21:03.180]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.180]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.180]                           info)
[16:21:03.180]                         info <- base::paste(info, collapse = "; ")
[16:21:03.180]                         if (!has_future) {
[16:21:03.180]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.180]                             info)
[16:21:03.180]                         }
[16:21:03.180]                         else {
[16:21:03.180]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.180]                             info, version)
[16:21:03.180]                         }
[16:21:03.180]                         base::stop(msg)
[16:21:03.180]                       }
[16:21:03.180]                     })
[16:21:03.180]                   }
[16:21:03.180]                   ...future.strategy.old <- future::plan("list")
[16:21:03.180]                   options(future.plan = NULL)
[16:21:03.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.180]                 }
[16:21:03.180]                 ...future.workdir <- getwd()
[16:21:03.180]             }
[16:21:03.180]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.180]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.180]         }
[16:21:03.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.180]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.180]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.180]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.180]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.180]             base::names(...future.oldOptions))
[16:21:03.180]     }
[16:21:03.180]     if (FALSE) {
[16:21:03.180]     }
[16:21:03.180]     else {
[16:21:03.180]         if (TRUE) {
[16:21:03.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.180]                 open = "w")
[16:21:03.180]         }
[16:21:03.180]         else {
[16:21:03.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.180]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.180]         }
[16:21:03.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.180]             base::sink(type = "output", split = FALSE)
[16:21:03.180]             base::close(...future.stdout)
[16:21:03.180]         }, add = TRUE)
[16:21:03.180]     }
[16:21:03.180]     ...future.frame <- base::sys.nframe()
[16:21:03.180]     ...future.conditions <- base::list()
[16:21:03.180]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.180]     if (FALSE) {
[16:21:03.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.180]     }
[16:21:03.180]     ...future.result <- base::tryCatch({
[16:21:03.180]         base::withCallingHandlers({
[16:21:03.180]             ...future.value <- base::withVisible(base::local({
[16:21:03.180]                 b <- a
[16:21:03.180]                 a <- 2
[16:21:03.180]                 a * b
[16:21:03.180]             }))
[16:21:03.180]             future::FutureResult(value = ...future.value$value, 
[16:21:03.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.180]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.180]                     ...future.globalenv.names))
[16:21:03.180]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.180]         }, condition = base::local({
[16:21:03.180]             c <- base::c
[16:21:03.180]             inherits <- base::inherits
[16:21:03.180]             invokeRestart <- base::invokeRestart
[16:21:03.180]             length <- base::length
[16:21:03.180]             list <- base::list
[16:21:03.180]             seq.int <- base::seq.int
[16:21:03.180]             signalCondition <- base::signalCondition
[16:21:03.180]             sys.calls <- base::sys.calls
[16:21:03.180]             `[[` <- base::`[[`
[16:21:03.180]             `+` <- base::`+`
[16:21:03.180]             `<<-` <- base::`<<-`
[16:21:03.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.180]                   3L)]
[16:21:03.180]             }
[16:21:03.180]             function(cond) {
[16:21:03.180]                 is_error <- inherits(cond, "error")
[16:21:03.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.180]                   NULL)
[16:21:03.180]                 if (is_error) {
[16:21:03.180]                   sessionInformation <- function() {
[16:21:03.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.180]                       search = base::search(), system = base::Sys.info())
[16:21:03.180]                   }
[16:21:03.180]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.180]                     cond$call), session = sessionInformation(), 
[16:21:03.180]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.180]                   signalCondition(cond)
[16:21:03.180]                 }
[16:21:03.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.180]                 "immediateCondition"))) {
[16:21:03.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.180]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.180]                   if (TRUE && !signal) {
[16:21:03.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.180]                     {
[16:21:03.180]                       inherits <- base::inherits
[16:21:03.180]                       invokeRestart <- base::invokeRestart
[16:21:03.180]                       is.null <- base::is.null
[16:21:03.180]                       muffled <- FALSE
[16:21:03.180]                       if (inherits(cond, "message")) {
[16:21:03.180]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.180]                         if (muffled) 
[16:21:03.180]                           invokeRestart("muffleMessage")
[16:21:03.180]                       }
[16:21:03.180]                       else if (inherits(cond, "warning")) {
[16:21:03.180]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.180]                         if (muffled) 
[16:21:03.180]                           invokeRestart("muffleWarning")
[16:21:03.180]                       }
[16:21:03.180]                       else if (inherits(cond, "condition")) {
[16:21:03.180]                         if (!is.null(pattern)) {
[16:21:03.180]                           computeRestarts <- base::computeRestarts
[16:21:03.180]                           grepl <- base::grepl
[16:21:03.180]                           restarts <- computeRestarts(cond)
[16:21:03.180]                           for (restart in restarts) {
[16:21:03.180]                             name <- restart$name
[16:21:03.180]                             if (is.null(name)) 
[16:21:03.180]                               next
[16:21:03.180]                             if (!grepl(pattern, name)) 
[16:21:03.180]                               next
[16:21:03.180]                             invokeRestart(restart)
[16:21:03.180]                             muffled <- TRUE
[16:21:03.180]                             break
[16:21:03.180]                           }
[16:21:03.180]                         }
[16:21:03.180]                       }
[16:21:03.180]                       invisible(muffled)
[16:21:03.180]                     }
[16:21:03.180]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.180]                   }
[16:21:03.180]                 }
[16:21:03.180]                 else {
[16:21:03.180]                   if (TRUE) {
[16:21:03.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.180]                     {
[16:21:03.180]                       inherits <- base::inherits
[16:21:03.180]                       invokeRestart <- base::invokeRestart
[16:21:03.180]                       is.null <- base::is.null
[16:21:03.180]                       muffled <- FALSE
[16:21:03.180]                       if (inherits(cond, "message")) {
[16:21:03.180]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.180]                         if (muffled) 
[16:21:03.180]                           invokeRestart("muffleMessage")
[16:21:03.180]                       }
[16:21:03.180]                       else if (inherits(cond, "warning")) {
[16:21:03.180]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.180]                         if (muffled) 
[16:21:03.180]                           invokeRestart("muffleWarning")
[16:21:03.180]                       }
[16:21:03.180]                       else if (inherits(cond, "condition")) {
[16:21:03.180]                         if (!is.null(pattern)) {
[16:21:03.180]                           computeRestarts <- base::computeRestarts
[16:21:03.180]                           grepl <- base::grepl
[16:21:03.180]                           restarts <- computeRestarts(cond)
[16:21:03.180]                           for (restart in restarts) {
[16:21:03.180]                             name <- restart$name
[16:21:03.180]                             if (is.null(name)) 
[16:21:03.180]                               next
[16:21:03.180]                             if (!grepl(pattern, name)) 
[16:21:03.180]                               next
[16:21:03.180]                             invokeRestart(restart)
[16:21:03.180]                             muffled <- TRUE
[16:21:03.180]                             break
[16:21:03.180]                           }
[16:21:03.180]                         }
[16:21:03.180]                       }
[16:21:03.180]                       invisible(muffled)
[16:21:03.180]                     }
[16:21:03.180]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.180]                   }
[16:21:03.180]                 }
[16:21:03.180]             }
[16:21:03.180]         }))
[16:21:03.180]     }, error = function(ex) {
[16:21:03.180]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.180]                 ...future.rng), started = ...future.startTime, 
[16:21:03.180]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.180]             version = "1.8"), class = "FutureResult")
[16:21:03.180]     }, finally = {
[16:21:03.180]         if (!identical(...future.workdir, getwd())) 
[16:21:03.180]             setwd(...future.workdir)
[16:21:03.180]         {
[16:21:03.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.180]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.180]             }
[16:21:03.180]             base::options(...future.oldOptions)
[16:21:03.180]             if (.Platform$OS.type == "windows") {
[16:21:03.180]                 old_names <- names(...future.oldEnvVars)
[16:21:03.180]                 envs <- base::Sys.getenv()
[16:21:03.180]                 names <- names(envs)
[16:21:03.180]                 common <- intersect(names, old_names)
[16:21:03.180]                 added <- setdiff(names, old_names)
[16:21:03.180]                 removed <- setdiff(old_names, names)
[16:21:03.180]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.180]                   envs[common]]
[16:21:03.180]                 NAMES <- toupper(changed)
[16:21:03.180]                 args <- list()
[16:21:03.180]                 for (kk in seq_along(NAMES)) {
[16:21:03.180]                   name <- changed[[kk]]
[16:21:03.180]                   NAME <- NAMES[[kk]]
[16:21:03.180]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.180]                     next
[16:21:03.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.180]                 }
[16:21:03.180]                 NAMES <- toupper(added)
[16:21:03.180]                 for (kk in seq_along(NAMES)) {
[16:21:03.180]                   name <- added[[kk]]
[16:21:03.180]                   NAME <- NAMES[[kk]]
[16:21:03.180]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.180]                     next
[16:21:03.180]                   args[[name]] <- ""
[16:21:03.180]                 }
[16:21:03.180]                 NAMES <- toupper(removed)
[16:21:03.180]                 for (kk in seq_along(NAMES)) {
[16:21:03.180]                   name <- removed[[kk]]
[16:21:03.180]                   NAME <- NAMES[[kk]]
[16:21:03.180]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.180]                     next
[16:21:03.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.180]                 }
[16:21:03.180]                 if (length(args) > 0) 
[16:21:03.180]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.180]             }
[16:21:03.180]             else {
[16:21:03.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.180]             }
[16:21:03.180]             {
[16:21:03.180]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.180]                   0L) {
[16:21:03.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.180]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.180]                   base::options(opts)
[16:21:03.180]                 }
[16:21:03.180]                 {
[16:21:03.180]                   {
[16:21:03.180]                     NULL
[16:21:03.180]                     RNGkind("Mersenne-Twister")
[16:21:03.180]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.180]                       inherits = FALSE)
[16:21:03.180]                   }
[16:21:03.180]                   options(future.plan = NULL)
[16:21:03.180]                   if (is.na(NA_character_)) 
[16:21:03.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.180]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.180]                     .init = FALSE)
[16:21:03.180]                 }
[16:21:03.180]             }
[16:21:03.180]         }
[16:21:03.180]     })
[16:21:03.180]     if (TRUE) {
[16:21:03.180]         base::sink(type = "output", split = FALSE)
[16:21:03.180]         if (TRUE) {
[16:21:03.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.180]         }
[16:21:03.180]         else {
[16:21:03.180]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.180]         }
[16:21:03.180]         base::close(...future.stdout)
[16:21:03.180]         ...future.stdout <- NULL
[16:21:03.180]     }
[16:21:03.180]     ...future.result$conditions <- ...future.conditions
[16:21:03.180]     ...future.result$finished <- base::Sys.time()
[16:21:03.180]     ...future.result
[16:21:03.180] }
[16:21:03.182] plan(): Setting new future strategy stack:
[16:21:03.182] List of future strategies:
[16:21:03.182] 1. sequential:
[16:21:03.182]    - args: function (..., envir = parent.frame())
[16:21:03.182]    - tweaked: FALSE
[16:21:03.182]    - call: NULL
[16:21:03.183] plan(): nbrOfWorkers() = 1
[16:21:03.184] plan(): Setting new future strategy stack:
[16:21:03.184] List of future strategies:
[16:21:03.184] 1. sequential:
[16:21:03.184]    - args: function (..., envir = parent.frame())
[16:21:03.184]    - tweaked: FALSE
[16:21:03.184]    - call: plan(strategy)
[16:21:03.184] plan(): nbrOfWorkers() = 1
[16:21:03.184] SequentialFuture started (and completed)
[16:21:03.184] signalConditions() ...
[16:21:03.184]  - include = ‘immediateCondition’
[16:21:03.185]  - exclude = 
[16:21:03.185]  - resignal = FALSE
[16:21:03.185]  - Number of conditions: 1
[16:21:03.185] signalConditions() ... done
[16:21:03.185] - Launch lazy future ... done
[16:21:03.185] run() for ‘SequentialFuture’ ... done
[16:21:03.185] signalConditions() ...
[16:21:03.185]  - include = ‘immediateCondition’
[16:21:03.185]  - exclude = 
[16:21:03.185]  - resignal = FALSE
[16:21:03.186]  - Number of conditions: 1
[16:21:03.186] signalConditions() ... done
[16:21:03.186] Future state: ‘finished’
[16:21:03.186] signalConditions() ...
[16:21:03.186]  - include = ‘condition’
[16:21:03.186]  - exclude = ‘immediateCondition’
[16:21:03.186]  - resignal = TRUE
[16:21:03.186]  - Number of conditions: 1
[16:21:03.186]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:21:03.186] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "b478068843b5" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:21:03"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.203] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.203] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.205] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.205] Searching for globals ... DONE
[16:21:03.205] Resolving globals: TRUE
[16:21:03.205] Resolving any globals that are futures ...
[16:21:03.205] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.205] Resolving any globals that are futures ... DONE
[16:21:03.206] Resolving futures part of globals (recursively) ...
[16:21:03.208] resolve() on list ...
[16:21:03.208]  recursive: 99
[16:21:03.209]  length: 1
[16:21:03.209]  elements: ‘ii’
[16:21:03.209]  length: 0 (resolved future 1)
[16:21:03.209] resolve() on list ... DONE
[16:21:03.209] - globals: [1] ‘ii’
[16:21:03.209] Resolving futures part of globals (recursively) ... DONE
[16:21:03.210] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.210] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.210] - globals: [1] ‘ii’
[16:21:03.211] 
[16:21:03.211] getGlobalsAndPackages() ... DONE
[16:21:03.211] run() for ‘Future’ ...
[16:21:03.211] - state: ‘created’
[16:21:03.211] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.211] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.211] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.212]   - Field: ‘label’
[16:21:03.212]   - Field: ‘local’
[16:21:03.212]   - Field: ‘owner’
[16:21:03.212]   - Field: ‘envir’
[16:21:03.212]   - Field: ‘packages’
[16:21:03.212]   - Field: ‘gc’
[16:21:03.212]   - Field: ‘conditions’
[16:21:03.212]   - Field: ‘expr’
[16:21:03.212]   - Field: ‘uuid’
[16:21:03.212]   - Field: ‘seed’
[16:21:03.213]   - Field: ‘version’
[16:21:03.213]   - Field: ‘result’
[16:21:03.213]   - Field: ‘asynchronous’
[16:21:03.213]   - Field: ‘calls’
[16:21:03.213]   - Field: ‘globals’
[16:21:03.213]   - Field: ‘stdout’
[16:21:03.213]   - Field: ‘earlySignal’
[16:21:03.213]   - Field: ‘lazy’
[16:21:03.213]   - Field: ‘state’
[16:21:03.213] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.214] - Launch lazy future ...
[16:21:03.214] Packages needed by the future expression (n = 0): <none>
[16:21:03.214] Packages needed by future strategies (n = 0): <none>
[16:21:03.214] {
[16:21:03.214]     {
[16:21:03.214]         {
[16:21:03.214]             ...future.startTime <- base::Sys.time()
[16:21:03.214]             {
[16:21:03.214]                 {
[16:21:03.214]                   {
[16:21:03.214]                     base::local({
[16:21:03.214]                       has_future <- base::requireNamespace("future", 
[16:21:03.214]                         quietly = TRUE)
[16:21:03.214]                       if (has_future) {
[16:21:03.214]                         ns <- base::getNamespace("future")
[16:21:03.214]                         version <- ns[[".package"]][["version"]]
[16:21:03.214]                         if (is.null(version)) 
[16:21:03.214]                           version <- utils::packageVersion("future")
[16:21:03.214]                       }
[16:21:03.214]                       else {
[16:21:03.214]                         version <- NULL
[16:21:03.214]                       }
[16:21:03.214]                       if (!has_future || version < "1.8.0") {
[16:21:03.214]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.214]                           "", base::R.version$version.string), 
[16:21:03.214]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.214]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.214]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.214]                             "release", "version")], collapse = " "), 
[16:21:03.214]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.214]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.214]                           info)
[16:21:03.214]                         info <- base::paste(info, collapse = "; ")
[16:21:03.214]                         if (!has_future) {
[16:21:03.214]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.214]                             info)
[16:21:03.214]                         }
[16:21:03.214]                         else {
[16:21:03.214]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.214]                             info, version)
[16:21:03.214]                         }
[16:21:03.214]                         base::stop(msg)
[16:21:03.214]                       }
[16:21:03.214]                     })
[16:21:03.214]                   }
[16:21:03.214]                   ...future.strategy.old <- future::plan("list")
[16:21:03.214]                   options(future.plan = NULL)
[16:21:03.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.214]                 }
[16:21:03.214]                 ...future.workdir <- getwd()
[16:21:03.214]             }
[16:21:03.214]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.214]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.214]         }
[16:21:03.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.214]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.214]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.214]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.214]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.214]             base::names(...future.oldOptions))
[16:21:03.214]     }
[16:21:03.214]     if (FALSE) {
[16:21:03.214]     }
[16:21:03.214]     else {
[16:21:03.214]         if (TRUE) {
[16:21:03.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.214]                 open = "w")
[16:21:03.214]         }
[16:21:03.214]         else {
[16:21:03.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.214]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.214]         }
[16:21:03.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.214]             base::sink(type = "output", split = FALSE)
[16:21:03.214]             base::close(...future.stdout)
[16:21:03.214]         }, add = TRUE)
[16:21:03.214]     }
[16:21:03.214]     ...future.frame <- base::sys.nframe()
[16:21:03.214]     ...future.conditions <- base::list()
[16:21:03.214]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.214]     if (FALSE) {
[16:21:03.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.214]     }
[16:21:03.214]     ...future.result <- base::tryCatch({
[16:21:03.214]         base::withCallingHandlers({
[16:21:03.214]             ...future.value <- base::withVisible(base::local({
[16:21:03.214]                 b <- a * ii
[16:21:03.214]                 a <- 0
[16:21:03.214]                 b
[16:21:03.214]             }))
[16:21:03.214]             future::FutureResult(value = ...future.value$value, 
[16:21:03.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.214]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.214]                     ...future.globalenv.names))
[16:21:03.214]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.214]         }, condition = base::local({
[16:21:03.214]             c <- base::c
[16:21:03.214]             inherits <- base::inherits
[16:21:03.214]             invokeRestart <- base::invokeRestart
[16:21:03.214]             length <- base::length
[16:21:03.214]             list <- base::list
[16:21:03.214]             seq.int <- base::seq.int
[16:21:03.214]             signalCondition <- base::signalCondition
[16:21:03.214]             sys.calls <- base::sys.calls
[16:21:03.214]             `[[` <- base::`[[`
[16:21:03.214]             `+` <- base::`+`
[16:21:03.214]             `<<-` <- base::`<<-`
[16:21:03.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.214]                   3L)]
[16:21:03.214]             }
[16:21:03.214]             function(cond) {
[16:21:03.214]                 is_error <- inherits(cond, "error")
[16:21:03.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.214]                   NULL)
[16:21:03.214]                 if (is_error) {
[16:21:03.214]                   sessionInformation <- function() {
[16:21:03.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.214]                       search = base::search(), system = base::Sys.info())
[16:21:03.214]                   }
[16:21:03.214]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.214]                     cond$call), session = sessionInformation(), 
[16:21:03.214]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.214]                   signalCondition(cond)
[16:21:03.214]                 }
[16:21:03.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.214]                 "immediateCondition"))) {
[16:21:03.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.214]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.214]                   if (TRUE && !signal) {
[16:21:03.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.214]                     {
[16:21:03.214]                       inherits <- base::inherits
[16:21:03.214]                       invokeRestart <- base::invokeRestart
[16:21:03.214]                       is.null <- base::is.null
[16:21:03.214]                       muffled <- FALSE
[16:21:03.214]                       if (inherits(cond, "message")) {
[16:21:03.214]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.214]                         if (muffled) 
[16:21:03.214]                           invokeRestart("muffleMessage")
[16:21:03.214]                       }
[16:21:03.214]                       else if (inherits(cond, "warning")) {
[16:21:03.214]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.214]                         if (muffled) 
[16:21:03.214]                           invokeRestart("muffleWarning")
[16:21:03.214]                       }
[16:21:03.214]                       else if (inherits(cond, "condition")) {
[16:21:03.214]                         if (!is.null(pattern)) {
[16:21:03.214]                           computeRestarts <- base::computeRestarts
[16:21:03.214]                           grepl <- base::grepl
[16:21:03.214]                           restarts <- computeRestarts(cond)
[16:21:03.214]                           for (restart in restarts) {
[16:21:03.214]                             name <- restart$name
[16:21:03.214]                             if (is.null(name)) 
[16:21:03.214]                               next
[16:21:03.214]                             if (!grepl(pattern, name)) 
[16:21:03.214]                               next
[16:21:03.214]                             invokeRestart(restart)
[16:21:03.214]                             muffled <- TRUE
[16:21:03.214]                             break
[16:21:03.214]                           }
[16:21:03.214]                         }
[16:21:03.214]                       }
[16:21:03.214]                       invisible(muffled)
[16:21:03.214]                     }
[16:21:03.214]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.214]                   }
[16:21:03.214]                 }
[16:21:03.214]                 else {
[16:21:03.214]                   if (TRUE) {
[16:21:03.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.214]                     {
[16:21:03.214]                       inherits <- base::inherits
[16:21:03.214]                       invokeRestart <- base::invokeRestart
[16:21:03.214]                       is.null <- base::is.null
[16:21:03.214]                       muffled <- FALSE
[16:21:03.214]                       if (inherits(cond, "message")) {
[16:21:03.214]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.214]                         if (muffled) 
[16:21:03.214]                           invokeRestart("muffleMessage")
[16:21:03.214]                       }
[16:21:03.214]                       else if (inherits(cond, "warning")) {
[16:21:03.214]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.214]                         if (muffled) 
[16:21:03.214]                           invokeRestart("muffleWarning")
[16:21:03.214]                       }
[16:21:03.214]                       else if (inherits(cond, "condition")) {
[16:21:03.214]                         if (!is.null(pattern)) {
[16:21:03.214]                           computeRestarts <- base::computeRestarts
[16:21:03.214]                           grepl <- base::grepl
[16:21:03.214]                           restarts <- computeRestarts(cond)
[16:21:03.214]                           for (restart in restarts) {
[16:21:03.214]                             name <- restart$name
[16:21:03.214]                             if (is.null(name)) 
[16:21:03.214]                               next
[16:21:03.214]                             if (!grepl(pattern, name)) 
[16:21:03.214]                               next
[16:21:03.214]                             invokeRestart(restart)
[16:21:03.214]                             muffled <- TRUE
[16:21:03.214]                             break
[16:21:03.214]                           }
[16:21:03.214]                         }
[16:21:03.214]                       }
[16:21:03.214]                       invisible(muffled)
[16:21:03.214]                     }
[16:21:03.214]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.214]                   }
[16:21:03.214]                 }
[16:21:03.214]             }
[16:21:03.214]         }))
[16:21:03.214]     }, error = function(ex) {
[16:21:03.214]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.214]                 ...future.rng), started = ...future.startTime, 
[16:21:03.214]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.214]             version = "1.8"), class = "FutureResult")
[16:21:03.214]     }, finally = {
[16:21:03.214]         if (!identical(...future.workdir, getwd())) 
[16:21:03.214]             setwd(...future.workdir)
[16:21:03.214]         {
[16:21:03.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.214]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.214]             }
[16:21:03.214]             base::options(...future.oldOptions)
[16:21:03.214]             if (.Platform$OS.type == "windows") {
[16:21:03.214]                 old_names <- names(...future.oldEnvVars)
[16:21:03.214]                 envs <- base::Sys.getenv()
[16:21:03.214]                 names <- names(envs)
[16:21:03.214]                 common <- intersect(names, old_names)
[16:21:03.214]                 added <- setdiff(names, old_names)
[16:21:03.214]                 removed <- setdiff(old_names, names)
[16:21:03.214]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.214]                   envs[common]]
[16:21:03.214]                 NAMES <- toupper(changed)
[16:21:03.214]                 args <- list()
[16:21:03.214]                 for (kk in seq_along(NAMES)) {
[16:21:03.214]                   name <- changed[[kk]]
[16:21:03.214]                   NAME <- NAMES[[kk]]
[16:21:03.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.214]                     next
[16:21:03.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.214]                 }
[16:21:03.214]                 NAMES <- toupper(added)
[16:21:03.214]                 for (kk in seq_along(NAMES)) {
[16:21:03.214]                   name <- added[[kk]]
[16:21:03.214]                   NAME <- NAMES[[kk]]
[16:21:03.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.214]                     next
[16:21:03.214]                   args[[name]] <- ""
[16:21:03.214]                 }
[16:21:03.214]                 NAMES <- toupper(removed)
[16:21:03.214]                 for (kk in seq_along(NAMES)) {
[16:21:03.214]                   name <- removed[[kk]]
[16:21:03.214]                   NAME <- NAMES[[kk]]
[16:21:03.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.214]                     next
[16:21:03.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.214]                 }
[16:21:03.214]                 if (length(args) > 0) 
[16:21:03.214]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.214]             }
[16:21:03.214]             else {
[16:21:03.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.214]             }
[16:21:03.214]             {
[16:21:03.214]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.214]                   0L) {
[16:21:03.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.214]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.214]                   base::options(opts)
[16:21:03.214]                 }
[16:21:03.214]                 {
[16:21:03.214]                   {
[16:21:03.214]                     NULL
[16:21:03.214]                     RNGkind("Mersenne-Twister")
[16:21:03.214]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.214]                       inherits = FALSE)
[16:21:03.214]                   }
[16:21:03.214]                   options(future.plan = NULL)
[16:21:03.214]                   if (is.na(NA_character_)) 
[16:21:03.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.214]                     .init = FALSE)
[16:21:03.214]                 }
[16:21:03.214]             }
[16:21:03.214]         }
[16:21:03.214]     })
[16:21:03.214]     if (TRUE) {
[16:21:03.214]         base::sink(type = "output", split = FALSE)
[16:21:03.214]         if (TRUE) {
[16:21:03.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.214]         }
[16:21:03.214]         else {
[16:21:03.214]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.214]         }
[16:21:03.214]         base::close(...future.stdout)
[16:21:03.214]         ...future.stdout <- NULL
[16:21:03.214]     }
[16:21:03.214]     ...future.result$conditions <- ...future.conditions
[16:21:03.214]     ...future.result$finished <- base::Sys.time()
[16:21:03.214]     ...future.result
[16:21:03.214] }
[16:21:03.216] assign_globals() ...
[16:21:03.216] List of 1
[16:21:03.216]  $ ii: int 1
[16:21:03.216]  - attr(*, "where")=List of 1
[16:21:03.216]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.216]  - attr(*, "resolved")= logi TRUE
[16:21:03.216]  - attr(*, "total_size")= num 56
[16:21:03.216]  - attr(*, "already-done")= logi TRUE
[16:21:03.219] - copied ‘ii’ to environment
[16:21:03.219] assign_globals() ... done
[16:21:03.219] plan(): Setting new future strategy stack:
[16:21:03.219] List of future strategies:
[16:21:03.219] 1. sequential:
[16:21:03.219]    - args: function (..., envir = parent.frame())
[16:21:03.219]    - tweaked: FALSE
[16:21:03.219]    - call: NULL
[16:21:03.219] plan(): nbrOfWorkers() = 1
[16:21:03.220] plan(): Setting new future strategy stack:
[16:21:03.220] List of future strategies:
[16:21:03.220] 1. sequential:
[16:21:03.220]    - args: function (..., envir = parent.frame())
[16:21:03.220]    - tweaked: FALSE
[16:21:03.220]    - call: plan(strategy)
[16:21:03.221] plan(): nbrOfWorkers() = 1
[16:21:03.221] SequentialFuture started (and completed)
[16:21:03.221] - Launch lazy future ... done
[16:21:03.221] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.221] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.222] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.223] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.223] Searching for globals ... DONE
[16:21:03.223] Resolving globals: TRUE
[16:21:03.223] Resolving any globals that are futures ...
[16:21:03.223] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.224] Resolving any globals that are futures ... DONE
[16:21:03.224] Resolving futures part of globals (recursively) ...
[16:21:03.224] resolve() on list ...
[16:21:03.224]  recursive: 99
[16:21:03.224]  length: 1
[16:21:03.224]  elements: ‘ii’
[16:21:03.224]  length: 0 (resolved future 1)
[16:21:03.225] resolve() on list ... DONE
[16:21:03.225] - globals: [1] ‘ii’
[16:21:03.225] Resolving futures part of globals (recursively) ... DONE
[16:21:03.225] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.225] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.225] - globals: [1] ‘ii’
[16:21:03.225] 
[16:21:03.226] getGlobalsAndPackages() ... DONE
[16:21:03.226] run() for ‘Future’ ...
[16:21:03.226] - state: ‘created’
[16:21:03.226] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.226] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.226]   - Field: ‘label’
[16:21:03.227]   - Field: ‘local’
[16:21:03.227]   - Field: ‘owner’
[16:21:03.227]   - Field: ‘envir’
[16:21:03.227]   - Field: ‘packages’
[16:21:03.227]   - Field: ‘gc’
[16:21:03.227]   - Field: ‘conditions’
[16:21:03.227]   - Field: ‘expr’
[16:21:03.227]   - Field: ‘uuid’
[16:21:03.227]   - Field: ‘seed’
[16:21:03.227]   - Field: ‘version’
[16:21:03.228]   - Field: ‘result’
[16:21:03.228]   - Field: ‘asynchronous’
[16:21:03.228]   - Field: ‘calls’
[16:21:03.228]   - Field: ‘globals’
[16:21:03.228]   - Field: ‘stdout’
[16:21:03.228]   - Field: ‘earlySignal’
[16:21:03.228]   - Field: ‘lazy’
[16:21:03.228]   - Field: ‘state’
[16:21:03.228] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.228] - Launch lazy future ...
[16:21:03.229] Packages needed by the future expression (n = 0): <none>
[16:21:03.229] Packages needed by future strategies (n = 0): <none>
[16:21:03.229] {
[16:21:03.229]     {
[16:21:03.229]         {
[16:21:03.229]             ...future.startTime <- base::Sys.time()
[16:21:03.229]             {
[16:21:03.229]                 {
[16:21:03.229]                   {
[16:21:03.229]                     base::local({
[16:21:03.229]                       has_future <- base::requireNamespace("future", 
[16:21:03.229]                         quietly = TRUE)
[16:21:03.229]                       if (has_future) {
[16:21:03.229]                         ns <- base::getNamespace("future")
[16:21:03.229]                         version <- ns[[".package"]][["version"]]
[16:21:03.229]                         if (is.null(version)) 
[16:21:03.229]                           version <- utils::packageVersion("future")
[16:21:03.229]                       }
[16:21:03.229]                       else {
[16:21:03.229]                         version <- NULL
[16:21:03.229]                       }
[16:21:03.229]                       if (!has_future || version < "1.8.0") {
[16:21:03.229]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.229]                           "", base::R.version$version.string), 
[16:21:03.229]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.229]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.229]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.229]                             "release", "version")], collapse = " "), 
[16:21:03.229]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.229]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.229]                           info)
[16:21:03.229]                         info <- base::paste(info, collapse = "; ")
[16:21:03.229]                         if (!has_future) {
[16:21:03.229]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.229]                             info)
[16:21:03.229]                         }
[16:21:03.229]                         else {
[16:21:03.229]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.229]                             info, version)
[16:21:03.229]                         }
[16:21:03.229]                         base::stop(msg)
[16:21:03.229]                       }
[16:21:03.229]                     })
[16:21:03.229]                   }
[16:21:03.229]                   ...future.strategy.old <- future::plan("list")
[16:21:03.229]                   options(future.plan = NULL)
[16:21:03.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.229]                 }
[16:21:03.229]                 ...future.workdir <- getwd()
[16:21:03.229]             }
[16:21:03.229]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.229]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.229]         }
[16:21:03.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.229]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.229]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.229]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.229]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.229]             base::names(...future.oldOptions))
[16:21:03.229]     }
[16:21:03.229]     if (FALSE) {
[16:21:03.229]     }
[16:21:03.229]     else {
[16:21:03.229]         if (TRUE) {
[16:21:03.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.229]                 open = "w")
[16:21:03.229]         }
[16:21:03.229]         else {
[16:21:03.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.229]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.229]         }
[16:21:03.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.229]             base::sink(type = "output", split = FALSE)
[16:21:03.229]             base::close(...future.stdout)
[16:21:03.229]         }, add = TRUE)
[16:21:03.229]     }
[16:21:03.229]     ...future.frame <- base::sys.nframe()
[16:21:03.229]     ...future.conditions <- base::list()
[16:21:03.229]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.229]     if (FALSE) {
[16:21:03.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.229]     }
[16:21:03.229]     ...future.result <- base::tryCatch({
[16:21:03.229]         base::withCallingHandlers({
[16:21:03.229]             ...future.value <- base::withVisible(base::local({
[16:21:03.229]                 b <- a * ii
[16:21:03.229]                 a <- 0
[16:21:03.229]                 b
[16:21:03.229]             }))
[16:21:03.229]             future::FutureResult(value = ...future.value$value, 
[16:21:03.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.229]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.229]                     ...future.globalenv.names))
[16:21:03.229]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.229]         }, condition = base::local({
[16:21:03.229]             c <- base::c
[16:21:03.229]             inherits <- base::inherits
[16:21:03.229]             invokeRestart <- base::invokeRestart
[16:21:03.229]             length <- base::length
[16:21:03.229]             list <- base::list
[16:21:03.229]             seq.int <- base::seq.int
[16:21:03.229]             signalCondition <- base::signalCondition
[16:21:03.229]             sys.calls <- base::sys.calls
[16:21:03.229]             `[[` <- base::`[[`
[16:21:03.229]             `+` <- base::`+`
[16:21:03.229]             `<<-` <- base::`<<-`
[16:21:03.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.229]                   3L)]
[16:21:03.229]             }
[16:21:03.229]             function(cond) {
[16:21:03.229]                 is_error <- inherits(cond, "error")
[16:21:03.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.229]                   NULL)
[16:21:03.229]                 if (is_error) {
[16:21:03.229]                   sessionInformation <- function() {
[16:21:03.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.229]                       search = base::search(), system = base::Sys.info())
[16:21:03.229]                   }
[16:21:03.229]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.229]                     cond$call), session = sessionInformation(), 
[16:21:03.229]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.229]                   signalCondition(cond)
[16:21:03.229]                 }
[16:21:03.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.229]                 "immediateCondition"))) {
[16:21:03.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.229]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.229]                   if (TRUE && !signal) {
[16:21:03.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.229]                     {
[16:21:03.229]                       inherits <- base::inherits
[16:21:03.229]                       invokeRestart <- base::invokeRestart
[16:21:03.229]                       is.null <- base::is.null
[16:21:03.229]                       muffled <- FALSE
[16:21:03.229]                       if (inherits(cond, "message")) {
[16:21:03.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.229]                         if (muffled) 
[16:21:03.229]                           invokeRestart("muffleMessage")
[16:21:03.229]                       }
[16:21:03.229]                       else if (inherits(cond, "warning")) {
[16:21:03.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.229]                         if (muffled) 
[16:21:03.229]                           invokeRestart("muffleWarning")
[16:21:03.229]                       }
[16:21:03.229]                       else if (inherits(cond, "condition")) {
[16:21:03.229]                         if (!is.null(pattern)) {
[16:21:03.229]                           computeRestarts <- base::computeRestarts
[16:21:03.229]                           grepl <- base::grepl
[16:21:03.229]                           restarts <- computeRestarts(cond)
[16:21:03.229]                           for (restart in restarts) {
[16:21:03.229]                             name <- restart$name
[16:21:03.229]                             if (is.null(name)) 
[16:21:03.229]                               next
[16:21:03.229]                             if (!grepl(pattern, name)) 
[16:21:03.229]                               next
[16:21:03.229]                             invokeRestart(restart)
[16:21:03.229]                             muffled <- TRUE
[16:21:03.229]                             break
[16:21:03.229]                           }
[16:21:03.229]                         }
[16:21:03.229]                       }
[16:21:03.229]                       invisible(muffled)
[16:21:03.229]                     }
[16:21:03.229]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.229]                   }
[16:21:03.229]                 }
[16:21:03.229]                 else {
[16:21:03.229]                   if (TRUE) {
[16:21:03.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.229]                     {
[16:21:03.229]                       inherits <- base::inherits
[16:21:03.229]                       invokeRestart <- base::invokeRestart
[16:21:03.229]                       is.null <- base::is.null
[16:21:03.229]                       muffled <- FALSE
[16:21:03.229]                       if (inherits(cond, "message")) {
[16:21:03.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.229]                         if (muffled) 
[16:21:03.229]                           invokeRestart("muffleMessage")
[16:21:03.229]                       }
[16:21:03.229]                       else if (inherits(cond, "warning")) {
[16:21:03.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.229]                         if (muffled) 
[16:21:03.229]                           invokeRestart("muffleWarning")
[16:21:03.229]                       }
[16:21:03.229]                       else if (inherits(cond, "condition")) {
[16:21:03.229]                         if (!is.null(pattern)) {
[16:21:03.229]                           computeRestarts <- base::computeRestarts
[16:21:03.229]                           grepl <- base::grepl
[16:21:03.229]                           restarts <- computeRestarts(cond)
[16:21:03.229]                           for (restart in restarts) {
[16:21:03.229]                             name <- restart$name
[16:21:03.229]                             if (is.null(name)) 
[16:21:03.229]                               next
[16:21:03.229]                             if (!grepl(pattern, name)) 
[16:21:03.229]                               next
[16:21:03.229]                             invokeRestart(restart)
[16:21:03.229]                             muffled <- TRUE
[16:21:03.229]                             break
[16:21:03.229]                           }
[16:21:03.229]                         }
[16:21:03.229]                       }
[16:21:03.229]                       invisible(muffled)
[16:21:03.229]                     }
[16:21:03.229]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.229]                   }
[16:21:03.229]                 }
[16:21:03.229]             }
[16:21:03.229]         }))
[16:21:03.229]     }, error = function(ex) {
[16:21:03.229]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.229]                 ...future.rng), started = ...future.startTime, 
[16:21:03.229]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.229]             version = "1.8"), class = "FutureResult")
[16:21:03.229]     }, finally = {
[16:21:03.229]         if (!identical(...future.workdir, getwd())) 
[16:21:03.229]             setwd(...future.workdir)
[16:21:03.229]         {
[16:21:03.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.229]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.229]             }
[16:21:03.229]             base::options(...future.oldOptions)
[16:21:03.229]             if (.Platform$OS.type == "windows") {
[16:21:03.229]                 old_names <- names(...future.oldEnvVars)
[16:21:03.229]                 envs <- base::Sys.getenv()
[16:21:03.229]                 names <- names(envs)
[16:21:03.229]                 common <- intersect(names, old_names)
[16:21:03.229]                 added <- setdiff(names, old_names)
[16:21:03.229]                 removed <- setdiff(old_names, names)
[16:21:03.229]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.229]                   envs[common]]
[16:21:03.229]                 NAMES <- toupper(changed)
[16:21:03.229]                 args <- list()
[16:21:03.229]                 for (kk in seq_along(NAMES)) {
[16:21:03.229]                   name <- changed[[kk]]
[16:21:03.229]                   NAME <- NAMES[[kk]]
[16:21:03.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.229]                     next
[16:21:03.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.229]                 }
[16:21:03.229]                 NAMES <- toupper(added)
[16:21:03.229]                 for (kk in seq_along(NAMES)) {
[16:21:03.229]                   name <- added[[kk]]
[16:21:03.229]                   NAME <- NAMES[[kk]]
[16:21:03.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.229]                     next
[16:21:03.229]                   args[[name]] <- ""
[16:21:03.229]                 }
[16:21:03.229]                 NAMES <- toupper(removed)
[16:21:03.229]                 for (kk in seq_along(NAMES)) {
[16:21:03.229]                   name <- removed[[kk]]
[16:21:03.229]                   NAME <- NAMES[[kk]]
[16:21:03.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.229]                     next
[16:21:03.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.229]                 }
[16:21:03.229]                 if (length(args) > 0) 
[16:21:03.229]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.229]             }
[16:21:03.229]             else {
[16:21:03.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.229]             }
[16:21:03.229]             {
[16:21:03.229]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.229]                   0L) {
[16:21:03.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.229]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.229]                   base::options(opts)
[16:21:03.229]                 }
[16:21:03.229]                 {
[16:21:03.229]                   {
[16:21:03.229]                     NULL
[16:21:03.229]                     RNGkind("Mersenne-Twister")
[16:21:03.229]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.229]                       inherits = FALSE)
[16:21:03.229]                   }
[16:21:03.229]                   options(future.plan = NULL)
[16:21:03.229]                   if (is.na(NA_character_)) 
[16:21:03.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.229]                     .init = FALSE)
[16:21:03.229]                 }
[16:21:03.229]             }
[16:21:03.229]         }
[16:21:03.229]     })
[16:21:03.229]     if (TRUE) {
[16:21:03.229]         base::sink(type = "output", split = FALSE)
[16:21:03.229]         if (TRUE) {
[16:21:03.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.229]         }
[16:21:03.229]         else {
[16:21:03.229]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.229]         }
[16:21:03.229]         base::close(...future.stdout)
[16:21:03.229]         ...future.stdout <- NULL
[16:21:03.229]     }
[16:21:03.229]     ...future.result$conditions <- ...future.conditions
[16:21:03.229]     ...future.result$finished <- base::Sys.time()
[16:21:03.229]     ...future.result
[16:21:03.229] }
[16:21:03.231] assign_globals() ...
[16:21:03.231] List of 1
[16:21:03.231]  $ ii: int 2
[16:21:03.231]  - attr(*, "where")=List of 1
[16:21:03.231]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.231]  - attr(*, "resolved")= logi TRUE
[16:21:03.231]  - attr(*, "total_size")= num 56
[16:21:03.231]  - attr(*, "already-done")= logi TRUE
[16:21:03.233] - copied ‘ii’ to environment
[16:21:03.233] assign_globals() ... done
[16:21:03.234] plan(): Setting new future strategy stack:
[16:21:03.234] List of future strategies:
[16:21:03.234] 1. sequential:
[16:21:03.234]    - args: function (..., envir = parent.frame())
[16:21:03.234]    - tweaked: FALSE
[16:21:03.234]    - call: NULL
[16:21:03.234] plan(): nbrOfWorkers() = 1
[16:21:03.235] plan(): Setting new future strategy stack:
[16:21:03.235] List of future strategies:
[16:21:03.235] 1. sequential:
[16:21:03.235]    - args: function (..., envir = parent.frame())
[16:21:03.235]    - tweaked: FALSE
[16:21:03.235]    - call: plan(strategy)
[16:21:03.235] plan(): nbrOfWorkers() = 1
[16:21:03.235] SequentialFuture started (and completed)
[16:21:03.236] - Launch lazy future ... done
[16:21:03.236] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.236] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.236] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.240] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.240] Searching for globals ... DONE
[16:21:03.240] Resolving globals: TRUE
[16:21:03.240] Resolving any globals that are futures ...
[16:21:03.240] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.240] Resolving any globals that are futures ... DONE
[16:21:03.240] Resolving futures part of globals (recursively) ...
[16:21:03.241] resolve() on list ...
[16:21:03.241]  recursive: 99
[16:21:03.241]  length: 1
[16:21:03.241]  elements: ‘ii’
[16:21:03.241]  length: 0 (resolved future 1)
[16:21:03.241] resolve() on list ... DONE
[16:21:03.241] - globals: [1] ‘ii’
[16:21:03.241] Resolving futures part of globals (recursively) ... DONE
[16:21:03.242] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.242] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.242] - globals: [1] ‘ii’
[16:21:03.242] 
[16:21:03.242] getGlobalsAndPackages() ... DONE
[16:21:03.242] run() for ‘Future’ ...
[16:21:03.243] - state: ‘created’
[16:21:03.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.243] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.243] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.243]   - Field: ‘label’
[16:21:03.243]   - Field: ‘local’
[16:21:03.243]   - Field: ‘owner’
[16:21:03.243]   - Field: ‘envir’
[16:21:03.244]   - Field: ‘packages’
[16:21:03.244]   - Field: ‘gc’
[16:21:03.244]   - Field: ‘conditions’
[16:21:03.244]   - Field: ‘expr’
[16:21:03.244]   - Field: ‘uuid’
[16:21:03.244]   - Field: ‘seed’
[16:21:03.244]   - Field: ‘version’
[16:21:03.244]   - Field: ‘result’
[16:21:03.244]   - Field: ‘asynchronous’
[16:21:03.244]   - Field: ‘calls’
[16:21:03.245]   - Field: ‘globals’
[16:21:03.245]   - Field: ‘stdout’
[16:21:03.245]   - Field: ‘earlySignal’
[16:21:03.245]   - Field: ‘lazy’
[16:21:03.245]   - Field: ‘state’
[16:21:03.245] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.245] - Launch lazy future ...
[16:21:03.245] Packages needed by the future expression (n = 0): <none>
[16:21:03.245] Packages needed by future strategies (n = 0): <none>
[16:21:03.246] {
[16:21:03.246]     {
[16:21:03.246]         {
[16:21:03.246]             ...future.startTime <- base::Sys.time()
[16:21:03.246]             {
[16:21:03.246]                 {
[16:21:03.246]                   {
[16:21:03.246]                     base::local({
[16:21:03.246]                       has_future <- base::requireNamespace("future", 
[16:21:03.246]                         quietly = TRUE)
[16:21:03.246]                       if (has_future) {
[16:21:03.246]                         ns <- base::getNamespace("future")
[16:21:03.246]                         version <- ns[[".package"]][["version"]]
[16:21:03.246]                         if (is.null(version)) 
[16:21:03.246]                           version <- utils::packageVersion("future")
[16:21:03.246]                       }
[16:21:03.246]                       else {
[16:21:03.246]                         version <- NULL
[16:21:03.246]                       }
[16:21:03.246]                       if (!has_future || version < "1.8.0") {
[16:21:03.246]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.246]                           "", base::R.version$version.string), 
[16:21:03.246]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.246]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.246]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.246]                             "release", "version")], collapse = " "), 
[16:21:03.246]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.246]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.246]                           info)
[16:21:03.246]                         info <- base::paste(info, collapse = "; ")
[16:21:03.246]                         if (!has_future) {
[16:21:03.246]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.246]                             info)
[16:21:03.246]                         }
[16:21:03.246]                         else {
[16:21:03.246]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.246]                             info, version)
[16:21:03.246]                         }
[16:21:03.246]                         base::stop(msg)
[16:21:03.246]                       }
[16:21:03.246]                     })
[16:21:03.246]                   }
[16:21:03.246]                   ...future.strategy.old <- future::plan("list")
[16:21:03.246]                   options(future.plan = NULL)
[16:21:03.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.246]                 }
[16:21:03.246]                 ...future.workdir <- getwd()
[16:21:03.246]             }
[16:21:03.246]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.246]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.246]         }
[16:21:03.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.246]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.246]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.246]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.246]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.246]             base::names(...future.oldOptions))
[16:21:03.246]     }
[16:21:03.246]     if (FALSE) {
[16:21:03.246]     }
[16:21:03.246]     else {
[16:21:03.246]         if (TRUE) {
[16:21:03.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.246]                 open = "w")
[16:21:03.246]         }
[16:21:03.246]         else {
[16:21:03.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.246]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.246]         }
[16:21:03.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.246]             base::sink(type = "output", split = FALSE)
[16:21:03.246]             base::close(...future.stdout)
[16:21:03.246]         }, add = TRUE)
[16:21:03.246]     }
[16:21:03.246]     ...future.frame <- base::sys.nframe()
[16:21:03.246]     ...future.conditions <- base::list()
[16:21:03.246]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.246]     if (FALSE) {
[16:21:03.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.246]     }
[16:21:03.246]     ...future.result <- base::tryCatch({
[16:21:03.246]         base::withCallingHandlers({
[16:21:03.246]             ...future.value <- base::withVisible(base::local({
[16:21:03.246]                 b <- a * ii
[16:21:03.246]                 a <- 0
[16:21:03.246]                 b
[16:21:03.246]             }))
[16:21:03.246]             future::FutureResult(value = ...future.value$value, 
[16:21:03.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.246]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.246]                     ...future.globalenv.names))
[16:21:03.246]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.246]         }, condition = base::local({
[16:21:03.246]             c <- base::c
[16:21:03.246]             inherits <- base::inherits
[16:21:03.246]             invokeRestart <- base::invokeRestart
[16:21:03.246]             length <- base::length
[16:21:03.246]             list <- base::list
[16:21:03.246]             seq.int <- base::seq.int
[16:21:03.246]             signalCondition <- base::signalCondition
[16:21:03.246]             sys.calls <- base::sys.calls
[16:21:03.246]             `[[` <- base::`[[`
[16:21:03.246]             `+` <- base::`+`
[16:21:03.246]             `<<-` <- base::`<<-`
[16:21:03.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.246]                   3L)]
[16:21:03.246]             }
[16:21:03.246]             function(cond) {
[16:21:03.246]                 is_error <- inherits(cond, "error")
[16:21:03.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.246]                   NULL)
[16:21:03.246]                 if (is_error) {
[16:21:03.246]                   sessionInformation <- function() {
[16:21:03.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.246]                       search = base::search(), system = base::Sys.info())
[16:21:03.246]                   }
[16:21:03.246]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.246]                     cond$call), session = sessionInformation(), 
[16:21:03.246]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.246]                   signalCondition(cond)
[16:21:03.246]                 }
[16:21:03.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.246]                 "immediateCondition"))) {
[16:21:03.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.246]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.246]                   if (TRUE && !signal) {
[16:21:03.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.246]                     {
[16:21:03.246]                       inherits <- base::inherits
[16:21:03.246]                       invokeRestart <- base::invokeRestart
[16:21:03.246]                       is.null <- base::is.null
[16:21:03.246]                       muffled <- FALSE
[16:21:03.246]                       if (inherits(cond, "message")) {
[16:21:03.246]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.246]                         if (muffled) 
[16:21:03.246]                           invokeRestart("muffleMessage")
[16:21:03.246]                       }
[16:21:03.246]                       else if (inherits(cond, "warning")) {
[16:21:03.246]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.246]                         if (muffled) 
[16:21:03.246]                           invokeRestart("muffleWarning")
[16:21:03.246]                       }
[16:21:03.246]                       else if (inherits(cond, "condition")) {
[16:21:03.246]                         if (!is.null(pattern)) {
[16:21:03.246]                           computeRestarts <- base::computeRestarts
[16:21:03.246]                           grepl <- base::grepl
[16:21:03.246]                           restarts <- computeRestarts(cond)
[16:21:03.246]                           for (restart in restarts) {
[16:21:03.246]                             name <- restart$name
[16:21:03.246]                             if (is.null(name)) 
[16:21:03.246]                               next
[16:21:03.246]                             if (!grepl(pattern, name)) 
[16:21:03.246]                               next
[16:21:03.246]                             invokeRestart(restart)
[16:21:03.246]                             muffled <- TRUE
[16:21:03.246]                             break
[16:21:03.246]                           }
[16:21:03.246]                         }
[16:21:03.246]                       }
[16:21:03.246]                       invisible(muffled)
[16:21:03.246]                     }
[16:21:03.246]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.246]                   }
[16:21:03.246]                 }
[16:21:03.246]                 else {
[16:21:03.246]                   if (TRUE) {
[16:21:03.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.246]                     {
[16:21:03.246]                       inherits <- base::inherits
[16:21:03.246]                       invokeRestart <- base::invokeRestart
[16:21:03.246]                       is.null <- base::is.null
[16:21:03.246]                       muffled <- FALSE
[16:21:03.246]                       if (inherits(cond, "message")) {
[16:21:03.246]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.246]                         if (muffled) 
[16:21:03.246]                           invokeRestart("muffleMessage")
[16:21:03.246]                       }
[16:21:03.246]                       else if (inherits(cond, "warning")) {
[16:21:03.246]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.246]                         if (muffled) 
[16:21:03.246]                           invokeRestart("muffleWarning")
[16:21:03.246]                       }
[16:21:03.246]                       else if (inherits(cond, "condition")) {
[16:21:03.246]                         if (!is.null(pattern)) {
[16:21:03.246]                           computeRestarts <- base::computeRestarts
[16:21:03.246]                           grepl <- base::grepl
[16:21:03.246]                           restarts <- computeRestarts(cond)
[16:21:03.246]                           for (restart in restarts) {
[16:21:03.246]                             name <- restart$name
[16:21:03.246]                             if (is.null(name)) 
[16:21:03.246]                               next
[16:21:03.246]                             if (!grepl(pattern, name)) 
[16:21:03.246]                               next
[16:21:03.246]                             invokeRestart(restart)
[16:21:03.246]                             muffled <- TRUE
[16:21:03.246]                             break
[16:21:03.246]                           }
[16:21:03.246]                         }
[16:21:03.246]                       }
[16:21:03.246]                       invisible(muffled)
[16:21:03.246]                     }
[16:21:03.246]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.246]                   }
[16:21:03.246]                 }
[16:21:03.246]             }
[16:21:03.246]         }))
[16:21:03.246]     }, error = function(ex) {
[16:21:03.246]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.246]                 ...future.rng), started = ...future.startTime, 
[16:21:03.246]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.246]             version = "1.8"), class = "FutureResult")
[16:21:03.246]     }, finally = {
[16:21:03.246]         if (!identical(...future.workdir, getwd())) 
[16:21:03.246]             setwd(...future.workdir)
[16:21:03.246]         {
[16:21:03.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.246]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.246]             }
[16:21:03.246]             base::options(...future.oldOptions)
[16:21:03.246]             if (.Platform$OS.type == "windows") {
[16:21:03.246]                 old_names <- names(...future.oldEnvVars)
[16:21:03.246]                 envs <- base::Sys.getenv()
[16:21:03.246]                 names <- names(envs)
[16:21:03.246]                 common <- intersect(names, old_names)
[16:21:03.246]                 added <- setdiff(names, old_names)
[16:21:03.246]                 removed <- setdiff(old_names, names)
[16:21:03.246]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.246]                   envs[common]]
[16:21:03.246]                 NAMES <- toupper(changed)
[16:21:03.246]                 args <- list()
[16:21:03.246]                 for (kk in seq_along(NAMES)) {
[16:21:03.246]                   name <- changed[[kk]]
[16:21:03.246]                   NAME <- NAMES[[kk]]
[16:21:03.246]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.246]                     next
[16:21:03.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.246]                 }
[16:21:03.246]                 NAMES <- toupper(added)
[16:21:03.246]                 for (kk in seq_along(NAMES)) {
[16:21:03.246]                   name <- added[[kk]]
[16:21:03.246]                   NAME <- NAMES[[kk]]
[16:21:03.246]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.246]                     next
[16:21:03.246]                   args[[name]] <- ""
[16:21:03.246]                 }
[16:21:03.246]                 NAMES <- toupper(removed)
[16:21:03.246]                 for (kk in seq_along(NAMES)) {
[16:21:03.246]                   name <- removed[[kk]]
[16:21:03.246]                   NAME <- NAMES[[kk]]
[16:21:03.246]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.246]                     next
[16:21:03.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.246]                 }
[16:21:03.246]                 if (length(args) > 0) 
[16:21:03.246]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.246]             }
[16:21:03.246]             else {
[16:21:03.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.246]             }
[16:21:03.246]             {
[16:21:03.246]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.246]                   0L) {
[16:21:03.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.246]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.246]                   base::options(opts)
[16:21:03.246]                 }
[16:21:03.246]                 {
[16:21:03.246]                   {
[16:21:03.246]                     NULL
[16:21:03.246]                     RNGkind("Mersenne-Twister")
[16:21:03.246]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.246]                       inherits = FALSE)
[16:21:03.246]                   }
[16:21:03.246]                   options(future.plan = NULL)
[16:21:03.246]                   if (is.na(NA_character_)) 
[16:21:03.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.246]                     .init = FALSE)
[16:21:03.246]                 }
[16:21:03.246]             }
[16:21:03.246]         }
[16:21:03.246]     })
[16:21:03.246]     if (TRUE) {
[16:21:03.246]         base::sink(type = "output", split = FALSE)
[16:21:03.246]         if (TRUE) {
[16:21:03.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.246]         }
[16:21:03.246]         else {
[16:21:03.246]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.246]         }
[16:21:03.246]         base::close(...future.stdout)
[16:21:03.246]         ...future.stdout <- NULL
[16:21:03.246]     }
[16:21:03.246]     ...future.result$conditions <- ...future.conditions
[16:21:03.246]     ...future.result$finished <- base::Sys.time()
[16:21:03.246]     ...future.result
[16:21:03.246] }
[16:21:03.247] assign_globals() ...
[16:21:03.248] List of 1
[16:21:03.248]  $ ii: int 3
[16:21:03.248]  - attr(*, "where")=List of 1
[16:21:03.248]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.248]  - attr(*, "resolved")= logi TRUE
[16:21:03.248]  - attr(*, "total_size")= num 56
[16:21:03.248]  - attr(*, "already-done")= logi TRUE
[16:21:03.250] - copied ‘ii’ to environment
[16:21:03.250] assign_globals() ... done
[16:21:03.250] plan(): Setting new future strategy stack:
[16:21:03.251] List of future strategies:
[16:21:03.251] 1. sequential:
[16:21:03.251]    - args: function (..., envir = parent.frame())
[16:21:03.251]    - tweaked: FALSE
[16:21:03.251]    - call: NULL
[16:21:03.251] plan(): nbrOfWorkers() = 1
[16:21:03.252] plan(): Setting new future strategy stack:
[16:21:03.252] List of future strategies:
[16:21:03.252] 1. sequential:
[16:21:03.252]    - args: function (..., envir = parent.frame())
[16:21:03.252]    - tweaked: FALSE
[16:21:03.252]    - call: plan(strategy)
[16:21:03.252] plan(): nbrOfWorkers() = 1
[16:21:03.252] SequentialFuture started (and completed)
[16:21:03.253] - Launch lazy future ... done
[16:21:03.253] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.254] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.254] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.255] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.255] Searching for globals ... DONE
[16:21:03.255] Resolving globals: TRUE
[16:21:03.256] Resolving any globals that are futures ...
[16:21:03.256] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.256] Resolving any globals that are futures ... DONE
[16:21:03.256] Resolving futures part of globals (recursively) ...
[16:21:03.256] resolve() on list ...
[16:21:03.256]  recursive: 99
[16:21:03.257]  length: 1
[16:21:03.257]  elements: ‘ii’
[16:21:03.257]  length: 0 (resolved future 1)
[16:21:03.257] resolve() on list ... DONE
[16:21:03.257] - globals: [1] ‘ii’
[16:21:03.257] Resolving futures part of globals (recursively) ... DONE
[16:21:03.257] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.258] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.258] - globals: [1] ‘ii’
[16:21:03.258] 
[16:21:03.258] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.258] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.259] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.260] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.260] Searching for globals ... DONE
[16:21:03.260] Resolving globals: TRUE
[16:21:03.260] Resolving any globals that are futures ...
[16:21:03.260] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.260] Resolving any globals that are futures ... DONE
[16:21:03.261] Resolving futures part of globals (recursively) ...
[16:21:03.261] resolve() on list ...
[16:21:03.261]  recursive: 99
[16:21:03.261]  length: 1
[16:21:03.261]  elements: ‘ii’
[16:21:03.261]  length: 0 (resolved future 1)
[16:21:03.261] resolve() on list ... DONE
[16:21:03.261] - globals: [1] ‘ii’
[16:21:03.262] Resolving futures part of globals (recursively) ... DONE
[16:21:03.262] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.262] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.262] - globals: [1] ‘ii’
[16:21:03.262] 
[16:21:03.262] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.263] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.263] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.266] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.266] Searching for globals ... DONE
[16:21:03.266] Resolving globals: TRUE
[16:21:03.266] Resolving any globals that are futures ...
[16:21:03.266] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.267] Resolving any globals that are futures ... DONE
[16:21:03.267] Resolving futures part of globals (recursively) ...
[16:21:03.267] resolve() on list ...
[16:21:03.267]  recursive: 99
[16:21:03.267]  length: 1
[16:21:03.267]  elements: ‘ii’
[16:21:03.267]  length: 0 (resolved future 1)
[16:21:03.268] resolve() on list ... DONE
[16:21:03.268] - globals: [1] ‘ii’
[16:21:03.268] Resolving futures part of globals (recursively) ... DONE
[16:21:03.268] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.268] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.268] - globals: [1] ‘ii’
[16:21:03.268] 
[16:21:03.269] getGlobalsAndPackages() ... DONE
[16:21:03.269] run() for ‘Future’ ...
[16:21:03.269] - state: ‘created’
[16:21:03.269] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.269] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.270] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.270]   - Field: ‘label’
[16:21:03.270]   - Field: ‘local’
[16:21:03.270]   - Field: ‘owner’
[16:21:03.270]   - Field: ‘envir’
[16:21:03.270]   - Field: ‘packages’
[16:21:03.270]   - Field: ‘gc’
[16:21:03.270]   - Field: ‘conditions’
[16:21:03.270]   - Field: ‘expr’
[16:21:03.270]   - Field: ‘uuid’
[16:21:03.270]   - Field: ‘seed’
[16:21:03.271]   - Field: ‘version’
[16:21:03.271]   - Field: ‘result’
[16:21:03.271]   - Field: ‘asynchronous’
[16:21:03.271]   - Field: ‘calls’
[16:21:03.271]   - Field: ‘globals’
[16:21:03.271]   - Field: ‘stdout’
[16:21:03.271]   - Field: ‘earlySignal’
[16:21:03.271]   - Field: ‘lazy’
[16:21:03.271]   - Field: ‘state’
[16:21:03.271] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.272] - Launch lazy future ...
[16:21:03.272] Packages needed by the future expression (n = 0): <none>
[16:21:03.272] Packages needed by future strategies (n = 0): <none>
[16:21:03.272] {
[16:21:03.272]     {
[16:21:03.272]         {
[16:21:03.272]             ...future.startTime <- base::Sys.time()
[16:21:03.272]             {
[16:21:03.272]                 {
[16:21:03.272]                   {
[16:21:03.272]                     base::local({
[16:21:03.272]                       has_future <- base::requireNamespace("future", 
[16:21:03.272]                         quietly = TRUE)
[16:21:03.272]                       if (has_future) {
[16:21:03.272]                         ns <- base::getNamespace("future")
[16:21:03.272]                         version <- ns[[".package"]][["version"]]
[16:21:03.272]                         if (is.null(version)) 
[16:21:03.272]                           version <- utils::packageVersion("future")
[16:21:03.272]                       }
[16:21:03.272]                       else {
[16:21:03.272]                         version <- NULL
[16:21:03.272]                       }
[16:21:03.272]                       if (!has_future || version < "1.8.0") {
[16:21:03.272]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.272]                           "", base::R.version$version.string), 
[16:21:03.272]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.272]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.272]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.272]                             "release", "version")], collapse = " "), 
[16:21:03.272]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.272]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.272]                           info)
[16:21:03.272]                         info <- base::paste(info, collapse = "; ")
[16:21:03.272]                         if (!has_future) {
[16:21:03.272]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.272]                             info)
[16:21:03.272]                         }
[16:21:03.272]                         else {
[16:21:03.272]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.272]                             info, version)
[16:21:03.272]                         }
[16:21:03.272]                         base::stop(msg)
[16:21:03.272]                       }
[16:21:03.272]                     })
[16:21:03.272]                   }
[16:21:03.272]                   ...future.strategy.old <- future::plan("list")
[16:21:03.272]                   options(future.plan = NULL)
[16:21:03.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.272]                 }
[16:21:03.272]                 ...future.workdir <- getwd()
[16:21:03.272]             }
[16:21:03.272]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.272]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.272]         }
[16:21:03.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.272]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.272]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.272]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.272]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.272]             base::names(...future.oldOptions))
[16:21:03.272]     }
[16:21:03.272]     if (FALSE) {
[16:21:03.272]     }
[16:21:03.272]     else {
[16:21:03.272]         if (TRUE) {
[16:21:03.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.272]                 open = "w")
[16:21:03.272]         }
[16:21:03.272]         else {
[16:21:03.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.272]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.272]         }
[16:21:03.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.272]             base::sink(type = "output", split = FALSE)
[16:21:03.272]             base::close(...future.stdout)
[16:21:03.272]         }, add = TRUE)
[16:21:03.272]     }
[16:21:03.272]     ...future.frame <- base::sys.nframe()
[16:21:03.272]     ...future.conditions <- base::list()
[16:21:03.272]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.272]     if (FALSE) {
[16:21:03.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.272]     }
[16:21:03.272]     ...future.result <- base::tryCatch({
[16:21:03.272]         base::withCallingHandlers({
[16:21:03.272]             ...future.value <- base::withVisible(base::local({
[16:21:03.272]                 b <- a * ii
[16:21:03.272]                 a <- 0
[16:21:03.272]                 b
[16:21:03.272]             }))
[16:21:03.272]             future::FutureResult(value = ...future.value$value, 
[16:21:03.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.272]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.272]                     ...future.globalenv.names))
[16:21:03.272]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.272]         }, condition = base::local({
[16:21:03.272]             c <- base::c
[16:21:03.272]             inherits <- base::inherits
[16:21:03.272]             invokeRestart <- base::invokeRestart
[16:21:03.272]             length <- base::length
[16:21:03.272]             list <- base::list
[16:21:03.272]             seq.int <- base::seq.int
[16:21:03.272]             signalCondition <- base::signalCondition
[16:21:03.272]             sys.calls <- base::sys.calls
[16:21:03.272]             `[[` <- base::`[[`
[16:21:03.272]             `+` <- base::`+`
[16:21:03.272]             `<<-` <- base::`<<-`
[16:21:03.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.272]                   3L)]
[16:21:03.272]             }
[16:21:03.272]             function(cond) {
[16:21:03.272]                 is_error <- inherits(cond, "error")
[16:21:03.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.272]                   NULL)
[16:21:03.272]                 if (is_error) {
[16:21:03.272]                   sessionInformation <- function() {
[16:21:03.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.272]                       search = base::search(), system = base::Sys.info())
[16:21:03.272]                   }
[16:21:03.272]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.272]                     cond$call), session = sessionInformation(), 
[16:21:03.272]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.272]                   signalCondition(cond)
[16:21:03.272]                 }
[16:21:03.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.272]                 "immediateCondition"))) {
[16:21:03.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.272]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.272]                   if (TRUE && !signal) {
[16:21:03.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.272]                     {
[16:21:03.272]                       inherits <- base::inherits
[16:21:03.272]                       invokeRestart <- base::invokeRestart
[16:21:03.272]                       is.null <- base::is.null
[16:21:03.272]                       muffled <- FALSE
[16:21:03.272]                       if (inherits(cond, "message")) {
[16:21:03.272]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.272]                         if (muffled) 
[16:21:03.272]                           invokeRestart("muffleMessage")
[16:21:03.272]                       }
[16:21:03.272]                       else if (inherits(cond, "warning")) {
[16:21:03.272]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.272]                         if (muffled) 
[16:21:03.272]                           invokeRestart("muffleWarning")
[16:21:03.272]                       }
[16:21:03.272]                       else if (inherits(cond, "condition")) {
[16:21:03.272]                         if (!is.null(pattern)) {
[16:21:03.272]                           computeRestarts <- base::computeRestarts
[16:21:03.272]                           grepl <- base::grepl
[16:21:03.272]                           restarts <- computeRestarts(cond)
[16:21:03.272]                           for (restart in restarts) {
[16:21:03.272]                             name <- restart$name
[16:21:03.272]                             if (is.null(name)) 
[16:21:03.272]                               next
[16:21:03.272]                             if (!grepl(pattern, name)) 
[16:21:03.272]                               next
[16:21:03.272]                             invokeRestart(restart)
[16:21:03.272]                             muffled <- TRUE
[16:21:03.272]                             break
[16:21:03.272]                           }
[16:21:03.272]                         }
[16:21:03.272]                       }
[16:21:03.272]                       invisible(muffled)
[16:21:03.272]                     }
[16:21:03.272]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.272]                   }
[16:21:03.272]                 }
[16:21:03.272]                 else {
[16:21:03.272]                   if (TRUE) {
[16:21:03.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.272]                     {
[16:21:03.272]                       inherits <- base::inherits
[16:21:03.272]                       invokeRestart <- base::invokeRestart
[16:21:03.272]                       is.null <- base::is.null
[16:21:03.272]                       muffled <- FALSE
[16:21:03.272]                       if (inherits(cond, "message")) {
[16:21:03.272]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.272]                         if (muffled) 
[16:21:03.272]                           invokeRestart("muffleMessage")
[16:21:03.272]                       }
[16:21:03.272]                       else if (inherits(cond, "warning")) {
[16:21:03.272]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.272]                         if (muffled) 
[16:21:03.272]                           invokeRestart("muffleWarning")
[16:21:03.272]                       }
[16:21:03.272]                       else if (inherits(cond, "condition")) {
[16:21:03.272]                         if (!is.null(pattern)) {
[16:21:03.272]                           computeRestarts <- base::computeRestarts
[16:21:03.272]                           grepl <- base::grepl
[16:21:03.272]                           restarts <- computeRestarts(cond)
[16:21:03.272]                           for (restart in restarts) {
[16:21:03.272]                             name <- restart$name
[16:21:03.272]                             if (is.null(name)) 
[16:21:03.272]                               next
[16:21:03.272]                             if (!grepl(pattern, name)) 
[16:21:03.272]                               next
[16:21:03.272]                             invokeRestart(restart)
[16:21:03.272]                             muffled <- TRUE
[16:21:03.272]                             break
[16:21:03.272]                           }
[16:21:03.272]                         }
[16:21:03.272]                       }
[16:21:03.272]                       invisible(muffled)
[16:21:03.272]                     }
[16:21:03.272]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.272]                   }
[16:21:03.272]                 }
[16:21:03.272]             }
[16:21:03.272]         }))
[16:21:03.272]     }, error = function(ex) {
[16:21:03.272]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.272]                 ...future.rng), started = ...future.startTime, 
[16:21:03.272]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.272]             version = "1.8"), class = "FutureResult")
[16:21:03.272]     }, finally = {
[16:21:03.272]         if (!identical(...future.workdir, getwd())) 
[16:21:03.272]             setwd(...future.workdir)
[16:21:03.272]         {
[16:21:03.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.272]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.272]             }
[16:21:03.272]             base::options(...future.oldOptions)
[16:21:03.272]             if (.Platform$OS.type == "windows") {
[16:21:03.272]                 old_names <- names(...future.oldEnvVars)
[16:21:03.272]                 envs <- base::Sys.getenv()
[16:21:03.272]                 names <- names(envs)
[16:21:03.272]                 common <- intersect(names, old_names)
[16:21:03.272]                 added <- setdiff(names, old_names)
[16:21:03.272]                 removed <- setdiff(old_names, names)
[16:21:03.272]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.272]                   envs[common]]
[16:21:03.272]                 NAMES <- toupper(changed)
[16:21:03.272]                 args <- list()
[16:21:03.272]                 for (kk in seq_along(NAMES)) {
[16:21:03.272]                   name <- changed[[kk]]
[16:21:03.272]                   NAME <- NAMES[[kk]]
[16:21:03.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.272]                     next
[16:21:03.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.272]                 }
[16:21:03.272]                 NAMES <- toupper(added)
[16:21:03.272]                 for (kk in seq_along(NAMES)) {
[16:21:03.272]                   name <- added[[kk]]
[16:21:03.272]                   NAME <- NAMES[[kk]]
[16:21:03.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.272]                     next
[16:21:03.272]                   args[[name]] <- ""
[16:21:03.272]                 }
[16:21:03.272]                 NAMES <- toupper(removed)
[16:21:03.272]                 for (kk in seq_along(NAMES)) {
[16:21:03.272]                   name <- removed[[kk]]
[16:21:03.272]                   NAME <- NAMES[[kk]]
[16:21:03.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.272]                     next
[16:21:03.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.272]                 }
[16:21:03.272]                 if (length(args) > 0) 
[16:21:03.272]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.272]             }
[16:21:03.272]             else {
[16:21:03.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.272]             }
[16:21:03.272]             {
[16:21:03.272]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.272]                   0L) {
[16:21:03.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.272]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.272]                   base::options(opts)
[16:21:03.272]                 }
[16:21:03.272]                 {
[16:21:03.272]                   {
[16:21:03.272]                     NULL
[16:21:03.272]                     RNGkind("Mersenne-Twister")
[16:21:03.272]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.272]                       inherits = FALSE)
[16:21:03.272]                   }
[16:21:03.272]                   options(future.plan = NULL)
[16:21:03.272]                   if (is.na(NA_character_)) 
[16:21:03.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.272]                     .init = FALSE)
[16:21:03.272]                 }
[16:21:03.272]             }
[16:21:03.272]         }
[16:21:03.272]     })
[16:21:03.272]     if (TRUE) {
[16:21:03.272]         base::sink(type = "output", split = FALSE)
[16:21:03.272]         if (TRUE) {
[16:21:03.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.272]         }
[16:21:03.272]         else {
[16:21:03.272]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.272]         }
[16:21:03.272]         base::close(...future.stdout)
[16:21:03.272]         ...future.stdout <- NULL
[16:21:03.272]     }
[16:21:03.272]     ...future.result$conditions <- ...future.conditions
[16:21:03.272]     ...future.result$finished <- base::Sys.time()
[16:21:03.272]     ...future.result
[16:21:03.272] }
[16:21:03.274] assign_globals() ...
[16:21:03.274] List of 1
[16:21:03.274]  $ ii: int 1
[16:21:03.274]  - attr(*, "where")=List of 1
[16:21:03.274]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.274]  - attr(*, "resolved")= logi TRUE
[16:21:03.274]  - attr(*, "total_size")= num 56
[16:21:03.274]  - attr(*, "already-done")= logi TRUE
[16:21:03.276] - copied ‘ii’ to environment
[16:21:03.277] assign_globals() ... done
[16:21:03.277] plan(): Setting new future strategy stack:
[16:21:03.277] List of future strategies:
[16:21:03.277] 1. sequential:
[16:21:03.277]    - args: function (..., envir = parent.frame())
[16:21:03.277]    - tweaked: FALSE
[16:21:03.277]    - call: NULL
[16:21:03.277] plan(): nbrOfWorkers() = 1
[16:21:03.278] plan(): Setting new future strategy stack:
[16:21:03.278] List of future strategies:
[16:21:03.278] 1. sequential:
[16:21:03.278]    - args: function (..., envir = parent.frame())
[16:21:03.278]    - tweaked: FALSE
[16:21:03.278]    - call: plan(strategy)
[16:21:03.279] plan(): nbrOfWorkers() = 1
[16:21:03.279] SequentialFuture started (and completed)
[16:21:03.279] signalConditions() ...
[16:21:03.279]  - include = ‘immediateCondition’
[16:21:03.279]  - exclude = 
[16:21:03.279]  - resignal = FALSE
[16:21:03.279]  - Number of conditions: 1
[16:21:03.279] signalConditions() ... done
[16:21:03.280] - Launch lazy future ... done
[16:21:03.280] run() for ‘SequentialFuture’ ... done
[16:21:03.280] signalConditions() ...
[16:21:03.280]  - include = ‘immediateCondition’
[16:21:03.280]  - exclude = 
[16:21:03.280]  - resignal = FALSE
[16:21:03.280]  - Number of conditions: 1
[16:21:03.280] signalConditions() ... done
[16:21:03.280] Future state: ‘finished’
[16:21:03.280] signalConditions() ...
[16:21:03.281]  - include = ‘condition’
[16:21:03.281]  - exclude = ‘immediateCondition’
[16:21:03.281]  - resignal = TRUE
[16:21:03.281]  - Number of conditions: 1
[16:21:03.281]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:21:03.281] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "b478068843b5" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:21:03"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.296] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.297] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.297] 
[16:21:03.297] Searching for globals ... DONE
[16:21:03.297] - globals: [0] <none>
[16:21:03.297] getGlobalsAndPackages() ... DONE
[16:21:03.298] run() for ‘Future’ ...
[16:21:03.298] - state: ‘created’
[16:21:03.298] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.298] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.298] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.298]   - Field: ‘label’
[16:21:03.299]   - Field: ‘local’
[16:21:03.299]   - Field: ‘owner’
[16:21:03.299]   - Field: ‘envir’
[16:21:03.299]   - Field: ‘packages’
[16:21:03.299]   - Field: ‘gc’
[16:21:03.299]   - Field: ‘conditions’
[16:21:03.299]   - Field: ‘expr’
[16:21:03.299]   - Field: ‘uuid’
[16:21:03.299]   - Field: ‘seed’
[16:21:03.299]   - Field: ‘version’
[16:21:03.299]   - Field: ‘result’
[16:21:03.300]   - Field: ‘asynchronous’
[16:21:03.300]   - Field: ‘calls’
[16:21:03.300]   - Field: ‘globals’
[16:21:03.300]   - Field: ‘stdout’
[16:21:03.300]   - Field: ‘earlySignal’
[16:21:03.300]   - Field: ‘lazy’
[16:21:03.300]   - Field: ‘state’
[16:21:03.300] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.300] - Launch lazy future ...
[16:21:03.301] Packages needed by the future expression (n = 0): <none>
[16:21:03.301] Packages needed by future strategies (n = 0): <none>
[16:21:03.301] {
[16:21:03.301]     {
[16:21:03.301]         {
[16:21:03.301]             ...future.startTime <- base::Sys.time()
[16:21:03.301]             {
[16:21:03.301]                 {
[16:21:03.301]                   {
[16:21:03.301]                     base::local({
[16:21:03.301]                       has_future <- base::requireNamespace("future", 
[16:21:03.301]                         quietly = TRUE)
[16:21:03.301]                       if (has_future) {
[16:21:03.301]                         ns <- base::getNamespace("future")
[16:21:03.301]                         version <- ns[[".package"]][["version"]]
[16:21:03.301]                         if (is.null(version)) 
[16:21:03.301]                           version <- utils::packageVersion("future")
[16:21:03.301]                       }
[16:21:03.301]                       else {
[16:21:03.301]                         version <- NULL
[16:21:03.301]                       }
[16:21:03.301]                       if (!has_future || version < "1.8.0") {
[16:21:03.301]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.301]                           "", base::R.version$version.string), 
[16:21:03.301]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.301]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.301]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.301]                             "release", "version")], collapse = " "), 
[16:21:03.301]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.301]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.301]                           info)
[16:21:03.301]                         info <- base::paste(info, collapse = "; ")
[16:21:03.301]                         if (!has_future) {
[16:21:03.301]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.301]                             info)
[16:21:03.301]                         }
[16:21:03.301]                         else {
[16:21:03.301]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.301]                             info, version)
[16:21:03.301]                         }
[16:21:03.301]                         base::stop(msg)
[16:21:03.301]                       }
[16:21:03.301]                     })
[16:21:03.301]                   }
[16:21:03.301]                   ...future.strategy.old <- future::plan("list")
[16:21:03.301]                   options(future.plan = NULL)
[16:21:03.301]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.301]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.301]                 }
[16:21:03.301]                 ...future.workdir <- getwd()
[16:21:03.301]             }
[16:21:03.301]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.301]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.301]         }
[16:21:03.301]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.301]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.301]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.301]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.301]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.301]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.301]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.301]             base::names(...future.oldOptions))
[16:21:03.301]     }
[16:21:03.301]     if (FALSE) {
[16:21:03.301]     }
[16:21:03.301]     else {
[16:21:03.301]         if (TRUE) {
[16:21:03.301]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.301]                 open = "w")
[16:21:03.301]         }
[16:21:03.301]         else {
[16:21:03.301]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.301]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.301]         }
[16:21:03.301]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.301]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.301]             base::sink(type = "output", split = FALSE)
[16:21:03.301]             base::close(...future.stdout)
[16:21:03.301]         }, add = TRUE)
[16:21:03.301]     }
[16:21:03.301]     ...future.frame <- base::sys.nframe()
[16:21:03.301]     ...future.conditions <- base::list()
[16:21:03.301]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.301]     if (FALSE) {
[16:21:03.301]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.301]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.301]     }
[16:21:03.301]     ...future.result <- base::tryCatch({
[16:21:03.301]         base::withCallingHandlers({
[16:21:03.301]             ...future.value <- base::withVisible(base::local(1))
[16:21:03.301]             future::FutureResult(value = ...future.value$value, 
[16:21:03.301]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.301]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.301]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.301]                     ...future.globalenv.names))
[16:21:03.301]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.301]         }, condition = base::local({
[16:21:03.301]             c <- base::c
[16:21:03.301]             inherits <- base::inherits
[16:21:03.301]             invokeRestart <- base::invokeRestart
[16:21:03.301]             length <- base::length
[16:21:03.301]             list <- base::list
[16:21:03.301]             seq.int <- base::seq.int
[16:21:03.301]             signalCondition <- base::signalCondition
[16:21:03.301]             sys.calls <- base::sys.calls
[16:21:03.301]             `[[` <- base::`[[`
[16:21:03.301]             `+` <- base::`+`
[16:21:03.301]             `<<-` <- base::`<<-`
[16:21:03.301]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.301]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.301]                   3L)]
[16:21:03.301]             }
[16:21:03.301]             function(cond) {
[16:21:03.301]                 is_error <- inherits(cond, "error")
[16:21:03.301]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.301]                   NULL)
[16:21:03.301]                 if (is_error) {
[16:21:03.301]                   sessionInformation <- function() {
[16:21:03.301]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.301]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.301]                       search = base::search(), system = base::Sys.info())
[16:21:03.301]                   }
[16:21:03.301]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.301]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.301]                     cond$call), session = sessionInformation(), 
[16:21:03.301]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.301]                   signalCondition(cond)
[16:21:03.301]                 }
[16:21:03.301]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.301]                 "immediateCondition"))) {
[16:21:03.301]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.301]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.301]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.301]                   if (TRUE && !signal) {
[16:21:03.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.301]                     {
[16:21:03.301]                       inherits <- base::inherits
[16:21:03.301]                       invokeRestart <- base::invokeRestart
[16:21:03.301]                       is.null <- base::is.null
[16:21:03.301]                       muffled <- FALSE
[16:21:03.301]                       if (inherits(cond, "message")) {
[16:21:03.301]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.301]                         if (muffled) 
[16:21:03.301]                           invokeRestart("muffleMessage")
[16:21:03.301]                       }
[16:21:03.301]                       else if (inherits(cond, "warning")) {
[16:21:03.301]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.301]                         if (muffled) 
[16:21:03.301]                           invokeRestart("muffleWarning")
[16:21:03.301]                       }
[16:21:03.301]                       else if (inherits(cond, "condition")) {
[16:21:03.301]                         if (!is.null(pattern)) {
[16:21:03.301]                           computeRestarts <- base::computeRestarts
[16:21:03.301]                           grepl <- base::grepl
[16:21:03.301]                           restarts <- computeRestarts(cond)
[16:21:03.301]                           for (restart in restarts) {
[16:21:03.301]                             name <- restart$name
[16:21:03.301]                             if (is.null(name)) 
[16:21:03.301]                               next
[16:21:03.301]                             if (!grepl(pattern, name)) 
[16:21:03.301]                               next
[16:21:03.301]                             invokeRestart(restart)
[16:21:03.301]                             muffled <- TRUE
[16:21:03.301]                             break
[16:21:03.301]                           }
[16:21:03.301]                         }
[16:21:03.301]                       }
[16:21:03.301]                       invisible(muffled)
[16:21:03.301]                     }
[16:21:03.301]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.301]                   }
[16:21:03.301]                 }
[16:21:03.301]                 else {
[16:21:03.301]                   if (TRUE) {
[16:21:03.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.301]                     {
[16:21:03.301]                       inherits <- base::inherits
[16:21:03.301]                       invokeRestart <- base::invokeRestart
[16:21:03.301]                       is.null <- base::is.null
[16:21:03.301]                       muffled <- FALSE
[16:21:03.301]                       if (inherits(cond, "message")) {
[16:21:03.301]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.301]                         if (muffled) 
[16:21:03.301]                           invokeRestart("muffleMessage")
[16:21:03.301]                       }
[16:21:03.301]                       else if (inherits(cond, "warning")) {
[16:21:03.301]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.301]                         if (muffled) 
[16:21:03.301]                           invokeRestart("muffleWarning")
[16:21:03.301]                       }
[16:21:03.301]                       else if (inherits(cond, "condition")) {
[16:21:03.301]                         if (!is.null(pattern)) {
[16:21:03.301]                           computeRestarts <- base::computeRestarts
[16:21:03.301]                           grepl <- base::grepl
[16:21:03.301]                           restarts <- computeRestarts(cond)
[16:21:03.301]                           for (restart in restarts) {
[16:21:03.301]                             name <- restart$name
[16:21:03.301]                             if (is.null(name)) 
[16:21:03.301]                               next
[16:21:03.301]                             if (!grepl(pattern, name)) 
[16:21:03.301]                               next
[16:21:03.301]                             invokeRestart(restart)
[16:21:03.301]                             muffled <- TRUE
[16:21:03.301]                             break
[16:21:03.301]                           }
[16:21:03.301]                         }
[16:21:03.301]                       }
[16:21:03.301]                       invisible(muffled)
[16:21:03.301]                     }
[16:21:03.301]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.301]                   }
[16:21:03.301]                 }
[16:21:03.301]             }
[16:21:03.301]         }))
[16:21:03.301]     }, error = function(ex) {
[16:21:03.301]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.301]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.301]                 ...future.rng), started = ...future.startTime, 
[16:21:03.301]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.301]             version = "1.8"), class = "FutureResult")
[16:21:03.301]     }, finally = {
[16:21:03.301]         if (!identical(...future.workdir, getwd())) 
[16:21:03.301]             setwd(...future.workdir)
[16:21:03.301]         {
[16:21:03.301]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.301]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.301]             }
[16:21:03.301]             base::options(...future.oldOptions)
[16:21:03.301]             if (.Platform$OS.type == "windows") {
[16:21:03.301]                 old_names <- names(...future.oldEnvVars)
[16:21:03.301]                 envs <- base::Sys.getenv()
[16:21:03.301]                 names <- names(envs)
[16:21:03.301]                 common <- intersect(names, old_names)
[16:21:03.301]                 added <- setdiff(names, old_names)
[16:21:03.301]                 removed <- setdiff(old_names, names)
[16:21:03.301]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.301]                   envs[common]]
[16:21:03.301]                 NAMES <- toupper(changed)
[16:21:03.301]                 args <- list()
[16:21:03.301]                 for (kk in seq_along(NAMES)) {
[16:21:03.301]                   name <- changed[[kk]]
[16:21:03.301]                   NAME <- NAMES[[kk]]
[16:21:03.301]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.301]                     next
[16:21:03.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.301]                 }
[16:21:03.301]                 NAMES <- toupper(added)
[16:21:03.301]                 for (kk in seq_along(NAMES)) {
[16:21:03.301]                   name <- added[[kk]]
[16:21:03.301]                   NAME <- NAMES[[kk]]
[16:21:03.301]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.301]                     next
[16:21:03.301]                   args[[name]] <- ""
[16:21:03.301]                 }
[16:21:03.301]                 NAMES <- toupper(removed)
[16:21:03.301]                 for (kk in seq_along(NAMES)) {
[16:21:03.301]                   name <- removed[[kk]]
[16:21:03.301]                   NAME <- NAMES[[kk]]
[16:21:03.301]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.301]                     next
[16:21:03.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.301]                 }
[16:21:03.301]                 if (length(args) > 0) 
[16:21:03.301]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.301]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.301]             }
[16:21:03.301]             else {
[16:21:03.301]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.301]             }
[16:21:03.301]             {
[16:21:03.301]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.301]                   0L) {
[16:21:03.301]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.301]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.301]                   base::options(opts)
[16:21:03.301]                 }
[16:21:03.301]                 {
[16:21:03.301]                   {
[16:21:03.301]                     NULL
[16:21:03.301]                     RNGkind("Mersenne-Twister")
[16:21:03.301]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.301]                       inherits = FALSE)
[16:21:03.301]                   }
[16:21:03.301]                   options(future.plan = NULL)
[16:21:03.301]                   if (is.na(NA_character_)) 
[16:21:03.301]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.301]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.301]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.301]                     .init = FALSE)
[16:21:03.301]                 }
[16:21:03.301]             }
[16:21:03.301]         }
[16:21:03.301]     })
[16:21:03.301]     if (TRUE) {
[16:21:03.301]         base::sink(type = "output", split = FALSE)
[16:21:03.301]         if (TRUE) {
[16:21:03.301]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.301]         }
[16:21:03.301]         else {
[16:21:03.301]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.301]         }
[16:21:03.301]         base::close(...future.stdout)
[16:21:03.301]         ...future.stdout <- NULL
[16:21:03.301]     }
[16:21:03.301]     ...future.result$conditions <- ...future.conditions
[16:21:03.301]     ...future.result$finished <- base::Sys.time()
[16:21:03.301]     ...future.result
[16:21:03.301] }
[16:21:03.303] plan(): Setting new future strategy stack:
[16:21:03.303] List of future strategies:
[16:21:03.303] 1. sequential:
[16:21:03.303]    - args: function (..., envir = parent.frame())
[16:21:03.303]    - tweaked: FALSE
[16:21:03.303]    - call: NULL
[16:21:03.303] plan(): nbrOfWorkers() = 1
[16:21:03.304] plan(): Setting new future strategy stack:
[16:21:03.304] List of future strategies:
[16:21:03.304] 1. sequential:
[16:21:03.304]    - args: function (..., envir = parent.frame())
[16:21:03.304]    - tweaked: FALSE
[16:21:03.304]    - call: plan(strategy)
[16:21:03.305] plan(): nbrOfWorkers() = 1
[16:21:03.305] SequentialFuture started (and completed)
[16:21:03.305] - Launch lazy future ... done
[16:21:03.305] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.305] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.305] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.306] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:03.306] Searching for globals ... DONE
[16:21:03.307] Resolving globals: TRUE
[16:21:03.307] Resolving any globals that are futures ...
[16:21:03.307] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:03.307] Resolving any globals that are futures ... DONE
[16:21:03.307] Resolving futures part of globals (recursively) ...
[16:21:03.307] resolve() on list ...
[16:21:03.307]  recursive: 99
[16:21:03.308]  length: 1
[16:21:03.308]  elements: ‘a’
[16:21:03.308] resolved() for ‘SequentialFuture’ ...
[16:21:03.308] - state: ‘finished’
[16:21:03.308] - run: TRUE
[16:21:03.308] - result: ‘FutureResult’
[16:21:03.308] resolved() for ‘SequentialFuture’ ... done
[16:21:03.308] Future #1
[16:21:03.309] resolved() for ‘SequentialFuture’ ...
[16:21:03.309] - state: ‘finished’
[16:21:03.309] - run: TRUE
[16:21:03.309] - result: ‘FutureResult’
[16:21:03.309] resolved() for ‘SequentialFuture’ ... done
[16:21:03.309] A SequentialFuture was resolved
[16:21:03.309]  length: 0 (resolved future 1)
[16:21:03.309] resolve() on list ... DONE
[16:21:03.310] - globals: [1] ‘a’
[16:21:03.310] Resolving futures part of globals (recursively) ... DONE
[16:21:03.310] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[16:21:03.311] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[16:21:03.311] - globals: [1] ‘a’
[16:21:03.311] - packages: [1] ‘future’
[16:21:03.311] getGlobalsAndPackages() ... DONE
[16:21:03.311] run() for ‘Future’ ...
[16:21:03.311] - state: ‘created’
[16:21:03.312] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.312] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.312] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.312]   - Field: ‘label’
[16:21:03.312]   - Field: ‘local’
[16:21:03.312]   - Field: ‘owner’
[16:21:03.312]   - Field: ‘envir’
[16:21:03.313]   - Field: ‘packages’
[16:21:03.313]   - Field: ‘gc’
[16:21:03.313]   - Field: ‘conditions’
[16:21:03.313]   - Field: ‘expr’
[16:21:03.313]   - Field: ‘uuid’
[16:21:03.313]   - Field: ‘seed’
[16:21:03.313]   - Field: ‘version’
[16:21:03.313]   - Field: ‘result’
[16:21:03.313]   - Field: ‘asynchronous’
[16:21:03.313]   - Field: ‘calls’
[16:21:03.313]   - Field: ‘globals’
[16:21:03.314]   - Field: ‘stdout’
[16:21:03.314]   - Field: ‘earlySignal’
[16:21:03.314]   - Field: ‘lazy’
[16:21:03.314]   - Field: ‘state’
[16:21:03.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.314] - Launch lazy future ...
[16:21:03.314] Packages needed by the future expression (n = 1): ‘future’
[16:21:03.314] Packages needed by future strategies (n = 0): <none>
[16:21:03.315] {
[16:21:03.315]     {
[16:21:03.315]         {
[16:21:03.315]             ...future.startTime <- base::Sys.time()
[16:21:03.315]             {
[16:21:03.315]                 {
[16:21:03.315]                   {
[16:21:03.315]                     {
[16:21:03.315]                       base::local({
[16:21:03.315]                         has_future <- base::requireNamespace("future", 
[16:21:03.315]                           quietly = TRUE)
[16:21:03.315]                         if (has_future) {
[16:21:03.315]                           ns <- base::getNamespace("future")
[16:21:03.315]                           version <- ns[[".package"]][["version"]]
[16:21:03.315]                           if (is.null(version)) 
[16:21:03.315]                             version <- utils::packageVersion("future")
[16:21:03.315]                         }
[16:21:03.315]                         else {
[16:21:03.315]                           version <- NULL
[16:21:03.315]                         }
[16:21:03.315]                         if (!has_future || version < "1.8.0") {
[16:21:03.315]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.315]                             "", base::R.version$version.string), 
[16:21:03.315]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.315]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.315]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.315]                               "release", "version")], collapse = " "), 
[16:21:03.315]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.315]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.315]                             info)
[16:21:03.315]                           info <- base::paste(info, collapse = "; ")
[16:21:03.315]                           if (!has_future) {
[16:21:03.315]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.315]                               info)
[16:21:03.315]                           }
[16:21:03.315]                           else {
[16:21:03.315]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.315]                               info, version)
[16:21:03.315]                           }
[16:21:03.315]                           base::stop(msg)
[16:21:03.315]                         }
[16:21:03.315]                       })
[16:21:03.315]                     }
[16:21:03.315]                     base::local({
[16:21:03.315]                       for (pkg in "future") {
[16:21:03.315]                         base::loadNamespace(pkg)
[16:21:03.315]                         base::library(pkg, character.only = TRUE)
[16:21:03.315]                       }
[16:21:03.315]                     })
[16:21:03.315]                   }
[16:21:03.315]                   ...future.strategy.old <- future::plan("list")
[16:21:03.315]                   options(future.plan = NULL)
[16:21:03.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.315]                 }
[16:21:03.315]                 ...future.workdir <- getwd()
[16:21:03.315]             }
[16:21:03.315]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.315]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.315]         }
[16:21:03.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.315]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.315]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.315]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.315]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.315]             base::names(...future.oldOptions))
[16:21:03.315]     }
[16:21:03.315]     if (FALSE) {
[16:21:03.315]     }
[16:21:03.315]     else {
[16:21:03.315]         if (TRUE) {
[16:21:03.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.315]                 open = "w")
[16:21:03.315]         }
[16:21:03.315]         else {
[16:21:03.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.315]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.315]         }
[16:21:03.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.315]             base::sink(type = "output", split = FALSE)
[16:21:03.315]             base::close(...future.stdout)
[16:21:03.315]         }, add = TRUE)
[16:21:03.315]     }
[16:21:03.315]     ...future.frame <- base::sys.nframe()
[16:21:03.315]     ...future.conditions <- base::list()
[16:21:03.315]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.315]     if (FALSE) {
[16:21:03.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.315]     }
[16:21:03.315]     ...future.result <- base::tryCatch({
[16:21:03.315]         base::withCallingHandlers({
[16:21:03.315]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:21:03.315]                 1))
[16:21:03.315]             future::FutureResult(value = ...future.value$value, 
[16:21:03.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.315]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.315]                     ...future.globalenv.names))
[16:21:03.315]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.315]         }, condition = base::local({
[16:21:03.315]             c <- base::c
[16:21:03.315]             inherits <- base::inherits
[16:21:03.315]             invokeRestart <- base::invokeRestart
[16:21:03.315]             length <- base::length
[16:21:03.315]             list <- base::list
[16:21:03.315]             seq.int <- base::seq.int
[16:21:03.315]             signalCondition <- base::signalCondition
[16:21:03.315]             sys.calls <- base::sys.calls
[16:21:03.315]             `[[` <- base::`[[`
[16:21:03.315]             `+` <- base::`+`
[16:21:03.315]             `<<-` <- base::`<<-`
[16:21:03.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.315]                   3L)]
[16:21:03.315]             }
[16:21:03.315]             function(cond) {
[16:21:03.315]                 is_error <- inherits(cond, "error")
[16:21:03.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.315]                   NULL)
[16:21:03.315]                 if (is_error) {
[16:21:03.315]                   sessionInformation <- function() {
[16:21:03.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.315]                       search = base::search(), system = base::Sys.info())
[16:21:03.315]                   }
[16:21:03.315]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.315]                     cond$call), session = sessionInformation(), 
[16:21:03.315]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.315]                   signalCondition(cond)
[16:21:03.315]                 }
[16:21:03.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.315]                 "immediateCondition"))) {
[16:21:03.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.315]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.315]                   if (TRUE && !signal) {
[16:21:03.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.315]                     {
[16:21:03.315]                       inherits <- base::inherits
[16:21:03.315]                       invokeRestart <- base::invokeRestart
[16:21:03.315]                       is.null <- base::is.null
[16:21:03.315]                       muffled <- FALSE
[16:21:03.315]                       if (inherits(cond, "message")) {
[16:21:03.315]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.315]                         if (muffled) 
[16:21:03.315]                           invokeRestart("muffleMessage")
[16:21:03.315]                       }
[16:21:03.315]                       else if (inherits(cond, "warning")) {
[16:21:03.315]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.315]                         if (muffled) 
[16:21:03.315]                           invokeRestart("muffleWarning")
[16:21:03.315]                       }
[16:21:03.315]                       else if (inherits(cond, "condition")) {
[16:21:03.315]                         if (!is.null(pattern)) {
[16:21:03.315]                           computeRestarts <- base::computeRestarts
[16:21:03.315]                           grepl <- base::grepl
[16:21:03.315]                           restarts <- computeRestarts(cond)
[16:21:03.315]                           for (restart in restarts) {
[16:21:03.315]                             name <- restart$name
[16:21:03.315]                             if (is.null(name)) 
[16:21:03.315]                               next
[16:21:03.315]                             if (!grepl(pattern, name)) 
[16:21:03.315]                               next
[16:21:03.315]                             invokeRestart(restart)
[16:21:03.315]                             muffled <- TRUE
[16:21:03.315]                             break
[16:21:03.315]                           }
[16:21:03.315]                         }
[16:21:03.315]                       }
[16:21:03.315]                       invisible(muffled)
[16:21:03.315]                     }
[16:21:03.315]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.315]                   }
[16:21:03.315]                 }
[16:21:03.315]                 else {
[16:21:03.315]                   if (TRUE) {
[16:21:03.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.315]                     {
[16:21:03.315]                       inherits <- base::inherits
[16:21:03.315]                       invokeRestart <- base::invokeRestart
[16:21:03.315]                       is.null <- base::is.null
[16:21:03.315]                       muffled <- FALSE
[16:21:03.315]                       if (inherits(cond, "message")) {
[16:21:03.315]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.315]                         if (muffled) 
[16:21:03.315]                           invokeRestart("muffleMessage")
[16:21:03.315]                       }
[16:21:03.315]                       else if (inherits(cond, "warning")) {
[16:21:03.315]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.315]                         if (muffled) 
[16:21:03.315]                           invokeRestart("muffleWarning")
[16:21:03.315]                       }
[16:21:03.315]                       else if (inherits(cond, "condition")) {
[16:21:03.315]                         if (!is.null(pattern)) {
[16:21:03.315]                           computeRestarts <- base::computeRestarts
[16:21:03.315]                           grepl <- base::grepl
[16:21:03.315]                           restarts <- computeRestarts(cond)
[16:21:03.315]                           for (restart in restarts) {
[16:21:03.315]                             name <- restart$name
[16:21:03.315]                             if (is.null(name)) 
[16:21:03.315]                               next
[16:21:03.315]                             if (!grepl(pattern, name)) 
[16:21:03.315]                               next
[16:21:03.315]                             invokeRestart(restart)
[16:21:03.315]                             muffled <- TRUE
[16:21:03.315]                             break
[16:21:03.315]                           }
[16:21:03.315]                         }
[16:21:03.315]                       }
[16:21:03.315]                       invisible(muffled)
[16:21:03.315]                     }
[16:21:03.315]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.315]                   }
[16:21:03.315]                 }
[16:21:03.315]             }
[16:21:03.315]         }))
[16:21:03.315]     }, error = function(ex) {
[16:21:03.315]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.315]                 ...future.rng), started = ...future.startTime, 
[16:21:03.315]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.315]             version = "1.8"), class = "FutureResult")
[16:21:03.315]     }, finally = {
[16:21:03.315]         if (!identical(...future.workdir, getwd())) 
[16:21:03.315]             setwd(...future.workdir)
[16:21:03.315]         {
[16:21:03.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.315]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.315]             }
[16:21:03.315]             base::options(...future.oldOptions)
[16:21:03.315]             if (.Platform$OS.type == "windows") {
[16:21:03.315]                 old_names <- names(...future.oldEnvVars)
[16:21:03.315]                 envs <- base::Sys.getenv()
[16:21:03.315]                 names <- names(envs)
[16:21:03.315]                 common <- intersect(names, old_names)
[16:21:03.315]                 added <- setdiff(names, old_names)
[16:21:03.315]                 removed <- setdiff(old_names, names)
[16:21:03.315]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.315]                   envs[common]]
[16:21:03.315]                 NAMES <- toupper(changed)
[16:21:03.315]                 args <- list()
[16:21:03.315]                 for (kk in seq_along(NAMES)) {
[16:21:03.315]                   name <- changed[[kk]]
[16:21:03.315]                   NAME <- NAMES[[kk]]
[16:21:03.315]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.315]                     next
[16:21:03.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.315]                 }
[16:21:03.315]                 NAMES <- toupper(added)
[16:21:03.315]                 for (kk in seq_along(NAMES)) {
[16:21:03.315]                   name <- added[[kk]]
[16:21:03.315]                   NAME <- NAMES[[kk]]
[16:21:03.315]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.315]                     next
[16:21:03.315]                   args[[name]] <- ""
[16:21:03.315]                 }
[16:21:03.315]                 NAMES <- toupper(removed)
[16:21:03.315]                 for (kk in seq_along(NAMES)) {
[16:21:03.315]                   name <- removed[[kk]]
[16:21:03.315]                   NAME <- NAMES[[kk]]
[16:21:03.315]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.315]                     next
[16:21:03.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.315]                 }
[16:21:03.315]                 if (length(args) > 0) 
[16:21:03.315]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.315]             }
[16:21:03.315]             else {
[16:21:03.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.315]             }
[16:21:03.315]             {
[16:21:03.315]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.315]                   0L) {
[16:21:03.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.315]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.315]                   base::options(opts)
[16:21:03.315]                 }
[16:21:03.315]                 {
[16:21:03.315]                   {
[16:21:03.315]                     NULL
[16:21:03.315]                     RNGkind("Mersenne-Twister")
[16:21:03.315]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.315]                       inherits = FALSE)
[16:21:03.315]                   }
[16:21:03.315]                   options(future.plan = NULL)
[16:21:03.315]                   if (is.na(NA_character_)) 
[16:21:03.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.315]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.315]                     .init = FALSE)
[16:21:03.315]                 }
[16:21:03.315]             }
[16:21:03.315]         }
[16:21:03.315]     })
[16:21:03.315]     if (TRUE) {
[16:21:03.315]         base::sink(type = "output", split = FALSE)
[16:21:03.315]         if (TRUE) {
[16:21:03.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.315]         }
[16:21:03.315]         else {
[16:21:03.315]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.315]         }
[16:21:03.315]         base::close(...future.stdout)
[16:21:03.315]         ...future.stdout <- NULL
[16:21:03.315]     }
[16:21:03.315]     ...future.result$conditions <- ...future.conditions
[16:21:03.315]     ...future.result$finished <- base::Sys.time()
[16:21:03.315]     ...future.result
[16:21:03.315] }
[16:21:03.317] assign_globals() ...
[16:21:03.317] List of 1
[16:21:03.317]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x562226c9dfb8> 
[16:21:03.317]  - attr(*, "where")=List of 1
[16:21:03.317]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.317]  - attr(*, "resolved")= logi TRUE
[16:21:03.317]  - attr(*, "total_size")= num 10424
[16:21:03.317]  - attr(*, "already-done")= logi TRUE
[16:21:03.321] - copied ‘a’ to environment
[16:21:03.321] assign_globals() ... done
[16:21:03.321] plan(): Setting new future strategy stack:
[16:21:03.322] List of future strategies:
[16:21:03.322] 1. sequential:
[16:21:03.322]    - args: function (..., envir = parent.frame())
[16:21:03.322]    - tweaked: FALSE
[16:21:03.322]    - call: NULL
[16:21:03.322] plan(): nbrOfWorkers() = 1
[16:21:03.323] plan(): Setting new future strategy stack:
[16:21:03.323] List of future strategies:
[16:21:03.323] 1. sequential:
[16:21:03.323]    - args: function (..., envir = parent.frame())
[16:21:03.323]    - tweaked: FALSE
[16:21:03.323]    - call: plan(strategy)
[16:21:03.323] plan(): nbrOfWorkers() = 1
[16:21:03.323] SequentialFuture started (and completed)
[16:21:03.324] - Launch lazy future ... done
[16:21:03.324] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.324] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.324] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.325] 
[16:21:03.325] Searching for globals ... DONE
[16:21:03.325] - globals: [0] <none>
[16:21:03.325] getGlobalsAndPackages() ... DONE
[16:21:03.325] run() for ‘Future’ ...
[16:21:03.325] - state: ‘created’
[16:21:03.326] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.326] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.326] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.326]   - Field: ‘label’
[16:21:03.326]   - Field: ‘local’
[16:21:03.326]   - Field: ‘owner’
[16:21:03.326]   - Field: ‘envir’
[16:21:03.326]   - Field: ‘packages’
[16:21:03.327]   - Field: ‘gc’
[16:21:03.327]   - Field: ‘conditions’
[16:21:03.327]   - Field: ‘expr’
[16:21:03.327]   - Field: ‘uuid’
[16:21:03.327]   - Field: ‘seed’
[16:21:03.327]   - Field: ‘version’
[16:21:03.327]   - Field: ‘result’
[16:21:03.327]   - Field: ‘asynchronous’
[16:21:03.327]   - Field: ‘calls’
[16:21:03.327]   - Field: ‘globals’
[16:21:03.327]   - Field: ‘stdout’
[16:21:03.328]   - Field: ‘earlySignal’
[16:21:03.328]   - Field: ‘lazy’
[16:21:03.328]   - Field: ‘state’
[16:21:03.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.328] - Launch lazy future ...
[16:21:03.328] Packages needed by the future expression (n = 0): <none>
[16:21:03.328] Packages needed by future strategies (n = 0): <none>
[16:21:03.329] {
[16:21:03.329]     {
[16:21:03.329]         {
[16:21:03.329]             ...future.startTime <- base::Sys.time()
[16:21:03.329]             {
[16:21:03.329]                 {
[16:21:03.329]                   {
[16:21:03.329]                     base::local({
[16:21:03.329]                       has_future <- base::requireNamespace("future", 
[16:21:03.329]                         quietly = TRUE)
[16:21:03.329]                       if (has_future) {
[16:21:03.329]                         ns <- base::getNamespace("future")
[16:21:03.329]                         version <- ns[[".package"]][["version"]]
[16:21:03.329]                         if (is.null(version)) 
[16:21:03.329]                           version <- utils::packageVersion("future")
[16:21:03.329]                       }
[16:21:03.329]                       else {
[16:21:03.329]                         version <- NULL
[16:21:03.329]                       }
[16:21:03.329]                       if (!has_future || version < "1.8.0") {
[16:21:03.329]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.329]                           "", base::R.version$version.string), 
[16:21:03.329]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.329]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.329]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.329]                             "release", "version")], collapse = " "), 
[16:21:03.329]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.329]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.329]                           info)
[16:21:03.329]                         info <- base::paste(info, collapse = "; ")
[16:21:03.329]                         if (!has_future) {
[16:21:03.329]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.329]                             info)
[16:21:03.329]                         }
[16:21:03.329]                         else {
[16:21:03.329]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.329]                             info, version)
[16:21:03.329]                         }
[16:21:03.329]                         base::stop(msg)
[16:21:03.329]                       }
[16:21:03.329]                     })
[16:21:03.329]                   }
[16:21:03.329]                   ...future.strategy.old <- future::plan("list")
[16:21:03.329]                   options(future.plan = NULL)
[16:21:03.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.329]                 }
[16:21:03.329]                 ...future.workdir <- getwd()
[16:21:03.329]             }
[16:21:03.329]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.329]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.329]         }
[16:21:03.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.329]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.329]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.329]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.329]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.329]             base::names(...future.oldOptions))
[16:21:03.329]     }
[16:21:03.329]     if (FALSE) {
[16:21:03.329]     }
[16:21:03.329]     else {
[16:21:03.329]         if (TRUE) {
[16:21:03.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.329]                 open = "w")
[16:21:03.329]         }
[16:21:03.329]         else {
[16:21:03.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.329]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.329]         }
[16:21:03.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.329]             base::sink(type = "output", split = FALSE)
[16:21:03.329]             base::close(...future.stdout)
[16:21:03.329]         }, add = TRUE)
[16:21:03.329]     }
[16:21:03.329]     ...future.frame <- base::sys.nframe()
[16:21:03.329]     ...future.conditions <- base::list()
[16:21:03.329]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.329]     if (FALSE) {
[16:21:03.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.329]     }
[16:21:03.329]     ...future.result <- base::tryCatch({
[16:21:03.329]         base::withCallingHandlers({
[16:21:03.329]             ...future.value <- base::withVisible(base::local(1))
[16:21:03.329]             future::FutureResult(value = ...future.value$value, 
[16:21:03.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.329]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.329]                     ...future.globalenv.names))
[16:21:03.329]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.329]         }, condition = base::local({
[16:21:03.329]             c <- base::c
[16:21:03.329]             inherits <- base::inherits
[16:21:03.329]             invokeRestart <- base::invokeRestart
[16:21:03.329]             length <- base::length
[16:21:03.329]             list <- base::list
[16:21:03.329]             seq.int <- base::seq.int
[16:21:03.329]             signalCondition <- base::signalCondition
[16:21:03.329]             sys.calls <- base::sys.calls
[16:21:03.329]             `[[` <- base::`[[`
[16:21:03.329]             `+` <- base::`+`
[16:21:03.329]             `<<-` <- base::`<<-`
[16:21:03.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.329]                   3L)]
[16:21:03.329]             }
[16:21:03.329]             function(cond) {
[16:21:03.329]                 is_error <- inherits(cond, "error")
[16:21:03.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.329]                   NULL)
[16:21:03.329]                 if (is_error) {
[16:21:03.329]                   sessionInformation <- function() {
[16:21:03.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.329]                       search = base::search(), system = base::Sys.info())
[16:21:03.329]                   }
[16:21:03.329]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.329]                     cond$call), session = sessionInformation(), 
[16:21:03.329]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.329]                   signalCondition(cond)
[16:21:03.329]                 }
[16:21:03.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.329]                 "immediateCondition"))) {
[16:21:03.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.329]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.329]                   if (TRUE && !signal) {
[16:21:03.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.329]                     {
[16:21:03.329]                       inherits <- base::inherits
[16:21:03.329]                       invokeRestart <- base::invokeRestart
[16:21:03.329]                       is.null <- base::is.null
[16:21:03.329]                       muffled <- FALSE
[16:21:03.329]                       if (inherits(cond, "message")) {
[16:21:03.329]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.329]                         if (muffled) 
[16:21:03.329]                           invokeRestart("muffleMessage")
[16:21:03.329]                       }
[16:21:03.329]                       else if (inherits(cond, "warning")) {
[16:21:03.329]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.329]                         if (muffled) 
[16:21:03.329]                           invokeRestart("muffleWarning")
[16:21:03.329]                       }
[16:21:03.329]                       else if (inherits(cond, "condition")) {
[16:21:03.329]                         if (!is.null(pattern)) {
[16:21:03.329]                           computeRestarts <- base::computeRestarts
[16:21:03.329]                           grepl <- base::grepl
[16:21:03.329]                           restarts <- computeRestarts(cond)
[16:21:03.329]                           for (restart in restarts) {
[16:21:03.329]                             name <- restart$name
[16:21:03.329]                             if (is.null(name)) 
[16:21:03.329]                               next
[16:21:03.329]                             if (!grepl(pattern, name)) 
[16:21:03.329]                               next
[16:21:03.329]                             invokeRestart(restart)
[16:21:03.329]                             muffled <- TRUE
[16:21:03.329]                             break
[16:21:03.329]                           }
[16:21:03.329]                         }
[16:21:03.329]                       }
[16:21:03.329]                       invisible(muffled)
[16:21:03.329]                     }
[16:21:03.329]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.329]                   }
[16:21:03.329]                 }
[16:21:03.329]                 else {
[16:21:03.329]                   if (TRUE) {
[16:21:03.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.329]                     {
[16:21:03.329]                       inherits <- base::inherits
[16:21:03.329]                       invokeRestart <- base::invokeRestart
[16:21:03.329]                       is.null <- base::is.null
[16:21:03.329]                       muffled <- FALSE
[16:21:03.329]                       if (inherits(cond, "message")) {
[16:21:03.329]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.329]                         if (muffled) 
[16:21:03.329]                           invokeRestart("muffleMessage")
[16:21:03.329]                       }
[16:21:03.329]                       else if (inherits(cond, "warning")) {
[16:21:03.329]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.329]                         if (muffled) 
[16:21:03.329]                           invokeRestart("muffleWarning")
[16:21:03.329]                       }
[16:21:03.329]                       else if (inherits(cond, "condition")) {
[16:21:03.329]                         if (!is.null(pattern)) {
[16:21:03.329]                           computeRestarts <- base::computeRestarts
[16:21:03.329]                           grepl <- base::grepl
[16:21:03.329]                           restarts <- computeRestarts(cond)
[16:21:03.329]                           for (restart in restarts) {
[16:21:03.329]                             name <- restart$name
[16:21:03.329]                             if (is.null(name)) 
[16:21:03.329]                               next
[16:21:03.329]                             if (!grepl(pattern, name)) 
[16:21:03.329]                               next
[16:21:03.329]                             invokeRestart(restart)
[16:21:03.329]                             muffled <- TRUE
[16:21:03.329]                             break
[16:21:03.329]                           }
[16:21:03.329]                         }
[16:21:03.329]                       }
[16:21:03.329]                       invisible(muffled)
[16:21:03.329]                     }
[16:21:03.329]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.329]                   }
[16:21:03.329]                 }
[16:21:03.329]             }
[16:21:03.329]         }))
[16:21:03.329]     }, error = function(ex) {
[16:21:03.329]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.329]                 ...future.rng), started = ...future.startTime, 
[16:21:03.329]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.329]             version = "1.8"), class = "FutureResult")
[16:21:03.329]     }, finally = {
[16:21:03.329]         if (!identical(...future.workdir, getwd())) 
[16:21:03.329]             setwd(...future.workdir)
[16:21:03.329]         {
[16:21:03.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.329]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.329]             }
[16:21:03.329]             base::options(...future.oldOptions)
[16:21:03.329]             if (.Platform$OS.type == "windows") {
[16:21:03.329]                 old_names <- names(...future.oldEnvVars)
[16:21:03.329]                 envs <- base::Sys.getenv()
[16:21:03.329]                 names <- names(envs)
[16:21:03.329]                 common <- intersect(names, old_names)
[16:21:03.329]                 added <- setdiff(names, old_names)
[16:21:03.329]                 removed <- setdiff(old_names, names)
[16:21:03.329]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.329]                   envs[common]]
[16:21:03.329]                 NAMES <- toupper(changed)
[16:21:03.329]                 args <- list()
[16:21:03.329]                 for (kk in seq_along(NAMES)) {
[16:21:03.329]                   name <- changed[[kk]]
[16:21:03.329]                   NAME <- NAMES[[kk]]
[16:21:03.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.329]                     next
[16:21:03.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.329]                 }
[16:21:03.329]                 NAMES <- toupper(added)
[16:21:03.329]                 for (kk in seq_along(NAMES)) {
[16:21:03.329]                   name <- added[[kk]]
[16:21:03.329]                   NAME <- NAMES[[kk]]
[16:21:03.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.329]                     next
[16:21:03.329]                   args[[name]] <- ""
[16:21:03.329]                 }
[16:21:03.329]                 NAMES <- toupper(removed)
[16:21:03.329]                 for (kk in seq_along(NAMES)) {
[16:21:03.329]                   name <- removed[[kk]]
[16:21:03.329]                   NAME <- NAMES[[kk]]
[16:21:03.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.329]                     next
[16:21:03.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.329]                 }
[16:21:03.329]                 if (length(args) > 0) 
[16:21:03.329]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.329]             }
[16:21:03.329]             else {
[16:21:03.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.329]             }
[16:21:03.329]             {
[16:21:03.329]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.329]                   0L) {
[16:21:03.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.329]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.329]                   base::options(opts)
[16:21:03.329]                 }
[16:21:03.329]                 {
[16:21:03.329]                   {
[16:21:03.329]                     NULL
[16:21:03.329]                     RNGkind("Mersenne-Twister")
[16:21:03.329]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.329]                       inherits = FALSE)
[16:21:03.329]                   }
[16:21:03.329]                   options(future.plan = NULL)
[16:21:03.329]                   if (is.na(NA_character_)) 
[16:21:03.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.329]                     .init = FALSE)
[16:21:03.329]                 }
[16:21:03.329]             }
[16:21:03.329]         }
[16:21:03.329]     })
[16:21:03.329]     if (TRUE) {
[16:21:03.329]         base::sink(type = "output", split = FALSE)
[16:21:03.329]         if (TRUE) {
[16:21:03.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.329]         }
[16:21:03.329]         else {
[16:21:03.329]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.329]         }
[16:21:03.329]         base::close(...future.stdout)
[16:21:03.329]         ...future.stdout <- NULL
[16:21:03.329]     }
[16:21:03.329]     ...future.result$conditions <- ...future.conditions
[16:21:03.329]     ...future.result$finished <- base::Sys.time()
[16:21:03.329]     ...future.result
[16:21:03.329] }
[16:21:03.330] plan(): Setting new future strategy stack:
[16:21:03.331] List of future strategies:
[16:21:03.331] 1. sequential:
[16:21:03.331]    - args: function (..., envir = parent.frame())
[16:21:03.331]    - tweaked: FALSE
[16:21:03.331]    - call: NULL
[16:21:03.331] plan(): nbrOfWorkers() = 1
[16:21:03.332] plan(): Setting new future strategy stack:
[16:21:03.332] List of future strategies:
[16:21:03.332] 1. sequential:
[16:21:03.332]    - args: function (..., envir = parent.frame())
[16:21:03.332]    - tweaked: FALSE
[16:21:03.332]    - call: plan(strategy)
[16:21:03.332] plan(): nbrOfWorkers() = 1
[16:21:03.332] SequentialFuture started (and completed)
[16:21:03.332] - Launch lazy future ... done
[16:21:03.332] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.333] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.333] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.334] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:03.334] Searching for globals ... DONE
[16:21:03.334] Resolving globals: TRUE
[16:21:03.334] Resolving any globals that are futures ...
[16:21:03.334] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:03.334] Resolving any globals that are futures ... DONE
[16:21:03.335] Resolving futures part of globals (recursively) ...
[16:21:03.335] resolve() on list ...
[16:21:03.335]  recursive: 99
[16:21:03.335]  length: 1
[16:21:03.335]  elements: ‘a’
[16:21:03.335] resolved() for ‘SequentialFuture’ ...
[16:21:03.335] - state: ‘finished’
[16:21:03.335] - run: TRUE
[16:21:03.336] - result: ‘FutureResult’
[16:21:03.336] resolved() for ‘SequentialFuture’ ... done
[16:21:03.336] Future #1
[16:21:03.336] resolved() for ‘SequentialFuture’ ...
[16:21:03.336] - state: ‘finished’
[16:21:03.336] - run: TRUE
[16:21:03.336] - result: ‘FutureResult’
[16:21:03.336] resolved() for ‘SequentialFuture’ ... done
[16:21:03.336] A SequentialFuture was resolved
[16:21:03.337]  length: 0 (resolved future 1)
[16:21:03.337] resolve() on list ... DONE
[16:21:03.337] - globals: [1] ‘a’
[16:21:03.337] Resolving futures part of globals (recursively) ... DONE
[16:21:03.338] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[16:21:03.338] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[16:21:03.338] - globals: [1] ‘a’
[16:21:03.338] - packages: [1] ‘future’
[16:21:03.338] getGlobalsAndPackages() ... DONE
[16:21:03.339] run() for ‘Future’ ...
[16:21:03.339] - state: ‘created’
[16:21:03.339] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.339] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.339] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.339]   - Field: ‘label’
[16:21:03.339]   - Field: ‘local’
[16:21:03.339]   - Field: ‘owner’
[16:21:03.340]   - Field: ‘envir’
[16:21:03.340]   - Field: ‘packages’
[16:21:03.340]   - Field: ‘gc’
[16:21:03.340]   - Field: ‘conditions’
[16:21:03.340]   - Field: ‘expr’
[16:21:03.340]   - Field: ‘uuid’
[16:21:03.340]   - Field: ‘seed’
[16:21:03.340]   - Field: ‘version’
[16:21:03.340]   - Field: ‘result’
[16:21:03.340]   - Field: ‘asynchronous’
[16:21:03.341]   - Field: ‘calls’
[16:21:03.341]   - Field: ‘globals’
[16:21:03.341]   - Field: ‘stdout’
[16:21:03.341]   - Field: ‘earlySignal’
[16:21:03.341]   - Field: ‘lazy’
[16:21:03.341]   - Field: ‘state’
[16:21:03.341] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.341] - Launch lazy future ...
[16:21:03.341] Packages needed by the future expression (n = 1): ‘future’
[16:21:03.341] Packages needed by future strategies (n = 0): <none>
[16:21:03.342] {
[16:21:03.342]     {
[16:21:03.342]         {
[16:21:03.342]             ...future.startTime <- base::Sys.time()
[16:21:03.342]             {
[16:21:03.342]                 {
[16:21:03.342]                   {
[16:21:03.342]                     {
[16:21:03.342]                       base::local({
[16:21:03.342]                         has_future <- base::requireNamespace("future", 
[16:21:03.342]                           quietly = TRUE)
[16:21:03.342]                         if (has_future) {
[16:21:03.342]                           ns <- base::getNamespace("future")
[16:21:03.342]                           version <- ns[[".package"]][["version"]]
[16:21:03.342]                           if (is.null(version)) 
[16:21:03.342]                             version <- utils::packageVersion("future")
[16:21:03.342]                         }
[16:21:03.342]                         else {
[16:21:03.342]                           version <- NULL
[16:21:03.342]                         }
[16:21:03.342]                         if (!has_future || version < "1.8.0") {
[16:21:03.342]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.342]                             "", base::R.version$version.string), 
[16:21:03.342]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.342]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.342]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.342]                               "release", "version")], collapse = " "), 
[16:21:03.342]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.342]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.342]                             info)
[16:21:03.342]                           info <- base::paste(info, collapse = "; ")
[16:21:03.342]                           if (!has_future) {
[16:21:03.342]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.342]                               info)
[16:21:03.342]                           }
[16:21:03.342]                           else {
[16:21:03.342]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.342]                               info, version)
[16:21:03.342]                           }
[16:21:03.342]                           base::stop(msg)
[16:21:03.342]                         }
[16:21:03.342]                       })
[16:21:03.342]                     }
[16:21:03.342]                     base::local({
[16:21:03.342]                       for (pkg in "future") {
[16:21:03.342]                         base::loadNamespace(pkg)
[16:21:03.342]                         base::library(pkg, character.only = TRUE)
[16:21:03.342]                       }
[16:21:03.342]                     })
[16:21:03.342]                   }
[16:21:03.342]                   ...future.strategy.old <- future::plan("list")
[16:21:03.342]                   options(future.plan = NULL)
[16:21:03.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.342]                 }
[16:21:03.342]                 ...future.workdir <- getwd()
[16:21:03.342]             }
[16:21:03.342]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.342]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.342]         }
[16:21:03.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.342]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.342]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.342]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.342]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.342]             base::names(...future.oldOptions))
[16:21:03.342]     }
[16:21:03.342]     if (FALSE) {
[16:21:03.342]     }
[16:21:03.342]     else {
[16:21:03.342]         if (TRUE) {
[16:21:03.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.342]                 open = "w")
[16:21:03.342]         }
[16:21:03.342]         else {
[16:21:03.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.342]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.342]         }
[16:21:03.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.342]             base::sink(type = "output", split = FALSE)
[16:21:03.342]             base::close(...future.stdout)
[16:21:03.342]         }, add = TRUE)
[16:21:03.342]     }
[16:21:03.342]     ...future.frame <- base::sys.nframe()
[16:21:03.342]     ...future.conditions <- base::list()
[16:21:03.342]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.342]     if (FALSE) {
[16:21:03.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.342]     }
[16:21:03.342]     ...future.result <- base::tryCatch({
[16:21:03.342]         base::withCallingHandlers({
[16:21:03.342]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:21:03.342]                 1))
[16:21:03.342]             future::FutureResult(value = ...future.value$value, 
[16:21:03.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.342]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.342]                     ...future.globalenv.names))
[16:21:03.342]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.342]         }, condition = base::local({
[16:21:03.342]             c <- base::c
[16:21:03.342]             inherits <- base::inherits
[16:21:03.342]             invokeRestart <- base::invokeRestart
[16:21:03.342]             length <- base::length
[16:21:03.342]             list <- base::list
[16:21:03.342]             seq.int <- base::seq.int
[16:21:03.342]             signalCondition <- base::signalCondition
[16:21:03.342]             sys.calls <- base::sys.calls
[16:21:03.342]             `[[` <- base::`[[`
[16:21:03.342]             `+` <- base::`+`
[16:21:03.342]             `<<-` <- base::`<<-`
[16:21:03.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.342]                   3L)]
[16:21:03.342]             }
[16:21:03.342]             function(cond) {
[16:21:03.342]                 is_error <- inherits(cond, "error")
[16:21:03.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.342]                   NULL)
[16:21:03.342]                 if (is_error) {
[16:21:03.342]                   sessionInformation <- function() {
[16:21:03.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.342]                       search = base::search(), system = base::Sys.info())
[16:21:03.342]                   }
[16:21:03.342]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.342]                     cond$call), session = sessionInformation(), 
[16:21:03.342]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.342]                   signalCondition(cond)
[16:21:03.342]                 }
[16:21:03.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.342]                 "immediateCondition"))) {
[16:21:03.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.342]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.342]                   if (TRUE && !signal) {
[16:21:03.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.342]                     {
[16:21:03.342]                       inherits <- base::inherits
[16:21:03.342]                       invokeRestart <- base::invokeRestart
[16:21:03.342]                       is.null <- base::is.null
[16:21:03.342]                       muffled <- FALSE
[16:21:03.342]                       if (inherits(cond, "message")) {
[16:21:03.342]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.342]                         if (muffled) 
[16:21:03.342]                           invokeRestart("muffleMessage")
[16:21:03.342]                       }
[16:21:03.342]                       else if (inherits(cond, "warning")) {
[16:21:03.342]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.342]                         if (muffled) 
[16:21:03.342]                           invokeRestart("muffleWarning")
[16:21:03.342]                       }
[16:21:03.342]                       else if (inherits(cond, "condition")) {
[16:21:03.342]                         if (!is.null(pattern)) {
[16:21:03.342]                           computeRestarts <- base::computeRestarts
[16:21:03.342]                           grepl <- base::grepl
[16:21:03.342]                           restarts <- computeRestarts(cond)
[16:21:03.342]                           for (restart in restarts) {
[16:21:03.342]                             name <- restart$name
[16:21:03.342]                             if (is.null(name)) 
[16:21:03.342]                               next
[16:21:03.342]                             if (!grepl(pattern, name)) 
[16:21:03.342]                               next
[16:21:03.342]                             invokeRestart(restart)
[16:21:03.342]                             muffled <- TRUE
[16:21:03.342]                             break
[16:21:03.342]                           }
[16:21:03.342]                         }
[16:21:03.342]                       }
[16:21:03.342]                       invisible(muffled)
[16:21:03.342]                     }
[16:21:03.342]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.342]                   }
[16:21:03.342]                 }
[16:21:03.342]                 else {
[16:21:03.342]                   if (TRUE) {
[16:21:03.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.342]                     {
[16:21:03.342]                       inherits <- base::inherits
[16:21:03.342]                       invokeRestart <- base::invokeRestart
[16:21:03.342]                       is.null <- base::is.null
[16:21:03.342]                       muffled <- FALSE
[16:21:03.342]                       if (inherits(cond, "message")) {
[16:21:03.342]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.342]                         if (muffled) 
[16:21:03.342]                           invokeRestart("muffleMessage")
[16:21:03.342]                       }
[16:21:03.342]                       else if (inherits(cond, "warning")) {
[16:21:03.342]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.342]                         if (muffled) 
[16:21:03.342]                           invokeRestart("muffleWarning")
[16:21:03.342]                       }
[16:21:03.342]                       else if (inherits(cond, "condition")) {
[16:21:03.342]                         if (!is.null(pattern)) {
[16:21:03.342]                           computeRestarts <- base::computeRestarts
[16:21:03.342]                           grepl <- base::grepl
[16:21:03.342]                           restarts <- computeRestarts(cond)
[16:21:03.342]                           for (restart in restarts) {
[16:21:03.342]                             name <- restart$name
[16:21:03.342]                             if (is.null(name)) 
[16:21:03.342]                               next
[16:21:03.342]                             if (!grepl(pattern, name)) 
[16:21:03.342]                               next
[16:21:03.342]                             invokeRestart(restart)
[16:21:03.342]                             muffled <- TRUE
[16:21:03.342]                             break
[16:21:03.342]                           }
[16:21:03.342]                         }
[16:21:03.342]                       }
[16:21:03.342]                       invisible(muffled)
[16:21:03.342]                     }
[16:21:03.342]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.342]                   }
[16:21:03.342]                 }
[16:21:03.342]             }
[16:21:03.342]         }))
[16:21:03.342]     }, error = function(ex) {
[16:21:03.342]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.342]                 ...future.rng), started = ...future.startTime, 
[16:21:03.342]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.342]             version = "1.8"), class = "FutureResult")
[16:21:03.342]     }, finally = {
[16:21:03.342]         if (!identical(...future.workdir, getwd())) 
[16:21:03.342]             setwd(...future.workdir)
[16:21:03.342]         {
[16:21:03.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.342]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.342]             }
[16:21:03.342]             base::options(...future.oldOptions)
[16:21:03.342]             if (.Platform$OS.type == "windows") {
[16:21:03.342]                 old_names <- names(...future.oldEnvVars)
[16:21:03.342]                 envs <- base::Sys.getenv()
[16:21:03.342]                 names <- names(envs)
[16:21:03.342]                 common <- intersect(names, old_names)
[16:21:03.342]                 added <- setdiff(names, old_names)
[16:21:03.342]                 removed <- setdiff(old_names, names)
[16:21:03.342]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.342]                   envs[common]]
[16:21:03.342]                 NAMES <- toupper(changed)
[16:21:03.342]                 args <- list()
[16:21:03.342]                 for (kk in seq_along(NAMES)) {
[16:21:03.342]                   name <- changed[[kk]]
[16:21:03.342]                   NAME <- NAMES[[kk]]
[16:21:03.342]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.342]                     next
[16:21:03.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.342]                 }
[16:21:03.342]                 NAMES <- toupper(added)
[16:21:03.342]                 for (kk in seq_along(NAMES)) {
[16:21:03.342]                   name <- added[[kk]]
[16:21:03.342]                   NAME <- NAMES[[kk]]
[16:21:03.342]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.342]                     next
[16:21:03.342]                   args[[name]] <- ""
[16:21:03.342]                 }
[16:21:03.342]                 NAMES <- toupper(removed)
[16:21:03.342]                 for (kk in seq_along(NAMES)) {
[16:21:03.342]                   name <- removed[[kk]]
[16:21:03.342]                   NAME <- NAMES[[kk]]
[16:21:03.342]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.342]                     next
[16:21:03.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.342]                 }
[16:21:03.342]                 if (length(args) > 0) 
[16:21:03.342]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.342]             }
[16:21:03.342]             else {
[16:21:03.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.342]             }
[16:21:03.342]             {
[16:21:03.342]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.342]                   0L) {
[16:21:03.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.342]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.342]                   base::options(opts)
[16:21:03.342]                 }
[16:21:03.342]                 {
[16:21:03.342]                   {
[16:21:03.342]                     NULL
[16:21:03.342]                     RNGkind("Mersenne-Twister")
[16:21:03.342]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.342]                       inherits = FALSE)
[16:21:03.342]                   }
[16:21:03.342]                   options(future.plan = NULL)
[16:21:03.342]                   if (is.na(NA_character_)) 
[16:21:03.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.342]                     .init = FALSE)
[16:21:03.342]                 }
[16:21:03.342]             }
[16:21:03.342]         }
[16:21:03.342]     })
[16:21:03.342]     if (TRUE) {
[16:21:03.342]         base::sink(type = "output", split = FALSE)
[16:21:03.342]         if (TRUE) {
[16:21:03.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.342]         }
[16:21:03.342]         else {
[16:21:03.342]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.342]         }
[16:21:03.342]         base::close(...future.stdout)
[16:21:03.342]         ...future.stdout <- NULL
[16:21:03.342]     }
[16:21:03.342]     ...future.result$conditions <- ...future.conditions
[16:21:03.342]     ...future.result$finished <- base::Sys.time()
[16:21:03.342]     ...future.result
[16:21:03.342] }
[16:21:03.344] assign_globals() ...
[16:21:03.344] List of 1
[16:21:03.344]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x562226571d18> 
[16:21:03.344]  - attr(*, "where")=List of 1
[16:21:03.344]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.344]  - attr(*, "resolved")= logi TRUE
[16:21:03.344]  - attr(*, "total_size")= num 10424
[16:21:03.344]  - attr(*, "already-done")= logi TRUE
[16:21:03.346] - copied ‘a’ to environment
[16:21:03.346] assign_globals() ... done
[16:21:03.347] plan(): Setting new future strategy stack:
[16:21:03.347] List of future strategies:
[16:21:03.347] 1. sequential:
[16:21:03.347]    - args: function (..., envir = parent.frame())
[16:21:03.347]    - tweaked: FALSE
[16:21:03.347]    - call: NULL
[16:21:03.347] plan(): nbrOfWorkers() = 1
[16:21:03.350] plan(): Setting new future strategy stack:
[16:21:03.350] List of future strategies:
[16:21:03.350] 1. sequential:
[16:21:03.350]    - args: function (..., envir = parent.frame())
[16:21:03.350]    - tweaked: FALSE
[16:21:03.350]    - call: plan(strategy)
[16:21:03.350] plan(): nbrOfWorkers() = 1
[16:21:03.350] SequentialFuture started (and completed)
[16:21:03.351] - Launch lazy future ... done
[16:21:03.351] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.351] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.351] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.352] 
[16:21:03.352] Searching for globals ... DONE
[16:21:03.352] - globals: [0] <none>
[16:21:03.352] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.353] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.353] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.354] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:03.354] Searching for globals ... DONE
[16:21:03.354] Resolving globals: TRUE
[16:21:03.354] Resolving any globals that are futures ...
[16:21:03.354] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:03.354] Resolving any globals that are futures ... DONE
[16:21:03.354] Resolving futures part of globals (recursively) ...
[16:21:03.355] resolve() on list ...
[16:21:03.355]  recursive: 99
[16:21:03.355]  length: 1
[16:21:03.355]  elements: ‘a’
[16:21:03.355] run() for ‘Future’ ...
[16:21:03.355] - state: ‘created’
[16:21:03.355] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.356] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.356] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.356]   - Field: ‘label’
[16:21:03.356]   - Field: ‘local’
[16:21:03.356]   - Field: ‘owner’
[16:21:03.356]   - Field: ‘envir’
[16:21:03.356]   - Field: ‘packages’
[16:21:03.356]   - Field: ‘gc’
[16:21:03.356]   - Field: ‘conditions’
[16:21:03.356]   - Field: ‘expr’
[16:21:03.357]   - Field: ‘uuid’
[16:21:03.357]   - Field: ‘seed’
[16:21:03.357]   - Field: ‘version’
[16:21:03.357]   - Field: ‘result’
[16:21:03.357]   - Field: ‘asynchronous’
[16:21:03.357]   - Field: ‘calls’
[16:21:03.357]   - Field: ‘globals’
[16:21:03.357]   - Field: ‘stdout’
[16:21:03.357]   - Field: ‘earlySignal’
[16:21:03.357]   - Field: ‘lazy’
[16:21:03.357]   - Field: ‘state’
[16:21:03.358] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.358] - Launch lazy future ...
[16:21:03.358] Packages needed by the future expression (n = 0): <none>
[16:21:03.358] Packages needed by future strategies (n = 0): <none>
[16:21:03.358] {
[16:21:03.358]     {
[16:21:03.358]         {
[16:21:03.358]             ...future.startTime <- base::Sys.time()
[16:21:03.358]             {
[16:21:03.358]                 {
[16:21:03.358]                   {
[16:21:03.358]                     base::local({
[16:21:03.358]                       has_future <- base::requireNamespace("future", 
[16:21:03.358]                         quietly = TRUE)
[16:21:03.358]                       if (has_future) {
[16:21:03.358]                         ns <- base::getNamespace("future")
[16:21:03.358]                         version <- ns[[".package"]][["version"]]
[16:21:03.358]                         if (is.null(version)) 
[16:21:03.358]                           version <- utils::packageVersion("future")
[16:21:03.358]                       }
[16:21:03.358]                       else {
[16:21:03.358]                         version <- NULL
[16:21:03.358]                       }
[16:21:03.358]                       if (!has_future || version < "1.8.0") {
[16:21:03.358]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.358]                           "", base::R.version$version.string), 
[16:21:03.358]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.358]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.358]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.358]                             "release", "version")], collapse = " "), 
[16:21:03.358]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.358]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.358]                           info)
[16:21:03.358]                         info <- base::paste(info, collapse = "; ")
[16:21:03.358]                         if (!has_future) {
[16:21:03.358]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.358]                             info)
[16:21:03.358]                         }
[16:21:03.358]                         else {
[16:21:03.358]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.358]                             info, version)
[16:21:03.358]                         }
[16:21:03.358]                         base::stop(msg)
[16:21:03.358]                       }
[16:21:03.358]                     })
[16:21:03.358]                   }
[16:21:03.358]                   ...future.strategy.old <- future::plan("list")
[16:21:03.358]                   options(future.plan = NULL)
[16:21:03.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.358]                 }
[16:21:03.358]                 ...future.workdir <- getwd()
[16:21:03.358]             }
[16:21:03.358]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.358]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.358]         }
[16:21:03.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.358]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.358]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.358]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.358]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.358]             base::names(...future.oldOptions))
[16:21:03.358]     }
[16:21:03.358]     if (FALSE) {
[16:21:03.358]     }
[16:21:03.358]     else {
[16:21:03.358]         if (TRUE) {
[16:21:03.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.358]                 open = "w")
[16:21:03.358]         }
[16:21:03.358]         else {
[16:21:03.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.358]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.358]         }
[16:21:03.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.358]             base::sink(type = "output", split = FALSE)
[16:21:03.358]             base::close(...future.stdout)
[16:21:03.358]         }, add = TRUE)
[16:21:03.358]     }
[16:21:03.358]     ...future.frame <- base::sys.nframe()
[16:21:03.358]     ...future.conditions <- base::list()
[16:21:03.358]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.358]     if (FALSE) {
[16:21:03.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.358]     }
[16:21:03.358]     ...future.result <- base::tryCatch({
[16:21:03.358]         base::withCallingHandlers({
[16:21:03.358]             ...future.value <- base::withVisible(base::local(1))
[16:21:03.358]             future::FutureResult(value = ...future.value$value, 
[16:21:03.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.358]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.358]                     ...future.globalenv.names))
[16:21:03.358]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.358]         }, condition = base::local({
[16:21:03.358]             c <- base::c
[16:21:03.358]             inherits <- base::inherits
[16:21:03.358]             invokeRestart <- base::invokeRestart
[16:21:03.358]             length <- base::length
[16:21:03.358]             list <- base::list
[16:21:03.358]             seq.int <- base::seq.int
[16:21:03.358]             signalCondition <- base::signalCondition
[16:21:03.358]             sys.calls <- base::sys.calls
[16:21:03.358]             `[[` <- base::`[[`
[16:21:03.358]             `+` <- base::`+`
[16:21:03.358]             `<<-` <- base::`<<-`
[16:21:03.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.358]                   3L)]
[16:21:03.358]             }
[16:21:03.358]             function(cond) {
[16:21:03.358]                 is_error <- inherits(cond, "error")
[16:21:03.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.358]                   NULL)
[16:21:03.358]                 if (is_error) {
[16:21:03.358]                   sessionInformation <- function() {
[16:21:03.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.358]                       search = base::search(), system = base::Sys.info())
[16:21:03.358]                   }
[16:21:03.358]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.358]                     cond$call), session = sessionInformation(), 
[16:21:03.358]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.358]                   signalCondition(cond)
[16:21:03.358]                 }
[16:21:03.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.358]                 "immediateCondition"))) {
[16:21:03.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.358]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.358]                   if (TRUE && !signal) {
[16:21:03.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.358]                     {
[16:21:03.358]                       inherits <- base::inherits
[16:21:03.358]                       invokeRestart <- base::invokeRestart
[16:21:03.358]                       is.null <- base::is.null
[16:21:03.358]                       muffled <- FALSE
[16:21:03.358]                       if (inherits(cond, "message")) {
[16:21:03.358]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.358]                         if (muffled) 
[16:21:03.358]                           invokeRestart("muffleMessage")
[16:21:03.358]                       }
[16:21:03.358]                       else if (inherits(cond, "warning")) {
[16:21:03.358]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.358]                         if (muffled) 
[16:21:03.358]                           invokeRestart("muffleWarning")
[16:21:03.358]                       }
[16:21:03.358]                       else if (inherits(cond, "condition")) {
[16:21:03.358]                         if (!is.null(pattern)) {
[16:21:03.358]                           computeRestarts <- base::computeRestarts
[16:21:03.358]                           grepl <- base::grepl
[16:21:03.358]                           restarts <- computeRestarts(cond)
[16:21:03.358]                           for (restart in restarts) {
[16:21:03.358]                             name <- restart$name
[16:21:03.358]                             if (is.null(name)) 
[16:21:03.358]                               next
[16:21:03.358]                             if (!grepl(pattern, name)) 
[16:21:03.358]                               next
[16:21:03.358]                             invokeRestart(restart)
[16:21:03.358]                             muffled <- TRUE
[16:21:03.358]                             break
[16:21:03.358]                           }
[16:21:03.358]                         }
[16:21:03.358]                       }
[16:21:03.358]                       invisible(muffled)
[16:21:03.358]                     }
[16:21:03.358]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.358]                   }
[16:21:03.358]                 }
[16:21:03.358]                 else {
[16:21:03.358]                   if (TRUE) {
[16:21:03.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.358]                     {
[16:21:03.358]                       inherits <- base::inherits
[16:21:03.358]                       invokeRestart <- base::invokeRestart
[16:21:03.358]                       is.null <- base::is.null
[16:21:03.358]                       muffled <- FALSE
[16:21:03.358]                       if (inherits(cond, "message")) {
[16:21:03.358]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.358]                         if (muffled) 
[16:21:03.358]                           invokeRestart("muffleMessage")
[16:21:03.358]                       }
[16:21:03.358]                       else if (inherits(cond, "warning")) {
[16:21:03.358]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.358]                         if (muffled) 
[16:21:03.358]                           invokeRestart("muffleWarning")
[16:21:03.358]                       }
[16:21:03.358]                       else if (inherits(cond, "condition")) {
[16:21:03.358]                         if (!is.null(pattern)) {
[16:21:03.358]                           computeRestarts <- base::computeRestarts
[16:21:03.358]                           grepl <- base::grepl
[16:21:03.358]                           restarts <- computeRestarts(cond)
[16:21:03.358]                           for (restart in restarts) {
[16:21:03.358]                             name <- restart$name
[16:21:03.358]                             if (is.null(name)) 
[16:21:03.358]                               next
[16:21:03.358]                             if (!grepl(pattern, name)) 
[16:21:03.358]                               next
[16:21:03.358]                             invokeRestart(restart)
[16:21:03.358]                             muffled <- TRUE
[16:21:03.358]                             break
[16:21:03.358]                           }
[16:21:03.358]                         }
[16:21:03.358]                       }
[16:21:03.358]                       invisible(muffled)
[16:21:03.358]                     }
[16:21:03.358]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.358]                   }
[16:21:03.358]                 }
[16:21:03.358]             }
[16:21:03.358]         }))
[16:21:03.358]     }, error = function(ex) {
[16:21:03.358]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.358]                 ...future.rng), started = ...future.startTime, 
[16:21:03.358]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.358]             version = "1.8"), class = "FutureResult")
[16:21:03.358]     }, finally = {
[16:21:03.358]         if (!identical(...future.workdir, getwd())) 
[16:21:03.358]             setwd(...future.workdir)
[16:21:03.358]         {
[16:21:03.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.358]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.358]             }
[16:21:03.358]             base::options(...future.oldOptions)
[16:21:03.358]             if (.Platform$OS.type == "windows") {
[16:21:03.358]                 old_names <- names(...future.oldEnvVars)
[16:21:03.358]                 envs <- base::Sys.getenv()
[16:21:03.358]                 names <- names(envs)
[16:21:03.358]                 common <- intersect(names, old_names)
[16:21:03.358]                 added <- setdiff(names, old_names)
[16:21:03.358]                 removed <- setdiff(old_names, names)
[16:21:03.358]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.358]                   envs[common]]
[16:21:03.358]                 NAMES <- toupper(changed)
[16:21:03.358]                 args <- list()
[16:21:03.358]                 for (kk in seq_along(NAMES)) {
[16:21:03.358]                   name <- changed[[kk]]
[16:21:03.358]                   NAME <- NAMES[[kk]]
[16:21:03.358]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.358]                     next
[16:21:03.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.358]                 }
[16:21:03.358]                 NAMES <- toupper(added)
[16:21:03.358]                 for (kk in seq_along(NAMES)) {
[16:21:03.358]                   name <- added[[kk]]
[16:21:03.358]                   NAME <- NAMES[[kk]]
[16:21:03.358]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.358]                     next
[16:21:03.358]                   args[[name]] <- ""
[16:21:03.358]                 }
[16:21:03.358]                 NAMES <- toupper(removed)
[16:21:03.358]                 for (kk in seq_along(NAMES)) {
[16:21:03.358]                   name <- removed[[kk]]
[16:21:03.358]                   NAME <- NAMES[[kk]]
[16:21:03.358]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.358]                     next
[16:21:03.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.358]                 }
[16:21:03.358]                 if (length(args) > 0) 
[16:21:03.358]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.358]             }
[16:21:03.358]             else {
[16:21:03.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.358]             }
[16:21:03.358]             {
[16:21:03.358]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.358]                   0L) {
[16:21:03.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.358]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.358]                   base::options(opts)
[16:21:03.358]                 }
[16:21:03.358]                 {
[16:21:03.358]                   {
[16:21:03.358]                     NULL
[16:21:03.358]                     RNGkind("Mersenne-Twister")
[16:21:03.358]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.358]                       inherits = FALSE)
[16:21:03.358]                   }
[16:21:03.358]                   options(future.plan = NULL)
[16:21:03.358]                   if (is.na(NA_character_)) 
[16:21:03.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.358]                     .init = FALSE)
[16:21:03.358]                 }
[16:21:03.358]             }
[16:21:03.358]         }
[16:21:03.358]     })
[16:21:03.358]     if (TRUE) {
[16:21:03.358]         base::sink(type = "output", split = FALSE)
[16:21:03.358]         if (TRUE) {
[16:21:03.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.358]         }
[16:21:03.358]         else {
[16:21:03.358]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.358]         }
[16:21:03.358]         base::close(...future.stdout)
[16:21:03.358]         ...future.stdout <- NULL
[16:21:03.358]     }
[16:21:03.358]     ...future.result$conditions <- ...future.conditions
[16:21:03.358]     ...future.result$finished <- base::Sys.time()
[16:21:03.358]     ...future.result
[16:21:03.358] }
[16:21:03.360] plan(): Setting new future strategy stack:
[16:21:03.360] List of future strategies:
[16:21:03.360] 1. sequential:
[16:21:03.360]    - args: function (..., envir = parent.frame())
[16:21:03.360]    - tweaked: FALSE
[16:21:03.360]    - call: NULL
[16:21:03.361] plan(): nbrOfWorkers() = 1
[16:21:03.361] plan(): Setting new future strategy stack:
[16:21:03.361] List of future strategies:
[16:21:03.361] 1. sequential:
[16:21:03.361]    - args: function (..., envir = parent.frame())
[16:21:03.361]    - tweaked: FALSE
[16:21:03.361]    - call: plan(strategy)
[16:21:03.362] plan(): nbrOfWorkers() = 1
[16:21:03.362] SequentialFuture started (and completed)
[16:21:03.362] - Launch lazy future ... done
[16:21:03.362] run() for ‘SequentialFuture’ ... done
[16:21:03.362] resolved() for ‘SequentialFuture’ ...
[16:21:03.362] - state: ‘finished’
[16:21:03.362] - run: TRUE
[16:21:03.363] - result: ‘FutureResult’
[16:21:03.363] resolved() for ‘SequentialFuture’ ... done
[16:21:03.363] Future #1
[16:21:03.363] resolved() for ‘SequentialFuture’ ...
[16:21:03.363] - state: ‘finished’
[16:21:03.363] - run: TRUE
[16:21:03.363] - result: ‘FutureResult’
[16:21:03.363] resolved() for ‘SequentialFuture’ ... done
[16:21:03.363] A SequentialFuture was resolved
[16:21:03.364]  length: 0 (resolved future 1)
[16:21:03.364] resolve() on list ... DONE
[16:21:03.364] - globals: [1] ‘a’
[16:21:03.364] Resolving futures part of globals (recursively) ... DONE
[16:21:03.365] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[16:21:03.365] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[16:21:03.365] - globals: [1] ‘a’
[16:21:03.365] - packages: [1] ‘future’
[16:21:03.365] getGlobalsAndPackages() ... DONE
[16:21:03.366] run() for ‘Future’ ...
[16:21:03.366] - state: ‘created’
[16:21:03.366] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.366] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.366] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.366]   - Field: ‘label’
[16:21:03.366]   - Field: ‘local’
[16:21:03.366]   - Field: ‘owner’
[16:21:03.367]   - Field: ‘envir’
[16:21:03.367]   - Field: ‘packages’
[16:21:03.367]   - Field: ‘gc’
[16:21:03.367]   - Field: ‘conditions’
[16:21:03.367]   - Field: ‘expr’
[16:21:03.367]   - Field: ‘uuid’
[16:21:03.367]   - Field: ‘seed’
[16:21:03.367]   - Field: ‘version’
[16:21:03.367]   - Field: ‘result’
[16:21:03.367]   - Field: ‘asynchronous’
[16:21:03.367]   - Field: ‘calls’
[16:21:03.368]   - Field: ‘globals’
[16:21:03.368]   - Field: ‘stdout’
[16:21:03.368]   - Field: ‘earlySignal’
[16:21:03.368]   - Field: ‘lazy’
[16:21:03.368]   - Field: ‘state’
[16:21:03.368] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.368] - Launch lazy future ...
[16:21:03.368] Packages needed by the future expression (n = 1): ‘future’
[16:21:03.368] Packages needed by future strategies (n = 0): <none>
[16:21:03.369] {
[16:21:03.369]     {
[16:21:03.369]         {
[16:21:03.369]             ...future.startTime <- base::Sys.time()
[16:21:03.369]             {
[16:21:03.369]                 {
[16:21:03.369]                   {
[16:21:03.369]                     {
[16:21:03.369]                       base::local({
[16:21:03.369]                         has_future <- base::requireNamespace("future", 
[16:21:03.369]                           quietly = TRUE)
[16:21:03.369]                         if (has_future) {
[16:21:03.369]                           ns <- base::getNamespace("future")
[16:21:03.369]                           version <- ns[[".package"]][["version"]]
[16:21:03.369]                           if (is.null(version)) 
[16:21:03.369]                             version <- utils::packageVersion("future")
[16:21:03.369]                         }
[16:21:03.369]                         else {
[16:21:03.369]                           version <- NULL
[16:21:03.369]                         }
[16:21:03.369]                         if (!has_future || version < "1.8.0") {
[16:21:03.369]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.369]                             "", base::R.version$version.string), 
[16:21:03.369]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.369]                               "release", "version")], collapse = " "), 
[16:21:03.369]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.369]                             info)
[16:21:03.369]                           info <- base::paste(info, collapse = "; ")
[16:21:03.369]                           if (!has_future) {
[16:21:03.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.369]                               info)
[16:21:03.369]                           }
[16:21:03.369]                           else {
[16:21:03.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.369]                               info, version)
[16:21:03.369]                           }
[16:21:03.369]                           base::stop(msg)
[16:21:03.369]                         }
[16:21:03.369]                       })
[16:21:03.369]                     }
[16:21:03.369]                     base::local({
[16:21:03.369]                       for (pkg in "future") {
[16:21:03.369]                         base::loadNamespace(pkg)
[16:21:03.369]                         base::library(pkg, character.only = TRUE)
[16:21:03.369]                       }
[16:21:03.369]                     })
[16:21:03.369]                   }
[16:21:03.369]                   ...future.strategy.old <- future::plan("list")
[16:21:03.369]                   options(future.plan = NULL)
[16:21:03.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.369]                 }
[16:21:03.369]                 ...future.workdir <- getwd()
[16:21:03.369]             }
[16:21:03.369]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.369]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.369]         }
[16:21:03.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.369]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.369]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.369]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.369]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.369]             base::names(...future.oldOptions))
[16:21:03.369]     }
[16:21:03.369]     if (FALSE) {
[16:21:03.369]     }
[16:21:03.369]     else {
[16:21:03.369]         if (TRUE) {
[16:21:03.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.369]                 open = "w")
[16:21:03.369]         }
[16:21:03.369]         else {
[16:21:03.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.369]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.369]         }
[16:21:03.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.369]             base::sink(type = "output", split = FALSE)
[16:21:03.369]             base::close(...future.stdout)
[16:21:03.369]         }, add = TRUE)
[16:21:03.369]     }
[16:21:03.369]     ...future.frame <- base::sys.nframe()
[16:21:03.369]     ...future.conditions <- base::list()
[16:21:03.369]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.369]     if (FALSE) {
[16:21:03.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.369]     }
[16:21:03.369]     ...future.result <- base::tryCatch({
[16:21:03.369]         base::withCallingHandlers({
[16:21:03.369]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:21:03.369]                 1))
[16:21:03.369]             future::FutureResult(value = ...future.value$value, 
[16:21:03.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.369]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.369]                     ...future.globalenv.names))
[16:21:03.369]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.369]         }, condition = base::local({
[16:21:03.369]             c <- base::c
[16:21:03.369]             inherits <- base::inherits
[16:21:03.369]             invokeRestart <- base::invokeRestart
[16:21:03.369]             length <- base::length
[16:21:03.369]             list <- base::list
[16:21:03.369]             seq.int <- base::seq.int
[16:21:03.369]             signalCondition <- base::signalCondition
[16:21:03.369]             sys.calls <- base::sys.calls
[16:21:03.369]             `[[` <- base::`[[`
[16:21:03.369]             `+` <- base::`+`
[16:21:03.369]             `<<-` <- base::`<<-`
[16:21:03.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.369]                   3L)]
[16:21:03.369]             }
[16:21:03.369]             function(cond) {
[16:21:03.369]                 is_error <- inherits(cond, "error")
[16:21:03.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.369]                   NULL)
[16:21:03.369]                 if (is_error) {
[16:21:03.369]                   sessionInformation <- function() {
[16:21:03.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.369]                       search = base::search(), system = base::Sys.info())
[16:21:03.369]                   }
[16:21:03.369]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.369]                     cond$call), session = sessionInformation(), 
[16:21:03.369]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.369]                   signalCondition(cond)
[16:21:03.369]                 }
[16:21:03.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.369]                 "immediateCondition"))) {
[16:21:03.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.369]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.369]                   if (TRUE && !signal) {
[16:21:03.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.369]                     {
[16:21:03.369]                       inherits <- base::inherits
[16:21:03.369]                       invokeRestart <- base::invokeRestart
[16:21:03.369]                       is.null <- base::is.null
[16:21:03.369]                       muffled <- FALSE
[16:21:03.369]                       if (inherits(cond, "message")) {
[16:21:03.369]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.369]                         if (muffled) 
[16:21:03.369]                           invokeRestart("muffleMessage")
[16:21:03.369]                       }
[16:21:03.369]                       else if (inherits(cond, "warning")) {
[16:21:03.369]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.369]                         if (muffled) 
[16:21:03.369]                           invokeRestart("muffleWarning")
[16:21:03.369]                       }
[16:21:03.369]                       else if (inherits(cond, "condition")) {
[16:21:03.369]                         if (!is.null(pattern)) {
[16:21:03.369]                           computeRestarts <- base::computeRestarts
[16:21:03.369]                           grepl <- base::grepl
[16:21:03.369]                           restarts <- computeRestarts(cond)
[16:21:03.369]                           for (restart in restarts) {
[16:21:03.369]                             name <- restart$name
[16:21:03.369]                             if (is.null(name)) 
[16:21:03.369]                               next
[16:21:03.369]                             if (!grepl(pattern, name)) 
[16:21:03.369]                               next
[16:21:03.369]                             invokeRestart(restart)
[16:21:03.369]                             muffled <- TRUE
[16:21:03.369]                             break
[16:21:03.369]                           }
[16:21:03.369]                         }
[16:21:03.369]                       }
[16:21:03.369]                       invisible(muffled)
[16:21:03.369]                     }
[16:21:03.369]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.369]                   }
[16:21:03.369]                 }
[16:21:03.369]                 else {
[16:21:03.369]                   if (TRUE) {
[16:21:03.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.369]                     {
[16:21:03.369]                       inherits <- base::inherits
[16:21:03.369]                       invokeRestart <- base::invokeRestart
[16:21:03.369]                       is.null <- base::is.null
[16:21:03.369]                       muffled <- FALSE
[16:21:03.369]                       if (inherits(cond, "message")) {
[16:21:03.369]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.369]                         if (muffled) 
[16:21:03.369]                           invokeRestart("muffleMessage")
[16:21:03.369]                       }
[16:21:03.369]                       else if (inherits(cond, "warning")) {
[16:21:03.369]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.369]                         if (muffled) 
[16:21:03.369]                           invokeRestart("muffleWarning")
[16:21:03.369]                       }
[16:21:03.369]                       else if (inherits(cond, "condition")) {
[16:21:03.369]                         if (!is.null(pattern)) {
[16:21:03.369]                           computeRestarts <- base::computeRestarts
[16:21:03.369]                           grepl <- base::grepl
[16:21:03.369]                           restarts <- computeRestarts(cond)
[16:21:03.369]                           for (restart in restarts) {
[16:21:03.369]                             name <- restart$name
[16:21:03.369]                             if (is.null(name)) 
[16:21:03.369]                               next
[16:21:03.369]                             if (!grepl(pattern, name)) 
[16:21:03.369]                               next
[16:21:03.369]                             invokeRestart(restart)
[16:21:03.369]                             muffled <- TRUE
[16:21:03.369]                             break
[16:21:03.369]                           }
[16:21:03.369]                         }
[16:21:03.369]                       }
[16:21:03.369]                       invisible(muffled)
[16:21:03.369]                     }
[16:21:03.369]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.369]                   }
[16:21:03.369]                 }
[16:21:03.369]             }
[16:21:03.369]         }))
[16:21:03.369]     }, error = function(ex) {
[16:21:03.369]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.369]                 ...future.rng), started = ...future.startTime, 
[16:21:03.369]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.369]             version = "1.8"), class = "FutureResult")
[16:21:03.369]     }, finally = {
[16:21:03.369]         if (!identical(...future.workdir, getwd())) 
[16:21:03.369]             setwd(...future.workdir)
[16:21:03.369]         {
[16:21:03.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.369]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.369]             }
[16:21:03.369]             base::options(...future.oldOptions)
[16:21:03.369]             if (.Platform$OS.type == "windows") {
[16:21:03.369]                 old_names <- names(...future.oldEnvVars)
[16:21:03.369]                 envs <- base::Sys.getenv()
[16:21:03.369]                 names <- names(envs)
[16:21:03.369]                 common <- intersect(names, old_names)
[16:21:03.369]                 added <- setdiff(names, old_names)
[16:21:03.369]                 removed <- setdiff(old_names, names)
[16:21:03.369]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.369]                   envs[common]]
[16:21:03.369]                 NAMES <- toupper(changed)
[16:21:03.369]                 args <- list()
[16:21:03.369]                 for (kk in seq_along(NAMES)) {
[16:21:03.369]                   name <- changed[[kk]]
[16:21:03.369]                   NAME <- NAMES[[kk]]
[16:21:03.369]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.369]                     next
[16:21:03.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.369]                 }
[16:21:03.369]                 NAMES <- toupper(added)
[16:21:03.369]                 for (kk in seq_along(NAMES)) {
[16:21:03.369]                   name <- added[[kk]]
[16:21:03.369]                   NAME <- NAMES[[kk]]
[16:21:03.369]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.369]                     next
[16:21:03.369]                   args[[name]] <- ""
[16:21:03.369]                 }
[16:21:03.369]                 NAMES <- toupper(removed)
[16:21:03.369]                 for (kk in seq_along(NAMES)) {
[16:21:03.369]                   name <- removed[[kk]]
[16:21:03.369]                   NAME <- NAMES[[kk]]
[16:21:03.369]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.369]                     next
[16:21:03.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.369]                 }
[16:21:03.369]                 if (length(args) > 0) 
[16:21:03.369]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.369]             }
[16:21:03.369]             else {
[16:21:03.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.369]             }
[16:21:03.369]             {
[16:21:03.369]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.369]                   0L) {
[16:21:03.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.369]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.369]                   base::options(opts)
[16:21:03.369]                 }
[16:21:03.369]                 {
[16:21:03.369]                   {
[16:21:03.369]                     NULL
[16:21:03.369]                     RNGkind("Mersenne-Twister")
[16:21:03.369]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.369]                       inherits = FALSE)
[16:21:03.369]                   }
[16:21:03.369]                   options(future.plan = NULL)
[16:21:03.369]                   if (is.na(NA_character_)) 
[16:21:03.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.369]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.369]                     .init = FALSE)
[16:21:03.369]                 }
[16:21:03.369]             }
[16:21:03.369]         }
[16:21:03.369]     })
[16:21:03.369]     if (TRUE) {
[16:21:03.369]         base::sink(type = "output", split = FALSE)
[16:21:03.369]         if (TRUE) {
[16:21:03.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.369]         }
[16:21:03.369]         else {
[16:21:03.369]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.369]         }
[16:21:03.369]         base::close(...future.stdout)
[16:21:03.369]         ...future.stdout <- NULL
[16:21:03.369]     }
[16:21:03.369]     ...future.result$conditions <- ...future.conditions
[16:21:03.369]     ...future.result$finished <- base::Sys.time()
[16:21:03.369]     ...future.result
[16:21:03.369] }
[16:21:03.370] assign_globals() ...
[16:21:03.371] List of 1
[16:21:03.371]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x562226c20400> 
[16:21:03.371]  - attr(*, "where")=List of 1
[16:21:03.371]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.371]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.371]  - attr(*, "resolved")= logi TRUE
[16:21:03.371]  - attr(*, "total_size")= num 10592
[16:21:03.371]  - attr(*, "already-done")= logi TRUE
[16:21:03.373] - copied ‘a’ to environment
[16:21:03.373] assign_globals() ... done
[16:21:03.374] plan(): Setting new future strategy stack:
[16:21:03.374] List of future strategies:
[16:21:03.374] 1. sequential:
[16:21:03.374]    - args: function (..., envir = parent.frame())
[16:21:03.374]    - tweaked: FALSE
[16:21:03.374]    - call: NULL
[16:21:03.374] plan(): nbrOfWorkers() = 1
[16:21:03.375] plan(): Setting new future strategy stack:
[16:21:03.375] List of future strategies:
[16:21:03.375] 1. sequential:
[16:21:03.375]    - args: function (..., envir = parent.frame())
[16:21:03.375]    - tweaked: FALSE
[16:21:03.375]    - call: plan(strategy)
[16:21:03.375] plan(): nbrOfWorkers() = 1
[16:21:03.375] SequentialFuture started (and completed)
[16:21:03.375] - Launch lazy future ... done
[16:21:03.376] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.378] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.378] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.379] 
[16:21:03.379] Searching for globals ... DONE
[16:21:03.379] - globals: [0] <none>
[16:21:03.379] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.379] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.379] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.380] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:03.380] Searching for globals ... DONE
[16:21:03.380] Resolving globals: TRUE
[16:21:03.381] Resolving any globals that are futures ...
[16:21:03.381] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:03.381] Resolving any globals that are futures ... DONE
[16:21:03.381] Resolving futures part of globals (recursively) ...
[16:21:03.381] resolve() on list ...
[16:21:03.381]  recursive: 99
[16:21:03.382]  length: 1
[16:21:03.382]  elements: ‘a’
[16:21:03.382] run() for ‘Future’ ...
[16:21:03.382] - state: ‘created’
[16:21:03.382] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.382] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.382]   - Field: ‘label’
[16:21:03.383]   - Field: ‘local’
[16:21:03.383]   - Field: ‘owner’
[16:21:03.383]   - Field: ‘envir’
[16:21:03.383]   - Field: ‘packages’
[16:21:03.383]   - Field: ‘gc’
[16:21:03.383]   - Field: ‘conditions’
[16:21:03.383]   - Field: ‘expr’
[16:21:03.383]   - Field: ‘uuid’
[16:21:03.383]   - Field: ‘seed’
[16:21:03.383]   - Field: ‘version’
[16:21:03.383]   - Field: ‘result’
[16:21:03.384]   - Field: ‘asynchronous’
[16:21:03.384]   - Field: ‘calls’
[16:21:03.384]   - Field: ‘globals’
[16:21:03.384]   - Field: ‘stdout’
[16:21:03.384]   - Field: ‘earlySignal’
[16:21:03.384]   - Field: ‘lazy’
[16:21:03.384]   - Field: ‘state’
[16:21:03.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.384] - Launch lazy future ...
[16:21:03.385] Packages needed by the future expression (n = 0): <none>
[16:21:03.385] Packages needed by future strategies (n = 0): <none>
[16:21:03.385] {
[16:21:03.385]     {
[16:21:03.385]         {
[16:21:03.385]             ...future.startTime <- base::Sys.time()
[16:21:03.385]             {
[16:21:03.385]                 {
[16:21:03.385]                   {
[16:21:03.385]                     base::local({
[16:21:03.385]                       has_future <- base::requireNamespace("future", 
[16:21:03.385]                         quietly = TRUE)
[16:21:03.385]                       if (has_future) {
[16:21:03.385]                         ns <- base::getNamespace("future")
[16:21:03.385]                         version <- ns[[".package"]][["version"]]
[16:21:03.385]                         if (is.null(version)) 
[16:21:03.385]                           version <- utils::packageVersion("future")
[16:21:03.385]                       }
[16:21:03.385]                       else {
[16:21:03.385]                         version <- NULL
[16:21:03.385]                       }
[16:21:03.385]                       if (!has_future || version < "1.8.0") {
[16:21:03.385]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.385]                           "", base::R.version$version.string), 
[16:21:03.385]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.385]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.385]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.385]                             "release", "version")], collapse = " "), 
[16:21:03.385]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.385]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.385]                           info)
[16:21:03.385]                         info <- base::paste(info, collapse = "; ")
[16:21:03.385]                         if (!has_future) {
[16:21:03.385]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.385]                             info)
[16:21:03.385]                         }
[16:21:03.385]                         else {
[16:21:03.385]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.385]                             info, version)
[16:21:03.385]                         }
[16:21:03.385]                         base::stop(msg)
[16:21:03.385]                       }
[16:21:03.385]                     })
[16:21:03.385]                   }
[16:21:03.385]                   ...future.strategy.old <- future::plan("list")
[16:21:03.385]                   options(future.plan = NULL)
[16:21:03.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.385]                 }
[16:21:03.385]                 ...future.workdir <- getwd()
[16:21:03.385]             }
[16:21:03.385]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.385]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.385]         }
[16:21:03.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.385]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.385]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.385]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.385]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.385]             base::names(...future.oldOptions))
[16:21:03.385]     }
[16:21:03.385]     if (FALSE) {
[16:21:03.385]     }
[16:21:03.385]     else {
[16:21:03.385]         if (TRUE) {
[16:21:03.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.385]                 open = "w")
[16:21:03.385]         }
[16:21:03.385]         else {
[16:21:03.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.385]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.385]         }
[16:21:03.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.385]             base::sink(type = "output", split = FALSE)
[16:21:03.385]             base::close(...future.stdout)
[16:21:03.385]         }, add = TRUE)
[16:21:03.385]     }
[16:21:03.385]     ...future.frame <- base::sys.nframe()
[16:21:03.385]     ...future.conditions <- base::list()
[16:21:03.385]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.385]     if (FALSE) {
[16:21:03.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.385]     }
[16:21:03.385]     ...future.result <- base::tryCatch({
[16:21:03.385]         base::withCallingHandlers({
[16:21:03.385]             ...future.value <- base::withVisible(base::local(1))
[16:21:03.385]             future::FutureResult(value = ...future.value$value, 
[16:21:03.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.385]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.385]                     ...future.globalenv.names))
[16:21:03.385]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.385]         }, condition = base::local({
[16:21:03.385]             c <- base::c
[16:21:03.385]             inherits <- base::inherits
[16:21:03.385]             invokeRestart <- base::invokeRestart
[16:21:03.385]             length <- base::length
[16:21:03.385]             list <- base::list
[16:21:03.385]             seq.int <- base::seq.int
[16:21:03.385]             signalCondition <- base::signalCondition
[16:21:03.385]             sys.calls <- base::sys.calls
[16:21:03.385]             `[[` <- base::`[[`
[16:21:03.385]             `+` <- base::`+`
[16:21:03.385]             `<<-` <- base::`<<-`
[16:21:03.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.385]                   3L)]
[16:21:03.385]             }
[16:21:03.385]             function(cond) {
[16:21:03.385]                 is_error <- inherits(cond, "error")
[16:21:03.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.385]                   NULL)
[16:21:03.385]                 if (is_error) {
[16:21:03.385]                   sessionInformation <- function() {
[16:21:03.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.385]                       search = base::search(), system = base::Sys.info())
[16:21:03.385]                   }
[16:21:03.385]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.385]                     cond$call), session = sessionInformation(), 
[16:21:03.385]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.385]                   signalCondition(cond)
[16:21:03.385]                 }
[16:21:03.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.385]                 "immediateCondition"))) {
[16:21:03.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.385]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.385]                   if (TRUE && !signal) {
[16:21:03.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.385]                     {
[16:21:03.385]                       inherits <- base::inherits
[16:21:03.385]                       invokeRestart <- base::invokeRestart
[16:21:03.385]                       is.null <- base::is.null
[16:21:03.385]                       muffled <- FALSE
[16:21:03.385]                       if (inherits(cond, "message")) {
[16:21:03.385]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.385]                         if (muffled) 
[16:21:03.385]                           invokeRestart("muffleMessage")
[16:21:03.385]                       }
[16:21:03.385]                       else if (inherits(cond, "warning")) {
[16:21:03.385]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.385]                         if (muffled) 
[16:21:03.385]                           invokeRestart("muffleWarning")
[16:21:03.385]                       }
[16:21:03.385]                       else if (inherits(cond, "condition")) {
[16:21:03.385]                         if (!is.null(pattern)) {
[16:21:03.385]                           computeRestarts <- base::computeRestarts
[16:21:03.385]                           grepl <- base::grepl
[16:21:03.385]                           restarts <- computeRestarts(cond)
[16:21:03.385]                           for (restart in restarts) {
[16:21:03.385]                             name <- restart$name
[16:21:03.385]                             if (is.null(name)) 
[16:21:03.385]                               next
[16:21:03.385]                             if (!grepl(pattern, name)) 
[16:21:03.385]                               next
[16:21:03.385]                             invokeRestart(restart)
[16:21:03.385]                             muffled <- TRUE
[16:21:03.385]                             break
[16:21:03.385]                           }
[16:21:03.385]                         }
[16:21:03.385]                       }
[16:21:03.385]                       invisible(muffled)
[16:21:03.385]                     }
[16:21:03.385]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.385]                   }
[16:21:03.385]                 }
[16:21:03.385]                 else {
[16:21:03.385]                   if (TRUE) {
[16:21:03.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.385]                     {
[16:21:03.385]                       inherits <- base::inherits
[16:21:03.385]                       invokeRestart <- base::invokeRestart
[16:21:03.385]                       is.null <- base::is.null
[16:21:03.385]                       muffled <- FALSE
[16:21:03.385]                       if (inherits(cond, "message")) {
[16:21:03.385]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.385]                         if (muffled) 
[16:21:03.385]                           invokeRestart("muffleMessage")
[16:21:03.385]                       }
[16:21:03.385]                       else if (inherits(cond, "warning")) {
[16:21:03.385]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.385]                         if (muffled) 
[16:21:03.385]                           invokeRestart("muffleWarning")
[16:21:03.385]                       }
[16:21:03.385]                       else if (inherits(cond, "condition")) {
[16:21:03.385]                         if (!is.null(pattern)) {
[16:21:03.385]                           computeRestarts <- base::computeRestarts
[16:21:03.385]                           grepl <- base::grepl
[16:21:03.385]                           restarts <- computeRestarts(cond)
[16:21:03.385]                           for (restart in restarts) {
[16:21:03.385]                             name <- restart$name
[16:21:03.385]                             if (is.null(name)) 
[16:21:03.385]                               next
[16:21:03.385]                             if (!grepl(pattern, name)) 
[16:21:03.385]                               next
[16:21:03.385]                             invokeRestart(restart)
[16:21:03.385]                             muffled <- TRUE
[16:21:03.385]                             break
[16:21:03.385]                           }
[16:21:03.385]                         }
[16:21:03.385]                       }
[16:21:03.385]                       invisible(muffled)
[16:21:03.385]                     }
[16:21:03.385]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.385]                   }
[16:21:03.385]                 }
[16:21:03.385]             }
[16:21:03.385]         }))
[16:21:03.385]     }, error = function(ex) {
[16:21:03.385]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.385]                 ...future.rng), started = ...future.startTime, 
[16:21:03.385]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.385]             version = "1.8"), class = "FutureResult")
[16:21:03.385]     }, finally = {
[16:21:03.385]         if (!identical(...future.workdir, getwd())) 
[16:21:03.385]             setwd(...future.workdir)
[16:21:03.385]         {
[16:21:03.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.385]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.385]             }
[16:21:03.385]             base::options(...future.oldOptions)
[16:21:03.385]             if (.Platform$OS.type == "windows") {
[16:21:03.385]                 old_names <- names(...future.oldEnvVars)
[16:21:03.385]                 envs <- base::Sys.getenv()
[16:21:03.385]                 names <- names(envs)
[16:21:03.385]                 common <- intersect(names, old_names)
[16:21:03.385]                 added <- setdiff(names, old_names)
[16:21:03.385]                 removed <- setdiff(old_names, names)
[16:21:03.385]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.385]                   envs[common]]
[16:21:03.385]                 NAMES <- toupper(changed)
[16:21:03.385]                 args <- list()
[16:21:03.385]                 for (kk in seq_along(NAMES)) {
[16:21:03.385]                   name <- changed[[kk]]
[16:21:03.385]                   NAME <- NAMES[[kk]]
[16:21:03.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.385]                     next
[16:21:03.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.385]                 }
[16:21:03.385]                 NAMES <- toupper(added)
[16:21:03.385]                 for (kk in seq_along(NAMES)) {
[16:21:03.385]                   name <- added[[kk]]
[16:21:03.385]                   NAME <- NAMES[[kk]]
[16:21:03.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.385]                     next
[16:21:03.385]                   args[[name]] <- ""
[16:21:03.385]                 }
[16:21:03.385]                 NAMES <- toupper(removed)
[16:21:03.385]                 for (kk in seq_along(NAMES)) {
[16:21:03.385]                   name <- removed[[kk]]
[16:21:03.385]                   NAME <- NAMES[[kk]]
[16:21:03.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.385]                     next
[16:21:03.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.385]                 }
[16:21:03.385]                 if (length(args) > 0) 
[16:21:03.385]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.385]             }
[16:21:03.385]             else {
[16:21:03.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.385]             }
[16:21:03.385]             {
[16:21:03.385]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.385]                   0L) {
[16:21:03.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.385]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.385]                   base::options(opts)
[16:21:03.385]                 }
[16:21:03.385]                 {
[16:21:03.385]                   {
[16:21:03.385]                     NULL
[16:21:03.385]                     RNGkind("Mersenne-Twister")
[16:21:03.385]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.385]                       inherits = FALSE)
[16:21:03.385]                   }
[16:21:03.385]                   options(future.plan = NULL)
[16:21:03.385]                   if (is.na(NA_character_)) 
[16:21:03.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.385]                     .init = FALSE)
[16:21:03.385]                 }
[16:21:03.385]             }
[16:21:03.385]         }
[16:21:03.385]     })
[16:21:03.385]     if (TRUE) {
[16:21:03.385]         base::sink(type = "output", split = FALSE)
[16:21:03.385]         if (TRUE) {
[16:21:03.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.385]         }
[16:21:03.385]         else {
[16:21:03.385]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.385]         }
[16:21:03.385]         base::close(...future.stdout)
[16:21:03.385]         ...future.stdout <- NULL
[16:21:03.385]     }
[16:21:03.385]     ...future.result$conditions <- ...future.conditions
[16:21:03.385]     ...future.result$finished <- base::Sys.time()
[16:21:03.385]     ...future.result
[16:21:03.385] }
[16:21:03.387] plan(): Setting new future strategy stack:
[16:21:03.387] List of future strategies:
[16:21:03.387] 1. sequential:
[16:21:03.387]    - args: function (..., envir = parent.frame())
[16:21:03.387]    - tweaked: FALSE
[16:21:03.387]    - call: NULL
[16:21:03.387] plan(): nbrOfWorkers() = 1
[16:21:03.388] plan(): Setting new future strategy stack:
[16:21:03.388] List of future strategies:
[16:21:03.388] 1. sequential:
[16:21:03.388]    - args: function (..., envir = parent.frame())
[16:21:03.388]    - tweaked: FALSE
[16:21:03.388]    - call: plan(strategy)
[16:21:03.388] plan(): nbrOfWorkers() = 1
[16:21:03.389] SequentialFuture started (and completed)
[16:21:03.389] - Launch lazy future ... done
[16:21:03.389] run() for ‘SequentialFuture’ ... done
[16:21:03.389] resolved() for ‘SequentialFuture’ ...
[16:21:03.389] - state: ‘finished’
[16:21:03.389] - run: TRUE
[16:21:03.389] - result: ‘FutureResult’
[16:21:03.389] resolved() for ‘SequentialFuture’ ... done
[16:21:03.389] Future #1
[16:21:03.390] resolved() for ‘SequentialFuture’ ...
[16:21:03.390] - state: ‘finished’
[16:21:03.390] - run: TRUE
[16:21:03.390] - result: ‘FutureResult’
[16:21:03.390] resolved() for ‘SequentialFuture’ ... done
[16:21:03.390] A SequentialFuture was resolved
[16:21:03.390]  length: 0 (resolved future 1)
[16:21:03.390] resolve() on list ... DONE
[16:21:03.390] - globals: [1] ‘a’
[16:21:03.390] Resolving futures part of globals (recursively) ... DONE
[16:21:03.391] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[16:21:03.391] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[16:21:03.392] - globals: [1] ‘a’
[16:21:03.392] - packages: [1] ‘future’
[16:21:03.392] getGlobalsAndPackages() ... DONE
[16:21:03.392] run() for ‘Future’ ...
[16:21:03.392] - state: ‘created’
[16:21:03.392] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.393] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.393]   - Field: ‘label’
[16:21:03.393]   - Field: ‘local’
[16:21:03.393]   - Field: ‘owner’
[16:21:03.393]   - Field: ‘envir’
[16:21:03.393]   - Field: ‘packages’
[16:21:03.393]   - Field: ‘gc’
[16:21:03.393]   - Field: ‘conditions’
[16:21:03.394]   - Field: ‘expr’
[16:21:03.394]   - Field: ‘uuid’
[16:21:03.394]   - Field: ‘seed’
[16:21:03.394]   - Field: ‘version’
[16:21:03.394]   - Field: ‘result’
[16:21:03.394]   - Field: ‘asynchronous’
[16:21:03.394]   - Field: ‘calls’
[16:21:03.394]   - Field: ‘globals’
[16:21:03.394]   - Field: ‘stdout’
[16:21:03.394]   - Field: ‘earlySignal’
[16:21:03.394]   - Field: ‘lazy’
[16:21:03.395]   - Field: ‘state’
[16:21:03.395] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.395] - Launch lazy future ...
[16:21:03.395] Packages needed by the future expression (n = 1): ‘future’
[16:21:03.395] Packages needed by future strategies (n = 0): <none>
[16:21:03.395] {
[16:21:03.395]     {
[16:21:03.395]         {
[16:21:03.395]             ...future.startTime <- base::Sys.time()
[16:21:03.395]             {
[16:21:03.395]                 {
[16:21:03.395]                   {
[16:21:03.395]                     {
[16:21:03.395]                       base::local({
[16:21:03.395]                         has_future <- base::requireNamespace("future", 
[16:21:03.395]                           quietly = TRUE)
[16:21:03.395]                         if (has_future) {
[16:21:03.395]                           ns <- base::getNamespace("future")
[16:21:03.395]                           version <- ns[[".package"]][["version"]]
[16:21:03.395]                           if (is.null(version)) 
[16:21:03.395]                             version <- utils::packageVersion("future")
[16:21:03.395]                         }
[16:21:03.395]                         else {
[16:21:03.395]                           version <- NULL
[16:21:03.395]                         }
[16:21:03.395]                         if (!has_future || version < "1.8.0") {
[16:21:03.395]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.395]                             "", base::R.version$version.string), 
[16:21:03.395]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.395]                               "release", "version")], collapse = " "), 
[16:21:03.395]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.395]                             info)
[16:21:03.395]                           info <- base::paste(info, collapse = "; ")
[16:21:03.395]                           if (!has_future) {
[16:21:03.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.395]                               info)
[16:21:03.395]                           }
[16:21:03.395]                           else {
[16:21:03.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.395]                               info, version)
[16:21:03.395]                           }
[16:21:03.395]                           base::stop(msg)
[16:21:03.395]                         }
[16:21:03.395]                       })
[16:21:03.395]                     }
[16:21:03.395]                     base::local({
[16:21:03.395]                       for (pkg in "future") {
[16:21:03.395]                         base::loadNamespace(pkg)
[16:21:03.395]                         base::library(pkg, character.only = TRUE)
[16:21:03.395]                       }
[16:21:03.395]                     })
[16:21:03.395]                   }
[16:21:03.395]                   ...future.strategy.old <- future::plan("list")
[16:21:03.395]                   options(future.plan = NULL)
[16:21:03.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.395]                 }
[16:21:03.395]                 ...future.workdir <- getwd()
[16:21:03.395]             }
[16:21:03.395]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.395]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.395]         }
[16:21:03.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.395]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.395]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.395]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.395]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.395]             base::names(...future.oldOptions))
[16:21:03.395]     }
[16:21:03.395]     if (FALSE) {
[16:21:03.395]     }
[16:21:03.395]     else {
[16:21:03.395]         if (TRUE) {
[16:21:03.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.395]                 open = "w")
[16:21:03.395]         }
[16:21:03.395]         else {
[16:21:03.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.395]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.395]         }
[16:21:03.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.395]             base::sink(type = "output", split = FALSE)
[16:21:03.395]             base::close(...future.stdout)
[16:21:03.395]         }, add = TRUE)
[16:21:03.395]     }
[16:21:03.395]     ...future.frame <- base::sys.nframe()
[16:21:03.395]     ...future.conditions <- base::list()
[16:21:03.395]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.395]     if (FALSE) {
[16:21:03.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.395]     }
[16:21:03.395]     ...future.result <- base::tryCatch({
[16:21:03.395]         base::withCallingHandlers({
[16:21:03.395]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:21:03.395]                 1))
[16:21:03.395]             future::FutureResult(value = ...future.value$value, 
[16:21:03.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.395]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.395]                     ...future.globalenv.names))
[16:21:03.395]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.395]         }, condition = base::local({
[16:21:03.395]             c <- base::c
[16:21:03.395]             inherits <- base::inherits
[16:21:03.395]             invokeRestart <- base::invokeRestart
[16:21:03.395]             length <- base::length
[16:21:03.395]             list <- base::list
[16:21:03.395]             seq.int <- base::seq.int
[16:21:03.395]             signalCondition <- base::signalCondition
[16:21:03.395]             sys.calls <- base::sys.calls
[16:21:03.395]             `[[` <- base::`[[`
[16:21:03.395]             `+` <- base::`+`
[16:21:03.395]             `<<-` <- base::`<<-`
[16:21:03.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.395]                   3L)]
[16:21:03.395]             }
[16:21:03.395]             function(cond) {
[16:21:03.395]                 is_error <- inherits(cond, "error")
[16:21:03.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.395]                   NULL)
[16:21:03.395]                 if (is_error) {
[16:21:03.395]                   sessionInformation <- function() {
[16:21:03.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.395]                       search = base::search(), system = base::Sys.info())
[16:21:03.395]                   }
[16:21:03.395]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.395]                     cond$call), session = sessionInformation(), 
[16:21:03.395]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.395]                   signalCondition(cond)
[16:21:03.395]                 }
[16:21:03.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.395]                 "immediateCondition"))) {
[16:21:03.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.395]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.395]                   if (TRUE && !signal) {
[16:21:03.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.395]                     {
[16:21:03.395]                       inherits <- base::inherits
[16:21:03.395]                       invokeRestart <- base::invokeRestart
[16:21:03.395]                       is.null <- base::is.null
[16:21:03.395]                       muffled <- FALSE
[16:21:03.395]                       if (inherits(cond, "message")) {
[16:21:03.395]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.395]                         if (muffled) 
[16:21:03.395]                           invokeRestart("muffleMessage")
[16:21:03.395]                       }
[16:21:03.395]                       else if (inherits(cond, "warning")) {
[16:21:03.395]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.395]                         if (muffled) 
[16:21:03.395]                           invokeRestart("muffleWarning")
[16:21:03.395]                       }
[16:21:03.395]                       else if (inherits(cond, "condition")) {
[16:21:03.395]                         if (!is.null(pattern)) {
[16:21:03.395]                           computeRestarts <- base::computeRestarts
[16:21:03.395]                           grepl <- base::grepl
[16:21:03.395]                           restarts <- computeRestarts(cond)
[16:21:03.395]                           for (restart in restarts) {
[16:21:03.395]                             name <- restart$name
[16:21:03.395]                             if (is.null(name)) 
[16:21:03.395]                               next
[16:21:03.395]                             if (!grepl(pattern, name)) 
[16:21:03.395]                               next
[16:21:03.395]                             invokeRestart(restart)
[16:21:03.395]                             muffled <- TRUE
[16:21:03.395]                             break
[16:21:03.395]                           }
[16:21:03.395]                         }
[16:21:03.395]                       }
[16:21:03.395]                       invisible(muffled)
[16:21:03.395]                     }
[16:21:03.395]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.395]                   }
[16:21:03.395]                 }
[16:21:03.395]                 else {
[16:21:03.395]                   if (TRUE) {
[16:21:03.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.395]                     {
[16:21:03.395]                       inherits <- base::inherits
[16:21:03.395]                       invokeRestart <- base::invokeRestart
[16:21:03.395]                       is.null <- base::is.null
[16:21:03.395]                       muffled <- FALSE
[16:21:03.395]                       if (inherits(cond, "message")) {
[16:21:03.395]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.395]                         if (muffled) 
[16:21:03.395]                           invokeRestart("muffleMessage")
[16:21:03.395]                       }
[16:21:03.395]                       else if (inherits(cond, "warning")) {
[16:21:03.395]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.395]                         if (muffled) 
[16:21:03.395]                           invokeRestart("muffleWarning")
[16:21:03.395]                       }
[16:21:03.395]                       else if (inherits(cond, "condition")) {
[16:21:03.395]                         if (!is.null(pattern)) {
[16:21:03.395]                           computeRestarts <- base::computeRestarts
[16:21:03.395]                           grepl <- base::grepl
[16:21:03.395]                           restarts <- computeRestarts(cond)
[16:21:03.395]                           for (restart in restarts) {
[16:21:03.395]                             name <- restart$name
[16:21:03.395]                             if (is.null(name)) 
[16:21:03.395]                               next
[16:21:03.395]                             if (!grepl(pattern, name)) 
[16:21:03.395]                               next
[16:21:03.395]                             invokeRestart(restart)
[16:21:03.395]                             muffled <- TRUE
[16:21:03.395]                             break
[16:21:03.395]                           }
[16:21:03.395]                         }
[16:21:03.395]                       }
[16:21:03.395]                       invisible(muffled)
[16:21:03.395]                     }
[16:21:03.395]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.395]                   }
[16:21:03.395]                 }
[16:21:03.395]             }
[16:21:03.395]         }))
[16:21:03.395]     }, error = function(ex) {
[16:21:03.395]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.395]                 ...future.rng), started = ...future.startTime, 
[16:21:03.395]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.395]             version = "1.8"), class = "FutureResult")
[16:21:03.395]     }, finally = {
[16:21:03.395]         if (!identical(...future.workdir, getwd())) 
[16:21:03.395]             setwd(...future.workdir)
[16:21:03.395]         {
[16:21:03.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.395]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.395]             }
[16:21:03.395]             base::options(...future.oldOptions)
[16:21:03.395]             if (.Platform$OS.type == "windows") {
[16:21:03.395]                 old_names <- names(...future.oldEnvVars)
[16:21:03.395]                 envs <- base::Sys.getenv()
[16:21:03.395]                 names <- names(envs)
[16:21:03.395]                 common <- intersect(names, old_names)
[16:21:03.395]                 added <- setdiff(names, old_names)
[16:21:03.395]                 removed <- setdiff(old_names, names)
[16:21:03.395]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.395]                   envs[common]]
[16:21:03.395]                 NAMES <- toupper(changed)
[16:21:03.395]                 args <- list()
[16:21:03.395]                 for (kk in seq_along(NAMES)) {
[16:21:03.395]                   name <- changed[[kk]]
[16:21:03.395]                   NAME <- NAMES[[kk]]
[16:21:03.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.395]                     next
[16:21:03.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.395]                 }
[16:21:03.395]                 NAMES <- toupper(added)
[16:21:03.395]                 for (kk in seq_along(NAMES)) {
[16:21:03.395]                   name <- added[[kk]]
[16:21:03.395]                   NAME <- NAMES[[kk]]
[16:21:03.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.395]                     next
[16:21:03.395]                   args[[name]] <- ""
[16:21:03.395]                 }
[16:21:03.395]                 NAMES <- toupper(removed)
[16:21:03.395]                 for (kk in seq_along(NAMES)) {
[16:21:03.395]                   name <- removed[[kk]]
[16:21:03.395]                   NAME <- NAMES[[kk]]
[16:21:03.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.395]                     next
[16:21:03.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.395]                 }
[16:21:03.395]                 if (length(args) > 0) 
[16:21:03.395]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.395]             }
[16:21:03.395]             else {
[16:21:03.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.395]             }
[16:21:03.395]             {
[16:21:03.395]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.395]                   0L) {
[16:21:03.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.395]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.395]                   base::options(opts)
[16:21:03.395]                 }
[16:21:03.395]                 {
[16:21:03.395]                   {
[16:21:03.395]                     NULL
[16:21:03.395]                     RNGkind("Mersenne-Twister")
[16:21:03.395]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.395]                       inherits = FALSE)
[16:21:03.395]                   }
[16:21:03.395]                   options(future.plan = NULL)
[16:21:03.395]                   if (is.na(NA_character_)) 
[16:21:03.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.395]                     .init = FALSE)
[16:21:03.395]                 }
[16:21:03.395]             }
[16:21:03.395]         }
[16:21:03.395]     })
[16:21:03.395]     if (TRUE) {
[16:21:03.395]         base::sink(type = "output", split = FALSE)
[16:21:03.395]         if (TRUE) {
[16:21:03.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.395]         }
[16:21:03.395]         else {
[16:21:03.395]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.395]         }
[16:21:03.395]         base::close(...future.stdout)
[16:21:03.395]         ...future.stdout <- NULL
[16:21:03.395]     }
[16:21:03.395]     ...future.result$conditions <- ...future.conditions
[16:21:03.395]     ...future.result$finished <- base::Sys.time()
[16:21:03.395]     ...future.result
[16:21:03.395] }
[16:21:03.397] assign_globals() ...
[16:21:03.397] List of 1
[16:21:03.397]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x562226f3b340> 
[16:21:03.397]  - attr(*, "where")=List of 1
[16:21:03.397]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.397]  - attr(*, "resolved")= logi TRUE
[16:21:03.397]  - attr(*, "total_size")= num 10592
[16:21:03.397]  - attr(*, "already-done")= logi TRUE
[16:21:03.400] - copied ‘a’ to environment
[16:21:03.400] assign_globals() ... done
[16:21:03.400] plan(): Setting new future strategy stack:
[16:21:03.400] List of future strategies:
[16:21:03.400] 1. sequential:
[16:21:03.400]    - args: function (..., envir = parent.frame())
[16:21:03.400]    - tweaked: FALSE
[16:21:03.400]    - call: NULL
[16:21:03.401] plan(): nbrOfWorkers() = 1
[16:21:03.401] plan(): Setting new future strategy stack:
[16:21:03.402] List of future strategies:
[16:21:03.402] 1. sequential:
[16:21:03.402]    - args: function (..., envir = parent.frame())
[16:21:03.402]    - tweaked: FALSE
[16:21:03.402]    - call: plan(strategy)
[16:21:03.402] plan(): nbrOfWorkers() = 1
[16:21:03.402] SequentialFuture started (and completed)
[16:21:03.402] - Launch lazy future ... done
[16:21:03.402] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.403] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.403] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.405] - globals found: [2] ‘{’, ‘pkg’
[16:21:03.406] Searching for globals ... DONE
[16:21:03.406] Resolving globals: TRUE
[16:21:03.406] Resolving any globals that are futures ...
[16:21:03.406] - globals: [2] ‘{’, ‘pkg’
[16:21:03.406] Resolving any globals that are futures ... DONE
[16:21:03.406] Resolving futures part of globals (recursively) ...
[16:21:03.407] resolve() on list ...
[16:21:03.407]  recursive: 99
[16:21:03.407]  length: 1
[16:21:03.407]  elements: ‘pkg’
[16:21:03.407]  length: 0 (resolved future 1)
[16:21:03.407] resolve() on list ... DONE
[16:21:03.407] - globals: [1] ‘pkg’
[16:21:03.407] Resolving futures part of globals (recursively) ... DONE
[16:21:03.407] The total size of the 1 globals is 112 bytes (112 bytes)
[16:21:03.408] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:21:03.408] - globals: [1] ‘pkg’
[16:21:03.408] 
[16:21:03.408] getGlobalsAndPackages() ... DONE
[16:21:03.408] Packages needed by the future expression (n = 0): <none>
[16:21:03.408] Packages needed by future strategies (n = 0): <none>
[16:21:03.409] {
[16:21:03.409]     {
[16:21:03.409]         {
[16:21:03.409]             ...future.startTime <- base::Sys.time()
[16:21:03.409]             {
[16:21:03.409]                 {
[16:21:03.409]                   {
[16:21:03.409]                     base::local({
[16:21:03.409]                       has_future <- base::requireNamespace("future", 
[16:21:03.409]                         quietly = TRUE)
[16:21:03.409]                       if (has_future) {
[16:21:03.409]                         ns <- base::getNamespace("future")
[16:21:03.409]                         version <- ns[[".package"]][["version"]]
[16:21:03.409]                         if (is.null(version)) 
[16:21:03.409]                           version <- utils::packageVersion("future")
[16:21:03.409]                       }
[16:21:03.409]                       else {
[16:21:03.409]                         version <- NULL
[16:21:03.409]                       }
[16:21:03.409]                       if (!has_future || version < "1.8.0") {
[16:21:03.409]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.409]                           "", base::R.version$version.string), 
[16:21:03.409]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.409]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.409]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.409]                             "release", "version")], collapse = " "), 
[16:21:03.409]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.409]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.409]                           info)
[16:21:03.409]                         info <- base::paste(info, collapse = "; ")
[16:21:03.409]                         if (!has_future) {
[16:21:03.409]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.409]                             info)
[16:21:03.409]                         }
[16:21:03.409]                         else {
[16:21:03.409]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.409]                             info, version)
[16:21:03.409]                         }
[16:21:03.409]                         base::stop(msg)
[16:21:03.409]                       }
[16:21:03.409]                     })
[16:21:03.409]                   }
[16:21:03.409]                   ...future.strategy.old <- future::plan("list")
[16:21:03.409]                   options(future.plan = NULL)
[16:21:03.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.409]                 }
[16:21:03.409]                 ...future.workdir <- getwd()
[16:21:03.409]             }
[16:21:03.409]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.409]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.409]         }
[16:21:03.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.409]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.409]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.409]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.409]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.409]             base::names(...future.oldOptions))
[16:21:03.409]     }
[16:21:03.409]     if (FALSE) {
[16:21:03.409]     }
[16:21:03.409]     else {
[16:21:03.409]         if (TRUE) {
[16:21:03.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.409]                 open = "w")
[16:21:03.409]         }
[16:21:03.409]         else {
[16:21:03.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.409]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.409]         }
[16:21:03.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.409]             base::sink(type = "output", split = FALSE)
[16:21:03.409]             base::close(...future.stdout)
[16:21:03.409]         }, add = TRUE)
[16:21:03.409]     }
[16:21:03.409]     ...future.frame <- base::sys.nframe()
[16:21:03.409]     ...future.conditions <- base::list()
[16:21:03.409]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.409]     if (FALSE) {
[16:21:03.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.409]     }
[16:21:03.409]     ...future.result <- base::tryCatch({
[16:21:03.409]         base::withCallingHandlers({
[16:21:03.409]             ...future.value <- base::withVisible(base::local({
[16:21:03.409]                 pkg
[16:21:03.409]             }))
[16:21:03.409]             future::FutureResult(value = ...future.value$value, 
[16:21:03.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.409]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.409]                     ...future.globalenv.names))
[16:21:03.409]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.409]         }, condition = base::local({
[16:21:03.409]             c <- base::c
[16:21:03.409]             inherits <- base::inherits
[16:21:03.409]             invokeRestart <- base::invokeRestart
[16:21:03.409]             length <- base::length
[16:21:03.409]             list <- base::list
[16:21:03.409]             seq.int <- base::seq.int
[16:21:03.409]             signalCondition <- base::signalCondition
[16:21:03.409]             sys.calls <- base::sys.calls
[16:21:03.409]             `[[` <- base::`[[`
[16:21:03.409]             `+` <- base::`+`
[16:21:03.409]             `<<-` <- base::`<<-`
[16:21:03.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.409]                   3L)]
[16:21:03.409]             }
[16:21:03.409]             function(cond) {
[16:21:03.409]                 is_error <- inherits(cond, "error")
[16:21:03.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.409]                   NULL)
[16:21:03.409]                 if (is_error) {
[16:21:03.409]                   sessionInformation <- function() {
[16:21:03.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.409]                       search = base::search(), system = base::Sys.info())
[16:21:03.409]                   }
[16:21:03.409]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.409]                     cond$call), session = sessionInformation(), 
[16:21:03.409]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.409]                   signalCondition(cond)
[16:21:03.409]                 }
[16:21:03.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.409]                 "immediateCondition"))) {
[16:21:03.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.409]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.409]                   if (TRUE && !signal) {
[16:21:03.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.409]                     {
[16:21:03.409]                       inherits <- base::inherits
[16:21:03.409]                       invokeRestart <- base::invokeRestart
[16:21:03.409]                       is.null <- base::is.null
[16:21:03.409]                       muffled <- FALSE
[16:21:03.409]                       if (inherits(cond, "message")) {
[16:21:03.409]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.409]                         if (muffled) 
[16:21:03.409]                           invokeRestart("muffleMessage")
[16:21:03.409]                       }
[16:21:03.409]                       else if (inherits(cond, "warning")) {
[16:21:03.409]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.409]                         if (muffled) 
[16:21:03.409]                           invokeRestart("muffleWarning")
[16:21:03.409]                       }
[16:21:03.409]                       else if (inherits(cond, "condition")) {
[16:21:03.409]                         if (!is.null(pattern)) {
[16:21:03.409]                           computeRestarts <- base::computeRestarts
[16:21:03.409]                           grepl <- base::grepl
[16:21:03.409]                           restarts <- computeRestarts(cond)
[16:21:03.409]                           for (restart in restarts) {
[16:21:03.409]                             name <- restart$name
[16:21:03.409]                             if (is.null(name)) 
[16:21:03.409]                               next
[16:21:03.409]                             if (!grepl(pattern, name)) 
[16:21:03.409]                               next
[16:21:03.409]                             invokeRestart(restart)
[16:21:03.409]                             muffled <- TRUE
[16:21:03.409]                             break
[16:21:03.409]                           }
[16:21:03.409]                         }
[16:21:03.409]                       }
[16:21:03.409]                       invisible(muffled)
[16:21:03.409]                     }
[16:21:03.409]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.409]                   }
[16:21:03.409]                 }
[16:21:03.409]                 else {
[16:21:03.409]                   if (TRUE) {
[16:21:03.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.409]                     {
[16:21:03.409]                       inherits <- base::inherits
[16:21:03.409]                       invokeRestart <- base::invokeRestart
[16:21:03.409]                       is.null <- base::is.null
[16:21:03.409]                       muffled <- FALSE
[16:21:03.409]                       if (inherits(cond, "message")) {
[16:21:03.409]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.409]                         if (muffled) 
[16:21:03.409]                           invokeRestart("muffleMessage")
[16:21:03.409]                       }
[16:21:03.409]                       else if (inherits(cond, "warning")) {
[16:21:03.409]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.409]                         if (muffled) 
[16:21:03.409]                           invokeRestart("muffleWarning")
[16:21:03.409]                       }
[16:21:03.409]                       else if (inherits(cond, "condition")) {
[16:21:03.409]                         if (!is.null(pattern)) {
[16:21:03.409]                           computeRestarts <- base::computeRestarts
[16:21:03.409]                           grepl <- base::grepl
[16:21:03.409]                           restarts <- computeRestarts(cond)
[16:21:03.409]                           for (restart in restarts) {
[16:21:03.409]                             name <- restart$name
[16:21:03.409]                             if (is.null(name)) 
[16:21:03.409]                               next
[16:21:03.409]                             if (!grepl(pattern, name)) 
[16:21:03.409]                               next
[16:21:03.409]                             invokeRestart(restart)
[16:21:03.409]                             muffled <- TRUE
[16:21:03.409]                             break
[16:21:03.409]                           }
[16:21:03.409]                         }
[16:21:03.409]                       }
[16:21:03.409]                       invisible(muffled)
[16:21:03.409]                     }
[16:21:03.409]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.409]                   }
[16:21:03.409]                 }
[16:21:03.409]             }
[16:21:03.409]         }))
[16:21:03.409]     }, error = function(ex) {
[16:21:03.409]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.409]                 ...future.rng), started = ...future.startTime, 
[16:21:03.409]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.409]             version = "1.8"), class = "FutureResult")
[16:21:03.409]     }, finally = {
[16:21:03.409]         if (!identical(...future.workdir, getwd())) 
[16:21:03.409]             setwd(...future.workdir)
[16:21:03.409]         {
[16:21:03.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.409]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.409]             }
[16:21:03.409]             base::options(...future.oldOptions)
[16:21:03.409]             if (.Platform$OS.type == "windows") {
[16:21:03.409]                 old_names <- names(...future.oldEnvVars)
[16:21:03.409]                 envs <- base::Sys.getenv()
[16:21:03.409]                 names <- names(envs)
[16:21:03.409]                 common <- intersect(names, old_names)
[16:21:03.409]                 added <- setdiff(names, old_names)
[16:21:03.409]                 removed <- setdiff(old_names, names)
[16:21:03.409]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.409]                   envs[common]]
[16:21:03.409]                 NAMES <- toupper(changed)
[16:21:03.409]                 args <- list()
[16:21:03.409]                 for (kk in seq_along(NAMES)) {
[16:21:03.409]                   name <- changed[[kk]]
[16:21:03.409]                   NAME <- NAMES[[kk]]
[16:21:03.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.409]                     next
[16:21:03.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.409]                 }
[16:21:03.409]                 NAMES <- toupper(added)
[16:21:03.409]                 for (kk in seq_along(NAMES)) {
[16:21:03.409]                   name <- added[[kk]]
[16:21:03.409]                   NAME <- NAMES[[kk]]
[16:21:03.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.409]                     next
[16:21:03.409]                   args[[name]] <- ""
[16:21:03.409]                 }
[16:21:03.409]                 NAMES <- toupper(removed)
[16:21:03.409]                 for (kk in seq_along(NAMES)) {
[16:21:03.409]                   name <- removed[[kk]]
[16:21:03.409]                   NAME <- NAMES[[kk]]
[16:21:03.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.409]                     next
[16:21:03.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.409]                 }
[16:21:03.409]                 if (length(args) > 0) 
[16:21:03.409]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.409]             }
[16:21:03.409]             else {
[16:21:03.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.409]             }
[16:21:03.409]             {
[16:21:03.409]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.409]                   0L) {
[16:21:03.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.409]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.409]                   base::options(opts)
[16:21:03.409]                 }
[16:21:03.409]                 {
[16:21:03.409]                   {
[16:21:03.409]                     NULL
[16:21:03.409]                     RNGkind("Mersenne-Twister")
[16:21:03.409]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.409]                       inherits = FALSE)
[16:21:03.409]                   }
[16:21:03.409]                   options(future.plan = NULL)
[16:21:03.409]                   if (is.na(NA_character_)) 
[16:21:03.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.409]                     .init = FALSE)
[16:21:03.409]                 }
[16:21:03.409]             }
[16:21:03.409]         }
[16:21:03.409]     })
[16:21:03.409]     if (TRUE) {
[16:21:03.409]         base::sink(type = "output", split = FALSE)
[16:21:03.409]         if (TRUE) {
[16:21:03.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.409]         }
[16:21:03.409]         else {
[16:21:03.409]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.409]         }
[16:21:03.409]         base::close(...future.stdout)
[16:21:03.409]         ...future.stdout <- NULL
[16:21:03.409]     }
[16:21:03.409]     ...future.result$conditions <- ...future.conditions
[16:21:03.409]     ...future.result$finished <- base::Sys.time()
[16:21:03.409]     ...future.result
[16:21:03.409] }
[16:21:03.410] assign_globals() ...
[16:21:03.411] List of 1
[16:21:03.411]  $ pkg: chr "foo"
[16:21:03.411]  - attr(*, "where")=List of 1
[16:21:03.411]   ..$ pkg:<environment: R_EmptyEnv> 
[16:21:03.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.411]  - attr(*, "resolved")= logi TRUE
[16:21:03.411]  - attr(*, "total_size")= num 112
[16:21:03.413] - copied ‘pkg’ to environment
[16:21:03.413] assign_globals() ... done
[16:21:03.413] plan(): Setting new future strategy stack:
[16:21:03.413] List of future strategies:
[16:21:03.413] 1. sequential:
[16:21:03.413]    - args: function (..., envir = parent.frame())
[16:21:03.413]    - tweaked: FALSE
[16:21:03.413]    - call: NULL
[16:21:03.413] plan(): nbrOfWorkers() = 1
[16:21:03.414] plan(): Setting new future strategy stack:
[16:21:03.414] List of future strategies:
[16:21:03.414] 1. sequential:
[16:21:03.414]    - args: function (..., envir = parent.frame())
[16:21:03.414]    - tweaked: FALSE
[16:21:03.414]    - call: plan(strategy)
[16:21:03.415] plan(): nbrOfWorkers() = 1
[16:21:03.415] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.416] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.416] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.418] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:03.418] Searching for globals ... DONE
[16:21:03.418] Resolving globals: TRUE
[16:21:03.418] Resolving any globals that are futures ...
[16:21:03.418] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:03.419] Resolving any globals that are futures ... DONE
[16:21:03.419] Resolving futures part of globals (recursively) ...
[16:21:03.419] resolve() on list ...
[16:21:03.419]  recursive: 99
[16:21:03.419]  length: 1
[16:21:03.419]  elements: ‘a’
[16:21:03.420]  length: 0 (resolved future 1)
[16:21:03.420] resolve() on list ... DONE
[16:21:03.420] - globals: [1] ‘a’
[16:21:03.420] Resolving futures part of globals (recursively) ... DONE
[16:21:03.420] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.420] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:21:03.420] - globals: [1] ‘a’
[16:21:03.421] 
[16:21:03.421] getGlobalsAndPackages() ... DONE
[16:21:03.421] run() for ‘Future’ ...
[16:21:03.421] - state: ‘created’
[16:21:03.421] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.421] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.422] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.422]   - Field: ‘label’
[16:21:03.422]   - Field: ‘local’
[16:21:03.422]   - Field: ‘owner’
[16:21:03.422]   - Field: ‘envir’
[16:21:03.422]   - Field: ‘packages’
[16:21:03.422]   - Field: ‘gc’
[16:21:03.422]   - Field: ‘conditions’
[16:21:03.422]   - Field: ‘expr’
[16:21:03.422]   - Field: ‘uuid’
[16:21:03.422]   - Field: ‘seed’
[16:21:03.423]   - Field: ‘version’
[16:21:03.423]   - Field: ‘result’
[16:21:03.423]   - Field: ‘asynchronous’
[16:21:03.423]   - Field: ‘calls’
[16:21:03.423]   - Field: ‘globals’
[16:21:03.423]   - Field: ‘stdout’
[16:21:03.423]   - Field: ‘earlySignal’
[16:21:03.423]   - Field: ‘lazy’
[16:21:03.423]   - Field: ‘state’
[16:21:03.423] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.424] - Launch lazy future ...
[16:21:03.424] Packages needed by the future expression (n = 0): <none>
[16:21:03.424] Packages needed by future strategies (n = 0): <none>
[16:21:03.424] {
[16:21:03.424]     {
[16:21:03.424]         {
[16:21:03.424]             ...future.startTime <- base::Sys.time()
[16:21:03.424]             {
[16:21:03.424]                 {
[16:21:03.424]                   {
[16:21:03.424]                     base::local({
[16:21:03.424]                       has_future <- base::requireNamespace("future", 
[16:21:03.424]                         quietly = TRUE)
[16:21:03.424]                       if (has_future) {
[16:21:03.424]                         ns <- base::getNamespace("future")
[16:21:03.424]                         version <- ns[[".package"]][["version"]]
[16:21:03.424]                         if (is.null(version)) 
[16:21:03.424]                           version <- utils::packageVersion("future")
[16:21:03.424]                       }
[16:21:03.424]                       else {
[16:21:03.424]                         version <- NULL
[16:21:03.424]                       }
[16:21:03.424]                       if (!has_future || version < "1.8.0") {
[16:21:03.424]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.424]                           "", base::R.version$version.string), 
[16:21:03.424]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.424]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.424]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.424]                             "release", "version")], collapse = " "), 
[16:21:03.424]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.424]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.424]                           info)
[16:21:03.424]                         info <- base::paste(info, collapse = "; ")
[16:21:03.424]                         if (!has_future) {
[16:21:03.424]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.424]                             info)
[16:21:03.424]                         }
[16:21:03.424]                         else {
[16:21:03.424]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.424]                             info, version)
[16:21:03.424]                         }
[16:21:03.424]                         base::stop(msg)
[16:21:03.424]                       }
[16:21:03.424]                     })
[16:21:03.424]                   }
[16:21:03.424]                   ...future.strategy.old <- future::plan("list")
[16:21:03.424]                   options(future.plan = NULL)
[16:21:03.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.424]                 }
[16:21:03.424]                 ...future.workdir <- getwd()
[16:21:03.424]             }
[16:21:03.424]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.424]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.424]         }
[16:21:03.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.424]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.424]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.424]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.424]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.424]             base::names(...future.oldOptions))
[16:21:03.424]     }
[16:21:03.424]     if (FALSE) {
[16:21:03.424]     }
[16:21:03.424]     else {
[16:21:03.424]         if (TRUE) {
[16:21:03.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.424]                 open = "w")
[16:21:03.424]         }
[16:21:03.424]         else {
[16:21:03.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.424]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.424]         }
[16:21:03.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.424]             base::sink(type = "output", split = FALSE)
[16:21:03.424]             base::close(...future.stdout)
[16:21:03.424]         }, add = TRUE)
[16:21:03.424]     }
[16:21:03.424]     ...future.frame <- base::sys.nframe()
[16:21:03.424]     ...future.conditions <- base::list()
[16:21:03.424]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.424]     if (FALSE) {
[16:21:03.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.424]     }
[16:21:03.424]     ...future.result <- base::tryCatch({
[16:21:03.424]         base::withCallingHandlers({
[16:21:03.424]             ...future.value <- base::withVisible(base::local({
[16:21:03.424]                 b <- a
[16:21:03.424]                 a <- 2
[16:21:03.424]                 a * b
[16:21:03.424]             }))
[16:21:03.424]             future::FutureResult(value = ...future.value$value, 
[16:21:03.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.424]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.424]                     ...future.globalenv.names))
[16:21:03.424]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.424]         }, condition = base::local({
[16:21:03.424]             c <- base::c
[16:21:03.424]             inherits <- base::inherits
[16:21:03.424]             invokeRestart <- base::invokeRestart
[16:21:03.424]             length <- base::length
[16:21:03.424]             list <- base::list
[16:21:03.424]             seq.int <- base::seq.int
[16:21:03.424]             signalCondition <- base::signalCondition
[16:21:03.424]             sys.calls <- base::sys.calls
[16:21:03.424]             `[[` <- base::`[[`
[16:21:03.424]             `+` <- base::`+`
[16:21:03.424]             `<<-` <- base::`<<-`
[16:21:03.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.424]                   3L)]
[16:21:03.424]             }
[16:21:03.424]             function(cond) {
[16:21:03.424]                 is_error <- inherits(cond, "error")
[16:21:03.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.424]                   NULL)
[16:21:03.424]                 if (is_error) {
[16:21:03.424]                   sessionInformation <- function() {
[16:21:03.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.424]                       search = base::search(), system = base::Sys.info())
[16:21:03.424]                   }
[16:21:03.424]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.424]                     cond$call), session = sessionInformation(), 
[16:21:03.424]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.424]                   signalCondition(cond)
[16:21:03.424]                 }
[16:21:03.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.424]                 "immediateCondition"))) {
[16:21:03.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.424]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.424]                   if (TRUE && !signal) {
[16:21:03.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.424]                     {
[16:21:03.424]                       inherits <- base::inherits
[16:21:03.424]                       invokeRestart <- base::invokeRestart
[16:21:03.424]                       is.null <- base::is.null
[16:21:03.424]                       muffled <- FALSE
[16:21:03.424]                       if (inherits(cond, "message")) {
[16:21:03.424]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.424]                         if (muffled) 
[16:21:03.424]                           invokeRestart("muffleMessage")
[16:21:03.424]                       }
[16:21:03.424]                       else if (inherits(cond, "warning")) {
[16:21:03.424]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.424]                         if (muffled) 
[16:21:03.424]                           invokeRestart("muffleWarning")
[16:21:03.424]                       }
[16:21:03.424]                       else if (inherits(cond, "condition")) {
[16:21:03.424]                         if (!is.null(pattern)) {
[16:21:03.424]                           computeRestarts <- base::computeRestarts
[16:21:03.424]                           grepl <- base::grepl
[16:21:03.424]                           restarts <- computeRestarts(cond)
[16:21:03.424]                           for (restart in restarts) {
[16:21:03.424]                             name <- restart$name
[16:21:03.424]                             if (is.null(name)) 
[16:21:03.424]                               next
[16:21:03.424]                             if (!grepl(pattern, name)) 
[16:21:03.424]                               next
[16:21:03.424]                             invokeRestart(restart)
[16:21:03.424]                             muffled <- TRUE
[16:21:03.424]                             break
[16:21:03.424]                           }
[16:21:03.424]                         }
[16:21:03.424]                       }
[16:21:03.424]                       invisible(muffled)
[16:21:03.424]                     }
[16:21:03.424]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.424]                   }
[16:21:03.424]                 }
[16:21:03.424]                 else {
[16:21:03.424]                   if (TRUE) {
[16:21:03.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.424]                     {
[16:21:03.424]                       inherits <- base::inherits
[16:21:03.424]                       invokeRestart <- base::invokeRestart
[16:21:03.424]                       is.null <- base::is.null
[16:21:03.424]                       muffled <- FALSE
[16:21:03.424]                       if (inherits(cond, "message")) {
[16:21:03.424]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.424]                         if (muffled) 
[16:21:03.424]                           invokeRestart("muffleMessage")
[16:21:03.424]                       }
[16:21:03.424]                       else if (inherits(cond, "warning")) {
[16:21:03.424]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.424]                         if (muffled) 
[16:21:03.424]                           invokeRestart("muffleWarning")
[16:21:03.424]                       }
[16:21:03.424]                       else if (inherits(cond, "condition")) {
[16:21:03.424]                         if (!is.null(pattern)) {
[16:21:03.424]                           computeRestarts <- base::computeRestarts
[16:21:03.424]                           grepl <- base::grepl
[16:21:03.424]                           restarts <- computeRestarts(cond)
[16:21:03.424]                           for (restart in restarts) {
[16:21:03.424]                             name <- restart$name
[16:21:03.424]                             if (is.null(name)) 
[16:21:03.424]                               next
[16:21:03.424]                             if (!grepl(pattern, name)) 
[16:21:03.424]                               next
[16:21:03.424]                             invokeRestart(restart)
[16:21:03.424]                             muffled <- TRUE
[16:21:03.424]                             break
[16:21:03.424]                           }
[16:21:03.424]                         }
[16:21:03.424]                       }
[16:21:03.424]                       invisible(muffled)
[16:21:03.424]                     }
[16:21:03.424]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.424]                   }
[16:21:03.424]                 }
[16:21:03.424]             }
[16:21:03.424]         }))
[16:21:03.424]     }, error = function(ex) {
[16:21:03.424]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.424]                 ...future.rng), started = ...future.startTime, 
[16:21:03.424]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.424]             version = "1.8"), class = "FutureResult")
[16:21:03.424]     }, finally = {
[16:21:03.424]         if (!identical(...future.workdir, getwd())) 
[16:21:03.424]             setwd(...future.workdir)
[16:21:03.424]         {
[16:21:03.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.424]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.424]             }
[16:21:03.424]             base::options(...future.oldOptions)
[16:21:03.424]             if (.Platform$OS.type == "windows") {
[16:21:03.424]                 old_names <- names(...future.oldEnvVars)
[16:21:03.424]                 envs <- base::Sys.getenv()
[16:21:03.424]                 names <- names(envs)
[16:21:03.424]                 common <- intersect(names, old_names)
[16:21:03.424]                 added <- setdiff(names, old_names)
[16:21:03.424]                 removed <- setdiff(old_names, names)
[16:21:03.424]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.424]                   envs[common]]
[16:21:03.424]                 NAMES <- toupper(changed)
[16:21:03.424]                 args <- list()
[16:21:03.424]                 for (kk in seq_along(NAMES)) {
[16:21:03.424]                   name <- changed[[kk]]
[16:21:03.424]                   NAME <- NAMES[[kk]]
[16:21:03.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.424]                     next
[16:21:03.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.424]                 }
[16:21:03.424]                 NAMES <- toupper(added)
[16:21:03.424]                 for (kk in seq_along(NAMES)) {
[16:21:03.424]                   name <- added[[kk]]
[16:21:03.424]                   NAME <- NAMES[[kk]]
[16:21:03.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.424]                     next
[16:21:03.424]                   args[[name]] <- ""
[16:21:03.424]                 }
[16:21:03.424]                 NAMES <- toupper(removed)
[16:21:03.424]                 for (kk in seq_along(NAMES)) {
[16:21:03.424]                   name <- removed[[kk]]
[16:21:03.424]                   NAME <- NAMES[[kk]]
[16:21:03.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.424]                     next
[16:21:03.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.424]                 }
[16:21:03.424]                 if (length(args) > 0) 
[16:21:03.424]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.424]             }
[16:21:03.424]             else {
[16:21:03.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.424]             }
[16:21:03.424]             {
[16:21:03.424]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.424]                   0L) {
[16:21:03.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.424]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.424]                   base::options(opts)
[16:21:03.424]                 }
[16:21:03.424]                 {
[16:21:03.424]                   {
[16:21:03.424]                     NULL
[16:21:03.424]                     RNGkind("Mersenne-Twister")
[16:21:03.424]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.424]                       inherits = FALSE)
[16:21:03.424]                   }
[16:21:03.424]                   options(future.plan = NULL)
[16:21:03.424]                   if (is.na(NA_character_)) 
[16:21:03.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.424]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.424]                     .init = FALSE)
[16:21:03.424]                 }
[16:21:03.424]             }
[16:21:03.424]         }
[16:21:03.424]     })
[16:21:03.424]     if (TRUE) {
[16:21:03.424]         base::sink(type = "output", split = FALSE)
[16:21:03.424]         if (TRUE) {
[16:21:03.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.424]         }
[16:21:03.424]         else {
[16:21:03.424]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.424]         }
[16:21:03.424]         base::close(...future.stdout)
[16:21:03.424]         ...future.stdout <- NULL
[16:21:03.424]     }
[16:21:03.424]     ...future.result$conditions <- ...future.conditions
[16:21:03.424]     ...future.result$finished <- base::Sys.time()
[16:21:03.424]     ...future.result
[16:21:03.424] }
[16:21:03.426] assign_globals() ...
[16:21:03.426] List of 1
[16:21:03.426]  $ a: num 3
[16:21:03.426]  - attr(*, "where")=List of 1
[16:21:03.426]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.426]  - attr(*, "resolved")= logi TRUE
[16:21:03.426]  - attr(*, "total_size")= num 56
[16:21:03.426]  - attr(*, "already-done")= logi TRUE
[16:21:03.428] - copied ‘a’ to environment
[16:21:03.428] assign_globals() ... done
[16:21:03.429] plan(): Setting new future strategy stack:
[16:21:03.429] List of future strategies:
[16:21:03.429] 1. sequential:
[16:21:03.429]    - args: function (..., envir = parent.frame())
[16:21:03.429]    - tweaked: FALSE
[16:21:03.429]    - call: NULL
[16:21:03.429] plan(): nbrOfWorkers() = 1
[16:21:03.430] plan(): Setting new future strategy stack:
[16:21:03.430] List of future strategies:
[16:21:03.430] 1. sequential:
[16:21:03.430]    - args: function (..., envir = parent.frame())
[16:21:03.430]    - tweaked: FALSE
[16:21:03.430]    - call: plan(strategy)
[16:21:03.430] plan(): nbrOfWorkers() = 1
[16:21:03.431] SequentialFuture started (and completed)
[16:21:03.431] - Launch lazy future ... done
[16:21:03.431] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.433] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.433] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.435] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:03.435] Searching for globals ... DONE
[16:21:03.435] Resolving globals: TRUE
[16:21:03.435] Resolving any globals that are futures ...
[16:21:03.436] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:03.436] Resolving any globals that are futures ... DONE
[16:21:03.436] Resolving futures part of globals (recursively) ...
[16:21:03.436] resolve() on list ...
[16:21:03.436]  recursive: 99
[16:21:03.436]  length: 1
[16:21:03.437]  elements: ‘a’
[16:21:03.437]  length: 0 (resolved future 1)
[16:21:03.437] resolve() on list ... DONE
[16:21:03.437] - globals: [1] ‘a’
[16:21:03.437] Resolving futures part of globals (recursively) ... DONE
[16:21:03.437] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.437] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:21:03.438] - globals: [1] ‘a’
[16:21:03.438] 
[16:21:03.438] getGlobalsAndPackages() ... DONE
[16:21:03.438] run() for ‘Future’ ...
[16:21:03.438] - state: ‘created’
[16:21:03.438] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.439] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.439]   - Field: ‘label’
[16:21:03.439]   - Field: ‘local’
[16:21:03.439]   - Field: ‘owner’
[16:21:03.439]   - Field: ‘envir’
[16:21:03.439]   - Field: ‘packages’
[16:21:03.439]   - Field: ‘gc’
[16:21:03.439]   - Field: ‘conditions’
[16:21:03.439]   - Field: ‘expr’
[16:21:03.440]   - Field: ‘uuid’
[16:21:03.440]   - Field: ‘seed’
[16:21:03.440]   - Field: ‘version’
[16:21:03.440]   - Field: ‘result’
[16:21:03.440]   - Field: ‘asynchronous’
[16:21:03.440]   - Field: ‘calls’
[16:21:03.440]   - Field: ‘globals’
[16:21:03.440]   - Field: ‘stdout’
[16:21:03.440]   - Field: ‘earlySignal’
[16:21:03.440]   - Field: ‘lazy’
[16:21:03.441]   - Field: ‘state’
[16:21:03.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.441] - Launch lazy future ...
[16:21:03.441] Packages needed by the future expression (n = 0): <none>
[16:21:03.441] Packages needed by future strategies (n = 0): <none>
[16:21:03.441] {
[16:21:03.441]     {
[16:21:03.441]         {
[16:21:03.441]             ...future.startTime <- base::Sys.time()
[16:21:03.441]             {
[16:21:03.441]                 {
[16:21:03.441]                   {
[16:21:03.441]                     base::local({
[16:21:03.441]                       has_future <- base::requireNamespace("future", 
[16:21:03.441]                         quietly = TRUE)
[16:21:03.441]                       if (has_future) {
[16:21:03.441]                         ns <- base::getNamespace("future")
[16:21:03.441]                         version <- ns[[".package"]][["version"]]
[16:21:03.441]                         if (is.null(version)) 
[16:21:03.441]                           version <- utils::packageVersion("future")
[16:21:03.441]                       }
[16:21:03.441]                       else {
[16:21:03.441]                         version <- NULL
[16:21:03.441]                       }
[16:21:03.441]                       if (!has_future || version < "1.8.0") {
[16:21:03.441]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.441]                           "", base::R.version$version.string), 
[16:21:03.441]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.441]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.441]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.441]                             "release", "version")], collapse = " "), 
[16:21:03.441]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.441]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.441]                           info)
[16:21:03.441]                         info <- base::paste(info, collapse = "; ")
[16:21:03.441]                         if (!has_future) {
[16:21:03.441]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.441]                             info)
[16:21:03.441]                         }
[16:21:03.441]                         else {
[16:21:03.441]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.441]                             info, version)
[16:21:03.441]                         }
[16:21:03.441]                         base::stop(msg)
[16:21:03.441]                       }
[16:21:03.441]                     })
[16:21:03.441]                   }
[16:21:03.441]                   ...future.strategy.old <- future::plan("list")
[16:21:03.441]                   options(future.plan = NULL)
[16:21:03.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.441]                 }
[16:21:03.441]                 ...future.workdir <- getwd()
[16:21:03.441]             }
[16:21:03.441]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.441]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.441]         }
[16:21:03.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.441]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.441]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.441]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.441]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.441]             base::names(...future.oldOptions))
[16:21:03.441]     }
[16:21:03.441]     if (FALSE) {
[16:21:03.441]     }
[16:21:03.441]     else {
[16:21:03.441]         if (TRUE) {
[16:21:03.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.441]                 open = "w")
[16:21:03.441]         }
[16:21:03.441]         else {
[16:21:03.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.441]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.441]         }
[16:21:03.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.441]             base::sink(type = "output", split = FALSE)
[16:21:03.441]             base::close(...future.stdout)
[16:21:03.441]         }, add = TRUE)
[16:21:03.441]     }
[16:21:03.441]     ...future.frame <- base::sys.nframe()
[16:21:03.441]     ...future.conditions <- base::list()
[16:21:03.441]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.441]     if (FALSE) {
[16:21:03.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.441]     }
[16:21:03.441]     ...future.result <- base::tryCatch({
[16:21:03.441]         base::withCallingHandlers({
[16:21:03.441]             ...future.value <- base::withVisible(base::local({
[16:21:03.441]                 b <- a
[16:21:03.441]                 a <- 2
[16:21:03.441]                 a * b
[16:21:03.441]             }))
[16:21:03.441]             future::FutureResult(value = ...future.value$value, 
[16:21:03.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.441]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.441]                     ...future.globalenv.names))
[16:21:03.441]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.441]         }, condition = base::local({
[16:21:03.441]             c <- base::c
[16:21:03.441]             inherits <- base::inherits
[16:21:03.441]             invokeRestart <- base::invokeRestart
[16:21:03.441]             length <- base::length
[16:21:03.441]             list <- base::list
[16:21:03.441]             seq.int <- base::seq.int
[16:21:03.441]             signalCondition <- base::signalCondition
[16:21:03.441]             sys.calls <- base::sys.calls
[16:21:03.441]             `[[` <- base::`[[`
[16:21:03.441]             `+` <- base::`+`
[16:21:03.441]             `<<-` <- base::`<<-`
[16:21:03.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.441]                   3L)]
[16:21:03.441]             }
[16:21:03.441]             function(cond) {
[16:21:03.441]                 is_error <- inherits(cond, "error")
[16:21:03.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.441]                   NULL)
[16:21:03.441]                 if (is_error) {
[16:21:03.441]                   sessionInformation <- function() {
[16:21:03.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.441]                       search = base::search(), system = base::Sys.info())
[16:21:03.441]                   }
[16:21:03.441]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.441]                     cond$call), session = sessionInformation(), 
[16:21:03.441]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.441]                   signalCondition(cond)
[16:21:03.441]                 }
[16:21:03.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.441]                 "immediateCondition"))) {
[16:21:03.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.441]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.441]                   if (TRUE && !signal) {
[16:21:03.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.441]                     {
[16:21:03.441]                       inherits <- base::inherits
[16:21:03.441]                       invokeRestart <- base::invokeRestart
[16:21:03.441]                       is.null <- base::is.null
[16:21:03.441]                       muffled <- FALSE
[16:21:03.441]                       if (inherits(cond, "message")) {
[16:21:03.441]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.441]                         if (muffled) 
[16:21:03.441]                           invokeRestart("muffleMessage")
[16:21:03.441]                       }
[16:21:03.441]                       else if (inherits(cond, "warning")) {
[16:21:03.441]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.441]                         if (muffled) 
[16:21:03.441]                           invokeRestart("muffleWarning")
[16:21:03.441]                       }
[16:21:03.441]                       else if (inherits(cond, "condition")) {
[16:21:03.441]                         if (!is.null(pattern)) {
[16:21:03.441]                           computeRestarts <- base::computeRestarts
[16:21:03.441]                           grepl <- base::grepl
[16:21:03.441]                           restarts <- computeRestarts(cond)
[16:21:03.441]                           for (restart in restarts) {
[16:21:03.441]                             name <- restart$name
[16:21:03.441]                             if (is.null(name)) 
[16:21:03.441]                               next
[16:21:03.441]                             if (!grepl(pattern, name)) 
[16:21:03.441]                               next
[16:21:03.441]                             invokeRestart(restart)
[16:21:03.441]                             muffled <- TRUE
[16:21:03.441]                             break
[16:21:03.441]                           }
[16:21:03.441]                         }
[16:21:03.441]                       }
[16:21:03.441]                       invisible(muffled)
[16:21:03.441]                     }
[16:21:03.441]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.441]                   }
[16:21:03.441]                 }
[16:21:03.441]                 else {
[16:21:03.441]                   if (TRUE) {
[16:21:03.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.441]                     {
[16:21:03.441]                       inherits <- base::inherits
[16:21:03.441]                       invokeRestart <- base::invokeRestart
[16:21:03.441]                       is.null <- base::is.null
[16:21:03.441]                       muffled <- FALSE
[16:21:03.441]                       if (inherits(cond, "message")) {
[16:21:03.441]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.441]                         if (muffled) 
[16:21:03.441]                           invokeRestart("muffleMessage")
[16:21:03.441]                       }
[16:21:03.441]                       else if (inherits(cond, "warning")) {
[16:21:03.441]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.441]                         if (muffled) 
[16:21:03.441]                           invokeRestart("muffleWarning")
[16:21:03.441]                       }
[16:21:03.441]                       else if (inherits(cond, "condition")) {
[16:21:03.441]                         if (!is.null(pattern)) {
[16:21:03.441]                           computeRestarts <- base::computeRestarts
[16:21:03.441]                           grepl <- base::grepl
[16:21:03.441]                           restarts <- computeRestarts(cond)
[16:21:03.441]                           for (restart in restarts) {
[16:21:03.441]                             name <- restart$name
[16:21:03.441]                             if (is.null(name)) 
[16:21:03.441]                               next
[16:21:03.441]                             if (!grepl(pattern, name)) 
[16:21:03.441]                               next
[16:21:03.441]                             invokeRestart(restart)
[16:21:03.441]                             muffled <- TRUE
[16:21:03.441]                             break
[16:21:03.441]                           }
[16:21:03.441]                         }
[16:21:03.441]                       }
[16:21:03.441]                       invisible(muffled)
[16:21:03.441]                     }
[16:21:03.441]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.441]                   }
[16:21:03.441]                 }
[16:21:03.441]             }
[16:21:03.441]         }))
[16:21:03.441]     }, error = function(ex) {
[16:21:03.441]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.441]                 ...future.rng), started = ...future.startTime, 
[16:21:03.441]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.441]             version = "1.8"), class = "FutureResult")
[16:21:03.441]     }, finally = {
[16:21:03.441]         if (!identical(...future.workdir, getwd())) 
[16:21:03.441]             setwd(...future.workdir)
[16:21:03.441]         {
[16:21:03.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.441]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.441]             }
[16:21:03.441]             base::options(...future.oldOptions)
[16:21:03.441]             if (.Platform$OS.type == "windows") {
[16:21:03.441]                 old_names <- names(...future.oldEnvVars)
[16:21:03.441]                 envs <- base::Sys.getenv()
[16:21:03.441]                 names <- names(envs)
[16:21:03.441]                 common <- intersect(names, old_names)
[16:21:03.441]                 added <- setdiff(names, old_names)
[16:21:03.441]                 removed <- setdiff(old_names, names)
[16:21:03.441]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.441]                   envs[common]]
[16:21:03.441]                 NAMES <- toupper(changed)
[16:21:03.441]                 args <- list()
[16:21:03.441]                 for (kk in seq_along(NAMES)) {
[16:21:03.441]                   name <- changed[[kk]]
[16:21:03.441]                   NAME <- NAMES[[kk]]
[16:21:03.441]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.441]                     next
[16:21:03.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.441]                 }
[16:21:03.441]                 NAMES <- toupper(added)
[16:21:03.441]                 for (kk in seq_along(NAMES)) {
[16:21:03.441]                   name <- added[[kk]]
[16:21:03.441]                   NAME <- NAMES[[kk]]
[16:21:03.441]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.441]                     next
[16:21:03.441]                   args[[name]] <- ""
[16:21:03.441]                 }
[16:21:03.441]                 NAMES <- toupper(removed)
[16:21:03.441]                 for (kk in seq_along(NAMES)) {
[16:21:03.441]                   name <- removed[[kk]]
[16:21:03.441]                   NAME <- NAMES[[kk]]
[16:21:03.441]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.441]                     next
[16:21:03.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.441]                 }
[16:21:03.441]                 if (length(args) > 0) 
[16:21:03.441]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.441]             }
[16:21:03.441]             else {
[16:21:03.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.441]             }
[16:21:03.441]             {
[16:21:03.441]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.441]                   0L) {
[16:21:03.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.441]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.441]                   base::options(opts)
[16:21:03.441]                 }
[16:21:03.441]                 {
[16:21:03.441]                   {
[16:21:03.441]                     NULL
[16:21:03.441]                     RNGkind("Mersenne-Twister")
[16:21:03.441]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.441]                       inherits = FALSE)
[16:21:03.441]                   }
[16:21:03.441]                   options(future.plan = NULL)
[16:21:03.441]                   if (is.na(NA_character_)) 
[16:21:03.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.441]                     .init = FALSE)
[16:21:03.441]                 }
[16:21:03.441]             }
[16:21:03.441]         }
[16:21:03.441]     })
[16:21:03.441]     if (TRUE) {
[16:21:03.441]         base::sink(type = "output", split = FALSE)
[16:21:03.441]         if (TRUE) {
[16:21:03.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.441]         }
[16:21:03.441]         else {
[16:21:03.441]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.441]         }
[16:21:03.441]         base::close(...future.stdout)
[16:21:03.441]         ...future.stdout <- NULL
[16:21:03.441]     }
[16:21:03.441]     ...future.result$conditions <- ...future.conditions
[16:21:03.441]     ...future.result$finished <- base::Sys.time()
[16:21:03.441]     ...future.result
[16:21:03.441] }
[16:21:03.443] assign_globals() ...
[16:21:03.443] List of 1
[16:21:03.443]  $ a: num 3
[16:21:03.443]  - attr(*, "where")=List of 1
[16:21:03.443]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.443]  - attr(*, "resolved")= logi TRUE
[16:21:03.443]  - attr(*, "total_size")= num 56
[16:21:03.443]  - attr(*, "already-done")= logi TRUE
[16:21:03.446] - copied ‘a’ to environment
[16:21:03.446] assign_globals() ... done
[16:21:03.446] plan(): Setting new future strategy stack:
[16:21:03.446] List of future strategies:
[16:21:03.446] 1. sequential:
[16:21:03.446]    - args: function (..., envir = parent.frame())
[16:21:03.446]    - tweaked: FALSE
[16:21:03.446]    - call: NULL
[16:21:03.446] plan(): nbrOfWorkers() = 1
[16:21:03.447] plan(): Setting new future strategy stack:
[16:21:03.447] List of future strategies:
[16:21:03.447] 1. sequential:
[16:21:03.447]    - args: function (..., envir = parent.frame())
[16:21:03.447]    - tweaked: FALSE
[16:21:03.447]    - call: plan(strategy)
[16:21:03.448] plan(): nbrOfWorkers() = 1
[16:21:03.448] SequentialFuture started (and completed)
[16:21:03.448] - Launch lazy future ... done
[16:21:03.448] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.449] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.449] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.451] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.451] Searching for globals ... DONE
[16:21:03.451] Resolving globals: TRUE
[16:21:03.451] Resolving any globals that are futures ...
[16:21:03.451] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.451] Resolving any globals that are futures ... DONE
[16:21:03.452] Resolving futures part of globals (recursively) ...
[16:21:03.452] resolve() on list ...
[16:21:03.452]  recursive: 99
[16:21:03.452]  length: 2
[16:21:03.452]  elements: ‘a’, ‘ii’
[16:21:03.452]  length: 1 (resolved future 1)
[16:21:03.452]  length: 0 (resolved future 2)
[16:21:03.452] resolve() on list ... DONE
[16:21:03.453] - globals: [2] ‘a’, ‘ii’
[16:21:03.453] Resolving futures part of globals (recursively) ... DONE
[16:21:03.453] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:03.453] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.453] - globals: [2] ‘a’, ‘ii’
[16:21:03.453] 
[16:21:03.454] getGlobalsAndPackages() ... DONE
[16:21:03.454] run() for ‘Future’ ...
[16:21:03.454] - state: ‘created’
[16:21:03.454] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.454] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.454]   - Field: ‘label’
[16:21:03.455]   - Field: ‘local’
[16:21:03.455]   - Field: ‘owner’
[16:21:03.455]   - Field: ‘envir’
[16:21:03.455]   - Field: ‘packages’
[16:21:03.455]   - Field: ‘gc’
[16:21:03.455]   - Field: ‘conditions’
[16:21:03.455]   - Field: ‘expr’
[16:21:03.455]   - Field: ‘uuid’
[16:21:03.455]   - Field: ‘seed’
[16:21:03.455]   - Field: ‘version’
[16:21:03.455]   - Field: ‘result’
[16:21:03.456]   - Field: ‘asynchronous’
[16:21:03.456]   - Field: ‘calls’
[16:21:03.456]   - Field: ‘globals’
[16:21:03.456]   - Field: ‘stdout’
[16:21:03.456]   - Field: ‘earlySignal’
[16:21:03.456]   - Field: ‘lazy’
[16:21:03.456]   - Field: ‘state’
[16:21:03.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.458] - Launch lazy future ...
[16:21:03.458] Packages needed by the future expression (n = 0): <none>
[16:21:03.458] Packages needed by future strategies (n = 0): <none>
[16:21:03.459] {
[16:21:03.459]     {
[16:21:03.459]         {
[16:21:03.459]             ...future.startTime <- base::Sys.time()
[16:21:03.459]             {
[16:21:03.459]                 {
[16:21:03.459]                   {
[16:21:03.459]                     base::local({
[16:21:03.459]                       has_future <- base::requireNamespace("future", 
[16:21:03.459]                         quietly = TRUE)
[16:21:03.459]                       if (has_future) {
[16:21:03.459]                         ns <- base::getNamespace("future")
[16:21:03.459]                         version <- ns[[".package"]][["version"]]
[16:21:03.459]                         if (is.null(version)) 
[16:21:03.459]                           version <- utils::packageVersion("future")
[16:21:03.459]                       }
[16:21:03.459]                       else {
[16:21:03.459]                         version <- NULL
[16:21:03.459]                       }
[16:21:03.459]                       if (!has_future || version < "1.8.0") {
[16:21:03.459]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.459]                           "", base::R.version$version.string), 
[16:21:03.459]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.459]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.459]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.459]                             "release", "version")], collapse = " "), 
[16:21:03.459]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.459]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.459]                           info)
[16:21:03.459]                         info <- base::paste(info, collapse = "; ")
[16:21:03.459]                         if (!has_future) {
[16:21:03.459]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.459]                             info)
[16:21:03.459]                         }
[16:21:03.459]                         else {
[16:21:03.459]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.459]                             info, version)
[16:21:03.459]                         }
[16:21:03.459]                         base::stop(msg)
[16:21:03.459]                       }
[16:21:03.459]                     })
[16:21:03.459]                   }
[16:21:03.459]                   ...future.strategy.old <- future::plan("list")
[16:21:03.459]                   options(future.plan = NULL)
[16:21:03.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.459]                 }
[16:21:03.459]                 ...future.workdir <- getwd()
[16:21:03.459]             }
[16:21:03.459]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.459]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.459]         }
[16:21:03.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.459]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.459]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.459]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.459]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.459]             base::names(...future.oldOptions))
[16:21:03.459]     }
[16:21:03.459]     if (FALSE) {
[16:21:03.459]     }
[16:21:03.459]     else {
[16:21:03.459]         if (TRUE) {
[16:21:03.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.459]                 open = "w")
[16:21:03.459]         }
[16:21:03.459]         else {
[16:21:03.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.459]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.459]         }
[16:21:03.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.459]             base::sink(type = "output", split = FALSE)
[16:21:03.459]             base::close(...future.stdout)
[16:21:03.459]         }, add = TRUE)
[16:21:03.459]     }
[16:21:03.459]     ...future.frame <- base::sys.nframe()
[16:21:03.459]     ...future.conditions <- base::list()
[16:21:03.459]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.459]     if (FALSE) {
[16:21:03.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.459]     }
[16:21:03.459]     ...future.result <- base::tryCatch({
[16:21:03.459]         base::withCallingHandlers({
[16:21:03.459]             ...future.value <- base::withVisible(base::local({
[16:21:03.459]                 b <- a * ii
[16:21:03.459]                 a <- 0
[16:21:03.459]                 b
[16:21:03.459]             }))
[16:21:03.459]             future::FutureResult(value = ...future.value$value, 
[16:21:03.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.459]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.459]                     ...future.globalenv.names))
[16:21:03.459]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.459]         }, condition = base::local({
[16:21:03.459]             c <- base::c
[16:21:03.459]             inherits <- base::inherits
[16:21:03.459]             invokeRestart <- base::invokeRestart
[16:21:03.459]             length <- base::length
[16:21:03.459]             list <- base::list
[16:21:03.459]             seq.int <- base::seq.int
[16:21:03.459]             signalCondition <- base::signalCondition
[16:21:03.459]             sys.calls <- base::sys.calls
[16:21:03.459]             `[[` <- base::`[[`
[16:21:03.459]             `+` <- base::`+`
[16:21:03.459]             `<<-` <- base::`<<-`
[16:21:03.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.459]                   3L)]
[16:21:03.459]             }
[16:21:03.459]             function(cond) {
[16:21:03.459]                 is_error <- inherits(cond, "error")
[16:21:03.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.459]                   NULL)
[16:21:03.459]                 if (is_error) {
[16:21:03.459]                   sessionInformation <- function() {
[16:21:03.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.459]                       search = base::search(), system = base::Sys.info())
[16:21:03.459]                   }
[16:21:03.459]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.459]                     cond$call), session = sessionInformation(), 
[16:21:03.459]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.459]                   signalCondition(cond)
[16:21:03.459]                 }
[16:21:03.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.459]                 "immediateCondition"))) {
[16:21:03.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.459]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.459]                   if (TRUE && !signal) {
[16:21:03.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.459]                     {
[16:21:03.459]                       inherits <- base::inherits
[16:21:03.459]                       invokeRestart <- base::invokeRestart
[16:21:03.459]                       is.null <- base::is.null
[16:21:03.459]                       muffled <- FALSE
[16:21:03.459]                       if (inherits(cond, "message")) {
[16:21:03.459]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.459]                         if (muffled) 
[16:21:03.459]                           invokeRestart("muffleMessage")
[16:21:03.459]                       }
[16:21:03.459]                       else if (inherits(cond, "warning")) {
[16:21:03.459]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.459]                         if (muffled) 
[16:21:03.459]                           invokeRestart("muffleWarning")
[16:21:03.459]                       }
[16:21:03.459]                       else if (inherits(cond, "condition")) {
[16:21:03.459]                         if (!is.null(pattern)) {
[16:21:03.459]                           computeRestarts <- base::computeRestarts
[16:21:03.459]                           grepl <- base::grepl
[16:21:03.459]                           restarts <- computeRestarts(cond)
[16:21:03.459]                           for (restart in restarts) {
[16:21:03.459]                             name <- restart$name
[16:21:03.459]                             if (is.null(name)) 
[16:21:03.459]                               next
[16:21:03.459]                             if (!grepl(pattern, name)) 
[16:21:03.459]                               next
[16:21:03.459]                             invokeRestart(restart)
[16:21:03.459]                             muffled <- TRUE
[16:21:03.459]                             break
[16:21:03.459]                           }
[16:21:03.459]                         }
[16:21:03.459]                       }
[16:21:03.459]                       invisible(muffled)
[16:21:03.459]                     }
[16:21:03.459]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.459]                   }
[16:21:03.459]                 }
[16:21:03.459]                 else {
[16:21:03.459]                   if (TRUE) {
[16:21:03.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.459]                     {
[16:21:03.459]                       inherits <- base::inherits
[16:21:03.459]                       invokeRestart <- base::invokeRestart
[16:21:03.459]                       is.null <- base::is.null
[16:21:03.459]                       muffled <- FALSE
[16:21:03.459]                       if (inherits(cond, "message")) {
[16:21:03.459]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.459]                         if (muffled) 
[16:21:03.459]                           invokeRestart("muffleMessage")
[16:21:03.459]                       }
[16:21:03.459]                       else if (inherits(cond, "warning")) {
[16:21:03.459]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.459]                         if (muffled) 
[16:21:03.459]                           invokeRestart("muffleWarning")
[16:21:03.459]                       }
[16:21:03.459]                       else if (inherits(cond, "condition")) {
[16:21:03.459]                         if (!is.null(pattern)) {
[16:21:03.459]                           computeRestarts <- base::computeRestarts
[16:21:03.459]                           grepl <- base::grepl
[16:21:03.459]                           restarts <- computeRestarts(cond)
[16:21:03.459]                           for (restart in restarts) {
[16:21:03.459]                             name <- restart$name
[16:21:03.459]                             if (is.null(name)) 
[16:21:03.459]                               next
[16:21:03.459]                             if (!grepl(pattern, name)) 
[16:21:03.459]                               next
[16:21:03.459]                             invokeRestart(restart)
[16:21:03.459]                             muffled <- TRUE
[16:21:03.459]                             break
[16:21:03.459]                           }
[16:21:03.459]                         }
[16:21:03.459]                       }
[16:21:03.459]                       invisible(muffled)
[16:21:03.459]                     }
[16:21:03.459]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.459]                   }
[16:21:03.459]                 }
[16:21:03.459]             }
[16:21:03.459]         }))
[16:21:03.459]     }, error = function(ex) {
[16:21:03.459]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.459]                 ...future.rng), started = ...future.startTime, 
[16:21:03.459]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.459]             version = "1.8"), class = "FutureResult")
[16:21:03.459]     }, finally = {
[16:21:03.459]         if (!identical(...future.workdir, getwd())) 
[16:21:03.459]             setwd(...future.workdir)
[16:21:03.459]         {
[16:21:03.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.459]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.459]             }
[16:21:03.459]             base::options(...future.oldOptions)
[16:21:03.459]             if (.Platform$OS.type == "windows") {
[16:21:03.459]                 old_names <- names(...future.oldEnvVars)
[16:21:03.459]                 envs <- base::Sys.getenv()
[16:21:03.459]                 names <- names(envs)
[16:21:03.459]                 common <- intersect(names, old_names)
[16:21:03.459]                 added <- setdiff(names, old_names)
[16:21:03.459]                 removed <- setdiff(old_names, names)
[16:21:03.459]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.459]                   envs[common]]
[16:21:03.459]                 NAMES <- toupper(changed)
[16:21:03.459]                 args <- list()
[16:21:03.459]                 for (kk in seq_along(NAMES)) {
[16:21:03.459]                   name <- changed[[kk]]
[16:21:03.459]                   NAME <- NAMES[[kk]]
[16:21:03.459]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.459]                     next
[16:21:03.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.459]                 }
[16:21:03.459]                 NAMES <- toupper(added)
[16:21:03.459]                 for (kk in seq_along(NAMES)) {
[16:21:03.459]                   name <- added[[kk]]
[16:21:03.459]                   NAME <- NAMES[[kk]]
[16:21:03.459]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.459]                     next
[16:21:03.459]                   args[[name]] <- ""
[16:21:03.459]                 }
[16:21:03.459]                 NAMES <- toupper(removed)
[16:21:03.459]                 for (kk in seq_along(NAMES)) {
[16:21:03.459]                   name <- removed[[kk]]
[16:21:03.459]                   NAME <- NAMES[[kk]]
[16:21:03.459]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.459]                     next
[16:21:03.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.459]                 }
[16:21:03.459]                 if (length(args) > 0) 
[16:21:03.459]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.459]             }
[16:21:03.459]             else {
[16:21:03.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.459]             }
[16:21:03.459]             {
[16:21:03.459]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.459]                   0L) {
[16:21:03.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.459]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.459]                   base::options(opts)
[16:21:03.459]                 }
[16:21:03.459]                 {
[16:21:03.459]                   {
[16:21:03.459]                     NULL
[16:21:03.459]                     RNGkind("Mersenne-Twister")
[16:21:03.459]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.459]                       inherits = FALSE)
[16:21:03.459]                   }
[16:21:03.459]                   options(future.plan = NULL)
[16:21:03.459]                   if (is.na(NA_character_)) 
[16:21:03.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.459]                     .init = FALSE)
[16:21:03.459]                 }
[16:21:03.459]             }
[16:21:03.459]         }
[16:21:03.459]     })
[16:21:03.459]     if (TRUE) {
[16:21:03.459]         base::sink(type = "output", split = FALSE)
[16:21:03.459]         if (TRUE) {
[16:21:03.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.459]         }
[16:21:03.459]         else {
[16:21:03.459]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.459]         }
[16:21:03.459]         base::close(...future.stdout)
[16:21:03.459]         ...future.stdout <- NULL
[16:21:03.459]     }
[16:21:03.459]     ...future.result$conditions <- ...future.conditions
[16:21:03.459]     ...future.result$finished <- base::Sys.time()
[16:21:03.459]     ...future.result
[16:21:03.459] }
[16:21:03.461] assign_globals() ...
[16:21:03.461] List of 2
[16:21:03.461]  $ a : num 1
[16:21:03.461]  $ ii: int 1
[16:21:03.461]  - attr(*, "where")=List of 2
[16:21:03.461]   ..$ a :<environment: R_EmptyEnv> 
[16:21:03.461]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.461]  - attr(*, "resolved")= logi TRUE
[16:21:03.461]  - attr(*, "total_size")= num 112
[16:21:03.461]  - attr(*, "already-done")= logi TRUE
[16:21:03.464] - copied ‘a’ to environment
[16:21:03.464] - copied ‘ii’ to environment
[16:21:03.464] assign_globals() ... done
[16:21:03.464] plan(): Setting new future strategy stack:
[16:21:03.464] List of future strategies:
[16:21:03.464] 1. sequential:
[16:21:03.464]    - args: function (..., envir = parent.frame())
[16:21:03.464]    - tweaked: FALSE
[16:21:03.464]    - call: NULL
[16:21:03.465] plan(): nbrOfWorkers() = 1
[16:21:03.465] plan(): Setting new future strategy stack:
[16:21:03.465] List of future strategies:
[16:21:03.465] 1. sequential:
[16:21:03.465]    - args: function (..., envir = parent.frame())
[16:21:03.465]    - tweaked: FALSE
[16:21:03.465]    - call: plan(strategy)
[16:21:03.466] plan(): nbrOfWorkers() = 1
[16:21:03.466] SequentialFuture started (and completed)
[16:21:03.466] - Launch lazy future ... done
[16:21:03.466] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.467] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.467] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.469] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.469] Searching for globals ... DONE
[16:21:03.469] Resolving globals: TRUE
[16:21:03.469] Resolving any globals that are futures ...
[16:21:03.469] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.469] Resolving any globals that are futures ... DONE
[16:21:03.469] Resolving futures part of globals (recursively) ...
[16:21:03.470] resolve() on list ...
[16:21:03.470]  recursive: 99
[16:21:03.470]  length: 2
[16:21:03.470]  elements: ‘a’, ‘ii’
[16:21:03.470]  length: 1 (resolved future 1)
[16:21:03.470]  length: 0 (resolved future 2)
[16:21:03.470] resolve() on list ... DONE
[16:21:03.470] - globals: [2] ‘a’, ‘ii’
[16:21:03.470] Resolving futures part of globals (recursively) ... DONE
[16:21:03.471] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:03.471] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.471] - globals: [2] ‘a’, ‘ii’
[16:21:03.471] 
[16:21:03.471] getGlobalsAndPackages() ... DONE
[16:21:03.472] run() for ‘Future’ ...
[16:21:03.472] - state: ‘created’
[16:21:03.472] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.472] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.472]   - Field: ‘label’
[16:21:03.472]   - Field: ‘local’
[16:21:03.473]   - Field: ‘owner’
[16:21:03.473]   - Field: ‘envir’
[16:21:03.473]   - Field: ‘packages’
[16:21:03.473]   - Field: ‘gc’
[16:21:03.473]   - Field: ‘conditions’
[16:21:03.473]   - Field: ‘expr’
[16:21:03.473]   - Field: ‘uuid’
[16:21:03.473]   - Field: ‘seed’
[16:21:03.473]   - Field: ‘version’
[16:21:03.473]   - Field: ‘result’
[16:21:03.474]   - Field: ‘asynchronous’
[16:21:03.474]   - Field: ‘calls’
[16:21:03.474]   - Field: ‘globals’
[16:21:03.474]   - Field: ‘stdout’
[16:21:03.474]   - Field: ‘earlySignal’
[16:21:03.474]   - Field: ‘lazy’
[16:21:03.474]   - Field: ‘state’
[16:21:03.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.474] - Launch lazy future ...
[16:21:03.475] Packages needed by the future expression (n = 0): <none>
[16:21:03.475] Packages needed by future strategies (n = 0): <none>
[16:21:03.475] {
[16:21:03.475]     {
[16:21:03.475]         {
[16:21:03.475]             ...future.startTime <- base::Sys.time()
[16:21:03.475]             {
[16:21:03.475]                 {
[16:21:03.475]                   {
[16:21:03.475]                     base::local({
[16:21:03.475]                       has_future <- base::requireNamespace("future", 
[16:21:03.475]                         quietly = TRUE)
[16:21:03.475]                       if (has_future) {
[16:21:03.475]                         ns <- base::getNamespace("future")
[16:21:03.475]                         version <- ns[[".package"]][["version"]]
[16:21:03.475]                         if (is.null(version)) 
[16:21:03.475]                           version <- utils::packageVersion("future")
[16:21:03.475]                       }
[16:21:03.475]                       else {
[16:21:03.475]                         version <- NULL
[16:21:03.475]                       }
[16:21:03.475]                       if (!has_future || version < "1.8.0") {
[16:21:03.475]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.475]                           "", base::R.version$version.string), 
[16:21:03.475]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.475]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.475]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.475]                             "release", "version")], collapse = " "), 
[16:21:03.475]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.475]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.475]                           info)
[16:21:03.475]                         info <- base::paste(info, collapse = "; ")
[16:21:03.475]                         if (!has_future) {
[16:21:03.475]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.475]                             info)
[16:21:03.475]                         }
[16:21:03.475]                         else {
[16:21:03.475]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.475]                             info, version)
[16:21:03.475]                         }
[16:21:03.475]                         base::stop(msg)
[16:21:03.475]                       }
[16:21:03.475]                     })
[16:21:03.475]                   }
[16:21:03.475]                   ...future.strategy.old <- future::plan("list")
[16:21:03.475]                   options(future.plan = NULL)
[16:21:03.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.475]                 }
[16:21:03.475]                 ...future.workdir <- getwd()
[16:21:03.475]             }
[16:21:03.475]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.475]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.475]         }
[16:21:03.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.475]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.475]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.475]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.475]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.475]             base::names(...future.oldOptions))
[16:21:03.475]     }
[16:21:03.475]     if (FALSE) {
[16:21:03.475]     }
[16:21:03.475]     else {
[16:21:03.475]         if (TRUE) {
[16:21:03.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.475]                 open = "w")
[16:21:03.475]         }
[16:21:03.475]         else {
[16:21:03.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.475]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.475]         }
[16:21:03.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.475]             base::sink(type = "output", split = FALSE)
[16:21:03.475]             base::close(...future.stdout)
[16:21:03.475]         }, add = TRUE)
[16:21:03.475]     }
[16:21:03.475]     ...future.frame <- base::sys.nframe()
[16:21:03.475]     ...future.conditions <- base::list()
[16:21:03.475]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.475]     if (FALSE) {
[16:21:03.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.475]     }
[16:21:03.475]     ...future.result <- base::tryCatch({
[16:21:03.475]         base::withCallingHandlers({
[16:21:03.475]             ...future.value <- base::withVisible(base::local({
[16:21:03.475]                 b <- a * ii
[16:21:03.475]                 a <- 0
[16:21:03.475]                 b
[16:21:03.475]             }))
[16:21:03.475]             future::FutureResult(value = ...future.value$value, 
[16:21:03.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.475]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.475]                     ...future.globalenv.names))
[16:21:03.475]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.475]         }, condition = base::local({
[16:21:03.475]             c <- base::c
[16:21:03.475]             inherits <- base::inherits
[16:21:03.475]             invokeRestart <- base::invokeRestart
[16:21:03.475]             length <- base::length
[16:21:03.475]             list <- base::list
[16:21:03.475]             seq.int <- base::seq.int
[16:21:03.475]             signalCondition <- base::signalCondition
[16:21:03.475]             sys.calls <- base::sys.calls
[16:21:03.475]             `[[` <- base::`[[`
[16:21:03.475]             `+` <- base::`+`
[16:21:03.475]             `<<-` <- base::`<<-`
[16:21:03.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.475]                   3L)]
[16:21:03.475]             }
[16:21:03.475]             function(cond) {
[16:21:03.475]                 is_error <- inherits(cond, "error")
[16:21:03.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.475]                   NULL)
[16:21:03.475]                 if (is_error) {
[16:21:03.475]                   sessionInformation <- function() {
[16:21:03.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.475]                       search = base::search(), system = base::Sys.info())
[16:21:03.475]                   }
[16:21:03.475]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.475]                     cond$call), session = sessionInformation(), 
[16:21:03.475]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.475]                   signalCondition(cond)
[16:21:03.475]                 }
[16:21:03.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.475]                 "immediateCondition"))) {
[16:21:03.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.475]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.475]                   if (TRUE && !signal) {
[16:21:03.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.475]                     {
[16:21:03.475]                       inherits <- base::inherits
[16:21:03.475]                       invokeRestart <- base::invokeRestart
[16:21:03.475]                       is.null <- base::is.null
[16:21:03.475]                       muffled <- FALSE
[16:21:03.475]                       if (inherits(cond, "message")) {
[16:21:03.475]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.475]                         if (muffled) 
[16:21:03.475]                           invokeRestart("muffleMessage")
[16:21:03.475]                       }
[16:21:03.475]                       else if (inherits(cond, "warning")) {
[16:21:03.475]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.475]                         if (muffled) 
[16:21:03.475]                           invokeRestart("muffleWarning")
[16:21:03.475]                       }
[16:21:03.475]                       else if (inherits(cond, "condition")) {
[16:21:03.475]                         if (!is.null(pattern)) {
[16:21:03.475]                           computeRestarts <- base::computeRestarts
[16:21:03.475]                           grepl <- base::grepl
[16:21:03.475]                           restarts <- computeRestarts(cond)
[16:21:03.475]                           for (restart in restarts) {
[16:21:03.475]                             name <- restart$name
[16:21:03.475]                             if (is.null(name)) 
[16:21:03.475]                               next
[16:21:03.475]                             if (!grepl(pattern, name)) 
[16:21:03.475]                               next
[16:21:03.475]                             invokeRestart(restart)
[16:21:03.475]                             muffled <- TRUE
[16:21:03.475]                             break
[16:21:03.475]                           }
[16:21:03.475]                         }
[16:21:03.475]                       }
[16:21:03.475]                       invisible(muffled)
[16:21:03.475]                     }
[16:21:03.475]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.475]                   }
[16:21:03.475]                 }
[16:21:03.475]                 else {
[16:21:03.475]                   if (TRUE) {
[16:21:03.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.475]                     {
[16:21:03.475]                       inherits <- base::inherits
[16:21:03.475]                       invokeRestart <- base::invokeRestart
[16:21:03.475]                       is.null <- base::is.null
[16:21:03.475]                       muffled <- FALSE
[16:21:03.475]                       if (inherits(cond, "message")) {
[16:21:03.475]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.475]                         if (muffled) 
[16:21:03.475]                           invokeRestart("muffleMessage")
[16:21:03.475]                       }
[16:21:03.475]                       else if (inherits(cond, "warning")) {
[16:21:03.475]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.475]                         if (muffled) 
[16:21:03.475]                           invokeRestart("muffleWarning")
[16:21:03.475]                       }
[16:21:03.475]                       else if (inherits(cond, "condition")) {
[16:21:03.475]                         if (!is.null(pattern)) {
[16:21:03.475]                           computeRestarts <- base::computeRestarts
[16:21:03.475]                           grepl <- base::grepl
[16:21:03.475]                           restarts <- computeRestarts(cond)
[16:21:03.475]                           for (restart in restarts) {
[16:21:03.475]                             name <- restart$name
[16:21:03.475]                             if (is.null(name)) 
[16:21:03.475]                               next
[16:21:03.475]                             if (!grepl(pattern, name)) 
[16:21:03.475]                               next
[16:21:03.475]                             invokeRestart(restart)
[16:21:03.475]                             muffled <- TRUE
[16:21:03.475]                             break
[16:21:03.475]                           }
[16:21:03.475]                         }
[16:21:03.475]                       }
[16:21:03.475]                       invisible(muffled)
[16:21:03.475]                     }
[16:21:03.475]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.475]                   }
[16:21:03.475]                 }
[16:21:03.475]             }
[16:21:03.475]         }))
[16:21:03.475]     }, error = function(ex) {
[16:21:03.475]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.475]                 ...future.rng), started = ...future.startTime, 
[16:21:03.475]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.475]             version = "1.8"), class = "FutureResult")
[16:21:03.475]     }, finally = {
[16:21:03.475]         if (!identical(...future.workdir, getwd())) 
[16:21:03.475]             setwd(...future.workdir)
[16:21:03.475]         {
[16:21:03.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.475]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.475]             }
[16:21:03.475]             base::options(...future.oldOptions)
[16:21:03.475]             if (.Platform$OS.type == "windows") {
[16:21:03.475]                 old_names <- names(...future.oldEnvVars)
[16:21:03.475]                 envs <- base::Sys.getenv()
[16:21:03.475]                 names <- names(envs)
[16:21:03.475]                 common <- intersect(names, old_names)
[16:21:03.475]                 added <- setdiff(names, old_names)
[16:21:03.475]                 removed <- setdiff(old_names, names)
[16:21:03.475]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.475]                   envs[common]]
[16:21:03.475]                 NAMES <- toupper(changed)
[16:21:03.475]                 args <- list()
[16:21:03.475]                 for (kk in seq_along(NAMES)) {
[16:21:03.475]                   name <- changed[[kk]]
[16:21:03.475]                   NAME <- NAMES[[kk]]
[16:21:03.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.475]                     next
[16:21:03.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.475]                 }
[16:21:03.475]                 NAMES <- toupper(added)
[16:21:03.475]                 for (kk in seq_along(NAMES)) {
[16:21:03.475]                   name <- added[[kk]]
[16:21:03.475]                   NAME <- NAMES[[kk]]
[16:21:03.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.475]                     next
[16:21:03.475]                   args[[name]] <- ""
[16:21:03.475]                 }
[16:21:03.475]                 NAMES <- toupper(removed)
[16:21:03.475]                 for (kk in seq_along(NAMES)) {
[16:21:03.475]                   name <- removed[[kk]]
[16:21:03.475]                   NAME <- NAMES[[kk]]
[16:21:03.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.475]                     next
[16:21:03.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.475]                 }
[16:21:03.475]                 if (length(args) > 0) 
[16:21:03.475]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.475]             }
[16:21:03.475]             else {
[16:21:03.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.475]             }
[16:21:03.475]             {
[16:21:03.475]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.475]                   0L) {
[16:21:03.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.475]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.475]                   base::options(opts)
[16:21:03.475]                 }
[16:21:03.475]                 {
[16:21:03.475]                   {
[16:21:03.475]                     NULL
[16:21:03.475]                     RNGkind("Mersenne-Twister")
[16:21:03.475]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.475]                       inherits = FALSE)
[16:21:03.475]                   }
[16:21:03.475]                   options(future.plan = NULL)
[16:21:03.475]                   if (is.na(NA_character_)) 
[16:21:03.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.475]                     .init = FALSE)
[16:21:03.475]                 }
[16:21:03.475]             }
[16:21:03.475]         }
[16:21:03.475]     })
[16:21:03.475]     if (TRUE) {
[16:21:03.475]         base::sink(type = "output", split = FALSE)
[16:21:03.475]         if (TRUE) {
[16:21:03.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.475]         }
[16:21:03.475]         else {
[16:21:03.475]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.475]         }
[16:21:03.475]         base::close(...future.stdout)
[16:21:03.475]         ...future.stdout <- NULL
[16:21:03.475]     }
[16:21:03.475]     ...future.result$conditions <- ...future.conditions
[16:21:03.475]     ...future.result$finished <- base::Sys.time()
[16:21:03.475]     ...future.result
[16:21:03.475] }
[16:21:03.477] assign_globals() ...
[16:21:03.477] List of 2
[16:21:03.477]  $ a : num 1
[16:21:03.477]  $ ii: int 2
[16:21:03.477]  - attr(*, "where")=List of 2
[16:21:03.477]   ..$ a :<environment: R_EmptyEnv> 
[16:21:03.477]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.477]  - attr(*, "resolved")= logi TRUE
[16:21:03.477]  - attr(*, "total_size")= num 112
[16:21:03.477]  - attr(*, "already-done")= logi TRUE
[16:21:03.480] - copied ‘a’ to environment
[16:21:03.480] - copied ‘ii’ to environment
[16:21:03.480] assign_globals() ... done
[16:21:03.480] plan(): Setting new future strategy stack:
[16:21:03.480] List of future strategies:
[16:21:03.480] 1. sequential:
[16:21:03.480]    - args: function (..., envir = parent.frame())
[16:21:03.480]    - tweaked: FALSE
[16:21:03.480]    - call: NULL
[16:21:03.481] plan(): nbrOfWorkers() = 1
[16:21:03.482] plan(): Setting new future strategy stack:
[16:21:03.482] List of future strategies:
[16:21:03.482] 1. sequential:
[16:21:03.482]    - args: function (..., envir = parent.frame())
[16:21:03.482]    - tweaked: FALSE
[16:21:03.482]    - call: plan(strategy)
[16:21:03.482] plan(): nbrOfWorkers() = 1
[16:21:03.482] SequentialFuture started (and completed)
[16:21:03.482] - Launch lazy future ... done
[16:21:03.482] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.483] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.485] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.487] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.487] Searching for globals ... DONE
[16:21:03.487] Resolving globals: TRUE
[16:21:03.487] Resolving any globals that are futures ...
[16:21:03.487] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.487] Resolving any globals that are futures ... DONE
[16:21:03.488] Resolving futures part of globals (recursively) ...
[16:21:03.488] resolve() on list ...
[16:21:03.488]  recursive: 99
[16:21:03.488]  length: 2
[16:21:03.488]  elements: ‘a’, ‘ii’
[16:21:03.488]  length: 1 (resolved future 1)
[16:21:03.489]  length: 0 (resolved future 2)
[16:21:03.489] resolve() on list ... DONE
[16:21:03.489] - globals: [2] ‘a’, ‘ii’
[16:21:03.489] Resolving futures part of globals (recursively) ... DONE
[16:21:03.489] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:03.489] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.489] - globals: [2] ‘a’, ‘ii’
[16:21:03.490] 
[16:21:03.490] getGlobalsAndPackages() ... DONE
[16:21:03.490] run() for ‘Future’ ...
[16:21:03.490] - state: ‘created’
[16:21:03.490] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.490] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.491] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.491]   - Field: ‘label’
[16:21:03.491]   - Field: ‘local’
[16:21:03.491]   - Field: ‘owner’
[16:21:03.491]   - Field: ‘envir’
[16:21:03.491]   - Field: ‘packages’
[16:21:03.491]   - Field: ‘gc’
[16:21:03.491]   - Field: ‘conditions’
[16:21:03.491]   - Field: ‘expr’
[16:21:03.491]   - Field: ‘uuid’
[16:21:03.492]   - Field: ‘seed’
[16:21:03.492]   - Field: ‘version’
[16:21:03.492]   - Field: ‘result’
[16:21:03.492]   - Field: ‘asynchronous’
[16:21:03.492]   - Field: ‘calls’
[16:21:03.492]   - Field: ‘globals’
[16:21:03.492]   - Field: ‘stdout’
[16:21:03.492]   - Field: ‘earlySignal’
[16:21:03.492]   - Field: ‘lazy’
[16:21:03.492]   - Field: ‘state’
[16:21:03.493] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.493] - Launch lazy future ...
[16:21:03.493] Packages needed by the future expression (n = 0): <none>
[16:21:03.493] Packages needed by future strategies (n = 0): <none>
[16:21:03.493] {
[16:21:03.493]     {
[16:21:03.493]         {
[16:21:03.493]             ...future.startTime <- base::Sys.time()
[16:21:03.493]             {
[16:21:03.493]                 {
[16:21:03.493]                   {
[16:21:03.493]                     base::local({
[16:21:03.493]                       has_future <- base::requireNamespace("future", 
[16:21:03.493]                         quietly = TRUE)
[16:21:03.493]                       if (has_future) {
[16:21:03.493]                         ns <- base::getNamespace("future")
[16:21:03.493]                         version <- ns[[".package"]][["version"]]
[16:21:03.493]                         if (is.null(version)) 
[16:21:03.493]                           version <- utils::packageVersion("future")
[16:21:03.493]                       }
[16:21:03.493]                       else {
[16:21:03.493]                         version <- NULL
[16:21:03.493]                       }
[16:21:03.493]                       if (!has_future || version < "1.8.0") {
[16:21:03.493]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.493]                           "", base::R.version$version.string), 
[16:21:03.493]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.493]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.493]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.493]                             "release", "version")], collapse = " "), 
[16:21:03.493]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.493]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.493]                           info)
[16:21:03.493]                         info <- base::paste(info, collapse = "; ")
[16:21:03.493]                         if (!has_future) {
[16:21:03.493]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.493]                             info)
[16:21:03.493]                         }
[16:21:03.493]                         else {
[16:21:03.493]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.493]                             info, version)
[16:21:03.493]                         }
[16:21:03.493]                         base::stop(msg)
[16:21:03.493]                       }
[16:21:03.493]                     })
[16:21:03.493]                   }
[16:21:03.493]                   ...future.strategy.old <- future::plan("list")
[16:21:03.493]                   options(future.plan = NULL)
[16:21:03.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.493]                 }
[16:21:03.493]                 ...future.workdir <- getwd()
[16:21:03.493]             }
[16:21:03.493]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.493]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.493]         }
[16:21:03.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.493]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.493]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.493]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.493]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.493]             base::names(...future.oldOptions))
[16:21:03.493]     }
[16:21:03.493]     if (FALSE) {
[16:21:03.493]     }
[16:21:03.493]     else {
[16:21:03.493]         if (TRUE) {
[16:21:03.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.493]                 open = "w")
[16:21:03.493]         }
[16:21:03.493]         else {
[16:21:03.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.493]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.493]         }
[16:21:03.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.493]             base::sink(type = "output", split = FALSE)
[16:21:03.493]             base::close(...future.stdout)
[16:21:03.493]         }, add = TRUE)
[16:21:03.493]     }
[16:21:03.493]     ...future.frame <- base::sys.nframe()
[16:21:03.493]     ...future.conditions <- base::list()
[16:21:03.493]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.493]     if (FALSE) {
[16:21:03.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.493]     }
[16:21:03.493]     ...future.result <- base::tryCatch({
[16:21:03.493]         base::withCallingHandlers({
[16:21:03.493]             ...future.value <- base::withVisible(base::local({
[16:21:03.493]                 b <- a * ii
[16:21:03.493]                 a <- 0
[16:21:03.493]                 b
[16:21:03.493]             }))
[16:21:03.493]             future::FutureResult(value = ...future.value$value, 
[16:21:03.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.493]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.493]                     ...future.globalenv.names))
[16:21:03.493]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.493]         }, condition = base::local({
[16:21:03.493]             c <- base::c
[16:21:03.493]             inherits <- base::inherits
[16:21:03.493]             invokeRestart <- base::invokeRestart
[16:21:03.493]             length <- base::length
[16:21:03.493]             list <- base::list
[16:21:03.493]             seq.int <- base::seq.int
[16:21:03.493]             signalCondition <- base::signalCondition
[16:21:03.493]             sys.calls <- base::sys.calls
[16:21:03.493]             `[[` <- base::`[[`
[16:21:03.493]             `+` <- base::`+`
[16:21:03.493]             `<<-` <- base::`<<-`
[16:21:03.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.493]                   3L)]
[16:21:03.493]             }
[16:21:03.493]             function(cond) {
[16:21:03.493]                 is_error <- inherits(cond, "error")
[16:21:03.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.493]                   NULL)
[16:21:03.493]                 if (is_error) {
[16:21:03.493]                   sessionInformation <- function() {
[16:21:03.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.493]                       search = base::search(), system = base::Sys.info())
[16:21:03.493]                   }
[16:21:03.493]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.493]                     cond$call), session = sessionInformation(), 
[16:21:03.493]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.493]                   signalCondition(cond)
[16:21:03.493]                 }
[16:21:03.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.493]                 "immediateCondition"))) {
[16:21:03.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.493]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.493]                   if (TRUE && !signal) {
[16:21:03.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.493]                     {
[16:21:03.493]                       inherits <- base::inherits
[16:21:03.493]                       invokeRestart <- base::invokeRestart
[16:21:03.493]                       is.null <- base::is.null
[16:21:03.493]                       muffled <- FALSE
[16:21:03.493]                       if (inherits(cond, "message")) {
[16:21:03.493]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.493]                         if (muffled) 
[16:21:03.493]                           invokeRestart("muffleMessage")
[16:21:03.493]                       }
[16:21:03.493]                       else if (inherits(cond, "warning")) {
[16:21:03.493]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.493]                         if (muffled) 
[16:21:03.493]                           invokeRestart("muffleWarning")
[16:21:03.493]                       }
[16:21:03.493]                       else if (inherits(cond, "condition")) {
[16:21:03.493]                         if (!is.null(pattern)) {
[16:21:03.493]                           computeRestarts <- base::computeRestarts
[16:21:03.493]                           grepl <- base::grepl
[16:21:03.493]                           restarts <- computeRestarts(cond)
[16:21:03.493]                           for (restart in restarts) {
[16:21:03.493]                             name <- restart$name
[16:21:03.493]                             if (is.null(name)) 
[16:21:03.493]                               next
[16:21:03.493]                             if (!grepl(pattern, name)) 
[16:21:03.493]                               next
[16:21:03.493]                             invokeRestart(restart)
[16:21:03.493]                             muffled <- TRUE
[16:21:03.493]                             break
[16:21:03.493]                           }
[16:21:03.493]                         }
[16:21:03.493]                       }
[16:21:03.493]                       invisible(muffled)
[16:21:03.493]                     }
[16:21:03.493]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.493]                   }
[16:21:03.493]                 }
[16:21:03.493]                 else {
[16:21:03.493]                   if (TRUE) {
[16:21:03.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.493]                     {
[16:21:03.493]                       inherits <- base::inherits
[16:21:03.493]                       invokeRestart <- base::invokeRestart
[16:21:03.493]                       is.null <- base::is.null
[16:21:03.493]                       muffled <- FALSE
[16:21:03.493]                       if (inherits(cond, "message")) {
[16:21:03.493]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.493]                         if (muffled) 
[16:21:03.493]                           invokeRestart("muffleMessage")
[16:21:03.493]                       }
[16:21:03.493]                       else if (inherits(cond, "warning")) {
[16:21:03.493]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.493]                         if (muffled) 
[16:21:03.493]                           invokeRestart("muffleWarning")
[16:21:03.493]                       }
[16:21:03.493]                       else if (inherits(cond, "condition")) {
[16:21:03.493]                         if (!is.null(pattern)) {
[16:21:03.493]                           computeRestarts <- base::computeRestarts
[16:21:03.493]                           grepl <- base::grepl
[16:21:03.493]                           restarts <- computeRestarts(cond)
[16:21:03.493]                           for (restart in restarts) {
[16:21:03.493]                             name <- restart$name
[16:21:03.493]                             if (is.null(name)) 
[16:21:03.493]                               next
[16:21:03.493]                             if (!grepl(pattern, name)) 
[16:21:03.493]                               next
[16:21:03.493]                             invokeRestart(restart)
[16:21:03.493]                             muffled <- TRUE
[16:21:03.493]                             break
[16:21:03.493]                           }
[16:21:03.493]                         }
[16:21:03.493]                       }
[16:21:03.493]                       invisible(muffled)
[16:21:03.493]                     }
[16:21:03.493]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.493]                   }
[16:21:03.493]                 }
[16:21:03.493]             }
[16:21:03.493]         }))
[16:21:03.493]     }, error = function(ex) {
[16:21:03.493]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.493]                 ...future.rng), started = ...future.startTime, 
[16:21:03.493]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.493]             version = "1.8"), class = "FutureResult")
[16:21:03.493]     }, finally = {
[16:21:03.493]         if (!identical(...future.workdir, getwd())) 
[16:21:03.493]             setwd(...future.workdir)
[16:21:03.493]         {
[16:21:03.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.493]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.493]             }
[16:21:03.493]             base::options(...future.oldOptions)
[16:21:03.493]             if (.Platform$OS.type == "windows") {
[16:21:03.493]                 old_names <- names(...future.oldEnvVars)
[16:21:03.493]                 envs <- base::Sys.getenv()
[16:21:03.493]                 names <- names(envs)
[16:21:03.493]                 common <- intersect(names, old_names)
[16:21:03.493]                 added <- setdiff(names, old_names)
[16:21:03.493]                 removed <- setdiff(old_names, names)
[16:21:03.493]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.493]                   envs[common]]
[16:21:03.493]                 NAMES <- toupper(changed)
[16:21:03.493]                 args <- list()
[16:21:03.493]                 for (kk in seq_along(NAMES)) {
[16:21:03.493]                   name <- changed[[kk]]
[16:21:03.493]                   NAME <- NAMES[[kk]]
[16:21:03.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.493]                     next
[16:21:03.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.493]                 }
[16:21:03.493]                 NAMES <- toupper(added)
[16:21:03.493]                 for (kk in seq_along(NAMES)) {
[16:21:03.493]                   name <- added[[kk]]
[16:21:03.493]                   NAME <- NAMES[[kk]]
[16:21:03.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.493]                     next
[16:21:03.493]                   args[[name]] <- ""
[16:21:03.493]                 }
[16:21:03.493]                 NAMES <- toupper(removed)
[16:21:03.493]                 for (kk in seq_along(NAMES)) {
[16:21:03.493]                   name <- removed[[kk]]
[16:21:03.493]                   NAME <- NAMES[[kk]]
[16:21:03.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.493]                     next
[16:21:03.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.493]                 }
[16:21:03.493]                 if (length(args) > 0) 
[16:21:03.493]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.493]             }
[16:21:03.493]             else {
[16:21:03.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.493]             }
[16:21:03.493]             {
[16:21:03.493]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.493]                   0L) {
[16:21:03.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.493]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.493]                   base::options(opts)
[16:21:03.493]                 }
[16:21:03.493]                 {
[16:21:03.493]                   {
[16:21:03.493]                     NULL
[16:21:03.493]                     RNGkind("Mersenne-Twister")
[16:21:03.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.493]                       inherits = FALSE)
[16:21:03.493]                   }
[16:21:03.493]                   options(future.plan = NULL)
[16:21:03.493]                   if (is.na(NA_character_)) 
[16:21:03.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.493]                     .init = FALSE)
[16:21:03.493]                 }
[16:21:03.493]             }
[16:21:03.493]         }
[16:21:03.493]     })
[16:21:03.493]     if (TRUE) {
[16:21:03.493]         base::sink(type = "output", split = FALSE)
[16:21:03.493]         if (TRUE) {
[16:21:03.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.493]         }
[16:21:03.493]         else {
[16:21:03.493]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.493]         }
[16:21:03.493]         base::close(...future.stdout)
[16:21:03.493]         ...future.stdout <- NULL
[16:21:03.493]     }
[16:21:03.493]     ...future.result$conditions <- ...future.conditions
[16:21:03.493]     ...future.result$finished <- base::Sys.time()
[16:21:03.493]     ...future.result
[16:21:03.493] }
[16:21:03.495] assign_globals() ...
[16:21:03.495] List of 2
[16:21:03.495]  $ a : num 1
[16:21:03.495]  $ ii: int 3
[16:21:03.495]  - attr(*, "where")=List of 2
[16:21:03.495]   ..$ a :<environment: R_EmptyEnv> 
[16:21:03.495]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.495]  - attr(*, "resolved")= logi TRUE
[16:21:03.495]  - attr(*, "total_size")= num 112
[16:21:03.495]  - attr(*, "already-done")= logi TRUE
[16:21:03.498] - copied ‘a’ to environment
[16:21:03.498] - copied ‘ii’ to environment
[16:21:03.498] assign_globals() ... done
[16:21:03.498] plan(): Setting new future strategy stack:
[16:21:03.499] List of future strategies:
[16:21:03.499] 1. sequential:
[16:21:03.499]    - args: function (..., envir = parent.frame())
[16:21:03.499]    - tweaked: FALSE
[16:21:03.499]    - call: NULL
[16:21:03.499] plan(): nbrOfWorkers() = 1
[16:21:03.500] plan(): Setting new future strategy stack:
[16:21:03.500] List of future strategies:
[16:21:03.500] 1. sequential:
[16:21:03.500]    - args: function (..., envir = parent.frame())
[16:21:03.500]    - tweaked: FALSE
[16:21:03.500]    - call: plan(strategy)
[16:21:03.500] plan(): nbrOfWorkers() = 1
[16:21:03.500] SequentialFuture started (and completed)
[16:21:03.500] - Launch lazy future ... done
[16:21:03.501] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.501] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.502] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.504] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.504] Searching for globals ... DONE
[16:21:03.504] Resolving globals: TRUE
[16:21:03.504] Resolving any globals that are futures ...
[16:21:03.504] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.504] Resolving any globals that are futures ... DONE
[16:21:03.504] Resolving futures part of globals (recursively) ...
[16:21:03.505] resolve() on list ...
[16:21:03.505]  recursive: 99
[16:21:03.505]  length: 2
[16:21:03.505]  elements: ‘a’, ‘ii’
[16:21:03.505]  length: 1 (resolved future 1)
[16:21:03.505]  length: 0 (resolved future 2)
[16:21:03.505] resolve() on list ... DONE
[16:21:03.505] - globals: [2] ‘a’, ‘ii’
[16:21:03.506] Resolving futures part of globals (recursively) ... DONE
[16:21:03.506] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:03.506] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.506] - globals: [2] ‘a’, ‘ii’
[16:21:03.506] 
[16:21:03.506] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.507] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.507] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.511] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.511] Searching for globals ... DONE
[16:21:03.511] Resolving globals: TRUE
[16:21:03.511] Resolving any globals that are futures ...
[16:21:03.511] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.511] Resolving any globals that are futures ... DONE
[16:21:03.512] Resolving futures part of globals (recursively) ...
[16:21:03.512] resolve() on list ...
[16:21:03.512]  recursive: 99
[16:21:03.512]  length: 2
[16:21:03.512]  elements: ‘a’, ‘ii’
[16:21:03.512]  length: 1 (resolved future 1)
[16:21:03.513]  length: 0 (resolved future 2)
[16:21:03.513] resolve() on list ... DONE
[16:21:03.513] - globals: [2] ‘a’, ‘ii’
[16:21:03.513] Resolving futures part of globals (recursively) ... DONE
[16:21:03.513] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:03.513] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.513] - globals: [2] ‘a’, ‘ii’
[16:21:03.514] 
[16:21:03.514] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.514] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.514] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.516] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.516] Searching for globals ... DONE
[16:21:03.516] Resolving globals: TRUE
[16:21:03.517] Resolving any globals that are futures ...
[16:21:03.517] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:03.517] Resolving any globals that are futures ... DONE
[16:21:03.517] Resolving futures part of globals (recursively) ...
[16:21:03.517] resolve() on list ...
[16:21:03.517]  recursive: 99
[16:21:03.518]  length: 2
[16:21:03.518]  elements: ‘a’, ‘ii’
[16:21:03.518]  length: 1 (resolved future 1)
[16:21:03.518]  length: 0 (resolved future 2)
[16:21:03.518] resolve() on list ... DONE
[16:21:03.518] - globals: [2] ‘a’, ‘ii’
[16:21:03.518] Resolving futures part of globals (recursively) ... DONE
[16:21:03.518] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:03.519] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.519] - globals: [2] ‘a’, ‘ii’
[16:21:03.519] 
[16:21:03.519] getGlobalsAndPackages() ... DONE
[16:21:03.519] run() for ‘Future’ ...
[16:21:03.519] - state: ‘created’
[16:21:03.519] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.520] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.520]   - Field: ‘label’
[16:21:03.520]   - Field: ‘local’
[16:21:03.520]   - Field: ‘owner’
[16:21:03.520]   - Field: ‘envir’
[16:21:03.520]   - Field: ‘packages’
[16:21:03.520]   - Field: ‘gc’
[16:21:03.521]   - Field: ‘conditions’
[16:21:03.521]   - Field: ‘expr’
[16:21:03.521]   - Field: ‘uuid’
[16:21:03.521]   - Field: ‘seed’
[16:21:03.521]   - Field: ‘version’
[16:21:03.521]   - Field: ‘result’
[16:21:03.521]   - Field: ‘asynchronous’
[16:21:03.521]   - Field: ‘calls’
[16:21:03.521]   - Field: ‘globals’
[16:21:03.521]   - Field: ‘stdout’
[16:21:03.521]   - Field: ‘earlySignal’
[16:21:03.522]   - Field: ‘lazy’
[16:21:03.522]   - Field: ‘state’
[16:21:03.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.522] - Launch lazy future ...
[16:21:03.522] Packages needed by the future expression (n = 0): <none>
[16:21:03.522] Packages needed by future strategies (n = 0): <none>
[16:21:03.523] {
[16:21:03.523]     {
[16:21:03.523]         {
[16:21:03.523]             ...future.startTime <- base::Sys.time()
[16:21:03.523]             {
[16:21:03.523]                 {
[16:21:03.523]                   {
[16:21:03.523]                     base::local({
[16:21:03.523]                       has_future <- base::requireNamespace("future", 
[16:21:03.523]                         quietly = TRUE)
[16:21:03.523]                       if (has_future) {
[16:21:03.523]                         ns <- base::getNamespace("future")
[16:21:03.523]                         version <- ns[[".package"]][["version"]]
[16:21:03.523]                         if (is.null(version)) 
[16:21:03.523]                           version <- utils::packageVersion("future")
[16:21:03.523]                       }
[16:21:03.523]                       else {
[16:21:03.523]                         version <- NULL
[16:21:03.523]                       }
[16:21:03.523]                       if (!has_future || version < "1.8.0") {
[16:21:03.523]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.523]                           "", base::R.version$version.string), 
[16:21:03.523]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.523]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.523]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.523]                             "release", "version")], collapse = " "), 
[16:21:03.523]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.523]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.523]                           info)
[16:21:03.523]                         info <- base::paste(info, collapse = "; ")
[16:21:03.523]                         if (!has_future) {
[16:21:03.523]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.523]                             info)
[16:21:03.523]                         }
[16:21:03.523]                         else {
[16:21:03.523]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.523]                             info, version)
[16:21:03.523]                         }
[16:21:03.523]                         base::stop(msg)
[16:21:03.523]                       }
[16:21:03.523]                     })
[16:21:03.523]                   }
[16:21:03.523]                   ...future.strategy.old <- future::plan("list")
[16:21:03.523]                   options(future.plan = NULL)
[16:21:03.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.523]                 }
[16:21:03.523]                 ...future.workdir <- getwd()
[16:21:03.523]             }
[16:21:03.523]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.523]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.523]         }
[16:21:03.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.523]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.523]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.523]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.523]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.523]             base::names(...future.oldOptions))
[16:21:03.523]     }
[16:21:03.523]     if (FALSE) {
[16:21:03.523]     }
[16:21:03.523]     else {
[16:21:03.523]         if (TRUE) {
[16:21:03.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.523]                 open = "w")
[16:21:03.523]         }
[16:21:03.523]         else {
[16:21:03.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.523]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.523]         }
[16:21:03.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.523]             base::sink(type = "output", split = FALSE)
[16:21:03.523]             base::close(...future.stdout)
[16:21:03.523]         }, add = TRUE)
[16:21:03.523]     }
[16:21:03.523]     ...future.frame <- base::sys.nframe()
[16:21:03.523]     ...future.conditions <- base::list()
[16:21:03.523]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.523]     if (FALSE) {
[16:21:03.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.523]     }
[16:21:03.523]     ...future.result <- base::tryCatch({
[16:21:03.523]         base::withCallingHandlers({
[16:21:03.523]             ...future.value <- base::withVisible(base::local({
[16:21:03.523]                 b <- a * ii
[16:21:03.523]                 a <- 0
[16:21:03.523]                 b
[16:21:03.523]             }))
[16:21:03.523]             future::FutureResult(value = ...future.value$value, 
[16:21:03.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.523]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.523]                     ...future.globalenv.names))
[16:21:03.523]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.523]         }, condition = base::local({
[16:21:03.523]             c <- base::c
[16:21:03.523]             inherits <- base::inherits
[16:21:03.523]             invokeRestart <- base::invokeRestart
[16:21:03.523]             length <- base::length
[16:21:03.523]             list <- base::list
[16:21:03.523]             seq.int <- base::seq.int
[16:21:03.523]             signalCondition <- base::signalCondition
[16:21:03.523]             sys.calls <- base::sys.calls
[16:21:03.523]             `[[` <- base::`[[`
[16:21:03.523]             `+` <- base::`+`
[16:21:03.523]             `<<-` <- base::`<<-`
[16:21:03.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.523]                   3L)]
[16:21:03.523]             }
[16:21:03.523]             function(cond) {
[16:21:03.523]                 is_error <- inherits(cond, "error")
[16:21:03.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.523]                   NULL)
[16:21:03.523]                 if (is_error) {
[16:21:03.523]                   sessionInformation <- function() {
[16:21:03.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.523]                       search = base::search(), system = base::Sys.info())
[16:21:03.523]                   }
[16:21:03.523]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.523]                     cond$call), session = sessionInformation(), 
[16:21:03.523]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.523]                   signalCondition(cond)
[16:21:03.523]                 }
[16:21:03.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.523]                 "immediateCondition"))) {
[16:21:03.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.523]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.523]                   if (TRUE && !signal) {
[16:21:03.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.523]                     {
[16:21:03.523]                       inherits <- base::inherits
[16:21:03.523]                       invokeRestart <- base::invokeRestart
[16:21:03.523]                       is.null <- base::is.null
[16:21:03.523]                       muffled <- FALSE
[16:21:03.523]                       if (inherits(cond, "message")) {
[16:21:03.523]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.523]                         if (muffled) 
[16:21:03.523]                           invokeRestart("muffleMessage")
[16:21:03.523]                       }
[16:21:03.523]                       else if (inherits(cond, "warning")) {
[16:21:03.523]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.523]                         if (muffled) 
[16:21:03.523]                           invokeRestart("muffleWarning")
[16:21:03.523]                       }
[16:21:03.523]                       else if (inherits(cond, "condition")) {
[16:21:03.523]                         if (!is.null(pattern)) {
[16:21:03.523]                           computeRestarts <- base::computeRestarts
[16:21:03.523]                           grepl <- base::grepl
[16:21:03.523]                           restarts <- computeRestarts(cond)
[16:21:03.523]                           for (restart in restarts) {
[16:21:03.523]                             name <- restart$name
[16:21:03.523]                             if (is.null(name)) 
[16:21:03.523]                               next
[16:21:03.523]                             if (!grepl(pattern, name)) 
[16:21:03.523]                               next
[16:21:03.523]                             invokeRestart(restart)
[16:21:03.523]                             muffled <- TRUE
[16:21:03.523]                             break
[16:21:03.523]                           }
[16:21:03.523]                         }
[16:21:03.523]                       }
[16:21:03.523]                       invisible(muffled)
[16:21:03.523]                     }
[16:21:03.523]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.523]                   }
[16:21:03.523]                 }
[16:21:03.523]                 else {
[16:21:03.523]                   if (TRUE) {
[16:21:03.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.523]                     {
[16:21:03.523]                       inherits <- base::inherits
[16:21:03.523]                       invokeRestart <- base::invokeRestart
[16:21:03.523]                       is.null <- base::is.null
[16:21:03.523]                       muffled <- FALSE
[16:21:03.523]                       if (inherits(cond, "message")) {
[16:21:03.523]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.523]                         if (muffled) 
[16:21:03.523]                           invokeRestart("muffleMessage")
[16:21:03.523]                       }
[16:21:03.523]                       else if (inherits(cond, "warning")) {
[16:21:03.523]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.523]                         if (muffled) 
[16:21:03.523]                           invokeRestart("muffleWarning")
[16:21:03.523]                       }
[16:21:03.523]                       else if (inherits(cond, "condition")) {
[16:21:03.523]                         if (!is.null(pattern)) {
[16:21:03.523]                           computeRestarts <- base::computeRestarts
[16:21:03.523]                           grepl <- base::grepl
[16:21:03.523]                           restarts <- computeRestarts(cond)
[16:21:03.523]                           for (restart in restarts) {
[16:21:03.523]                             name <- restart$name
[16:21:03.523]                             if (is.null(name)) 
[16:21:03.523]                               next
[16:21:03.523]                             if (!grepl(pattern, name)) 
[16:21:03.523]                               next
[16:21:03.523]                             invokeRestart(restart)
[16:21:03.523]                             muffled <- TRUE
[16:21:03.523]                             break
[16:21:03.523]                           }
[16:21:03.523]                         }
[16:21:03.523]                       }
[16:21:03.523]                       invisible(muffled)
[16:21:03.523]                     }
[16:21:03.523]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.523]                   }
[16:21:03.523]                 }
[16:21:03.523]             }
[16:21:03.523]         }))
[16:21:03.523]     }, error = function(ex) {
[16:21:03.523]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.523]                 ...future.rng), started = ...future.startTime, 
[16:21:03.523]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.523]             version = "1.8"), class = "FutureResult")
[16:21:03.523]     }, finally = {
[16:21:03.523]         if (!identical(...future.workdir, getwd())) 
[16:21:03.523]             setwd(...future.workdir)
[16:21:03.523]         {
[16:21:03.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.523]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.523]             }
[16:21:03.523]             base::options(...future.oldOptions)
[16:21:03.523]             if (.Platform$OS.type == "windows") {
[16:21:03.523]                 old_names <- names(...future.oldEnvVars)
[16:21:03.523]                 envs <- base::Sys.getenv()
[16:21:03.523]                 names <- names(envs)
[16:21:03.523]                 common <- intersect(names, old_names)
[16:21:03.523]                 added <- setdiff(names, old_names)
[16:21:03.523]                 removed <- setdiff(old_names, names)
[16:21:03.523]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.523]                   envs[common]]
[16:21:03.523]                 NAMES <- toupper(changed)
[16:21:03.523]                 args <- list()
[16:21:03.523]                 for (kk in seq_along(NAMES)) {
[16:21:03.523]                   name <- changed[[kk]]
[16:21:03.523]                   NAME <- NAMES[[kk]]
[16:21:03.523]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.523]                     next
[16:21:03.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.523]                 }
[16:21:03.523]                 NAMES <- toupper(added)
[16:21:03.523]                 for (kk in seq_along(NAMES)) {
[16:21:03.523]                   name <- added[[kk]]
[16:21:03.523]                   NAME <- NAMES[[kk]]
[16:21:03.523]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.523]                     next
[16:21:03.523]                   args[[name]] <- ""
[16:21:03.523]                 }
[16:21:03.523]                 NAMES <- toupper(removed)
[16:21:03.523]                 for (kk in seq_along(NAMES)) {
[16:21:03.523]                   name <- removed[[kk]]
[16:21:03.523]                   NAME <- NAMES[[kk]]
[16:21:03.523]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.523]                     next
[16:21:03.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.523]                 }
[16:21:03.523]                 if (length(args) > 0) 
[16:21:03.523]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.523]             }
[16:21:03.523]             else {
[16:21:03.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.523]             }
[16:21:03.523]             {
[16:21:03.523]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.523]                   0L) {
[16:21:03.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.523]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.523]                   base::options(opts)
[16:21:03.523]                 }
[16:21:03.523]                 {
[16:21:03.523]                   {
[16:21:03.523]                     NULL
[16:21:03.523]                     RNGkind("Mersenne-Twister")
[16:21:03.523]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.523]                       inherits = FALSE)
[16:21:03.523]                   }
[16:21:03.523]                   options(future.plan = NULL)
[16:21:03.523]                   if (is.na(NA_character_)) 
[16:21:03.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.523]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.523]                     .init = FALSE)
[16:21:03.523]                 }
[16:21:03.523]             }
[16:21:03.523]         }
[16:21:03.523]     })
[16:21:03.523]     if (TRUE) {
[16:21:03.523]         base::sink(type = "output", split = FALSE)
[16:21:03.523]         if (TRUE) {
[16:21:03.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.523]         }
[16:21:03.523]         else {
[16:21:03.523]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.523]         }
[16:21:03.523]         base::close(...future.stdout)
[16:21:03.523]         ...future.stdout <- NULL
[16:21:03.523]     }
[16:21:03.523]     ...future.result$conditions <- ...future.conditions
[16:21:03.523]     ...future.result$finished <- base::Sys.time()
[16:21:03.523]     ...future.result
[16:21:03.523] }
[16:21:03.524] assign_globals() ...
[16:21:03.524] List of 2
[16:21:03.524]  $ a : num 1
[16:21:03.524]  $ ii: int 1
[16:21:03.524]  - attr(*, "where")=List of 2
[16:21:03.524]   ..$ a :<environment: R_EmptyEnv> 
[16:21:03.524]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.524]  - attr(*, "resolved")= logi TRUE
[16:21:03.524]  - attr(*, "total_size")= num 112
[16:21:03.524]  - attr(*, "already-done")= logi TRUE
[16:21:03.527] - copied ‘a’ to environment
[16:21:03.527] - copied ‘ii’ to environment
[16:21:03.528] assign_globals() ... done
[16:21:03.528] plan(): Setting new future strategy stack:
[16:21:03.528] List of future strategies:
[16:21:03.528] 1. sequential:
[16:21:03.528]    - args: function (..., envir = parent.frame())
[16:21:03.528]    - tweaked: FALSE
[16:21:03.528]    - call: NULL
[16:21:03.528] plan(): nbrOfWorkers() = 1
[16:21:03.529] plan(): Setting new future strategy stack:
[16:21:03.529] List of future strategies:
[16:21:03.529] 1. sequential:
[16:21:03.529]    - args: function (..., envir = parent.frame())
[16:21:03.529]    - tweaked: FALSE
[16:21:03.529]    - call: plan(strategy)
[16:21:03.529] plan(): nbrOfWorkers() = 1
[16:21:03.530] SequentialFuture started (and completed)
[16:21:03.530] - Launch lazy future ... done
[16:21:03.530] run() for ‘SequentialFuture’ ... done
[16:21:03.530] run() for ‘Future’ ...
[16:21:03.530] - state: ‘created’
[16:21:03.530] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.531] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.531] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.531]   - Field: ‘label’
[16:21:03.531]   - Field: ‘local’
[16:21:03.531]   - Field: ‘owner’
[16:21:03.531]   - Field: ‘envir’
[16:21:03.531]   - Field: ‘packages’
[16:21:03.531]   - Field: ‘gc’
[16:21:03.531]   - Field: ‘conditions’
[16:21:03.531]   - Field: ‘expr’
[16:21:03.532]   - Field: ‘uuid’
[16:21:03.532]   - Field: ‘seed’
[16:21:03.532]   - Field: ‘version’
[16:21:03.532]   - Field: ‘result’
[16:21:03.532]   - Field: ‘asynchronous’
[16:21:03.534]   - Field: ‘calls’
[16:21:03.534]   - Field: ‘globals’
[16:21:03.534]   - Field: ‘stdout’
[16:21:03.534]   - Field: ‘earlySignal’
[16:21:03.534]   - Field: ‘lazy’
[16:21:03.534]   - Field: ‘state’
[16:21:03.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.534] - Launch lazy future ...
[16:21:03.535] Packages needed by the future expression (n = 0): <none>
[16:21:03.535] Packages needed by future strategies (n = 0): <none>
[16:21:03.535] {
[16:21:03.535]     {
[16:21:03.535]         {
[16:21:03.535]             ...future.startTime <- base::Sys.time()
[16:21:03.535]             {
[16:21:03.535]                 {
[16:21:03.535]                   {
[16:21:03.535]                     base::local({
[16:21:03.535]                       has_future <- base::requireNamespace("future", 
[16:21:03.535]                         quietly = TRUE)
[16:21:03.535]                       if (has_future) {
[16:21:03.535]                         ns <- base::getNamespace("future")
[16:21:03.535]                         version <- ns[[".package"]][["version"]]
[16:21:03.535]                         if (is.null(version)) 
[16:21:03.535]                           version <- utils::packageVersion("future")
[16:21:03.535]                       }
[16:21:03.535]                       else {
[16:21:03.535]                         version <- NULL
[16:21:03.535]                       }
[16:21:03.535]                       if (!has_future || version < "1.8.0") {
[16:21:03.535]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.535]                           "", base::R.version$version.string), 
[16:21:03.535]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.535]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.535]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.535]                             "release", "version")], collapse = " "), 
[16:21:03.535]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.535]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.535]                           info)
[16:21:03.535]                         info <- base::paste(info, collapse = "; ")
[16:21:03.535]                         if (!has_future) {
[16:21:03.535]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.535]                             info)
[16:21:03.535]                         }
[16:21:03.535]                         else {
[16:21:03.535]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.535]                             info, version)
[16:21:03.535]                         }
[16:21:03.535]                         base::stop(msg)
[16:21:03.535]                       }
[16:21:03.535]                     })
[16:21:03.535]                   }
[16:21:03.535]                   ...future.strategy.old <- future::plan("list")
[16:21:03.535]                   options(future.plan = NULL)
[16:21:03.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.535]                 }
[16:21:03.535]                 ...future.workdir <- getwd()
[16:21:03.535]             }
[16:21:03.535]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.535]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.535]         }
[16:21:03.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.535]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.535]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.535]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.535]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.535]             base::names(...future.oldOptions))
[16:21:03.535]     }
[16:21:03.535]     if (FALSE) {
[16:21:03.535]     }
[16:21:03.535]     else {
[16:21:03.535]         if (TRUE) {
[16:21:03.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.535]                 open = "w")
[16:21:03.535]         }
[16:21:03.535]         else {
[16:21:03.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.535]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.535]         }
[16:21:03.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.535]             base::sink(type = "output", split = FALSE)
[16:21:03.535]             base::close(...future.stdout)
[16:21:03.535]         }, add = TRUE)
[16:21:03.535]     }
[16:21:03.535]     ...future.frame <- base::sys.nframe()
[16:21:03.535]     ...future.conditions <- base::list()
[16:21:03.535]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.535]     if (FALSE) {
[16:21:03.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.535]     }
[16:21:03.535]     ...future.result <- base::tryCatch({
[16:21:03.535]         base::withCallingHandlers({
[16:21:03.535]             ...future.value <- base::withVisible(base::local({
[16:21:03.535]                 b <- a * ii
[16:21:03.535]                 a <- 0
[16:21:03.535]                 b
[16:21:03.535]             }))
[16:21:03.535]             future::FutureResult(value = ...future.value$value, 
[16:21:03.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.535]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.535]                     ...future.globalenv.names))
[16:21:03.535]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.535]         }, condition = base::local({
[16:21:03.535]             c <- base::c
[16:21:03.535]             inherits <- base::inherits
[16:21:03.535]             invokeRestart <- base::invokeRestart
[16:21:03.535]             length <- base::length
[16:21:03.535]             list <- base::list
[16:21:03.535]             seq.int <- base::seq.int
[16:21:03.535]             signalCondition <- base::signalCondition
[16:21:03.535]             sys.calls <- base::sys.calls
[16:21:03.535]             `[[` <- base::`[[`
[16:21:03.535]             `+` <- base::`+`
[16:21:03.535]             `<<-` <- base::`<<-`
[16:21:03.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.535]                   3L)]
[16:21:03.535]             }
[16:21:03.535]             function(cond) {
[16:21:03.535]                 is_error <- inherits(cond, "error")
[16:21:03.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.535]                   NULL)
[16:21:03.535]                 if (is_error) {
[16:21:03.535]                   sessionInformation <- function() {
[16:21:03.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.535]                       search = base::search(), system = base::Sys.info())
[16:21:03.535]                   }
[16:21:03.535]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.535]                     cond$call), session = sessionInformation(), 
[16:21:03.535]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.535]                   signalCondition(cond)
[16:21:03.535]                 }
[16:21:03.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.535]                 "immediateCondition"))) {
[16:21:03.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.535]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.535]                   if (TRUE && !signal) {
[16:21:03.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.535]                     {
[16:21:03.535]                       inherits <- base::inherits
[16:21:03.535]                       invokeRestart <- base::invokeRestart
[16:21:03.535]                       is.null <- base::is.null
[16:21:03.535]                       muffled <- FALSE
[16:21:03.535]                       if (inherits(cond, "message")) {
[16:21:03.535]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.535]                         if (muffled) 
[16:21:03.535]                           invokeRestart("muffleMessage")
[16:21:03.535]                       }
[16:21:03.535]                       else if (inherits(cond, "warning")) {
[16:21:03.535]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.535]                         if (muffled) 
[16:21:03.535]                           invokeRestart("muffleWarning")
[16:21:03.535]                       }
[16:21:03.535]                       else if (inherits(cond, "condition")) {
[16:21:03.535]                         if (!is.null(pattern)) {
[16:21:03.535]                           computeRestarts <- base::computeRestarts
[16:21:03.535]                           grepl <- base::grepl
[16:21:03.535]                           restarts <- computeRestarts(cond)
[16:21:03.535]                           for (restart in restarts) {
[16:21:03.535]                             name <- restart$name
[16:21:03.535]                             if (is.null(name)) 
[16:21:03.535]                               next
[16:21:03.535]                             if (!grepl(pattern, name)) 
[16:21:03.535]                               next
[16:21:03.535]                             invokeRestart(restart)
[16:21:03.535]                             muffled <- TRUE
[16:21:03.535]                             break
[16:21:03.535]                           }
[16:21:03.535]                         }
[16:21:03.535]                       }
[16:21:03.535]                       invisible(muffled)
[16:21:03.535]                     }
[16:21:03.535]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.535]                   }
[16:21:03.535]                 }
[16:21:03.535]                 else {
[16:21:03.535]                   if (TRUE) {
[16:21:03.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.535]                     {
[16:21:03.535]                       inherits <- base::inherits
[16:21:03.535]                       invokeRestart <- base::invokeRestart
[16:21:03.535]                       is.null <- base::is.null
[16:21:03.535]                       muffled <- FALSE
[16:21:03.535]                       if (inherits(cond, "message")) {
[16:21:03.535]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.535]                         if (muffled) 
[16:21:03.535]                           invokeRestart("muffleMessage")
[16:21:03.535]                       }
[16:21:03.535]                       else if (inherits(cond, "warning")) {
[16:21:03.535]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.535]                         if (muffled) 
[16:21:03.535]                           invokeRestart("muffleWarning")
[16:21:03.535]                       }
[16:21:03.535]                       else if (inherits(cond, "condition")) {
[16:21:03.535]                         if (!is.null(pattern)) {
[16:21:03.535]                           computeRestarts <- base::computeRestarts
[16:21:03.535]                           grepl <- base::grepl
[16:21:03.535]                           restarts <- computeRestarts(cond)
[16:21:03.535]                           for (restart in restarts) {
[16:21:03.535]                             name <- restart$name
[16:21:03.535]                             if (is.null(name)) 
[16:21:03.535]                               next
[16:21:03.535]                             if (!grepl(pattern, name)) 
[16:21:03.535]                               next
[16:21:03.535]                             invokeRestart(restart)
[16:21:03.535]                             muffled <- TRUE
[16:21:03.535]                             break
[16:21:03.535]                           }
[16:21:03.535]                         }
[16:21:03.535]                       }
[16:21:03.535]                       invisible(muffled)
[16:21:03.535]                     }
[16:21:03.535]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.535]                   }
[16:21:03.535]                 }
[16:21:03.535]             }
[16:21:03.535]         }))
[16:21:03.535]     }, error = function(ex) {
[16:21:03.535]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.535]                 ...future.rng), started = ...future.startTime, 
[16:21:03.535]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.535]             version = "1.8"), class = "FutureResult")
[16:21:03.535]     }, finally = {
[16:21:03.535]         if (!identical(...future.workdir, getwd())) 
[16:21:03.535]             setwd(...future.workdir)
[16:21:03.535]         {
[16:21:03.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.535]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.535]             }
[16:21:03.535]             base::options(...future.oldOptions)
[16:21:03.535]             if (.Platform$OS.type == "windows") {
[16:21:03.535]                 old_names <- names(...future.oldEnvVars)
[16:21:03.535]                 envs <- base::Sys.getenv()
[16:21:03.535]                 names <- names(envs)
[16:21:03.535]                 common <- intersect(names, old_names)
[16:21:03.535]                 added <- setdiff(names, old_names)
[16:21:03.535]                 removed <- setdiff(old_names, names)
[16:21:03.535]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.535]                   envs[common]]
[16:21:03.535]                 NAMES <- toupper(changed)
[16:21:03.535]                 args <- list()
[16:21:03.535]                 for (kk in seq_along(NAMES)) {
[16:21:03.535]                   name <- changed[[kk]]
[16:21:03.535]                   NAME <- NAMES[[kk]]
[16:21:03.535]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.535]                     next
[16:21:03.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.535]                 }
[16:21:03.535]                 NAMES <- toupper(added)
[16:21:03.535]                 for (kk in seq_along(NAMES)) {
[16:21:03.535]                   name <- added[[kk]]
[16:21:03.535]                   NAME <- NAMES[[kk]]
[16:21:03.535]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.535]                     next
[16:21:03.535]                   args[[name]] <- ""
[16:21:03.535]                 }
[16:21:03.535]                 NAMES <- toupper(removed)
[16:21:03.535]                 for (kk in seq_along(NAMES)) {
[16:21:03.535]                   name <- removed[[kk]]
[16:21:03.535]                   NAME <- NAMES[[kk]]
[16:21:03.535]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.535]                     next
[16:21:03.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.535]                 }
[16:21:03.535]                 if (length(args) > 0) 
[16:21:03.535]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.535]             }
[16:21:03.535]             else {
[16:21:03.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.535]             }
[16:21:03.535]             {
[16:21:03.535]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.535]                   0L) {
[16:21:03.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.535]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.535]                   base::options(opts)
[16:21:03.535]                 }
[16:21:03.535]                 {
[16:21:03.535]                   {
[16:21:03.535]                     NULL
[16:21:03.535]                     RNGkind("Mersenne-Twister")
[16:21:03.535]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.535]                       inherits = FALSE)
[16:21:03.535]                   }
[16:21:03.535]                   options(future.plan = NULL)
[16:21:03.535]                   if (is.na(NA_character_)) 
[16:21:03.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.535]                     .init = FALSE)
[16:21:03.535]                 }
[16:21:03.535]             }
[16:21:03.535]         }
[16:21:03.535]     })
[16:21:03.535]     if (TRUE) {
[16:21:03.535]         base::sink(type = "output", split = FALSE)
[16:21:03.535]         if (TRUE) {
[16:21:03.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.535]         }
[16:21:03.535]         else {
[16:21:03.535]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.535]         }
[16:21:03.535]         base::close(...future.stdout)
[16:21:03.535]         ...future.stdout <- NULL
[16:21:03.535]     }
[16:21:03.535]     ...future.result$conditions <- ...future.conditions
[16:21:03.535]     ...future.result$finished <- base::Sys.time()
[16:21:03.535]     ...future.result
[16:21:03.535] }
[16:21:03.537] assign_globals() ...
[16:21:03.537] List of 2
[16:21:03.537]  $ a : num 1
[16:21:03.537]  $ ii: int 2
[16:21:03.537]  - attr(*, "where")=List of 2
[16:21:03.537]   ..$ a :<environment: R_EmptyEnv> 
[16:21:03.537]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.537]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.537]  - attr(*, "resolved")= logi TRUE
[16:21:03.537]  - attr(*, "total_size")= num 112
[16:21:03.537]  - attr(*, "already-done")= logi TRUE
[16:21:03.540] - copied ‘a’ to environment
[16:21:03.540] - copied ‘ii’ to environment
[16:21:03.540] assign_globals() ... done
[16:21:03.540] plan(): Setting new future strategy stack:
[16:21:03.540] List of future strategies:
[16:21:03.540] 1. sequential:
[16:21:03.540]    - args: function (..., envir = parent.frame())
[16:21:03.540]    - tweaked: FALSE
[16:21:03.540]    - call: NULL
[16:21:03.541] plan(): nbrOfWorkers() = 1
[16:21:03.541] plan(): Setting new future strategy stack:
[16:21:03.542] List of future strategies:
[16:21:03.542] 1. sequential:
[16:21:03.542]    - args: function (..., envir = parent.frame())
[16:21:03.542]    - tweaked: FALSE
[16:21:03.542]    - call: plan(strategy)
[16:21:03.542] plan(): nbrOfWorkers() = 1
[16:21:03.542] SequentialFuture started (and completed)
[16:21:03.542] - Launch lazy future ... done
[16:21:03.542] run() for ‘SequentialFuture’ ... done
[16:21:03.542] run() for ‘Future’ ...
[16:21:03.543] - state: ‘created’
[16:21:03.543] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.543] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.543]   - Field: ‘label’
[16:21:03.543]   - Field: ‘local’
[16:21:03.543]   - Field: ‘owner’
[16:21:03.543]   - Field: ‘envir’
[16:21:03.544]   - Field: ‘packages’
[16:21:03.544]   - Field: ‘gc’
[16:21:03.544]   - Field: ‘conditions’
[16:21:03.544]   - Field: ‘expr’
[16:21:03.544]   - Field: ‘uuid’
[16:21:03.544]   - Field: ‘seed’
[16:21:03.544]   - Field: ‘version’
[16:21:03.544]   - Field: ‘result’
[16:21:03.544]   - Field: ‘asynchronous’
[16:21:03.544]   - Field: ‘calls’
[16:21:03.545]   - Field: ‘globals’
[16:21:03.545]   - Field: ‘stdout’
[16:21:03.545]   - Field: ‘earlySignal’
[16:21:03.545]   - Field: ‘lazy’
[16:21:03.545]   - Field: ‘state’
[16:21:03.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.545] - Launch lazy future ...
[16:21:03.545] Packages needed by the future expression (n = 0): <none>
[16:21:03.545] Packages needed by future strategies (n = 0): <none>
[16:21:03.546] {
[16:21:03.546]     {
[16:21:03.546]         {
[16:21:03.546]             ...future.startTime <- base::Sys.time()
[16:21:03.546]             {
[16:21:03.546]                 {
[16:21:03.546]                   {
[16:21:03.546]                     base::local({
[16:21:03.546]                       has_future <- base::requireNamespace("future", 
[16:21:03.546]                         quietly = TRUE)
[16:21:03.546]                       if (has_future) {
[16:21:03.546]                         ns <- base::getNamespace("future")
[16:21:03.546]                         version <- ns[[".package"]][["version"]]
[16:21:03.546]                         if (is.null(version)) 
[16:21:03.546]                           version <- utils::packageVersion("future")
[16:21:03.546]                       }
[16:21:03.546]                       else {
[16:21:03.546]                         version <- NULL
[16:21:03.546]                       }
[16:21:03.546]                       if (!has_future || version < "1.8.0") {
[16:21:03.546]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.546]                           "", base::R.version$version.string), 
[16:21:03.546]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.546]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.546]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.546]                             "release", "version")], collapse = " "), 
[16:21:03.546]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.546]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.546]                           info)
[16:21:03.546]                         info <- base::paste(info, collapse = "; ")
[16:21:03.546]                         if (!has_future) {
[16:21:03.546]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.546]                             info)
[16:21:03.546]                         }
[16:21:03.546]                         else {
[16:21:03.546]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.546]                             info, version)
[16:21:03.546]                         }
[16:21:03.546]                         base::stop(msg)
[16:21:03.546]                       }
[16:21:03.546]                     })
[16:21:03.546]                   }
[16:21:03.546]                   ...future.strategy.old <- future::plan("list")
[16:21:03.546]                   options(future.plan = NULL)
[16:21:03.546]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.546]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.546]                 }
[16:21:03.546]                 ...future.workdir <- getwd()
[16:21:03.546]             }
[16:21:03.546]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.546]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.546]         }
[16:21:03.546]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.546]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.546]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.546]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.546]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.546]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.546]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.546]             base::names(...future.oldOptions))
[16:21:03.546]     }
[16:21:03.546]     if (FALSE) {
[16:21:03.546]     }
[16:21:03.546]     else {
[16:21:03.546]         if (TRUE) {
[16:21:03.546]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.546]                 open = "w")
[16:21:03.546]         }
[16:21:03.546]         else {
[16:21:03.546]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.546]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.546]         }
[16:21:03.546]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.546]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.546]             base::sink(type = "output", split = FALSE)
[16:21:03.546]             base::close(...future.stdout)
[16:21:03.546]         }, add = TRUE)
[16:21:03.546]     }
[16:21:03.546]     ...future.frame <- base::sys.nframe()
[16:21:03.546]     ...future.conditions <- base::list()
[16:21:03.546]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.546]     if (FALSE) {
[16:21:03.546]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.546]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.546]     }
[16:21:03.546]     ...future.result <- base::tryCatch({
[16:21:03.546]         base::withCallingHandlers({
[16:21:03.546]             ...future.value <- base::withVisible(base::local({
[16:21:03.546]                 b <- a * ii
[16:21:03.546]                 a <- 0
[16:21:03.546]                 b
[16:21:03.546]             }))
[16:21:03.546]             future::FutureResult(value = ...future.value$value, 
[16:21:03.546]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.546]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.546]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.546]                     ...future.globalenv.names))
[16:21:03.546]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.546]         }, condition = base::local({
[16:21:03.546]             c <- base::c
[16:21:03.546]             inherits <- base::inherits
[16:21:03.546]             invokeRestart <- base::invokeRestart
[16:21:03.546]             length <- base::length
[16:21:03.546]             list <- base::list
[16:21:03.546]             seq.int <- base::seq.int
[16:21:03.546]             signalCondition <- base::signalCondition
[16:21:03.546]             sys.calls <- base::sys.calls
[16:21:03.546]             `[[` <- base::`[[`
[16:21:03.546]             `+` <- base::`+`
[16:21:03.546]             `<<-` <- base::`<<-`
[16:21:03.546]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.546]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.546]                   3L)]
[16:21:03.546]             }
[16:21:03.546]             function(cond) {
[16:21:03.546]                 is_error <- inherits(cond, "error")
[16:21:03.546]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.546]                   NULL)
[16:21:03.546]                 if (is_error) {
[16:21:03.546]                   sessionInformation <- function() {
[16:21:03.546]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.546]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.546]                       search = base::search(), system = base::Sys.info())
[16:21:03.546]                   }
[16:21:03.546]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.546]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.546]                     cond$call), session = sessionInformation(), 
[16:21:03.546]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.546]                   signalCondition(cond)
[16:21:03.546]                 }
[16:21:03.546]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.546]                 "immediateCondition"))) {
[16:21:03.546]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.546]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.546]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.546]                   if (TRUE && !signal) {
[16:21:03.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.546]                     {
[16:21:03.546]                       inherits <- base::inherits
[16:21:03.546]                       invokeRestart <- base::invokeRestart
[16:21:03.546]                       is.null <- base::is.null
[16:21:03.546]                       muffled <- FALSE
[16:21:03.546]                       if (inherits(cond, "message")) {
[16:21:03.546]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.546]                         if (muffled) 
[16:21:03.546]                           invokeRestart("muffleMessage")
[16:21:03.546]                       }
[16:21:03.546]                       else if (inherits(cond, "warning")) {
[16:21:03.546]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.546]                         if (muffled) 
[16:21:03.546]                           invokeRestart("muffleWarning")
[16:21:03.546]                       }
[16:21:03.546]                       else if (inherits(cond, "condition")) {
[16:21:03.546]                         if (!is.null(pattern)) {
[16:21:03.546]                           computeRestarts <- base::computeRestarts
[16:21:03.546]                           grepl <- base::grepl
[16:21:03.546]                           restarts <- computeRestarts(cond)
[16:21:03.546]                           for (restart in restarts) {
[16:21:03.546]                             name <- restart$name
[16:21:03.546]                             if (is.null(name)) 
[16:21:03.546]                               next
[16:21:03.546]                             if (!grepl(pattern, name)) 
[16:21:03.546]                               next
[16:21:03.546]                             invokeRestart(restart)
[16:21:03.546]                             muffled <- TRUE
[16:21:03.546]                             break
[16:21:03.546]                           }
[16:21:03.546]                         }
[16:21:03.546]                       }
[16:21:03.546]                       invisible(muffled)
[16:21:03.546]                     }
[16:21:03.546]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.546]                   }
[16:21:03.546]                 }
[16:21:03.546]                 else {
[16:21:03.546]                   if (TRUE) {
[16:21:03.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.546]                     {
[16:21:03.546]                       inherits <- base::inherits
[16:21:03.546]                       invokeRestart <- base::invokeRestart
[16:21:03.546]                       is.null <- base::is.null
[16:21:03.546]                       muffled <- FALSE
[16:21:03.546]                       if (inherits(cond, "message")) {
[16:21:03.546]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.546]                         if (muffled) 
[16:21:03.546]                           invokeRestart("muffleMessage")
[16:21:03.546]                       }
[16:21:03.546]                       else if (inherits(cond, "warning")) {
[16:21:03.546]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.546]                         if (muffled) 
[16:21:03.546]                           invokeRestart("muffleWarning")
[16:21:03.546]                       }
[16:21:03.546]                       else if (inherits(cond, "condition")) {
[16:21:03.546]                         if (!is.null(pattern)) {
[16:21:03.546]                           computeRestarts <- base::computeRestarts
[16:21:03.546]                           grepl <- base::grepl
[16:21:03.546]                           restarts <- computeRestarts(cond)
[16:21:03.546]                           for (restart in restarts) {
[16:21:03.546]                             name <- restart$name
[16:21:03.546]                             if (is.null(name)) 
[16:21:03.546]                               next
[16:21:03.546]                             if (!grepl(pattern, name)) 
[16:21:03.546]                               next
[16:21:03.546]                             invokeRestart(restart)
[16:21:03.546]                             muffled <- TRUE
[16:21:03.546]                             break
[16:21:03.546]                           }
[16:21:03.546]                         }
[16:21:03.546]                       }
[16:21:03.546]                       invisible(muffled)
[16:21:03.546]                     }
[16:21:03.546]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.546]                   }
[16:21:03.546]                 }
[16:21:03.546]             }
[16:21:03.546]         }))
[16:21:03.546]     }, error = function(ex) {
[16:21:03.546]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.546]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.546]                 ...future.rng), started = ...future.startTime, 
[16:21:03.546]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.546]             version = "1.8"), class = "FutureResult")
[16:21:03.546]     }, finally = {
[16:21:03.546]         if (!identical(...future.workdir, getwd())) 
[16:21:03.546]             setwd(...future.workdir)
[16:21:03.546]         {
[16:21:03.546]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.546]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.546]             }
[16:21:03.546]             base::options(...future.oldOptions)
[16:21:03.546]             if (.Platform$OS.type == "windows") {
[16:21:03.546]                 old_names <- names(...future.oldEnvVars)
[16:21:03.546]                 envs <- base::Sys.getenv()
[16:21:03.546]                 names <- names(envs)
[16:21:03.546]                 common <- intersect(names, old_names)
[16:21:03.546]                 added <- setdiff(names, old_names)
[16:21:03.546]                 removed <- setdiff(old_names, names)
[16:21:03.546]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.546]                   envs[common]]
[16:21:03.546]                 NAMES <- toupper(changed)
[16:21:03.546]                 args <- list()
[16:21:03.546]                 for (kk in seq_along(NAMES)) {
[16:21:03.546]                   name <- changed[[kk]]
[16:21:03.546]                   NAME <- NAMES[[kk]]
[16:21:03.546]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.546]                     next
[16:21:03.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.546]                 }
[16:21:03.546]                 NAMES <- toupper(added)
[16:21:03.546]                 for (kk in seq_along(NAMES)) {
[16:21:03.546]                   name <- added[[kk]]
[16:21:03.546]                   NAME <- NAMES[[kk]]
[16:21:03.546]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.546]                     next
[16:21:03.546]                   args[[name]] <- ""
[16:21:03.546]                 }
[16:21:03.546]                 NAMES <- toupper(removed)
[16:21:03.546]                 for (kk in seq_along(NAMES)) {
[16:21:03.546]                   name <- removed[[kk]]
[16:21:03.546]                   NAME <- NAMES[[kk]]
[16:21:03.546]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.546]                     next
[16:21:03.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.546]                 }
[16:21:03.546]                 if (length(args) > 0) 
[16:21:03.546]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.546]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.546]             }
[16:21:03.546]             else {
[16:21:03.546]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.546]             }
[16:21:03.546]             {
[16:21:03.546]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.546]                   0L) {
[16:21:03.546]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.546]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.546]                   base::options(opts)
[16:21:03.546]                 }
[16:21:03.546]                 {
[16:21:03.546]                   {
[16:21:03.546]                     NULL
[16:21:03.546]                     RNGkind("Mersenne-Twister")
[16:21:03.546]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.546]                       inherits = FALSE)
[16:21:03.546]                   }
[16:21:03.546]                   options(future.plan = NULL)
[16:21:03.546]                   if (is.na(NA_character_)) 
[16:21:03.546]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.546]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.546]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.546]                     .init = FALSE)
[16:21:03.546]                 }
[16:21:03.546]             }
[16:21:03.546]         }
[16:21:03.546]     })
[16:21:03.546]     if (TRUE) {
[16:21:03.546]         base::sink(type = "output", split = FALSE)
[16:21:03.546]         if (TRUE) {
[16:21:03.546]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.546]         }
[16:21:03.546]         else {
[16:21:03.546]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.546]         }
[16:21:03.546]         base::close(...future.stdout)
[16:21:03.546]         ...future.stdout <- NULL
[16:21:03.546]     }
[16:21:03.546]     ...future.result$conditions <- ...future.conditions
[16:21:03.546]     ...future.result$finished <- base::Sys.time()
[16:21:03.546]     ...future.result
[16:21:03.546] }
[16:21:03.547] assign_globals() ...
[16:21:03.547] List of 2
[16:21:03.547]  $ a : num 1
[16:21:03.547]  $ ii: int 3
[16:21:03.547]  - attr(*, "where")=List of 2
[16:21:03.547]   ..$ a :<environment: R_EmptyEnv> 
[16:21:03.547]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.547]  - attr(*, "resolved")= logi TRUE
[16:21:03.547]  - attr(*, "total_size")= num 112
[16:21:03.547]  - attr(*, "already-done")= logi TRUE
[16:21:03.550] - copied ‘a’ to environment
[16:21:03.550] - copied ‘ii’ to environment
[16:21:03.551] assign_globals() ... done
[16:21:03.551] plan(): Setting new future strategy stack:
[16:21:03.551] List of future strategies:
[16:21:03.551] 1. sequential:
[16:21:03.551]    - args: function (..., envir = parent.frame())
[16:21:03.551]    - tweaked: FALSE
[16:21:03.551]    - call: NULL
[16:21:03.551] plan(): nbrOfWorkers() = 1
[16:21:03.552] plan(): Setting new future strategy stack:
[16:21:03.552] List of future strategies:
[16:21:03.552] 1. sequential:
[16:21:03.552]    - args: function (..., envir = parent.frame())
[16:21:03.552]    - tweaked: FALSE
[16:21:03.552]    - call: plan(strategy)
[16:21:03.552] plan(): nbrOfWorkers() = 1
[16:21:03.553] SequentialFuture started (and completed)
[16:21:03.553] - Launch lazy future ... done
[16:21:03.553] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.553] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.553] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.554] 
[16:21:03.554] Searching for globals ... DONE
[16:21:03.554] - globals: [0] <none>
[16:21:03.554] getGlobalsAndPackages() ... DONE
[16:21:03.554] run() for ‘Future’ ...
[16:21:03.554] - state: ‘created’
[16:21:03.554] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.555] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.555] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.555]   - Field: ‘label’
[16:21:03.555]   - Field: ‘local’
[16:21:03.555]   - Field: ‘owner’
[16:21:03.555]   - Field: ‘envir’
[16:21:03.555]   - Field: ‘packages’
[16:21:03.555]   - Field: ‘gc’
[16:21:03.556]   - Field: ‘conditions’
[16:21:03.556]   - Field: ‘expr’
[16:21:03.556]   - Field: ‘uuid’
[16:21:03.556]   - Field: ‘seed’
[16:21:03.556]   - Field: ‘version’
[16:21:03.556]   - Field: ‘result’
[16:21:03.556]   - Field: ‘asynchronous’
[16:21:03.556]   - Field: ‘calls’
[16:21:03.556]   - Field: ‘globals’
[16:21:03.556]   - Field: ‘stdout’
[16:21:03.557]   - Field: ‘earlySignal’
[16:21:03.557]   - Field: ‘lazy’
[16:21:03.557]   - Field: ‘state’
[16:21:03.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.557] - Launch lazy future ...
[16:21:03.557] Packages needed by the future expression (n = 0): <none>
[16:21:03.557] Packages needed by future strategies (n = 0): <none>
[16:21:03.558] {
[16:21:03.558]     {
[16:21:03.558]         {
[16:21:03.558]             ...future.startTime <- base::Sys.time()
[16:21:03.558]             {
[16:21:03.558]                 {
[16:21:03.558]                   {
[16:21:03.558]                     base::local({
[16:21:03.558]                       has_future <- base::requireNamespace("future", 
[16:21:03.558]                         quietly = TRUE)
[16:21:03.558]                       if (has_future) {
[16:21:03.558]                         ns <- base::getNamespace("future")
[16:21:03.558]                         version <- ns[[".package"]][["version"]]
[16:21:03.558]                         if (is.null(version)) 
[16:21:03.558]                           version <- utils::packageVersion("future")
[16:21:03.558]                       }
[16:21:03.558]                       else {
[16:21:03.558]                         version <- NULL
[16:21:03.558]                       }
[16:21:03.558]                       if (!has_future || version < "1.8.0") {
[16:21:03.558]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.558]                           "", base::R.version$version.string), 
[16:21:03.558]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.558]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.558]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.558]                             "release", "version")], collapse = " "), 
[16:21:03.558]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.558]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.558]                           info)
[16:21:03.558]                         info <- base::paste(info, collapse = "; ")
[16:21:03.558]                         if (!has_future) {
[16:21:03.558]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.558]                             info)
[16:21:03.558]                         }
[16:21:03.558]                         else {
[16:21:03.558]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.558]                             info, version)
[16:21:03.558]                         }
[16:21:03.558]                         base::stop(msg)
[16:21:03.558]                       }
[16:21:03.558]                     })
[16:21:03.558]                   }
[16:21:03.558]                   ...future.strategy.old <- future::plan("list")
[16:21:03.558]                   options(future.plan = NULL)
[16:21:03.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.558]                 }
[16:21:03.558]                 ...future.workdir <- getwd()
[16:21:03.558]             }
[16:21:03.558]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.558]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.558]         }
[16:21:03.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.558]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.558]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.558]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.558]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.558]             base::names(...future.oldOptions))
[16:21:03.558]     }
[16:21:03.558]     if (FALSE) {
[16:21:03.558]     }
[16:21:03.558]     else {
[16:21:03.558]         if (TRUE) {
[16:21:03.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.558]                 open = "w")
[16:21:03.558]         }
[16:21:03.558]         else {
[16:21:03.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.558]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.558]         }
[16:21:03.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.558]             base::sink(type = "output", split = FALSE)
[16:21:03.558]             base::close(...future.stdout)
[16:21:03.558]         }, add = TRUE)
[16:21:03.558]     }
[16:21:03.558]     ...future.frame <- base::sys.nframe()
[16:21:03.558]     ...future.conditions <- base::list()
[16:21:03.558]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.558]     if (FALSE) {
[16:21:03.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.558]     }
[16:21:03.558]     ...future.result <- base::tryCatch({
[16:21:03.558]         base::withCallingHandlers({
[16:21:03.558]             ...future.value <- base::withVisible(base::local(1))
[16:21:03.558]             future::FutureResult(value = ...future.value$value, 
[16:21:03.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.558]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.558]                     ...future.globalenv.names))
[16:21:03.558]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.558]         }, condition = base::local({
[16:21:03.558]             c <- base::c
[16:21:03.558]             inherits <- base::inherits
[16:21:03.558]             invokeRestart <- base::invokeRestart
[16:21:03.558]             length <- base::length
[16:21:03.558]             list <- base::list
[16:21:03.558]             seq.int <- base::seq.int
[16:21:03.558]             signalCondition <- base::signalCondition
[16:21:03.558]             sys.calls <- base::sys.calls
[16:21:03.558]             `[[` <- base::`[[`
[16:21:03.558]             `+` <- base::`+`
[16:21:03.558]             `<<-` <- base::`<<-`
[16:21:03.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.558]                   3L)]
[16:21:03.558]             }
[16:21:03.558]             function(cond) {
[16:21:03.558]                 is_error <- inherits(cond, "error")
[16:21:03.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.558]                   NULL)
[16:21:03.558]                 if (is_error) {
[16:21:03.558]                   sessionInformation <- function() {
[16:21:03.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.558]                       search = base::search(), system = base::Sys.info())
[16:21:03.558]                   }
[16:21:03.558]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.558]                     cond$call), session = sessionInformation(), 
[16:21:03.558]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.558]                   signalCondition(cond)
[16:21:03.558]                 }
[16:21:03.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.558]                 "immediateCondition"))) {
[16:21:03.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.558]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.558]                   if (TRUE && !signal) {
[16:21:03.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.558]                     {
[16:21:03.558]                       inherits <- base::inherits
[16:21:03.558]                       invokeRestart <- base::invokeRestart
[16:21:03.558]                       is.null <- base::is.null
[16:21:03.558]                       muffled <- FALSE
[16:21:03.558]                       if (inherits(cond, "message")) {
[16:21:03.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.558]                         if (muffled) 
[16:21:03.558]                           invokeRestart("muffleMessage")
[16:21:03.558]                       }
[16:21:03.558]                       else if (inherits(cond, "warning")) {
[16:21:03.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.558]                         if (muffled) 
[16:21:03.558]                           invokeRestart("muffleWarning")
[16:21:03.558]                       }
[16:21:03.558]                       else if (inherits(cond, "condition")) {
[16:21:03.558]                         if (!is.null(pattern)) {
[16:21:03.558]                           computeRestarts <- base::computeRestarts
[16:21:03.558]                           grepl <- base::grepl
[16:21:03.558]                           restarts <- computeRestarts(cond)
[16:21:03.558]                           for (restart in restarts) {
[16:21:03.558]                             name <- restart$name
[16:21:03.558]                             if (is.null(name)) 
[16:21:03.558]                               next
[16:21:03.558]                             if (!grepl(pattern, name)) 
[16:21:03.558]                               next
[16:21:03.558]                             invokeRestart(restart)
[16:21:03.558]                             muffled <- TRUE
[16:21:03.558]                             break
[16:21:03.558]                           }
[16:21:03.558]                         }
[16:21:03.558]                       }
[16:21:03.558]                       invisible(muffled)
[16:21:03.558]                     }
[16:21:03.558]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.558]                   }
[16:21:03.558]                 }
[16:21:03.558]                 else {
[16:21:03.558]                   if (TRUE) {
[16:21:03.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.558]                     {
[16:21:03.558]                       inherits <- base::inherits
[16:21:03.558]                       invokeRestart <- base::invokeRestart
[16:21:03.558]                       is.null <- base::is.null
[16:21:03.558]                       muffled <- FALSE
[16:21:03.558]                       if (inherits(cond, "message")) {
[16:21:03.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.558]                         if (muffled) 
[16:21:03.558]                           invokeRestart("muffleMessage")
[16:21:03.558]                       }
[16:21:03.558]                       else if (inherits(cond, "warning")) {
[16:21:03.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.558]                         if (muffled) 
[16:21:03.558]                           invokeRestart("muffleWarning")
[16:21:03.558]                       }
[16:21:03.558]                       else if (inherits(cond, "condition")) {
[16:21:03.558]                         if (!is.null(pattern)) {
[16:21:03.558]                           computeRestarts <- base::computeRestarts
[16:21:03.558]                           grepl <- base::grepl
[16:21:03.558]                           restarts <- computeRestarts(cond)
[16:21:03.558]                           for (restart in restarts) {
[16:21:03.558]                             name <- restart$name
[16:21:03.558]                             if (is.null(name)) 
[16:21:03.558]                               next
[16:21:03.558]                             if (!grepl(pattern, name)) 
[16:21:03.558]                               next
[16:21:03.558]                             invokeRestart(restart)
[16:21:03.558]                             muffled <- TRUE
[16:21:03.558]                             break
[16:21:03.558]                           }
[16:21:03.558]                         }
[16:21:03.558]                       }
[16:21:03.558]                       invisible(muffled)
[16:21:03.558]                     }
[16:21:03.558]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.558]                   }
[16:21:03.558]                 }
[16:21:03.558]             }
[16:21:03.558]         }))
[16:21:03.558]     }, error = function(ex) {
[16:21:03.558]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.558]                 ...future.rng), started = ...future.startTime, 
[16:21:03.558]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.558]             version = "1.8"), class = "FutureResult")
[16:21:03.558]     }, finally = {
[16:21:03.558]         if (!identical(...future.workdir, getwd())) 
[16:21:03.558]             setwd(...future.workdir)
[16:21:03.558]         {
[16:21:03.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.558]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.558]             }
[16:21:03.558]             base::options(...future.oldOptions)
[16:21:03.558]             if (.Platform$OS.type == "windows") {
[16:21:03.558]                 old_names <- names(...future.oldEnvVars)
[16:21:03.558]                 envs <- base::Sys.getenv()
[16:21:03.558]                 names <- names(envs)
[16:21:03.558]                 common <- intersect(names, old_names)
[16:21:03.558]                 added <- setdiff(names, old_names)
[16:21:03.558]                 removed <- setdiff(old_names, names)
[16:21:03.558]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.558]                   envs[common]]
[16:21:03.558]                 NAMES <- toupper(changed)
[16:21:03.558]                 args <- list()
[16:21:03.558]                 for (kk in seq_along(NAMES)) {
[16:21:03.558]                   name <- changed[[kk]]
[16:21:03.558]                   NAME <- NAMES[[kk]]
[16:21:03.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.558]                     next
[16:21:03.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.558]                 }
[16:21:03.558]                 NAMES <- toupper(added)
[16:21:03.558]                 for (kk in seq_along(NAMES)) {
[16:21:03.558]                   name <- added[[kk]]
[16:21:03.558]                   NAME <- NAMES[[kk]]
[16:21:03.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.558]                     next
[16:21:03.558]                   args[[name]] <- ""
[16:21:03.558]                 }
[16:21:03.558]                 NAMES <- toupper(removed)
[16:21:03.558]                 for (kk in seq_along(NAMES)) {
[16:21:03.558]                   name <- removed[[kk]]
[16:21:03.558]                   NAME <- NAMES[[kk]]
[16:21:03.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.558]                     next
[16:21:03.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.558]                 }
[16:21:03.558]                 if (length(args) > 0) 
[16:21:03.558]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.558]             }
[16:21:03.558]             else {
[16:21:03.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.558]             }
[16:21:03.558]             {
[16:21:03.558]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.558]                   0L) {
[16:21:03.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.558]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.558]                   base::options(opts)
[16:21:03.558]                 }
[16:21:03.558]                 {
[16:21:03.558]                   {
[16:21:03.558]                     NULL
[16:21:03.558]                     RNGkind("Mersenne-Twister")
[16:21:03.558]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.558]                       inherits = FALSE)
[16:21:03.558]                   }
[16:21:03.558]                   options(future.plan = NULL)
[16:21:03.558]                   if (is.na(NA_character_)) 
[16:21:03.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.558]                     .init = FALSE)
[16:21:03.558]                 }
[16:21:03.558]             }
[16:21:03.558]         }
[16:21:03.558]     })
[16:21:03.558]     if (TRUE) {
[16:21:03.558]         base::sink(type = "output", split = FALSE)
[16:21:03.558]         if (TRUE) {
[16:21:03.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.558]         }
[16:21:03.558]         else {
[16:21:03.558]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.558]         }
[16:21:03.558]         base::close(...future.stdout)
[16:21:03.558]         ...future.stdout <- NULL
[16:21:03.558]     }
[16:21:03.558]     ...future.result$conditions <- ...future.conditions
[16:21:03.558]     ...future.result$finished <- base::Sys.time()
[16:21:03.558]     ...future.result
[16:21:03.558] }
[16:21:03.561] plan(): Setting new future strategy stack:
[16:21:03.561] List of future strategies:
[16:21:03.561] 1. sequential:
[16:21:03.561]    - args: function (..., envir = parent.frame())
[16:21:03.561]    - tweaked: FALSE
[16:21:03.561]    - call: NULL
[16:21:03.562] plan(): nbrOfWorkers() = 1
[16:21:03.562] plan(): Setting new future strategy stack:
[16:21:03.562] List of future strategies:
[16:21:03.562] 1. sequential:
[16:21:03.562]    - args: function (..., envir = parent.frame())
[16:21:03.562]    - tweaked: FALSE
[16:21:03.562]    - call: plan(strategy)
[16:21:03.563] plan(): nbrOfWorkers() = 1
[16:21:03.563] SequentialFuture started (and completed)
[16:21:03.563] - Launch lazy future ... done
[16:21:03.563] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.563] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.564] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.564] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:03.564] Searching for globals ... DONE
[16:21:03.565] Resolving globals: TRUE
[16:21:03.565] Resolving any globals that are futures ...
[16:21:03.565] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:03.565] Resolving any globals that are futures ... DONE
[16:21:03.565] Resolving futures part of globals (recursively) ...
[16:21:03.565] resolve() on list ...
[16:21:03.565]  recursive: 99
[16:21:03.566]  length: 1
[16:21:03.566]  elements: ‘a’
[16:21:03.566] resolved() for ‘SequentialFuture’ ...
[16:21:03.566] - state: ‘finished’
[16:21:03.566] - run: TRUE
[16:21:03.566] - result: ‘FutureResult’
[16:21:03.566] resolved() for ‘SequentialFuture’ ... done
[16:21:03.566] Future #1
[16:21:03.566] resolved() for ‘SequentialFuture’ ...
[16:21:03.566] - state: ‘finished’
[16:21:03.567] - run: TRUE
[16:21:03.567] - result: ‘FutureResult’
[16:21:03.567] resolved() for ‘SequentialFuture’ ... done
[16:21:03.567] A SequentialFuture was resolved
[16:21:03.567]  length: 0 (resolved future 1)
[16:21:03.567] resolve() on list ... DONE
[16:21:03.567] - globals: [1] ‘a’
[16:21:03.567] Resolving futures part of globals (recursively) ... DONE
[16:21:03.569] The total size of the 1 globals is 1.55 MiB (1621800 bytes)
[16:21:03.569] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:21:03.570] - globals: [1] ‘a’
[16:21:03.570] - packages: [1] ‘future’
[16:21:03.570] getGlobalsAndPackages() ... DONE
[16:21:03.570] run() for ‘Future’ ...
[16:21:03.570] - state: ‘created’
[16:21:03.570] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.571] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.571]   - Field: ‘label’
[16:21:03.571]   - Field: ‘local’
[16:21:03.571]   - Field: ‘owner’
[16:21:03.571]   - Field: ‘envir’
[16:21:03.571]   - Field: ‘packages’
[16:21:03.571]   - Field: ‘gc’
[16:21:03.571]   - Field: ‘conditions’
[16:21:03.572]   - Field: ‘expr’
[16:21:03.572]   - Field: ‘uuid’
[16:21:03.572]   - Field: ‘seed’
[16:21:03.572]   - Field: ‘version’
[16:21:03.572]   - Field: ‘result’
[16:21:03.572]   - Field: ‘asynchronous’
[16:21:03.572]   - Field: ‘calls’
[16:21:03.572]   - Field: ‘globals’
[16:21:03.572]   - Field: ‘stdout’
[16:21:03.572]   - Field: ‘earlySignal’
[16:21:03.573]   - Field: ‘lazy’
[16:21:03.573]   - Field: ‘state’
[16:21:03.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.573] - Launch lazy future ...
[16:21:03.573] Packages needed by the future expression (n = 1): ‘future’
[16:21:03.573] Packages needed by future strategies (n = 0): <none>
[16:21:03.574] {
[16:21:03.574]     {
[16:21:03.574]         {
[16:21:03.574]             ...future.startTime <- base::Sys.time()
[16:21:03.574]             {
[16:21:03.574]                 {
[16:21:03.574]                   {
[16:21:03.574]                     {
[16:21:03.574]                       base::local({
[16:21:03.574]                         has_future <- base::requireNamespace("future", 
[16:21:03.574]                           quietly = TRUE)
[16:21:03.574]                         if (has_future) {
[16:21:03.574]                           ns <- base::getNamespace("future")
[16:21:03.574]                           version <- ns[[".package"]][["version"]]
[16:21:03.574]                           if (is.null(version)) 
[16:21:03.574]                             version <- utils::packageVersion("future")
[16:21:03.574]                         }
[16:21:03.574]                         else {
[16:21:03.574]                           version <- NULL
[16:21:03.574]                         }
[16:21:03.574]                         if (!has_future || version < "1.8.0") {
[16:21:03.574]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.574]                             "", base::R.version$version.string), 
[16:21:03.574]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.574]                               "release", "version")], collapse = " "), 
[16:21:03.574]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.574]                             info)
[16:21:03.574]                           info <- base::paste(info, collapse = "; ")
[16:21:03.574]                           if (!has_future) {
[16:21:03.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.574]                               info)
[16:21:03.574]                           }
[16:21:03.574]                           else {
[16:21:03.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.574]                               info, version)
[16:21:03.574]                           }
[16:21:03.574]                           base::stop(msg)
[16:21:03.574]                         }
[16:21:03.574]                       })
[16:21:03.574]                     }
[16:21:03.574]                     base::local({
[16:21:03.574]                       for (pkg in "future") {
[16:21:03.574]                         base::loadNamespace(pkg)
[16:21:03.574]                         base::library(pkg, character.only = TRUE)
[16:21:03.574]                       }
[16:21:03.574]                     })
[16:21:03.574]                   }
[16:21:03.574]                   ...future.strategy.old <- future::plan("list")
[16:21:03.574]                   options(future.plan = NULL)
[16:21:03.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.574]                 }
[16:21:03.574]                 ...future.workdir <- getwd()
[16:21:03.574]             }
[16:21:03.574]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.574]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.574]         }
[16:21:03.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.574]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.574]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.574]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.574]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.574]             base::names(...future.oldOptions))
[16:21:03.574]     }
[16:21:03.574]     if (FALSE) {
[16:21:03.574]     }
[16:21:03.574]     else {
[16:21:03.574]         if (TRUE) {
[16:21:03.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.574]                 open = "w")
[16:21:03.574]         }
[16:21:03.574]         else {
[16:21:03.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.574]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.574]         }
[16:21:03.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.574]             base::sink(type = "output", split = FALSE)
[16:21:03.574]             base::close(...future.stdout)
[16:21:03.574]         }, add = TRUE)
[16:21:03.574]     }
[16:21:03.574]     ...future.frame <- base::sys.nframe()
[16:21:03.574]     ...future.conditions <- base::list()
[16:21:03.574]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.574]     if (FALSE) {
[16:21:03.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.574]     }
[16:21:03.574]     ...future.result <- base::tryCatch({
[16:21:03.574]         base::withCallingHandlers({
[16:21:03.574]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:21:03.574]                 1))
[16:21:03.574]             future::FutureResult(value = ...future.value$value, 
[16:21:03.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.574]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.574]                     ...future.globalenv.names))
[16:21:03.574]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.574]         }, condition = base::local({
[16:21:03.574]             c <- base::c
[16:21:03.574]             inherits <- base::inherits
[16:21:03.574]             invokeRestart <- base::invokeRestart
[16:21:03.574]             length <- base::length
[16:21:03.574]             list <- base::list
[16:21:03.574]             seq.int <- base::seq.int
[16:21:03.574]             signalCondition <- base::signalCondition
[16:21:03.574]             sys.calls <- base::sys.calls
[16:21:03.574]             `[[` <- base::`[[`
[16:21:03.574]             `+` <- base::`+`
[16:21:03.574]             `<<-` <- base::`<<-`
[16:21:03.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.574]                   3L)]
[16:21:03.574]             }
[16:21:03.574]             function(cond) {
[16:21:03.574]                 is_error <- inherits(cond, "error")
[16:21:03.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.574]                   NULL)
[16:21:03.574]                 if (is_error) {
[16:21:03.574]                   sessionInformation <- function() {
[16:21:03.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.574]                       search = base::search(), system = base::Sys.info())
[16:21:03.574]                   }
[16:21:03.574]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.574]                     cond$call), session = sessionInformation(), 
[16:21:03.574]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.574]                   signalCondition(cond)
[16:21:03.574]                 }
[16:21:03.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.574]                 "immediateCondition"))) {
[16:21:03.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.574]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.574]                   if (TRUE && !signal) {
[16:21:03.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.574]                     {
[16:21:03.574]                       inherits <- base::inherits
[16:21:03.574]                       invokeRestart <- base::invokeRestart
[16:21:03.574]                       is.null <- base::is.null
[16:21:03.574]                       muffled <- FALSE
[16:21:03.574]                       if (inherits(cond, "message")) {
[16:21:03.574]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.574]                         if (muffled) 
[16:21:03.574]                           invokeRestart("muffleMessage")
[16:21:03.574]                       }
[16:21:03.574]                       else if (inherits(cond, "warning")) {
[16:21:03.574]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.574]                         if (muffled) 
[16:21:03.574]                           invokeRestart("muffleWarning")
[16:21:03.574]                       }
[16:21:03.574]                       else if (inherits(cond, "condition")) {
[16:21:03.574]                         if (!is.null(pattern)) {
[16:21:03.574]                           computeRestarts <- base::computeRestarts
[16:21:03.574]                           grepl <- base::grepl
[16:21:03.574]                           restarts <- computeRestarts(cond)
[16:21:03.574]                           for (restart in restarts) {
[16:21:03.574]                             name <- restart$name
[16:21:03.574]                             if (is.null(name)) 
[16:21:03.574]                               next
[16:21:03.574]                             if (!grepl(pattern, name)) 
[16:21:03.574]                               next
[16:21:03.574]                             invokeRestart(restart)
[16:21:03.574]                             muffled <- TRUE
[16:21:03.574]                             break
[16:21:03.574]                           }
[16:21:03.574]                         }
[16:21:03.574]                       }
[16:21:03.574]                       invisible(muffled)
[16:21:03.574]                     }
[16:21:03.574]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.574]                   }
[16:21:03.574]                 }
[16:21:03.574]                 else {
[16:21:03.574]                   if (TRUE) {
[16:21:03.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.574]                     {
[16:21:03.574]                       inherits <- base::inherits
[16:21:03.574]                       invokeRestart <- base::invokeRestart
[16:21:03.574]                       is.null <- base::is.null
[16:21:03.574]                       muffled <- FALSE
[16:21:03.574]                       if (inherits(cond, "message")) {
[16:21:03.574]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.574]                         if (muffled) 
[16:21:03.574]                           invokeRestart("muffleMessage")
[16:21:03.574]                       }
[16:21:03.574]                       else if (inherits(cond, "warning")) {
[16:21:03.574]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.574]                         if (muffled) 
[16:21:03.574]                           invokeRestart("muffleWarning")
[16:21:03.574]                       }
[16:21:03.574]                       else if (inherits(cond, "condition")) {
[16:21:03.574]                         if (!is.null(pattern)) {
[16:21:03.574]                           computeRestarts <- base::computeRestarts
[16:21:03.574]                           grepl <- base::grepl
[16:21:03.574]                           restarts <- computeRestarts(cond)
[16:21:03.574]                           for (restart in restarts) {
[16:21:03.574]                             name <- restart$name
[16:21:03.574]                             if (is.null(name)) 
[16:21:03.574]                               next
[16:21:03.574]                             if (!grepl(pattern, name)) 
[16:21:03.574]                               next
[16:21:03.574]                             invokeRestart(restart)
[16:21:03.574]                             muffled <- TRUE
[16:21:03.574]                             break
[16:21:03.574]                           }
[16:21:03.574]                         }
[16:21:03.574]                       }
[16:21:03.574]                       invisible(muffled)
[16:21:03.574]                     }
[16:21:03.574]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.574]                   }
[16:21:03.574]                 }
[16:21:03.574]             }
[16:21:03.574]         }))
[16:21:03.574]     }, error = function(ex) {
[16:21:03.574]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.574]                 ...future.rng), started = ...future.startTime, 
[16:21:03.574]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.574]             version = "1.8"), class = "FutureResult")
[16:21:03.574]     }, finally = {
[16:21:03.574]         if (!identical(...future.workdir, getwd())) 
[16:21:03.574]             setwd(...future.workdir)
[16:21:03.574]         {
[16:21:03.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.574]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.574]             }
[16:21:03.574]             base::options(...future.oldOptions)
[16:21:03.574]             if (.Platform$OS.type == "windows") {
[16:21:03.574]                 old_names <- names(...future.oldEnvVars)
[16:21:03.574]                 envs <- base::Sys.getenv()
[16:21:03.574]                 names <- names(envs)
[16:21:03.574]                 common <- intersect(names, old_names)
[16:21:03.574]                 added <- setdiff(names, old_names)
[16:21:03.574]                 removed <- setdiff(old_names, names)
[16:21:03.574]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.574]                   envs[common]]
[16:21:03.574]                 NAMES <- toupper(changed)
[16:21:03.574]                 args <- list()
[16:21:03.574]                 for (kk in seq_along(NAMES)) {
[16:21:03.574]                   name <- changed[[kk]]
[16:21:03.574]                   NAME <- NAMES[[kk]]
[16:21:03.574]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.574]                     next
[16:21:03.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.574]                 }
[16:21:03.574]                 NAMES <- toupper(added)
[16:21:03.574]                 for (kk in seq_along(NAMES)) {
[16:21:03.574]                   name <- added[[kk]]
[16:21:03.574]                   NAME <- NAMES[[kk]]
[16:21:03.574]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.574]                     next
[16:21:03.574]                   args[[name]] <- ""
[16:21:03.574]                 }
[16:21:03.574]                 NAMES <- toupper(removed)
[16:21:03.574]                 for (kk in seq_along(NAMES)) {
[16:21:03.574]                   name <- removed[[kk]]
[16:21:03.574]                   NAME <- NAMES[[kk]]
[16:21:03.574]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.574]                     next
[16:21:03.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.574]                 }
[16:21:03.574]                 if (length(args) > 0) 
[16:21:03.574]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.574]             }
[16:21:03.574]             else {
[16:21:03.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.574]             }
[16:21:03.574]             {
[16:21:03.574]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.574]                   0L) {
[16:21:03.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.574]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.574]                   base::options(opts)
[16:21:03.574]                 }
[16:21:03.574]                 {
[16:21:03.574]                   {
[16:21:03.574]                     NULL
[16:21:03.574]                     RNGkind("Mersenne-Twister")
[16:21:03.574]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.574]                       inherits = FALSE)
[16:21:03.574]                   }
[16:21:03.574]                   options(future.plan = NULL)
[16:21:03.574]                   if (is.na(NA_character_)) 
[16:21:03.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.574]                     .init = FALSE)
[16:21:03.574]                 }
[16:21:03.574]             }
[16:21:03.574]         }
[16:21:03.574]     })
[16:21:03.574]     if (TRUE) {
[16:21:03.574]         base::sink(type = "output", split = FALSE)
[16:21:03.574]         if (TRUE) {
[16:21:03.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.574]         }
[16:21:03.574]         else {
[16:21:03.574]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.574]         }
[16:21:03.574]         base::close(...future.stdout)
[16:21:03.574]         ...future.stdout <- NULL
[16:21:03.574]     }
[16:21:03.574]     ...future.result$conditions <- ...future.conditions
[16:21:03.574]     ...future.result$finished <- base::Sys.time()
[16:21:03.574]     ...future.result
[16:21:03.574] }
[16:21:03.575] assign_globals() ...
[16:21:03.575] List of 1
[16:21:03.575]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5622286fee98> 
[16:21:03.575]  - attr(*, "where")=List of 1
[16:21:03.575]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.575]  - attr(*, "resolved")= logi TRUE
[16:21:03.575]  - attr(*, "total_size")= num 1621800
[16:21:03.575]  - attr(*, "already-done")= logi TRUE
[16:21:03.578] - copied ‘a’ to environment
[16:21:03.578] assign_globals() ... done
[16:21:03.578] plan(): Setting new future strategy stack:
[16:21:03.578] List of future strategies:
[16:21:03.578] 1. sequential:
[16:21:03.578]    - args: function (..., envir = parent.frame())
[16:21:03.578]    - tweaked: FALSE
[16:21:03.578]    - call: NULL
[16:21:03.579] plan(): nbrOfWorkers() = 1
[16:21:03.580] plan(): Setting new future strategy stack:
[16:21:03.580] List of future strategies:
[16:21:03.580] 1. sequential:
[16:21:03.580]    - args: function (..., envir = parent.frame())
[16:21:03.580]    - tweaked: FALSE
[16:21:03.580]    - call: plan(strategy)
[16:21:03.580] plan(): nbrOfWorkers() = 1
[16:21:03.580] SequentialFuture started (and completed)
[16:21:03.580] - Launch lazy future ... done
[16:21:03.580] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.581] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.581] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.582] 
[16:21:03.582] Searching for globals ... DONE
[16:21:03.582] - globals: [0] <none>
[16:21:03.582] getGlobalsAndPackages() ... DONE
[16:21:03.582] run() for ‘Future’ ...
[16:21:03.582] - state: ‘created’
[16:21:03.582] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.583] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.583]   - Field: ‘label’
[16:21:03.583]   - Field: ‘local’
[16:21:03.583]   - Field: ‘owner’
[16:21:03.583]   - Field: ‘envir’
[16:21:03.583]   - Field: ‘packages’
[16:21:03.583]   - Field: ‘gc’
[16:21:03.583]   - Field: ‘conditions’
[16:21:03.583]   - Field: ‘expr’
[16:21:03.584]   - Field: ‘uuid’
[16:21:03.584]   - Field: ‘seed’
[16:21:03.584]   - Field: ‘version’
[16:21:03.584]   - Field: ‘result’
[16:21:03.584]   - Field: ‘asynchronous’
[16:21:03.584]   - Field: ‘calls’
[16:21:03.584]   - Field: ‘globals’
[16:21:03.584]   - Field: ‘stdout’
[16:21:03.612]   - Field: ‘earlySignal’
[16:21:03.612]   - Field: ‘lazy’
[16:21:03.612]   - Field: ‘state’
[16:21:03.612] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.612] - Launch lazy future ...
[16:21:03.613] Packages needed by the future expression (n = 0): <none>
[16:21:03.613] Packages needed by future strategies (n = 0): <none>
[16:21:03.613] {
[16:21:03.613]     {
[16:21:03.613]         {
[16:21:03.613]             ...future.startTime <- base::Sys.time()
[16:21:03.613]             {
[16:21:03.613]                 {
[16:21:03.613]                   {
[16:21:03.613]                     base::local({
[16:21:03.613]                       has_future <- base::requireNamespace("future", 
[16:21:03.613]                         quietly = TRUE)
[16:21:03.613]                       if (has_future) {
[16:21:03.613]                         ns <- base::getNamespace("future")
[16:21:03.613]                         version <- ns[[".package"]][["version"]]
[16:21:03.613]                         if (is.null(version)) 
[16:21:03.613]                           version <- utils::packageVersion("future")
[16:21:03.613]                       }
[16:21:03.613]                       else {
[16:21:03.613]                         version <- NULL
[16:21:03.613]                       }
[16:21:03.613]                       if (!has_future || version < "1.8.0") {
[16:21:03.613]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.613]                           "", base::R.version$version.string), 
[16:21:03.613]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.613]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.613]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.613]                             "release", "version")], collapse = " "), 
[16:21:03.613]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.613]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.613]                           info)
[16:21:03.613]                         info <- base::paste(info, collapse = "; ")
[16:21:03.613]                         if (!has_future) {
[16:21:03.613]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.613]                             info)
[16:21:03.613]                         }
[16:21:03.613]                         else {
[16:21:03.613]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.613]                             info, version)
[16:21:03.613]                         }
[16:21:03.613]                         base::stop(msg)
[16:21:03.613]                       }
[16:21:03.613]                     })
[16:21:03.613]                   }
[16:21:03.613]                   ...future.strategy.old <- future::plan("list")
[16:21:03.613]                   options(future.plan = NULL)
[16:21:03.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.613]                 }
[16:21:03.613]                 ...future.workdir <- getwd()
[16:21:03.613]             }
[16:21:03.613]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.613]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.613]         }
[16:21:03.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.613]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.613]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.613]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.613]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.613]             base::names(...future.oldOptions))
[16:21:03.613]     }
[16:21:03.613]     if (FALSE) {
[16:21:03.613]     }
[16:21:03.613]     else {
[16:21:03.613]         if (TRUE) {
[16:21:03.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.613]                 open = "w")
[16:21:03.613]         }
[16:21:03.613]         else {
[16:21:03.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.613]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.613]         }
[16:21:03.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.613]             base::sink(type = "output", split = FALSE)
[16:21:03.613]             base::close(...future.stdout)
[16:21:03.613]         }, add = TRUE)
[16:21:03.613]     }
[16:21:03.613]     ...future.frame <- base::sys.nframe()
[16:21:03.613]     ...future.conditions <- base::list()
[16:21:03.613]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.613]     if (FALSE) {
[16:21:03.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.613]     }
[16:21:03.613]     ...future.result <- base::tryCatch({
[16:21:03.613]         base::withCallingHandlers({
[16:21:03.613]             ...future.value <- base::withVisible(base::local(1))
[16:21:03.613]             future::FutureResult(value = ...future.value$value, 
[16:21:03.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.613]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.613]                     ...future.globalenv.names))
[16:21:03.613]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.613]         }, condition = base::local({
[16:21:03.613]             c <- base::c
[16:21:03.613]             inherits <- base::inherits
[16:21:03.613]             invokeRestart <- base::invokeRestart
[16:21:03.613]             length <- base::length
[16:21:03.613]             list <- base::list
[16:21:03.613]             seq.int <- base::seq.int
[16:21:03.613]             signalCondition <- base::signalCondition
[16:21:03.613]             sys.calls <- base::sys.calls
[16:21:03.613]             `[[` <- base::`[[`
[16:21:03.613]             `+` <- base::`+`
[16:21:03.613]             `<<-` <- base::`<<-`
[16:21:03.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.613]                   3L)]
[16:21:03.613]             }
[16:21:03.613]             function(cond) {
[16:21:03.613]                 is_error <- inherits(cond, "error")
[16:21:03.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.613]                   NULL)
[16:21:03.613]                 if (is_error) {
[16:21:03.613]                   sessionInformation <- function() {
[16:21:03.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.613]                       search = base::search(), system = base::Sys.info())
[16:21:03.613]                   }
[16:21:03.613]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.613]                     cond$call), session = sessionInformation(), 
[16:21:03.613]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.613]                   signalCondition(cond)
[16:21:03.613]                 }
[16:21:03.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.613]                 "immediateCondition"))) {
[16:21:03.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.613]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.613]                   if (TRUE && !signal) {
[16:21:03.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.613]                     {
[16:21:03.613]                       inherits <- base::inherits
[16:21:03.613]                       invokeRestart <- base::invokeRestart
[16:21:03.613]                       is.null <- base::is.null
[16:21:03.613]                       muffled <- FALSE
[16:21:03.613]                       if (inherits(cond, "message")) {
[16:21:03.613]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.613]                         if (muffled) 
[16:21:03.613]                           invokeRestart("muffleMessage")
[16:21:03.613]                       }
[16:21:03.613]                       else if (inherits(cond, "warning")) {
[16:21:03.613]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.613]                         if (muffled) 
[16:21:03.613]                           invokeRestart("muffleWarning")
[16:21:03.613]                       }
[16:21:03.613]                       else if (inherits(cond, "condition")) {
[16:21:03.613]                         if (!is.null(pattern)) {
[16:21:03.613]                           computeRestarts <- base::computeRestarts
[16:21:03.613]                           grepl <- base::grepl
[16:21:03.613]                           restarts <- computeRestarts(cond)
[16:21:03.613]                           for (restart in restarts) {
[16:21:03.613]                             name <- restart$name
[16:21:03.613]                             if (is.null(name)) 
[16:21:03.613]                               next
[16:21:03.613]                             if (!grepl(pattern, name)) 
[16:21:03.613]                               next
[16:21:03.613]                             invokeRestart(restart)
[16:21:03.613]                             muffled <- TRUE
[16:21:03.613]                             break
[16:21:03.613]                           }
[16:21:03.613]                         }
[16:21:03.613]                       }
[16:21:03.613]                       invisible(muffled)
[16:21:03.613]                     }
[16:21:03.613]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.613]                   }
[16:21:03.613]                 }
[16:21:03.613]                 else {
[16:21:03.613]                   if (TRUE) {
[16:21:03.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.613]                     {
[16:21:03.613]                       inherits <- base::inherits
[16:21:03.613]                       invokeRestart <- base::invokeRestart
[16:21:03.613]                       is.null <- base::is.null
[16:21:03.613]                       muffled <- FALSE
[16:21:03.613]                       if (inherits(cond, "message")) {
[16:21:03.613]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.613]                         if (muffled) 
[16:21:03.613]                           invokeRestart("muffleMessage")
[16:21:03.613]                       }
[16:21:03.613]                       else if (inherits(cond, "warning")) {
[16:21:03.613]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.613]                         if (muffled) 
[16:21:03.613]                           invokeRestart("muffleWarning")
[16:21:03.613]                       }
[16:21:03.613]                       else if (inherits(cond, "condition")) {
[16:21:03.613]                         if (!is.null(pattern)) {
[16:21:03.613]                           computeRestarts <- base::computeRestarts
[16:21:03.613]                           grepl <- base::grepl
[16:21:03.613]                           restarts <- computeRestarts(cond)
[16:21:03.613]                           for (restart in restarts) {
[16:21:03.613]                             name <- restart$name
[16:21:03.613]                             if (is.null(name)) 
[16:21:03.613]                               next
[16:21:03.613]                             if (!grepl(pattern, name)) 
[16:21:03.613]                               next
[16:21:03.613]                             invokeRestart(restart)
[16:21:03.613]                             muffled <- TRUE
[16:21:03.613]                             break
[16:21:03.613]                           }
[16:21:03.613]                         }
[16:21:03.613]                       }
[16:21:03.613]                       invisible(muffled)
[16:21:03.613]                     }
[16:21:03.613]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.613]                   }
[16:21:03.613]                 }
[16:21:03.613]             }
[16:21:03.613]         }))
[16:21:03.613]     }, error = function(ex) {
[16:21:03.613]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.613]                 ...future.rng), started = ...future.startTime, 
[16:21:03.613]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.613]             version = "1.8"), class = "FutureResult")
[16:21:03.613]     }, finally = {
[16:21:03.613]         if (!identical(...future.workdir, getwd())) 
[16:21:03.613]             setwd(...future.workdir)
[16:21:03.613]         {
[16:21:03.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.613]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.613]             }
[16:21:03.613]             base::options(...future.oldOptions)
[16:21:03.613]             if (.Platform$OS.type == "windows") {
[16:21:03.613]                 old_names <- names(...future.oldEnvVars)
[16:21:03.613]                 envs <- base::Sys.getenv()
[16:21:03.613]                 names <- names(envs)
[16:21:03.613]                 common <- intersect(names, old_names)
[16:21:03.613]                 added <- setdiff(names, old_names)
[16:21:03.613]                 removed <- setdiff(old_names, names)
[16:21:03.613]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.613]                   envs[common]]
[16:21:03.613]                 NAMES <- toupper(changed)
[16:21:03.613]                 args <- list()
[16:21:03.613]                 for (kk in seq_along(NAMES)) {
[16:21:03.613]                   name <- changed[[kk]]
[16:21:03.613]                   NAME <- NAMES[[kk]]
[16:21:03.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.613]                     next
[16:21:03.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.613]                 }
[16:21:03.613]                 NAMES <- toupper(added)
[16:21:03.613]                 for (kk in seq_along(NAMES)) {
[16:21:03.613]                   name <- added[[kk]]
[16:21:03.613]                   NAME <- NAMES[[kk]]
[16:21:03.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.613]                     next
[16:21:03.613]                   args[[name]] <- ""
[16:21:03.613]                 }
[16:21:03.613]                 NAMES <- toupper(removed)
[16:21:03.613]                 for (kk in seq_along(NAMES)) {
[16:21:03.613]                   name <- removed[[kk]]
[16:21:03.613]                   NAME <- NAMES[[kk]]
[16:21:03.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.613]                     next
[16:21:03.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.613]                 }
[16:21:03.613]                 if (length(args) > 0) 
[16:21:03.613]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.613]             }
[16:21:03.613]             else {
[16:21:03.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.613]             }
[16:21:03.613]             {
[16:21:03.613]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.613]                   0L) {
[16:21:03.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.613]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.613]                   base::options(opts)
[16:21:03.613]                 }
[16:21:03.613]                 {
[16:21:03.613]                   {
[16:21:03.613]                     NULL
[16:21:03.613]                     RNGkind("Mersenne-Twister")
[16:21:03.613]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.613]                       inherits = FALSE)
[16:21:03.613]                   }
[16:21:03.613]                   options(future.plan = NULL)
[16:21:03.613]                   if (is.na(NA_character_)) 
[16:21:03.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.613]                     .init = FALSE)
[16:21:03.613]                 }
[16:21:03.613]             }
[16:21:03.613]         }
[16:21:03.613]     })
[16:21:03.613]     if (TRUE) {
[16:21:03.613]         base::sink(type = "output", split = FALSE)
[16:21:03.613]         if (TRUE) {
[16:21:03.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.613]         }
[16:21:03.613]         else {
[16:21:03.613]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.613]         }
[16:21:03.613]         base::close(...future.stdout)
[16:21:03.613]         ...future.stdout <- NULL
[16:21:03.613]     }
[16:21:03.613]     ...future.result$conditions <- ...future.conditions
[16:21:03.613]     ...future.result$finished <- base::Sys.time()
[16:21:03.613]     ...future.result
[16:21:03.613] }
[16:21:03.616] plan(): Setting new future strategy stack:
[16:21:03.616] List of future strategies:
[16:21:03.616] 1. sequential:
[16:21:03.616]    - args: function (..., envir = parent.frame())
[16:21:03.616]    - tweaked: FALSE
[16:21:03.616]    - call: NULL
[16:21:03.616] plan(): nbrOfWorkers() = 1
[16:21:03.617] plan(): Setting new future strategy stack:
[16:21:03.617] List of future strategies:
[16:21:03.617] 1. sequential:
[16:21:03.617]    - args: function (..., envir = parent.frame())
[16:21:03.617]    - tweaked: FALSE
[16:21:03.617]    - call: plan(strategy)
[16:21:03.618] plan(): nbrOfWorkers() = 1
[16:21:03.618] SequentialFuture started (and completed)
[16:21:03.618] - Launch lazy future ... done
[16:21:03.618] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.618] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.618] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.619] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:03.619] Searching for globals ... DONE
[16:21:03.619] Resolving globals: TRUE
[16:21:03.619] Resolving any globals that are futures ...
[16:21:03.620] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:03.620] Resolving any globals that are futures ... DONE
[16:21:03.620] Resolving futures part of globals (recursively) ...
[16:21:03.620] resolve() on list ...
[16:21:03.620]  recursive: 99
[16:21:03.620]  length: 1
[16:21:03.620]  elements: ‘a’
[16:21:03.621] resolved() for ‘SequentialFuture’ ...
[16:21:03.621] - state: ‘finished’
[16:21:03.621] - run: TRUE
[16:21:03.621] - result: ‘FutureResult’
[16:21:03.621] resolved() for ‘SequentialFuture’ ... done
[16:21:03.621] Future #1
[16:21:03.621] resolved() for ‘SequentialFuture’ ...
[16:21:03.621] - state: ‘finished’
[16:21:03.621] - run: TRUE
[16:21:03.622] - result: ‘FutureResult’
[16:21:03.622] resolved() for ‘SequentialFuture’ ... done
[16:21:03.622] A SequentialFuture was resolved
[16:21:03.622]  length: 0 (resolved future 1)
[16:21:03.622] resolve() on list ... DONE
[16:21:03.622] - globals: [1] ‘a’
[16:21:03.622] Resolving futures part of globals (recursively) ... DONE
[16:21:03.624] The total size of the 1 globals is 1.55 MiB (1621800 bytes)
[16:21:03.624] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:21:03.624] - globals: [1] ‘a’
[16:21:03.625] - packages: [1] ‘future’
[16:21:03.625] getGlobalsAndPackages() ... DONE
[16:21:03.625] run() for ‘Future’ ...
[16:21:03.625] - state: ‘created’
[16:21:03.625] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.625] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.626]   - Field: ‘label’
[16:21:03.626]   - Field: ‘local’
[16:21:03.626]   - Field: ‘owner’
[16:21:03.626]   - Field: ‘envir’
[16:21:03.626]   - Field: ‘packages’
[16:21:03.626]   - Field: ‘gc’
[16:21:03.626]   - Field: ‘conditions’
[16:21:03.626]   - Field: ‘expr’
[16:21:03.626]   - Field: ‘uuid’
[16:21:03.627]   - Field: ‘seed’
[16:21:03.627]   - Field: ‘version’
[16:21:03.627]   - Field: ‘result’
[16:21:03.627]   - Field: ‘asynchronous’
[16:21:03.627]   - Field: ‘calls’
[16:21:03.627]   - Field: ‘globals’
[16:21:03.627]   - Field: ‘stdout’
[16:21:03.627]   - Field: ‘earlySignal’
[16:21:03.627]   - Field: ‘lazy’
[16:21:03.627]   - Field: ‘state’
[16:21:03.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.628] - Launch lazy future ...
[16:21:03.628] Packages needed by the future expression (n = 1): ‘future’
[16:21:03.628] Packages needed by future strategies (n = 0): <none>
[16:21:03.628] {
[16:21:03.628]     {
[16:21:03.628]         {
[16:21:03.628]             ...future.startTime <- base::Sys.time()
[16:21:03.628]             {
[16:21:03.628]                 {
[16:21:03.628]                   {
[16:21:03.628]                     {
[16:21:03.628]                       base::local({
[16:21:03.628]                         has_future <- base::requireNamespace("future", 
[16:21:03.628]                           quietly = TRUE)
[16:21:03.628]                         if (has_future) {
[16:21:03.628]                           ns <- base::getNamespace("future")
[16:21:03.628]                           version <- ns[[".package"]][["version"]]
[16:21:03.628]                           if (is.null(version)) 
[16:21:03.628]                             version <- utils::packageVersion("future")
[16:21:03.628]                         }
[16:21:03.628]                         else {
[16:21:03.628]                           version <- NULL
[16:21:03.628]                         }
[16:21:03.628]                         if (!has_future || version < "1.8.0") {
[16:21:03.628]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.628]                             "", base::R.version$version.string), 
[16:21:03.628]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.628]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.628]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.628]                               "release", "version")], collapse = " "), 
[16:21:03.628]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.628]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.628]                             info)
[16:21:03.628]                           info <- base::paste(info, collapse = "; ")
[16:21:03.628]                           if (!has_future) {
[16:21:03.628]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.628]                               info)
[16:21:03.628]                           }
[16:21:03.628]                           else {
[16:21:03.628]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.628]                               info, version)
[16:21:03.628]                           }
[16:21:03.628]                           base::stop(msg)
[16:21:03.628]                         }
[16:21:03.628]                       })
[16:21:03.628]                     }
[16:21:03.628]                     base::local({
[16:21:03.628]                       for (pkg in "future") {
[16:21:03.628]                         base::loadNamespace(pkg)
[16:21:03.628]                         base::library(pkg, character.only = TRUE)
[16:21:03.628]                       }
[16:21:03.628]                     })
[16:21:03.628]                   }
[16:21:03.628]                   ...future.strategy.old <- future::plan("list")
[16:21:03.628]                   options(future.plan = NULL)
[16:21:03.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.628]                 }
[16:21:03.628]                 ...future.workdir <- getwd()
[16:21:03.628]             }
[16:21:03.628]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.628]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.628]         }
[16:21:03.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.628]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.628]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.628]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.628]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.628]             base::names(...future.oldOptions))
[16:21:03.628]     }
[16:21:03.628]     if (FALSE) {
[16:21:03.628]     }
[16:21:03.628]     else {
[16:21:03.628]         if (TRUE) {
[16:21:03.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.628]                 open = "w")
[16:21:03.628]         }
[16:21:03.628]         else {
[16:21:03.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.628]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.628]         }
[16:21:03.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.628]             base::sink(type = "output", split = FALSE)
[16:21:03.628]             base::close(...future.stdout)
[16:21:03.628]         }, add = TRUE)
[16:21:03.628]     }
[16:21:03.628]     ...future.frame <- base::sys.nframe()
[16:21:03.628]     ...future.conditions <- base::list()
[16:21:03.628]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.628]     if (FALSE) {
[16:21:03.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.628]     }
[16:21:03.628]     ...future.result <- base::tryCatch({
[16:21:03.628]         base::withCallingHandlers({
[16:21:03.628]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:21:03.628]                 1))
[16:21:03.628]             future::FutureResult(value = ...future.value$value, 
[16:21:03.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.628]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.628]                     ...future.globalenv.names))
[16:21:03.628]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.628]         }, condition = base::local({
[16:21:03.628]             c <- base::c
[16:21:03.628]             inherits <- base::inherits
[16:21:03.628]             invokeRestart <- base::invokeRestart
[16:21:03.628]             length <- base::length
[16:21:03.628]             list <- base::list
[16:21:03.628]             seq.int <- base::seq.int
[16:21:03.628]             signalCondition <- base::signalCondition
[16:21:03.628]             sys.calls <- base::sys.calls
[16:21:03.628]             `[[` <- base::`[[`
[16:21:03.628]             `+` <- base::`+`
[16:21:03.628]             `<<-` <- base::`<<-`
[16:21:03.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.628]                   3L)]
[16:21:03.628]             }
[16:21:03.628]             function(cond) {
[16:21:03.628]                 is_error <- inherits(cond, "error")
[16:21:03.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.628]                   NULL)
[16:21:03.628]                 if (is_error) {
[16:21:03.628]                   sessionInformation <- function() {
[16:21:03.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.628]                       search = base::search(), system = base::Sys.info())
[16:21:03.628]                   }
[16:21:03.628]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.628]                     cond$call), session = sessionInformation(), 
[16:21:03.628]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.628]                   signalCondition(cond)
[16:21:03.628]                 }
[16:21:03.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.628]                 "immediateCondition"))) {
[16:21:03.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.628]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.628]                   if (TRUE && !signal) {
[16:21:03.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.628]                     {
[16:21:03.628]                       inherits <- base::inherits
[16:21:03.628]                       invokeRestart <- base::invokeRestart
[16:21:03.628]                       is.null <- base::is.null
[16:21:03.628]                       muffled <- FALSE
[16:21:03.628]                       if (inherits(cond, "message")) {
[16:21:03.628]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.628]                         if (muffled) 
[16:21:03.628]                           invokeRestart("muffleMessage")
[16:21:03.628]                       }
[16:21:03.628]                       else if (inherits(cond, "warning")) {
[16:21:03.628]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.628]                         if (muffled) 
[16:21:03.628]                           invokeRestart("muffleWarning")
[16:21:03.628]                       }
[16:21:03.628]                       else if (inherits(cond, "condition")) {
[16:21:03.628]                         if (!is.null(pattern)) {
[16:21:03.628]                           computeRestarts <- base::computeRestarts
[16:21:03.628]                           grepl <- base::grepl
[16:21:03.628]                           restarts <- computeRestarts(cond)
[16:21:03.628]                           for (restart in restarts) {
[16:21:03.628]                             name <- restart$name
[16:21:03.628]                             if (is.null(name)) 
[16:21:03.628]                               next
[16:21:03.628]                             if (!grepl(pattern, name)) 
[16:21:03.628]                               next
[16:21:03.628]                             invokeRestart(restart)
[16:21:03.628]                             muffled <- TRUE
[16:21:03.628]                             break
[16:21:03.628]                           }
[16:21:03.628]                         }
[16:21:03.628]                       }
[16:21:03.628]                       invisible(muffled)
[16:21:03.628]                     }
[16:21:03.628]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.628]                   }
[16:21:03.628]                 }
[16:21:03.628]                 else {
[16:21:03.628]                   if (TRUE) {
[16:21:03.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.628]                     {
[16:21:03.628]                       inherits <- base::inherits
[16:21:03.628]                       invokeRestart <- base::invokeRestart
[16:21:03.628]                       is.null <- base::is.null
[16:21:03.628]                       muffled <- FALSE
[16:21:03.628]                       if (inherits(cond, "message")) {
[16:21:03.628]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.628]                         if (muffled) 
[16:21:03.628]                           invokeRestart("muffleMessage")
[16:21:03.628]                       }
[16:21:03.628]                       else if (inherits(cond, "warning")) {
[16:21:03.628]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.628]                         if (muffled) 
[16:21:03.628]                           invokeRestart("muffleWarning")
[16:21:03.628]                       }
[16:21:03.628]                       else if (inherits(cond, "condition")) {
[16:21:03.628]                         if (!is.null(pattern)) {
[16:21:03.628]                           computeRestarts <- base::computeRestarts
[16:21:03.628]                           grepl <- base::grepl
[16:21:03.628]                           restarts <- computeRestarts(cond)
[16:21:03.628]                           for (restart in restarts) {
[16:21:03.628]                             name <- restart$name
[16:21:03.628]                             if (is.null(name)) 
[16:21:03.628]                               next
[16:21:03.628]                             if (!grepl(pattern, name)) 
[16:21:03.628]                               next
[16:21:03.628]                             invokeRestart(restart)
[16:21:03.628]                             muffled <- TRUE
[16:21:03.628]                             break
[16:21:03.628]                           }
[16:21:03.628]                         }
[16:21:03.628]                       }
[16:21:03.628]                       invisible(muffled)
[16:21:03.628]                     }
[16:21:03.628]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.628]                   }
[16:21:03.628]                 }
[16:21:03.628]             }
[16:21:03.628]         }))
[16:21:03.628]     }, error = function(ex) {
[16:21:03.628]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.628]                 ...future.rng), started = ...future.startTime, 
[16:21:03.628]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.628]             version = "1.8"), class = "FutureResult")
[16:21:03.628]     }, finally = {
[16:21:03.628]         if (!identical(...future.workdir, getwd())) 
[16:21:03.628]             setwd(...future.workdir)
[16:21:03.628]         {
[16:21:03.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.628]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.628]             }
[16:21:03.628]             base::options(...future.oldOptions)
[16:21:03.628]             if (.Platform$OS.type == "windows") {
[16:21:03.628]                 old_names <- names(...future.oldEnvVars)
[16:21:03.628]                 envs <- base::Sys.getenv()
[16:21:03.628]                 names <- names(envs)
[16:21:03.628]                 common <- intersect(names, old_names)
[16:21:03.628]                 added <- setdiff(names, old_names)
[16:21:03.628]                 removed <- setdiff(old_names, names)
[16:21:03.628]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.628]                   envs[common]]
[16:21:03.628]                 NAMES <- toupper(changed)
[16:21:03.628]                 args <- list()
[16:21:03.628]                 for (kk in seq_along(NAMES)) {
[16:21:03.628]                   name <- changed[[kk]]
[16:21:03.628]                   NAME <- NAMES[[kk]]
[16:21:03.628]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.628]                     next
[16:21:03.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.628]                 }
[16:21:03.628]                 NAMES <- toupper(added)
[16:21:03.628]                 for (kk in seq_along(NAMES)) {
[16:21:03.628]                   name <- added[[kk]]
[16:21:03.628]                   NAME <- NAMES[[kk]]
[16:21:03.628]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.628]                     next
[16:21:03.628]                   args[[name]] <- ""
[16:21:03.628]                 }
[16:21:03.628]                 NAMES <- toupper(removed)
[16:21:03.628]                 for (kk in seq_along(NAMES)) {
[16:21:03.628]                   name <- removed[[kk]]
[16:21:03.628]                   NAME <- NAMES[[kk]]
[16:21:03.628]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.628]                     next
[16:21:03.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.628]                 }
[16:21:03.628]                 if (length(args) > 0) 
[16:21:03.628]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.628]             }
[16:21:03.628]             else {
[16:21:03.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.628]             }
[16:21:03.628]             {
[16:21:03.628]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.628]                   0L) {
[16:21:03.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.628]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.628]                   base::options(opts)
[16:21:03.628]                 }
[16:21:03.628]                 {
[16:21:03.628]                   {
[16:21:03.628]                     NULL
[16:21:03.628]                     RNGkind("Mersenne-Twister")
[16:21:03.628]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.628]                       inherits = FALSE)
[16:21:03.628]                   }
[16:21:03.628]                   options(future.plan = NULL)
[16:21:03.628]                   if (is.na(NA_character_)) 
[16:21:03.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.628]                     .init = FALSE)
[16:21:03.628]                 }
[16:21:03.628]             }
[16:21:03.628]         }
[16:21:03.628]     })
[16:21:03.628]     if (TRUE) {
[16:21:03.628]         base::sink(type = "output", split = FALSE)
[16:21:03.628]         if (TRUE) {
[16:21:03.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.628]         }
[16:21:03.628]         else {
[16:21:03.628]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.628]         }
[16:21:03.628]         base::close(...future.stdout)
[16:21:03.628]         ...future.stdout <- NULL
[16:21:03.628]     }
[16:21:03.628]     ...future.result$conditions <- ...future.conditions
[16:21:03.628]     ...future.result$finished <- base::Sys.time()
[16:21:03.628]     ...future.result
[16:21:03.628] }
[16:21:03.630] assign_globals() ...
[16:21:03.630] List of 1
[16:21:03.630]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5622287e80b8> 
[16:21:03.630]  - attr(*, "where")=List of 1
[16:21:03.630]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.630]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.630]  - attr(*, "resolved")= logi TRUE
[16:21:03.630]  - attr(*, "total_size")= num 1621800
[16:21:03.630]  - attr(*, "already-done")= logi TRUE
[16:21:03.633] - copied ‘a’ to environment
[16:21:03.633] assign_globals() ... done
[16:21:03.633] plan(): Setting new future strategy stack:
[16:21:03.633] List of future strategies:
[16:21:03.633] 1. sequential:
[16:21:03.633]    - args: function (..., envir = parent.frame())
[16:21:03.633]    - tweaked: FALSE
[16:21:03.633]    - call: NULL
[16:21:03.633] plan(): nbrOfWorkers() = 1
[16:21:03.634] plan(): Setting new future strategy stack:
[16:21:03.634] List of future strategies:
[16:21:03.634] 1. sequential:
[16:21:03.634]    - args: function (..., envir = parent.frame())
[16:21:03.634]    - tweaked: FALSE
[16:21:03.634]    - call: plan(strategy)
[16:21:03.635] plan(): nbrOfWorkers() = 1
[16:21:03.635] SequentialFuture started (and completed)
[16:21:03.635] - Launch lazy future ... done
[16:21:03.635] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.636] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.636] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.636] 
[16:21:03.636] Searching for globals ... DONE
[16:21:03.636] - globals: [0] <none>
[16:21:03.636] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.637] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.637] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.638] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:03.638] Searching for globals ... DONE
[16:21:03.638] Resolving globals: TRUE
[16:21:03.638] Resolving any globals that are futures ...
[16:21:03.638] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:03.638] Resolving any globals that are futures ... DONE
[16:21:03.638] Resolving futures part of globals (recursively) ...
[16:21:03.639] resolve() on list ...
[16:21:03.639]  recursive: 99
[16:21:03.639]  length: 1
[16:21:03.639]  elements: ‘a’
[16:21:03.639] run() for ‘Future’ ...
[16:21:03.639] - state: ‘created’
[16:21:03.639] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.640] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.640] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.640]   - Field: ‘label’
[16:21:03.640]   - Field: ‘local’
[16:21:03.640]   - Field: ‘owner’
[16:21:03.640]   - Field: ‘envir’
[16:21:03.640]   - Field: ‘packages’
[16:21:03.640]   - Field: ‘gc’
[16:21:03.640]   - Field: ‘conditions’
[16:21:03.640]   - Field: ‘expr’
[16:21:03.641]   - Field: ‘uuid’
[16:21:03.641]   - Field: ‘seed’
[16:21:03.641]   - Field: ‘version’
[16:21:03.642]   - Field: ‘result’
[16:21:03.642]   - Field: ‘asynchronous’
[16:21:03.642]   - Field: ‘calls’
[16:21:03.643]   - Field: ‘globals’
[16:21:03.643]   - Field: ‘stdout’
[16:21:03.643]   - Field: ‘earlySignal’
[16:21:03.643]   - Field: ‘lazy’
[16:21:03.643]   - Field: ‘state’
[16:21:03.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.643] - Launch lazy future ...
[16:21:03.643] Packages needed by the future expression (n = 0): <none>
[16:21:03.644] Packages needed by future strategies (n = 0): <none>
[16:21:03.644] {
[16:21:03.644]     {
[16:21:03.644]         {
[16:21:03.644]             ...future.startTime <- base::Sys.time()
[16:21:03.644]             {
[16:21:03.644]                 {
[16:21:03.644]                   {
[16:21:03.644]                     base::local({
[16:21:03.644]                       has_future <- base::requireNamespace("future", 
[16:21:03.644]                         quietly = TRUE)
[16:21:03.644]                       if (has_future) {
[16:21:03.644]                         ns <- base::getNamespace("future")
[16:21:03.644]                         version <- ns[[".package"]][["version"]]
[16:21:03.644]                         if (is.null(version)) 
[16:21:03.644]                           version <- utils::packageVersion("future")
[16:21:03.644]                       }
[16:21:03.644]                       else {
[16:21:03.644]                         version <- NULL
[16:21:03.644]                       }
[16:21:03.644]                       if (!has_future || version < "1.8.0") {
[16:21:03.644]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.644]                           "", base::R.version$version.string), 
[16:21:03.644]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.644]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.644]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.644]                             "release", "version")], collapse = " "), 
[16:21:03.644]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.644]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.644]                           info)
[16:21:03.644]                         info <- base::paste(info, collapse = "; ")
[16:21:03.644]                         if (!has_future) {
[16:21:03.644]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.644]                             info)
[16:21:03.644]                         }
[16:21:03.644]                         else {
[16:21:03.644]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.644]                             info, version)
[16:21:03.644]                         }
[16:21:03.644]                         base::stop(msg)
[16:21:03.644]                       }
[16:21:03.644]                     })
[16:21:03.644]                   }
[16:21:03.644]                   ...future.strategy.old <- future::plan("list")
[16:21:03.644]                   options(future.plan = NULL)
[16:21:03.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.644]                 }
[16:21:03.644]                 ...future.workdir <- getwd()
[16:21:03.644]             }
[16:21:03.644]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.644]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.644]         }
[16:21:03.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.644]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.644]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.644]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.644]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.644]             base::names(...future.oldOptions))
[16:21:03.644]     }
[16:21:03.644]     if (FALSE) {
[16:21:03.644]     }
[16:21:03.644]     else {
[16:21:03.644]         if (TRUE) {
[16:21:03.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.644]                 open = "w")
[16:21:03.644]         }
[16:21:03.644]         else {
[16:21:03.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.644]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.644]         }
[16:21:03.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.644]             base::sink(type = "output", split = FALSE)
[16:21:03.644]             base::close(...future.stdout)
[16:21:03.644]         }, add = TRUE)
[16:21:03.644]     }
[16:21:03.644]     ...future.frame <- base::sys.nframe()
[16:21:03.644]     ...future.conditions <- base::list()
[16:21:03.644]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.644]     if (FALSE) {
[16:21:03.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.644]     }
[16:21:03.644]     ...future.result <- base::tryCatch({
[16:21:03.644]         base::withCallingHandlers({
[16:21:03.644]             ...future.value <- base::withVisible(base::local(1))
[16:21:03.644]             future::FutureResult(value = ...future.value$value, 
[16:21:03.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.644]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.644]                     ...future.globalenv.names))
[16:21:03.644]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.644]         }, condition = base::local({
[16:21:03.644]             c <- base::c
[16:21:03.644]             inherits <- base::inherits
[16:21:03.644]             invokeRestart <- base::invokeRestart
[16:21:03.644]             length <- base::length
[16:21:03.644]             list <- base::list
[16:21:03.644]             seq.int <- base::seq.int
[16:21:03.644]             signalCondition <- base::signalCondition
[16:21:03.644]             sys.calls <- base::sys.calls
[16:21:03.644]             `[[` <- base::`[[`
[16:21:03.644]             `+` <- base::`+`
[16:21:03.644]             `<<-` <- base::`<<-`
[16:21:03.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.644]                   3L)]
[16:21:03.644]             }
[16:21:03.644]             function(cond) {
[16:21:03.644]                 is_error <- inherits(cond, "error")
[16:21:03.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.644]                   NULL)
[16:21:03.644]                 if (is_error) {
[16:21:03.644]                   sessionInformation <- function() {
[16:21:03.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.644]                       search = base::search(), system = base::Sys.info())
[16:21:03.644]                   }
[16:21:03.644]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.644]                     cond$call), session = sessionInformation(), 
[16:21:03.644]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.644]                   signalCondition(cond)
[16:21:03.644]                 }
[16:21:03.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.644]                 "immediateCondition"))) {
[16:21:03.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.644]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.644]                   if (TRUE && !signal) {
[16:21:03.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.644]                     {
[16:21:03.644]                       inherits <- base::inherits
[16:21:03.644]                       invokeRestart <- base::invokeRestart
[16:21:03.644]                       is.null <- base::is.null
[16:21:03.644]                       muffled <- FALSE
[16:21:03.644]                       if (inherits(cond, "message")) {
[16:21:03.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.644]                         if (muffled) 
[16:21:03.644]                           invokeRestart("muffleMessage")
[16:21:03.644]                       }
[16:21:03.644]                       else if (inherits(cond, "warning")) {
[16:21:03.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.644]                         if (muffled) 
[16:21:03.644]                           invokeRestart("muffleWarning")
[16:21:03.644]                       }
[16:21:03.644]                       else if (inherits(cond, "condition")) {
[16:21:03.644]                         if (!is.null(pattern)) {
[16:21:03.644]                           computeRestarts <- base::computeRestarts
[16:21:03.644]                           grepl <- base::grepl
[16:21:03.644]                           restarts <- computeRestarts(cond)
[16:21:03.644]                           for (restart in restarts) {
[16:21:03.644]                             name <- restart$name
[16:21:03.644]                             if (is.null(name)) 
[16:21:03.644]                               next
[16:21:03.644]                             if (!grepl(pattern, name)) 
[16:21:03.644]                               next
[16:21:03.644]                             invokeRestart(restart)
[16:21:03.644]                             muffled <- TRUE
[16:21:03.644]                             break
[16:21:03.644]                           }
[16:21:03.644]                         }
[16:21:03.644]                       }
[16:21:03.644]                       invisible(muffled)
[16:21:03.644]                     }
[16:21:03.644]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.644]                   }
[16:21:03.644]                 }
[16:21:03.644]                 else {
[16:21:03.644]                   if (TRUE) {
[16:21:03.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.644]                     {
[16:21:03.644]                       inherits <- base::inherits
[16:21:03.644]                       invokeRestart <- base::invokeRestart
[16:21:03.644]                       is.null <- base::is.null
[16:21:03.644]                       muffled <- FALSE
[16:21:03.644]                       if (inherits(cond, "message")) {
[16:21:03.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.644]                         if (muffled) 
[16:21:03.644]                           invokeRestart("muffleMessage")
[16:21:03.644]                       }
[16:21:03.644]                       else if (inherits(cond, "warning")) {
[16:21:03.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.644]                         if (muffled) 
[16:21:03.644]                           invokeRestart("muffleWarning")
[16:21:03.644]                       }
[16:21:03.644]                       else if (inherits(cond, "condition")) {
[16:21:03.644]                         if (!is.null(pattern)) {
[16:21:03.644]                           computeRestarts <- base::computeRestarts
[16:21:03.644]                           grepl <- base::grepl
[16:21:03.644]                           restarts <- computeRestarts(cond)
[16:21:03.644]                           for (restart in restarts) {
[16:21:03.644]                             name <- restart$name
[16:21:03.644]                             if (is.null(name)) 
[16:21:03.644]                               next
[16:21:03.644]                             if (!grepl(pattern, name)) 
[16:21:03.644]                               next
[16:21:03.644]                             invokeRestart(restart)
[16:21:03.644]                             muffled <- TRUE
[16:21:03.644]                             break
[16:21:03.644]                           }
[16:21:03.644]                         }
[16:21:03.644]                       }
[16:21:03.644]                       invisible(muffled)
[16:21:03.644]                     }
[16:21:03.644]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.644]                   }
[16:21:03.644]                 }
[16:21:03.644]             }
[16:21:03.644]         }))
[16:21:03.644]     }, error = function(ex) {
[16:21:03.644]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.644]                 ...future.rng), started = ...future.startTime, 
[16:21:03.644]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.644]             version = "1.8"), class = "FutureResult")
[16:21:03.644]     }, finally = {
[16:21:03.644]         if (!identical(...future.workdir, getwd())) 
[16:21:03.644]             setwd(...future.workdir)
[16:21:03.644]         {
[16:21:03.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.644]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.644]             }
[16:21:03.644]             base::options(...future.oldOptions)
[16:21:03.644]             if (.Platform$OS.type == "windows") {
[16:21:03.644]                 old_names <- names(...future.oldEnvVars)
[16:21:03.644]                 envs <- base::Sys.getenv()
[16:21:03.644]                 names <- names(envs)
[16:21:03.644]                 common <- intersect(names, old_names)
[16:21:03.644]                 added <- setdiff(names, old_names)
[16:21:03.644]                 removed <- setdiff(old_names, names)
[16:21:03.644]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.644]                   envs[common]]
[16:21:03.644]                 NAMES <- toupper(changed)
[16:21:03.644]                 args <- list()
[16:21:03.644]                 for (kk in seq_along(NAMES)) {
[16:21:03.644]                   name <- changed[[kk]]
[16:21:03.644]                   NAME <- NAMES[[kk]]
[16:21:03.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.644]                     next
[16:21:03.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.644]                 }
[16:21:03.644]                 NAMES <- toupper(added)
[16:21:03.644]                 for (kk in seq_along(NAMES)) {
[16:21:03.644]                   name <- added[[kk]]
[16:21:03.644]                   NAME <- NAMES[[kk]]
[16:21:03.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.644]                     next
[16:21:03.644]                   args[[name]] <- ""
[16:21:03.644]                 }
[16:21:03.644]                 NAMES <- toupper(removed)
[16:21:03.644]                 for (kk in seq_along(NAMES)) {
[16:21:03.644]                   name <- removed[[kk]]
[16:21:03.644]                   NAME <- NAMES[[kk]]
[16:21:03.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.644]                     next
[16:21:03.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.644]                 }
[16:21:03.644]                 if (length(args) > 0) 
[16:21:03.644]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.644]             }
[16:21:03.644]             else {
[16:21:03.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.644]             }
[16:21:03.644]             {
[16:21:03.644]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.644]                   0L) {
[16:21:03.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.644]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.644]                   base::options(opts)
[16:21:03.644]                 }
[16:21:03.644]                 {
[16:21:03.644]                   {
[16:21:03.644]                     NULL
[16:21:03.644]                     RNGkind("Mersenne-Twister")
[16:21:03.644]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.644]                       inherits = FALSE)
[16:21:03.644]                   }
[16:21:03.644]                   options(future.plan = NULL)
[16:21:03.644]                   if (is.na(NA_character_)) 
[16:21:03.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.644]                     .init = FALSE)
[16:21:03.644]                 }
[16:21:03.644]             }
[16:21:03.644]         }
[16:21:03.644]     })
[16:21:03.644]     if (TRUE) {
[16:21:03.644]         base::sink(type = "output", split = FALSE)
[16:21:03.644]         if (TRUE) {
[16:21:03.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.644]         }
[16:21:03.644]         else {
[16:21:03.644]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.644]         }
[16:21:03.644]         base::close(...future.stdout)
[16:21:03.644]         ...future.stdout <- NULL
[16:21:03.644]     }
[16:21:03.644]     ...future.result$conditions <- ...future.conditions
[16:21:03.644]     ...future.result$finished <- base::Sys.time()
[16:21:03.644]     ...future.result
[16:21:03.644] }
[16:21:03.646] plan(): Setting new future strategy stack:
[16:21:03.646] List of future strategies:
[16:21:03.646] 1. sequential:
[16:21:03.646]    - args: function (..., envir = parent.frame())
[16:21:03.646]    - tweaked: FALSE
[16:21:03.646]    - call: NULL
[16:21:03.646] plan(): nbrOfWorkers() = 1
[16:21:03.647] plan(): Setting new future strategy stack:
[16:21:03.647] List of future strategies:
[16:21:03.647] 1. sequential:
[16:21:03.647]    - args: function (..., envir = parent.frame())
[16:21:03.647]    - tweaked: FALSE
[16:21:03.647]    - call: plan(strategy)
[16:21:03.647] plan(): nbrOfWorkers() = 1
[16:21:03.648] SequentialFuture started (and completed)
[16:21:03.648] - Launch lazy future ... done
[16:21:03.648] run() for ‘SequentialFuture’ ... done
[16:21:03.648] resolved() for ‘SequentialFuture’ ...
[16:21:03.648] - state: ‘finished’
[16:21:03.648] - run: TRUE
[16:21:03.648] - result: ‘FutureResult’
[16:21:03.648] resolved() for ‘SequentialFuture’ ... done
[16:21:03.648] Future #1
[16:21:03.649] resolved() for ‘SequentialFuture’ ...
[16:21:03.649] - state: ‘finished’
[16:21:03.649] - run: TRUE
[16:21:03.649] - result: ‘FutureResult’
[16:21:03.649] resolved() for ‘SequentialFuture’ ... done
[16:21:03.649] A SequentialFuture was resolved
[16:21:03.649]  length: 0 (resolved future 1)
[16:21:03.649] resolve() on list ... DONE
[16:21:03.649] - globals: [1] ‘a’
[16:21:03.649] Resolving futures part of globals (recursively) ... DONE
[16:21:03.651] The total size of the 1 globals is 1.55 MiB (1621968 bytes)
[16:21:03.652] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:21:03.652] - globals: [1] ‘a’
[16:21:03.652] - packages: [1] ‘future’
[16:21:03.652] getGlobalsAndPackages() ... DONE
[16:21:03.652] run() for ‘Future’ ...
[16:21:03.652] - state: ‘created’
[16:21:03.653] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.653] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.653]   - Field: ‘label’
[16:21:03.653]   - Field: ‘local’
[16:21:03.653]   - Field: ‘owner’
[16:21:03.653]   - Field: ‘envir’
[16:21:03.653]   - Field: ‘packages’
[16:21:03.653]   - Field: ‘gc’
[16:21:03.654]   - Field: ‘conditions’
[16:21:03.654]   - Field: ‘expr’
[16:21:03.654]   - Field: ‘uuid’
[16:21:03.654]   - Field: ‘seed’
[16:21:03.654]   - Field: ‘version’
[16:21:03.654]   - Field: ‘result’
[16:21:03.654]   - Field: ‘asynchronous’
[16:21:03.654]   - Field: ‘calls’
[16:21:03.654]   - Field: ‘globals’
[16:21:03.654]   - Field: ‘stdout’
[16:21:03.654]   - Field: ‘earlySignal’
[16:21:03.655]   - Field: ‘lazy’
[16:21:03.655]   - Field: ‘state’
[16:21:03.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.655] - Launch lazy future ...
[16:21:03.655] Packages needed by the future expression (n = 1): ‘future’
[16:21:03.655] Packages needed by future strategies (n = 0): <none>
[16:21:03.656] {
[16:21:03.656]     {
[16:21:03.656]         {
[16:21:03.656]             ...future.startTime <- base::Sys.time()
[16:21:03.656]             {
[16:21:03.656]                 {
[16:21:03.656]                   {
[16:21:03.656]                     {
[16:21:03.656]                       base::local({
[16:21:03.656]                         has_future <- base::requireNamespace("future", 
[16:21:03.656]                           quietly = TRUE)
[16:21:03.656]                         if (has_future) {
[16:21:03.656]                           ns <- base::getNamespace("future")
[16:21:03.656]                           version <- ns[[".package"]][["version"]]
[16:21:03.656]                           if (is.null(version)) 
[16:21:03.656]                             version <- utils::packageVersion("future")
[16:21:03.656]                         }
[16:21:03.656]                         else {
[16:21:03.656]                           version <- NULL
[16:21:03.656]                         }
[16:21:03.656]                         if (!has_future || version < "1.8.0") {
[16:21:03.656]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.656]                             "", base::R.version$version.string), 
[16:21:03.656]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.656]                               "release", "version")], collapse = " "), 
[16:21:03.656]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.656]                             info)
[16:21:03.656]                           info <- base::paste(info, collapse = "; ")
[16:21:03.656]                           if (!has_future) {
[16:21:03.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.656]                               info)
[16:21:03.656]                           }
[16:21:03.656]                           else {
[16:21:03.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.656]                               info, version)
[16:21:03.656]                           }
[16:21:03.656]                           base::stop(msg)
[16:21:03.656]                         }
[16:21:03.656]                       })
[16:21:03.656]                     }
[16:21:03.656]                     base::local({
[16:21:03.656]                       for (pkg in "future") {
[16:21:03.656]                         base::loadNamespace(pkg)
[16:21:03.656]                         base::library(pkg, character.only = TRUE)
[16:21:03.656]                       }
[16:21:03.656]                     })
[16:21:03.656]                   }
[16:21:03.656]                   ...future.strategy.old <- future::plan("list")
[16:21:03.656]                   options(future.plan = NULL)
[16:21:03.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.656]                 }
[16:21:03.656]                 ...future.workdir <- getwd()
[16:21:03.656]             }
[16:21:03.656]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.656]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.656]         }
[16:21:03.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.656]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.656]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.656]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.656]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.656]             base::names(...future.oldOptions))
[16:21:03.656]     }
[16:21:03.656]     if (FALSE) {
[16:21:03.656]     }
[16:21:03.656]     else {
[16:21:03.656]         if (TRUE) {
[16:21:03.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.656]                 open = "w")
[16:21:03.656]         }
[16:21:03.656]         else {
[16:21:03.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.656]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.656]         }
[16:21:03.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.656]             base::sink(type = "output", split = FALSE)
[16:21:03.656]             base::close(...future.stdout)
[16:21:03.656]         }, add = TRUE)
[16:21:03.656]     }
[16:21:03.656]     ...future.frame <- base::sys.nframe()
[16:21:03.656]     ...future.conditions <- base::list()
[16:21:03.656]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.656]     if (FALSE) {
[16:21:03.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.656]     }
[16:21:03.656]     ...future.result <- base::tryCatch({
[16:21:03.656]         base::withCallingHandlers({
[16:21:03.656]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:21:03.656]                 1))
[16:21:03.656]             future::FutureResult(value = ...future.value$value, 
[16:21:03.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.656]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.656]                     ...future.globalenv.names))
[16:21:03.656]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.656]         }, condition = base::local({
[16:21:03.656]             c <- base::c
[16:21:03.656]             inherits <- base::inherits
[16:21:03.656]             invokeRestart <- base::invokeRestart
[16:21:03.656]             length <- base::length
[16:21:03.656]             list <- base::list
[16:21:03.656]             seq.int <- base::seq.int
[16:21:03.656]             signalCondition <- base::signalCondition
[16:21:03.656]             sys.calls <- base::sys.calls
[16:21:03.656]             `[[` <- base::`[[`
[16:21:03.656]             `+` <- base::`+`
[16:21:03.656]             `<<-` <- base::`<<-`
[16:21:03.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.656]                   3L)]
[16:21:03.656]             }
[16:21:03.656]             function(cond) {
[16:21:03.656]                 is_error <- inherits(cond, "error")
[16:21:03.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.656]                   NULL)
[16:21:03.656]                 if (is_error) {
[16:21:03.656]                   sessionInformation <- function() {
[16:21:03.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.656]                       search = base::search(), system = base::Sys.info())
[16:21:03.656]                   }
[16:21:03.656]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.656]                     cond$call), session = sessionInformation(), 
[16:21:03.656]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.656]                   signalCondition(cond)
[16:21:03.656]                 }
[16:21:03.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.656]                 "immediateCondition"))) {
[16:21:03.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.656]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.656]                   if (TRUE && !signal) {
[16:21:03.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.656]                     {
[16:21:03.656]                       inherits <- base::inherits
[16:21:03.656]                       invokeRestart <- base::invokeRestart
[16:21:03.656]                       is.null <- base::is.null
[16:21:03.656]                       muffled <- FALSE
[16:21:03.656]                       if (inherits(cond, "message")) {
[16:21:03.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.656]                         if (muffled) 
[16:21:03.656]                           invokeRestart("muffleMessage")
[16:21:03.656]                       }
[16:21:03.656]                       else if (inherits(cond, "warning")) {
[16:21:03.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.656]                         if (muffled) 
[16:21:03.656]                           invokeRestart("muffleWarning")
[16:21:03.656]                       }
[16:21:03.656]                       else if (inherits(cond, "condition")) {
[16:21:03.656]                         if (!is.null(pattern)) {
[16:21:03.656]                           computeRestarts <- base::computeRestarts
[16:21:03.656]                           grepl <- base::grepl
[16:21:03.656]                           restarts <- computeRestarts(cond)
[16:21:03.656]                           for (restart in restarts) {
[16:21:03.656]                             name <- restart$name
[16:21:03.656]                             if (is.null(name)) 
[16:21:03.656]                               next
[16:21:03.656]                             if (!grepl(pattern, name)) 
[16:21:03.656]                               next
[16:21:03.656]                             invokeRestart(restart)
[16:21:03.656]                             muffled <- TRUE
[16:21:03.656]                             break
[16:21:03.656]                           }
[16:21:03.656]                         }
[16:21:03.656]                       }
[16:21:03.656]                       invisible(muffled)
[16:21:03.656]                     }
[16:21:03.656]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.656]                   }
[16:21:03.656]                 }
[16:21:03.656]                 else {
[16:21:03.656]                   if (TRUE) {
[16:21:03.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.656]                     {
[16:21:03.656]                       inherits <- base::inherits
[16:21:03.656]                       invokeRestart <- base::invokeRestart
[16:21:03.656]                       is.null <- base::is.null
[16:21:03.656]                       muffled <- FALSE
[16:21:03.656]                       if (inherits(cond, "message")) {
[16:21:03.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.656]                         if (muffled) 
[16:21:03.656]                           invokeRestart("muffleMessage")
[16:21:03.656]                       }
[16:21:03.656]                       else if (inherits(cond, "warning")) {
[16:21:03.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.656]                         if (muffled) 
[16:21:03.656]                           invokeRestart("muffleWarning")
[16:21:03.656]                       }
[16:21:03.656]                       else if (inherits(cond, "condition")) {
[16:21:03.656]                         if (!is.null(pattern)) {
[16:21:03.656]                           computeRestarts <- base::computeRestarts
[16:21:03.656]                           grepl <- base::grepl
[16:21:03.656]                           restarts <- computeRestarts(cond)
[16:21:03.656]                           for (restart in restarts) {
[16:21:03.656]                             name <- restart$name
[16:21:03.656]                             if (is.null(name)) 
[16:21:03.656]                               next
[16:21:03.656]                             if (!grepl(pattern, name)) 
[16:21:03.656]                               next
[16:21:03.656]                             invokeRestart(restart)
[16:21:03.656]                             muffled <- TRUE
[16:21:03.656]                             break
[16:21:03.656]                           }
[16:21:03.656]                         }
[16:21:03.656]                       }
[16:21:03.656]                       invisible(muffled)
[16:21:03.656]                     }
[16:21:03.656]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.656]                   }
[16:21:03.656]                 }
[16:21:03.656]             }
[16:21:03.656]         }))
[16:21:03.656]     }, error = function(ex) {
[16:21:03.656]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.656]                 ...future.rng), started = ...future.startTime, 
[16:21:03.656]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.656]             version = "1.8"), class = "FutureResult")
[16:21:03.656]     }, finally = {
[16:21:03.656]         if (!identical(...future.workdir, getwd())) 
[16:21:03.656]             setwd(...future.workdir)
[16:21:03.656]         {
[16:21:03.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.656]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.656]             }
[16:21:03.656]             base::options(...future.oldOptions)
[16:21:03.656]             if (.Platform$OS.type == "windows") {
[16:21:03.656]                 old_names <- names(...future.oldEnvVars)
[16:21:03.656]                 envs <- base::Sys.getenv()
[16:21:03.656]                 names <- names(envs)
[16:21:03.656]                 common <- intersect(names, old_names)
[16:21:03.656]                 added <- setdiff(names, old_names)
[16:21:03.656]                 removed <- setdiff(old_names, names)
[16:21:03.656]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.656]                   envs[common]]
[16:21:03.656]                 NAMES <- toupper(changed)
[16:21:03.656]                 args <- list()
[16:21:03.656]                 for (kk in seq_along(NAMES)) {
[16:21:03.656]                   name <- changed[[kk]]
[16:21:03.656]                   NAME <- NAMES[[kk]]
[16:21:03.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.656]                     next
[16:21:03.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.656]                 }
[16:21:03.656]                 NAMES <- toupper(added)
[16:21:03.656]                 for (kk in seq_along(NAMES)) {
[16:21:03.656]                   name <- added[[kk]]
[16:21:03.656]                   NAME <- NAMES[[kk]]
[16:21:03.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.656]                     next
[16:21:03.656]                   args[[name]] <- ""
[16:21:03.656]                 }
[16:21:03.656]                 NAMES <- toupper(removed)
[16:21:03.656]                 for (kk in seq_along(NAMES)) {
[16:21:03.656]                   name <- removed[[kk]]
[16:21:03.656]                   NAME <- NAMES[[kk]]
[16:21:03.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.656]                     next
[16:21:03.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.656]                 }
[16:21:03.656]                 if (length(args) > 0) 
[16:21:03.656]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.656]             }
[16:21:03.656]             else {
[16:21:03.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.656]             }
[16:21:03.656]             {
[16:21:03.656]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.656]                   0L) {
[16:21:03.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.656]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.656]                   base::options(opts)
[16:21:03.656]                 }
[16:21:03.656]                 {
[16:21:03.656]                   {
[16:21:03.656]                     NULL
[16:21:03.656]                     RNGkind("Mersenne-Twister")
[16:21:03.656]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.656]                       inherits = FALSE)
[16:21:03.656]                   }
[16:21:03.656]                   options(future.plan = NULL)
[16:21:03.656]                   if (is.na(NA_character_)) 
[16:21:03.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.656]                     .init = FALSE)
[16:21:03.656]                 }
[16:21:03.656]             }
[16:21:03.656]         }
[16:21:03.656]     })
[16:21:03.656]     if (TRUE) {
[16:21:03.656]         base::sink(type = "output", split = FALSE)
[16:21:03.656]         if (TRUE) {
[16:21:03.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.656]         }
[16:21:03.656]         else {
[16:21:03.656]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.656]         }
[16:21:03.656]         base::close(...future.stdout)
[16:21:03.656]         ...future.stdout <- NULL
[16:21:03.656]     }
[16:21:03.656]     ...future.result$conditions <- ...future.conditions
[16:21:03.656]     ...future.result$finished <- base::Sys.time()
[16:21:03.656]     ...future.result
[16:21:03.656] }
[16:21:03.657] assign_globals() ...
[16:21:03.657] List of 1
[16:21:03.657]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56222872de20> 
[16:21:03.657]  - attr(*, "where")=List of 1
[16:21:03.657]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.657]  - attr(*, "resolved")= logi TRUE
[16:21:03.657]  - attr(*, "total_size")= num 1621968
[16:21:03.657]  - attr(*, "already-done")= logi TRUE
[16:21:03.660] - copied ‘a’ to environment
[16:21:03.660] assign_globals() ... done
[16:21:03.660] plan(): Setting new future strategy stack:
[16:21:03.660] List of future strategies:
[16:21:03.660] 1. sequential:
[16:21:03.660]    - args: function (..., envir = parent.frame())
[16:21:03.660]    - tweaked: FALSE
[16:21:03.660]    - call: NULL
[16:21:03.661] plan(): nbrOfWorkers() = 1
[16:21:03.661] plan(): Setting new future strategy stack:
[16:21:03.662] List of future strategies:
[16:21:03.662] 1. sequential:
[16:21:03.662]    - args: function (..., envir = parent.frame())
[16:21:03.662]    - tweaked: FALSE
[16:21:03.662]    - call: plan(strategy)
[16:21:03.662] plan(): nbrOfWorkers() = 1
[16:21:03.662] SequentialFuture started (and completed)
[16:21:03.662] - Launch lazy future ... done
[16:21:03.662] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.663] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.663] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.663] 
[16:21:03.663] Searching for globals ... DONE
[16:21:03.664] - globals: [0] <none>
[16:21:03.664] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.664] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.664] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.665] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:03.665] Searching for globals ... DONE
[16:21:03.665] Resolving globals: TRUE
[16:21:03.665] Resolving any globals that are futures ...
[16:21:03.665] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:03.665] Resolving any globals that are futures ... DONE
[16:21:03.666] Resolving futures part of globals (recursively) ...
[16:21:03.666] resolve() on list ...
[16:21:03.666]  recursive: 99
[16:21:03.666]  length: 1
[16:21:03.666]  elements: ‘a’
[16:21:03.666] run() for ‘Future’ ...
[16:21:03.666] - state: ‘created’
[16:21:03.667] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.667] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.667]   - Field: ‘label’
[16:21:03.667]   - Field: ‘local’
[16:21:03.667]   - Field: ‘owner’
[16:21:03.667]   - Field: ‘envir’
[16:21:03.667]   - Field: ‘packages’
[16:21:03.668]   - Field: ‘gc’
[16:21:03.668]   - Field: ‘conditions’
[16:21:03.668]   - Field: ‘expr’
[16:21:03.668]   - Field: ‘uuid’
[16:21:03.668]   - Field: ‘seed’
[16:21:03.668]   - Field: ‘version’
[16:21:03.668]   - Field: ‘result’
[16:21:03.668]   - Field: ‘asynchronous’
[16:21:03.668]   - Field: ‘calls’
[16:21:03.668]   - Field: ‘globals’
[16:21:03.668]   - Field: ‘stdout’
[16:21:03.669]   - Field: ‘earlySignal’
[16:21:03.669]   - Field: ‘lazy’
[16:21:03.669]   - Field: ‘state’
[16:21:03.669] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.669] - Launch lazy future ...
[16:21:03.669] Packages needed by the future expression (n = 0): <none>
[16:21:03.669] Packages needed by future strategies (n = 0): <none>
[16:21:03.670] {
[16:21:03.670]     {
[16:21:03.670]         {
[16:21:03.670]             ...future.startTime <- base::Sys.time()
[16:21:03.670]             {
[16:21:03.670]                 {
[16:21:03.670]                   {
[16:21:03.670]                     base::local({
[16:21:03.670]                       has_future <- base::requireNamespace("future", 
[16:21:03.670]                         quietly = TRUE)
[16:21:03.670]                       if (has_future) {
[16:21:03.670]                         ns <- base::getNamespace("future")
[16:21:03.670]                         version <- ns[[".package"]][["version"]]
[16:21:03.670]                         if (is.null(version)) 
[16:21:03.670]                           version <- utils::packageVersion("future")
[16:21:03.670]                       }
[16:21:03.670]                       else {
[16:21:03.670]                         version <- NULL
[16:21:03.670]                       }
[16:21:03.670]                       if (!has_future || version < "1.8.0") {
[16:21:03.670]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.670]                           "", base::R.version$version.string), 
[16:21:03.670]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.670]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.670]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.670]                             "release", "version")], collapse = " "), 
[16:21:03.670]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.670]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.670]                           info)
[16:21:03.670]                         info <- base::paste(info, collapse = "; ")
[16:21:03.670]                         if (!has_future) {
[16:21:03.670]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.670]                             info)
[16:21:03.670]                         }
[16:21:03.670]                         else {
[16:21:03.670]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.670]                             info, version)
[16:21:03.670]                         }
[16:21:03.670]                         base::stop(msg)
[16:21:03.670]                       }
[16:21:03.670]                     })
[16:21:03.670]                   }
[16:21:03.670]                   ...future.strategy.old <- future::plan("list")
[16:21:03.670]                   options(future.plan = NULL)
[16:21:03.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.670]                 }
[16:21:03.670]                 ...future.workdir <- getwd()
[16:21:03.670]             }
[16:21:03.670]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.670]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.670]         }
[16:21:03.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.670]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.670]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.670]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.670]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.670]             base::names(...future.oldOptions))
[16:21:03.670]     }
[16:21:03.670]     if (FALSE) {
[16:21:03.670]     }
[16:21:03.670]     else {
[16:21:03.670]         if (TRUE) {
[16:21:03.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.670]                 open = "w")
[16:21:03.670]         }
[16:21:03.670]         else {
[16:21:03.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.670]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.670]         }
[16:21:03.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.670]             base::sink(type = "output", split = FALSE)
[16:21:03.670]             base::close(...future.stdout)
[16:21:03.670]         }, add = TRUE)
[16:21:03.670]     }
[16:21:03.670]     ...future.frame <- base::sys.nframe()
[16:21:03.670]     ...future.conditions <- base::list()
[16:21:03.670]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.670]     if (FALSE) {
[16:21:03.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.670]     }
[16:21:03.670]     ...future.result <- base::tryCatch({
[16:21:03.670]         base::withCallingHandlers({
[16:21:03.670]             ...future.value <- base::withVisible(base::local(1))
[16:21:03.670]             future::FutureResult(value = ...future.value$value, 
[16:21:03.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.670]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.670]                     ...future.globalenv.names))
[16:21:03.670]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.670]         }, condition = base::local({
[16:21:03.670]             c <- base::c
[16:21:03.670]             inherits <- base::inherits
[16:21:03.670]             invokeRestart <- base::invokeRestart
[16:21:03.670]             length <- base::length
[16:21:03.670]             list <- base::list
[16:21:03.670]             seq.int <- base::seq.int
[16:21:03.670]             signalCondition <- base::signalCondition
[16:21:03.670]             sys.calls <- base::sys.calls
[16:21:03.670]             `[[` <- base::`[[`
[16:21:03.670]             `+` <- base::`+`
[16:21:03.670]             `<<-` <- base::`<<-`
[16:21:03.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.670]                   3L)]
[16:21:03.670]             }
[16:21:03.670]             function(cond) {
[16:21:03.670]                 is_error <- inherits(cond, "error")
[16:21:03.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.670]                   NULL)
[16:21:03.670]                 if (is_error) {
[16:21:03.670]                   sessionInformation <- function() {
[16:21:03.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.670]                       search = base::search(), system = base::Sys.info())
[16:21:03.670]                   }
[16:21:03.670]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.670]                     cond$call), session = sessionInformation(), 
[16:21:03.670]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.670]                   signalCondition(cond)
[16:21:03.670]                 }
[16:21:03.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.670]                 "immediateCondition"))) {
[16:21:03.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.670]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.670]                   if (TRUE && !signal) {
[16:21:03.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.670]                     {
[16:21:03.670]                       inherits <- base::inherits
[16:21:03.670]                       invokeRestart <- base::invokeRestart
[16:21:03.670]                       is.null <- base::is.null
[16:21:03.670]                       muffled <- FALSE
[16:21:03.670]                       if (inherits(cond, "message")) {
[16:21:03.670]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.670]                         if (muffled) 
[16:21:03.670]                           invokeRestart("muffleMessage")
[16:21:03.670]                       }
[16:21:03.670]                       else if (inherits(cond, "warning")) {
[16:21:03.670]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.670]                         if (muffled) 
[16:21:03.670]                           invokeRestart("muffleWarning")
[16:21:03.670]                       }
[16:21:03.670]                       else if (inherits(cond, "condition")) {
[16:21:03.670]                         if (!is.null(pattern)) {
[16:21:03.670]                           computeRestarts <- base::computeRestarts
[16:21:03.670]                           grepl <- base::grepl
[16:21:03.670]                           restarts <- computeRestarts(cond)
[16:21:03.670]                           for (restart in restarts) {
[16:21:03.670]                             name <- restart$name
[16:21:03.670]                             if (is.null(name)) 
[16:21:03.670]                               next
[16:21:03.670]                             if (!grepl(pattern, name)) 
[16:21:03.670]                               next
[16:21:03.670]                             invokeRestart(restart)
[16:21:03.670]                             muffled <- TRUE
[16:21:03.670]                             break
[16:21:03.670]                           }
[16:21:03.670]                         }
[16:21:03.670]                       }
[16:21:03.670]                       invisible(muffled)
[16:21:03.670]                     }
[16:21:03.670]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.670]                   }
[16:21:03.670]                 }
[16:21:03.670]                 else {
[16:21:03.670]                   if (TRUE) {
[16:21:03.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.670]                     {
[16:21:03.670]                       inherits <- base::inherits
[16:21:03.670]                       invokeRestart <- base::invokeRestart
[16:21:03.670]                       is.null <- base::is.null
[16:21:03.670]                       muffled <- FALSE
[16:21:03.670]                       if (inherits(cond, "message")) {
[16:21:03.670]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.670]                         if (muffled) 
[16:21:03.670]                           invokeRestart("muffleMessage")
[16:21:03.670]                       }
[16:21:03.670]                       else if (inherits(cond, "warning")) {
[16:21:03.670]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.670]                         if (muffled) 
[16:21:03.670]                           invokeRestart("muffleWarning")
[16:21:03.670]                       }
[16:21:03.670]                       else if (inherits(cond, "condition")) {
[16:21:03.670]                         if (!is.null(pattern)) {
[16:21:03.670]                           computeRestarts <- base::computeRestarts
[16:21:03.670]                           grepl <- base::grepl
[16:21:03.670]                           restarts <- computeRestarts(cond)
[16:21:03.670]                           for (restart in restarts) {
[16:21:03.670]                             name <- restart$name
[16:21:03.670]                             if (is.null(name)) 
[16:21:03.670]                               next
[16:21:03.670]                             if (!grepl(pattern, name)) 
[16:21:03.670]                               next
[16:21:03.670]                             invokeRestart(restart)
[16:21:03.670]                             muffled <- TRUE
[16:21:03.670]                             break
[16:21:03.670]                           }
[16:21:03.670]                         }
[16:21:03.670]                       }
[16:21:03.670]                       invisible(muffled)
[16:21:03.670]                     }
[16:21:03.670]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.670]                   }
[16:21:03.670]                 }
[16:21:03.670]             }
[16:21:03.670]         }))
[16:21:03.670]     }, error = function(ex) {
[16:21:03.670]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.670]                 ...future.rng), started = ...future.startTime, 
[16:21:03.670]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.670]             version = "1.8"), class = "FutureResult")
[16:21:03.670]     }, finally = {
[16:21:03.670]         if (!identical(...future.workdir, getwd())) 
[16:21:03.670]             setwd(...future.workdir)
[16:21:03.670]         {
[16:21:03.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.670]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.670]             }
[16:21:03.670]             base::options(...future.oldOptions)
[16:21:03.670]             if (.Platform$OS.type == "windows") {
[16:21:03.670]                 old_names <- names(...future.oldEnvVars)
[16:21:03.670]                 envs <- base::Sys.getenv()
[16:21:03.670]                 names <- names(envs)
[16:21:03.670]                 common <- intersect(names, old_names)
[16:21:03.670]                 added <- setdiff(names, old_names)
[16:21:03.670]                 removed <- setdiff(old_names, names)
[16:21:03.670]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.670]                   envs[common]]
[16:21:03.670]                 NAMES <- toupper(changed)
[16:21:03.670]                 args <- list()
[16:21:03.670]                 for (kk in seq_along(NAMES)) {
[16:21:03.670]                   name <- changed[[kk]]
[16:21:03.670]                   NAME <- NAMES[[kk]]
[16:21:03.670]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.670]                     next
[16:21:03.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.670]                 }
[16:21:03.670]                 NAMES <- toupper(added)
[16:21:03.670]                 for (kk in seq_along(NAMES)) {
[16:21:03.670]                   name <- added[[kk]]
[16:21:03.670]                   NAME <- NAMES[[kk]]
[16:21:03.670]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.670]                     next
[16:21:03.670]                   args[[name]] <- ""
[16:21:03.670]                 }
[16:21:03.670]                 NAMES <- toupper(removed)
[16:21:03.670]                 for (kk in seq_along(NAMES)) {
[16:21:03.670]                   name <- removed[[kk]]
[16:21:03.670]                   NAME <- NAMES[[kk]]
[16:21:03.670]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.670]                     next
[16:21:03.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.670]                 }
[16:21:03.670]                 if (length(args) > 0) 
[16:21:03.670]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.670]             }
[16:21:03.670]             else {
[16:21:03.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.670]             }
[16:21:03.670]             {
[16:21:03.670]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.670]                   0L) {
[16:21:03.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.670]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.670]                   base::options(opts)
[16:21:03.670]                 }
[16:21:03.670]                 {
[16:21:03.670]                   {
[16:21:03.670]                     NULL
[16:21:03.670]                     RNGkind("Mersenne-Twister")
[16:21:03.670]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.670]                       inherits = FALSE)
[16:21:03.670]                   }
[16:21:03.670]                   options(future.plan = NULL)
[16:21:03.670]                   if (is.na(NA_character_)) 
[16:21:03.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.670]                     .init = FALSE)
[16:21:03.670]                 }
[16:21:03.670]             }
[16:21:03.670]         }
[16:21:03.670]     })
[16:21:03.670]     if (TRUE) {
[16:21:03.670]         base::sink(type = "output", split = FALSE)
[16:21:03.670]         if (TRUE) {
[16:21:03.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.670]         }
[16:21:03.670]         else {
[16:21:03.670]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.670]         }
[16:21:03.670]         base::close(...future.stdout)
[16:21:03.670]         ...future.stdout <- NULL
[16:21:03.670]     }
[16:21:03.670]     ...future.result$conditions <- ...future.conditions
[16:21:03.670]     ...future.result$finished <- base::Sys.time()
[16:21:03.670]     ...future.result
[16:21:03.670] }
[16:21:03.673] plan(): Setting new future strategy stack:
[16:21:03.673] List of future strategies:
[16:21:03.673] 1. sequential:
[16:21:03.673]    - args: function (..., envir = parent.frame())
[16:21:03.673]    - tweaked: FALSE
[16:21:03.673]    - call: NULL
[16:21:03.674] plan(): nbrOfWorkers() = 1
[16:21:03.674] plan(): Setting new future strategy stack:
[16:21:03.675] List of future strategies:
[16:21:03.675] 1. sequential:
[16:21:03.675]    - args: function (..., envir = parent.frame())
[16:21:03.675]    - tweaked: FALSE
[16:21:03.675]    - call: plan(strategy)
[16:21:03.675] plan(): nbrOfWorkers() = 1
[16:21:03.675] SequentialFuture started (and completed)
[16:21:03.675] - Launch lazy future ... done
[16:21:03.675] run() for ‘SequentialFuture’ ... done
[16:21:03.676] resolved() for ‘SequentialFuture’ ...
[16:21:03.676] - state: ‘finished’
[16:21:03.676] - run: TRUE
[16:21:03.676] - result: ‘FutureResult’
[16:21:03.676] resolved() for ‘SequentialFuture’ ... done
[16:21:03.676] Future #1
[16:21:03.676] resolved() for ‘SequentialFuture’ ...
[16:21:03.676] - state: ‘finished’
[16:21:03.676] - run: TRUE
[16:21:03.677] - result: ‘FutureResult’
[16:21:03.677] resolved() for ‘SequentialFuture’ ... done
[16:21:03.677] A SequentialFuture was resolved
[16:21:03.677]  length: 0 (resolved future 1)
[16:21:03.677] resolve() on list ... DONE
[16:21:03.677] - globals: [1] ‘a’
[16:21:03.677] Resolving futures part of globals (recursively) ... DONE
[16:21:03.679] The total size of the 1 globals is 1.55 MiB (1621968 bytes)
[16:21:03.679] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:21:03.680] - globals: [1] ‘a’
[16:21:03.680] - packages: [1] ‘future’
[16:21:03.680] getGlobalsAndPackages() ... DONE
[16:21:03.680] run() for ‘Future’ ...
[16:21:03.680] - state: ‘created’
[16:21:03.680] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.681] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.681]   - Field: ‘label’
[16:21:03.681]   - Field: ‘local’
[16:21:03.681]   - Field: ‘owner’
[16:21:03.681]   - Field: ‘envir’
[16:21:03.681]   - Field: ‘packages’
[16:21:03.681]   - Field: ‘gc’
[16:21:03.681]   - Field: ‘conditions’
[16:21:03.681]   - Field: ‘expr’
[16:21:03.682]   - Field: ‘uuid’
[16:21:03.682]   - Field: ‘seed’
[16:21:03.682]   - Field: ‘version’
[16:21:03.682]   - Field: ‘result’
[16:21:03.682]   - Field: ‘asynchronous’
[16:21:03.682]   - Field: ‘calls’
[16:21:03.682]   - Field: ‘globals’
[16:21:03.682]   - Field: ‘stdout’
[16:21:03.682]   - Field: ‘earlySignal’
[16:21:03.682]   - Field: ‘lazy’
[16:21:03.682]   - Field: ‘state’
[16:21:03.683] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.683] - Launch lazy future ...
[16:21:03.683] Packages needed by the future expression (n = 1): ‘future’
[16:21:03.683] Packages needed by future strategies (n = 0): <none>
[16:21:03.683] {
[16:21:03.683]     {
[16:21:03.683]         {
[16:21:03.683]             ...future.startTime <- base::Sys.time()
[16:21:03.683]             {
[16:21:03.683]                 {
[16:21:03.683]                   {
[16:21:03.683]                     {
[16:21:03.683]                       base::local({
[16:21:03.683]                         has_future <- base::requireNamespace("future", 
[16:21:03.683]                           quietly = TRUE)
[16:21:03.683]                         if (has_future) {
[16:21:03.683]                           ns <- base::getNamespace("future")
[16:21:03.683]                           version <- ns[[".package"]][["version"]]
[16:21:03.683]                           if (is.null(version)) 
[16:21:03.683]                             version <- utils::packageVersion("future")
[16:21:03.683]                         }
[16:21:03.683]                         else {
[16:21:03.683]                           version <- NULL
[16:21:03.683]                         }
[16:21:03.683]                         if (!has_future || version < "1.8.0") {
[16:21:03.683]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.683]                             "", base::R.version$version.string), 
[16:21:03.683]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.683]                               "release", "version")], collapse = " "), 
[16:21:03.683]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.683]                             info)
[16:21:03.683]                           info <- base::paste(info, collapse = "; ")
[16:21:03.683]                           if (!has_future) {
[16:21:03.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.683]                               info)
[16:21:03.683]                           }
[16:21:03.683]                           else {
[16:21:03.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.683]                               info, version)
[16:21:03.683]                           }
[16:21:03.683]                           base::stop(msg)
[16:21:03.683]                         }
[16:21:03.683]                       })
[16:21:03.683]                     }
[16:21:03.683]                     base::local({
[16:21:03.683]                       for (pkg in "future") {
[16:21:03.683]                         base::loadNamespace(pkg)
[16:21:03.683]                         base::library(pkg, character.only = TRUE)
[16:21:03.683]                       }
[16:21:03.683]                     })
[16:21:03.683]                   }
[16:21:03.683]                   ...future.strategy.old <- future::plan("list")
[16:21:03.683]                   options(future.plan = NULL)
[16:21:03.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.683]                 }
[16:21:03.683]                 ...future.workdir <- getwd()
[16:21:03.683]             }
[16:21:03.683]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.683]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.683]         }
[16:21:03.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.683]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.683]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.683]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.683]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.683]             base::names(...future.oldOptions))
[16:21:03.683]     }
[16:21:03.683]     if (FALSE) {
[16:21:03.683]     }
[16:21:03.683]     else {
[16:21:03.683]         if (TRUE) {
[16:21:03.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.683]                 open = "w")
[16:21:03.683]         }
[16:21:03.683]         else {
[16:21:03.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.683]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.683]         }
[16:21:03.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.683]             base::sink(type = "output", split = FALSE)
[16:21:03.683]             base::close(...future.stdout)
[16:21:03.683]         }, add = TRUE)
[16:21:03.683]     }
[16:21:03.683]     ...future.frame <- base::sys.nframe()
[16:21:03.683]     ...future.conditions <- base::list()
[16:21:03.683]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.683]     if (FALSE) {
[16:21:03.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.683]     }
[16:21:03.683]     ...future.result <- base::tryCatch({
[16:21:03.683]         base::withCallingHandlers({
[16:21:03.683]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:21:03.683]                 1))
[16:21:03.683]             future::FutureResult(value = ...future.value$value, 
[16:21:03.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.683]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.683]                     ...future.globalenv.names))
[16:21:03.683]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.683]         }, condition = base::local({
[16:21:03.683]             c <- base::c
[16:21:03.683]             inherits <- base::inherits
[16:21:03.683]             invokeRestart <- base::invokeRestart
[16:21:03.683]             length <- base::length
[16:21:03.683]             list <- base::list
[16:21:03.683]             seq.int <- base::seq.int
[16:21:03.683]             signalCondition <- base::signalCondition
[16:21:03.683]             sys.calls <- base::sys.calls
[16:21:03.683]             `[[` <- base::`[[`
[16:21:03.683]             `+` <- base::`+`
[16:21:03.683]             `<<-` <- base::`<<-`
[16:21:03.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.683]                   3L)]
[16:21:03.683]             }
[16:21:03.683]             function(cond) {
[16:21:03.683]                 is_error <- inherits(cond, "error")
[16:21:03.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.683]                   NULL)
[16:21:03.683]                 if (is_error) {
[16:21:03.683]                   sessionInformation <- function() {
[16:21:03.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.683]                       search = base::search(), system = base::Sys.info())
[16:21:03.683]                   }
[16:21:03.683]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.683]                     cond$call), session = sessionInformation(), 
[16:21:03.683]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.683]                   signalCondition(cond)
[16:21:03.683]                 }
[16:21:03.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.683]                 "immediateCondition"))) {
[16:21:03.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.683]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.683]                   if (TRUE && !signal) {
[16:21:03.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.683]                     {
[16:21:03.683]                       inherits <- base::inherits
[16:21:03.683]                       invokeRestart <- base::invokeRestart
[16:21:03.683]                       is.null <- base::is.null
[16:21:03.683]                       muffled <- FALSE
[16:21:03.683]                       if (inherits(cond, "message")) {
[16:21:03.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.683]                         if (muffled) 
[16:21:03.683]                           invokeRestart("muffleMessage")
[16:21:03.683]                       }
[16:21:03.683]                       else if (inherits(cond, "warning")) {
[16:21:03.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.683]                         if (muffled) 
[16:21:03.683]                           invokeRestart("muffleWarning")
[16:21:03.683]                       }
[16:21:03.683]                       else if (inherits(cond, "condition")) {
[16:21:03.683]                         if (!is.null(pattern)) {
[16:21:03.683]                           computeRestarts <- base::computeRestarts
[16:21:03.683]                           grepl <- base::grepl
[16:21:03.683]                           restarts <- computeRestarts(cond)
[16:21:03.683]                           for (restart in restarts) {
[16:21:03.683]                             name <- restart$name
[16:21:03.683]                             if (is.null(name)) 
[16:21:03.683]                               next
[16:21:03.683]                             if (!grepl(pattern, name)) 
[16:21:03.683]                               next
[16:21:03.683]                             invokeRestart(restart)
[16:21:03.683]                             muffled <- TRUE
[16:21:03.683]                             break
[16:21:03.683]                           }
[16:21:03.683]                         }
[16:21:03.683]                       }
[16:21:03.683]                       invisible(muffled)
[16:21:03.683]                     }
[16:21:03.683]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.683]                   }
[16:21:03.683]                 }
[16:21:03.683]                 else {
[16:21:03.683]                   if (TRUE) {
[16:21:03.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.683]                     {
[16:21:03.683]                       inherits <- base::inherits
[16:21:03.683]                       invokeRestart <- base::invokeRestart
[16:21:03.683]                       is.null <- base::is.null
[16:21:03.683]                       muffled <- FALSE
[16:21:03.683]                       if (inherits(cond, "message")) {
[16:21:03.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.683]                         if (muffled) 
[16:21:03.683]                           invokeRestart("muffleMessage")
[16:21:03.683]                       }
[16:21:03.683]                       else if (inherits(cond, "warning")) {
[16:21:03.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.683]                         if (muffled) 
[16:21:03.683]                           invokeRestart("muffleWarning")
[16:21:03.683]                       }
[16:21:03.683]                       else if (inherits(cond, "condition")) {
[16:21:03.683]                         if (!is.null(pattern)) {
[16:21:03.683]                           computeRestarts <- base::computeRestarts
[16:21:03.683]                           grepl <- base::grepl
[16:21:03.683]                           restarts <- computeRestarts(cond)
[16:21:03.683]                           for (restart in restarts) {
[16:21:03.683]                             name <- restart$name
[16:21:03.683]                             if (is.null(name)) 
[16:21:03.683]                               next
[16:21:03.683]                             if (!grepl(pattern, name)) 
[16:21:03.683]                               next
[16:21:03.683]                             invokeRestart(restart)
[16:21:03.683]                             muffled <- TRUE
[16:21:03.683]                             break
[16:21:03.683]                           }
[16:21:03.683]                         }
[16:21:03.683]                       }
[16:21:03.683]                       invisible(muffled)
[16:21:03.683]                     }
[16:21:03.683]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.683]                   }
[16:21:03.683]                 }
[16:21:03.683]             }
[16:21:03.683]         }))
[16:21:03.683]     }, error = function(ex) {
[16:21:03.683]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.683]                 ...future.rng), started = ...future.startTime, 
[16:21:03.683]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.683]             version = "1.8"), class = "FutureResult")
[16:21:03.683]     }, finally = {
[16:21:03.683]         if (!identical(...future.workdir, getwd())) 
[16:21:03.683]             setwd(...future.workdir)
[16:21:03.683]         {
[16:21:03.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.683]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.683]             }
[16:21:03.683]             base::options(...future.oldOptions)
[16:21:03.683]             if (.Platform$OS.type == "windows") {
[16:21:03.683]                 old_names <- names(...future.oldEnvVars)
[16:21:03.683]                 envs <- base::Sys.getenv()
[16:21:03.683]                 names <- names(envs)
[16:21:03.683]                 common <- intersect(names, old_names)
[16:21:03.683]                 added <- setdiff(names, old_names)
[16:21:03.683]                 removed <- setdiff(old_names, names)
[16:21:03.683]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.683]                   envs[common]]
[16:21:03.683]                 NAMES <- toupper(changed)
[16:21:03.683]                 args <- list()
[16:21:03.683]                 for (kk in seq_along(NAMES)) {
[16:21:03.683]                   name <- changed[[kk]]
[16:21:03.683]                   NAME <- NAMES[[kk]]
[16:21:03.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.683]                     next
[16:21:03.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.683]                 }
[16:21:03.683]                 NAMES <- toupper(added)
[16:21:03.683]                 for (kk in seq_along(NAMES)) {
[16:21:03.683]                   name <- added[[kk]]
[16:21:03.683]                   NAME <- NAMES[[kk]]
[16:21:03.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.683]                     next
[16:21:03.683]                   args[[name]] <- ""
[16:21:03.683]                 }
[16:21:03.683]                 NAMES <- toupper(removed)
[16:21:03.683]                 for (kk in seq_along(NAMES)) {
[16:21:03.683]                   name <- removed[[kk]]
[16:21:03.683]                   NAME <- NAMES[[kk]]
[16:21:03.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.683]                     next
[16:21:03.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.683]                 }
[16:21:03.683]                 if (length(args) > 0) 
[16:21:03.683]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.683]             }
[16:21:03.683]             else {
[16:21:03.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.683]             }
[16:21:03.683]             {
[16:21:03.683]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.683]                   0L) {
[16:21:03.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.683]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.683]                   base::options(opts)
[16:21:03.683]                 }
[16:21:03.683]                 {
[16:21:03.683]                   {
[16:21:03.683]                     NULL
[16:21:03.683]                     RNGkind("Mersenne-Twister")
[16:21:03.683]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.683]                       inherits = FALSE)
[16:21:03.683]                   }
[16:21:03.683]                   options(future.plan = NULL)
[16:21:03.683]                   if (is.na(NA_character_)) 
[16:21:03.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.683]                     .init = FALSE)
[16:21:03.683]                 }
[16:21:03.683]             }
[16:21:03.683]         }
[16:21:03.683]     })
[16:21:03.683]     if (TRUE) {
[16:21:03.683]         base::sink(type = "output", split = FALSE)
[16:21:03.683]         if (TRUE) {
[16:21:03.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.683]         }
[16:21:03.683]         else {
[16:21:03.683]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.683]         }
[16:21:03.683]         base::close(...future.stdout)
[16:21:03.683]         ...future.stdout <- NULL
[16:21:03.683]     }
[16:21:03.683]     ...future.result$conditions <- ...future.conditions
[16:21:03.683]     ...future.result$finished <- base::Sys.time()
[16:21:03.683]     ...future.result
[16:21:03.683] }
[16:21:03.685] assign_globals() ...
[16:21:03.685] List of 1
[16:21:03.685]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x562228625118> 
[16:21:03.685]  - attr(*, "where")=List of 1
[16:21:03.685]   ..$ a:<environment: R_EmptyEnv> 
[16:21:03.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.685]  - attr(*, "resolved")= logi TRUE
[16:21:03.685]  - attr(*, "total_size")= num 1621968
[16:21:03.685]  - attr(*, "already-done")= logi TRUE
[16:21:03.688] - copied ‘a’ to environment
[16:21:03.688] assign_globals() ... done
[16:21:03.688] plan(): Setting new future strategy stack:
[16:21:03.688] List of future strategies:
[16:21:03.688] 1. sequential:
[16:21:03.688]    - args: function (..., envir = parent.frame())
[16:21:03.688]    - tweaked: FALSE
[16:21:03.688]    - call: NULL
[16:21:03.689] plan(): nbrOfWorkers() = 1
[16:21:03.689] plan(): Setting new future strategy stack:
[16:21:03.689] List of future strategies:
[16:21:03.689] 1. sequential:
[16:21:03.689]    - args: function (..., envir = parent.frame())
[16:21:03.689]    - tweaked: FALSE
[16:21:03.689]    - call: plan(strategy)
[16:21:03.690] plan(): nbrOfWorkers() = 1
[16:21:03.690] SequentialFuture started (and completed)
[16:21:03.690] - Launch lazy future ... done
[16:21:03.690] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.691] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.691] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.692] - globals found: [2] ‘{’, ‘pkg’
[16:21:03.692] Searching for globals ... DONE
[16:21:03.692] Resolving globals: TRUE
[16:21:03.692] Resolving any globals that are futures ...
[16:21:03.692] - globals: [2] ‘{’, ‘pkg’
[16:21:03.692] Resolving any globals that are futures ... DONE
[16:21:03.692] Resolving futures part of globals (recursively) ...
[16:21:03.693] resolve() on list ...
[16:21:03.693]  recursive: 99
[16:21:03.693]  length: 1
[16:21:03.693]  elements: ‘pkg’
[16:21:03.693]  length: 0 (resolved future 1)
[16:21:03.693] resolve() on list ... DONE
[16:21:03.693] - globals: [1] ‘pkg’
[16:21:03.693] Resolving futures part of globals (recursively) ... DONE
[16:21:03.693] The total size of the 1 globals is 112 bytes (112 bytes)
[16:21:03.694] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:21:03.694] - globals: [1] ‘pkg’
[16:21:03.694] 
[16:21:03.694] getGlobalsAndPackages() ... DONE
[16:21:03.694] Packages needed by the future expression (n = 0): <none>
[16:21:03.694] Packages needed by future strategies (n = 0): <none>
[16:21:03.695] {
[16:21:03.695]     {
[16:21:03.695]         {
[16:21:03.695]             ...future.startTime <- base::Sys.time()
[16:21:03.695]             {
[16:21:03.695]                 {
[16:21:03.695]                   {
[16:21:03.695]                     base::local({
[16:21:03.695]                       has_future <- base::requireNamespace("future", 
[16:21:03.695]                         quietly = TRUE)
[16:21:03.695]                       if (has_future) {
[16:21:03.695]                         ns <- base::getNamespace("future")
[16:21:03.695]                         version <- ns[[".package"]][["version"]]
[16:21:03.695]                         if (is.null(version)) 
[16:21:03.695]                           version <- utils::packageVersion("future")
[16:21:03.695]                       }
[16:21:03.695]                       else {
[16:21:03.695]                         version <- NULL
[16:21:03.695]                       }
[16:21:03.695]                       if (!has_future || version < "1.8.0") {
[16:21:03.695]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.695]                           "", base::R.version$version.string), 
[16:21:03.695]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.695]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.695]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.695]                             "release", "version")], collapse = " "), 
[16:21:03.695]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.695]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.695]                           info)
[16:21:03.695]                         info <- base::paste(info, collapse = "; ")
[16:21:03.695]                         if (!has_future) {
[16:21:03.695]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.695]                             info)
[16:21:03.695]                         }
[16:21:03.695]                         else {
[16:21:03.695]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.695]                             info, version)
[16:21:03.695]                         }
[16:21:03.695]                         base::stop(msg)
[16:21:03.695]                       }
[16:21:03.695]                     })
[16:21:03.695]                   }
[16:21:03.695]                   ...future.strategy.old <- future::plan("list")
[16:21:03.695]                   options(future.plan = NULL)
[16:21:03.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.695]                 }
[16:21:03.695]                 ...future.workdir <- getwd()
[16:21:03.695]             }
[16:21:03.695]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.695]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.695]         }
[16:21:03.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.695]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.695]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.695]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.695]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.695]             base::names(...future.oldOptions))
[16:21:03.695]     }
[16:21:03.695]     if (FALSE) {
[16:21:03.695]     }
[16:21:03.695]     else {
[16:21:03.695]         if (TRUE) {
[16:21:03.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.695]                 open = "w")
[16:21:03.695]         }
[16:21:03.695]         else {
[16:21:03.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.695]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.695]         }
[16:21:03.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.695]             base::sink(type = "output", split = FALSE)
[16:21:03.695]             base::close(...future.stdout)
[16:21:03.695]         }, add = TRUE)
[16:21:03.695]     }
[16:21:03.695]     ...future.frame <- base::sys.nframe()
[16:21:03.695]     ...future.conditions <- base::list()
[16:21:03.695]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.695]     if (FALSE) {
[16:21:03.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.695]     }
[16:21:03.695]     ...future.result <- base::tryCatch({
[16:21:03.695]         base::withCallingHandlers({
[16:21:03.695]             ...future.value <- base::withVisible(base::local({
[16:21:03.695]                 pkg
[16:21:03.695]             }))
[16:21:03.695]             future::FutureResult(value = ...future.value$value, 
[16:21:03.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.695]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.695]                     ...future.globalenv.names))
[16:21:03.695]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.695]         }, condition = base::local({
[16:21:03.695]             c <- base::c
[16:21:03.695]             inherits <- base::inherits
[16:21:03.695]             invokeRestart <- base::invokeRestart
[16:21:03.695]             length <- base::length
[16:21:03.695]             list <- base::list
[16:21:03.695]             seq.int <- base::seq.int
[16:21:03.695]             signalCondition <- base::signalCondition
[16:21:03.695]             sys.calls <- base::sys.calls
[16:21:03.695]             `[[` <- base::`[[`
[16:21:03.695]             `+` <- base::`+`
[16:21:03.695]             `<<-` <- base::`<<-`
[16:21:03.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.695]                   3L)]
[16:21:03.695]             }
[16:21:03.695]             function(cond) {
[16:21:03.695]                 is_error <- inherits(cond, "error")
[16:21:03.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.695]                   NULL)
[16:21:03.695]                 if (is_error) {
[16:21:03.695]                   sessionInformation <- function() {
[16:21:03.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.695]                       search = base::search(), system = base::Sys.info())
[16:21:03.695]                   }
[16:21:03.695]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.695]                     cond$call), session = sessionInformation(), 
[16:21:03.695]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.695]                   signalCondition(cond)
[16:21:03.695]                 }
[16:21:03.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.695]                 "immediateCondition"))) {
[16:21:03.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.695]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.695]                   if (TRUE && !signal) {
[16:21:03.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.695]                     {
[16:21:03.695]                       inherits <- base::inherits
[16:21:03.695]                       invokeRestart <- base::invokeRestart
[16:21:03.695]                       is.null <- base::is.null
[16:21:03.695]                       muffled <- FALSE
[16:21:03.695]                       if (inherits(cond, "message")) {
[16:21:03.695]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.695]                         if (muffled) 
[16:21:03.695]                           invokeRestart("muffleMessage")
[16:21:03.695]                       }
[16:21:03.695]                       else if (inherits(cond, "warning")) {
[16:21:03.695]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.695]                         if (muffled) 
[16:21:03.695]                           invokeRestart("muffleWarning")
[16:21:03.695]                       }
[16:21:03.695]                       else if (inherits(cond, "condition")) {
[16:21:03.695]                         if (!is.null(pattern)) {
[16:21:03.695]                           computeRestarts <- base::computeRestarts
[16:21:03.695]                           grepl <- base::grepl
[16:21:03.695]                           restarts <- computeRestarts(cond)
[16:21:03.695]                           for (restart in restarts) {
[16:21:03.695]                             name <- restart$name
[16:21:03.695]                             if (is.null(name)) 
[16:21:03.695]                               next
[16:21:03.695]                             if (!grepl(pattern, name)) 
[16:21:03.695]                               next
[16:21:03.695]                             invokeRestart(restart)
[16:21:03.695]                             muffled <- TRUE
[16:21:03.695]                             break
[16:21:03.695]                           }
[16:21:03.695]                         }
[16:21:03.695]                       }
[16:21:03.695]                       invisible(muffled)
[16:21:03.695]                     }
[16:21:03.695]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.695]                   }
[16:21:03.695]                 }
[16:21:03.695]                 else {
[16:21:03.695]                   if (TRUE) {
[16:21:03.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.695]                     {
[16:21:03.695]                       inherits <- base::inherits
[16:21:03.695]                       invokeRestart <- base::invokeRestart
[16:21:03.695]                       is.null <- base::is.null
[16:21:03.695]                       muffled <- FALSE
[16:21:03.695]                       if (inherits(cond, "message")) {
[16:21:03.695]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.695]                         if (muffled) 
[16:21:03.695]                           invokeRestart("muffleMessage")
[16:21:03.695]                       }
[16:21:03.695]                       else if (inherits(cond, "warning")) {
[16:21:03.695]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.695]                         if (muffled) 
[16:21:03.695]                           invokeRestart("muffleWarning")
[16:21:03.695]                       }
[16:21:03.695]                       else if (inherits(cond, "condition")) {
[16:21:03.695]                         if (!is.null(pattern)) {
[16:21:03.695]                           computeRestarts <- base::computeRestarts
[16:21:03.695]                           grepl <- base::grepl
[16:21:03.695]                           restarts <- computeRestarts(cond)
[16:21:03.695]                           for (restart in restarts) {
[16:21:03.695]                             name <- restart$name
[16:21:03.695]                             if (is.null(name)) 
[16:21:03.695]                               next
[16:21:03.695]                             if (!grepl(pattern, name)) 
[16:21:03.695]                               next
[16:21:03.695]                             invokeRestart(restart)
[16:21:03.695]                             muffled <- TRUE
[16:21:03.695]                             break
[16:21:03.695]                           }
[16:21:03.695]                         }
[16:21:03.695]                       }
[16:21:03.695]                       invisible(muffled)
[16:21:03.695]                     }
[16:21:03.695]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.695]                   }
[16:21:03.695]                 }
[16:21:03.695]             }
[16:21:03.695]         }))
[16:21:03.695]     }, error = function(ex) {
[16:21:03.695]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.695]                 ...future.rng), started = ...future.startTime, 
[16:21:03.695]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.695]             version = "1.8"), class = "FutureResult")
[16:21:03.695]     }, finally = {
[16:21:03.695]         if (!identical(...future.workdir, getwd())) 
[16:21:03.695]             setwd(...future.workdir)
[16:21:03.695]         {
[16:21:03.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.695]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.695]             }
[16:21:03.695]             base::options(...future.oldOptions)
[16:21:03.695]             if (.Platform$OS.type == "windows") {
[16:21:03.695]                 old_names <- names(...future.oldEnvVars)
[16:21:03.695]                 envs <- base::Sys.getenv()
[16:21:03.695]                 names <- names(envs)
[16:21:03.695]                 common <- intersect(names, old_names)
[16:21:03.695]                 added <- setdiff(names, old_names)
[16:21:03.695]                 removed <- setdiff(old_names, names)
[16:21:03.695]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.695]                   envs[common]]
[16:21:03.695]                 NAMES <- toupper(changed)
[16:21:03.695]                 args <- list()
[16:21:03.695]                 for (kk in seq_along(NAMES)) {
[16:21:03.695]                   name <- changed[[kk]]
[16:21:03.695]                   NAME <- NAMES[[kk]]
[16:21:03.695]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.695]                     next
[16:21:03.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.695]                 }
[16:21:03.695]                 NAMES <- toupper(added)
[16:21:03.695]                 for (kk in seq_along(NAMES)) {
[16:21:03.695]                   name <- added[[kk]]
[16:21:03.695]                   NAME <- NAMES[[kk]]
[16:21:03.695]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.695]                     next
[16:21:03.695]                   args[[name]] <- ""
[16:21:03.695]                 }
[16:21:03.695]                 NAMES <- toupper(removed)
[16:21:03.695]                 for (kk in seq_along(NAMES)) {
[16:21:03.695]                   name <- removed[[kk]]
[16:21:03.695]                   NAME <- NAMES[[kk]]
[16:21:03.695]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.695]                     next
[16:21:03.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.695]                 }
[16:21:03.695]                 if (length(args) > 0) 
[16:21:03.695]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.695]             }
[16:21:03.695]             else {
[16:21:03.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.695]             }
[16:21:03.695]             {
[16:21:03.695]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.695]                   0L) {
[16:21:03.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.695]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.695]                   base::options(opts)
[16:21:03.695]                 }
[16:21:03.695]                 {
[16:21:03.695]                   {
[16:21:03.695]                     NULL
[16:21:03.695]                     RNGkind("Mersenne-Twister")
[16:21:03.695]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.695]                       inherits = FALSE)
[16:21:03.695]                   }
[16:21:03.695]                   options(future.plan = NULL)
[16:21:03.695]                   if (is.na(NA_character_)) 
[16:21:03.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.695]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.695]                     .init = FALSE)
[16:21:03.695]                 }
[16:21:03.695]             }
[16:21:03.695]         }
[16:21:03.695]     })
[16:21:03.695]     if (TRUE) {
[16:21:03.695]         base::sink(type = "output", split = FALSE)
[16:21:03.695]         if (TRUE) {
[16:21:03.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.695]         }
[16:21:03.695]         else {
[16:21:03.695]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.695]         }
[16:21:03.695]         base::close(...future.stdout)
[16:21:03.695]         ...future.stdout <- NULL
[16:21:03.695]     }
[16:21:03.695]     ...future.result$conditions <- ...future.conditions
[16:21:03.695]     ...future.result$finished <- base::Sys.time()
[16:21:03.695]     ...future.result
[16:21:03.695] }
[16:21:03.696] assign_globals() ...
[16:21:03.697] List of 1
[16:21:03.697]  $ pkg: chr "foo"
[16:21:03.697]  - attr(*, "where")=List of 1
[16:21:03.697]   ..$ pkg:<environment: R_EmptyEnv> 
[16:21:03.697]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.697]  - attr(*, "resolved")= logi TRUE
[16:21:03.697]  - attr(*, "total_size")= num 112
[16:21:03.699] - copied ‘pkg’ to environment
[16:21:03.699] assign_globals() ... done
[16:21:03.699] plan(): Setting new future strategy stack:
[16:21:03.699] List of future strategies:
[16:21:03.699] 1. sequential:
[16:21:03.699]    - args: function (..., envir = parent.frame())
[16:21:03.699]    - tweaked: FALSE
[16:21:03.699]    - call: NULL
[16:21:03.699] plan(): nbrOfWorkers() = 1
[16:21:03.700] plan(): Setting new future strategy stack:
[16:21:03.700] List of future strategies:
[16:21:03.700] 1. sequential:
[16:21:03.700]    - args: function (..., envir = parent.frame())
[16:21:03.700]    - tweaked: FALSE
[16:21:03.700]    - call: plan(strategy)
[16:21:03.701] plan(): nbrOfWorkers() = 1
[16:21:03.701] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.703] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.703] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.705] - globals found: [3] ‘{’, ‘<-’, ‘+’
[16:21:03.705] Searching for globals ... DONE
[16:21:03.705] Resolving globals: TRUE
[16:21:03.706] Resolving any globals that are futures ...
[16:21:03.706] - globals: [3] ‘{’, ‘<-’, ‘+’
[16:21:03.706] Resolving any globals that are futures ... DONE
[16:21:03.706] 
[16:21:03.706] 
[16:21:03.706] getGlobalsAndPackages() ... DONE
[16:21:03.707] run() for ‘Future’ ...
[16:21:03.707] - state: ‘created’
[16:21:03.707] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.707] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.707] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.707]   - Field: ‘label’
[16:21:03.707]   - Field: ‘local’
[16:21:03.707]   - Field: ‘owner’
[16:21:03.708]   - Field: ‘envir’
[16:21:03.708]   - Field: ‘packages’
[16:21:03.708]   - Field: ‘gc’
[16:21:03.708]   - Field: ‘conditions’
[16:21:03.708]   - Field: ‘expr’
[16:21:03.708]   - Field: ‘uuid’
[16:21:03.708]   - Field: ‘seed’
[16:21:03.708]   - Field: ‘version’
[16:21:03.708]   - Field: ‘result’
[16:21:03.708]   - Field: ‘asynchronous’
[16:21:03.709]   - Field: ‘calls’
[16:21:03.709]   - Field: ‘globals’
[16:21:03.709]   - Field: ‘stdout’
[16:21:03.709]   - Field: ‘earlySignal’
[16:21:03.709]   - Field: ‘lazy’
[16:21:03.709]   - Field: ‘state’
[16:21:03.709] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.709] - Launch lazy future ...
[16:21:03.709] Packages needed by the future expression (n = 0): <none>
[16:21:03.709] Packages needed by future strategies (n = 0): <none>
[16:21:03.710] {
[16:21:03.710]     {
[16:21:03.710]         {
[16:21:03.710]             ...future.startTime <- base::Sys.time()
[16:21:03.710]             {
[16:21:03.710]                 {
[16:21:03.710]                   {
[16:21:03.710]                     base::local({
[16:21:03.710]                       has_future <- base::requireNamespace("future", 
[16:21:03.710]                         quietly = TRUE)
[16:21:03.710]                       if (has_future) {
[16:21:03.710]                         ns <- base::getNamespace("future")
[16:21:03.710]                         version <- ns[[".package"]][["version"]]
[16:21:03.710]                         if (is.null(version)) 
[16:21:03.710]                           version <- utils::packageVersion("future")
[16:21:03.710]                       }
[16:21:03.710]                       else {
[16:21:03.710]                         version <- NULL
[16:21:03.710]                       }
[16:21:03.710]                       if (!has_future || version < "1.8.0") {
[16:21:03.710]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.710]                           "", base::R.version$version.string), 
[16:21:03.710]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.710]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.710]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.710]                             "release", "version")], collapse = " "), 
[16:21:03.710]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.710]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.710]                           info)
[16:21:03.710]                         info <- base::paste(info, collapse = "; ")
[16:21:03.710]                         if (!has_future) {
[16:21:03.710]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.710]                             info)
[16:21:03.710]                         }
[16:21:03.710]                         else {
[16:21:03.710]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.710]                             info, version)
[16:21:03.710]                         }
[16:21:03.710]                         base::stop(msg)
[16:21:03.710]                       }
[16:21:03.710]                     })
[16:21:03.710]                   }
[16:21:03.710]                   ...future.strategy.old <- future::plan("list")
[16:21:03.710]                   options(future.plan = NULL)
[16:21:03.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.710]                 }
[16:21:03.710]                 ...future.workdir <- getwd()
[16:21:03.710]             }
[16:21:03.710]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.710]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.710]         }
[16:21:03.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.710]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.710]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.710]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.710]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.710]             base::names(...future.oldOptions))
[16:21:03.710]     }
[16:21:03.710]     if (FALSE) {
[16:21:03.710]     }
[16:21:03.710]     else {
[16:21:03.710]         if (TRUE) {
[16:21:03.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.710]                 open = "w")
[16:21:03.710]         }
[16:21:03.710]         else {
[16:21:03.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.710]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.710]         }
[16:21:03.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.710]             base::sink(type = "output", split = FALSE)
[16:21:03.710]             base::close(...future.stdout)
[16:21:03.710]         }, add = TRUE)
[16:21:03.710]     }
[16:21:03.710]     ...future.frame <- base::sys.nframe()
[16:21:03.710]     ...future.conditions <- base::list()
[16:21:03.710]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.710]     if (FALSE) {
[16:21:03.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.710]     }
[16:21:03.710]     ...future.result <- base::tryCatch({
[16:21:03.710]         base::withCallingHandlers({
[16:21:03.710]             ...future.value <- base::withVisible(base::local({
[16:21:03.710]                 x <- 0
[16:21:03.710]                 x <- x + 1
[16:21:03.710]                 x
[16:21:03.710]             }))
[16:21:03.710]             future::FutureResult(value = ...future.value$value, 
[16:21:03.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.710]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.710]                     ...future.globalenv.names))
[16:21:03.710]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.710]         }, condition = base::local({
[16:21:03.710]             c <- base::c
[16:21:03.710]             inherits <- base::inherits
[16:21:03.710]             invokeRestart <- base::invokeRestart
[16:21:03.710]             length <- base::length
[16:21:03.710]             list <- base::list
[16:21:03.710]             seq.int <- base::seq.int
[16:21:03.710]             signalCondition <- base::signalCondition
[16:21:03.710]             sys.calls <- base::sys.calls
[16:21:03.710]             `[[` <- base::`[[`
[16:21:03.710]             `+` <- base::`+`
[16:21:03.710]             `<<-` <- base::`<<-`
[16:21:03.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.710]                   3L)]
[16:21:03.710]             }
[16:21:03.710]             function(cond) {
[16:21:03.710]                 is_error <- inherits(cond, "error")
[16:21:03.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.710]                   NULL)
[16:21:03.710]                 if (is_error) {
[16:21:03.710]                   sessionInformation <- function() {
[16:21:03.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.710]                       search = base::search(), system = base::Sys.info())
[16:21:03.710]                   }
[16:21:03.710]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.710]                     cond$call), session = sessionInformation(), 
[16:21:03.710]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.710]                   signalCondition(cond)
[16:21:03.710]                 }
[16:21:03.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.710]                 "immediateCondition"))) {
[16:21:03.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.710]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.710]                   if (TRUE && !signal) {
[16:21:03.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.710]                     {
[16:21:03.710]                       inherits <- base::inherits
[16:21:03.710]                       invokeRestart <- base::invokeRestart
[16:21:03.710]                       is.null <- base::is.null
[16:21:03.710]                       muffled <- FALSE
[16:21:03.710]                       if (inherits(cond, "message")) {
[16:21:03.710]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.710]                         if (muffled) 
[16:21:03.710]                           invokeRestart("muffleMessage")
[16:21:03.710]                       }
[16:21:03.710]                       else if (inherits(cond, "warning")) {
[16:21:03.710]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.710]                         if (muffled) 
[16:21:03.710]                           invokeRestart("muffleWarning")
[16:21:03.710]                       }
[16:21:03.710]                       else if (inherits(cond, "condition")) {
[16:21:03.710]                         if (!is.null(pattern)) {
[16:21:03.710]                           computeRestarts <- base::computeRestarts
[16:21:03.710]                           grepl <- base::grepl
[16:21:03.710]                           restarts <- computeRestarts(cond)
[16:21:03.710]                           for (restart in restarts) {
[16:21:03.710]                             name <- restart$name
[16:21:03.710]                             if (is.null(name)) 
[16:21:03.710]                               next
[16:21:03.710]                             if (!grepl(pattern, name)) 
[16:21:03.710]                               next
[16:21:03.710]                             invokeRestart(restart)
[16:21:03.710]                             muffled <- TRUE
[16:21:03.710]                             break
[16:21:03.710]                           }
[16:21:03.710]                         }
[16:21:03.710]                       }
[16:21:03.710]                       invisible(muffled)
[16:21:03.710]                     }
[16:21:03.710]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.710]                   }
[16:21:03.710]                 }
[16:21:03.710]                 else {
[16:21:03.710]                   if (TRUE) {
[16:21:03.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.710]                     {
[16:21:03.710]                       inherits <- base::inherits
[16:21:03.710]                       invokeRestart <- base::invokeRestart
[16:21:03.710]                       is.null <- base::is.null
[16:21:03.710]                       muffled <- FALSE
[16:21:03.710]                       if (inherits(cond, "message")) {
[16:21:03.710]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.710]                         if (muffled) 
[16:21:03.710]                           invokeRestart("muffleMessage")
[16:21:03.710]                       }
[16:21:03.710]                       else if (inherits(cond, "warning")) {
[16:21:03.710]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.710]                         if (muffled) 
[16:21:03.710]                           invokeRestart("muffleWarning")
[16:21:03.710]                       }
[16:21:03.710]                       else if (inherits(cond, "condition")) {
[16:21:03.710]                         if (!is.null(pattern)) {
[16:21:03.710]                           computeRestarts <- base::computeRestarts
[16:21:03.710]                           grepl <- base::grepl
[16:21:03.710]                           restarts <- computeRestarts(cond)
[16:21:03.710]                           for (restart in restarts) {
[16:21:03.710]                             name <- restart$name
[16:21:03.710]                             if (is.null(name)) 
[16:21:03.710]                               next
[16:21:03.710]                             if (!grepl(pattern, name)) 
[16:21:03.710]                               next
[16:21:03.710]                             invokeRestart(restart)
[16:21:03.710]                             muffled <- TRUE
[16:21:03.710]                             break
[16:21:03.710]                           }
[16:21:03.710]                         }
[16:21:03.710]                       }
[16:21:03.710]                       invisible(muffled)
[16:21:03.710]                     }
[16:21:03.710]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.710]                   }
[16:21:03.710]                 }
[16:21:03.710]             }
[16:21:03.710]         }))
[16:21:03.710]     }, error = function(ex) {
[16:21:03.710]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.710]                 ...future.rng), started = ...future.startTime, 
[16:21:03.710]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.710]             version = "1.8"), class = "FutureResult")
[16:21:03.710]     }, finally = {
[16:21:03.710]         if (!identical(...future.workdir, getwd())) 
[16:21:03.710]             setwd(...future.workdir)
[16:21:03.710]         {
[16:21:03.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.710]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.710]             }
[16:21:03.710]             base::options(...future.oldOptions)
[16:21:03.710]             if (.Platform$OS.type == "windows") {
[16:21:03.710]                 old_names <- names(...future.oldEnvVars)
[16:21:03.710]                 envs <- base::Sys.getenv()
[16:21:03.710]                 names <- names(envs)
[16:21:03.710]                 common <- intersect(names, old_names)
[16:21:03.710]                 added <- setdiff(names, old_names)
[16:21:03.710]                 removed <- setdiff(old_names, names)
[16:21:03.710]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.710]                   envs[common]]
[16:21:03.710]                 NAMES <- toupper(changed)
[16:21:03.710]                 args <- list()
[16:21:03.710]                 for (kk in seq_along(NAMES)) {
[16:21:03.710]                   name <- changed[[kk]]
[16:21:03.710]                   NAME <- NAMES[[kk]]
[16:21:03.710]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.710]                     next
[16:21:03.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.710]                 }
[16:21:03.710]                 NAMES <- toupper(added)
[16:21:03.710]                 for (kk in seq_along(NAMES)) {
[16:21:03.710]                   name <- added[[kk]]
[16:21:03.710]                   NAME <- NAMES[[kk]]
[16:21:03.710]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.710]                     next
[16:21:03.710]                   args[[name]] <- ""
[16:21:03.710]                 }
[16:21:03.710]                 NAMES <- toupper(removed)
[16:21:03.710]                 for (kk in seq_along(NAMES)) {
[16:21:03.710]                   name <- removed[[kk]]
[16:21:03.710]                   NAME <- NAMES[[kk]]
[16:21:03.710]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.710]                     next
[16:21:03.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.710]                 }
[16:21:03.710]                 if (length(args) > 0) 
[16:21:03.710]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.710]             }
[16:21:03.710]             else {
[16:21:03.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.710]             }
[16:21:03.710]             {
[16:21:03.710]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.710]                   0L) {
[16:21:03.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.710]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.710]                   base::options(opts)
[16:21:03.710]                 }
[16:21:03.710]                 {
[16:21:03.710]                   {
[16:21:03.710]                     NULL
[16:21:03.710]                     RNGkind("Mersenne-Twister")
[16:21:03.710]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.710]                       inherits = FALSE)
[16:21:03.710]                   }
[16:21:03.710]                   options(future.plan = NULL)
[16:21:03.710]                   if (is.na(NA_character_)) 
[16:21:03.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.710]                     .init = FALSE)
[16:21:03.710]                 }
[16:21:03.710]             }
[16:21:03.710]         }
[16:21:03.710]     })
[16:21:03.710]     if (TRUE) {
[16:21:03.710]         base::sink(type = "output", split = FALSE)
[16:21:03.710]         if (TRUE) {
[16:21:03.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.710]         }
[16:21:03.710]         else {
[16:21:03.710]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.710]         }
[16:21:03.710]         base::close(...future.stdout)
[16:21:03.710]         ...future.stdout <- NULL
[16:21:03.710]     }
[16:21:03.710]     ...future.result$conditions <- ...future.conditions
[16:21:03.710]     ...future.result$finished <- base::Sys.time()
[16:21:03.710]     ...future.result
[16:21:03.710] }
[16:21:03.712] plan(): Setting new future strategy stack:
[16:21:03.712] List of future strategies:
[16:21:03.712] 1. sequential:
[16:21:03.712]    - args: function (..., envir = parent.frame())
[16:21:03.712]    - tweaked: FALSE
[16:21:03.712]    - call: NULL
[16:21:03.712] plan(): nbrOfWorkers() = 1
[16:21:03.713] plan(): Setting new future strategy stack:
[16:21:03.713] List of future strategies:
[16:21:03.713] 1. sequential:
[16:21:03.713]    - args: function (..., envir = parent.frame())
[16:21:03.713]    - tweaked: FALSE
[16:21:03.713]    - call: plan(strategy)
[16:21:03.713] plan(): nbrOfWorkers() = 1
[16:21:03.713] SequentialFuture started (and completed)
[16:21:03.714] - Launch lazy future ... done
[16:21:03.714] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.714] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.714] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.716] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:21:03.716] Searching for globals ... DONE
[16:21:03.716] Resolving globals: TRUE
[16:21:03.716] Resolving any globals that are futures ...
[16:21:03.716] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:21:03.716] Resolving any globals that are futures ... DONE
[16:21:03.716] Resolving futures part of globals (recursively) ...
[16:21:03.717] resolve() on list ...
[16:21:03.717]  recursive: 99
[16:21:03.717]  length: 1
[16:21:03.717]  elements: ‘x’
[16:21:03.717]  length: 0 (resolved future 1)
[16:21:03.717] resolve() on list ... DONE
[16:21:03.717] - globals: [1] ‘x’
[16:21:03.717] Resolving futures part of globals (recursively) ... DONE
[16:21:03.717] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.718] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[16:21:03.718] - globals: [1] ‘x’
[16:21:03.718] 
[16:21:03.718] getGlobalsAndPackages() ... DONE
[16:21:03.718] run() for ‘Future’ ...
[16:21:03.718] - state: ‘created’
[16:21:03.719] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.719] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.719]   - Field: ‘label’
[16:21:03.719]   - Field: ‘local’
[16:21:03.719]   - Field: ‘owner’
[16:21:03.719]   - Field: ‘envir’
[16:21:03.720]   - Field: ‘packages’
[16:21:03.720]   - Field: ‘gc’
[16:21:03.720]   - Field: ‘conditions’
[16:21:03.720]   - Field: ‘expr’
[16:21:03.720]   - Field: ‘uuid’
[16:21:03.720]   - Field: ‘seed’
[16:21:03.720]   - Field: ‘version’
[16:21:03.720]   - Field: ‘result’
[16:21:03.720]   - Field: ‘asynchronous’
[16:21:03.720]   - Field: ‘calls’
[16:21:03.721]   - Field: ‘globals’
[16:21:03.721]   - Field: ‘stdout’
[16:21:03.721]   - Field: ‘earlySignal’
[16:21:03.721]   - Field: ‘lazy’
[16:21:03.721]   - Field: ‘state’
[16:21:03.721] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.721] - Launch lazy future ...
[16:21:03.721] Packages needed by the future expression (n = 0): <none>
[16:21:03.721] Packages needed by future strategies (n = 0): <none>
[16:21:03.722] {
[16:21:03.722]     {
[16:21:03.722]         {
[16:21:03.722]             ...future.startTime <- base::Sys.time()
[16:21:03.722]             {
[16:21:03.722]                 {
[16:21:03.722]                   {
[16:21:03.722]                     base::local({
[16:21:03.722]                       has_future <- base::requireNamespace("future", 
[16:21:03.722]                         quietly = TRUE)
[16:21:03.722]                       if (has_future) {
[16:21:03.722]                         ns <- base::getNamespace("future")
[16:21:03.722]                         version <- ns[[".package"]][["version"]]
[16:21:03.722]                         if (is.null(version)) 
[16:21:03.722]                           version <- utils::packageVersion("future")
[16:21:03.722]                       }
[16:21:03.722]                       else {
[16:21:03.722]                         version <- NULL
[16:21:03.722]                       }
[16:21:03.722]                       if (!has_future || version < "1.8.0") {
[16:21:03.722]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.722]                           "", base::R.version$version.string), 
[16:21:03.722]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.722]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.722]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.722]                             "release", "version")], collapse = " "), 
[16:21:03.722]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.722]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.722]                           info)
[16:21:03.722]                         info <- base::paste(info, collapse = "; ")
[16:21:03.722]                         if (!has_future) {
[16:21:03.722]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.722]                             info)
[16:21:03.722]                         }
[16:21:03.722]                         else {
[16:21:03.722]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.722]                             info, version)
[16:21:03.722]                         }
[16:21:03.722]                         base::stop(msg)
[16:21:03.722]                       }
[16:21:03.722]                     })
[16:21:03.722]                   }
[16:21:03.722]                   ...future.strategy.old <- future::plan("list")
[16:21:03.722]                   options(future.plan = NULL)
[16:21:03.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.722]                 }
[16:21:03.722]                 ...future.workdir <- getwd()
[16:21:03.722]             }
[16:21:03.722]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.722]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.722]         }
[16:21:03.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.722]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.722]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.722]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.722]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.722]             base::names(...future.oldOptions))
[16:21:03.722]     }
[16:21:03.722]     if (FALSE) {
[16:21:03.722]     }
[16:21:03.722]     else {
[16:21:03.722]         if (TRUE) {
[16:21:03.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.722]                 open = "w")
[16:21:03.722]         }
[16:21:03.722]         else {
[16:21:03.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.722]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.722]         }
[16:21:03.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.722]             base::sink(type = "output", split = FALSE)
[16:21:03.722]             base::close(...future.stdout)
[16:21:03.722]         }, add = TRUE)
[16:21:03.722]     }
[16:21:03.722]     ...future.frame <- base::sys.nframe()
[16:21:03.722]     ...future.conditions <- base::list()
[16:21:03.722]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.722]     if (FALSE) {
[16:21:03.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.722]     }
[16:21:03.722]     ...future.result <- base::tryCatch({
[16:21:03.722]         base::withCallingHandlers({
[16:21:03.722]             ...future.value <- base::withVisible(base::local({
[16:21:03.722]                 x <- x + 1
[16:21:03.722]                 x
[16:21:03.722]             }))
[16:21:03.722]             future::FutureResult(value = ...future.value$value, 
[16:21:03.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.722]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.722]                     ...future.globalenv.names))
[16:21:03.722]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.722]         }, condition = base::local({
[16:21:03.722]             c <- base::c
[16:21:03.722]             inherits <- base::inherits
[16:21:03.722]             invokeRestart <- base::invokeRestart
[16:21:03.722]             length <- base::length
[16:21:03.722]             list <- base::list
[16:21:03.722]             seq.int <- base::seq.int
[16:21:03.722]             signalCondition <- base::signalCondition
[16:21:03.722]             sys.calls <- base::sys.calls
[16:21:03.722]             `[[` <- base::`[[`
[16:21:03.722]             `+` <- base::`+`
[16:21:03.722]             `<<-` <- base::`<<-`
[16:21:03.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.722]                   3L)]
[16:21:03.722]             }
[16:21:03.722]             function(cond) {
[16:21:03.722]                 is_error <- inherits(cond, "error")
[16:21:03.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.722]                   NULL)
[16:21:03.722]                 if (is_error) {
[16:21:03.722]                   sessionInformation <- function() {
[16:21:03.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.722]                       search = base::search(), system = base::Sys.info())
[16:21:03.722]                   }
[16:21:03.722]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.722]                     cond$call), session = sessionInformation(), 
[16:21:03.722]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.722]                   signalCondition(cond)
[16:21:03.722]                 }
[16:21:03.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.722]                 "immediateCondition"))) {
[16:21:03.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.722]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.722]                   if (TRUE && !signal) {
[16:21:03.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.722]                     {
[16:21:03.722]                       inherits <- base::inherits
[16:21:03.722]                       invokeRestart <- base::invokeRestart
[16:21:03.722]                       is.null <- base::is.null
[16:21:03.722]                       muffled <- FALSE
[16:21:03.722]                       if (inherits(cond, "message")) {
[16:21:03.722]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.722]                         if (muffled) 
[16:21:03.722]                           invokeRestart("muffleMessage")
[16:21:03.722]                       }
[16:21:03.722]                       else if (inherits(cond, "warning")) {
[16:21:03.722]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.722]                         if (muffled) 
[16:21:03.722]                           invokeRestart("muffleWarning")
[16:21:03.722]                       }
[16:21:03.722]                       else if (inherits(cond, "condition")) {
[16:21:03.722]                         if (!is.null(pattern)) {
[16:21:03.722]                           computeRestarts <- base::computeRestarts
[16:21:03.722]                           grepl <- base::grepl
[16:21:03.722]                           restarts <- computeRestarts(cond)
[16:21:03.722]                           for (restart in restarts) {
[16:21:03.722]                             name <- restart$name
[16:21:03.722]                             if (is.null(name)) 
[16:21:03.722]                               next
[16:21:03.722]                             if (!grepl(pattern, name)) 
[16:21:03.722]                               next
[16:21:03.722]                             invokeRestart(restart)
[16:21:03.722]                             muffled <- TRUE
[16:21:03.722]                             break
[16:21:03.722]                           }
[16:21:03.722]                         }
[16:21:03.722]                       }
[16:21:03.722]                       invisible(muffled)
[16:21:03.722]                     }
[16:21:03.722]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.722]                   }
[16:21:03.722]                 }
[16:21:03.722]                 else {
[16:21:03.722]                   if (TRUE) {
[16:21:03.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.722]                     {
[16:21:03.722]                       inherits <- base::inherits
[16:21:03.722]                       invokeRestart <- base::invokeRestart
[16:21:03.722]                       is.null <- base::is.null
[16:21:03.722]                       muffled <- FALSE
[16:21:03.722]                       if (inherits(cond, "message")) {
[16:21:03.722]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.722]                         if (muffled) 
[16:21:03.722]                           invokeRestart("muffleMessage")
[16:21:03.722]                       }
[16:21:03.722]                       else if (inherits(cond, "warning")) {
[16:21:03.722]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.722]                         if (muffled) 
[16:21:03.722]                           invokeRestart("muffleWarning")
[16:21:03.722]                       }
[16:21:03.722]                       else if (inherits(cond, "condition")) {
[16:21:03.722]                         if (!is.null(pattern)) {
[16:21:03.722]                           computeRestarts <- base::computeRestarts
[16:21:03.722]                           grepl <- base::grepl
[16:21:03.722]                           restarts <- computeRestarts(cond)
[16:21:03.722]                           for (restart in restarts) {
[16:21:03.722]                             name <- restart$name
[16:21:03.722]                             if (is.null(name)) 
[16:21:03.722]                               next
[16:21:03.722]                             if (!grepl(pattern, name)) 
[16:21:03.722]                               next
[16:21:03.722]                             invokeRestart(restart)
[16:21:03.722]                             muffled <- TRUE
[16:21:03.722]                             break
[16:21:03.722]                           }
[16:21:03.722]                         }
[16:21:03.722]                       }
[16:21:03.722]                       invisible(muffled)
[16:21:03.722]                     }
[16:21:03.722]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.722]                   }
[16:21:03.722]                 }
[16:21:03.722]             }
[16:21:03.722]         }))
[16:21:03.722]     }, error = function(ex) {
[16:21:03.722]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.722]                 ...future.rng), started = ...future.startTime, 
[16:21:03.722]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.722]             version = "1.8"), class = "FutureResult")
[16:21:03.722]     }, finally = {
[16:21:03.722]         if (!identical(...future.workdir, getwd())) 
[16:21:03.722]             setwd(...future.workdir)
[16:21:03.722]         {
[16:21:03.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.722]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.722]             }
[16:21:03.722]             base::options(...future.oldOptions)
[16:21:03.722]             if (.Platform$OS.type == "windows") {
[16:21:03.722]                 old_names <- names(...future.oldEnvVars)
[16:21:03.722]                 envs <- base::Sys.getenv()
[16:21:03.722]                 names <- names(envs)
[16:21:03.722]                 common <- intersect(names, old_names)
[16:21:03.722]                 added <- setdiff(names, old_names)
[16:21:03.722]                 removed <- setdiff(old_names, names)
[16:21:03.722]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.722]                   envs[common]]
[16:21:03.722]                 NAMES <- toupper(changed)
[16:21:03.722]                 args <- list()
[16:21:03.722]                 for (kk in seq_along(NAMES)) {
[16:21:03.722]                   name <- changed[[kk]]
[16:21:03.722]                   NAME <- NAMES[[kk]]
[16:21:03.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.722]                     next
[16:21:03.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.722]                 }
[16:21:03.722]                 NAMES <- toupper(added)
[16:21:03.722]                 for (kk in seq_along(NAMES)) {
[16:21:03.722]                   name <- added[[kk]]
[16:21:03.722]                   NAME <- NAMES[[kk]]
[16:21:03.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.722]                     next
[16:21:03.722]                   args[[name]] <- ""
[16:21:03.722]                 }
[16:21:03.722]                 NAMES <- toupper(removed)
[16:21:03.722]                 for (kk in seq_along(NAMES)) {
[16:21:03.722]                   name <- removed[[kk]]
[16:21:03.722]                   NAME <- NAMES[[kk]]
[16:21:03.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.722]                     next
[16:21:03.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.722]                 }
[16:21:03.722]                 if (length(args) > 0) 
[16:21:03.722]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.722]             }
[16:21:03.722]             else {
[16:21:03.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.722]             }
[16:21:03.722]             {
[16:21:03.722]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.722]                   0L) {
[16:21:03.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.722]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.722]                   base::options(opts)
[16:21:03.722]                 }
[16:21:03.722]                 {
[16:21:03.722]                   {
[16:21:03.722]                     NULL
[16:21:03.722]                     RNGkind("Mersenne-Twister")
[16:21:03.722]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.722]                       inherits = FALSE)
[16:21:03.722]                   }
[16:21:03.722]                   options(future.plan = NULL)
[16:21:03.722]                   if (is.na(NA_character_)) 
[16:21:03.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.722]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.722]                     .init = FALSE)
[16:21:03.722]                 }
[16:21:03.722]             }
[16:21:03.722]         }
[16:21:03.722]     })
[16:21:03.722]     if (TRUE) {
[16:21:03.722]         base::sink(type = "output", split = FALSE)
[16:21:03.722]         if (TRUE) {
[16:21:03.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.722]         }
[16:21:03.722]         else {
[16:21:03.722]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.722]         }
[16:21:03.722]         base::close(...future.stdout)
[16:21:03.722]         ...future.stdout <- NULL
[16:21:03.722]     }
[16:21:03.722]     ...future.result$conditions <- ...future.conditions
[16:21:03.722]     ...future.result$finished <- base::Sys.time()
[16:21:03.722]     ...future.result
[16:21:03.722] }
[16:21:03.723] assign_globals() ...
[16:21:03.723] List of 1
[16:21:03.723]  $ x: num 1
[16:21:03.723]  - attr(*, "where")=List of 1
[16:21:03.723]   ..$ x:<environment: R_EmptyEnv> 
[16:21:03.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.723]  - attr(*, "resolved")= logi TRUE
[16:21:03.723]  - attr(*, "total_size")= num 56
[16:21:03.723]  - attr(*, "already-done")= logi TRUE
[16:21:03.726] - copied ‘x’ to environment
[16:21:03.726] assign_globals() ... done
[16:21:03.726] plan(): Setting new future strategy stack:
[16:21:03.726] List of future strategies:
[16:21:03.726] 1. sequential:
[16:21:03.726]    - args: function (..., envir = parent.frame())
[16:21:03.726]    - tweaked: FALSE
[16:21:03.726]    - call: NULL
[16:21:03.727] plan(): nbrOfWorkers() = 1
[16:21:03.727] plan(): Setting new future strategy stack:
[16:21:03.728] List of future strategies:
[16:21:03.728] 1. sequential:
[16:21:03.728]    - args: function (..., envir = parent.frame())
[16:21:03.728]    - tweaked: FALSE
[16:21:03.728]    - call: plan(strategy)
[16:21:03.728] plan(): nbrOfWorkers() = 1
[16:21:03.728] SequentialFuture started (and completed)
[16:21:03.728] - Launch lazy future ... done
[16:21:03.728] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.729] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.729] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:03.732] - globals found: [3] ‘{’, ‘<-’, ‘x’
[16:21:03.732] Searching for globals ... DONE
[16:21:03.733] Resolving globals: TRUE
[16:21:03.733] Resolving any globals that are futures ...
[16:21:03.733] - globals: [3] ‘{’, ‘<-’, ‘x’
[16:21:03.733] Resolving any globals that are futures ... DONE
[16:21:03.733] Resolving futures part of globals (recursively) ...
[16:21:03.733] resolve() on list ...
[16:21:03.734]  recursive: 99
[16:21:03.734]  length: 1
[16:21:03.734]  elements: ‘x’
[16:21:03.734]  length: 0 (resolved future 1)
[16:21:03.734] resolve() on list ... DONE
[16:21:03.734] - globals: [1] ‘x’
[16:21:03.734] Resolving futures part of globals (recursively) ... DONE
[16:21:03.734] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[16:21:03.735] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[16:21:03.735] - globals: [1] ‘x’
[16:21:03.735] 
[16:21:03.735] getGlobalsAndPackages() ... DONE
[16:21:03.735] run() for ‘Future’ ...
[16:21:03.735] - state: ‘created’
[16:21:03.735] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:03.736] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:03.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:03.736]   - Field: ‘label’
[16:21:03.736]   - Field: ‘local’
[16:21:03.736]   - Field: ‘owner’
[16:21:03.736]   - Field: ‘envir’
[16:21:03.736]   - Field: ‘packages’
[16:21:03.736]   - Field: ‘gc’
[16:21:03.737]   - Field: ‘conditions’
[16:21:03.737]   - Field: ‘expr’
[16:21:03.737]   - Field: ‘uuid’
[16:21:03.737]   - Field: ‘seed’
[16:21:03.737]   - Field: ‘version’
[16:21:03.737]   - Field: ‘result’
[16:21:03.737]   - Field: ‘asynchronous’
[16:21:03.737]   - Field: ‘calls’
[16:21:03.737]   - Field: ‘globals’
[16:21:03.737]   - Field: ‘stdout’
[16:21:03.737]   - Field: ‘earlySignal’
[16:21:03.738]   - Field: ‘lazy’
[16:21:03.738]   - Field: ‘state’
[16:21:03.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:03.738] - Launch lazy future ...
[16:21:03.738] Packages needed by the future expression (n = 0): <none>
[16:21:03.738] Packages needed by future strategies (n = 0): <none>
[16:21:03.739] {
[16:21:03.739]     {
[16:21:03.739]         {
[16:21:03.739]             ...future.startTime <- base::Sys.time()
[16:21:03.739]             {
[16:21:03.739]                 {
[16:21:03.739]                   {
[16:21:03.739]                     base::local({
[16:21:03.739]                       has_future <- base::requireNamespace("future", 
[16:21:03.739]                         quietly = TRUE)
[16:21:03.739]                       if (has_future) {
[16:21:03.739]                         ns <- base::getNamespace("future")
[16:21:03.739]                         version <- ns[[".package"]][["version"]]
[16:21:03.739]                         if (is.null(version)) 
[16:21:03.739]                           version <- utils::packageVersion("future")
[16:21:03.739]                       }
[16:21:03.739]                       else {
[16:21:03.739]                         version <- NULL
[16:21:03.739]                       }
[16:21:03.739]                       if (!has_future || version < "1.8.0") {
[16:21:03.739]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.739]                           "", base::R.version$version.string), 
[16:21:03.739]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:03.739]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.739]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.739]                             "release", "version")], collapse = " "), 
[16:21:03.739]                           hostname = base::Sys.info()[["nodename"]])
[16:21:03.739]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.739]                           info)
[16:21:03.739]                         info <- base::paste(info, collapse = "; ")
[16:21:03.739]                         if (!has_future) {
[16:21:03.739]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.739]                             info)
[16:21:03.739]                         }
[16:21:03.739]                         else {
[16:21:03.739]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.739]                             info, version)
[16:21:03.739]                         }
[16:21:03.739]                         base::stop(msg)
[16:21:03.739]                       }
[16:21:03.739]                     })
[16:21:03.739]                   }
[16:21:03.739]                   ...future.strategy.old <- future::plan("list")
[16:21:03.739]                   options(future.plan = NULL)
[16:21:03.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.739]                 }
[16:21:03.739]                 ...future.workdir <- getwd()
[16:21:03.739]             }
[16:21:03.739]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.739]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.739]         }
[16:21:03.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.739]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:03.739]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.739]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.739]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.739]             base::names(...future.oldOptions))
[16:21:03.739]     }
[16:21:03.739]     if (FALSE) {
[16:21:03.739]     }
[16:21:03.739]     else {
[16:21:03.739]         if (TRUE) {
[16:21:03.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.739]                 open = "w")
[16:21:03.739]         }
[16:21:03.739]         else {
[16:21:03.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.739]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.739]         }
[16:21:03.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.739]             base::sink(type = "output", split = FALSE)
[16:21:03.739]             base::close(...future.stdout)
[16:21:03.739]         }, add = TRUE)
[16:21:03.739]     }
[16:21:03.739]     ...future.frame <- base::sys.nframe()
[16:21:03.739]     ...future.conditions <- base::list()
[16:21:03.739]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.739]     if (FALSE) {
[16:21:03.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.739]     }
[16:21:03.739]     ...future.result <- base::tryCatch({
[16:21:03.739]         base::withCallingHandlers({
[16:21:03.739]             ...future.value <- base::withVisible(base::local({
[16:21:03.739]                 x <- x()
[16:21:03.739]                 x
[16:21:03.739]             }))
[16:21:03.739]             future::FutureResult(value = ...future.value$value, 
[16:21:03.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.739]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.739]                     ...future.globalenv.names))
[16:21:03.739]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.739]         }, condition = base::local({
[16:21:03.739]             c <- base::c
[16:21:03.739]             inherits <- base::inherits
[16:21:03.739]             invokeRestart <- base::invokeRestart
[16:21:03.739]             length <- base::length
[16:21:03.739]             list <- base::list
[16:21:03.739]             seq.int <- base::seq.int
[16:21:03.739]             signalCondition <- base::signalCondition
[16:21:03.739]             sys.calls <- base::sys.calls
[16:21:03.739]             `[[` <- base::`[[`
[16:21:03.739]             `+` <- base::`+`
[16:21:03.739]             `<<-` <- base::`<<-`
[16:21:03.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.739]                   3L)]
[16:21:03.739]             }
[16:21:03.739]             function(cond) {
[16:21:03.739]                 is_error <- inherits(cond, "error")
[16:21:03.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.739]                   NULL)
[16:21:03.739]                 if (is_error) {
[16:21:03.739]                   sessionInformation <- function() {
[16:21:03.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.739]                       search = base::search(), system = base::Sys.info())
[16:21:03.739]                   }
[16:21:03.739]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.739]                     cond$call), session = sessionInformation(), 
[16:21:03.739]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.739]                   signalCondition(cond)
[16:21:03.739]                 }
[16:21:03.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.739]                 "immediateCondition"))) {
[16:21:03.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.739]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.739]                   if (TRUE && !signal) {
[16:21:03.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.739]                     {
[16:21:03.739]                       inherits <- base::inherits
[16:21:03.739]                       invokeRestart <- base::invokeRestart
[16:21:03.739]                       is.null <- base::is.null
[16:21:03.739]                       muffled <- FALSE
[16:21:03.739]                       if (inherits(cond, "message")) {
[16:21:03.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.739]                         if (muffled) 
[16:21:03.739]                           invokeRestart("muffleMessage")
[16:21:03.739]                       }
[16:21:03.739]                       else if (inherits(cond, "warning")) {
[16:21:03.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.739]                         if (muffled) 
[16:21:03.739]                           invokeRestart("muffleWarning")
[16:21:03.739]                       }
[16:21:03.739]                       else if (inherits(cond, "condition")) {
[16:21:03.739]                         if (!is.null(pattern)) {
[16:21:03.739]                           computeRestarts <- base::computeRestarts
[16:21:03.739]                           grepl <- base::grepl
[16:21:03.739]                           restarts <- computeRestarts(cond)
[16:21:03.739]                           for (restart in restarts) {
[16:21:03.739]                             name <- restart$name
[16:21:03.739]                             if (is.null(name)) 
[16:21:03.739]                               next
[16:21:03.739]                             if (!grepl(pattern, name)) 
[16:21:03.739]                               next
[16:21:03.739]                             invokeRestart(restart)
[16:21:03.739]                             muffled <- TRUE
[16:21:03.739]                             break
[16:21:03.739]                           }
[16:21:03.739]                         }
[16:21:03.739]                       }
[16:21:03.739]                       invisible(muffled)
[16:21:03.739]                     }
[16:21:03.739]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.739]                   }
[16:21:03.739]                 }
[16:21:03.739]                 else {
[16:21:03.739]                   if (TRUE) {
[16:21:03.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.739]                     {
[16:21:03.739]                       inherits <- base::inherits
[16:21:03.739]                       invokeRestart <- base::invokeRestart
[16:21:03.739]                       is.null <- base::is.null
[16:21:03.739]                       muffled <- FALSE
[16:21:03.739]                       if (inherits(cond, "message")) {
[16:21:03.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.739]                         if (muffled) 
[16:21:03.739]                           invokeRestart("muffleMessage")
[16:21:03.739]                       }
[16:21:03.739]                       else if (inherits(cond, "warning")) {
[16:21:03.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.739]                         if (muffled) 
[16:21:03.739]                           invokeRestart("muffleWarning")
[16:21:03.739]                       }
[16:21:03.739]                       else if (inherits(cond, "condition")) {
[16:21:03.739]                         if (!is.null(pattern)) {
[16:21:03.739]                           computeRestarts <- base::computeRestarts
[16:21:03.739]                           grepl <- base::grepl
[16:21:03.739]                           restarts <- computeRestarts(cond)
[16:21:03.739]                           for (restart in restarts) {
[16:21:03.739]                             name <- restart$name
[16:21:03.739]                             if (is.null(name)) 
[16:21:03.739]                               next
[16:21:03.739]                             if (!grepl(pattern, name)) 
[16:21:03.739]                               next
[16:21:03.739]                             invokeRestart(restart)
[16:21:03.739]                             muffled <- TRUE
[16:21:03.739]                             break
[16:21:03.739]                           }
[16:21:03.739]                         }
[16:21:03.739]                       }
[16:21:03.739]                       invisible(muffled)
[16:21:03.739]                     }
[16:21:03.739]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.739]                   }
[16:21:03.739]                 }
[16:21:03.739]             }
[16:21:03.739]         }))
[16:21:03.739]     }, error = function(ex) {
[16:21:03.739]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.739]                 ...future.rng), started = ...future.startTime, 
[16:21:03.739]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.739]             version = "1.8"), class = "FutureResult")
[16:21:03.739]     }, finally = {
[16:21:03.739]         if (!identical(...future.workdir, getwd())) 
[16:21:03.739]             setwd(...future.workdir)
[16:21:03.739]         {
[16:21:03.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.739]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.739]             }
[16:21:03.739]             base::options(...future.oldOptions)
[16:21:03.739]             if (.Platform$OS.type == "windows") {
[16:21:03.739]                 old_names <- names(...future.oldEnvVars)
[16:21:03.739]                 envs <- base::Sys.getenv()
[16:21:03.739]                 names <- names(envs)
[16:21:03.739]                 common <- intersect(names, old_names)
[16:21:03.739]                 added <- setdiff(names, old_names)
[16:21:03.739]                 removed <- setdiff(old_names, names)
[16:21:03.739]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.739]                   envs[common]]
[16:21:03.739]                 NAMES <- toupper(changed)
[16:21:03.739]                 args <- list()
[16:21:03.739]                 for (kk in seq_along(NAMES)) {
[16:21:03.739]                   name <- changed[[kk]]
[16:21:03.739]                   NAME <- NAMES[[kk]]
[16:21:03.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.739]                     next
[16:21:03.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.739]                 }
[16:21:03.739]                 NAMES <- toupper(added)
[16:21:03.739]                 for (kk in seq_along(NAMES)) {
[16:21:03.739]                   name <- added[[kk]]
[16:21:03.739]                   NAME <- NAMES[[kk]]
[16:21:03.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.739]                     next
[16:21:03.739]                   args[[name]] <- ""
[16:21:03.739]                 }
[16:21:03.739]                 NAMES <- toupper(removed)
[16:21:03.739]                 for (kk in seq_along(NAMES)) {
[16:21:03.739]                   name <- removed[[kk]]
[16:21:03.739]                   NAME <- NAMES[[kk]]
[16:21:03.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.739]                     next
[16:21:03.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.739]                 }
[16:21:03.739]                 if (length(args) > 0) 
[16:21:03.739]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.739]             }
[16:21:03.739]             else {
[16:21:03.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.739]             }
[16:21:03.739]             {
[16:21:03.739]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.739]                   0L) {
[16:21:03.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.739]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.739]                   base::options(opts)
[16:21:03.739]                 }
[16:21:03.739]                 {
[16:21:03.739]                   {
[16:21:03.739]                     NULL
[16:21:03.739]                     RNGkind("Mersenne-Twister")
[16:21:03.739]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:03.739]                       inherits = FALSE)
[16:21:03.739]                   }
[16:21:03.739]                   options(future.plan = NULL)
[16:21:03.739]                   if (is.na(NA_character_)) 
[16:21:03.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.739]                     .init = FALSE)
[16:21:03.739]                 }
[16:21:03.739]             }
[16:21:03.739]         }
[16:21:03.739]     })
[16:21:03.739]     if (TRUE) {
[16:21:03.739]         base::sink(type = "output", split = FALSE)
[16:21:03.739]         if (TRUE) {
[16:21:03.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.739]         }
[16:21:03.739]         else {
[16:21:03.739]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.739]         }
[16:21:03.739]         base::close(...future.stdout)
[16:21:03.739]         ...future.stdout <- NULL
[16:21:03.739]     }
[16:21:03.739]     ...future.result$conditions <- ...future.conditions
[16:21:03.739]     ...future.result$finished <- base::Sys.time()
[16:21:03.739]     ...future.result
[16:21:03.739] }
[16:21:03.740] assign_globals() ...
[16:21:03.740] List of 1
[16:21:03.740]  $ x:function ()  
[16:21:03.740]  - attr(*, "where")=List of 1
[16:21:03.740]   ..$ x:<environment: R_EmptyEnv> 
[16:21:03.740]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.740]  - attr(*, "resolved")= logi TRUE
[16:21:03.740]  - attr(*, "total_size")= num 1032
[16:21:03.740]  - attr(*, "already-done")= logi TRUE
[16:21:03.743] - reassign environment for ‘x’
[16:21:03.743] - copied ‘x’ to environment
[16:21:03.743] assign_globals() ... done
[16:21:03.743] plan(): Setting new future strategy stack:
[16:21:03.743] List of future strategies:
[16:21:03.743] 1. sequential:
[16:21:03.743]    - args: function (..., envir = parent.frame())
[16:21:03.743]    - tweaked: FALSE
[16:21:03.743]    - call: NULL
[16:21:03.743] plan(): nbrOfWorkers() = 1
[16:21:03.744] plan(): Setting new future strategy stack:
[16:21:03.744] List of future strategies:
[16:21:03.744] 1. sequential:
[16:21:03.744]    - args: function (..., envir = parent.frame())
[16:21:03.744]    - tweaked: FALSE
[16:21:03.744]    - call: plan(strategy)
[16:21:03.745] plan(): nbrOfWorkers() = 1
[16:21:03.745] SequentialFuture started (and completed)
[16:21:03.745] - Launch lazy future ... done
[16:21:03.745] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[16:21:03.754] plan(): Setting new future strategy stack:
[16:21:03.754] List of future strategies:
[16:21:03.754] 1. multicore:
[16:21:03.754]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:03.754]    - tweaked: FALSE
[16:21:03.754]    - call: plan(strategy)
[16:21:03.758] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.758] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.758] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.759] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:21:03.760] Searching for globals ... DONE
[16:21:03.760] Resolving globals: TRUE
[16:21:03.760] Resolving any globals that are futures ...
[16:21:03.760] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:21:03.762] Resolving any globals that are futures ... DONE
[16:21:03.762] 
[16:21:03.762] 
[16:21:03.762] getGlobalsAndPackages() ... DONE
[16:21:03.762] run() for ‘Future’ ...
[16:21:03.763] - state: ‘created’
[16:21:03.763] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:03.766] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:03.767] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:03.767]   - Field: ‘label’
[16:21:03.767]   - Field: ‘local’
[16:21:03.767]   - Field: ‘owner’
[16:21:03.767]   - Field: ‘envir’
[16:21:03.767]   - Field: ‘workers’
[16:21:03.767]   - Field: ‘packages’
[16:21:03.767]   - Field: ‘gc’
[16:21:03.767]   - Field: ‘job’
[16:21:03.767]   - Field: ‘conditions’
[16:21:03.767]   - Field: ‘expr’
[16:21:03.768]   - Field: ‘uuid’
[16:21:03.768]   - Field: ‘seed’
[16:21:03.768]   - Field: ‘version’
[16:21:03.768]   - Field: ‘result’
[16:21:03.768]   - Field: ‘asynchronous’
[16:21:03.768]   - Field: ‘calls’
[16:21:03.768]   - Field: ‘globals’
[16:21:03.768]   - Field: ‘stdout’
[16:21:03.768]   - Field: ‘earlySignal’
[16:21:03.768]   - Field: ‘lazy’
[16:21:03.769]   - Field: ‘state’
[16:21:03.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:03.769] - Launch lazy future ...
[16:21:03.770] Packages needed by the future expression (n = 0): <none>
[16:21:03.770] Packages needed by future strategies (n = 0): <none>
[16:21:03.770] {
[16:21:03.770]     {
[16:21:03.770]         {
[16:21:03.770]             ...future.startTime <- base::Sys.time()
[16:21:03.770]             {
[16:21:03.770]                 {
[16:21:03.770]                   {
[16:21:03.770]                     {
[16:21:03.770]                       base::local({
[16:21:03.770]                         has_future <- base::requireNamespace("future", 
[16:21:03.770]                           quietly = TRUE)
[16:21:03.770]                         if (has_future) {
[16:21:03.770]                           ns <- base::getNamespace("future")
[16:21:03.770]                           version <- ns[[".package"]][["version"]]
[16:21:03.770]                           if (is.null(version)) 
[16:21:03.770]                             version <- utils::packageVersion("future")
[16:21:03.770]                         }
[16:21:03.770]                         else {
[16:21:03.770]                           version <- NULL
[16:21:03.770]                         }
[16:21:03.770]                         if (!has_future || version < "1.8.0") {
[16:21:03.770]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.770]                             "", base::R.version$version.string), 
[16:21:03.770]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.770]                               "release", "version")], collapse = " "), 
[16:21:03.770]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.770]                             info)
[16:21:03.770]                           info <- base::paste(info, collapse = "; ")
[16:21:03.770]                           if (!has_future) {
[16:21:03.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.770]                               info)
[16:21:03.770]                           }
[16:21:03.770]                           else {
[16:21:03.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.770]                               info, version)
[16:21:03.770]                           }
[16:21:03.770]                           base::stop(msg)
[16:21:03.770]                         }
[16:21:03.770]                       })
[16:21:03.770]                     }
[16:21:03.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:03.770]                     base::options(mc.cores = 1L)
[16:21:03.770]                   }
[16:21:03.770]                   ...future.strategy.old <- future::plan("list")
[16:21:03.770]                   options(future.plan = NULL)
[16:21:03.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.770]                 }
[16:21:03.770]                 ...future.workdir <- getwd()
[16:21:03.770]             }
[16:21:03.770]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.770]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.770]         }
[16:21:03.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.770]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.770]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.770]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.770]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.770]             base::names(...future.oldOptions))
[16:21:03.770]     }
[16:21:03.770]     if (FALSE) {
[16:21:03.770]     }
[16:21:03.770]     else {
[16:21:03.770]         if (TRUE) {
[16:21:03.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.770]                 open = "w")
[16:21:03.770]         }
[16:21:03.770]         else {
[16:21:03.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.770]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.770]         }
[16:21:03.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.770]             base::sink(type = "output", split = FALSE)
[16:21:03.770]             base::close(...future.stdout)
[16:21:03.770]         }, add = TRUE)
[16:21:03.770]     }
[16:21:03.770]     ...future.frame <- base::sys.nframe()
[16:21:03.770]     ...future.conditions <- base::list()
[16:21:03.770]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.770]     if (FALSE) {
[16:21:03.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.770]     }
[16:21:03.770]     ...future.result <- base::tryCatch({
[16:21:03.770]         base::withCallingHandlers({
[16:21:03.770]             ...future.value <- base::withVisible(base::local({
[16:21:03.770]                 withCallingHandlers({
[16:21:03.770]                   {
[16:21:03.770]                     b <- a
[16:21:03.770]                     a <- 2
[16:21:03.770]                     a * b
[16:21:03.770]                   }
[16:21:03.770]                 }, immediateCondition = function(cond) {
[16:21:03.770]                   save_rds <- function (object, pathname, ...) 
[16:21:03.770]                   {
[16:21:03.770]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:03.770]                     if (file_test("-f", pathname_tmp)) {
[16:21:03.770]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.770]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:03.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.770]                         fi_tmp[["mtime"]])
[16:21:03.770]                     }
[16:21:03.770]                     tryCatch({
[16:21:03.770]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:03.770]                     }, error = function(ex) {
[16:21:03.770]                       msg <- conditionMessage(ex)
[16:21:03.770]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.770]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:03.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.770]                         fi_tmp[["mtime"]], msg)
[16:21:03.770]                       ex$message <- msg
[16:21:03.770]                       stop(ex)
[16:21:03.770]                     })
[16:21:03.770]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:03.770]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:03.770]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:03.770]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.770]                       fi <- file.info(pathname)
[16:21:03.770]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:03.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.770]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:03.770]                         fi[["size"]], fi[["mtime"]])
[16:21:03.770]                       stop(msg)
[16:21:03.770]                     }
[16:21:03.770]                     invisible(pathname)
[16:21:03.770]                   }
[16:21:03.770]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:03.770]                     rootPath = tempdir()) 
[16:21:03.770]                   {
[16:21:03.770]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:03.770]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:03.770]                       tmpdir = path, fileext = ".rds")
[16:21:03.770]                     save_rds(obj, file)
[16:21:03.770]                   }
[16:21:03.770]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:03.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.770]                   {
[16:21:03.770]                     inherits <- base::inherits
[16:21:03.770]                     invokeRestart <- base::invokeRestart
[16:21:03.770]                     is.null <- base::is.null
[16:21:03.770]                     muffled <- FALSE
[16:21:03.770]                     if (inherits(cond, "message")) {
[16:21:03.770]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:03.770]                       if (muffled) 
[16:21:03.770]                         invokeRestart("muffleMessage")
[16:21:03.770]                     }
[16:21:03.770]                     else if (inherits(cond, "warning")) {
[16:21:03.770]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:03.770]                       if (muffled) 
[16:21:03.770]                         invokeRestart("muffleWarning")
[16:21:03.770]                     }
[16:21:03.770]                     else if (inherits(cond, "condition")) {
[16:21:03.770]                       if (!is.null(pattern)) {
[16:21:03.770]                         computeRestarts <- base::computeRestarts
[16:21:03.770]                         grepl <- base::grepl
[16:21:03.770]                         restarts <- computeRestarts(cond)
[16:21:03.770]                         for (restart in restarts) {
[16:21:03.770]                           name <- restart$name
[16:21:03.770]                           if (is.null(name)) 
[16:21:03.770]                             next
[16:21:03.770]                           if (!grepl(pattern, name)) 
[16:21:03.770]                             next
[16:21:03.770]                           invokeRestart(restart)
[16:21:03.770]                           muffled <- TRUE
[16:21:03.770]                           break
[16:21:03.770]                         }
[16:21:03.770]                       }
[16:21:03.770]                     }
[16:21:03.770]                     invisible(muffled)
[16:21:03.770]                   }
[16:21:03.770]                   muffleCondition(cond)
[16:21:03.770]                 })
[16:21:03.770]             }))
[16:21:03.770]             future::FutureResult(value = ...future.value$value, 
[16:21:03.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.770]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.770]                     ...future.globalenv.names))
[16:21:03.770]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.770]         }, condition = base::local({
[16:21:03.770]             c <- base::c
[16:21:03.770]             inherits <- base::inherits
[16:21:03.770]             invokeRestart <- base::invokeRestart
[16:21:03.770]             length <- base::length
[16:21:03.770]             list <- base::list
[16:21:03.770]             seq.int <- base::seq.int
[16:21:03.770]             signalCondition <- base::signalCondition
[16:21:03.770]             sys.calls <- base::sys.calls
[16:21:03.770]             `[[` <- base::`[[`
[16:21:03.770]             `+` <- base::`+`
[16:21:03.770]             `<<-` <- base::`<<-`
[16:21:03.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.770]                   3L)]
[16:21:03.770]             }
[16:21:03.770]             function(cond) {
[16:21:03.770]                 is_error <- inherits(cond, "error")
[16:21:03.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.770]                   NULL)
[16:21:03.770]                 if (is_error) {
[16:21:03.770]                   sessionInformation <- function() {
[16:21:03.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.770]                       search = base::search(), system = base::Sys.info())
[16:21:03.770]                   }
[16:21:03.770]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.770]                     cond$call), session = sessionInformation(), 
[16:21:03.770]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.770]                   signalCondition(cond)
[16:21:03.770]                 }
[16:21:03.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.770]                 "immediateCondition"))) {
[16:21:03.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.770]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.770]                   if (TRUE && !signal) {
[16:21:03.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.770]                     {
[16:21:03.770]                       inherits <- base::inherits
[16:21:03.770]                       invokeRestart <- base::invokeRestart
[16:21:03.770]                       is.null <- base::is.null
[16:21:03.770]                       muffled <- FALSE
[16:21:03.770]                       if (inherits(cond, "message")) {
[16:21:03.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.770]                         if (muffled) 
[16:21:03.770]                           invokeRestart("muffleMessage")
[16:21:03.770]                       }
[16:21:03.770]                       else if (inherits(cond, "warning")) {
[16:21:03.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.770]                         if (muffled) 
[16:21:03.770]                           invokeRestart("muffleWarning")
[16:21:03.770]                       }
[16:21:03.770]                       else if (inherits(cond, "condition")) {
[16:21:03.770]                         if (!is.null(pattern)) {
[16:21:03.770]                           computeRestarts <- base::computeRestarts
[16:21:03.770]                           grepl <- base::grepl
[16:21:03.770]                           restarts <- computeRestarts(cond)
[16:21:03.770]                           for (restart in restarts) {
[16:21:03.770]                             name <- restart$name
[16:21:03.770]                             if (is.null(name)) 
[16:21:03.770]                               next
[16:21:03.770]                             if (!grepl(pattern, name)) 
[16:21:03.770]                               next
[16:21:03.770]                             invokeRestart(restart)
[16:21:03.770]                             muffled <- TRUE
[16:21:03.770]                             break
[16:21:03.770]                           }
[16:21:03.770]                         }
[16:21:03.770]                       }
[16:21:03.770]                       invisible(muffled)
[16:21:03.770]                     }
[16:21:03.770]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.770]                   }
[16:21:03.770]                 }
[16:21:03.770]                 else {
[16:21:03.770]                   if (TRUE) {
[16:21:03.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.770]                     {
[16:21:03.770]                       inherits <- base::inherits
[16:21:03.770]                       invokeRestart <- base::invokeRestart
[16:21:03.770]                       is.null <- base::is.null
[16:21:03.770]                       muffled <- FALSE
[16:21:03.770]                       if (inherits(cond, "message")) {
[16:21:03.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.770]                         if (muffled) 
[16:21:03.770]                           invokeRestart("muffleMessage")
[16:21:03.770]                       }
[16:21:03.770]                       else if (inherits(cond, "warning")) {
[16:21:03.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.770]                         if (muffled) 
[16:21:03.770]                           invokeRestart("muffleWarning")
[16:21:03.770]                       }
[16:21:03.770]                       else if (inherits(cond, "condition")) {
[16:21:03.770]                         if (!is.null(pattern)) {
[16:21:03.770]                           computeRestarts <- base::computeRestarts
[16:21:03.770]                           grepl <- base::grepl
[16:21:03.770]                           restarts <- computeRestarts(cond)
[16:21:03.770]                           for (restart in restarts) {
[16:21:03.770]                             name <- restart$name
[16:21:03.770]                             if (is.null(name)) 
[16:21:03.770]                               next
[16:21:03.770]                             if (!grepl(pattern, name)) 
[16:21:03.770]                               next
[16:21:03.770]                             invokeRestart(restart)
[16:21:03.770]                             muffled <- TRUE
[16:21:03.770]                             break
[16:21:03.770]                           }
[16:21:03.770]                         }
[16:21:03.770]                       }
[16:21:03.770]                       invisible(muffled)
[16:21:03.770]                     }
[16:21:03.770]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.770]                   }
[16:21:03.770]                 }
[16:21:03.770]             }
[16:21:03.770]         }))
[16:21:03.770]     }, error = function(ex) {
[16:21:03.770]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.770]                 ...future.rng), started = ...future.startTime, 
[16:21:03.770]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.770]             version = "1.8"), class = "FutureResult")
[16:21:03.770]     }, finally = {
[16:21:03.770]         if (!identical(...future.workdir, getwd())) 
[16:21:03.770]             setwd(...future.workdir)
[16:21:03.770]         {
[16:21:03.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.770]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.770]             }
[16:21:03.770]             base::options(...future.oldOptions)
[16:21:03.770]             if (.Platform$OS.type == "windows") {
[16:21:03.770]                 old_names <- names(...future.oldEnvVars)
[16:21:03.770]                 envs <- base::Sys.getenv()
[16:21:03.770]                 names <- names(envs)
[16:21:03.770]                 common <- intersect(names, old_names)
[16:21:03.770]                 added <- setdiff(names, old_names)
[16:21:03.770]                 removed <- setdiff(old_names, names)
[16:21:03.770]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.770]                   envs[common]]
[16:21:03.770]                 NAMES <- toupper(changed)
[16:21:03.770]                 args <- list()
[16:21:03.770]                 for (kk in seq_along(NAMES)) {
[16:21:03.770]                   name <- changed[[kk]]
[16:21:03.770]                   NAME <- NAMES[[kk]]
[16:21:03.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.770]                     next
[16:21:03.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.770]                 }
[16:21:03.770]                 NAMES <- toupper(added)
[16:21:03.770]                 for (kk in seq_along(NAMES)) {
[16:21:03.770]                   name <- added[[kk]]
[16:21:03.770]                   NAME <- NAMES[[kk]]
[16:21:03.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.770]                     next
[16:21:03.770]                   args[[name]] <- ""
[16:21:03.770]                 }
[16:21:03.770]                 NAMES <- toupper(removed)
[16:21:03.770]                 for (kk in seq_along(NAMES)) {
[16:21:03.770]                   name <- removed[[kk]]
[16:21:03.770]                   NAME <- NAMES[[kk]]
[16:21:03.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.770]                     next
[16:21:03.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.770]                 }
[16:21:03.770]                 if (length(args) > 0) 
[16:21:03.770]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.770]             }
[16:21:03.770]             else {
[16:21:03.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.770]             }
[16:21:03.770]             {
[16:21:03.770]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.770]                   0L) {
[16:21:03.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.770]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.770]                   base::options(opts)
[16:21:03.770]                 }
[16:21:03.770]                 {
[16:21:03.770]                   {
[16:21:03.770]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:03.770]                     NULL
[16:21:03.770]                   }
[16:21:03.770]                   options(future.plan = NULL)
[16:21:03.770]                   if (is.na(NA_character_)) 
[16:21:03.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.770]                     .init = FALSE)
[16:21:03.770]                 }
[16:21:03.770]             }
[16:21:03.770]         }
[16:21:03.770]     })
[16:21:03.770]     if (TRUE) {
[16:21:03.770]         base::sink(type = "output", split = FALSE)
[16:21:03.770]         if (TRUE) {
[16:21:03.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.770]         }
[16:21:03.770]         else {
[16:21:03.770]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.770]         }
[16:21:03.770]         base::close(...future.stdout)
[16:21:03.770]         ...future.stdout <- NULL
[16:21:03.770]     }
[16:21:03.770]     ...future.result$conditions <- ...future.conditions
[16:21:03.770]     ...future.result$finished <- base::Sys.time()
[16:21:03.770]     ...future.result
[16:21:03.770] }
[16:21:03.773] requestCore(): workers = 2
[16:21:03.776] MulticoreFuture started
[16:21:03.776] - Launch lazy future ... done
[16:21:03.777] plan(): Setting new future strategy stack:
[16:21:03.777] run() for ‘MulticoreFuture’ ... done
[16:21:03.777] List of future strategies:
[16:21:03.777] 1. sequential:
[16:21:03.777]    - args: function (..., envir = parent.frame())
[16:21:03.777]    - tweaked: FALSE
[16:21:03.777]    - call: NULL
[16:21:03.778] plan(): nbrOfWorkers() = 1
[16:21:03.778] result() for MulticoreFuture ...
[16:21:03.780] plan(): Setting new future strategy stack:
[16:21:03.780] List of future strategies:
[16:21:03.780] 1. multicore:
[16:21:03.780]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:03.780]    - tweaked: FALSE
[16:21:03.780]    - call: plan(strategy)
[16:21:03.785] plan(): nbrOfWorkers() = 2
[16:21:03.790] result() for MulticoreFuture ...
[16:21:03.790] result() for MulticoreFuture ... done
[16:21:03.790] result() for MulticoreFuture ... done
[16:21:03.790] result() for MulticoreFuture ...
[16:21:03.791] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.791] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.792] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.793] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:21:03.794] Searching for globals ... DONE
[16:21:03.794] Resolving globals: TRUE
[16:21:03.794] Resolving any globals that are futures ...
[16:21:03.794] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:21:03.794] Resolving any globals that are futures ... DONE
[16:21:03.795] 
[16:21:03.795] 
[16:21:03.795] getGlobalsAndPackages() ... DONE
[16:21:03.795] run() for ‘Future’ ...
[16:21:03.795] - state: ‘created’
[16:21:03.795] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:03.800] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:03.800] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:03.800]   - Field: ‘label’
[16:21:03.800]   - Field: ‘local’
[16:21:03.800]   - Field: ‘owner’
[16:21:03.800]   - Field: ‘envir’
[16:21:03.800]   - Field: ‘workers’
[16:21:03.801]   - Field: ‘packages’
[16:21:03.801]   - Field: ‘gc’
[16:21:03.801]   - Field: ‘job’
[16:21:03.801]   - Field: ‘conditions’
[16:21:03.801]   - Field: ‘expr’
[16:21:03.801]   - Field: ‘uuid’
[16:21:03.801]   - Field: ‘seed’
[16:21:03.801]   - Field: ‘version’
[16:21:03.801]   - Field: ‘result’
[16:21:03.802]   - Field: ‘asynchronous’
[16:21:03.802]   - Field: ‘calls’
[16:21:03.802]   - Field: ‘globals’
[16:21:03.802]   - Field: ‘stdout’
[16:21:03.802]   - Field: ‘earlySignal’
[16:21:03.802]   - Field: ‘lazy’
[16:21:03.802]   - Field: ‘state’
[16:21:03.802] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:03.802] - Launch lazy future ...
[16:21:03.803] Packages needed by the future expression (n = 0): <none>
[16:21:03.803] Packages needed by future strategies (n = 0): <none>
[16:21:03.803] {
[16:21:03.803]     {
[16:21:03.803]         {
[16:21:03.803]             ...future.startTime <- base::Sys.time()
[16:21:03.803]             {
[16:21:03.803]                 {
[16:21:03.803]                   {
[16:21:03.803]                     {
[16:21:03.803]                       base::local({
[16:21:03.803]                         has_future <- base::requireNamespace("future", 
[16:21:03.803]                           quietly = TRUE)
[16:21:03.803]                         if (has_future) {
[16:21:03.803]                           ns <- base::getNamespace("future")
[16:21:03.803]                           version <- ns[[".package"]][["version"]]
[16:21:03.803]                           if (is.null(version)) 
[16:21:03.803]                             version <- utils::packageVersion("future")
[16:21:03.803]                         }
[16:21:03.803]                         else {
[16:21:03.803]                           version <- NULL
[16:21:03.803]                         }
[16:21:03.803]                         if (!has_future || version < "1.8.0") {
[16:21:03.803]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.803]                             "", base::R.version$version.string), 
[16:21:03.803]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.803]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.803]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.803]                               "release", "version")], collapse = " "), 
[16:21:03.803]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.803]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.803]                             info)
[16:21:03.803]                           info <- base::paste(info, collapse = "; ")
[16:21:03.803]                           if (!has_future) {
[16:21:03.803]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.803]                               info)
[16:21:03.803]                           }
[16:21:03.803]                           else {
[16:21:03.803]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.803]                               info, version)
[16:21:03.803]                           }
[16:21:03.803]                           base::stop(msg)
[16:21:03.803]                         }
[16:21:03.803]                       })
[16:21:03.803]                     }
[16:21:03.803]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:03.803]                     base::options(mc.cores = 1L)
[16:21:03.803]                   }
[16:21:03.803]                   ...future.strategy.old <- future::plan("list")
[16:21:03.803]                   options(future.plan = NULL)
[16:21:03.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.803]                 }
[16:21:03.803]                 ...future.workdir <- getwd()
[16:21:03.803]             }
[16:21:03.803]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.803]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.803]         }
[16:21:03.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.803]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.803]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.803]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.803]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.803]             base::names(...future.oldOptions))
[16:21:03.803]     }
[16:21:03.803]     if (FALSE) {
[16:21:03.803]     }
[16:21:03.803]     else {
[16:21:03.803]         if (TRUE) {
[16:21:03.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.803]                 open = "w")
[16:21:03.803]         }
[16:21:03.803]         else {
[16:21:03.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.803]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.803]         }
[16:21:03.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.803]             base::sink(type = "output", split = FALSE)
[16:21:03.803]             base::close(...future.stdout)
[16:21:03.803]         }, add = TRUE)
[16:21:03.803]     }
[16:21:03.803]     ...future.frame <- base::sys.nframe()
[16:21:03.803]     ...future.conditions <- base::list()
[16:21:03.803]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.803]     if (FALSE) {
[16:21:03.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.803]     }
[16:21:03.803]     ...future.result <- base::tryCatch({
[16:21:03.803]         base::withCallingHandlers({
[16:21:03.803]             ...future.value <- base::withVisible(base::local({
[16:21:03.803]                 withCallingHandlers({
[16:21:03.803]                   {
[16:21:03.803]                     b <- a
[16:21:03.803]                     a <- 2
[16:21:03.803]                     a * b
[16:21:03.803]                   }
[16:21:03.803]                 }, immediateCondition = function(cond) {
[16:21:03.803]                   save_rds <- function (object, pathname, ...) 
[16:21:03.803]                   {
[16:21:03.803]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:03.803]                     if (file_test("-f", pathname_tmp)) {
[16:21:03.803]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.803]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:03.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.803]                         fi_tmp[["mtime"]])
[16:21:03.803]                     }
[16:21:03.803]                     tryCatch({
[16:21:03.803]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:03.803]                     }, error = function(ex) {
[16:21:03.803]                       msg <- conditionMessage(ex)
[16:21:03.803]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.803]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:03.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.803]                         fi_tmp[["mtime"]], msg)
[16:21:03.803]                       ex$message <- msg
[16:21:03.803]                       stop(ex)
[16:21:03.803]                     })
[16:21:03.803]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:03.803]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:03.803]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:03.803]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.803]                       fi <- file.info(pathname)
[16:21:03.803]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:03.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.803]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:03.803]                         fi[["size"]], fi[["mtime"]])
[16:21:03.803]                       stop(msg)
[16:21:03.803]                     }
[16:21:03.803]                     invisible(pathname)
[16:21:03.803]                   }
[16:21:03.803]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:03.803]                     rootPath = tempdir()) 
[16:21:03.803]                   {
[16:21:03.803]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:03.803]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:03.803]                       tmpdir = path, fileext = ".rds")
[16:21:03.803]                     save_rds(obj, file)
[16:21:03.803]                   }
[16:21:03.803]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:03.803]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.803]                   {
[16:21:03.803]                     inherits <- base::inherits
[16:21:03.803]                     invokeRestart <- base::invokeRestart
[16:21:03.803]                     is.null <- base::is.null
[16:21:03.803]                     muffled <- FALSE
[16:21:03.803]                     if (inherits(cond, "message")) {
[16:21:03.803]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:03.803]                       if (muffled) 
[16:21:03.803]                         invokeRestart("muffleMessage")
[16:21:03.803]                     }
[16:21:03.803]                     else if (inherits(cond, "warning")) {
[16:21:03.803]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:03.803]                       if (muffled) 
[16:21:03.803]                         invokeRestart("muffleWarning")
[16:21:03.803]                     }
[16:21:03.803]                     else if (inherits(cond, "condition")) {
[16:21:03.803]                       if (!is.null(pattern)) {
[16:21:03.803]                         computeRestarts <- base::computeRestarts
[16:21:03.803]                         grepl <- base::grepl
[16:21:03.803]                         restarts <- computeRestarts(cond)
[16:21:03.803]                         for (restart in restarts) {
[16:21:03.803]                           name <- restart$name
[16:21:03.803]                           if (is.null(name)) 
[16:21:03.803]                             next
[16:21:03.803]                           if (!grepl(pattern, name)) 
[16:21:03.803]                             next
[16:21:03.803]                           invokeRestart(restart)
[16:21:03.803]                           muffled <- TRUE
[16:21:03.803]                           break
[16:21:03.803]                         }
[16:21:03.803]                       }
[16:21:03.803]                     }
[16:21:03.803]                     invisible(muffled)
[16:21:03.803]                   }
[16:21:03.803]                   muffleCondition(cond)
[16:21:03.803]                 })
[16:21:03.803]             }))
[16:21:03.803]             future::FutureResult(value = ...future.value$value, 
[16:21:03.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.803]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.803]                     ...future.globalenv.names))
[16:21:03.803]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.803]         }, condition = base::local({
[16:21:03.803]             c <- base::c
[16:21:03.803]             inherits <- base::inherits
[16:21:03.803]             invokeRestart <- base::invokeRestart
[16:21:03.803]             length <- base::length
[16:21:03.803]             list <- base::list
[16:21:03.803]             seq.int <- base::seq.int
[16:21:03.803]             signalCondition <- base::signalCondition
[16:21:03.803]             sys.calls <- base::sys.calls
[16:21:03.803]             `[[` <- base::`[[`
[16:21:03.803]             `+` <- base::`+`
[16:21:03.803]             `<<-` <- base::`<<-`
[16:21:03.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.803]                   3L)]
[16:21:03.803]             }
[16:21:03.803]             function(cond) {
[16:21:03.803]                 is_error <- inherits(cond, "error")
[16:21:03.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.803]                   NULL)
[16:21:03.803]                 if (is_error) {
[16:21:03.803]                   sessionInformation <- function() {
[16:21:03.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.803]                       search = base::search(), system = base::Sys.info())
[16:21:03.803]                   }
[16:21:03.803]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.803]                     cond$call), session = sessionInformation(), 
[16:21:03.803]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.803]                   signalCondition(cond)
[16:21:03.803]                 }
[16:21:03.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.803]                 "immediateCondition"))) {
[16:21:03.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.803]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.803]                   if (TRUE && !signal) {
[16:21:03.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.803]                     {
[16:21:03.803]                       inherits <- base::inherits
[16:21:03.803]                       invokeRestart <- base::invokeRestart
[16:21:03.803]                       is.null <- base::is.null
[16:21:03.803]                       muffled <- FALSE
[16:21:03.803]                       if (inherits(cond, "message")) {
[16:21:03.803]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.803]                         if (muffled) 
[16:21:03.803]                           invokeRestart("muffleMessage")
[16:21:03.803]                       }
[16:21:03.803]                       else if (inherits(cond, "warning")) {
[16:21:03.803]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.803]                         if (muffled) 
[16:21:03.803]                           invokeRestart("muffleWarning")
[16:21:03.803]                       }
[16:21:03.803]                       else if (inherits(cond, "condition")) {
[16:21:03.803]                         if (!is.null(pattern)) {
[16:21:03.803]                           computeRestarts <- base::computeRestarts
[16:21:03.803]                           grepl <- base::grepl
[16:21:03.803]                           restarts <- computeRestarts(cond)
[16:21:03.803]                           for (restart in restarts) {
[16:21:03.803]                             name <- restart$name
[16:21:03.803]                             if (is.null(name)) 
[16:21:03.803]                               next
[16:21:03.803]                             if (!grepl(pattern, name)) 
[16:21:03.803]                               next
[16:21:03.803]                             invokeRestart(restart)
[16:21:03.803]                             muffled <- TRUE
[16:21:03.803]                             break
[16:21:03.803]                           }
[16:21:03.803]                         }
[16:21:03.803]                       }
[16:21:03.803]                       invisible(muffled)
[16:21:03.803]                     }
[16:21:03.803]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.803]                   }
[16:21:03.803]                 }
[16:21:03.803]                 else {
[16:21:03.803]                   if (TRUE) {
[16:21:03.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.803]                     {
[16:21:03.803]                       inherits <- base::inherits
[16:21:03.803]                       invokeRestart <- base::invokeRestart
[16:21:03.803]                       is.null <- base::is.null
[16:21:03.803]                       muffled <- FALSE
[16:21:03.803]                       if (inherits(cond, "message")) {
[16:21:03.803]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.803]                         if (muffled) 
[16:21:03.803]                           invokeRestart("muffleMessage")
[16:21:03.803]                       }
[16:21:03.803]                       else if (inherits(cond, "warning")) {
[16:21:03.803]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.803]                         if (muffled) 
[16:21:03.803]                           invokeRestart("muffleWarning")
[16:21:03.803]                       }
[16:21:03.803]                       else if (inherits(cond, "condition")) {
[16:21:03.803]                         if (!is.null(pattern)) {
[16:21:03.803]                           computeRestarts <- base::computeRestarts
[16:21:03.803]                           grepl <- base::grepl
[16:21:03.803]                           restarts <- computeRestarts(cond)
[16:21:03.803]                           for (restart in restarts) {
[16:21:03.803]                             name <- restart$name
[16:21:03.803]                             if (is.null(name)) 
[16:21:03.803]                               next
[16:21:03.803]                             if (!grepl(pattern, name)) 
[16:21:03.803]                               next
[16:21:03.803]                             invokeRestart(restart)
[16:21:03.803]                             muffled <- TRUE
[16:21:03.803]                             break
[16:21:03.803]                           }
[16:21:03.803]                         }
[16:21:03.803]                       }
[16:21:03.803]                       invisible(muffled)
[16:21:03.803]                     }
[16:21:03.803]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.803]                   }
[16:21:03.803]                 }
[16:21:03.803]             }
[16:21:03.803]         }))
[16:21:03.803]     }, error = function(ex) {
[16:21:03.803]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.803]                 ...future.rng), started = ...future.startTime, 
[16:21:03.803]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.803]             version = "1.8"), class = "FutureResult")
[16:21:03.803]     }, finally = {
[16:21:03.803]         if (!identical(...future.workdir, getwd())) 
[16:21:03.803]             setwd(...future.workdir)
[16:21:03.803]         {
[16:21:03.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.803]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.803]             }
[16:21:03.803]             base::options(...future.oldOptions)
[16:21:03.803]             if (.Platform$OS.type == "windows") {
[16:21:03.803]                 old_names <- names(...future.oldEnvVars)
[16:21:03.803]                 envs <- base::Sys.getenv()
[16:21:03.803]                 names <- names(envs)
[16:21:03.803]                 common <- intersect(names, old_names)
[16:21:03.803]                 added <- setdiff(names, old_names)
[16:21:03.803]                 removed <- setdiff(old_names, names)
[16:21:03.803]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.803]                   envs[common]]
[16:21:03.803]                 NAMES <- toupper(changed)
[16:21:03.803]                 args <- list()
[16:21:03.803]                 for (kk in seq_along(NAMES)) {
[16:21:03.803]                   name <- changed[[kk]]
[16:21:03.803]                   NAME <- NAMES[[kk]]
[16:21:03.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.803]                     next
[16:21:03.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.803]                 }
[16:21:03.803]                 NAMES <- toupper(added)
[16:21:03.803]                 for (kk in seq_along(NAMES)) {
[16:21:03.803]                   name <- added[[kk]]
[16:21:03.803]                   NAME <- NAMES[[kk]]
[16:21:03.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.803]                     next
[16:21:03.803]                   args[[name]] <- ""
[16:21:03.803]                 }
[16:21:03.803]                 NAMES <- toupper(removed)
[16:21:03.803]                 for (kk in seq_along(NAMES)) {
[16:21:03.803]                   name <- removed[[kk]]
[16:21:03.803]                   NAME <- NAMES[[kk]]
[16:21:03.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.803]                     next
[16:21:03.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.803]                 }
[16:21:03.803]                 if (length(args) > 0) 
[16:21:03.803]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.803]             }
[16:21:03.803]             else {
[16:21:03.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.803]             }
[16:21:03.803]             {
[16:21:03.803]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.803]                   0L) {
[16:21:03.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.803]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.803]                   base::options(opts)
[16:21:03.803]                 }
[16:21:03.803]                 {
[16:21:03.803]                   {
[16:21:03.803]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:03.803]                     NULL
[16:21:03.803]                   }
[16:21:03.803]                   options(future.plan = NULL)
[16:21:03.803]                   if (is.na(NA_character_)) 
[16:21:03.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.803]                     .init = FALSE)
[16:21:03.803]                 }
[16:21:03.803]             }
[16:21:03.803]         }
[16:21:03.803]     })
[16:21:03.803]     if (TRUE) {
[16:21:03.803]         base::sink(type = "output", split = FALSE)
[16:21:03.803]         if (TRUE) {
[16:21:03.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.803]         }
[16:21:03.803]         else {
[16:21:03.803]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.803]         }
[16:21:03.803]         base::close(...future.stdout)
[16:21:03.803]         ...future.stdout <- NULL
[16:21:03.803]     }
[16:21:03.803]     ...future.result$conditions <- ...future.conditions
[16:21:03.803]     ...future.result$finished <- base::Sys.time()
[16:21:03.803]     ...future.result
[16:21:03.803] }
[16:21:03.806] requestCore(): workers = 2
[16:21:03.808] MulticoreFuture started
[16:21:03.808] - Launch lazy future ... done
[16:21:03.809] run() for ‘MulticoreFuture’ ... done
[16:21:03.809] result() for MulticoreFuture ...
[16:21:03.809] plan(): Setting new future strategy stack:
[16:21:03.809] List of future strategies:
[16:21:03.809] 1. sequential:
[16:21:03.809]    - args: function (..., envir = parent.frame())
[16:21:03.809]    - tweaked: FALSE
[16:21:03.809]    - call: NULL
[16:21:03.810] plan(): nbrOfWorkers() = 1
[16:21:03.812] plan(): Setting new future strategy stack:
[16:21:03.812] List of future strategies:
[16:21:03.812] 1. multicore:
[16:21:03.812]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:03.812]    - tweaked: FALSE
[16:21:03.812]    - call: plan(strategy)
[16:21:03.817] plan(): nbrOfWorkers() = 2
[16:21:03.823] result() for MulticoreFuture ...
[16:21:03.823] result() for MulticoreFuture ... done
[16:21:03.823] signalConditions() ...
[16:21:03.824]  - include = ‘immediateCondition’
[16:21:03.824]  - exclude = 
[16:21:03.824]  - resignal = FALSE
[16:21:03.824]  - Number of conditions: 1
[16:21:03.824] signalConditions() ... done
[16:21:03.824] result() for MulticoreFuture ... done
[16:21:03.824] result() for MulticoreFuture ...
[16:21:03.824] result() for MulticoreFuture ... done
[16:21:03.825] signalConditions() ...
[16:21:03.825]  - include = ‘immediateCondition’
[16:21:03.825]  - exclude = 
[16:21:03.825]  - resignal = FALSE
[16:21:03.825]  - Number of conditions: 1
[16:21:03.825] signalConditions() ... done
[16:21:03.825] Future state: ‘finished’
[16:21:03.825] result() for MulticoreFuture ...
[16:21:03.826] result() for MulticoreFuture ... done
[16:21:03.826] signalConditions() ...
[16:21:03.826]  - include = ‘condition’
[16:21:03.829]  - exclude = ‘immediateCondition’
[16:21:03.830]  - resignal = TRUE
[16:21:03.830]  - Number of conditions: 1
[16:21:03.830]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:21:03.830] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "b478068843b5" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:21:03"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.858] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.859] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.860] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.860] Searching for globals ... DONE
[16:21:03.860] Resolving globals: TRUE
[16:21:03.860] Resolving any globals that are futures ...
[16:21:03.861] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.861] Resolving any globals that are futures ... DONE
[16:21:03.861] Resolving futures part of globals (recursively) ...
[16:21:03.861] resolve() on list ...
[16:21:03.861]  recursive: 99
[16:21:03.861]  length: 1
[16:21:03.862]  elements: ‘ii’
[16:21:03.862]  length: 0 (resolved future 1)
[16:21:03.862] resolve() on list ... DONE
[16:21:03.862] - globals: [1] ‘ii’
[16:21:03.862] Resolving futures part of globals (recursively) ... DONE
[16:21:03.862] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.862] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.863] - globals: [1] ‘ii’
[16:21:03.863] 
[16:21:03.863] getGlobalsAndPackages() ... DONE
[16:21:03.863] run() for ‘Future’ ...
[16:21:03.863] - state: ‘created’
[16:21:03.863] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:03.868] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:03.868] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:03.868]   - Field: ‘label’
[16:21:03.868]   - Field: ‘local’
[16:21:03.868]   - Field: ‘owner’
[16:21:03.868]   - Field: ‘envir’
[16:21:03.868]   - Field: ‘workers’
[16:21:03.869]   - Field: ‘packages’
[16:21:03.869]   - Field: ‘gc’
[16:21:03.869]   - Field: ‘job’
[16:21:03.869]   - Field: ‘conditions’
[16:21:03.869]   - Field: ‘expr’
[16:21:03.869]   - Field: ‘uuid’
[16:21:03.869]   - Field: ‘seed’
[16:21:03.869]   - Field: ‘version’
[16:21:03.869]   - Field: ‘result’
[16:21:03.869]   - Field: ‘asynchronous’
[16:21:03.870]   - Field: ‘calls’
[16:21:03.870]   - Field: ‘globals’
[16:21:03.870]   - Field: ‘stdout’
[16:21:03.870]   - Field: ‘earlySignal’
[16:21:03.870]   - Field: ‘lazy’
[16:21:03.870]   - Field: ‘state’
[16:21:03.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:03.870] - Launch lazy future ...
[16:21:03.871] Packages needed by the future expression (n = 0): <none>
[16:21:03.871] Packages needed by future strategies (n = 0): <none>
[16:21:03.871] {
[16:21:03.871]     {
[16:21:03.871]         {
[16:21:03.871]             ...future.startTime <- base::Sys.time()
[16:21:03.871]             {
[16:21:03.871]                 {
[16:21:03.871]                   {
[16:21:03.871]                     {
[16:21:03.871]                       base::local({
[16:21:03.871]                         has_future <- base::requireNamespace("future", 
[16:21:03.871]                           quietly = TRUE)
[16:21:03.871]                         if (has_future) {
[16:21:03.871]                           ns <- base::getNamespace("future")
[16:21:03.871]                           version <- ns[[".package"]][["version"]]
[16:21:03.871]                           if (is.null(version)) 
[16:21:03.871]                             version <- utils::packageVersion("future")
[16:21:03.871]                         }
[16:21:03.871]                         else {
[16:21:03.871]                           version <- NULL
[16:21:03.871]                         }
[16:21:03.871]                         if (!has_future || version < "1.8.0") {
[16:21:03.871]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.871]                             "", base::R.version$version.string), 
[16:21:03.871]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.871]                               "release", "version")], collapse = " "), 
[16:21:03.871]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.871]                             info)
[16:21:03.871]                           info <- base::paste(info, collapse = "; ")
[16:21:03.871]                           if (!has_future) {
[16:21:03.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.871]                               info)
[16:21:03.871]                           }
[16:21:03.871]                           else {
[16:21:03.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.871]                               info, version)
[16:21:03.871]                           }
[16:21:03.871]                           base::stop(msg)
[16:21:03.871]                         }
[16:21:03.871]                       })
[16:21:03.871]                     }
[16:21:03.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:03.871]                     base::options(mc.cores = 1L)
[16:21:03.871]                   }
[16:21:03.871]                   ...future.strategy.old <- future::plan("list")
[16:21:03.871]                   options(future.plan = NULL)
[16:21:03.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.871]                 }
[16:21:03.871]                 ...future.workdir <- getwd()
[16:21:03.871]             }
[16:21:03.871]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.871]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.871]         }
[16:21:03.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.871]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.871]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.871]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.871]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.871]             base::names(...future.oldOptions))
[16:21:03.871]     }
[16:21:03.871]     if (FALSE) {
[16:21:03.871]     }
[16:21:03.871]     else {
[16:21:03.871]         if (TRUE) {
[16:21:03.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.871]                 open = "w")
[16:21:03.871]         }
[16:21:03.871]         else {
[16:21:03.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.871]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.871]         }
[16:21:03.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.871]             base::sink(type = "output", split = FALSE)
[16:21:03.871]             base::close(...future.stdout)
[16:21:03.871]         }, add = TRUE)
[16:21:03.871]     }
[16:21:03.871]     ...future.frame <- base::sys.nframe()
[16:21:03.871]     ...future.conditions <- base::list()
[16:21:03.871]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.871]     if (FALSE) {
[16:21:03.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.871]     }
[16:21:03.871]     ...future.result <- base::tryCatch({
[16:21:03.871]         base::withCallingHandlers({
[16:21:03.871]             ...future.value <- base::withVisible(base::local({
[16:21:03.871]                 withCallingHandlers({
[16:21:03.871]                   {
[16:21:03.871]                     b <- a * ii
[16:21:03.871]                     a <- 0
[16:21:03.871]                     b
[16:21:03.871]                   }
[16:21:03.871]                 }, immediateCondition = function(cond) {
[16:21:03.871]                   save_rds <- function (object, pathname, ...) 
[16:21:03.871]                   {
[16:21:03.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:03.871]                     if (file_test("-f", pathname_tmp)) {
[16:21:03.871]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:03.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.871]                         fi_tmp[["mtime"]])
[16:21:03.871]                     }
[16:21:03.871]                     tryCatch({
[16:21:03.871]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:03.871]                     }, error = function(ex) {
[16:21:03.871]                       msg <- conditionMessage(ex)
[16:21:03.871]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:03.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.871]                         fi_tmp[["mtime"]], msg)
[16:21:03.871]                       ex$message <- msg
[16:21:03.871]                       stop(ex)
[16:21:03.871]                     })
[16:21:03.871]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:03.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:03.871]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:03.871]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.871]                       fi <- file.info(pathname)
[16:21:03.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:03.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:03.871]                         fi[["size"]], fi[["mtime"]])
[16:21:03.871]                       stop(msg)
[16:21:03.871]                     }
[16:21:03.871]                     invisible(pathname)
[16:21:03.871]                   }
[16:21:03.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:03.871]                     rootPath = tempdir()) 
[16:21:03.871]                   {
[16:21:03.871]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:03.871]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:03.871]                       tmpdir = path, fileext = ".rds")
[16:21:03.871]                     save_rds(obj, file)
[16:21:03.871]                   }
[16:21:03.871]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:03.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.871]                   {
[16:21:03.871]                     inherits <- base::inherits
[16:21:03.871]                     invokeRestart <- base::invokeRestart
[16:21:03.871]                     is.null <- base::is.null
[16:21:03.871]                     muffled <- FALSE
[16:21:03.871]                     if (inherits(cond, "message")) {
[16:21:03.871]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:03.871]                       if (muffled) 
[16:21:03.871]                         invokeRestart("muffleMessage")
[16:21:03.871]                     }
[16:21:03.871]                     else if (inherits(cond, "warning")) {
[16:21:03.871]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:03.871]                       if (muffled) 
[16:21:03.871]                         invokeRestart("muffleWarning")
[16:21:03.871]                     }
[16:21:03.871]                     else if (inherits(cond, "condition")) {
[16:21:03.871]                       if (!is.null(pattern)) {
[16:21:03.871]                         computeRestarts <- base::computeRestarts
[16:21:03.871]                         grepl <- base::grepl
[16:21:03.871]                         restarts <- computeRestarts(cond)
[16:21:03.871]                         for (restart in restarts) {
[16:21:03.871]                           name <- restart$name
[16:21:03.871]                           if (is.null(name)) 
[16:21:03.871]                             next
[16:21:03.871]                           if (!grepl(pattern, name)) 
[16:21:03.871]                             next
[16:21:03.871]                           invokeRestart(restart)
[16:21:03.871]                           muffled <- TRUE
[16:21:03.871]                           break
[16:21:03.871]                         }
[16:21:03.871]                       }
[16:21:03.871]                     }
[16:21:03.871]                     invisible(muffled)
[16:21:03.871]                   }
[16:21:03.871]                   muffleCondition(cond)
[16:21:03.871]                 })
[16:21:03.871]             }))
[16:21:03.871]             future::FutureResult(value = ...future.value$value, 
[16:21:03.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.871]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.871]                     ...future.globalenv.names))
[16:21:03.871]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.871]         }, condition = base::local({
[16:21:03.871]             c <- base::c
[16:21:03.871]             inherits <- base::inherits
[16:21:03.871]             invokeRestart <- base::invokeRestart
[16:21:03.871]             length <- base::length
[16:21:03.871]             list <- base::list
[16:21:03.871]             seq.int <- base::seq.int
[16:21:03.871]             signalCondition <- base::signalCondition
[16:21:03.871]             sys.calls <- base::sys.calls
[16:21:03.871]             `[[` <- base::`[[`
[16:21:03.871]             `+` <- base::`+`
[16:21:03.871]             `<<-` <- base::`<<-`
[16:21:03.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.871]                   3L)]
[16:21:03.871]             }
[16:21:03.871]             function(cond) {
[16:21:03.871]                 is_error <- inherits(cond, "error")
[16:21:03.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.871]                   NULL)
[16:21:03.871]                 if (is_error) {
[16:21:03.871]                   sessionInformation <- function() {
[16:21:03.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.871]                       search = base::search(), system = base::Sys.info())
[16:21:03.871]                   }
[16:21:03.871]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.871]                     cond$call), session = sessionInformation(), 
[16:21:03.871]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.871]                   signalCondition(cond)
[16:21:03.871]                 }
[16:21:03.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.871]                 "immediateCondition"))) {
[16:21:03.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.871]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.871]                   if (TRUE && !signal) {
[16:21:03.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.871]                     {
[16:21:03.871]                       inherits <- base::inherits
[16:21:03.871]                       invokeRestart <- base::invokeRestart
[16:21:03.871]                       is.null <- base::is.null
[16:21:03.871]                       muffled <- FALSE
[16:21:03.871]                       if (inherits(cond, "message")) {
[16:21:03.871]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.871]                         if (muffled) 
[16:21:03.871]                           invokeRestart("muffleMessage")
[16:21:03.871]                       }
[16:21:03.871]                       else if (inherits(cond, "warning")) {
[16:21:03.871]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.871]                         if (muffled) 
[16:21:03.871]                           invokeRestart("muffleWarning")
[16:21:03.871]                       }
[16:21:03.871]                       else if (inherits(cond, "condition")) {
[16:21:03.871]                         if (!is.null(pattern)) {
[16:21:03.871]                           computeRestarts <- base::computeRestarts
[16:21:03.871]                           grepl <- base::grepl
[16:21:03.871]                           restarts <- computeRestarts(cond)
[16:21:03.871]                           for (restart in restarts) {
[16:21:03.871]                             name <- restart$name
[16:21:03.871]                             if (is.null(name)) 
[16:21:03.871]                               next
[16:21:03.871]                             if (!grepl(pattern, name)) 
[16:21:03.871]                               next
[16:21:03.871]                             invokeRestart(restart)
[16:21:03.871]                             muffled <- TRUE
[16:21:03.871]                             break
[16:21:03.871]                           }
[16:21:03.871]                         }
[16:21:03.871]                       }
[16:21:03.871]                       invisible(muffled)
[16:21:03.871]                     }
[16:21:03.871]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.871]                   }
[16:21:03.871]                 }
[16:21:03.871]                 else {
[16:21:03.871]                   if (TRUE) {
[16:21:03.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.871]                     {
[16:21:03.871]                       inherits <- base::inherits
[16:21:03.871]                       invokeRestart <- base::invokeRestart
[16:21:03.871]                       is.null <- base::is.null
[16:21:03.871]                       muffled <- FALSE
[16:21:03.871]                       if (inherits(cond, "message")) {
[16:21:03.871]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.871]                         if (muffled) 
[16:21:03.871]                           invokeRestart("muffleMessage")
[16:21:03.871]                       }
[16:21:03.871]                       else if (inherits(cond, "warning")) {
[16:21:03.871]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.871]                         if (muffled) 
[16:21:03.871]                           invokeRestart("muffleWarning")
[16:21:03.871]                       }
[16:21:03.871]                       else if (inherits(cond, "condition")) {
[16:21:03.871]                         if (!is.null(pattern)) {
[16:21:03.871]                           computeRestarts <- base::computeRestarts
[16:21:03.871]                           grepl <- base::grepl
[16:21:03.871]                           restarts <- computeRestarts(cond)
[16:21:03.871]                           for (restart in restarts) {
[16:21:03.871]                             name <- restart$name
[16:21:03.871]                             if (is.null(name)) 
[16:21:03.871]                               next
[16:21:03.871]                             if (!grepl(pattern, name)) 
[16:21:03.871]                               next
[16:21:03.871]                             invokeRestart(restart)
[16:21:03.871]                             muffled <- TRUE
[16:21:03.871]                             break
[16:21:03.871]                           }
[16:21:03.871]                         }
[16:21:03.871]                       }
[16:21:03.871]                       invisible(muffled)
[16:21:03.871]                     }
[16:21:03.871]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.871]                   }
[16:21:03.871]                 }
[16:21:03.871]             }
[16:21:03.871]         }))
[16:21:03.871]     }, error = function(ex) {
[16:21:03.871]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.871]                 ...future.rng), started = ...future.startTime, 
[16:21:03.871]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.871]             version = "1.8"), class = "FutureResult")
[16:21:03.871]     }, finally = {
[16:21:03.871]         if (!identical(...future.workdir, getwd())) 
[16:21:03.871]             setwd(...future.workdir)
[16:21:03.871]         {
[16:21:03.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.871]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.871]             }
[16:21:03.871]             base::options(...future.oldOptions)
[16:21:03.871]             if (.Platform$OS.type == "windows") {
[16:21:03.871]                 old_names <- names(...future.oldEnvVars)
[16:21:03.871]                 envs <- base::Sys.getenv()
[16:21:03.871]                 names <- names(envs)
[16:21:03.871]                 common <- intersect(names, old_names)
[16:21:03.871]                 added <- setdiff(names, old_names)
[16:21:03.871]                 removed <- setdiff(old_names, names)
[16:21:03.871]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.871]                   envs[common]]
[16:21:03.871]                 NAMES <- toupper(changed)
[16:21:03.871]                 args <- list()
[16:21:03.871]                 for (kk in seq_along(NAMES)) {
[16:21:03.871]                   name <- changed[[kk]]
[16:21:03.871]                   NAME <- NAMES[[kk]]
[16:21:03.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.871]                     next
[16:21:03.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.871]                 }
[16:21:03.871]                 NAMES <- toupper(added)
[16:21:03.871]                 for (kk in seq_along(NAMES)) {
[16:21:03.871]                   name <- added[[kk]]
[16:21:03.871]                   NAME <- NAMES[[kk]]
[16:21:03.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.871]                     next
[16:21:03.871]                   args[[name]] <- ""
[16:21:03.871]                 }
[16:21:03.871]                 NAMES <- toupper(removed)
[16:21:03.871]                 for (kk in seq_along(NAMES)) {
[16:21:03.871]                   name <- removed[[kk]]
[16:21:03.871]                   NAME <- NAMES[[kk]]
[16:21:03.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.871]                     next
[16:21:03.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.871]                 }
[16:21:03.871]                 if (length(args) > 0) 
[16:21:03.871]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.871]             }
[16:21:03.871]             else {
[16:21:03.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.871]             }
[16:21:03.871]             {
[16:21:03.871]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.871]                   0L) {
[16:21:03.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.871]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.871]                   base::options(opts)
[16:21:03.871]                 }
[16:21:03.871]                 {
[16:21:03.871]                   {
[16:21:03.871]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:03.871]                     NULL
[16:21:03.871]                   }
[16:21:03.871]                   options(future.plan = NULL)
[16:21:03.871]                   if (is.na(NA_character_)) 
[16:21:03.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.871]                     .init = FALSE)
[16:21:03.871]                 }
[16:21:03.871]             }
[16:21:03.871]         }
[16:21:03.871]     })
[16:21:03.871]     if (TRUE) {
[16:21:03.871]         base::sink(type = "output", split = FALSE)
[16:21:03.871]         if (TRUE) {
[16:21:03.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.871]         }
[16:21:03.871]         else {
[16:21:03.871]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.871]         }
[16:21:03.871]         base::close(...future.stdout)
[16:21:03.871]         ...future.stdout <- NULL
[16:21:03.871]     }
[16:21:03.871]     ...future.result$conditions <- ...future.conditions
[16:21:03.871]     ...future.result$finished <- base::Sys.time()
[16:21:03.871]     ...future.result
[16:21:03.871] }
[16:21:03.873] assign_globals() ...
[16:21:03.874] List of 1
[16:21:03.874]  $ ii: int 1
[16:21:03.874]  - attr(*, "where")=List of 1
[16:21:03.874]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.874]  - attr(*, "resolved")= logi TRUE
[16:21:03.874]  - attr(*, "total_size")= num 56
[16:21:03.874]  - attr(*, "already-done")= logi TRUE
[16:21:03.876] - copied ‘ii’ to environment
[16:21:03.876] assign_globals() ... done
[16:21:03.876] requestCore(): workers = 2
[16:21:03.879] MulticoreFuture started
[16:21:03.879] - Launch lazy future ... done
[16:21:03.879] run() for ‘MulticoreFuture’ ... done
[16:21:03.880] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.880] getGlobalsAndPackages() ...
[16:21:03.880] List of future strategies:
[16:21:03.880] 1. sequential:
[16:21:03.880]    - args: function (..., envir = parent.frame())
[16:21:03.880]    - tweaked: FALSE
[16:21:03.880]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.881] plan(): nbrOfWorkers() = 1
[16:21:03.881] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.883] plan(): Setting new future strategy stack:
[16:21:03.883] List of future strategies:
[16:21:03.883] 1. multicore:
[16:21:03.883]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:03.883]    - tweaked: FALSE
[16:21:03.883]    - call: plan(strategy)
[16:21:03.883] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.884] Searching for globals ... DONE
[16:21:03.884] Resolving globals: TRUE
[16:21:03.884] Resolving any globals that are futures ...
[16:21:03.884] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.884] Resolving any globals that are futures ... DONE
[16:21:03.885] Resolving futures part of globals (recursively) ...
[16:21:03.886] resolve() on list ...
[16:21:03.886]  recursive: 99
[16:21:03.886]  length: 1
[16:21:03.886]  elements: ‘ii’
[16:21:03.886]  length: 0 (resolved future 1)
[16:21:03.887] resolve() on list ... DONE
[16:21:03.887] - globals: [1] ‘ii’
[16:21:03.887] Resolving futures part of globals (recursively) ... DONE
[16:21:03.888] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.889] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.889] plan(): nbrOfWorkers() = 2
[16:21:03.889] - globals: [1] ‘ii’
[16:21:03.889] 
[16:21:03.889] getGlobalsAndPackages() ... DONE
[16:21:03.893] run() for ‘Future’ ...
[16:21:03.893] - state: ‘created’
[16:21:03.894] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:03.900] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:03.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:03.901]   - Field: ‘label’
[16:21:03.901]   - Field: ‘local’
[16:21:03.901]   - Field: ‘owner’
[16:21:03.901]   - Field: ‘envir’
[16:21:03.902]   - Field: ‘workers’
[16:21:03.902]   - Field: ‘packages’
[16:21:03.902]   - Field: ‘gc’
[16:21:03.902]   - Field: ‘job’
[16:21:03.902]   - Field: ‘conditions’
[16:21:03.903]   - Field: ‘expr’
[16:21:03.903]   - Field: ‘uuid’
[16:21:03.903]   - Field: ‘seed’
[16:21:03.903]   - Field: ‘version’
[16:21:03.903]   - Field: ‘result’
[16:21:03.903]   - Field: ‘asynchronous’
[16:21:03.903]   - Field: ‘calls’
[16:21:03.904]   - Field: ‘globals’
[16:21:03.904]   - Field: ‘stdout’
[16:21:03.904]   - Field: ‘earlySignal’
[16:21:03.904]   - Field: ‘lazy’
[16:21:03.905]   - Field: ‘state’
[16:21:03.905] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:03.905] - Launch lazy future ...
[16:21:03.906] Packages needed by the future expression (n = 0): <none>
[16:21:03.906] Packages needed by future strategies (n = 0): <none>
[16:21:03.907] {
[16:21:03.907]     {
[16:21:03.907]         {
[16:21:03.907]             ...future.startTime <- base::Sys.time()
[16:21:03.907]             {
[16:21:03.907]                 {
[16:21:03.907]                   {
[16:21:03.907]                     {
[16:21:03.907]                       base::local({
[16:21:03.907]                         has_future <- base::requireNamespace("future", 
[16:21:03.907]                           quietly = TRUE)
[16:21:03.907]                         if (has_future) {
[16:21:03.907]                           ns <- base::getNamespace("future")
[16:21:03.907]                           version <- ns[[".package"]][["version"]]
[16:21:03.907]                           if (is.null(version)) 
[16:21:03.907]                             version <- utils::packageVersion("future")
[16:21:03.907]                         }
[16:21:03.907]                         else {
[16:21:03.907]                           version <- NULL
[16:21:03.907]                         }
[16:21:03.907]                         if (!has_future || version < "1.8.0") {
[16:21:03.907]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.907]                             "", base::R.version$version.string), 
[16:21:03.907]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.907]                               "release", "version")], collapse = " "), 
[16:21:03.907]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.907]                             info)
[16:21:03.907]                           info <- base::paste(info, collapse = "; ")
[16:21:03.907]                           if (!has_future) {
[16:21:03.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.907]                               info)
[16:21:03.907]                           }
[16:21:03.907]                           else {
[16:21:03.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.907]                               info, version)
[16:21:03.907]                           }
[16:21:03.907]                           base::stop(msg)
[16:21:03.907]                         }
[16:21:03.907]                       })
[16:21:03.907]                     }
[16:21:03.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:03.907]                     base::options(mc.cores = 1L)
[16:21:03.907]                   }
[16:21:03.907]                   ...future.strategy.old <- future::plan("list")
[16:21:03.907]                   options(future.plan = NULL)
[16:21:03.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.907]                 }
[16:21:03.907]                 ...future.workdir <- getwd()
[16:21:03.907]             }
[16:21:03.907]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.907]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.907]         }
[16:21:03.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.907]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.907]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.907]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.907]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.907]             base::names(...future.oldOptions))
[16:21:03.907]     }
[16:21:03.907]     if (FALSE) {
[16:21:03.907]     }
[16:21:03.907]     else {
[16:21:03.907]         if (TRUE) {
[16:21:03.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.907]                 open = "w")
[16:21:03.907]         }
[16:21:03.907]         else {
[16:21:03.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.907]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.907]         }
[16:21:03.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.907]             base::sink(type = "output", split = FALSE)
[16:21:03.907]             base::close(...future.stdout)
[16:21:03.907]         }, add = TRUE)
[16:21:03.907]     }
[16:21:03.907]     ...future.frame <- base::sys.nframe()
[16:21:03.907]     ...future.conditions <- base::list()
[16:21:03.907]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.907]     if (FALSE) {
[16:21:03.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.907]     }
[16:21:03.907]     ...future.result <- base::tryCatch({
[16:21:03.907]         base::withCallingHandlers({
[16:21:03.907]             ...future.value <- base::withVisible(base::local({
[16:21:03.907]                 withCallingHandlers({
[16:21:03.907]                   {
[16:21:03.907]                     b <- a * ii
[16:21:03.907]                     a <- 0
[16:21:03.907]                     b
[16:21:03.907]                   }
[16:21:03.907]                 }, immediateCondition = function(cond) {
[16:21:03.907]                   save_rds <- function (object, pathname, ...) 
[16:21:03.907]                   {
[16:21:03.907]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:03.907]                     if (file_test("-f", pathname_tmp)) {
[16:21:03.907]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.907]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:03.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.907]                         fi_tmp[["mtime"]])
[16:21:03.907]                     }
[16:21:03.907]                     tryCatch({
[16:21:03.907]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:03.907]                     }, error = function(ex) {
[16:21:03.907]                       msg <- conditionMessage(ex)
[16:21:03.907]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.907]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:03.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.907]                         fi_tmp[["mtime"]], msg)
[16:21:03.907]                       ex$message <- msg
[16:21:03.907]                       stop(ex)
[16:21:03.907]                     })
[16:21:03.907]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:03.907]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:03.907]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:03.907]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.907]                       fi <- file.info(pathname)
[16:21:03.907]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:03.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.907]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:03.907]                         fi[["size"]], fi[["mtime"]])
[16:21:03.907]                       stop(msg)
[16:21:03.907]                     }
[16:21:03.907]                     invisible(pathname)
[16:21:03.907]                   }
[16:21:03.907]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:03.907]                     rootPath = tempdir()) 
[16:21:03.907]                   {
[16:21:03.907]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:03.907]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:03.907]                       tmpdir = path, fileext = ".rds")
[16:21:03.907]                     save_rds(obj, file)
[16:21:03.907]                   }
[16:21:03.907]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:03.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.907]                   {
[16:21:03.907]                     inherits <- base::inherits
[16:21:03.907]                     invokeRestart <- base::invokeRestart
[16:21:03.907]                     is.null <- base::is.null
[16:21:03.907]                     muffled <- FALSE
[16:21:03.907]                     if (inherits(cond, "message")) {
[16:21:03.907]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:03.907]                       if (muffled) 
[16:21:03.907]                         invokeRestart("muffleMessage")
[16:21:03.907]                     }
[16:21:03.907]                     else if (inherits(cond, "warning")) {
[16:21:03.907]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:03.907]                       if (muffled) 
[16:21:03.907]                         invokeRestart("muffleWarning")
[16:21:03.907]                     }
[16:21:03.907]                     else if (inherits(cond, "condition")) {
[16:21:03.907]                       if (!is.null(pattern)) {
[16:21:03.907]                         computeRestarts <- base::computeRestarts
[16:21:03.907]                         grepl <- base::grepl
[16:21:03.907]                         restarts <- computeRestarts(cond)
[16:21:03.907]                         for (restart in restarts) {
[16:21:03.907]                           name <- restart$name
[16:21:03.907]                           if (is.null(name)) 
[16:21:03.907]                             next
[16:21:03.907]                           if (!grepl(pattern, name)) 
[16:21:03.907]                             next
[16:21:03.907]                           invokeRestart(restart)
[16:21:03.907]                           muffled <- TRUE
[16:21:03.907]                           break
[16:21:03.907]                         }
[16:21:03.907]                       }
[16:21:03.907]                     }
[16:21:03.907]                     invisible(muffled)
[16:21:03.907]                   }
[16:21:03.907]                   muffleCondition(cond)
[16:21:03.907]                 })
[16:21:03.907]             }))
[16:21:03.907]             future::FutureResult(value = ...future.value$value, 
[16:21:03.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.907]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.907]                     ...future.globalenv.names))
[16:21:03.907]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.907]         }, condition = base::local({
[16:21:03.907]             c <- base::c
[16:21:03.907]             inherits <- base::inherits
[16:21:03.907]             invokeRestart <- base::invokeRestart
[16:21:03.907]             length <- base::length
[16:21:03.907]             list <- base::list
[16:21:03.907]             seq.int <- base::seq.int
[16:21:03.907]             signalCondition <- base::signalCondition
[16:21:03.907]             sys.calls <- base::sys.calls
[16:21:03.907]             `[[` <- base::`[[`
[16:21:03.907]             `+` <- base::`+`
[16:21:03.907]             `<<-` <- base::`<<-`
[16:21:03.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.907]                   3L)]
[16:21:03.907]             }
[16:21:03.907]             function(cond) {
[16:21:03.907]                 is_error <- inherits(cond, "error")
[16:21:03.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.907]                   NULL)
[16:21:03.907]                 if (is_error) {
[16:21:03.907]                   sessionInformation <- function() {
[16:21:03.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.907]                       search = base::search(), system = base::Sys.info())
[16:21:03.907]                   }
[16:21:03.907]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.907]                     cond$call), session = sessionInformation(), 
[16:21:03.907]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.907]                   signalCondition(cond)
[16:21:03.907]                 }
[16:21:03.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.907]                 "immediateCondition"))) {
[16:21:03.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.907]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.907]                   if (TRUE && !signal) {
[16:21:03.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.907]                     {
[16:21:03.907]                       inherits <- base::inherits
[16:21:03.907]                       invokeRestart <- base::invokeRestart
[16:21:03.907]                       is.null <- base::is.null
[16:21:03.907]                       muffled <- FALSE
[16:21:03.907]                       if (inherits(cond, "message")) {
[16:21:03.907]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.907]                         if (muffled) 
[16:21:03.907]                           invokeRestart("muffleMessage")
[16:21:03.907]                       }
[16:21:03.907]                       else if (inherits(cond, "warning")) {
[16:21:03.907]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.907]                         if (muffled) 
[16:21:03.907]                           invokeRestart("muffleWarning")
[16:21:03.907]                       }
[16:21:03.907]                       else if (inherits(cond, "condition")) {
[16:21:03.907]                         if (!is.null(pattern)) {
[16:21:03.907]                           computeRestarts <- base::computeRestarts
[16:21:03.907]                           grepl <- base::grepl
[16:21:03.907]                           restarts <- computeRestarts(cond)
[16:21:03.907]                           for (restart in restarts) {
[16:21:03.907]                             name <- restart$name
[16:21:03.907]                             if (is.null(name)) 
[16:21:03.907]                               next
[16:21:03.907]                             if (!grepl(pattern, name)) 
[16:21:03.907]                               next
[16:21:03.907]                             invokeRestart(restart)
[16:21:03.907]                             muffled <- TRUE
[16:21:03.907]                             break
[16:21:03.907]                           }
[16:21:03.907]                         }
[16:21:03.907]                       }
[16:21:03.907]                       invisible(muffled)
[16:21:03.907]                     }
[16:21:03.907]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.907]                   }
[16:21:03.907]                 }
[16:21:03.907]                 else {
[16:21:03.907]                   if (TRUE) {
[16:21:03.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.907]                     {
[16:21:03.907]                       inherits <- base::inherits
[16:21:03.907]                       invokeRestart <- base::invokeRestart
[16:21:03.907]                       is.null <- base::is.null
[16:21:03.907]                       muffled <- FALSE
[16:21:03.907]                       if (inherits(cond, "message")) {
[16:21:03.907]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.907]                         if (muffled) 
[16:21:03.907]                           invokeRestart("muffleMessage")
[16:21:03.907]                       }
[16:21:03.907]                       else if (inherits(cond, "warning")) {
[16:21:03.907]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.907]                         if (muffled) 
[16:21:03.907]                           invokeRestart("muffleWarning")
[16:21:03.907]                       }
[16:21:03.907]                       else if (inherits(cond, "condition")) {
[16:21:03.907]                         if (!is.null(pattern)) {
[16:21:03.907]                           computeRestarts <- base::computeRestarts
[16:21:03.907]                           grepl <- base::grepl
[16:21:03.907]                           restarts <- computeRestarts(cond)
[16:21:03.907]                           for (restart in restarts) {
[16:21:03.907]                             name <- restart$name
[16:21:03.907]                             if (is.null(name)) 
[16:21:03.907]                               next
[16:21:03.907]                             if (!grepl(pattern, name)) 
[16:21:03.907]                               next
[16:21:03.907]                             invokeRestart(restart)
[16:21:03.907]                             muffled <- TRUE
[16:21:03.907]                             break
[16:21:03.907]                           }
[16:21:03.907]                         }
[16:21:03.907]                       }
[16:21:03.907]                       invisible(muffled)
[16:21:03.907]                     }
[16:21:03.907]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.907]                   }
[16:21:03.907]                 }
[16:21:03.907]             }
[16:21:03.907]         }))
[16:21:03.907]     }, error = function(ex) {
[16:21:03.907]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.907]                 ...future.rng), started = ...future.startTime, 
[16:21:03.907]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.907]             version = "1.8"), class = "FutureResult")
[16:21:03.907]     }, finally = {
[16:21:03.907]         if (!identical(...future.workdir, getwd())) 
[16:21:03.907]             setwd(...future.workdir)
[16:21:03.907]         {
[16:21:03.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.907]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.907]             }
[16:21:03.907]             base::options(...future.oldOptions)
[16:21:03.907]             if (.Platform$OS.type == "windows") {
[16:21:03.907]                 old_names <- names(...future.oldEnvVars)
[16:21:03.907]                 envs <- base::Sys.getenv()
[16:21:03.907]                 names <- names(envs)
[16:21:03.907]                 common <- intersect(names, old_names)
[16:21:03.907]                 added <- setdiff(names, old_names)
[16:21:03.907]                 removed <- setdiff(old_names, names)
[16:21:03.907]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.907]                   envs[common]]
[16:21:03.907]                 NAMES <- toupper(changed)
[16:21:03.907]                 args <- list()
[16:21:03.907]                 for (kk in seq_along(NAMES)) {
[16:21:03.907]                   name <- changed[[kk]]
[16:21:03.907]                   NAME <- NAMES[[kk]]
[16:21:03.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.907]                     next
[16:21:03.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.907]                 }
[16:21:03.907]                 NAMES <- toupper(added)
[16:21:03.907]                 for (kk in seq_along(NAMES)) {
[16:21:03.907]                   name <- added[[kk]]
[16:21:03.907]                   NAME <- NAMES[[kk]]
[16:21:03.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.907]                     next
[16:21:03.907]                   args[[name]] <- ""
[16:21:03.907]                 }
[16:21:03.907]                 NAMES <- toupper(removed)
[16:21:03.907]                 for (kk in seq_along(NAMES)) {
[16:21:03.907]                   name <- removed[[kk]]
[16:21:03.907]                   NAME <- NAMES[[kk]]
[16:21:03.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.907]                     next
[16:21:03.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.907]                 }
[16:21:03.907]                 if (length(args) > 0) 
[16:21:03.907]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.907]             }
[16:21:03.907]             else {
[16:21:03.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.907]             }
[16:21:03.907]             {
[16:21:03.907]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.907]                   0L) {
[16:21:03.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.907]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.907]                   base::options(opts)
[16:21:03.907]                 }
[16:21:03.907]                 {
[16:21:03.907]                   {
[16:21:03.907]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:03.907]                     NULL
[16:21:03.907]                   }
[16:21:03.907]                   options(future.plan = NULL)
[16:21:03.907]                   if (is.na(NA_character_)) 
[16:21:03.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.907]                     .init = FALSE)
[16:21:03.907]                 }
[16:21:03.907]             }
[16:21:03.907]         }
[16:21:03.907]     })
[16:21:03.907]     if (TRUE) {
[16:21:03.907]         base::sink(type = "output", split = FALSE)
[16:21:03.907]         if (TRUE) {
[16:21:03.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.907]         }
[16:21:03.907]         else {
[16:21:03.907]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.907]         }
[16:21:03.907]         base::close(...future.stdout)
[16:21:03.907]         ...future.stdout <- NULL
[16:21:03.907]     }
[16:21:03.907]     ...future.result$conditions <- ...future.conditions
[16:21:03.907]     ...future.result$finished <- base::Sys.time()
[16:21:03.907]     ...future.result
[16:21:03.907] }
[16:21:03.909] assign_globals() ...
[16:21:03.909] List of 1
[16:21:03.909]  $ ii: int 2
[16:21:03.909]  - attr(*, "where")=List of 1
[16:21:03.909]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.909]  - attr(*, "resolved")= logi TRUE
[16:21:03.909]  - attr(*, "total_size")= num 56
[16:21:03.909]  - attr(*, "already-done")= logi TRUE
[16:21:03.913] - copied ‘ii’ to environment
[16:21:03.913] assign_globals() ... done
[16:21:03.914] requestCore(): workers = 2
[16:21:03.916] MulticoreFuture started
[16:21:03.916] - Launch lazy future ... done
[16:21:03.916] run() for ‘MulticoreFuture’ ... done
[16:21:03.917] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.918] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.917] List of future strategies:
[16:21:03.917] 1. sequential:
[16:21:03.917]    - args: function (..., envir = parent.frame())
[16:21:03.917]    - tweaked: FALSE
[16:21:03.917]    - call: NULL
[16:21:03.918] Searching for globals...
[16:21:03.918] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.921] plan(): Setting new future strategy stack:
[16:21:03.921] List of future strategies:
[16:21:03.921] 1. multicore:
[16:21:03.921]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:03.921]    - tweaked: FALSE
[16:21:03.921]    - call: plan(strategy)
[16:21:03.921] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.921] Searching for globals ... DONE
[16:21:03.921] Resolving globals: TRUE
[16:21:03.922] Resolving any globals that are futures ...
[16:21:03.922] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.922] Resolving any globals that are futures ... DONE
[16:21:03.923] Resolving futures part of globals (recursively) ...
[16:21:03.923] resolve() on list ...
[16:21:03.923]  recursive: 99
[16:21:03.924]  length: 1
[16:21:03.924]  elements: ‘ii’
[16:21:03.924]  length: 0 (resolved future 1)
[16:21:03.924] resolve() on list ... DONE
[16:21:03.924] - globals: [1] ‘ii’
[16:21:03.924] Resolving futures part of globals (recursively) ... DONE
[16:21:03.925] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.925] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.925] - globals: [1] ‘ii’
[16:21:03.926] 
[16:21:03.926] getGlobalsAndPackages() ... DONE
[16:21:03.926] plan(): nbrOfWorkers() = 2
[16:21:03.926] run() for ‘Future’ ...
[16:21:03.926] - state: ‘created’
[16:21:03.927] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:03.931] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:03.932] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:03.932]   - Field: ‘label’
[16:21:03.932]   - Field: ‘local’
[16:21:03.932]   - Field: ‘owner’
[16:21:03.932]   - Field: ‘envir’
[16:21:03.932]   - Field: ‘workers’
[16:21:03.932]   - Field: ‘packages’
[16:21:03.933]   - Field: ‘gc’
[16:21:03.933]   - Field: ‘job’
[16:21:03.933]   - Field: ‘conditions’
[16:21:03.933]   - Field: ‘expr’
[16:21:03.933]   - Field: ‘uuid’
[16:21:03.933]   - Field: ‘seed’
[16:21:03.933]   - Field: ‘version’
[16:21:03.934]   - Field: ‘result’
[16:21:03.934]   - Field: ‘asynchronous’
[16:21:03.934]   - Field: ‘calls’
[16:21:03.934]   - Field: ‘globals’
[16:21:03.934]   - Field: ‘stdout’
[16:21:03.934]   - Field: ‘earlySignal’
[16:21:03.934]   - Field: ‘lazy’
[16:21:03.935]   - Field: ‘state’
[16:21:03.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:03.935] - Launch lazy future ...
[16:21:03.935] Packages needed by the future expression (n = 0): <none>
[16:21:03.936] Packages needed by future strategies (n = 0): <none>
[16:21:03.936] {
[16:21:03.936]     {
[16:21:03.936]         {
[16:21:03.936]             ...future.startTime <- base::Sys.time()
[16:21:03.936]             {
[16:21:03.936]                 {
[16:21:03.936]                   {
[16:21:03.936]                     {
[16:21:03.936]                       base::local({
[16:21:03.936]                         has_future <- base::requireNamespace("future", 
[16:21:03.936]                           quietly = TRUE)
[16:21:03.936]                         if (has_future) {
[16:21:03.936]                           ns <- base::getNamespace("future")
[16:21:03.936]                           version <- ns[[".package"]][["version"]]
[16:21:03.936]                           if (is.null(version)) 
[16:21:03.936]                             version <- utils::packageVersion("future")
[16:21:03.936]                         }
[16:21:03.936]                         else {
[16:21:03.936]                           version <- NULL
[16:21:03.936]                         }
[16:21:03.936]                         if (!has_future || version < "1.8.0") {
[16:21:03.936]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:03.936]                             "", base::R.version$version.string), 
[16:21:03.936]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:03.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:03.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:03.936]                               "release", "version")], collapse = " "), 
[16:21:03.936]                             hostname = base::Sys.info()[["nodename"]])
[16:21:03.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:03.936]                             info)
[16:21:03.936]                           info <- base::paste(info, collapse = "; ")
[16:21:03.936]                           if (!has_future) {
[16:21:03.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:03.936]                               info)
[16:21:03.936]                           }
[16:21:03.936]                           else {
[16:21:03.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:03.936]                               info, version)
[16:21:03.936]                           }
[16:21:03.936]                           base::stop(msg)
[16:21:03.936]                         }
[16:21:03.936]                       })
[16:21:03.936]                     }
[16:21:03.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:03.936]                     base::options(mc.cores = 1L)
[16:21:03.936]                   }
[16:21:03.936]                   ...future.strategy.old <- future::plan("list")
[16:21:03.936]                   options(future.plan = NULL)
[16:21:03.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:03.936]                 }
[16:21:03.936]                 ...future.workdir <- getwd()
[16:21:03.936]             }
[16:21:03.936]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:03.936]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:03.936]         }
[16:21:03.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:03.936]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:03.936]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:03.936]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:03.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:03.936]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:03.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:03.936]             base::names(...future.oldOptions))
[16:21:03.936]     }
[16:21:03.936]     if (FALSE) {
[16:21:03.936]     }
[16:21:03.936]     else {
[16:21:03.936]         if (TRUE) {
[16:21:03.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:03.936]                 open = "w")
[16:21:03.936]         }
[16:21:03.936]         else {
[16:21:03.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:03.936]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:03.936]         }
[16:21:03.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:03.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:03.936]             base::sink(type = "output", split = FALSE)
[16:21:03.936]             base::close(...future.stdout)
[16:21:03.936]         }, add = TRUE)
[16:21:03.936]     }
[16:21:03.936]     ...future.frame <- base::sys.nframe()
[16:21:03.936]     ...future.conditions <- base::list()
[16:21:03.936]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:03.936]     if (FALSE) {
[16:21:03.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:03.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:03.936]     }
[16:21:03.936]     ...future.result <- base::tryCatch({
[16:21:03.936]         base::withCallingHandlers({
[16:21:03.936]             ...future.value <- base::withVisible(base::local({
[16:21:03.936]                 withCallingHandlers({
[16:21:03.936]                   {
[16:21:03.936]                     b <- a * ii
[16:21:03.936]                     a <- 0
[16:21:03.936]                     b
[16:21:03.936]                   }
[16:21:03.936]                 }, immediateCondition = function(cond) {
[16:21:03.936]                   save_rds <- function (object, pathname, ...) 
[16:21:03.936]                   {
[16:21:03.936]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:03.936]                     if (file_test("-f", pathname_tmp)) {
[16:21:03.936]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.936]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:03.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.936]                         fi_tmp[["mtime"]])
[16:21:03.936]                     }
[16:21:03.936]                     tryCatch({
[16:21:03.936]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:03.936]                     }, error = function(ex) {
[16:21:03.936]                       msg <- conditionMessage(ex)
[16:21:03.936]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.936]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:03.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.936]                         fi_tmp[["mtime"]], msg)
[16:21:03.936]                       ex$message <- msg
[16:21:03.936]                       stop(ex)
[16:21:03.936]                     })
[16:21:03.936]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:03.936]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:03.936]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:03.936]                       fi_tmp <- file.info(pathname_tmp)
[16:21:03.936]                       fi <- file.info(pathname)
[16:21:03.936]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:03.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:03.936]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:03.936]                         fi[["size"]], fi[["mtime"]])
[16:21:03.936]                       stop(msg)
[16:21:03.936]                     }
[16:21:03.936]                     invisible(pathname)
[16:21:03.936]                   }
[16:21:03.936]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:03.936]                     rootPath = tempdir()) 
[16:21:03.936]                   {
[16:21:03.936]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:03.936]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:03.936]                       tmpdir = path, fileext = ".rds")
[16:21:03.936]                     save_rds(obj, file)
[16:21:03.936]                   }
[16:21:03.936]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:03.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.936]                   {
[16:21:03.936]                     inherits <- base::inherits
[16:21:03.936]                     invokeRestart <- base::invokeRestart
[16:21:03.936]                     is.null <- base::is.null
[16:21:03.936]                     muffled <- FALSE
[16:21:03.936]                     if (inherits(cond, "message")) {
[16:21:03.936]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:03.936]                       if (muffled) 
[16:21:03.936]                         invokeRestart("muffleMessage")
[16:21:03.936]                     }
[16:21:03.936]                     else if (inherits(cond, "warning")) {
[16:21:03.936]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:03.936]                       if (muffled) 
[16:21:03.936]                         invokeRestart("muffleWarning")
[16:21:03.936]                     }
[16:21:03.936]                     else if (inherits(cond, "condition")) {
[16:21:03.936]                       if (!is.null(pattern)) {
[16:21:03.936]                         computeRestarts <- base::computeRestarts
[16:21:03.936]                         grepl <- base::grepl
[16:21:03.936]                         restarts <- computeRestarts(cond)
[16:21:03.936]                         for (restart in restarts) {
[16:21:03.936]                           name <- restart$name
[16:21:03.936]                           if (is.null(name)) 
[16:21:03.936]                             next
[16:21:03.936]                           if (!grepl(pattern, name)) 
[16:21:03.936]                             next
[16:21:03.936]                           invokeRestart(restart)
[16:21:03.936]                           muffled <- TRUE
[16:21:03.936]                           break
[16:21:03.936]                         }
[16:21:03.936]                       }
[16:21:03.936]                     }
[16:21:03.936]                     invisible(muffled)
[16:21:03.936]                   }
[16:21:03.936]                   muffleCondition(cond)
[16:21:03.936]                 })
[16:21:03.936]             }))
[16:21:03.936]             future::FutureResult(value = ...future.value$value, 
[16:21:03.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.936]                   ...future.rng), globalenv = if (FALSE) 
[16:21:03.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:03.936]                     ...future.globalenv.names))
[16:21:03.936]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:03.936]         }, condition = base::local({
[16:21:03.936]             c <- base::c
[16:21:03.936]             inherits <- base::inherits
[16:21:03.936]             invokeRestart <- base::invokeRestart
[16:21:03.936]             length <- base::length
[16:21:03.936]             list <- base::list
[16:21:03.936]             seq.int <- base::seq.int
[16:21:03.936]             signalCondition <- base::signalCondition
[16:21:03.936]             sys.calls <- base::sys.calls
[16:21:03.936]             `[[` <- base::`[[`
[16:21:03.936]             `+` <- base::`+`
[16:21:03.936]             `<<-` <- base::`<<-`
[16:21:03.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:03.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:03.936]                   3L)]
[16:21:03.936]             }
[16:21:03.936]             function(cond) {
[16:21:03.936]                 is_error <- inherits(cond, "error")
[16:21:03.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:03.936]                   NULL)
[16:21:03.936]                 if (is_error) {
[16:21:03.936]                   sessionInformation <- function() {
[16:21:03.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:03.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:03.936]                       search = base::search(), system = base::Sys.info())
[16:21:03.936]                   }
[16:21:03.936]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:03.936]                     cond$call), session = sessionInformation(), 
[16:21:03.936]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:03.936]                   signalCondition(cond)
[16:21:03.936]                 }
[16:21:03.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:03.936]                 "immediateCondition"))) {
[16:21:03.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:03.936]                   ...future.conditions[[length(...future.conditions) + 
[16:21:03.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:03.936]                   if (TRUE && !signal) {
[16:21:03.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.936]                     {
[16:21:03.936]                       inherits <- base::inherits
[16:21:03.936]                       invokeRestart <- base::invokeRestart
[16:21:03.936]                       is.null <- base::is.null
[16:21:03.936]                       muffled <- FALSE
[16:21:03.936]                       if (inherits(cond, "message")) {
[16:21:03.936]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.936]                         if (muffled) 
[16:21:03.936]                           invokeRestart("muffleMessage")
[16:21:03.936]                       }
[16:21:03.936]                       else if (inherits(cond, "warning")) {
[16:21:03.936]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.936]                         if (muffled) 
[16:21:03.936]                           invokeRestart("muffleWarning")
[16:21:03.936]                       }
[16:21:03.936]                       else if (inherits(cond, "condition")) {
[16:21:03.936]                         if (!is.null(pattern)) {
[16:21:03.936]                           computeRestarts <- base::computeRestarts
[16:21:03.936]                           grepl <- base::grepl
[16:21:03.936]                           restarts <- computeRestarts(cond)
[16:21:03.936]                           for (restart in restarts) {
[16:21:03.936]                             name <- restart$name
[16:21:03.936]                             if (is.null(name)) 
[16:21:03.936]                               next
[16:21:03.936]                             if (!grepl(pattern, name)) 
[16:21:03.936]                               next
[16:21:03.936]                             invokeRestart(restart)
[16:21:03.936]                             muffled <- TRUE
[16:21:03.936]                             break
[16:21:03.936]                           }
[16:21:03.936]                         }
[16:21:03.936]                       }
[16:21:03.936]                       invisible(muffled)
[16:21:03.936]                     }
[16:21:03.936]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.936]                   }
[16:21:03.936]                 }
[16:21:03.936]                 else {
[16:21:03.936]                   if (TRUE) {
[16:21:03.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:03.936]                     {
[16:21:03.936]                       inherits <- base::inherits
[16:21:03.936]                       invokeRestart <- base::invokeRestart
[16:21:03.936]                       is.null <- base::is.null
[16:21:03.936]                       muffled <- FALSE
[16:21:03.936]                       if (inherits(cond, "message")) {
[16:21:03.936]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:03.936]                         if (muffled) 
[16:21:03.936]                           invokeRestart("muffleMessage")
[16:21:03.936]                       }
[16:21:03.936]                       else if (inherits(cond, "warning")) {
[16:21:03.936]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:03.936]                         if (muffled) 
[16:21:03.936]                           invokeRestart("muffleWarning")
[16:21:03.936]                       }
[16:21:03.936]                       else if (inherits(cond, "condition")) {
[16:21:03.936]                         if (!is.null(pattern)) {
[16:21:03.936]                           computeRestarts <- base::computeRestarts
[16:21:03.936]                           grepl <- base::grepl
[16:21:03.936]                           restarts <- computeRestarts(cond)
[16:21:03.936]                           for (restart in restarts) {
[16:21:03.936]                             name <- restart$name
[16:21:03.936]                             if (is.null(name)) 
[16:21:03.936]                               next
[16:21:03.936]                             if (!grepl(pattern, name)) 
[16:21:03.936]                               next
[16:21:03.936]                             invokeRestart(restart)
[16:21:03.936]                             muffled <- TRUE
[16:21:03.936]                             break
[16:21:03.936]                           }
[16:21:03.936]                         }
[16:21:03.936]                       }
[16:21:03.936]                       invisible(muffled)
[16:21:03.936]                     }
[16:21:03.936]                     muffleCondition(cond, pattern = "^muffle")
[16:21:03.936]                   }
[16:21:03.936]                 }
[16:21:03.936]             }
[16:21:03.936]         }))
[16:21:03.936]     }, error = function(ex) {
[16:21:03.936]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:03.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:03.936]                 ...future.rng), started = ...future.startTime, 
[16:21:03.936]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:03.936]             version = "1.8"), class = "FutureResult")
[16:21:03.936]     }, finally = {
[16:21:03.936]         if (!identical(...future.workdir, getwd())) 
[16:21:03.936]             setwd(...future.workdir)
[16:21:03.936]         {
[16:21:03.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:03.936]                 ...future.oldOptions$nwarnings <- NULL
[16:21:03.936]             }
[16:21:03.936]             base::options(...future.oldOptions)
[16:21:03.936]             if (.Platform$OS.type == "windows") {
[16:21:03.936]                 old_names <- names(...future.oldEnvVars)
[16:21:03.936]                 envs <- base::Sys.getenv()
[16:21:03.936]                 names <- names(envs)
[16:21:03.936]                 common <- intersect(names, old_names)
[16:21:03.936]                 added <- setdiff(names, old_names)
[16:21:03.936]                 removed <- setdiff(old_names, names)
[16:21:03.936]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:03.936]                   envs[common]]
[16:21:03.936]                 NAMES <- toupper(changed)
[16:21:03.936]                 args <- list()
[16:21:03.936]                 for (kk in seq_along(NAMES)) {
[16:21:03.936]                   name <- changed[[kk]]
[16:21:03.936]                   NAME <- NAMES[[kk]]
[16:21:03.936]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.936]                     next
[16:21:03.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.936]                 }
[16:21:03.936]                 NAMES <- toupper(added)
[16:21:03.936]                 for (kk in seq_along(NAMES)) {
[16:21:03.936]                   name <- added[[kk]]
[16:21:03.936]                   NAME <- NAMES[[kk]]
[16:21:03.936]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.936]                     next
[16:21:03.936]                   args[[name]] <- ""
[16:21:03.936]                 }
[16:21:03.936]                 NAMES <- toupper(removed)
[16:21:03.936]                 for (kk in seq_along(NAMES)) {
[16:21:03.936]                   name <- removed[[kk]]
[16:21:03.936]                   NAME <- NAMES[[kk]]
[16:21:03.936]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:03.936]                     next
[16:21:03.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:03.936]                 }
[16:21:03.936]                 if (length(args) > 0) 
[16:21:03.936]                   base::do.call(base::Sys.setenv, args = args)
[16:21:03.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:03.936]             }
[16:21:03.936]             else {
[16:21:03.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:03.936]             }
[16:21:03.936]             {
[16:21:03.936]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:03.936]                   0L) {
[16:21:03.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:03.936]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:03.936]                   base::options(opts)
[16:21:03.936]                 }
[16:21:03.936]                 {
[16:21:03.936]                   {
[16:21:03.936]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:03.936]                     NULL
[16:21:03.936]                   }
[16:21:03.936]                   options(future.plan = NULL)
[16:21:03.936]                   if (is.na(NA_character_)) 
[16:21:03.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:03.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:03.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:03.936]                     .init = FALSE)
[16:21:03.936]                 }
[16:21:03.936]             }
[16:21:03.936]         }
[16:21:03.936]     })
[16:21:03.936]     if (TRUE) {
[16:21:03.936]         base::sink(type = "output", split = FALSE)
[16:21:03.936]         if (TRUE) {
[16:21:03.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:03.936]         }
[16:21:03.936]         else {
[16:21:03.936]             ...future.result["stdout"] <- base::list(NULL)
[16:21:03.936]         }
[16:21:03.936]         base::close(...future.stdout)
[16:21:03.936]         ...future.stdout <- NULL
[16:21:03.936]     }
[16:21:03.936]     ...future.result$conditions <- ...future.conditions
[16:21:03.936]     ...future.result$finished <- base::Sys.time()
[16:21:03.936]     ...future.result
[16:21:03.936] }
[16:21:03.940] assign_globals() ...
[16:21:03.940] List of 1
[16:21:03.940]  $ ii: int 3
[16:21:03.940]  - attr(*, "where")=List of 1
[16:21:03.940]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:03.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:03.940]  - attr(*, "resolved")= logi TRUE
[16:21:03.940]  - attr(*, "total_size")= num 56
[16:21:03.940]  - attr(*, "already-done")= logi TRUE
[16:21:03.947] - copied ‘ii’ to environment
[16:21:03.947] assign_globals() ... done
[16:21:03.948] requestCore(): workers = 2
[16:21:03.948] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:03.960] result() for MulticoreFuture ...
[16:21:03.961] result() for MulticoreFuture ...
[16:21:03.961] result() for MulticoreFuture ... done
[16:21:03.961] result() for MulticoreFuture ... done
[16:21:03.962] result() for MulticoreFuture ...
[16:21:03.962] result() for MulticoreFuture ... done
[16:21:03.965] MulticoreFuture started
[16:21:03.966] - Launch lazy future ... done
[16:21:03.966] run() for ‘MulticoreFuture’ ... done
[16:21:03.967] plan(): Setting new future strategy stack:
[16:21:03.967] result() for MulticoreFuture ...
[16:21:03.967] result() for MulticoreFuture ... done
[16:21:03.967] List of future strategies:
[16:21:03.967] 1. sequential:
[16:21:03.967]    - args: function (..., envir = parent.frame())
[16:21:03.967]    - tweaked: FALSE
[16:21:03.967]    - call: NULL
[16:21:03.968] result() for MulticoreFuture ...
[16:21:03.968] result() for MulticoreFuture ... done
[16:21:03.968] plan(): nbrOfWorkers() = 1
[16:21:03.968] result() for MulticoreFuture ...
[16:21:03.970] result() for MulticoreFuture ...
[16:21:03.970] result() for MulticoreFuture ... done
[16:21:03.970] result() for MulticoreFuture ... done
[16:21:03.971] result() for MulticoreFuture ...
[16:21:03.971] plan(): Setting new future strategy stack:
[16:21:03.971] result() for MulticoreFuture ... done
[16:21:03.971] result() for MulticoreFuture ...
[16:21:03.971] List of future strategies:
[16:21:03.971] 1. multicore:
[16:21:03.971]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:03.971]    - tweaked: FALSE
[16:21:03.971]    - call: plan(strategy)
[16:21:03.977] plan(): nbrOfWorkers() = 2
[16:21:03.978] result() for MulticoreFuture ...
[16:21:03.978] result() for MulticoreFuture ... done
[16:21:03.978] result() for MulticoreFuture ... done
[16:21:03.979] result() for MulticoreFuture ...
[16:21:03.979] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.980] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.981] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.983] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.983] Searching for globals ... DONE
[16:21:03.983] Resolving globals: TRUE
[16:21:03.983] Resolving any globals that are futures ...
[16:21:03.983] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.983] Resolving any globals that are futures ... DONE
[16:21:03.984] Resolving futures part of globals (recursively) ...
[16:21:03.984] resolve() on list ...
[16:21:03.984]  recursive: 99
[16:21:03.984]  length: 1
[16:21:03.984]  elements: ‘ii’
[16:21:03.985]  length: 0 (resolved future 1)
[16:21:03.985] resolve() on list ... DONE
[16:21:03.985] - globals: [1] ‘ii’
[16:21:03.985] Resolving futures part of globals (recursively) ... DONE
[16:21:03.985] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.986] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.986] - globals: [1] ‘ii’
[16:21:03.986] 
[16:21:03.986] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.987] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.987] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.989] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.989] Searching for globals ... DONE
[16:21:03.989] Resolving globals: TRUE
[16:21:03.989] Resolving any globals that are futures ...
[16:21:03.989] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.989] Resolving any globals that are futures ... DONE
[16:21:03.990] Resolving futures part of globals (recursively) ...
[16:21:03.990] resolve() on list ...
[16:21:03.990]  recursive: 99
[16:21:03.990]  length: 1
[16:21:03.990]  elements: ‘ii’
[16:21:03.990]  length: 0 (resolved future 1)
[16:21:03.990] resolve() on list ... DONE
[16:21:03.991] - globals: [1] ‘ii’
[16:21:03.991] Resolving futures part of globals (recursively) ... DONE
[16:21:03.991] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.991] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.991] - globals: [1] ‘ii’
[16:21:03.991] 
[16:21:03.992] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:03.992] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:03.993] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:03.994] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.994] Searching for globals ... DONE
[16:21:03.994] Resolving globals: TRUE
[16:21:03.994] Resolving any globals that are futures ...
[16:21:03.995] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:03.995] Resolving any globals that are futures ... DONE
[16:21:03.995] Resolving futures part of globals (recursively) ...
[16:21:03.995] resolve() on list ...
[16:21:03.995]  recursive: 99
[16:21:03.996]  length: 1
[16:21:03.996]  elements: ‘ii’
[16:21:03.996]  length: 0 (resolved future 1)
[16:21:03.996] resolve() on list ... DONE
[16:21:03.996] - globals: [1] ‘ii’
[16:21:03.996] Resolving futures part of globals (recursively) ... DONE
[16:21:03.996] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:03.997] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:03.997] - globals: [1] ‘ii’
[16:21:03.997] 
[16:21:03.997] getGlobalsAndPackages() ... DONE
[16:21:03.997] run() for ‘Future’ ...
[16:21:03.998] - state: ‘created’
[16:21:03.998] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.004] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.005]   - Field: ‘label’
[16:21:04.005]   - Field: ‘local’
[16:21:04.005]   - Field: ‘owner’
[16:21:04.005]   - Field: ‘envir’
[16:21:04.005]   - Field: ‘workers’
[16:21:04.005]   - Field: ‘packages’
[16:21:04.006]   - Field: ‘gc’
[16:21:04.006]   - Field: ‘job’
[16:21:04.006]   - Field: ‘conditions’
[16:21:04.006]   - Field: ‘expr’
[16:21:04.006]   - Field: ‘uuid’
[16:21:04.006]   - Field: ‘seed’
[16:21:04.006]   - Field: ‘version’
[16:21:04.006]   - Field: ‘result’
[16:21:04.006]   - Field: ‘asynchronous’
[16:21:04.007]   - Field: ‘calls’
[16:21:04.007]   - Field: ‘globals’
[16:21:04.007]   - Field: ‘stdout’
[16:21:04.007]   - Field: ‘earlySignal’
[16:21:04.007]   - Field: ‘lazy’
[16:21:04.007]   - Field: ‘state’
[16:21:04.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.007] - Launch lazy future ...
[16:21:04.008] Packages needed by the future expression (n = 0): <none>
[16:21:04.008] Packages needed by future strategies (n = 0): <none>
[16:21:04.008] {
[16:21:04.008]     {
[16:21:04.008]         {
[16:21:04.008]             ...future.startTime <- base::Sys.time()
[16:21:04.008]             {
[16:21:04.008]                 {
[16:21:04.008]                   {
[16:21:04.008]                     {
[16:21:04.008]                       base::local({
[16:21:04.008]                         has_future <- base::requireNamespace("future", 
[16:21:04.008]                           quietly = TRUE)
[16:21:04.008]                         if (has_future) {
[16:21:04.008]                           ns <- base::getNamespace("future")
[16:21:04.008]                           version <- ns[[".package"]][["version"]]
[16:21:04.008]                           if (is.null(version)) 
[16:21:04.008]                             version <- utils::packageVersion("future")
[16:21:04.008]                         }
[16:21:04.008]                         else {
[16:21:04.008]                           version <- NULL
[16:21:04.008]                         }
[16:21:04.008]                         if (!has_future || version < "1.8.0") {
[16:21:04.008]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.008]                             "", base::R.version$version.string), 
[16:21:04.008]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.008]                               "release", "version")], collapse = " "), 
[16:21:04.008]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.008]                             info)
[16:21:04.008]                           info <- base::paste(info, collapse = "; ")
[16:21:04.008]                           if (!has_future) {
[16:21:04.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.008]                               info)
[16:21:04.008]                           }
[16:21:04.008]                           else {
[16:21:04.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.008]                               info, version)
[16:21:04.008]                           }
[16:21:04.008]                           base::stop(msg)
[16:21:04.008]                         }
[16:21:04.008]                       })
[16:21:04.008]                     }
[16:21:04.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.008]                     base::options(mc.cores = 1L)
[16:21:04.008]                   }
[16:21:04.008]                   ...future.strategy.old <- future::plan("list")
[16:21:04.008]                   options(future.plan = NULL)
[16:21:04.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.008]                 }
[16:21:04.008]                 ...future.workdir <- getwd()
[16:21:04.008]             }
[16:21:04.008]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.008]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.008]         }
[16:21:04.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.008]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.008]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.008]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.008]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.008]             base::names(...future.oldOptions))
[16:21:04.008]     }
[16:21:04.008]     if (FALSE) {
[16:21:04.008]     }
[16:21:04.008]     else {
[16:21:04.008]         if (TRUE) {
[16:21:04.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.008]                 open = "w")
[16:21:04.008]         }
[16:21:04.008]         else {
[16:21:04.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.008]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.008]         }
[16:21:04.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.008]             base::sink(type = "output", split = FALSE)
[16:21:04.008]             base::close(...future.stdout)
[16:21:04.008]         }, add = TRUE)
[16:21:04.008]     }
[16:21:04.008]     ...future.frame <- base::sys.nframe()
[16:21:04.008]     ...future.conditions <- base::list()
[16:21:04.008]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.008]     if (FALSE) {
[16:21:04.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.008]     }
[16:21:04.008]     ...future.result <- base::tryCatch({
[16:21:04.008]         base::withCallingHandlers({
[16:21:04.008]             ...future.value <- base::withVisible(base::local({
[16:21:04.008]                 withCallingHandlers({
[16:21:04.008]                   {
[16:21:04.008]                     b <- a * ii
[16:21:04.008]                     a <- 0
[16:21:04.008]                     b
[16:21:04.008]                   }
[16:21:04.008]                 }, immediateCondition = function(cond) {
[16:21:04.008]                   save_rds <- function (object, pathname, ...) 
[16:21:04.008]                   {
[16:21:04.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.008]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.008]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.008]                         fi_tmp[["mtime"]])
[16:21:04.008]                     }
[16:21:04.008]                     tryCatch({
[16:21:04.008]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.008]                     }, error = function(ex) {
[16:21:04.008]                       msg <- conditionMessage(ex)
[16:21:04.008]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.008]                         fi_tmp[["mtime"]], msg)
[16:21:04.008]                       ex$message <- msg
[16:21:04.008]                       stop(ex)
[16:21:04.008]                     })
[16:21:04.008]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.008]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.008]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.008]                       fi <- file.info(pathname)
[16:21:04.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.008]                         fi[["size"]], fi[["mtime"]])
[16:21:04.008]                       stop(msg)
[16:21:04.008]                     }
[16:21:04.008]                     invisible(pathname)
[16:21:04.008]                   }
[16:21:04.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.008]                     rootPath = tempdir()) 
[16:21:04.008]                   {
[16:21:04.008]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.008]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.008]                       tmpdir = path, fileext = ".rds")
[16:21:04.008]                     save_rds(obj, file)
[16:21:04.008]                   }
[16:21:04.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.008]                   {
[16:21:04.008]                     inherits <- base::inherits
[16:21:04.008]                     invokeRestart <- base::invokeRestart
[16:21:04.008]                     is.null <- base::is.null
[16:21:04.008]                     muffled <- FALSE
[16:21:04.008]                     if (inherits(cond, "message")) {
[16:21:04.008]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.008]                       if (muffled) 
[16:21:04.008]                         invokeRestart("muffleMessage")
[16:21:04.008]                     }
[16:21:04.008]                     else if (inherits(cond, "warning")) {
[16:21:04.008]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.008]                       if (muffled) 
[16:21:04.008]                         invokeRestart("muffleWarning")
[16:21:04.008]                     }
[16:21:04.008]                     else if (inherits(cond, "condition")) {
[16:21:04.008]                       if (!is.null(pattern)) {
[16:21:04.008]                         computeRestarts <- base::computeRestarts
[16:21:04.008]                         grepl <- base::grepl
[16:21:04.008]                         restarts <- computeRestarts(cond)
[16:21:04.008]                         for (restart in restarts) {
[16:21:04.008]                           name <- restart$name
[16:21:04.008]                           if (is.null(name)) 
[16:21:04.008]                             next
[16:21:04.008]                           if (!grepl(pattern, name)) 
[16:21:04.008]                             next
[16:21:04.008]                           invokeRestart(restart)
[16:21:04.008]                           muffled <- TRUE
[16:21:04.008]                           break
[16:21:04.008]                         }
[16:21:04.008]                       }
[16:21:04.008]                     }
[16:21:04.008]                     invisible(muffled)
[16:21:04.008]                   }
[16:21:04.008]                   muffleCondition(cond)
[16:21:04.008]                 })
[16:21:04.008]             }))
[16:21:04.008]             future::FutureResult(value = ...future.value$value, 
[16:21:04.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.008]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.008]                     ...future.globalenv.names))
[16:21:04.008]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.008]         }, condition = base::local({
[16:21:04.008]             c <- base::c
[16:21:04.008]             inherits <- base::inherits
[16:21:04.008]             invokeRestart <- base::invokeRestart
[16:21:04.008]             length <- base::length
[16:21:04.008]             list <- base::list
[16:21:04.008]             seq.int <- base::seq.int
[16:21:04.008]             signalCondition <- base::signalCondition
[16:21:04.008]             sys.calls <- base::sys.calls
[16:21:04.008]             `[[` <- base::`[[`
[16:21:04.008]             `+` <- base::`+`
[16:21:04.008]             `<<-` <- base::`<<-`
[16:21:04.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.008]                   3L)]
[16:21:04.008]             }
[16:21:04.008]             function(cond) {
[16:21:04.008]                 is_error <- inherits(cond, "error")
[16:21:04.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.008]                   NULL)
[16:21:04.008]                 if (is_error) {
[16:21:04.008]                   sessionInformation <- function() {
[16:21:04.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.008]                       search = base::search(), system = base::Sys.info())
[16:21:04.008]                   }
[16:21:04.008]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.008]                     cond$call), session = sessionInformation(), 
[16:21:04.008]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.008]                   signalCondition(cond)
[16:21:04.008]                 }
[16:21:04.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.008]                 "immediateCondition"))) {
[16:21:04.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.008]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.008]                   if (TRUE && !signal) {
[16:21:04.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.008]                     {
[16:21:04.008]                       inherits <- base::inherits
[16:21:04.008]                       invokeRestart <- base::invokeRestart
[16:21:04.008]                       is.null <- base::is.null
[16:21:04.008]                       muffled <- FALSE
[16:21:04.008]                       if (inherits(cond, "message")) {
[16:21:04.008]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.008]                         if (muffled) 
[16:21:04.008]                           invokeRestart("muffleMessage")
[16:21:04.008]                       }
[16:21:04.008]                       else if (inherits(cond, "warning")) {
[16:21:04.008]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.008]                         if (muffled) 
[16:21:04.008]                           invokeRestart("muffleWarning")
[16:21:04.008]                       }
[16:21:04.008]                       else if (inherits(cond, "condition")) {
[16:21:04.008]                         if (!is.null(pattern)) {
[16:21:04.008]                           computeRestarts <- base::computeRestarts
[16:21:04.008]                           grepl <- base::grepl
[16:21:04.008]                           restarts <- computeRestarts(cond)
[16:21:04.008]                           for (restart in restarts) {
[16:21:04.008]                             name <- restart$name
[16:21:04.008]                             if (is.null(name)) 
[16:21:04.008]                               next
[16:21:04.008]                             if (!grepl(pattern, name)) 
[16:21:04.008]                               next
[16:21:04.008]                             invokeRestart(restart)
[16:21:04.008]                             muffled <- TRUE
[16:21:04.008]                             break
[16:21:04.008]                           }
[16:21:04.008]                         }
[16:21:04.008]                       }
[16:21:04.008]                       invisible(muffled)
[16:21:04.008]                     }
[16:21:04.008]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.008]                   }
[16:21:04.008]                 }
[16:21:04.008]                 else {
[16:21:04.008]                   if (TRUE) {
[16:21:04.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.008]                     {
[16:21:04.008]                       inherits <- base::inherits
[16:21:04.008]                       invokeRestart <- base::invokeRestart
[16:21:04.008]                       is.null <- base::is.null
[16:21:04.008]                       muffled <- FALSE
[16:21:04.008]                       if (inherits(cond, "message")) {
[16:21:04.008]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.008]                         if (muffled) 
[16:21:04.008]                           invokeRestart("muffleMessage")
[16:21:04.008]                       }
[16:21:04.008]                       else if (inherits(cond, "warning")) {
[16:21:04.008]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.008]                         if (muffled) 
[16:21:04.008]                           invokeRestart("muffleWarning")
[16:21:04.008]                       }
[16:21:04.008]                       else if (inherits(cond, "condition")) {
[16:21:04.008]                         if (!is.null(pattern)) {
[16:21:04.008]                           computeRestarts <- base::computeRestarts
[16:21:04.008]                           grepl <- base::grepl
[16:21:04.008]                           restarts <- computeRestarts(cond)
[16:21:04.008]                           for (restart in restarts) {
[16:21:04.008]                             name <- restart$name
[16:21:04.008]                             if (is.null(name)) 
[16:21:04.008]                               next
[16:21:04.008]                             if (!grepl(pattern, name)) 
[16:21:04.008]                               next
[16:21:04.008]                             invokeRestart(restart)
[16:21:04.008]                             muffled <- TRUE
[16:21:04.008]                             break
[16:21:04.008]                           }
[16:21:04.008]                         }
[16:21:04.008]                       }
[16:21:04.008]                       invisible(muffled)
[16:21:04.008]                     }
[16:21:04.008]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.008]                   }
[16:21:04.008]                 }
[16:21:04.008]             }
[16:21:04.008]         }))
[16:21:04.008]     }, error = function(ex) {
[16:21:04.008]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.008]                 ...future.rng), started = ...future.startTime, 
[16:21:04.008]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.008]             version = "1.8"), class = "FutureResult")
[16:21:04.008]     }, finally = {
[16:21:04.008]         if (!identical(...future.workdir, getwd())) 
[16:21:04.008]             setwd(...future.workdir)
[16:21:04.008]         {
[16:21:04.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.008]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.008]             }
[16:21:04.008]             base::options(...future.oldOptions)
[16:21:04.008]             if (.Platform$OS.type == "windows") {
[16:21:04.008]                 old_names <- names(...future.oldEnvVars)
[16:21:04.008]                 envs <- base::Sys.getenv()
[16:21:04.008]                 names <- names(envs)
[16:21:04.008]                 common <- intersect(names, old_names)
[16:21:04.008]                 added <- setdiff(names, old_names)
[16:21:04.008]                 removed <- setdiff(old_names, names)
[16:21:04.008]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.008]                   envs[common]]
[16:21:04.008]                 NAMES <- toupper(changed)
[16:21:04.008]                 args <- list()
[16:21:04.008]                 for (kk in seq_along(NAMES)) {
[16:21:04.008]                   name <- changed[[kk]]
[16:21:04.008]                   NAME <- NAMES[[kk]]
[16:21:04.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.008]                     next
[16:21:04.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.008]                 }
[16:21:04.008]                 NAMES <- toupper(added)
[16:21:04.008]                 for (kk in seq_along(NAMES)) {
[16:21:04.008]                   name <- added[[kk]]
[16:21:04.008]                   NAME <- NAMES[[kk]]
[16:21:04.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.008]                     next
[16:21:04.008]                   args[[name]] <- ""
[16:21:04.008]                 }
[16:21:04.008]                 NAMES <- toupper(removed)
[16:21:04.008]                 for (kk in seq_along(NAMES)) {
[16:21:04.008]                   name <- removed[[kk]]
[16:21:04.008]                   NAME <- NAMES[[kk]]
[16:21:04.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.008]                     next
[16:21:04.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.008]                 }
[16:21:04.008]                 if (length(args) > 0) 
[16:21:04.008]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.008]             }
[16:21:04.008]             else {
[16:21:04.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.008]             }
[16:21:04.008]             {
[16:21:04.008]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.008]                   0L) {
[16:21:04.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.008]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.008]                   base::options(opts)
[16:21:04.008]                 }
[16:21:04.008]                 {
[16:21:04.008]                   {
[16:21:04.008]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.008]                     NULL
[16:21:04.008]                   }
[16:21:04.008]                   options(future.plan = NULL)
[16:21:04.008]                   if (is.na(NA_character_)) 
[16:21:04.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.008]                     .init = FALSE)
[16:21:04.008]                 }
[16:21:04.008]             }
[16:21:04.008]         }
[16:21:04.008]     })
[16:21:04.008]     if (TRUE) {
[16:21:04.008]         base::sink(type = "output", split = FALSE)
[16:21:04.008]         if (TRUE) {
[16:21:04.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.008]         }
[16:21:04.008]         else {
[16:21:04.008]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.008]         }
[16:21:04.008]         base::close(...future.stdout)
[16:21:04.008]         ...future.stdout <- NULL
[16:21:04.008]     }
[16:21:04.008]     ...future.result$conditions <- ...future.conditions
[16:21:04.008]     ...future.result$finished <- base::Sys.time()
[16:21:04.008]     ...future.result
[16:21:04.008] }
[16:21:04.011] assign_globals() ...
[16:21:04.011] List of 1
[16:21:04.011]  $ ii: int 1
[16:21:04.011]  - attr(*, "where")=List of 1
[16:21:04.011]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:04.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.011]  - attr(*, "resolved")= logi TRUE
[16:21:04.011]  - attr(*, "total_size")= num 56
[16:21:04.011]  - attr(*, "already-done")= logi TRUE
[16:21:04.014] - copied ‘ii’ to environment
[16:21:04.014] assign_globals() ... done
[16:21:04.014] requestCore(): workers = 2
[16:21:04.016] MulticoreFuture started
[16:21:04.016] - Launch lazy future ... done
[16:21:04.017] run() for ‘MulticoreFuture’ ... done
[16:21:04.017] result() for MulticoreFuture ...
[16:21:04.017] plan(): Setting new future strategy stack:
[16:21:04.018] List of future strategies:
[16:21:04.018] 1. sequential:
[16:21:04.018]    - args: function (..., envir = parent.frame())
[16:21:04.018]    - tweaked: FALSE
[16:21:04.018]    - call: NULL
[16:21:04.018] plan(): nbrOfWorkers() = 1
[16:21:04.021] plan(): Setting new future strategy stack:
[16:21:04.021] List of future strategies:
[16:21:04.021] 1. multicore:
[16:21:04.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.021]    - tweaked: FALSE
[16:21:04.021]    - call: plan(strategy)
[16:21:04.027] plan(): nbrOfWorkers() = 2
[16:21:04.033] result() for MulticoreFuture ...
[16:21:04.034] result() for MulticoreFuture ... done
[16:21:04.034] signalConditions() ...
[16:21:04.034]  - include = ‘immediateCondition’
[16:21:04.034]  - exclude = 
[16:21:04.034]  - resignal = FALSE
[16:21:04.034]  - Number of conditions: 1
[16:21:04.034] signalConditions() ... done
[16:21:04.035] result() for MulticoreFuture ... done
[16:21:04.035] result() for MulticoreFuture ...
[16:21:04.035] result() for MulticoreFuture ... done
[16:21:04.035] signalConditions() ...
[16:21:04.035]  - include = ‘immediateCondition’
[16:21:04.035]  - exclude = 
[16:21:04.035]  - resignal = FALSE
[16:21:04.035]  - Number of conditions: 1
[16:21:04.036] signalConditions() ... done
[16:21:04.036] Future state: ‘finished’
[16:21:04.036] result() for MulticoreFuture ...
[16:21:04.036] result() for MulticoreFuture ... done
[16:21:04.036] signalConditions() ...
[16:21:04.036]  - include = ‘condition’
[16:21:04.036]  - exclude = ‘immediateCondition’
[16:21:04.036]  - resignal = TRUE
[16:21:04.037]  - Number of conditions: 1
[16:21:04.037]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:21:04.037] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "b478068843b5" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:21:04"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.069] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.070] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:04.070] 
[16:21:04.071] Searching for globals ... DONE
[16:21:04.071] - globals: [0] <none>
[16:21:04.071] getGlobalsAndPackages() ... DONE
[16:21:04.071] run() for ‘Future’ ...
[16:21:04.071] - state: ‘created’
[16:21:04.071] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.076] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.076]   - Field: ‘label’
[16:21:04.076]   - Field: ‘local’
[16:21:04.076]   - Field: ‘owner’
[16:21:04.076]   - Field: ‘envir’
[16:21:04.077]   - Field: ‘workers’
[16:21:04.077]   - Field: ‘packages’
[16:21:04.077]   - Field: ‘gc’
[16:21:04.077]   - Field: ‘job’
[16:21:04.077]   - Field: ‘conditions’
[16:21:04.077]   - Field: ‘expr’
[16:21:04.077]   - Field: ‘uuid’
[16:21:04.077]   - Field: ‘seed’
[16:21:04.077]   - Field: ‘version’
[16:21:04.078]   - Field: ‘result’
[16:21:04.078]   - Field: ‘asynchronous’
[16:21:04.078]   - Field: ‘calls’
[16:21:04.078]   - Field: ‘globals’
[16:21:04.078]   - Field: ‘stdout’
[16:21:04.078]   - Field: ‘earlySignal’
[16:21:04.078]   - Field: ‘lazy’
[16:21:04.078]   - Field: ‘state’
[16:21:04.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.078] - Launch lazy future ...
[16:21:04.079] Packages needed by the future expression (n = 0): <none>
[16:21:04.079] Packages needed by future strategies (n = 0): <none>
[16:21:04.079] {
[16:21:04.079]     {
[16:21:04.079]         {
[16:21:04.079]             ...future.startTime <- base::Sys.time()
[16:21:04.079]             {
[16:21:04.079]                 {
[16:21:04.079]                   {
[16:21:04.079]                     {
[16:21:04.079]                       base::local({
[16:21:04.079]                         has_future <- base::requireNamespace("future", 
[16:21:04.079]                           quietly = TRUE)
[16:21:04.079]                         if (has_future) {
[16:21:04.079]                           ns <- base::getNamespace("future")
[16:21:04.079]                           version <- ns[[".package"]][["version"]]
[16:21:04.079]                           if (is.null(version)) 
[16:21:04.079]                             version <- utils::packageVersion("future")
[16:21:04.079]                         }
[16:21:04.079]                         else {
[16:21:04.079]                           version <- NULL
[16:21:04.079]                         }
[16:21:04.079]                         if (!has_future || version < "1.8.0") {
[16:21:04.079]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.079]                             "", base::R.version$version.string), 
[16:21:04.079]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.079]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.079]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.079]                               "release", "version")], collapse = " "), 
[16:21:04.079]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.079]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.079]                             info)
[16:21:04.079]                           info <- base::paste(info, collapse = "; ")
[16:21:04.079]                           if (!has_future) {
[16:21:04.079]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.079]                               info)
[16:21:04.079]                           }
[16:21:04.079]                           else {
[16:21:04.079]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.079]                               info, version)
[16:21:04.079]                           }
[16:21:04.079]                           base::stop(msg)
[16:21:04.079]                         }
[16:21:04.079]                       })
[16:21:04.079]                     }
[16:21:04.079]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.079]                     base::options(mc.cores = 1L)
[16:21:04.079]                   }
[16:21:04.079]                   ...future.strategy.old <- future::plan("list")
[16:21:04.079]                   options(future.plan = NULL)
[16:21:04.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.079]                 }
[16:21:04.079]                 ...future.workdir <- getwd()
[16:21:04.079]             }
[16:21:04.079]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.079]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.079]         }
[16:21:04.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.079]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.079]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.079]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.079]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.079]             base::names(...future.oldOptions))
[16:21:04.079]     }
[16:21:04.079]     if (FALSE) {
[16:21:04.079]     }
[16:21:04.079]     else {
[16:21:04.079]         if (TRUE) {
[16:21:04.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.079]                 open = "w")
[16:21:04.079]         }
[16:21:04.079]         else {
[16:21:04.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.079]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.079]         }
[16:21:04.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.079]             base::sink(type = "output", split = FALSE)
[16:21:04.079]             base::close(...future.stdout)
[16:21:04.079]         }, add = TRUE)
[16:21:04.079]     }
[16:21:04.079]     ...future.frame <- base::sys.nframe()
[16:21:04.079]     ...future.conditions <- base::list()
[16:21:04.079]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.079]     if (FALSE) {
[16:21:04.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.079]     }
[16:21:04.079]     ...future.result <- base::tryCatch({
[16:21:04.079]         base::withCallingHandlers({
[16:21:04.079]             ...future.value <- base::withVisible(base::local({
[16:21:04.079]                 withCallingHandlers({
[16:21:04.079]                   1
[16:21:04.079]                 }, immediateCondition = function(cond) {
[16:21:04.079]                   save_rds <- function (object, pathname, ...) 
[16:21:04.079]                   {
[16:21:04.079]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.079]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.079]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.079]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.079]                         fi_tmp[["mtime"]])
[16:21:04.079]                     }
[16:21:04.079]                     tryCatch({
[16:21:04.079]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.079]                     }, error = function(ex) {
[16:21:04.079]                       msg <- conditionMessage(ex)
[16:21:04.079]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.079]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.079]                         fi_tmp[["mtime"]], msg)
[16:21:04.079]                       ex$message <- msg
[16:21:04.079]                       stop(ex)
[16:21:04.079]                     })
[16:21:04.079]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.079]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.079]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.079]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.079]                       fi <- file.info(pathname)
[16:21:04.079]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.079]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.079]                         fi[["size"]], fi[["mtime"]])
[16:21:04.079]                       stop(msg)
[16:21:04.079]                     }
[16:21:04.079]                     invisible(pathname)
[16:21:04.079]                   }
[16:21:04.079]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.079]                     rootPath = tempdir()) 
[16:21:04.079]                   {
[16:21:04.079]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.079]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.079]                       tmpdir = path, fileext = ".rds")
[16:21:04.079]                     save_rds(obj, file)
[16:21:04.079]                   }
[16:21:04.079]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.079]                   {
[16:21:04.079]                     inherits <- base::inherits
[16:21:04.079]                     invokeRestart <- base::invokeRestart
[16:21:04.079]                     is.null <- base::is.null
[16:21:04.079]                     muffled <- FALSE
[16:21:04.079]                     if (inherits(cond, "message")) {
[16:21:04.079]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.079]                       if (muffled) 
[16:21:04.079]                         invokeRestart("muffleMessage")
[16:21:04.079]                     }
[16:21:04.079]                     else if (inherits(cond, "warning")) {
[16:21:04.079]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.079]                       if (muffled) 
[16:21:04.079]                         invokeRestart("muffleWarning")
[16:21:04.079]                     }
[16:21:04.079]                     else if (inherits(cond, "condition")) {
[16:21:04.079]                       if (!is.null(pattern)) {
[16:21:04.079]                         computeRestarts <- base::computeRestarts
[16:21:04.079]                         grepl <- base::grepl
[16:21:04.079]                         restarts <- computeRestarts(cond)
[16:21:04.079]                         for (restart in restarts) {
[16:21:04.079]                           name <- restart$name
[16:21:04.079]                           if (is.null(name)) 
[16:21:04.079]                             next
[16:21:04.079]                           if (!grepl(pattern, name)) 
[16:21:04.079]                             next
[16:21:04.079]                           invokeRestart(restart)
[16:21:04.079]                           muffled <- TRUE
[16:21:04.079]                           break
[16:21:04.079]                         }
[16:21:04.079]                       }
[16:21:04.079]                     }
[16:21:04.079]                     invisible(muffled)
[16:21:04.079]                   }
[16:21:04.079]                   muffleCondition(cond)
[16:21:04.079]                 })
[16:21:04.079]             }))
[16:21:04.079]             future::FutureResult(value = ...future.value$value, 
[16:21:04.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.079]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.079]                     ...future.globalenv.names))
[16:21:04.079]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.079]         }, condition = base::local({
[16:21:04.079]             c <- base::c
[16:21:04.079]             inherits <- base::inherits
[16:21:04.079]             invokeRestart <- base::invokeRestart
[16:21:04.079]             length <- base::length
[16:21:04.079]             list <- base::list
[16:21:04.079]             seq.int <- base::seq.int
[16:21:04.079]             signalCondition <- base::signalCondition
[16:21:04.079]             sys.calls <- base::sys.calls
[16:21:04.079]             `[[` <- base::`[[`
[16:21:04.079]             `+` <- base::`+`
[16:21:04.079]             `<<-` <- base::`<<-`
[16:21:04.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.079]                   3L)]
[16:21:04.079]             }
[16:21:04.079]             function(cond) {
[16:21:04.079]                 is_error <- inherits(cond, "error")
[16:21:04.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.079]                   NULL)
[16:21:04.079]                 if (is_error) {
[16:21:04.079]                   sessionInformation <- function() {
[16:21:04.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.079]                       search = base::search(), system = base::Sys.info())
[16:21:04.079]                   }
[16:21:04.079]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.079]                     cond$call), session = sessionInformation(), 
[16:21:04.079]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.079]                   signalCondition(cond)
[16:21:04.079]                 }
[16:21:04.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.079]                 "immediateCondition"))) {
[16:21:04.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.079]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.079]                   if (TRUE && !signal) {
[16:21:04.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.079]                     {
[16:21:04.079]                       inherits <- base::inherits
[16:21:04.079]                       invokeRestart <- base::invokeRestart
[16:21:04.079]                       is.null <- base::is.null
[16:21:04.079]                       muffled <- FALSE
[16:21:04.079]                       if (inherits(cond, "message")) {
[16:21:04.079]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.079]                         if (muffled) 
[16:21:04.079]                           invokeRestart("muffleMessage")
[16:21:04.079]                       }
[16:21:04.079]                       else if (inherits(cond, "warning")) {
[16:21:04.079]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.079]                         if (muffled) 
[16:21:04.079]                           invokeRestart("muffleWarning")
[16:21:04.079]                       }
[16:21:04.079]                       else if (inherits(cond, "condition")) {
[16:21:04.079]                         if (!is.null(pattern)) {
[16:21:04.079]                           computeRestarts <- base::computeRestarts
[16:21:04.079]                           grepl <- base::grepl
[16:21:04.079]                           restarts <- computeRestarts(cond)
[16:21:04.079]                           for (restart in restarts) {
[16:21:04.079]                             name <- restart$name
[16:21:04.079]                             if (is.null(name)) 
[16:21:04.079]                               next
[16:21:04.079]                             if (!grepl(pattern, name)) 
[16:21:04.079]                               next
[16:21:04.079]                             invokeRestart(restart)
[16:21:04.079]                             muffled <- TRUE
[16:21:04.079]                             break
[16:21:04.079]                           }
[16:21:04.079]                         }
[16:21:04.079]                       }
[16:21:04.079]                       invisible(muffled)
[16:21:04.079]                     }
[16:21:04.079]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.079]                   }
[16:21:04.079]                 }
[16:21:04.079]                 else {
[16:21:04.079]                   if (TRUE) {
[16:21:04.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.079]                     {
[16:21:04.079]                       inherits <- base::inherits
[16:21:04.079]                       invokeRestart <- base::invokeRestart
[16:21:04.079]                       is.null <- base::is.null
[16:21:04.079]                       muffled <- FALSE
[16:21:04.079]                       if (inherits(cond, "message")) {
[16:21:04.079]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.079]                         if (muffled) 
[16:21:04.079]                           invokeRestart("muffleMessage")
[16:21:04.079]                       }
[16:21:04.079]                       else if (inherits(cond, "warning")) {
[16:21:04.079]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.079]                         if (muffled) 
[16:21:04.079]                           invokeRestart("muffleWarning")
[16:21:04.079]                       }
[16:21:04.079]                       else if (inherits(cond, "condition")) {
[16:21:04.079]                         if (!is.null(pattern)) {
[16:21:04.079]                           computeRestarts <- base::computeRestarts
[16:21:04.079]                           grepl <- base::grepl
[16:21:04.079]                           restarts <- computeRestarts(cond)
[16:21:04.079]                           for (restart in restarts) {
[16:21:04.079]                             name <- restart$name
[16:21:04.079]                             if (is.null(name)) 
[16:21:04.079]                               next
[16:21:04.079]                             if (!grepl(pattern, name)) 
[16:21:04.079]                               next
[16:21:04.079]                             invokeRestart(restart)
[16:21:04.079]                             muffled <- TRUE
[16:21:04.079]                             break
[16:21:04.079]                           }
[16:21:04.079]                         }
[16:21:04.079]                       }
[16:21:04.079]                       invisible(muffled)
[16:21:04.079]                     }
[16:21:04.079]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.079]                   }
[16:21:04.079]                 }
[16:21:04.079]             }
[16:21:04.079]         }))
[16:21:04.079]     }, error = function(ex) {
[16:21:04.079]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.079]                 ...future.rng), started = ...future.startTime, 
[16:21:04.079]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.079]             version = "1.8"), class = "FutureResult")
[16:21:04.079]     }, finally = {
[16:21:04.079]         if (!identical(...future.workdir, getwd())) 
[16:21:04.079]             setwd(...future.workdir)
[16:21:04.079]         {
[16:21:04.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.079]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.079]             }
[16:21:04.079]             base::options(...future.oldOptions)
[16:21:04.079]             if (.Platform$OS.type == "windows") {
[16:21:04.079]                 old_names <- names(...future.oldEnvVars)
[16:21:04.079]                 envs <- base::Sys.getenv()
[16:21:04.079]                 names <- names(envs)
[16:21:04.079]                 common <- intersect(names, old_names)
[16:21:04.079]                 added <- setdiff(names, old_names)
[16:21:04.079]                 removed <- setdiff(old_names, names)
[16:21:04.079]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.079]                   envs[common]]
[16:21:04.079]                 NAMES <- toupper(changed)
[16:21:04.079]                 args <- list()
[16:21:04.079]                 for (kk in seq_along(NAMES)) {
[16:21:04.079]                   name <- changed[[kk]]
[16:21:04.079]                   NAME <- NAMES[[kk]]
[16:21:04.079]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.079]                     next
[16:21:04.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.079]                 }
[16:21:04.079]                 NAMES <- toupper(added)
[16:21:04.079]                 for (kk in seq_along(NAMES)) {
[16:21:04.079]                   name <- added[[kk]]
[16:21:04.079]                   NAME <- NAMES[[kk]]
[16:21:04.079]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.079]                     next
[16:21:04.079]                   args[[name]] <- ""
[16:21:04.079]                 }
[16:21:04.079]                 NAMES <- toupper(removed)
[16:21:04.079]                 for (kk in seq_along(NAMES)) {
[16:21:04.079]                   name <- removed[[kk]]
[16:21:04.079]                   NAME <- NAMES[[kk]]
[16:21:04.079]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.079]                     next
[16:21:04.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.079]                 }
[16:21:04.079]                 if (length(args) > 0) 
[16:21:04.079]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.079]             }
[16:21:04.079]             else {
[16:21:04.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.079]             }
[16:21:04.079]             {
[16:21:04.079]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.079]                   0L) {
[16:21:04.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.079]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.079]                   base::options(opts)
[16:21:04.079]                 }
[16:21:04.079]                 {
[16:21:04.079]                   {
[16:21:04.079]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.079]                     NULL
[16:21:04.079]                   }
[16:21:04.079]                   options(future.plan = NULL)
[16:21:04.079]                   if (is.na(NA_character_)) 
[16:21:04.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.079]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.079]                     .init = FALSE)
[16:21:04.079]                 }
[16:21:04.079]             }
[16:21:04.079]         }
[16:21:04.079]     })
[16:21:04.079]     if (TRUE) {
[16:21:04.079]         base::sink(type = "output", split = FALSE)
[16:21:04.079]         if (TRUE) {
[16:21:04.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.079]         }
[16:21:04.079]         else {
[16:21:04.079]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.079]         }
[16:21:04.079]         base::close(...future.stdout)
[16:21:04.079]         ...future.stdout <- NULL
[16:21:04.079]     }
[16:21:04.079]     ...future.result$conditions <- ...future.conditions
[16:21:04.079]     ...future.result$finished <- base::Sys.time()
[16:21:04.079]     ...future.result
[16:21:04.079] }
[16:21:04.082] requestCore(): workers = 2
[16:21:04.084] MulticoreFuture started
[16:21:04.084] - Launch lazy future ... done
[16:21:04.084] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.085] plan(): Setting new future strategy stack:
[16:21:04.085] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.085] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:04.085] List of future strategies:
[16:21:04.085] 1. sequential:
[16:21:04.085]    - args: function (..., envir = parent.frame())
[16:21:04.085]    - tweaked: FALSE
[16:21:04.085]    - call: NULL
[16:21:04.086] plan(): nbrOfWorkers() = 1
[16:21:04.088] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:04.088] Searching for globals ... DONE
[16:21:04.088] Resolving globals: TRUE
[16:21:04.088] plan(): Setting new future strategy stack:
[16:21:04.088] Resolving any globals that are futures ...
[16:21:04.088] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:04.089] Resolving any globals that are futures ... DONE
[16:21:04.088] List of future strategies:
[16:21:04.088] 1. multicore:
[16:21:04.088]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.088]    - tweaked: FALSE
[16:21:04.088]    - call: plan(strategy)
[16:21:04.089] Resolving futures part of globals (recursively) ...
[16:21:04.090] resolve() on list ...
[16:21:04.090]  recursive: 99
[16:21:04.090]  length: 1
[16:21:04.090]  elements: ‘a’
[16:21:04.093] plan(): nbrOfWorkers() = 2
[16:21:04.094] Future #1
[16:21:04.094] result() for MulticoreFuture ...
[16:21:04.095] result() for MulticoreFuture ...
[16:21:04.095] result() for MulticoreFuture ... done
[16:21:04.095] result() for MulticoreFuture ... done
[16:21:04.095] result() for MulticoreFuture ...
[16:21:04.095] result() for MulticoreFuture ... done
[16:21:04.096] A MulticoreFuture was resolved
[16:21:04.096]  length: 0 (resolved future 1)
[16:21:04.096] resolve() on list ... DONE
[16:21:04.096] - globals: [1] ‘a’
[16:21:04.096] Resolving futures part of globals (recursively) ... DONE
[16:21:04.098] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[16:21:04.098] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[16:21:04.098] - globals: [1] ‘a’
[16:21:04.098] - packages: [1] ‘future’
[16:21:04.098] getGlobalsAndPackages() ... DONE
[16:21:04.099] run() for ‘Future’ ...
[16:21:04.099] - state: ‘created’
[16:21:04.099] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.103] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.103]   - Field: ‘label’
[16:21:04.104]   - Field: ‘local’
[16:21:04.104]   - Field: ‘owner’
[16:21:04.104]   - Field: ‘envir’
[16:21:04.104]   - Field: ‘workers’
[16:21:04.104]   - Field: ‘packages’
[16:21:04.104]   - Field: ‘gc’
[16:21:04.104]   - Field: ‘job’
[16:21:04.105]   - Field: ‘conditions’
[16:21:04.105]   - Field: ‘expr’
[16:21:04.105]   - Field: ‘uuid’
[16:21:04.105]   - Field: ‘seed’
[16:21:04.105]   - Field: ‘version’
[16:21:04.105]   - Field: ‘result’
[16:21:04.105]   - Field: ‘asynchronous’
[16:21:04.105]   - Field: ‘calls’
[16:21:04.105]   - Field: ‘globals’
[16:21:04.106]   - Field: ‘stdout’
[16:21:04.106]   - Field: ‘earlySignal’
[16:21:04.106]   - Field: ‘lazy’
[16:21:04.106]   - Field: ‘state’
[16:21:04.106] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.106] - Launch lazy future ...
[16:21:04.106] Packages needed by the future expression (n = 1): ‘future’
[16:21:04.107] Packages needed by future strategies (n = 0): <none>
[16:21:04.110] {
[16:21:04.110]     {
[16:21:04.110]         {
[16:21:04.110]             ...future.startTime <- base::Sys.time()
[16:21:04.110]             {
[16:21:04.110]                 {
[16:21:04.110]                   {
[16:21:04.110]                     {
[16:21:04.110]                       {
[16:21:04.110]                         base::local({
[16:21:04.110]                           has_future <- base::requireNamespace("future", 
[16:21:04.110]                             quietly = TRUE)
[16:21:04.110]                           if (has_future) {
[16:21:04.110]                             ns <- base::getNamespace("future")
[16:21:04.110]                             version <- ns[[".package"]][["version"]]
[16:21:04.110]                             if (is.null(version)) 
[16:21:04.110]                               version <- utils::packageVersion("future")
[16:21:04.110]                           }
[16:21:04.110]                           else {
[16:21:04.110]                             version <- NULL
[16:21:04.110]                           }
[16:21:04.110]                           if (!has_future || version < "1.8.0") {
[16:21:04.110]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.110]                               "", base::R.version$version.string), 
[16:21:04.110]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:04.110]                                 base::R.version$platform, 8 * 
[16:21:04.110]                                   base::.Machine$sizeof.pointer), 
[16:21:04.110]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.110]                                 "release", "version")], collapse = " "), 
[16:21:04.110]                               hostname = base::Sys.info()[["nodename"]])
[16:21:04.110]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.110]                               info)
[16:21:04.110]                             info <- base::paste(info, collapse = "; ")
[16:21:04.110]                             if (!has_future) {
[16:21:04.110]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.110]                                 info)
[16:21:04.110]                             }
[16:21:04.110]                             else {
[16:21:04.110]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.110]                                 info, version)
[16:21:04.110]                             }
[16:21:04.110]                             base::stop(msg)
[16:21:04.110]                           }
[16:21:04.110]                         })
[16:21:04.110]                       }
[16:21:04.110]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.110]                       base::options(mc.cores = 1L)
[16:21:04.110]                     }
[16:21:04.110]                     base::local({
[16:21:04.110]                       for (pkg in "future") {
[16:21:04.110]                         base::loadNamespace(pkg)
[16:21:04.110]                         base::library(pkg, character.only = TRUE)
[16:21:04.110]                       }
[16:21:04.110]                     })
[16:21:04.110]                   }
[16:21:04.110]                   ...future.strategy.old <- future::plan("list")
[16:21:04.110]                   options(future.plan = NULL)
[16:21:04.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.110]                 }
[16:21:04.110]                 ...future.workdir <- getwd()
[16:21:04.110]             }
[16:21:04.110]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.110]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.110]         }
[16:21:04.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.110]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.110]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.110]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.110]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.110]             base::names(...future.oldOptions))
[16:21:04.110]     }
[16:21:04.110]     if (FALSE) {
[16:21:04.110]     }
[16:21:04.110]     else {
[16:21:04.110]         if (TRUE) {
[16:21:04.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.110]                 open = "w")
[16:21:04.110]         }
[16:21:04.110]         else {
[16:21:04.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.110]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.110]         }
[16:21:04.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.110]             base::sink(type = "output", split = FALSE)
[16:21:04.110]             base::close(...future.stdout)
[16:21:04.110]         }, add = TRUE)
[16:21:04.110]     }
[16:21:04.110]     ...future.frame <- base::sys.nframe()
[16:21:04.110]     ...future.conditions <- base::list()
[16:21:04.110]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.110]     if (FALSE) {
[16:21:04.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.110]     }
[16:21:04.110]     ...future.result <- base::tryCatch({
[16:21:04.110]         base::withCallingHandlers({
[16:21:04.110]             ...future.value <- base::withVisible(base::local({
[16:21:04.110]                 withCallingHandlers({
[16:21:04.110]                   value(a) + 1
[16:21:04.110]                 }, immediateCondition = function(cond) {
[16:21:04.110]                   save_rds <- function (object, pathname, ...) 
[16:21:04.110]                   {
[16:21:04.110]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.110]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.110]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.110]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.110]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.110]                         fi_tmp[["mtime"]])
[16:21:04.110]                     }
[16:21:04.110]                     tryCatch({
[16:21:04.110]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.110]                     }, error = function(ex) {
[16:21:04.110]                       msg <- conditionMessage(ex)
[16:21:04.110]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.110]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.110]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.110]                         fi_tmp[["mtime"]], msg)
[16:21:04.110]                       ex$message <- msg
[16:21:04.110]                       stop(ex)
[16:21:04.110]                     })
[16:21:04.110]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.110]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.110]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.110]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.110]                       fi <- file.info(pathname)
[16:21:04.110]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.110]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.110]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.110]                         fi[["size"]], fi[["mtime"]])
[16:21:04.110]                       stop(msg)
[16:21:04.110]                     }
[16:21:04.110]                     invisible(pathname)
[16:21:04.110]                   }
[16:21:04.110]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.110]                     rootPath = tempdir()) 
[16:21:04.110]                   {
[16:21:04.110]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.110]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.110]                       tmpdir = path, fileext = ".rds")
[16:21:04.110]                     save_rds(obj, file)
[16:21:04.110]                   }
[16:21:04.110]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.110]                   {
[16:21:04.110]                     inherits <- base::inherits
[16:21:04.110]                     invokeRestart <- base::invokeRestart
[16:21:04.110]                     is.null <- base::is.null
[16:21:04.110]                     muffled <- FALSE
[16:21:04.110]                     if (inherits(cond, "message")) {
[16:21:04.110]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.110]                       if (muffled) 
[16:21:04.110]                         invokeRestart("muffleMessage")
[16:21:04.110]                     }
[16:21:04.110]                     else if (inherits(cond, "warning")) {
[16:21:04.110]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.110]                       if (muffled) 
[16:21:04.110]                         invokeRestart("muffleWarning")
[16:21:04.110]                     }
[16:21:04.110]                     else if (inherits(cond, "condition")) {
[16:21:04.110]                       if (!is.null(pattern)) {
[16:21:04.110]                         computeRestarts <- base::computeRestarts
[16:21:04.110]                         grepl <- base::grepl
[16:21:04.110]                         restarts <- computeRestarts(cond)
[16:21:04.110]                         for (restart in restarts) {
[16:21:04.110]                           name <- restart$name
[16:21:04.110]                           if (is.null(name)) 
[16:21:04.110]                             next
[16:21:04.110]                           if (!grepl(pattern, name)) 
[16:21:04.110]                             next
[16:21:04.110]                           invokeRestart(restart)
[16:21:04.110]                           muffled <- TRUE
[16:21:04.110]                           break
[16:21:04.110]                         }
[16:21:04.110]                       }
[16:21:04.110]                     }
[16:21:04.110]                     invisible(muffled)
[16:21:04.110]                   }
[16:21:04.110]                   muffleCondition(cond)
[16:21:04.110]                 })
[16:21:04.110]             }))
[16:21:04.110]             future::FutureResult(value = ...future.value$value, 
[16:21:04.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.110]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.110]                     ...future.globalenv.names))
[16:21:04.110]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.110]         }, condition = base::local({
[16:21:04.110]             c <- base::c
[16:21:04.110]             inherits <- base::inherits
[16:21:04.110]             invokeRestart <- base::invokeRestart
[16:21:04.110]             length <- base::length
[16:21:04.110]             list <- base::list
[16:21:04.110]             seq.int <- base::seq.int
[16:21:04.110]             signalCondition <- base::signalCondition
[16:21:04.110]             sys.calls <- base::sys.calls
[16:21:04.110]             `[[` <- base::`[[`
[16:21:04.110]             `+` <- base::`+`
[16:21:04.110]             `<<-` <- base::`<<-`
[16:21:04.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.110]                   3L)]
[16:21:04.110]             }
[16:21:04.110]             function(cond) {
[16:21:04.110]                 is_error <- inherits(cond, "error")
[16:21:04.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.110]                   NULL)
[16:21:04.110]                 if (is_error) {
[16:21:04.110]                   sessionInformation <- function() {
[16:21:04.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.110]                       search = base::search(), system = base::Sys.info())
[16:21:04.110]                   }
[16:21:04.110]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.110]                     cond$call), session = sessionInformation(), 
[16:21:04.110]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.110]                   signalCondition(cond)
[16:21:04.110]                 }
[16:21:04.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.110]                 "immediateCondition"))) {
[16:21:04.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.110]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.110]                   if (TRUE && !signal) {
[16:21:04.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.110]                     {
[16:21:04.110]                       inherits <- base::inherits
[16:21:04.110]                       invokeRestart <- base::invokeRestart
[16:21:04.110]                       is.null <- base::is.null
[16:21:04.110]                       muffled <- FALSE
[16:21:04.110]                       if (inherits(cond, "message")) {
[16:21:04.110]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.110]                         if (muffled) 
[16:21:04.110]                           invokeRestart("muffleMessage")
[16:21:04.110]                       }
[16:21:04.110]                       else if (inherits(cond, "warning")) {
[16:21:04.110]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.110]                         if (muffled) 
[16:21:04.110]                           invokeRestart("muffleWarning")
[16:21:04.110]                       }
[16:21:04.110]                       else if (inherits(cond, "condition")) {
[16:21:04.110]                         if (!is.null(pattern)) {
[16:21:04.110]                           computeRestarts <- base::computeRestarts
[16:21:04.110]                           grepl <- base::grepl
[16:21:04.110]                           restarts <- computeRestarts(cond)
[16:21:04.110]                           for (restart in restarts) {
[16:21:04.110]                             name <- restart$name
[16:21:04.110]                             if (is.null(name)) 
[16:21:04.110]                               next
[16:21:04.110]                             if (!grepl(pattern, name)) 
[16:21:04.110]                               next
[16:21:04.110]                             invokeRestart(restart)
[16:21:04.110]                             muffled <- TRUE
[16:21:04.110]                             break
[16:21:04.110]                           }
[16:21:04.110]                         }
[16:21:04.110]                       }
[16:21:04.110]                       invisible(muffled)
[16:21:04.110]                     }
[16:21:04.110]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.110]                   }
[16:21:04.110]                 }
[16:21:04.110]                 else {
[16:21:04.110]                   if (TRUE) {
[16:21:04.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.110]                     {
[16:21:04.110]                       inherits <- base::inherits
[16:21:04.110]                       invokeRestart <- base::invokeRestart
[16:21:04.110]                       is.null <- base::is.null
[16:21:04.110]                       muffled <- FALSE
[16:21:04.110]                       if (inherits(cond, "message")) {
[16:21:04.110]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.110]                         if (muffled) 
[16:21:04.110]                           invokeRestart("muffleMessage")
[16:21:04.110]                       }
[16:21:04.110]                       else if (inherits(cond, "warning")) {
[16:21:04.110]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.110]                         if (muffled) 
[16:21:04.110]                           invokeRestart("muffleWarning")
[16:21:04.110]                       }
[16:21:04.110]                       else if (inherits(cond, "condition")) {
[16:21:04.110]                         if (!is.null(pattern)) {
[16:21:04.110]                           computeRestarts <- base::computeRestarts
[16:21:04.110]                           grepl <- base::grepl
[16:21:04.110]                           restarts <- computeRestarts(cond)
[16:21:04.110]                           for (restart in restarts) {
[16:21:04.110]                             name <- restart$name
[16:21:04.110]                             if (is.null(name)) 
[16:21:04.110]                               next
[16:21:04.110]                             if (!grepl(pattern, name)) 
[16:21:04.110]                               next
[16:21:04.110]                             invokeRestart(restart)
[16:21:04.110]                             muffled <- TRUE
[16:21:04.110]                             break
[16:21:04.110]                           }
[16:21:04.110]                         }
[16:21:04.110]                       }
[16:21:04.110]                       invisible(muffled)
[16:21:04.110]                     }
[16:21:04.110]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.110]                   }
[16:21:04.110]                 }
[16:21:04.110]             }
[16:21:04.110]         }))
[16:21:04.110]     }, error = function(ex) {
[16:21:04.110]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.110]                 ...future.rng), started = ...future.startTime, 
[16:21:04.110]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.110]             version = "1.8"), class = "FutureResult")
[16:21:04.110]     }, finally = {
[16:21:04.110]         if (!identical(...future.workdir, getwd())) 
[16:21:04.110]             setwd(...future.workdir)
[16:21:04.110]         {
[16:21:04.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.110]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.110]             }
[16:21:04.110]             base::options(...future.oldOptions)
[16:21:04.110]             if (.Platform$OS.type == "windows") {
[16:21:04.110]                 old_names <- names(...future.oldEnvVars)
[16:21:04.110]                 envs <- base::Sys.getenv()
[16:21:04.110]                 names <- names(envs)
[16:21:04.110]                 common <- intersect(names, old_names)
[16:21:04.110]                 added <- setdiff(names, old_names)
[16:21:04.110]                 removed <- setdiff(old_names, names)
[16:21:04.110]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.110]                   envs[common]]
[16:21:04.110]                 NAMES <- toupper(changed)
[16:21:04.110]                 args <- list()
[16:21:04.110]                 for (kk in seq_along(NAMES)) {
[16:21:04.110]                   name <- changed[[kk]]
[16:21:04.110]                   NAME <- NAMES[[kk]]
[16:21:04.110]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.110]                     next
[16:21:04.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.110]                 }
[16:21:04.110]                 NAMES <- toupper(added)
[16:21:04.110]                 for (kk in seq_along(NAMES)) {
[16:21:04.110]                   name <- added[[kk]]
[16:21:04.110]                   NAME <- NAMES[[kk]]
[16:21:04.110]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.110]                     next
[16:21:04.110]                   args[[name]] <- ""
[16:21:04.110]                 }
[16:21:04.110]                 NAMES <- toupper(removed)
[16:21:04.110]                 for (kk in seq_along(NAMES)) {
[16:21:04.110]                   name <- removed[[kk]]
[16:21:04.110]                   NAME <- NAMES[[kk]]
[16:21:04.110]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.110]                     next
[16:21:04.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.110]                 }
[16:21:04.110]                 if (length(args) > 0) 
[16:21:04.110]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.110]             }
[16:21:04.110]             else {
[16:21:04.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.110]             }
[16:21:04.110]             {
[16:21:04.110]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.110]                   0L) {
[16:21:04.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.110]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.110]                   base::options(opts)
[16:21:04.110]                 }
[16:21:04.110]                 {
[16:21:04.110]                   {
[16:21:04.110]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.110]                     NULL
[16:21:04.110]                   }
[16:21:04.110]                   options(future.plan = NULL)
[16:21:04.110]                   if (is.na(NA_character_)) 
[16:21:04.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.110]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.110]                     .init = FALSE)
[16:21:04.110]                 }
[16:21:04.110]             }
[16:21:04.110]         }
[16:21:04.110]     })
[16:21:04.110]     if (TRUE) {
[16:21:04.110]         base::sink(type = "output", split = FALSE)
[16:21:04.110]         if (TRUE) {
[16:21:04.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.110]         }
[16:21:04.110]         else {
[16:21:04.110]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.110]         }
[16:21:04.110]         base::close(...future.stdout)
[16:21:04.110]         ...future.stdout <- NULL
[16:21:04.110]     }
[16:21:04.110]     ...future.result$conditions <- ...future.conditions
[16:21:04.110]     ...future.result$finished <- base::Sys.time()
[16:21:04.110]     ...future.result
[16:21:04.110] }
[16:21:04.112] assign_globals() ...
[16:21:04.112] List of 1
[16:21:04.112]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56222701f070> 
[16:21:04.112]  - attr(*, "where")=List of 1
[16:21:04.112]   ..$ a:<environment: R_EmptyEnv> 
[16:21:04.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.112]  - attr(*, "resolved")= logi TRUE
[16:21:04.112]  - attr(*, "total_size")= num 10816
[16:21:04.112]  - attr(*, "already-done")= logi TRUE
[16:21:04.116] - copied ‘a’ to environment
[16:21:04.116] assign_globals() ... done
[16:21:04.116] requestCore(): workers = 2
[16:21:04.118] MulticoreFuture started
[16:21:04.119] - Launch lazy future ... done
[16:21:04.119] run() for ‘MulticoreFuture’ ... done
[16:21:04.120] result() for MulticoreFuture ...
[16:21:04.120] plan(): Setting new future strategy stack:
[16:21:04.120] List of future strategies:
[16:21:04.120] 1. sequential:
[16:21:04.120]    - args: function (..., envir = parent.frame())
[16:21:04.120]    - tweaked: FALSE
[16:21:04.120]    - call: NULL
[16:21:04.122] plan(): nbrOfWorkers() = 1
[16:21:04.125] plan(): Setting new future strategy stack:
[16:21:04.125] List of future strategies:
[16:21:04.125] 1. multicore:
[16:21:04.125]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.125]    - tweaked: FALSE
[16:21:04.125]    - call: plan(strategy)
[16:21:04.131] plan(): nbrOfWorkers() = 2
[16:21:04.132] result() for MulticoreFuture ...
[16:21:04.132] result() for MulticoreFuture ... done
[16:21:04.132] signalConditions() ...
[16:21:04.132]  - include = ‘immediateCondition’
[16:21:04.132]  - exclude = 
[16:21:04.132]  - resignal = FALSE
[16:21:04.132]  - Number of conditions: 4
[16:21:04.133] signalConditions() ... done
[16:21:04.133] result() for MulticoreFuture ... done
[16:21:04.133] result() for MulticoreFuture ...
[16:21:04.133] result() for MulticoreFuture ... done
[16:21:04.133] signalConditions() ...
[16:21:04.133]  - include = ‘immediateCondition’
[16:21:04.133]  - exclude = 
[16:21:04.134]  - resignal = FALSE
[16:21:04.134]  - Number of conditions: 4
[16:21:04.134] signalConditions() ... done
[16:21:04.134] Future state: ‘finished’
[16:21:04.134] result() for MulticoreFuture ...
[16:21:04.134] result() for MulticoreFuture ... done
[16:21:04.134] signalConditions() ...
[16:21:04.134]  - include = ‘condition’
[16:21:04.135]  - exclude = ‘immediateCondition’
[16:21:04.135]  - resignal = TRUE
[16:21:04.135]  - Number of conditions: 4
[16:21:04.135]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.123] result() for MulticoreFuture ...
[16:21:04.135]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.123] result() for MulticoreFuture ... done
[16:21:04.135]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.124] result() for MulticoreFuture ...
[16:21:04.135]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.124] result() for MulticoreFuture ... done
[16:21:04.136] signalConditions() ... done
value(b) = 2
[16:21:04.136] result() for MulticoreFuture ...
[16:21:04.136] result() for MulticoreFuture ... done
[16:21:04.136] result() for MulticoreFuture ...
[16:21:04.136] result() for MulticoreFuture ... done
[16:21:04.136] signalConditions() ...
[16:21:04.137]  - include = ‘immediateCondition’
[16:21:04.137]  - exclude = 
[16:21:04.137]  - resignal = FALSE
[16:21:04.137]  - Number of conditions: 4
[16:21:04.137] signalConditions() ... done
[16:21:04.137] Future state: ‘finished’
[16:21:04.137] result() for MulticoreFuture ...
[16:21:04.137] result() for MulticoreFuture ... done
[16:21:04.137] signalConditions() ...
[16:21:04.138]  - include = ‘condition’
[16:21:04.138]  - exclude = ‘immediateCondition’
[16:21:04.138]  - resignal = TRUE
[16:21:04.138]  - Number of conditions: 4
[16:21:04.138]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.123] result() for MulticoreFuture ...
[16:21:04.138]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.123] result() for MulticoreFuture ... done
[16:21:04.138]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.124] result() for MulticoreFuture ...
[16:21:04.139]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.124] result() for MulticoreFuture ... done
[16:21:04.139] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.139] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.139] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:04.140] 
[16:21:04.140] Searching for globals ... DONE
[16:21:04.140] - globals: [0] <none>
[16:21:04.140] getGlobalsAndPackages() ... DONE
[16:21:04.141] run() for ‘Future’ ...
[16:21:04.141] - state: ‘created’
[16:21:04.141] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.146] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.146]   - Field: ‘label’
[16:21:04.146]   - Field: ‘local’
[16:21:04.146]   - Field: ‘owner’
[16:21:04.147]   - Field: ‘envir’
[16:21:04.147]   - Field: ‘workers’
[16:21:04.147]   - Field: ‘packages’
[16:21:04.147]   - Field: ‘gc’
[16:21:04.147]   - Field: ‘job’
[16:21:04.147]   - Field: ‘conditions’
[16:21:04.147]   - Field: ‘expr’
[16:21:04.147]   - Field: ‘uuid’
[16:21:04.147]   - Field: ‘seed’
[16:21:04.148]   - Field: ‘version’
[16:21:04.148]   - Field: ‘result’
[16:21:04.148]   - Field: ‘asynchronous’
[16:21:04.148]   - Field: ‘calls’
[16:21:04.148]   - Field: ‘globals’
[16:21:04.148]   - Field: ‘stdout’
[16:21:04.148]   - Field: ‘earlySignal’
[16:21:04.148]   - Field: ‘lazy’
[16:21:04.149]   - Field: ‘state’
[16:21:04.149] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.149] - Launch lazy future ...
[16:21:04.149] Packages needed by the future expression (n = 0): <none>
[16:21:04.149] Packages needed by future strategies (n = 0): <none>
[16:21:04.150] {
[16:21:04.150]     {
[16:21:04.150]         {
[16:21:04.150]             ...future.startTime <- base::Sys.time()
[16:21:04.150]             {
[16:21:04.150]                 {
[16:21:04.150]                   {
[16:21:04.150]                     {
[16:21:04.150]                       base::local({
[16:21:04.150]                         has_future <- base::requireNamespace("future", 
[16:21:04.150]                           quietly = TRUE)
[16:21:04.150]                         if (has_future) {
[16:21:04.150]                           ns <- base::getNamespace("future")
[16:21:04.150]                           version <- ns[[".package"]][["version"]]
[16:21:04.150]                           if (is.null(version)) 
[16:21:04.150]                             version <- utils::packageVersion("future")
[16:21:04.150]                         }
[16:21:04.150]                         else {
[16:21:04.150]                           version <- NULL
[16:21:04.150]                         }
[16:21:04.150]                         if (!has_future || version < "1.8.0") {
[16:21:04.150]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.150]                             "", base::R.version$version.string), 
[16:21:04.150]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.150]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.150]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.150]                               "release", "version")], collapse = " "), 
[16:21:04.150]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.150]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.150]                             info)
[16:21:04.150]                           info <- base::paste(info, collapse = "; ")
[16:21:04.150]                           if (!has_future) {
[16:21:04.150]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.150]                               info)
[16:21:04.150]                           }
[16:21:04.150]                           else {
[16:21:04.150]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.150]                               info, version)
[16:21:04.150]                           }
[16:21:04.150]                           base::stop(msg)
[16:21:04.150]                         }
[16:21:04.150]                       })
[16:21:04.150]                     }
[16:21:04.150]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.150]                     base::options(mc.cores = 1L)
[16:21:04.150]                   }
[16:21:04.150]                   ...future.strategy.old <- future::plan("list")
[16:21:04.150]                   options(future.plan = NULL)
[16:21:04.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.150]                 }
[16:21:04.150]                 ...future.workdir <- getwd()
[16:21:04.150]             }
[16:21:04.150]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.150]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.150]         }
[16:21:04.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.150]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.150]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.150]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.150]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.150]             base::names(...future.oldOptions))
[16:21:04.150]     }
[16:21:04.150]     if (FALSE) {
[16:21:04.150]     }
[16:21:04.150]     else {
[16:21:04.150]         if (TRUE) {
[16:21:04.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.150]                 open = "w")
[16:21:04.150]         }
[16:21:04.150]         else {
[16:21:04.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.150]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.150]         }
[16:21:04.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.150]             base::sink(type = "output", split = FALSE)
[16:21:04.150]             base::close(...future.stdout)
[16:21:04.150]         }, add = TRUE)
[16:21:04.150]     }
[16:21:04.150]     ...future.frame <- base::sys.nframe()
[16:21:04.150]     ...future.conditions <- base::list()
[16:21:04.150]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.150]     if (FALSE) {
[16:21:04.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.150]     }
[16:21:04.150]     ...future.result <- base::tryCatch({
[16:21:04.150]         base::withCallingHandlers({
[16:21:04.150]             ...future.value <- base::withVisible(base::local({
[16:21:04.150]                 withCallingHandlers({
[16:21:04.150]                   1
[16:21:04.150]                 }, immediateCondition = function(cond) {
[16:21:04.150]                   save_rds <- function (object, pathname, ...) 
[16:21:04.150]                   {
[16:21:04.150]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.150]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.150]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.150]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.150]                         fi_tmp[["mtime"]])
[16:21:04.150]                     }
[16:21:04.150]                     tryCatch({
[16:21:04.150]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.150]                     }, error = function(ex) {
[16:21:04.150]                       msg <- conditionMessage(ex)
[16:21:04.150]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.150]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.150]                         fi_tmp[["mtime"]], msg)
[16:21:04.150]                       ex$message <- msg
[16:21:04.150]                       stop(ex)
[16:21:04.150]                     })
[16:21:04.150]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.150]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.150]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.150]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.150]                       fi <- file.info(pathname)
[16:21:04.150]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.150]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.150]                         fi[["size"]], fi[["mtime"]])
[16:21:04.150]                       stop(msg)
[16:21:04.150]                     }
[16:21:04.150]                     invisible(pathname)
[16:21:04.150]                   }
[16:21:04.150]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.150]                     rootPath = tempdir()) 
[16:21:04.150]                   {
[16:21:04.150]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.150]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.150]                       tmpdir = path, fileext = ".rds")
[16:21:04.150]                     save_rds(obj, file)
[16:21:04.150]                   }
[16:21:04.150]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.150]                   {
[16:21:04.150]                     inherits <- base::inherits
[16:21:04.150]                     invokeRestart <- base::invokeRestart
[16:21:04.150]                     is.null <- base::is.null
[16:21:04.150]                     muffled <- FALSE
[16:21:04.150]                     if (inherits(cond, "message")) {
[16:21:04.150]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.150]                       if (muffled) 
[16:21:04.150]                         invokeRestart("muffleMessage")
[16:21:04.150]                     }
[16:21:04.150]                     else if (inherits(cond, "warning")) {
[16:21:04.150]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.150]                       if (muffled) 
[16:21:04.150]                         invokeRestart("muffleWarning")
[16:21:04.150]                     }
[16:21:04.150]                     else if (inherits(cond, "condition")) {
[16:21:04.150]                       if (!is.null(pattern)) {
[16:21:04.150]                         computeRestarts <- base::computeRestarts
[16:21:04.150]                         grepl <- base::grepl
[16:21:04.150]                         restarts <- computeRestarts(cond)
[16:21:04.150]                         for (restart in restarts) {
[16:21:04.150]                           name <- restart$name
[16:21:04.150]                           if (is.null(name)) 
[16:21:04.150]                             next
[16:21:04.150]                           if (!grepl(pattern, name)) 
[16:21:04.150]                             next
[16:21:04.150]                           invokeRestart(restart)
[16:21:04.150]                           muffled <- TRUE
[16:21:04.150]                           break
[16:21:04.150]                         }
[16:21:04.150]                       }
[16:21:04.150]                     }
[16:21:04.150]                     invisible(muffled)
[16:21:04.150]                   }
[16:21:04.150]                   muffleCondition(cond)
[16:21:04.150]                 })
[16:21:04.150]             }))
[16:21:04.150]             future::FutureResult(value = ...future.value$value, 
[16:21:04.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.150]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.150]                     ...future.globalenv.names))
[16:21:04.150]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.150]         }, condition = base::local({
[16:21:04.150]             c <- base::c
[16:21:04.150]             inherits <- base::inherits
[16:21:04.150]             invokeRestart <- base::invokeRestart
[16:21:04.150]             length <- base::length
[16:21:04.150]             list <- base::list
[16:21:04.150]             seq.int <- base::seq.int
[16:21:04.150]             signalCondition <- base::signalCondition
[16:21:04.150]             sys.calls <- base::sys.calls
[16:21:04.150]             `[[` <- base::`[[`
[16:21:04.150]             `+` <- base::`+`
[16:21:04.150]             `<<-` <- base::`<<-`
[16:21:04.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.150]                   3L)]
[16:21:04.150]             }
[16:21:04.150]             function(cond) {
[16:21:04.150]                 is_error <- inherits(cond, "error")
[16:21:04.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.150]                   NULL)
[16:21:04.150]                 if (is_error) {
[16:21:04.150]                   sessionInformation <- function() {
[16:21:04.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.150]                       search = base::search(), system = base::Sys.info())
[16:21:04.150]                   }
[16:21:04.150]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.150]                     cond$call), session = sessionInformation(), 
[16:21:04.150]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.150]                   signalCondition(cond)
[16:21:04.150]                 }
[16:21:04.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.150]                 "immediateCondition"))) {
[16:21:04.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.150]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.150]                   if (TRUE && !signal) {
[16:21:04.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.150]                     {
[16:21:04.150]                       inherits <- base::inherits
[16:21:04.150]                       invokeRestart <- base::invokeRestart
[16:21:04.150]                       is.null <- base::is.null
[16:21:04.150]                       muffled <- FALSE
[16:21:04.150]                       if (inherits(cond, "message")) {
[16:21:04.150]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.150]                         if (muffled) 
[16:21:04.150]                           invokeRestart("muffleMessage")
[16:21:04.150]                       }
[16:21:04.150]                       else if (inherits(cond, "warning")) {
[16:21:04.150]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.150]                         if (muffled) 
[16:21:04.150]                           invokeRestart("muffleWarning")
[16:21:04.150]                       }
[16:21:04.150]                       else if (inherits(cond, "condition")) {
[16:21:04.150]                         if (!is.null(pattern)) {
[16:21:04.150]                           computeRestarts <- base::computeRestarts
[16:21:04.150]                           grepl <- base::grepl
[16:21:04.150]                           restarts <- computeRestarts(cond)
[16:21:04.150]                           for (restart in restarts) {
[16:21:04.150]                             name <- restart$name
[16:21:04.150]                             if (is.null(name)) 
[16:21:04.150]                               next
[16:21:04.150]                             if (!grepl(pattern, name)) 
[16:21:04.150]                               next
[16:21:04.150]                             invokeRestart(restart)
[16:21:04.150]                             muffled <- TRUE
[16:21:04.150]                             break
[16:21:04.150]                           }
[16:21:04.150]                         }
[16:21:04.150]                       }
[16:21:04.150]                       invisible(muffled)
[16:21:04.150]                     }
[16:21:04.150]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.150]                   }
[16:21:04.150]                 }
[16:21:04.150]                 else {
[16:21:04.150]                   if (TRUE) {
[16:21:04.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.150]                     {
[16:21:04.150]                       inherits <- base::inherits
[16:21:04.150]                       invokeRestart <- base::invokeRestart
[16:21:04.150]                       is.null <- base::is.null
[16:21:04.150]                       muffled <- FALSE
[16:21:04.150]                       if (inherits(cond, "message")) {
[16:21:04.150]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.150]                         if (muffled) 
[16:21:04.150]                           invokeRestart("muffleMessage")
[16:21:04.150]                       }
[16:21:04.150]                       else if (inherits(cond, "warning")) {
[16:21:04.150]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.150]                         if (muffled) 
[16:21:04.150]                           invokeRestart("muffleWarning")
[16:21:04.150]                       }
[16:21:04.150]                       else if (inherits(cond, "condition")) {
[16:21:04.150]                         if (!is.null(pattern)) {
[16:21:04.150]                           computeRestarts <- base::computeRestarts
[16:21:04.150]                           grepl <- base::grepl
[16:21:04.150]                           restarts <- computeRestarts(cond)
[16:21:04.150]                           for (restart in restarts) {
[16:21:04.150]                             name <- restart$name
[16:21:04.150]                             if (is.null(name)) 
[16:21:04.150]                               next
[16:21:04.150]                             if (!grepl(pattern, name)) 
[16:21:04.150]                               next
[16:21:04.150]                             invokeRestart(restart)
[16:21:04.150]                             muffled <- TRUE
[16:21:04.150]                             break
[16:21:04.150]                           }
[16:21:04.150]                         }
[16:21:04.150]                       }
[16:21:04.150]                       invisible(muffled)
[16:21:04.150]                     }
[16:21:04.150]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.150]                   }
[16:21:04.150]                 }
[16:21:04.150]             }
[16:21:04.150]         }))
[16:21:04.150]     }, error = function(ex) {
[16:21:04.150]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.150]                 ...future.rng), started = ...future.startTime, 
[16:21:04.150]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.150]             version = "1.8"), class = "FutureResult")
[16:21:04.150]     }, finally = {
[16:21:04.150]         if (!identical(...future.workdir, getwd())) 
[16:21:04.150]             setwd(...future.workdir)
[16:21:04.150]         {
[16:21:04.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.150]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.150]             }
[16:21:04.150]             base::options(...future.oldOptions)
[16:21:04.150]             if (.Platform$OS.type == "windows") {
[16:21:04.150]                 old_names <- names(...future.oldEnvVars)
[16:21:04.150]                 envs <- base::Sys.getenv()
[16:21:04.150]                 names <- names(envs)
[16:21:04.150]                 common <- intersect(names, old_names)
[16:21:04.150]                 added <- setdiff(names, old_names)
[16:21:04.150]                 removed <- setdiff(old_names, names)
[16:21:04.150]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.150]                   envs[common]]
[16:21:04.150]                 NAMES <- toupper(changed)
[16:21:04.150]                 args <- list()
[16:21:04.150]                 for (kk in seq_along(NAMES)) {
[16:21:04.150]                   name <- changed[[kk]]
[16:21:04.150]                   NAME <- NAMES[[kk]]
[16:21:04.150]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.150]                     next
[16:21:04.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.150]                 }
[16:21:04.150]                 NAMES <- toupper(added)
[16:21:04.150]                 for (kk in seq_along(NAMES)) {
[16:21:04.150]                   name <- added[[kk]]
[16:21:04.150]                   NAME <- NAMES[[kk]]
[16:21:04.150]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.150]                     next
[16:21:04.150]                   args[[name]] <- ""
[16:21:04.150]                 }
[16:21:04.150]                 NAMES <- toupper(removed)
[16:21:04.150]                 for (kk in seq_along(NAMES)) {
[16:21:04.150]                   name <- removed[[kk]]
[16:21:04.150]                   NAME <- NAMES[[kk]]
[16:21:04.150]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.150]                     next
[16:21:04.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.150]                 }
[16:21:04.150]                 if (length(args) > 0) 
[16:21:04.150]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.150]             }
[16:21:04.150]             else {
[16:21:04.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.150]             }
[16:21:04.150]             {
[16:21:04.150]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.150]                   0L) {
[16:21:04.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.150]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.150]                   base::options(opts)
[16:21:04.150]                 }
[16:21:04.150]                 {
[16:21:04.150]                   {
[16:21:04.150]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.150]                     NULL
[16:21:04.150]                   }
[16:21:04.150]                   options(future.plan = NULL)
[16:21:04.150]                   if (is.na(NA_character_)) 
[16:21:04.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.150]                     .init = FALSE)
[16:21:04.150]                 }
[16:21:04.150]             }
[16:21:04.150]         }
[16:21:04.150]     })
[16:21:04.150]     if (TRUE) {
[16:21:04.150]         base::sink(type = "output", split = FALSE)
[16:21:04.150]         if (TRUE) {
[16:21:04.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.150]         }
[16:21:04.150]         else {
[16:21:04.150]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.150]         }
[16:21:04.150]         base::close(...future.stdout)
[16:21:04.150]         ...future.stdout <- NULL
[16:21:04.150]     }
[16:21:04.150]     ...future.result$conditions <- ...future.conditions
[16:21:04.150]     ...future.result$finished <- base::Sys.time()
[16:21:04.150]     ...future.result
[16:21:04.150] }
[16:21:04.152] requestCore(): workers = 2
[16:21:04.154] MulticoreFuture started
[16:21:04.155] - Launch lazy future ... done
[16:21:04.155] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.155] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.156] plan(): Setting new future strategy stack:
[16:21:04.156] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:04.156] List of future strategies:
[16:21:04.156] 1. sequential:
[16:21:04.156]    - args: function (..., envir = parent.frame())
[16:21:04.156]    - tweaked: FALSE
[16:21:04.156]    - call: NULL
[16:21:04.157] plan(): nbrOfWorkers() = 1
[16:21:04.159] plan(): Setting new future strategy stack:
[16:21:04.162] List of future strategies:
[16:21:04.162] 1. multicore:
[16:21:04.162]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.162]    - tweaked: FALSE
[16:21:04.162]    - call: plan(strategy)
[16:21:04.163] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:04.164] Searching for globals ... DONE
[16:21:04.164] Resolving globals: TRUE
[16:21:04.165] Resolving any globals that are futures ...
[16:21:04.165] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:04.165] Resolving any globals that are futures ... DONE
[16:21:04.166] Resolving futures part of globals (recursively) ...
[16:21:04.167] resolve() on list ...
[16:21:04.167]  recursive: 99
[16:21:04.168]  length: 1
[16:21:04.168]  elements: ‘a’
[16:21:04.169] plan(): nbrOfWorkers() = 2
[16:21:04.169] Future #1
[16:21:04.170] result() for MulticoreFuture ...
[16:21:04.171] result() for MulticoreFuture ...
[16:21:04.171] result() for MulticoreFuture ... done
[16:21:04.171] result() for MulticoreFuture ... done
[16:21:04.172] result() for MulticoreFuture ...
[16:21:04.172] result() for MulticoreFuture ... done
[16:21:04.172] A MulticoreFuture was resolved
[16:21:04.172]  length: 0 (resolved future 1)
[16:21:04.173] resolve() on list ... DONE
[16:21:04.173] - globals: [1] ‘a’
[16:21:04.173] Resolving futures part of globals (recursively) ... DONE
[16:21:04.175] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[16:21:04.175] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[16:21:04.175] - globals: [1] ‘a’
[16:21:04.175] - packages: [1] ‘future’
[16:21:04.176] getGlobalsAndPackages() ... DONE
[16:21:04.176] run() for ‘Future’ ...
[16:21:04.176] - state: ‘created’
[16:21:04.176] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.180] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.181]   - Field: ‘label’
[16:21:04.181]   - Field: ‘local’
[16:21:04.181]   - Field: ‘owner’
[16:21:04.181]   - Field: ‘envir’
[16:21:04.181]   - Field: ‘workers’
[16:21:04.181]   - Field: ‘packages’
[16:21:04.181]   - Field: ‘gc’
[16:21:04.181]   - Field: ‘job’
[16:21:04.181]   - Field: ‘conditions’
[16:21:04.182]   - Field: ‘expr’
[16:21:04.182]   - Field: ‘uuid’
[16:21:04.182]   - Field: ‘seed’
[16:21:04.182]   - Field: ‘version’
[16:21:04.182]   - Field: ‘result’
[16:21:04.182]   - Field: ‘asynchronous’
[16:21:04.182]   - Field: ‘calls’
[16:21:04.182]   - Field: ‘globals’
[16:21:04.182]   - Field: ‘stdout’
[16:21:04.183]   - Field: ‘earlySignal’
[16:21:04.183]   - Field: ‘lazy’
[16:21:04.183]   - Field: ‘state’
[16:21:04.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.183] - Launch lazy future ...
[16:21:04.183] Packages needed by the future expression (n = 1): ‘future’
[16:21:04.183] Packages needed by future strategies (n = 0): <none>
[16:21:04.184] {
[16:21:04.184]     {
[16:21:04.184]         {
[16:21:04.184]             ...future.startTime <- base::Sys.time()
[16:21:04.184]             {
[16:21:04.184]                 {
[16:21:04.184]                   {
[16:21:04.184]                     {
[16:21:04.184]                       {
[16:21:04.184]                         base::local({
[16:21:04.184]                           has_future <- base::requireNamespace("future", 
[16:21:04.184]                             quietly = TRUE)
[16:21:04.184]                           if (has_future) {
[16:21:04.184]                             ns <- base::getNamespace("future")
[16:21:04.184]                             version <- ns[[".package"]][["version"]]
[16:21:04.184]                             if (is.null(version)) 
[16:21:04.184]                               version <- utils::packageVersion("future")
[16:21:04.184]                           }
[16:21:04.184]                           else {
[16:21:04.184]                             version <- NULL
[16:21:04.184]                           }
[16:21:04.184]                           if (!has_future || version < "1.8.0") {
[16:21:04.184]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.184]                               "", base::R.version$version.string), 
[16:21:04.184]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:04.184]                                 base::R.version$platform, 8 * 
[16:21:04.184]                                   base::.Machine$sizeof.pointer), 
[16:21:04.184]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.184]                                 "release", "version")], collapse = " "), 
[16:21:04.184]                               hostname = base::Sys.info()[["nodename"]])
[16:21:04.184]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.184]                               info)
[16:21:04.184]                             info <- base::paste(info, collapse = "; ")
[16:21:04.184]                             if (!has_future) {
[16:21:04.184]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.184]                                 info)
[16:21:04.184]                             }
[16:21:04.184]                             else {
[16:21:04.184]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.184]                                 info, version)
[16:21:04.184]                             }
[16:21:04.184]                             base::stop(msg)
[16:21:04.184]                           }
[16:21:04.184]                         })
[16:21:04.184]                       }
[16:21:04.184]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.184]                       base::options(mc.cores = 1L)
[16:21:04.184]                     }
[16:21:04.184]                     base::local({
[16:21:04.184]                       for (pkg in "future") {
[16:21:04.184]                         base::loadNamespace(pkg)
[16:21:04.184]                         base::library(pkg, character.only = TRUE)
[16:21:04.184]                       }
[16:21:04.184]                     })
[16:21:04.184]                   }
[16:21:04.184]                   ...future.strategy.old <- future::plan("list")
[16:21:04.184]                   options(future.plan = NULL)
[16:21:04.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.184]                 }
[16:21:04.184]                 ...future.workdir <- getwd()
[16:21:04.184]             }
[16:21:04.184]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.184]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.184]         }
[16:21:04.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.184]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.184]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.184]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.184]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.184]             base::names(...future.oldOptions))
[16:21:04.184]     }
[16:21:04.184]     if (FALSE) {
[16:21:04.184]     }
[16:21:04.184]     else {
[16:21:04.184]         if (TRUE) {
[16:21:04.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.184]                 open = "w")
[16:21:04.184]         }
[16:21:04.184]         else {
[16:21:04.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.184]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.184]         }
[16:21:04.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.184]             base::sink(type = "output", split = FALSE)
[16:21:04.184]             base::close(...future.stdout)
[16:21:04.184]         }, add = TRUE)
[16:21:04.184]     }
[16:21:04.184]     ...future.frame <- base::sys.nframe()
[16:21:04.184]     ...future.conditions <- base::list()
[16:21:04.184]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.184]     if (FALSE) {
[16:21:04.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.184]     }
[16:21:04.184]     ...future.result <- base::tryCatch({
[16:21:04.184]         base::withCallingHandlers({
[16:21:04.184]             ...future.value <- base::withVisible(base::local({
[16:21:04.184]                 withCallingHandlers({
[16:21:04.184]                   value(a) + 1
[16:21:04.184]                 }, immediateCondition = function(cond) {
[16:21:04.184]                   save_rds <- function (object, pathname, ...) 
[16:21:04.184]                   {
[16:21:04.184]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.184]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.184]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.184]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.184]                         fi_tmp[["mtime"]])
[16:21:04.184]                     }
[16:21:04.184]                     tryCatch({
[16:21:04.184]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.184]                     }, error = function(ex) {
[16:21:04.184]                       msg <- conditionMessage(ex)
[16:21:04.184]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.184]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.184]                         fi_tmp[["mtime"]], msg)
[16:21:04.184]                       ex$message <- msg
[16:21:04.184]                       stop(ex)
[16:21:04.184]                     })
[16:21:04.184]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.184]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.184]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.184]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.184]                       fi <- file.info(pathname)
[16:21:04.184]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.184]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.184]                         fi[["size"]], fi[["mtime"]])
[16:21:04.184]                       stop(msg)
[16:21:04.184]                     }
[16:21:04.184]                     invisible(pathname)
[16:21:04.184]                   }
[16:21:04.184]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.184]                     rootPath = tempdir()) 
[16:21:04.184]                   {
[16:21:04.184]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.184]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.184]                       tmpdir = path, fileext = ".rds")
[16:21:04.184]                     save_rds(obj, file)
[16:21:04.184]                   }
[16:21:04.184]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.184]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.184]                   {
[16:21:04.184]                     inherits <- base::inherits
[16:21:04.184]                     invokeRestart <- base::invokeRestart
[16:21:04.184]                     is.null <- base::is.null
[16:21:04.184]                     muffled <- FALSE
[16:21:04.184]                     if (inherits(cond, "message")) {
[16:21:04.184]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.184]                       if (muffled) 
[16:21:04.184]                         invokeRestart("muffleMessage")
[16:21:04.184]                     }
[16:21:04.184]                     else if (inherits(cond, "warning")) {
[16:21:04.184]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.184]                       if (muffled) 
[16:21:04.184]                         invokeRestart("muffleWarning")
[16:21:04.184]                     }
[16:21:04.184]                     else if (inherits(cond, "condition")) {
[16:21:04.184]                       if (!is.null(pattern)) {
[16:21:04.184]                         computeRestarts <- base::computeRestarts
[16:21:04.184]                         grepl <- base::grepl
[16:21:04.184]                         restarts <- computeRestarts(cond)
[16:21:04.184]                         for (restart in restarts) {
[16:21:04.184]                           name <- restart$name
[16:21:04.184]                           if (is.null(name)) 
[16:21:04.184]                             next
[16:21:04.184]                           if (!grepl(pattern, name)) 
[16:21:04.184]                             next
[16:21:04.184]                           invokeRestart(restart)
[16:21:04.184]                           muffled <- TRUE
[16:21:04.184]                           break
[16:21:04.184]                         }
[16:21:04.184]                       }
[16:21:04.184]                     }
[16:21:04.184]                     invisible(muffled)
[16:21:04.184]                   }
[16:21:04.184]                   muffleCondition(cond)
[16:21:04.184]                 })
[16:21:04.184]             }))
[16:21:04.184]             future::FutureResult(value = ...future.value$value, 
[16:21:04.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.184]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.184]                     ...future.globalenv.names))
[16:21:04.184]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.184]         }, condition = base::local({
[16:21:04.184]             c <- base::c
[16:21:04.184]             inherits <- base::inherits
[16:21:04.184]             invokeRestart <- base::invokeRestart
[16:21:04.184]             length <- base::length
[16:21:04.184]             list <- base::list
[16:21:04.184]             seq.int <- base::seq.int
[16:21:04.184]             signalCondition <- base::signalCondition
[16:21:04.184]             sys.calls <- base::sys.calls
[16:21:04.184]             `[[` <- base::`[[`
[16:21:04.184]             `+` <- base::`+`
[16:21:04.184]             `<<-` <- base::`<<-`
[16:21:04.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.184]                   3L)]
[16:21:04.184]             }
[16:21:04.184]             function(cond) {
[16:21:04.184]                 is_error <- inherits(cond, "error")
[16:21:04.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.184]                   NULL)
[16:21:04.184]                 if (is_error) {
[16:21:04.184]                   sessionInformation <- function() {
[16:21:04.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.184]                       search = base::search(), system = base::Sys.info())
[16:21:04.184]                   }
[16:21:04.184]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.184]                     cond$call), session = sessionInformation(), 
[16:21:04.184]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.184]                   signalCondition(cond)
[16:21:04.184]                 }
[16:21:04.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.184]                 "immediateCondition"))) {
[16:21:04.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.184]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.184]                   if (TRUE && !signal) {
[16:21:04.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.184]                     {
[16:21:04.184]                       inherits <- base::inherits
[16:21:04.184]                       invokeRestart <- base::invokeRestart
[16:21:04.184]                       is.null <- base::is.null
[16:21:04.184]                       muffled <- FALSE
[16:21:04.184]                       if (inherits(cond, "message")) {
[16:21:04.184]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.184]                         if (muffled) 
[16:21:04.184]                           invokeRestart("muffleMessage")
[16:21:04.184]                       }
[16:21:04.184]                       else if (inherits(cond, "warning")) {
[16:21:04.184]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.184]                         if (muffled) 
[16:21:04.184]                           invokeRestart("muffleWarning")
[16:21:04.184]                       }
[16:21:04.184]                       else if (inherits(cond, "condition")) {
[16:21:04.184]                         if (!is.null(pattern)) {
[16:21:04.184]                           computeRestarts <- base::computeRestarts
[16:21:04.184]                           grepl <- base::grepl
[16:21:04.184]                           restarts <- computeRestarts(cond)
[16:21:04.184]                           for (restart in restarts) {
[16:21:04.184]                             name <- restart$name
[16:21:04.184]                             if (is.null(name)) 
[16:21:04.184]                               next
[16:21:04.184]                             if (!grepl(pattern, name)) 
[16:21:04.184]                               next
[16:21:04.184]                             invokeRestart(restart)
[16:21:04.184]                             muffled <- TRUE
[16:21:04.184]                             break
[16:21:04.184]                           }
[16:21:04.184]                         }
[16:21:04.184]                       }
[16:21:04.184]                       invisible(muffled)
[16:21:04.184]                     }
[16:21:04.184]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.184]                   }
[16:21:04.184]                 }
[16:21:04.184]                 else {
[16:21:04.184]                   if (TRUE) {
[16:21:04.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.184]                     {
[16:21:04.184]                       inherits <- base::inherits
[16:21:04.184]                       invokeRestart <- base::invokeRestart
[16:21:04.184]                       is.null <- base::is.null
[16:21:04.184]                       muffled <- FALSE
[16:21:04.184]                       if (inherits(cond, "message")) {
[16:21:04.184]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.184]                         if (muffled) 
[16:21:04.184]                           invokeRestart("muffleMessage")
[16:21:04.184]                       }
[16:21:04.184]                       else if (inherits(cond, "warning")) {
[16:21:04.184]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.184]                         if (muffled) 
[16:21:04.184]                           invokeRestart("muffleWarning")
[16:21:04.184]                       }
[16:21:04.184]                       else if (inherits(cond, "condition")) {
[16:21:04.184]                         if (!is.null(pattern)) {
[16:21:04.184]                           computeRestarts <- base::computeRestarts
[16:21:04.184]                           grepl <- base::grepl
[16:21:04.184]                           restarts <- computeRestarts(cond)
[16:21:04.184]                           for (restart in restarts) {
[16:21:04.184]                             name <- restart$name
[16:21:04.184]                             if (is.null(name)) 
[16:21:04.184]                               next
[16:21:04.184]                             if (!grepl(pattern, name)) 
[16:21:04.184]                               next
[16:21:04.184]                             invokeRestart(restart)
[16:21:04.184]                             muffled <- TRUE
[16:21:04.184]                             break
[16:21:04.184]                           }
[16:21:04.184]                         }
[16:21:04.184]                       }
[16:21:04.184]                       invisible(muffled)
[16:21:04.184]                     }
[16:21:04.184]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.184]                   }
[16:21:04.184]                 }
[16:21:04.184]             }
[16:21:04.184]         }))
[16:21:04.184]     }, error = function(ex) {
[16:21:04.184]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.184]                 ...future.rng), started = ...future.startTime, 
[16:21:04.184]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.184]             version = "1.8"), class = "FutureResult")
[16:21:04.184]     }, finally = {
[16:21:04.184]         if (!identical(...future.workdir, getwd())) 
[16:21:04.184]             setwd(...future.workdir)
[16:21:04.184]         {
[16:21:04.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.184]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.184]             }
[16:21:04.184]             base::options(...future.oldOptions)
[16:21:04.184]             if (.Platform$OS.type == "windows") {
[16:21:04.184]                 old_names <- names(...future.oldEnvVars)
[16:21:04.184]                 envs <- base::Sys.getenv()
[16:21:04.184]                 names <- names(envs)
[16:21:04.184]                 common <- intersect(names, old_names)
[16:21:04.184]                 added <- setdiff(names, old_names)
[16:21:04.184]                 removed <- setdiff(old_names, names)
[16:21:04.184]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.184]                   envs[common]]
[16:21:04.184]                 NAMES <- toupper(changed)
[16:21:04.184]                 args <- list()
[16:21:04.184]                 for (kk in seq_along(NAMES)) {
[16:21:04.184]                   name <- changed[[kk]]
[16:21:04.184]                   NAME <- NAMES[[kk]]
[16:21:04.184]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.184]                     next
[16:21:04.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.184]                 }
[16:21:04.184]                 NAMES <- toupper(added)
[16:21:04.184]                 for (kk in seq_along(NAMES)) {
[16:21:04.184]                   name <- added[[kk]]
[16:21:04.184]                   NAME <- NAMES[[kk]]
[16:21:04.184]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.184]                     next
[16:21:04.184]                   args[[name]] <- ""
[16:21:04.184]                 }
[16:21:04.184]                 NAMES <- toupper(removed)
[16:21:04.184]                 for (kk in seq_along(NAMES)) {
[16:21:04.184]                   name <- removed[[kk]]
[16:21:04.184]                   NAME <- NAMES[[kk]]
[16:21:04.184]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.184]                     next
[16:21:04.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.184]                 }
[16:21:04.184]                 if (length(args) > 0) 
[16:21:04.184]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.184]             }
[16:21:04.184]             else {
[16:21:04.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.184]             }
[16:21:04.184]             {
[16:21:04.184]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.184]                   0L) {
[16:21:04.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.184]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.184]                   base::options(opts)
[16:21:04.184]                 }
[16:21:04.184]                 {
[16:21:04.184]                   {
[16:21:04.184]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.184]                     NULL
[16:21:04.184]                   }
[16:21:04.184]                   options(future.plan = NULL)
[16:21:04.184]                   if (is.na(NA_character_)) 
[16:21:04.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.184]                     .init = FALSE)
[16:21:04.184]                 }
[16:21:04.184]             }
[16:21:04.184]         }
[16:21:04.184]     })
[16:21:04.184]     if (TRUE) {
[16:21:04.184]         base::sink(type = "output", split = FALSE)
[16:21:04.184]         if (TRUE) {
[16:21:04.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.184]         }
[16:21:04.184]         else {
[16:21:04.184]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.184]         }
[16:21:04.184]         base::close(...future.stdout)
[16:21:04.184]         ...future.stdout <- NULL
[16:21:04.184]     }
[16:21:04.184]     ...future.result$conditions <- ...future.conditions
[16:21:04.184]     ...future.result$finished <- base::Sys.time()
[16:21:04.184]     ...future.result
[16:21:04.184] }
[16:21:04.186] assign_globals() ...
[16:21:04.187] List of 1
[16:21:04.187]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56222834a0f8> 
[16:21:04.187]  - attr(*, "where")=List of 1
[16:21:04.187]   ..$ a:<environment: R_EmptyEnv> 
[16:21:04.187]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.187]  - attr(*, "resolved")= logi TRUE
[16:21:04.187]  - attr(*, "total_size")= num 10816
[16:21:04.187]  - attr(*, "already-done")= logi TRUE
[16:21:04.190] - copied ‘a’ to environment
[16:21:04.190] assign_globals() ... done
[16:21:04.190] requestCore(): workers = 2
[16:21:04.192] MulticoreFuture started
[16:21:04.192] - Launch lazy future ... done
[16:21:04.192] run() for ‘MulticoreFuture’ ... done
[16:21:04.193] result() for MulticoreFuture ...
[16:21:04.193] plan(): Setting new future strategy stack:
[16:21:04.194] List of future strategies:
[16:21:04.194] 1. sequential:
[16:21:04.194]    - args: function (..., envir = parent.frame())
[16:21:04.194]    - tweaked: FALSE
[16:21:04.194]    - call: NULL
[16:21:04.195] plan(): nbrOfWorkers() = 1
[16:21:04.198] plan(): Setting new future strategy stack:
[16:21:04.198] List of future strategies:
[16:21:04.198] 1. multicore:
[16:21:04.198]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.198]    - tweaked: FALSE
[16:21:04.198]    - call: plan(strategy)
[16:21:04.203] plan(): nbrOfWorkers() = 2
[16:21:04.204] result() for MulticoreFuture ...
[16:21:04.205] result() for MulticoreFuture ... done
[16:21:04.205] signalConditions() ...
[16:21:04.205]  - include = ‘immediateCondition’
[16:21:04.205]  - exclude = 
[16:21:04.205]  - resignal = FALSE
[16:21:04.205]  - Number of conditions: 4
[16:21:04.205] signalConditions() ... done
[16:21:04.206] result() for MulticoreFuture ... done
[16:21:04.206] result() for MulticoreFuture ...
[16:21:04.206] result() for MulticoreFuture ... done
[16:21:04.206] signalConditions() ...
[16:21:04.206]  - include = ‘immediateCondition’
[16:21:04.206]  - exclude = 
[16:21:04.206]  - resignal = FALSE
[16:21:04.207]  - Number of conditions: 4
[16:21:04.207] signalConditions() ... done
[16:21:04.207] Future state: ‘finished’
[16:21:04.207] result() for MulticoreFuture ...
[16:21:04.207] result() for MulticoreFuture ... done
[16:21:04.207] signalConditions() ...
[16:21:04.207]  - include = ‘condition’
[16:21:04.207]  - exclude = ‘immediateCondition’
[16:21:04.208]  - resignal = TRUE
[16:21:04.208]  - Number of conditions: 4
[16:21:04.208]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.196] result() for MulticoreFuture ...
[16:21:04.208]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.196] result() for MulticoreFuture ... done
[16:21:04.208]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.197] result() for MulticoreFuture ...
[16:21:04.208]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.197] result() for MulticoreFuture ... done
[16:21:04.209] signalConditions() ... done
value(b) = 2
[16:21:04.209] result() for MulticoreFuture ...
[16:21:04.209] result() for MulticoreFuture ... done
[16:21:04.212] result() for MulticoreFuture ...
[16:21:04.212] result() for MulticoreFuture ... done
[16:21:04.212] signalConditions() ...
[16:21:04.213]  - include = ‘immediateCondition’
[16:21:04.213]  - exclude = 
[16:21:04.213]  - resignal = FALSE
[16:21:04.213]  - Number of conditions: 4
[16:21:04.213] signalConditions() ... done
[16:21:04.214] Future state: ‘finished’
[16:21:04.214] result() for MulticoreFuture ...
[16:21:04.214] result() for MulticoreFuture ... done
[16:21:04.214] signalConditions() ...
[16:21:04.214]  - include = ‘condition’
[16:21:04.215]  - exclude = ‘immediateCondition’
[16:21:04.215]  - resignal = TRUE
[16:21:04.215]  - Number of conditions: 4
[16:21:04.215]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.196] result() for MulticoreFuture ...
[16:21:04.215]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.196] result() for MulticoreFuture ... done
[16:21:04.215]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.197] result() for MulticoreFuture ...
[16:21:04.216]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.197] result() for MulticoreFuture ... done
[16:21:04.216] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.216] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.216] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:04.217] 
[16:21:04.217] Searching for globals ... DONE
[16:21:04.218] - globals: [0] <none>
[16:21:04.218] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.218] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.218] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:04.220] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:04.220] Searching for globals ... DONE
[16:21:04.220] Resolving globals: TRUE
[16:21:04.220] Resolving any globals that are futures ...
[16:21:04.220] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:04.220] Resolving any globals that are futures ... DONE
[16:21:04.221] Resolving futures part of globals (recursively) ...
[16:21:04.221] resolve() on list ...
[16:21:04.221]  recursive: 99
[16:21:04.221]  length: 1
[16:21:04.221]  elements: ‘a’
[16:21:04.222] run() for ‘Future’ ...
[16:21:04.222] - state: ‘created’
[16:21:04.222] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.226] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.226]   - Field: ‘label’
[16:21:04.226]   - Field: ‘local’
[16:21:04.226]   - Field: ‘owner’
[16:21:04.226]   - Field: ‘envir’
[16:21:04.227]   - Field: ‘workers’
[16:21:04.227]   - Field: ‘packages’
[16:21:04.227]   - Field: ‘gc’
[16:21:04.227]   - Field: ‘job’
[16:21:04.227]   - Field: ‘conditions’
[16:21:04.227]   - Field: ‘expr’
[16:21:04.227]   - Field: ‘uuid’
[16:21:04.227]   - Field: ‘seed’
[16:21:04.227]   - Field: ‘version’
[16:21:04.228]   - Field: ‘result’
[16:21:04.228]   - Field: ‘asynchronous’
[16:21:04.228]   - Field: ‘calls’
[16:21:04.228]   - Field: ‘globals’
[16:21:04.228]   - Field: ‘stdout’
[16:21:04.228]   - Field: ‘earlySignal’
[16:21:04.228]   - Field: ‘lazy’
[16:21:04.228]   - Field: ‘state’
[16:21:04.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.229] - Launch lazy future ...
[16:21:04.229] Packages needed by the future expression (n = 0): <none>
[16:21:04.229] Packages needed by future strategies (n = 0): <none>
[16:21:04.230] {
[16:21:04.230]     {
[16:21:04.230]         {
[16:21:04.230]             ...future.startTime <- base::Sys.time()
[16:21:04.230]             {
[16:21:04.230]                 {
[16:21:04.230]                   {
[16:21:04.230]                     {
[16:21:04.230]                       base::local({
[16:21:04.230]                         has_future <- base::requireNamespace("future", 
[16:21:04.230]                           quietly = TRUE)
[16:21:04.230]                         if (has_future) {
[16:21:04.230]                           ns <- base::getNamespace("future")
[16:21:04.230]                           version <- ns[[".package"]][["version"]]
[16:21:04.230]                           if (is.null(version)) 
[16:21:04.230]                             version <- utils::packageVersion("future")
[16:21:04.230]                         }
[16:21:04.230]                         else {
[16:21:04.230]                           version <- NULL
[16:21:04.230]                         }
[16:21:04.230]                         if (!has_future || version < "1.8.0") {
[16:21:04.230]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.230]                             "", base::R.version$version.string), 
[16:21:04.230]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.230]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.230]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.230]                               "release", "version")], collapse = " "), 
[16:21:04.230]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.230]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.230]                             info)
[16:21:04.230]                           info <- base::paste(info, collapse = "; ")
[16:21:04.230]                           if (!has_future) {
[16:21:04.230]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.230]                               info)
[16:21:04.230]                           }
[16:21:04.230]                           else {
[16:21:04.230]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.230]                               info, version)
[16:21:04.230]                           }
[16:21:04.230]                           base::stop(msg)
[16:21:04.230]                         }
[16:21:04.230]                       })
[16:21:04.230]                     }
[16:21:04.230]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.230]                     base::options(mc.cores = 1L)
[16:21:04.230]                   }
[16:21:04.230]                   ...future.strategy.old <- future::plan("list")
[16:21:04.230]                   options(future.plan = NULL)
[16:21:04.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.230]                 }
[16:21:04.230]                 ...future.workdir <- getwd()
[16:21:04.230]             }
[16:21:04.230]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.230]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.230]         }
[16:21:04.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.230]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.230]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.230]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.230]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.230]             base::names(...future.oldOptions))
[16:21:04.230]     }
[16:21:04.230]     if (FALSE) {
[16:21:04.230]     }
[16:21:04.230]     else {
[16:21:04.230]         if (TRUE) {
[16:21:04.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.230]                 open = "w")
[16:21:04.230]         }
[16:21:04.230]         else {
[16:21:04.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.230]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.230]         }
[16:21:04.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.230]             base::sink(type = "output", split = FALSE)
[16:21:04.230]             base::close(...future.stdout)
[16:21:04.230]         }, add = TRUE)
[16:21:04.230]     }
[16:21:04.230]     ...future.frame <- base::sys.nframe()
[16:21:04.230]     ...future.conditions <- base::list()
[16:21:04.230]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.230]     if (FALSE) {
[16:21:04.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.230]     }
[16:21:04.230]     ...future.result <- base::tryCatch({
[16:21:04.230]         base::withCallingHandlers({
[16:21:04.230]             ...future.value <- base::withVisible(base::local({
[16:21:04.230]                 withCallingHandlers({
[16:21:04.230]                   1
[16:21:04.230]                 }, immediateCondition = function(cond) {
[16:21:04.230]                   save_rds <- function (object, pathname, ...) 
[16:21:04.230]                   {
[16:21:04.230]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.230]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.230]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.230]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.230]                         fi_tmp[["mtime"]])
[16:21:04.230]                     }
[16:21:04.230]                     tryCatch({
[16:21:04.230]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.230]                     }, error = function(ex) {
[16:21:04.230]                       msg <- conditionMessage(ex)
[16:21:04.230]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.230]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.230]                         fi_tmp[["mtime"]], msg)
[16:21:04.230]                       ex$message <- msg
[16:21:04.230]                       stop(ex)
[16:21:04.230]                     })
[16:21:04.230]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.230]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.230]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.230]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.230]                       fi <- file.info(pathname)
[16:21:04.230]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.230]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.230]                         fi[["size"]], fi[["mtime"]])
[16:21:04.230]                       stop(msg)
[16:21:04.230]                     }
[16:21:04.230]                     invisible(pathname)
[16:21:04.230]                   }
[16:21:04.230]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.230]                     rootPath = tempdir()) 
[16:21:04.230]                   {
[16:21:04.230]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.230]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.230]                       tmpdir = path, fileext = ".rds")
[16:21:04.230]                     save_rds(obj, file)
[16:21:04.230]                   }
[16:21:04.230]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.230]                   {
[16:21:04.230]                     inherits <- base::inherits
[16:21:04.230]                     invokeRestart <- base::invokeRestart
[16:21:04.230]                     is.null <- base::is.null
[16:21:04.230]                     muffled <- FALSE
[16:21:04.230]                     if (inherits(cond, "message")) {
[16:21:04.230]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.230]                       if (muffled) 
[16:21:04.230]                         invokeRestart("muffleMessage")
[16:21:04.230]                     }
[16:21:04.230]                     else if (inherits(cond, "warning")) {
[16:21:04.230]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.230]                       if (muffled) 
[16:21:04.230]                         invokeRestart("muffleWarning")
[16:21:04.230]                     }
[16:21:04.230]                     else if (inherits(cond, "condition")) {
[16:21:04.230]                       if (!is.null(pattern)) {
[16:21:04.230]                         computeRestarts <- base::computeRestarts
[16:21:04.230]                         grepl <- base::grepl
[16:21:04.230]                         restarts <- computeRestarts(cond)
[16:21:04.230]                         for (restart in restarts) {
[16:21:04.230]                           name <- restart$name
[16:21:04.230]                           if (is.null(name)) 
[16:21:04.230]                             next
[16:21:04.230]                           if (!grepl(pattern, name)) 
[16:21:04.230]                             next
[16:21:04.230]                           invokeRestart(restart)
[16:21:04.230]                           muffled <- TRUE
[16:21:04.230]                           break
[16:21:04.230]                         }
[16:21:04.230]                       }
[16:21:04.230]                     }
[16:21:04.230]                     invisible(muffled)
[16:21:04.230]                   }
[16:21:04.230]                   muffleCondition(cond)
[16:21:04.230]                 })
[16:21:04.230]             }))
[16:21:04.230]             future::FutureResult(value = ...future.value$value, 
[16:21:04.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.230]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.230]                     ...future.globalenv.names))
[16:21:04.230]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.230]         }, condition = base::local({
[16:21:04.230]             c <- base::c
[16:21:04.230]             inherits <- base::inherits
[16:21:04.230]             invokeRestart <- base::invokeRestart
[16:21:04.230]             length <- base::length
[16:21:04.230]             list <- base::list
[16:21:04.230]             seq.int <- base::seq.int
[16:21:04.230]             signalCondition <- base::signalCondition
[16:21:04.230]             sys.calls <- base::sys.calls
[16:21:04.230]             `[[` <- base::`[[`
[16:21:04.230]             `+` <- base::`+`
[16:21:04.230]             `<<-` <- base::`<<-`
[16:21:04.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.230]                   3L)]
[16:21:04.230]             }
[16:21:04.230]             function(cond) {
[16:21:04.230]                 is_error <- inherits(cond, "error")
[16:21:04.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.230]                   NULL)
[16:21:04.230]                 if (is_error) {
[16:21:04.230]                   sessionInformation <- function() {
[16:21:04.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.230]                       search = base::search(), system = base::Sys.info())
[16:21:04.230]                   }
[16:21:04.230]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.230]                     cond$call), session = sessionInformation(), 
[16:21:04.230]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.230]                   signalCondition(cond)
[16:21:04.230]                 }
[16:21:04.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.230]                 "immediateCondition"))) {
[16:21:04.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.230]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.230]                   if (TRUE && !signal) {
[16:21:04.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.230]                     {
[16:21:04.230]                       inherits <- base::inherits
[16:21:04.230]                       invokeRestart <- base::invokeRestart
[16:21:04.230]                       is.null <- base::is.null
[16:21:04.230]                       muffled <- FALSE
[16:21:04.230]                       if (inherits(cond, "message")) {
[16:21:04.230]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.230]                         if (muffled) 
[16:21:04.230]                           invokeRestart("muffleMessage")
[16:21:04.230]                       }
[16:21:04.230]                       else if (inherits(cond, "warning")) {
[16:21:04.230]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.230]                         if (muffled) 
[16:21:04.230]                           invokeRestart("muffleWarning")
[16:21:04.230]                       }
[16:21:04.230]                       else if (inherits(cond, "condition")) {
[16:21:04.230]                         if (!is.null(pattern)) {
[16:21:04.230]                           computeRestarts <- base::computeRestarts
[16:21:04.230]                           grepl <- base::grepl
[16:21:04.230]                           restarts <- computeRestarts(cond)
[16:21:04.230]                           for (restart in restarts) {
[16:21:04.230]                             name <- restart$name
[16:21:04.230]                             if (is.null(name)) 
[16:21:04.230]                               next
[16:21:04.230]                             if (!grepl(pattern, name)) 
[16:21:04.230]                               next
[16:21:04.230]                             invokeRestart(restart)
[16:21:04.230]                             muffled <- TRUE
[16:21:04.230]                             break
[16:21:04.230]                           }
[16:21:04.230]                         }
[16:21:04.230]                       }
[16:21:04.230]                       invisible(muffled)
[16:21:04.230]                     }
[16:21:04.230]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.230]                   }
[16:21:04.230]                 }
[16:21:04.230]                 else {
[16:21:04.230]                   if (TRUE) {
[16:21:04.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.230]                     {
[16:21:04.230]                       inherits <- base::inherits
[16:21:04.230]                       invokeRestart <- base::invokeRestart
[16:21:04.230]                       is.null <- base::is.null
[16:21:04.230]                       muffled <- FALSE
[16:21:04.230]                       if (inherits(cond, "message")) {
[16:21:04.230]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.230]                         if (muffled) 
[16:21:04.230]                           invokeRestart("muffleMessage")
[16:21:04.230]                       }
[16:21:04.230]                       else if (inherits(cond, "warning")) {
[16:21:04.230]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.230]                         if (muffled) 
[16:21:04.230]                           invokeRestart("muffleWarning")
[16:21:04.230]                       }
[16:21:04.230]                       else if (inherits(cond, "condition")) {
[16:21:04.230]                         if (!is.null(pattern)) {
[16:21:04.230]                           computeRestarts <- base::computeRestarts
[16:21:04.230]                           grepl <- base::grepl
[16:21:04.230]                           restarts <- computeRestarts(cond)
[16:21:04.230]                           for (restart in restarts) {
[16:21:04.230]                             name <- restart$name
[16:21:04.230]                             if (is.null(name)) 
[16:21:04.230]                               next
[16:21:04.230]                             if (!grepl(pattern, name)) 
[16:21:04.230]                               next
[16:21:04.230]                             invokeRestart(restart)
[16:21:04.230]                             muffled <- TRUE
[16:21:04.230]                             break
[16:21:04.230]                           }
[16:21:04.230]                         }
[16:21:04.230]                       }
[16:21:04.230]                       invisible(muffled)
[16:21:04.230]                     }
[16:21:04.230]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.230]                   }
[16:21:04.230]                 }
[16:21:04.230]             }
[16:21:04.230]         }))
[16:21:04.230]     }, error = function(ex) {
[16:21:04.230]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.230]                 ...future.rng), started = ...future.startTime, 
[16:21:04.230]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.230]             version = "1.8"), class = "FutureResult")
[16:21:04.230]     }, finally = {
[16:21:04.230]         if (!identical(...future.workdir, getwd())) 
[16:21:04.230]             setwd(...future.workdir)
[16:21:04.230]         {
[16:21:04.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.230]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.230]             }
[16:21:04.230]             base::options(...future.oldOptions)
[16:21:04.230]             if (.Platform$OS.type == "windows") {
[16:21:04.230]                 old_names <- names(...future.oldEnvVars)
[16:21:04.230]                 envs <- base::Sys.getenv()
[16:21:04.230]                 names <- names(envs)
[16:21:04.230]                 common <- intersect(names, old_names)
[16:21:04.230]                 added <- setdiff(names, old_names)
[16:21:04.230]                 removed <- setdiff(old_names, names)
[16:21:04.230]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.230]                   envs[common]]
[16:21:04.230]                 NAMES <- toupper(changed)
[16:21:04.230]                 args <- list()
[16:21:04.230]                 for (kk in seq_along(NAMES)) {
[16:21:04.230]                   name <- changed[[kk]]
[16:21:04.230]                   NAME <- NAMES[[kk]]
[16:21:04.230]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.230]                     next
[16:21:04.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.230]                 }
[16:21:04.230]                 NAMES <- toupper(added)
[16:21:04.230]                 for (kk in seq_along(NAMES)) {
[16:21:04.230]                   name <- added[[kk]]
[16:21:04.230]                   NAME <- NAMES[[kk]]
[16:21:04.230]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.230]                     next
[16:21:04.230]                   args[[name]] <- ""
[16:21:04.230]                 }
[16:21:04.230]                 NAMES <- toupper(removed)
[16:21:04.230]                 for (kk in seq_along(NAMES)) {
[16:21:04.230]                   name <- removed[[kk]]
[16:21:04.230]                   NAME <- NAMES[[kk]]
[16:21:04.230]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.230]                     next
[16:21:04.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.230]                 }
[16:21:04.230]                 if (length(args) > 0) 
[16:21:04.230]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.230]             }
[16:21:04.230]             else {
[16:21:04.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.230]             }
[16:21:04.230]             {
[16:21:04.230]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.230]                   0L) {
[16:21:04.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.230]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.230]                   base::options(opts)
[16:21:04.230]                 }
[16:21:04.230]                 {
[16:21:04.230]                   {
[16:21:04.230]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.230]                     NULL
[16:21:04.230]                   }
[16:21:04.230]                   options(future.plan = NULL)
[16:21:04.230]                   if (is.na(NA_character_)) 
[16:21:04.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.230]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.230]                     .init = FALSE)
[16:21:04.230]                 }
[16:21:04.230]             }
[16:21:04.230]         }
[16:21:04.230]     })
[16:21:04.230]     if (TRUE) {
[16:21:04.230]         base::sink(type = "output", split = FALSE)
[16:21:04.230]         if (TRUE) {
[16:21:04.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.230]         }
[16:21:04.230]         else {
[16:21:04.230]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.230]         }
[16:21:04.230]         base::close(...future.stdout)
[16:21:04.230]         ...future.stdout <- NULL
[16:21:04.230]     }
[16:21:04.230]     ...future.result$conditions <- ...future.conditions
[16:21:04.230]     ...future.result$finished <- base::Sys.time()
[16:21:04.230]     ...future.result
[16:21:04.230] }
[16:21:04.232] requestCore(): workers = 2
[16:21:04.234] MulticoreFuture started
[16:21:04.234] - Launch lazy future ... done
[16:21:04.234] run() for ‘MulticoreFuture’ ... done
[16:21:04.235] plan(): Setting new future strategy stack:
[16:21:04.235] List of future strategies:
[16:21:04.235] 1. sequential:
[16:21:04.235]    - args: function (..., envir = parent.frame())
[16:21:04.235]    - tweaked: FALSE
[16:21:04.235]    - call: NULL
[16:21:04.236] plan(): nbrOfWorkers() = 1
[16:21:04.238] plan(): Setting new future strategy stack:
[16:21:04.239] List of future strategies:
[16:21:04.239] 1. multicore:
[16:21:04.239]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.239]    - tweaked: FALSE
[16:21:04.239]    - call: plan(strategy)
[16:21:04.244] plan(): nbrOfWorkers() = 2
[16:21:04.244] Future #1
[16:21:04.245] result() for MulticoreFuture ...
[16:21:04.246] result() for MulticoreFuture ...
[16:21:04.246] result() for MulticoreFuture ... done
[16:21:04.246] result() for MulticoreFuture ... done
[16:21:04.246] result() for MulticoreFuture ...
[16:21:04.246] result() for MulticoreFuture ... done
[16:21:04.247] A MulticoreFuture was resolved
[16:21:04.247]  length: 0 (resolved future 1)
[16:21:04.247] resolve() on list ... DONE
[16:21:04.247] - globals: [1] ‘a’
[16:21:04.247] Resolving futures part of globals (recursively) ... DONE
[16:21:04.249] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[16:21:04.249] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[16:21:04.249] - globals: [1] ‘a’
[16:21:04.249] - packages: [1] ‘future’
[16:21:04.250] getGlobalsAndPackages() ... DONE
[16:21:04.250] run() for ‘Future’ ...
[16:21:04.250] - state: ‘created’
[16:21:04.250] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.254] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.255] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.255]   - Field: ‘label’
[16:21:04.255]   - Field: ‘local’
[16:21:04.255]   - Field: ‘owner’
[16:21:04.255]   - Field: ‘envir’
[16:21:04.258]   - Field: ‘workers’
[16:21:04.258]   - Field: ‘packages’
[16:21:04.258]   - Field: ‘gc’
[16:21:04.258]   - Field: ‘job’
[16:21:04.259]   - Field: ‘conditions’
[16:21:04.259]   - Field: ‘expr’
[16:21:04.259]   - Field: ‘uuid’
[16:21:04.259]   - Field: ‘seed’
[16:21:04.259]   - Field: ‘version’
[16:21:04.260]   - Field: ‘result’
[16:21:04.260]   - Field: ‘asynchronous’
[16:21:04.260]   - Field: ‘calls’
[16:21:04.260]   - Field: ‘globals’
[16:21:04.260]   - Field: ‘stdout’
[16:21:04.260]   - Field: ‘earlySignal’
[16:21:04.261]   - Field: ‘lazy’
[16:21:04.261]   - Field: ‘state’
[16:21:04.261] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.261] - Launch lazy future ...
[16:21:04.261] Packages needed by the future expression (n = 1): ‘future’
[16:21:04.262] Packages needed by future strategies (n = 0): <none>
[16:21:04.262] {
[16:21:04.262]     {
[16:21:04.262]         {
[16:21:04.262]             ...future.startTime <- base::Sys.time()
[16:21:04.262]             {
[16:21:04.262]                 {
[16:21:04.262]                   {
[16:21:04.262]                     {
[16:21:04.262]                       {
[16:21:04.262]                         base::local({
[16:21:04.262]                           has_future <- base::requireNamespace("future", 
[16:21:04.262]                             quietly = TRUE)
[16:21:04.262]                           if (has_future) {
[16:21:04.262]                             ns <- base::getNamespace("future")
[16:21:04.262]                             version <- ns[[".package"]][["version"]]
[16:21:04.262]                             if (is.null(version)) 
[16:21:04.262]                               version <- utils::packageVersion("future")
[16:21:04.262]                           }
[16:21:04.262]                           else {
[16:21:04.262]                             version <- NULL
[16:21:04.262]                           }
[16:21:04.262]                           if (!has_future || version < "1.8.0") {
[16:21:04.262]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.262]                               "", base::R.version$version.string), 
[16:21:04.262]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:04.262]                                 base::R.version$platform, 8 * 
[16:21:04.262]                                   base::.Machine$sizeof.pointer), 
[16:21:04.262]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.262]                                 "release", "version")], collapse = " "), 
[16:21:04.262]                               hostname = base::Sys.info()[["nodename"]])
[16:21:04.262]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.262]                               info)
[16:21:04.262]                             info <- base::paste(info, collapse = "; ")
[16:21:04.262]                             if (!has_future) {
[16:21:04.262]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.262]                                 info)
[16:21:04.262]                             }
[16:21:04.262]                             else {
[16:21:04.262]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.262]                                 info, version)
[16:21:04.262]                             }
[16:21:04.262]                             base::stop(msg)
[16:21:04.262]                           }
[16:21:04.262]                         })
[16:21:04.262]                       }
[16:21:04.262]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.262]                       base::options(mc.cores = 1L)
[16:21:04.262]                     }
[16:21:04.262]                     base::local({
[16:21:04.262]                       for (pkg in "future") {
[16:21:04.262]                         base::loadNamespace(pkg)
[16:21:04.262]                         base::library(pkg, character.only = TRUE)
[16:21:04.262]                       }
[16:21:04.262]                     })
[16:21:04.262]                   }
[16:21:04.262]                   ...future.strategy.old <- future::plan("list")
[16:21:04.262]                   options(future.plan = NULL)
[16:21:04.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.262]                 }
[16:21:04.262]                 ...future.workdir <- getwd()
[16:21:04.262]             }
[16:21:04.262]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.262]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.262]         }
[16:21:04.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.262]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.262]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.262]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.262]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.262]             base::names(...future.oldOptions))
[16:21:04.262]     }
[16:21:04.262]     if (FALSE) {
[16:21:04.262]     }
[16:21:04.262]     else {
[16:21:04.262]         if (TRUE) {
[16:21:04.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.262]                 open = "w")
[16:21:04.262]         }
[16:21:04.262]         else {
[16:21:04.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.262]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.262]         }
[16:21:04.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.262]             base::sink(type = "output", split = FALSE)
[16:21:04.262]             base::close(...future.stdout)
[16:21:04.262]         }, add = TRUE)
[16:21:04.262]     }
[16:21:04.262]     ...future.frame <- base::sys.nframe()
[16:21:04.262]     ...future.conditions <- base::list()
[16:21:04.262]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.262]     if (FALSE) {
[16:21:04.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.262]     }
[16:21:04.262]     ...future.result <- base::tryCatch({
[16:21:04.262]         base::withCallingHandlers({
[16:21:04.262]             ...future.value <- base::withVisible(base::local({
[16:21:04.262]                 withCallingHandlers({
[16:21:04.262]                   value(a) + 1
[16:21:04.262]                 }, immediateCondition = function(cond) {
[16:21:04.262]                   save_rds <- function (object, pathname, ...) 
[16:21:04.262]                   {
[16:21:04.262]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.262]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.262]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.262]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.262]                         fi_tmp[["mtime"]])
[16:21:04.262]                     }
[16:21:04.262]                     tryCatch({
[16:21:04.262]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.262]                     }, error = function(ex) {
[16:21:04.262]                       msg <- conditionMessage(ex)
[16:21:04.262]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.262]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.262]                         fi_tmp[["mtime"]], msg)
[16:21:04.262]                       ex$message <- msg
[16:21:04.262]                       stop(ex)
[16:21:04.262]                     })
[16:21:04.262]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.262]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.262]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.262]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.262]                       fi <- file.info(pathname)
[16:21:04.262]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.262]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.262]                         fi[["size"]], fi[["mtime"]])
[16:21:04.262]                       stop(msg)
[16:21:04.262]                     }
[16:21:04.262]                     invisible(pathname)
[16:21:04.262]                   }
[16:21:04.262]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.262]                     rootPath = tempdir()) 
[16:21:04.262]                   {
[16:21:04.262]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.262]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.262]                       tmpdir = path, fileext = ".rds")
[16:21:04.262]                     save_rds(obj, file)
[16:21:04.262]                   }
[16:21:04.262]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.262]                   {
[16:21:04.262]                     inherits <- base::inherits
[16:21:04.262]                     invokeRestart <- base::invokeRestart
[16:21:04.262]                     is.null <- base::is.null
[16:21:04.262]                     muffled <- FALSE
[16:21:04.262]                     if (inherits(cond, "message")) {
[16:21:04.262]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.262]                       if (muffled) 
[16:21:04.262]                         invokeRestart("muffleMessage")
[16:21:04.262]                     }
[16:21:04.262]                     else if (inherits(cond, "warning")) {
[16:21:04.262]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.262]                       if (muffled) 
[16:21:04.262]                         invokeRestart("muffleWarning")
[16:21:04.262]                     }
[16:21:04.262]                     else if (inherits(cond, "condition")) {
[16:21:04.262]                       if (!is.null(pattern)) {
[16:21:04.262]                         computeRestarts <- base::computeRestarts
[16:21:04.262]                         grepl <- base::grepl
[16:21:04.262]                         restarts <- computeRestarts(cond)
[16:21:04.262]                         for (restart in restarts) {
[16:21:04.262]                           name <- restart$name
[16:21:04.262]                           if (is.null(name)) 
[16:21:04.262]                             next
[16:21:04.262]                           if (!grepl(pattern, name)) 
[16:21:04.262]                             next
[16:21:04.262]                           invokeRestart(restart)
[16:21:04.262]                           muffled <- TRUE
[16:21:04.262]                           break
[16:21:04.262]                         }
[16:21:04.262]                       }
[16:21:04.262]                     }
[16:21:04.262]                     invisible(muffled)
[16:21:04.262]                   }
[16:21:04.262]                   muffleCondition(cond)
[16:21:04.262]                 })
[16:21:04.262]             }))
[16:21:04.262]             future::FutureResult(value = ...future.value$value, 
[16:21:04.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.262]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.262]                     ...future.globalenv.names))
[16:21:04.262]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.262]         }, condition = base::local({
[16:21:04.262]             c <- base::c
[16:21:04.262]             inherits <- base::inherits
[16:21:04.262]             invokeRestart <- base::invokeRestart
[16:21:04.262]             length <- base::length
[16:21:04.262]             list <- base::list
[16:21:04.262]             seq.int <- base::seq.int
[16:21:04.262]             signalCondition <- base::signalCondition
[16:21:04.262]             sys.calls <- base::sys.calls
[16:21:04.262]             `[[` <- base::`[[`
[16:21:04.262]             `+` <- base::`+`
[16:21:04.262]             `<<-` <- base::`<<-`
[16:21:04.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.262]                   3L)]
[16:21:04.262]             }
[16:21:04.262]             function(cond) {
[16:21:04.262]                 is_error <- inherits(cond, "error")
[16:21:04.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.262]                   NULL)
[16:21:04.262]                 if (is_error) {
[16:21:04.262]                   sessionInformation <- function() {
[16:21:04.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.262]                       search = base::search(), system = base::Sys.info())
[16:21:04.262]                   }
[16:21:04.262]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.262]                     cond$call), session = sessionInformation(), 
[16:21:04.262]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.262]                   signalCondition(cond)
[16:21:04.262]                 }
[16:21:04.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.262]                 "immediateCondition"))) {
[16:21:04.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.262]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.262]                   if (TRUE && !signal) {
[16:21:04.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.262]                     {
[16:21:04.262]                       inherits <- base::inherits
[16:21:04.262]                       invokeRestart <- base::invokeRestart
[16:21:04.262]                       is.null <- base::is.null
[16:21:04.262]                       muffled <- FALSE
[16:21:04.262]                       if (inherits(cond, "message")) {
[16:21:04.262]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.262]                         if (muffled) 
[16:21:04.262]                           invokeRestart("muffleMessage")
[16:21:04.262]                       }
[16:21:04.262]                       else if (inherits(cond, "warning")) {
[16:21:04.262]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.262]                         if (muffled) 
[16:21:04.262]                           invokeRestart("muffleWarning")
[16:21:04.262]                       }
[16:21:04.262]                       else if (inherits(cond, "condition")) {
[16:21:04.262]                         if (!is.null(pattern)) {
[16:21:04.262]                           computeRestarts <- base::computeRestarts
[16:21:04.262]                           grepl <- base::grepl
[16:21:04.262]                           restarts <- computeRestarts(cond)
[16:21:04.262]                           for (restart in restarts) {
[16:21:04.262]                             name <- restart$name
[16:21:04.262]                             if (is.null(name)) 
[16:21:04.262]                               next
[16:21:04.262]                             if (!grepl(pattern, name)) 
[16:21:04.262]                               next
[16:21:04.262]                             invokeRestart(restart)
[16:21:04.262]                             muffled <- TRUE
[16:21:04.262]                             break
[16:21:04.262]                           }
[16:21:04.262]                         }
[16:21:04.262]                       }
[16:21:04.262]                       invisible(muffled)
[16:21:04.262]                     }
[16:21:04.262]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.262]                   }
[16:21:04.262]                 }
[16:21:04.262]                 else {
[16:21:04.262]                   if (TRUE) {
[16:21:04.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.262]                     {
[16:21:04.262]                       inherits <- base::inherits
[16:21:04.262]                       invokeRestart <- base::invokeRestart
[16:21:04.262]                       is.null <- base::is.null
[16:21:04.262]                       muffled <- FALSE
[16:21:04.262]                       if (inherits(cond, "message")) {
[16:21:04.262]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.262]                         if (muffled) 
[16:21:04.262]                           invokeRestart("muffleMessage")
[16:21:04.262]                       }
[16:21:04.262]                       else if (inherits(cond, "warning")) {
[16:21:04.262]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.262]                         if (muffled) 
[16:21:04.262]                           invokeRestart("muffleWarning")
[16:21:04.262]                       }
[16:21:04.262]                       else if (inherits(cond, "condition")) {
[16:21:04.262]                         if (!is.null(pattern)) {
[16:21:04.262]                           computeRestarts <- base::computeRestarts
[16:21:04.262]                           grepl <- base::grepl
[16:21:04.262]                           restarts <- computeRestarts(cond)
[16:21:04.262]                           for (restart in restarts) {
[16:21:04.262]                             name <- restart$name
[16:21:04.262]                             if (is.null(name)) 
[16:21:04.262]                               next
[16:21:04.262]                             if (!grepl(pattern, name)) 
[16:21:04.262]                               next
[16:21:04.262]                             invokeRestart(restart)
[16:21:04.262]                             muffled <- TRUE
[16:21:04.262]                             break
[16:21:04.262]                           }
[16:21:04.262]                         }
[16:21:04.262]                       }
[16:21:04.262]                       invisible(muffled)
[16:21:04.262]                     }
[16:21:04.262]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.262]                   }
[16:21:04.262]                 }
[16:21:04.262]             }
[16:21:04.262]         }))
[16:21:04.262]     }, error = function(ex) {
[16:21:04.262]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.262]                 ...future.rng), started = ...future.startTime, 
[16:21:04.262]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.262]             version = "1.8"), class = "FutureResult")
[16:21:04.262]     }, finally = {
[16:21:04.262]         if (!identical(...future.workdir, getwd())) 
[16:21:04.262]             setwd(...future.workdir)
[16:21:04.262]         {
[16:21:04.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.262]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.262]             }
[16:21:04.262]             base::options(...future.oldOptions)
[16:21:04.262]             if (.Platform$OS.type == "windows") {
[16:21:04.262]                 old_names <- names(...future.oldEnvVars)
[16:21:04.262]                 envs <- base::Sys.getenv()
[16:21:04.262]                 names <- names(envs)
[16:21:04.262]                 common <- intersect(names, old_names)
[16:21:04.262]                 added <- setdiff(names, old_names)
[16:21:04.262]                 removed <- setdiff(old_names, names)
[16:21:04.262]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.262]                   envs[common]]
[16:21:04.262]                 NAMES <- toupper(changed)
[16:21:04.262]                 args <- list()
[16:21:04.262]                 for (kk in seq_along(NAMES)) {
[16:21:04.262]                   name <- changed[[kk]]
[16:21:04.262]                   NAME <- NAMES[[kk]]
[16:21:04.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.262]                     next
[16:21:04.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.262]                 }
[16:21:04.262]                 NAMES <- toupper(added)
[16:21:04.262]                 for (kk in seq_along(NAMES)) {
[16:21:04.262]                   name <- added[[kk]]
[16:21:04.262]                   NAME <- NAMES[[kk]]
[16:21:04.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.262]                     next
[16:21:04.262]                   args[[name]] <- ""
[16:21:04.262]                 }
[16:21:04.262]                 NAMES <- toupper(removed)
[16:21:04.262]                 for (kk in seq_along(NAMES)) {
[16:21:04.262]                   name <- removed[[kk]]
[16:21:04.262]                   NAME <- NAMES[[kk]]
[16:21:04.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.262]                     next
[16:21:04.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.262]                 }
[16:21:04.262]                 if (length(args) > 0) 
[16:21:04.262]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.262]             }
[16:21:04.262]             else {
[16:21:04.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.262]             }
[16:21:04.262]             {
[16:21:04.262]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.262]                   0L) {
[16:21:04.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.262]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.262]                   base::options(opts)
[16:21:04.262]                 }
[16:21:04.262]                 {
[16:21:04.262]                   {
[16:21:04.262]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.262]                     NULL
[16:21:04.262]                   }
[16:21:04.262]                   options(future.plan = NULL)
[16:21:04.262]                   if (is.na(NA_character_)) 
[16:21:04.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.262]                     .init = FALSE)
[16:21:04.262]                 }
[16:21:04.262]             }
[16:21:04.262]         }
[16:21:04.262]     })
[16:21:04.262]     if (TRUE) {
[16:21:04.262]         base::sink(type = "output", split = FALSE)
[16:21:04.262]         if (TRUE) {
[16:21:04.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.262]         }
[16:21:04.262]         else {
[16:21:04.262]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.262]         }
[16:21:04.262]         base::close(...future.stdout)
[16:21:04.262]         ...future.stdout <- NULL
[16:21:04.262]     }
[16:21:04.262]     ...future.result$conditions <- ...future.conditions
[16:21:04.262]     ...future.result$finished <- base::Sys.time()
[16:21:04.262]     ...future.result
[16:21:04.262] }
[16:21:04.265] assign_globals() ...
[16:21:04.265] List of 1
[16:21:04.265]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x562226bd07a0> 
[16:21:04.265]  - attr(*, "where")=List of 1
[16:21:04.265]   ..$ a:<environment: R_EmptyEnv> 
[16:21:04.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.265]  - attr(*, "resolved")= logi TRUE
[16:21:04.265]  - attr(*, "total_size")= num 10984
[16:21:04.265]  - attr(*, "already-done")= logi TRUE
[16:21:04.268] - copied ‘a’ to environment
[16:21:04.268] assign_globals() ... done
[16:21:04.269] requestCore(): workers = 2
[16:21:04.271] MulticoreFuture started
[16:21:04.271] - Launch lazy future ... done
[16:21:04.271] run() for ‘MulticoreFuture’ ... done
[16:21:04.272] result() for MulticoreFuture ...
[16:21:04.272] plan(): Setting new future strategy stack:
[16:21:04.273] List of future strategies:
[16:21:04.273] 1. sequential:
[16:21:04.273]    - args: function (..., envir = parent.frame())
[16:21:04.273]    - tweaked: FALSE
[16:21:04.273]    - call: NULL
[16:21:04.273] plan(): nbrOfWorkers() = 1
[16:21:04.277] plan(): Setting new future strategy stack:
[16:21:04.277] List of future strategies:
[16:21:04.277] 1. multicore:
[16:21:04.277]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.277]    - tweaked: FALSE
[16:21:04.277]    - call: plan(strategy)
[16:21:04.283] plan(): nbrOfWorkers() = 2
[16:21:04.284] result() for MulticoreFuture ...
[16:21:04.284] result() for MulticoreFuture ... done
[16:21:04.284] signalConditions() ...
[16:21:04.284]  - include = ‘immediateCondition’
[16:21:04.284]  - exclude = 
[16:21:04.284]  - resignal = FALSE
[16:21:04.284]  - Number of conditions: 4
[16:21:04.285] signalConditions() ... done
[16:21:04.285] result() for MulticoreFuture ... done
[16:21:04.285] result() for MulticoreFuture ...
[16:21:04.285] result() for MulticoreFuture ... done
[16:21:04.285] signalConditions() ...
[16:21:04.285]  - include = ‘immediateCondition’
[16:21:04.285]  - exclude = 
[16:21:04.285]  - resignal = FALSE
[16:21:04.286]  - Number of conditions: 4
[16:21:04.286] signalConditions() ... done
[16:21:04.286] Future state: ‘finished’
[16:21:04.286] result() for MulticoreFuture ...
[16:21:04.286] result() for MulticoreFuture ... done
[16:21:04.286] signalConditions() ...
[16:21:04.286]  - include = ‘condition’
[16:21:04.287]  - exclude = ‘immediateCondition’
[16:21:04.287]  - resignal = TRUE
[16:21:04.287]  - Number of conditions: 4
[16:21:04.287]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.275] result() for MulticoreFuture ...
[16:21:04.287]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.275] result() for MulticoreFuture ... done
[16:21:04.287]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.275] result() for MulticoreFuture ...
[16:21:04.287]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.276] result() for MulticoreFuture ... done
[16:21:04.288] signalConditions() ... done
value(b) = 2
[16:21:04.288] result() for MulticoreFuture ...
[16:21:04.288] result() for MulticoreFuture ... done
[16:21:04.288] result() for MulticoreFuture ...
[16:21:04.288] result() for MulticoreFuture ... done
[16:21:04.288] signalConditions() ...
[16:21:04.288]  - include = ‘immediateCondition’
[16:21:04.289]  - exclude = 
[16:21:04.289]  - resignal = FALSE
[16:21:04.289]  - Number of conditions: 4
[16:21:04.289] signalConditions() ... done
[16:21:04.289] Future state: ‘finished’
[16:21:04.289] result() for MulticoreFuture ...
[16:21:04.289] result() for MulticoreFuture ... done
[16:21:04.289] signalConditions() ...
[16:21:04.290]  - include = ‘condition’
[16:21:04.290]  - exclude = ‘immediateCondition’
[16:21:04.290]  - resignal = TRUE
[16:21:04.290]  - Number of conditions: 4
[16:21:04.290]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.275] result() for MulticoreFuture ...
[16:21:04.290]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.275] result() for MulticoreFuture ... done
[16:21:04.290]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.275] result() for MulticoreFuture ...
[16:21:04.291]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.276] result() for MulticoreFuture ... done
[16:21:04.291] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.291] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.291] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:04.292] 
[16:21:04.292] Searching for globals ... DONE
[16:21:04.292] - globals: [0] <none>
[16:21:04.292] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.293] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.293] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:04.294] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:04.295] Searching for globals ... DONE
[16:21:04.295] Resolving globals: TRUE
[16:21:04.295] Resolving any globals that are futures ...
[16:21:04.295] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:04.295] Resolving any globals that are futures ... DONE
[16:21:04.295] Resolving futures part of globals (recursively) ...
[16:21:04.296] resolve() on list ...
[16:21:04.296]  recursive: 99
[16:21:04.296]  length: 1
[16:21:04.296]  elements: ‘a’
[16:21:04.296] run() for ‘Future’ ...
[16:21:04.296] - state: ‘created’
[16:21:04.297] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.304] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.305]   - Field: ‘label’
[16:21:04.305]   - Field: ‘local’
[16:21:04.305]   - Field: ‘owner’
[16:21:04.305]   - Field: ‘envir’
[16:21:04.305]   - Field: ‘workers’
[16:21:04.305]   - Field: ‘packages’
[16:21:04.305]   - Field: ‘gc’
[16:21:04.306]   - Field: ‘job’
[16:21:04.306]   - Field: ‘conditions’
[16:21:04.306]   - Field: ‘expr’
[16:21:04.306]   - Field: ‘uuid’
[16:21:04.306]   - Field: ‘seed’
[16:21:04.306]   - Field: ‘version’
[16:21:04.306]   - Field: ‘result’
[16:21:04.306]   - Field: ‘asynchronous’
[16:21:04.307]   - Field: ‘calls’
[16:21:04.307]   - Field: ‘globals’
[16:21:04.307]   - Field: ‘stdout’
[16:21:04.307]   - Field: ‘earlySignal’
[16:21:04.307]   - Field: ‘lazy’
[16:21:04.307]   - Field: ‘state’
[16:21:04.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.307] - Launch lazy future ...
[16:21:04.308] Packages needed by the future expression (n = 0): <none>
[16:21:04.308] Packages needed by future strategies (n = 0): <none>
[16:21:04.309] {
[16:21:04.309]     {
[16:21:04.309]         {
[16:21:04.309]             ...future.startTime <- base::Sys.time()
[16:21:04.309]             {
[16:21:04.309]                 {
[16:21:04.309]                   {
[16:21:04.309]                     {
[16:21:04.309]                       base::local({
[16:21:04.309]                         has_future <- base::requireNamespace("future", 
[16:21:04.309]                           quietly = TRUE)
[16:21:04.309]                         if (has_future) {
[16:21:04.309]                           ns <- base::getNamespace("future")
[16:21:04.309]                           version <- ns[[".package"]][["version"]]
[16:21:04.309]                           if (is.null(version)) 
[16:21:04.309]                             version <- utils::packageVersion("future")
[16:21:04.309]                         }
[16:21:04.309]                         else {
[16:21:04.309]                           version <- NULL
[16:21:04.309]                         }
[16:21:04.309]                         if (!has_future || version < "1.8.0") {
[16:21:04.309]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.309]                             "", base::R.version$version.string), 
[16:21:04.309]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.309]                               "release", "version")], collapse = " "), 
[16:21:04.309]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.309]                             info)
[16:21:04.309]                           info <- base::paste(info, collapse = "; ")
[16:21:04.309]                           if (!has_future) {
[16:21:04.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.309]                               info)
[16:21:04.309]                           }
[16:21:04.309]                           else {
[16:21:04.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.309]                               info, version)
[16:21:04.309]                           }
[16:21:04.309]                           base::stop(msg)
[16:21:04.309]                         }
[16:21:04.309]                       })
[16:21:04.309]                     }
[16:21:04.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.309]                     base::options(mc.cores = 1L)
[16:21:04.309]                   }
[16:21:04.309]                   ...future.strategy.old <- future::plan("list")
[16:21:04.309]                   options(future.plan = NULL)
[16:21:04.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.309]                 }
[16:21:04.309]                 ...future.workdir <- getwd()
[16:21:04.309]             }
[16:21:04.309]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.309]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.309]         }
[16:21:04.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.309]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.309]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.309]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.309]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.309]             base::names(...future.oldOptions))
[16:21:04.309]     }
[16:21:04.309]     if (FALSE) {
[16:21:04.309]     }
[16:21:04.309]     else {
[16:21:04.309]         if (TRUE) {
[16:21:04.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.309]                 open = "w")
[16:21:04.309]         }
[16:21:04.309]         else {
[16:21:04.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.309]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.309]         }
[16:21:04.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.309]             base::sink(type = "output", split = FALSE)
[16:21:04.309]             base::close(...future.stdout)
[16:21:04.309]         }, add = TRUE)
[16:21:04.309]     }
[16:21:04.309]     ...future.frame <- base::sys.nframe()
[16:21:04.309]     ...future.conditions <- base::list()
[16:21:04.309]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.309]     if (FALSE) {
[16:21:04.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.309]     }
[16:21:04.309]     ...future.result <- base::tryCatch({
[16:21:04.309]         base::withCallingHandlers({
[16:21:04.309]             ...future.value <- base::withVisible(base::local({
[16:21:04.309]                 withCallingHandlers({
[16:21:04.309]                   1
[16:21:04.309]                 }, immediateCondition = function(cond) {
[16:21:04.309]                   save_rds <- function (object, pathname, ...) 
[16:21:04.309]                   {
[16:21:04.309]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.309]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.309]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.309]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.309]                         fi_tmp[["mtime"]])
[16:21:04.309]                     }
[16:21:04.309]                     tryCatch({
[16:21:04.309]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.309]                     }, error = function(ex) {
[16:21:04.309]                       msg <- conditionMessage(ex)
[16:21:04.309]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.309]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.309]                         fi_tmp[["mtime"]], msg)
[16:21:04.309]                       ex$message <- msg
[16:21:04.309]                       stop(ex)
[16:21:04.309]                     })
[16:21:04.309]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.309]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.309]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.309]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.309]                       fi <- file.info(pathname)
[16:21:04.309]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.309]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.309]                         fi[["size"]], fi[["mtime"]])
[16:21:04.309]                       stop(msg)
[16:21:04.309]                     }
[16:21:04.309]                     invisible(pathname)
[16:21:04.309]                   }
[16:21:04.309]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.309]                     rootPath = tempdir()) 
[16:21:04.309]                   {
[16:21:04.309]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.309]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.309]                       tmpdir = path, fileext = ".rds")
[16:21:04.309]                     save_rds(obj, file)
[16:21:04.309]                   }
[16:21:04.309]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.309]                   {
[16:21:04.309]                     inherits <- base::inherits
[16:21:04.309]                     invokeRestart <- base::invokeRestart
[16:21:04.309]                     is.null <- base::is.null
[16:21:04.309]                     muffled <- FALSE
[16:21:04.309]                     if (inherits(cond, "message")) {
[16:21:04.309]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.309]                       if (muffled) 
[16:21:04.309]                         invokeRestart("muffleMessage")
[16:21:04.309]                     }
[16:21:04.309]                     else if (inherits(cond, "warning")) {
[16:21:04.309]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.309]                       if (muffled) 
[16:21:04.309]                         invokeRestart("muffleWarning")
[16:21:04.309]                     }
[16:21:04.309]                     else if (inherits(cond, "condition")) {
[16:21:04.309]                       if (!is.null(pattern)) {
[16:21:04.309]                         computeRestarts <- base::computeRestarts
[16:21:04.309]                         grepl <- base::grepl
[16:21:04.309]                         restarts <- computeRestarts(cond)
[16:21:04.309]                         for (restart in restarts) {
[16:21:04.309]                           name <- restart$name
[16:21:04.309]                           if (is.null(name)) 
[16:21:04.309]                             next
[16:21:04.309]                           if (!grepl(pattern, name)) 
[16:21:04.309]                             next
[16:21:04.309]                           invokeRestart(restart)
[16:21:04.309]                           muffled <- TRUE
[16:21:04.309]                           break
[16:21:04.309]                         }
[16:21:04.309]                       }
[16:21:04.309]                     }
[16:21:04.309]                     invisible(muffled)
[16:21:04.309]                   }
[16:21:04.309]                   muffleCondition(cond)
[16:21:04.309]                 })
[16:21:04.309]             }))
[16:21:04.309]             future::FutureResult(value = ...future.value$value, 
[16:21:04.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.309]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.309]                     ...future.globalenv.names))
[16:21:04.309]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.309]         }, condition = base::local({
[16:21:04.309]             c <- base::c
[16:21:04.309]             inherits <- base::inherits
[16:21:04.309]             invokeRestart <- base::invokeRestart
[16:21:04.309]             length <- base::length
[16:21:04.309]             list <- base::list
[16:21:04.309]             seq.int <- base::seq.int
[16:21:04.309]             signalCondition <- base::signalCondition
[16:21:04.309]             sys.calls <- base::sys.calls
[16:21:04.309]             `[[` <- base::`[[`
[16:21:04.309]             `+` <- base::`+`
[16:21:04.309]             `<<-` <- base::`<<-`
[16:21:04.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.309]                   3L)]
[16:21:04.309]             }
[16:21:04.309]             function(cond) {
[16:21:04.309]                 is_error <- inherits(cond, "error")
[16:21:04.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.309]                   NULL)
[16:21:04.309]                 if (is_error) {
[16:21:04.309]                   sessionInformation <- function() {
[16:21:04.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.309]                       search = base::search(), system = base::Sys.info())
[16:21:04.309]                   }
[16:21:04.309]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.309]                     cond$call), session = sessionInformation(), 
[16:21:04.309]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.309]                   signalCondition(cond)
[16:21:04.309]                 }
[16:21:04.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.309]                 "immediateCondition"))) {
[16:21:04.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.309]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.309]                   if (TRUE && !signal) {
[16:21:04.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.309]                     {
[16:21:04.309]                       inherits <- base::inherits
[16:21:04.309]                       invokeRestart <- base::invokeRestart
[16:21:04.309]                       is.null <- base::is.null
[16:21:04.309]                       muffled <- FALSE
[16:21:04.309]                       if (inherits(cond, "message")) {
[16:21:04.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.309]                         if (muffled) 
[16:21:04.309]                           invokeRestart("muffleMessage")
[16:21:04.309]                       }
[16:21:04.309]                       else if (inherits(cond, "warning")) {
[16:21:04.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.309]                         if (muffled) 
[16:21:04.309]                           invokeRestart("muffleWarning")
[16:21:04.309]                       }
[16:21:04.309]                       else if (inherits(cond, "condition")) {
[16:21:04.309]                         if (!is.null(pattern)) {
[16:21:04.309]                           computeRestarts <- base::computeRestarts
[16:21:04.309]                           grepl <- base::grepl
[16:21:04.309]                           restarts <- computeRestarts(cond)
[16:21:04.309]                           for (restart in restarts) {
[16:21:04.309]                             name <- restart$name
[16:21:04.309]                             if (is.null(name)) 
[16:21:04.309]                               next
[16:21:04.309]                             if (!grepl(pattern, name)) 
[16:21:04.309]                               next
[16:21:04.309]                             invokeRestart(restart)
[16:21:04.309]                             muffled <- TRUE
[16:21:04.309]                             break
[16:21:04.309]                           }
[16:21:04.309]                         }
[16:21:04.309]                       }
[16:21:04.309]                       invisible(muffled)
[16:21:04.309]                     }
[16:21:04.309]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.309]                   }
[16:21:04.309]                 }
[16:21:04.309]                 else {
[16:21:04.309]                   if (TRUE) {
[16:21:04.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.309]                     {
[16:21:04.309]                       inherits <- base::inherits
[16:21:04.309]                       invokeRestart <- base::invokeRestart
[16:21:04.309]                       is.null <- base::is.null
[16:21:04.309]                       muffled <- FALSE
[16:21:04.309]                       if (inherits(cond, "message")) {
[16:21:04.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.309]                         if (muffled) 
[16:21:04.309]                           invokeRestart("muffleMessage")
[16:21:04.309]                       }
[16:21:04.309]                       else if (inherits(cond, "warning")) {
[16:21:04.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.309]                         if (muffled) 
[16:21:04.309]                           invokeRestart("muffleWarning")
[16:21:04.309]                       }
[16:21:04.309]                       else if (inherits(cond, "condition")) {
[16:21:04.309]                         if (!is.null(pattern)) {
[16:21:04.309]                           computeRestarts <- base::computeRestarts
[16:21:04.309]                           grepl <- base::grepl
[16:21:04.309]                           restarts <- computeRestarts(cond)
[16:21:04.309]                           for (restart in restarts) {
[16:21:04.309]                             name <- restart$name
[16:21:04.309]                             if (is.null(name)) 
[16:21:04.309]                               next
[16:21:04.309]                             if (!grepl(pattern, name)) 
[16:21:04.309]                               next
[16:21:04.309]                             invokeRestart(restart)
[16:21:04.309]                             muffled <- TRUE
[16:21:04.309]                             break
[16:21:04.309]                           }
[16:21:04.309]                         }
[16:21:04.309]                       }
[16:21:04.309]                       invisible(muffled)
[16:21:04.309]                     }
[16:21:04.309]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.309]                   }
[16:21:04.309]                 }
[16:21:04.309]             }
[16:21:04.309]         }))
[16:21:04.309]     }, error = function(ex) {
[16:21:04.309]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.309]                 ...future.rng), started = ...future.startTime, 
[16:21:04.309]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.309]             version = "1.8"), class = "FutureResult")
[16:21:04.309]     }, finally = {
[16:21:04.309]         if (!identical(...future.workdir, getwd())) 
[16:21:04.309]             setwd(...future.workdir)
[16:21:04.309]         {
[16:21:04.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.309]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.309]             }
[16:21:04.309]             base::options(...future.oldOptions)
[16:21:04.309]             if (.Platform$OS.type == "windows") {
[16:21:04.309]                 old_names <- names(...future.oldEnvVars)
[16:21:04.309]                 envs <- base::Sys.getenv()
[16:21:04.309]                 names <- names(envs)
[16:21:04.309]                 common <- intersect(names, old_names)
[16:21:04.309]                 added <- setdiff(names, old_names)
[16:21:04.309]                 removed <- setdiff(old_names, names)
[16:21:04.309]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.309]                   envs[common]]
[16:21:04.309]                 NAMES <- toupper(changed)
[16:21:04.309]                 args <- list()
[16:21:04.309]                 for (kk in seq_along(NAMES)) {
[16:21:04.309]                   name <- changed[[kk]]
[16:21:04.309]                   NAME <- NAMES[[kk]]
[16:21:04.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.309]                     next
[16:21:04.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.309]                 }
[16:21:04.309]                 NAMES <- toupper(added)
[16:21:04.309]                 for (kk in seq_along(NAMES)) {
[16:21:04.309]                   name <- added[[kk]]
[16:21:04.309]                   NAME <- NAMES[[kk]]
[16:21:04.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.309]                     next
[16:21:04.309]                   args[[name]] <- ""
[16:21:04.309]                 }
[16:21:04.309]                 NAMES <- toupper(removed)
[16:21:04.309]                 for (kk in seq_along(NAMES)) {
[16:21:04.309]                   name <- removed[[kk]]
[16:21:04.309]                   NAME <- NAMES[[kk]]
[16:21:04.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.309]                     next
[16:21:04.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.309]                 }
[16:21:04.309]                 if (length(args) > 0) 
[16:21:04.309]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.309]             }
[16:21:04.309]             else {
[16:21:04.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.309]             }
[16:21:04.309]             {
[16:21:04.309]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.309]                   0L) {
[16:21:04.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.309]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.309]                   base::options(opts)
[16:21:04.309]                 }
[16:21:04.309]                 {
[16:21:04.309]                   {
[16:21:04.309]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.309]                     NULL
[16:21:04.309]                   }
[16:21:04.309]                   options(future.plan = NULL)
[16:21:04.309]                   if (is.na(NA_character_)) 
[16:21:04.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.309]                     .init = FALSE)
[16:21:04.309]                 }
[16:21:04.309]             }
[16:21:04.309]         }
[16:21:04.309]     })
[16:21:04.309]     if (TRUE) {
[16:21:04.309]         base::sink(type = "output", split = FALSE)
[16:21:04.309]         if (TRUE) {
[16:21:04.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.309]         }
[16:21:04.309]         else {
[16:21:04.309]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.309]         }
[16:21:04.309]         base::close(...future.stdout)
[16:21:04.309]         ...future.stdout <- NULL
[16:21:04.309]     }
[16:21:04.309]     ...future.result$conditions <- ...future.conditions
[16:21:04.309]     ...future.result$finished <- base::Sys.time()
[16:21:04.309]     ...future.result
[16:21:04.309] }
[16:21:04.311] requestCore(): workers = 2
[16:21:04.313] MulticoreFuture started
[16:21:04.314] - Launch lazy future ... done
[16:21:04.314] run() for ‘MulticoreFuture’ ... done
[16:21:04.314] plan(): Setting new future strategy stack:
[16:21:04.315] List of future strategies:
[16:21:04.315] 1. sequential:
[16:21:04.315]    - args: function (..., envir = parent.frame())
[16:21:04.315]    - tweaked: FALSE
[16:21:04.315]    - call: NULL
[16:21:04.316] plan(): nbrOfWorkers() = 1
[16:21:04.318] plan(): Setting new future strategy stack:
[16:21:04.318] List of future strategies:
[16:21:04.318] 1. multicore:
[16:21:04.318]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.318]    - tweaked: FALSE
[16:21:04.318]    - call: plan(strategy)
[16:21:04.323] plan(): nbrOfWorkers() = 2
[16:21:04.324] Future #1
[16:21:04.324] result() for MulticoreFuture ...
[16:21:04.325] result() for MulticoreFuture ...
[16:21:04.325] result() for MulticoreFuture ... done
[16:21:04.326] result() for MulticoreFuture ... done
[16:21:04.326] result() for MulticoreFuture ...
[16:21:04.326] result() for MulticoreFuture ... done
[16:21:04.326] A MulticoreFuture was resolved
[16:21:04.326]  length: 0 (resolved future 1)
[16:21:04.326] resolve() on list ... DONE
[16:21:04.327] - globals: [1] ‘a’
[16:21:04.327] Resolving futures part of globals (recursively) ... DONE
[16:21:04.328] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[16:21:04.329] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[16:21:04.329] - globals: [1] ‘a’
[16:21:04.329] - packages: [1] ‘future’
[16:21:04.329] getGlobalsAndPackages() ... DONE
[16:21:04.330] run() for ‘Future’ ...
[16:21:04.330] - state: ‘created’
[16:21:04.330] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.335] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.335] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.335]   - Field: ‘label’
[16:21:04.335]   - Field: ‘local’
[16:21:04.335]   - Field: ‘owner’
[16:21:04.335]   - Field: ‘envir’
[16:21:04.336]   - Field: ‘workers’
[16:21:04.336]   - Field: ‘packages’
[16:21:04.336]   - Field: ‘gc’
[16:21:04.336]   - Field: ‘job’
[16:21:04.336]   - Field: ‘conditions’
[16:21:04.336]   - Field: ‘expr’
[16:21:04.337]   - Field: ‘uuid’
[16:21:04.337]   - Field: ‘seed’
[16:21:04.337]   - Field: ‘version’
[16:21:04.337]   - Field: ‘result’
[16:21:04.337]   - Field: ‘asynchronous’
[16:21:04.337]   - Field: ‘calls’
[16:21:04.337]   - Field: ‘globals’
[16:21:04.337]   - Field: ‘stdout’
[16:21:04.338]   - Field: ‘earlySignal’
[16:21:04.338]   - Field: ‘lazy’
[16:21:04.338]   - Field: ‘state’
[16:21:04.338] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.338] - Launch lazy future ...
[16:21:04.338] Packages needed by the future expression (n = 1): ‘future’
[16:21:04.339] Packages needed by future strategies (n = 0): <none>
[16:21:04.339] {
[16:21:04.339]     {
[16:21:04.339]         {
[16:21:04.339]             ...future.startTime <- base::Sys.time()
[16:21:04.339]             {
[16:21:04.339]                 {
[16:21:04.339]                   {
[16:21:04.339]                     {
[16:21:04.339]                       {
[16:21:04.339]                         base::local({
[16:21:04.339]                           has_future <- base::requireNamespace("future", 
[16:21:04.339]                             quietly = TRUE)
[16:21:04.339]                           if (has_future) {
[16:21:04.339]                             ns <- base::getNamespace("future")
[16:21:04.339]                             version <- ns[[".package"]][["version"]]
[16:21:04.339]                             if (is.null(version)) 
[16:21:04.339]                               version <- utils::packageVersion("future")
[16:21:04.339]                           }
[16:21:04.339]                           else {
[16:21:04.339]                             version <- NULL
[16:21:04.339]                           }
[16:21:04.339]                           if (!has_future || version < "1.8.0") {
[16:21:04.339]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.339]                               "", base::R.version$version.string), 
[16:21:04.339]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:04.339]                                 base::R.version$platform, 8 * 
[16:21:04.339]                                   base::.Machine$sizeof.pointer), 
[16:21:04.339]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.339]                                 "release", "version")], collapse = " "), 
[16:21:04.339]                               hostname = base::Sys.info()[["nodename"]])
[16:21:04.339]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.339]                               info)
[16:21:04.339]                             info <- base::paste(info, collapse = "; ")
[16:21:04.339]                             if (!has_future) {
[16:21:04.339]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.339]                                 info)
[16:21:04.339]                             }
[16:21:04.339]                             else {
[16:21:04.339]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.339]                                 info, version)
[16:21:04.339]                             }
[16:21:04.339]                             base::stop(msg)
[16:21:04.339]                           }
[16:21:04.339]                         })
[16:21:04.339]                       }
[16:21:04.339]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.339]                       base::options(mc.cores = 1L)
[16:21:04.339]                     }
[16:21:04.339]                     base::local({
[16:21:04.339]                       for (pkg in "future") {
[16:21:04.339]                         base::loadNamespace(pkg)
[16:21:04.339]                         base::library(pkg, character.only = TRUE)
[16:21:04.339]                       }
[16:21:04.339]                     })
[16:21:04.339]                   }
[16:21:04.339]                   ...future.strategy.old <- future::plan("list")
[16:21:04.339]                   options(future.plan = NULL)
[16:21:04.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.339]                 }
[16:21:04.339]                 ...future.workdir <- getwd()
[16:21:04.339]             }
[16:21:04.339]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.339]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.339]         }
[16:21:04.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.339]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.339]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.339]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.339]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.339]             base::names(...future.oldOptions))
[16:21:04.339]     }
[16:21:04.339]     if (FALSE) {
[16:21:04.339]     }
[16:21:04.339]     else {
[16:21:04.339]         if (TRUE) {
[16:21:04.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.339]                 open = "w")
[16:21:04.339]         }
[16:21:04.339]         else {
[16:21:04.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.339]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.339]         }
[16:21:04.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.339]             base::sink(type = "output", split = FALSE)
[16:21:04.339]             base::close(...future.stdout)
[16:21:04.339]         }, add = TRUE)
[16:21:04.339]     }
[16:21:04.339]     ...future.frame <- base::sys.nframe()
[16:21:04.339]     ...future.conditions <- base::list()
[16:21:04.339]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.339]     if (FALSE) {
[16:21:04.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.339]     }
[16:21:04.339]     ...future.result <- base::tryCatch({
[16:21:04.339]         base::withCallingHandlers({
[16:21:04.339]             ...future.value <- base::withVisible(base::local({
[16:21:04.339]                 withCallingHandlers({
[16:21:04.339]                   value(a) + 1
[16:21:04.339]                 }, immediateCondition = function(cond) {
[16:21:04.339]                   save_rds <- function (object, pathname, ...) 
[16:21:04.339]                   {
[16:21:04.339]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.339]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.339]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.339]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.339]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.339]                         fi_tmp[["mtime"]])
[16:21:04.339]                     }
[16:21:04.339]                     tryCatch({
[16:21:04.339]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.339]                     }, error = function(ex) {
[16:21:04.339]                       msg <- conditionMessage(ex)
[16:21:04.339]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.339]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.339]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.339]                         fi_tmp[["mtime"]], msg)
[16:21:04.339]                       ex$message <- msg
[16:21:04.339]                       stop(ex)
[16:21:04.339]                     })
[16:21:04.339]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.339]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.339]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.339]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.339]                       fi <- file.info(pathname)
[16:21:04.339]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.339]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.339]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.339]                         fi[["size"]], fi[["mtime"]])
[16:21:04.339]                       stop(msg)
[16:21:04.339]                     }
[16:21:04.339]                     invisible(pathname)
[16:21:04.339]                   }
[16:21:04.339]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.339]                     rootPath = tempdir()) 
[16:21:04.339]                   {
[16:21:04.339]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.339]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.339]                       tmpdir = path, fileext = ".rds")
[16:21:04.339]                     save_rds(obj, file)
[16:21:04.339]                   }
[16:21:04.339]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.339]                   {
[16:21:04.339]                     inherits <- base::inherits
[16:21:04.339]                     invokeRestart <- base::invokeRestart
[16:21:04.339]                     is.null <- base::is.null
[16:21:04.339]                     muffled <- FALSE
[16:21:04.339]                     if (inherits(cond, "message")) {
[16:21:04.339]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.339]                       if (muffled) 
[16:21:04.339]                         invokeRestart("muffleMessage")
[16:21:04.339]                     }
[16:21:04.339]                     else if (inherits(cond, "warning")) {
[16:21:04.339]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.339]                       if (muffled) 
[16:21:04.339]                         invokeRestart("muffleWarning")
[16:21:04.339]                     }
[16:21:04.339]                     else if (inherits(cond, "condition")) {
[16:21:04.339]                       if (!is.null(pattern)) {
[16:21:04.339]                         computeRestarts <- base::computeRestarts
[16:21:04.339]                         grepl <- base::grepl
[16:21:04.339]                         restarts <- computeRestarts(cond)
[16:21:04.339]                         for (restart in restarts) {
[16:21:04.339]                           name <- restart$name
[16:21:04.339]                           if (is.null(name)) 
[16:21:04.339]                             next
[16:21:04.339]                           if (!grepl(pattern, name)) 
[16:21:04.339]                             next
[16:21:04.339]                           invokeRestart(restart)
[16:21:04.339]                           muffled <- TRUE
[16:21:04.339]                           break
[16:21:04.339]                         }
[16:21:04.339]                       }
[16:21:04.339]                     }
[16:21:04.339]                     invisible(muffled)
[16:21:04.339]                   }
[16:21:04.339]                   muffleCondition(cond)
[16:21:04.339]                 })
[16:21:04.339]             }))
[16:21:04.339]             future::FutureResult(value = ...future.value$value, 
[16:21:04.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.339]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.339]                     ...future.globalenv.names))
[16:21:04.339]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.339]         }, condition = base::local({
[16:21:04.339]             c <- base::c
[16:21:04.339]             inherits <- base::inherits
[16:21:04.339]             invokeRestart <- base::invokeRestart
[16:21:04.339]             length <- base::length
[16:21:04.339]             list <- base::list
[16:21:04.339]             seq.int <- base::seq.int
[16:21:04.339]             signalCondition <- base::signalCondition
[16:21:04.339]             sys.calls <- base::sys.calls
[16:21:04.339]             `[[` <- base::`[[`
[16:21:04.339]             `+` <- base::`+`
[16:21:04.339]             `<<-` <- base::`<<-`
[16:21:04.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.339]                   3L)]
[16:21:04.339]             }
[16:21:04.339]             function(cond) {
[16:21:04.339]                 is_error <- inherits(cond, "error")
[16:21:04.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.339]                   NULL)
[16:21:04.339]                 if (is_error) {
[16:21:04.339]                   sessionInformation <- function() {
[16:21:04.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.339]                       search = base::search(), system = base::Sys.info())
[16:21:04.339]                   }
[16:21:04.339]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.339]                     cond$call), session = sessionInformation(), 
[16:21:04.339]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.339]                   signalCondition(cond)
[16:21:04.339]                 }
[16:21:04.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.339]                 "immediateCondition"))) {
[16:21:04.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.339]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.339]                   if (TRUE && !signal) {
[16:21:04.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.339]                     {
[16:21:04.339]                       inherits <- base::inherits
[16:21:04.339]                       invokeRestart <- base::invokeRestart
[16:21:04.339]                       is.null <- base::is.null
[16:21:04.339]                       muffled <- FALSE
[16:21:04.339]                       if (inherits(cond, "message")) {
[16:21:04.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.339]                         if (muffled) 
[16:21:04.339]                           invokeRestart("muffleMessage")
[16:21:04.339]                       }
[16:21:04.339]                       else if (inherits(cond, "warning")) {
[16:21:04.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.339]                         if (muffled) 
[16:21:04.339]                           invokeRestart("muffleWarning")
[16:21:04.339]                       }
[16:21:04.339]                       else if (inherits(cond, "condition")) {
[16:21:04.339]                         if (!is.null(pattern)) {
[16:21:04.339]                           computeRestarts <- base::computeRestarts
[16:21:04.339]                           grepl <- base::grepl
[16:21:04.339]                           restarts <- computeRestarts(cond)
[16:21:04.339]                           for (restart in restarts) {
[16:21:04.339]                             name <- restart$name
[16:21:04.339]                             if (is.null(name)) 
[16:21:04.339]                               next
[16:21:04.339]                             if (!grepl(pattern, name)) 
[16:21:04.339]                               next
[16:21:04.339]                             invokeRestart(restart)
[16:21:04.339]                             muffled <- TRUE
[16:21:04.339]                             break
[16:21:04.339]                           }
[16:21:04.339]                         }
[16:21:04.339]                       }
[16:21:04.339]                       invisible(muffled)
[16:21:04.339]                     }
[16:21:04.339]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.339]                   }
[16:21:04.339]                 }
[16:21:04.339]                 else {
[16:21:04.339]                   if (TRUE) {
[16:21:04.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.339]                     {
[16:21:04.339]                       inherits <- base::inherits
[16:21:04.339]                       invokeRestart <- base::invokeRestart
[16:21:04.339]                       is.null <- base::is.null
[16:21:04.339]                       muffled <- FALSE
[16:21:04.339]                       if (inherits(cond, "message")) {
[16:21:04.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.339]                         if (muffled) 
[16:21:04.339]                           invokeRestart("muffleMessage")
[16:21:04.339]                       }
[16:21:04.339]                       else if (inherits(cond, "warning")) {
[16:21:04.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.339]                         if (muffled) 
[16:21:04.339]                           invokeRestart("muffleWarning")
[16:21:04.339]                       }
[16:21:04.339]                       else if (inherits(cond, "condition")) {
[16:21:04.339]                         if (!is.null(pattern)) {
[16:21:04.339]                           computeRestarts <- base::computeRestarts
[16:21:04.339]                           grepl <- base::grepl
[16:21:04.339]                           restarts <- computeRestarts(cond)
[16:21:04.339]                           for (restart in restarts) {
[16:21:04.339]                             name <- restart$name
[16:21:04.339]                             if (is.null(name)) 
[16:21:04.339]                               next
[16:21:04.339]                             if (!grepl(pattern, name)) 
[16:21:04.339]                               next
[16:21:04.339]                             invokeRestart(restart)
[16:21:04.339]                             muffled <- TRUE
[16:21:04.339]                             break
[16:21:04.339]                           }
[16:21:04.339]                         }
[16:21:04.339]                       }
[16:21:04.339]                       invisible(muffled)
[16:21:04.339]                     }
[16:21:04.339]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.339]                   }
[16:21:04.339]                 }
[16:21:04.339]             }
[16:21:04.339]         }))
[16:21:04.339]     }, error = function(ex) {
[16:21:04.339]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.339]                 ...future.rng), started = ...future.startTime, 
[16:21:04.339]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.339]             version = "1.8"), class = "FutureResult")
[16:21:04.339]     }, finally = {
[16:21:04.339]         if (!identical(...future.workdir, getwd())) 
[16:21:04.339]             setwd(...future.workdir)
[16:21:04.339]         {
[16:21:04.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.339]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.339]             }
[16:21:04.339]             base::options(...future.oldOptions)
[16:21:04.339]             if (.Platform$OS.type == "windows") {
[16:21:04.339]                 old_names <- names(...future.oldEnvVars)
[16:21:04.339]                 envs <- base::Sys.getenv()
[16:21:04.339]                 names <- names(envs)
[16:21:04.339]                 common <- intersect(names, old_names)
[16:21:04.339]                 added <- setdiff(names, old_names)
[16:21:04.339]                 removed <- setdiff(old_names, names)
[16:21:04.339]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.339]                   envs[common]]
[16:21:04.339]                 NAMES <- toupper(changed)
[16:21:04.339]                 args <- list()
[16:21:04.339]                 for (kk in seq_along(NAMES)) {
[16:21:04.339]                   name <- changed[[kk]]
[16:21:04.339]                   NAME <- NAMES[[kk]]
[16:21:04.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.339]                     next
[16:21:04.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.339]                 }
[16:21:04.339]                 NAMES <- toupper(added)
[16:21:04.339]                 for (kk in seq_along(NAMES)) {
[16:21:04.339]                   name <- added[[kk]]
[16:21:04.339]                   NAME <- NAMES[[kk]]
[16:21:04.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.339]                     next
[16:21:04.339]                   args[[name]] <- ""
[16:21:04.339]                 }
[16:21:04.339]                 NAMES <- toupper(removed)
[16:21:04.339]                 for (kk in seq_along(NAMES)) {
[16:21:04.339]                   name <- removed[[kk]]
[16:21:04.339]                   NAME <- NAMES[[kk]]
[16:21:04.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.339]                     next
[16:21:04.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.339]                 }
[16:21:04.339]                 if (length(args) > 0) 
[16:21:04.339]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.339]             }
[16:21:04.339]             else {
[16:21:04.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.339]             }
[16:21:04.339]             {
[16:21:04.339]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.339]                   0L) {
[16:21:04.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.339]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.339]                   base::options(opts)
[16:21:04.339]                 }
[16:21:04.339]                 {
[16:21:04.339]                   {
[16:21:04.339]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.339]                     NULL
[16:21:04.339]                   }
[16:21:04.339]                   options(future.plan = NULL)
[16:21:04.339]                   if (is.na(NA_character_)) 
[16:21:04.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.339]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.339]                     .init = FALSE)
[16:21:04.339]                 }
[16:21:04.339]             }
[16:21:04.339]         }
[16:21:04.339]     })
[16:21:04.339]     if (TRUE) {
[16:21:04.339]         base::sink(type = "output", split = FALSE)
[16:21:04.339]         if (TRUE) {
[16:21:04.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.339]         }
[16:21:04.339]         else {
[16:21:04.339]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.339]         }
[16:21:04.339]         base::close(...future.stdout)
[16:21:04.339]         ...future.stdout <- NULL
[16:21:04.339]     }
[16:21:04.339]     ...future.result$conditions <- ...future.conditions
[16:21:04.339]     ...future.result$finished <- base::Sys.time()
[16:21:04.339]     ...future.result
[16:21:04.339] }
[16:21:04.342] assign_globals() ...
[16:21:04.342] List of 1
[16:21:04.342]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5622285e8c30> 
[16:21:04.342]  - attr(*, "where")=List of 1
[16:21:04.342]   ..$ a:<environment: R_EmptyEnv> 
[16:21:04.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.342]  - attr(*, "resolved")= logi TRUE
[16:21:04.342]  - attr(*, "total_size")= num 10984
[16:21:04.342]  - attr(*, "already-done")= logi TRUE
[16:21:04.345] - copied ‘a’ to environment
[16:21:04.345] assign_globals() ... done
[16:21:04.346] requestCore(): workers = 2
[16:21:04.348] MulticoreFuture started
[16:21:04.348] - Launch lazy future ... done
[16:21:04.348] run() for ‘MulticoreFuture’ ... done
[16:21:04.348] result() for MulticoreFuture ...
[16:21:04.349] plan(): Setting new future strategy stack:
[16:21:04.349] List of future strategies:
[16:21:04.349] 1. sequential:
[16:21:04.349]    - args: function (..., envir = parent.frame())
[16:21:04.349]    - tweaked: FALSE
[16:21:04.349]    - call: NULL
[16:21:04.356] plan(): nbrOfWorkers() = 1
[16:21:04.361] plan(): Setting new future strategy stack:
[16:21:04.361] List of future strategies:
[16:21:04.361] 1. multicore:
[16:21:04.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.361]    - tweaked: FALSE
[16:21:04.361]    - call: plan(strategy)
[16:21:04.367] plan(): nbrOfWorkers() = 2
[16:21:04.371] result() for MulticoreFuture ...
[16:21:04.371] result() for MulticoreFuture ... done
[16:21:04.371] signalConditions() ...
[16:21:04.372]  - include = ‘immediateCondition’
[16:21:04.372]  - exclude = 
[16:21:04.372]  - resignal = FALSE
[16:21:04.372]  - Number of conditions: 4
[16:21:04.373] signalConditions() ... done
[16:21:04.373] result() for MulticoreFuture ... done
[16:21:04.373] result() for MulticoreFuture ...
[16:21:04.373] result() for MulticoreFuture ... done
[16:21:04.373] signalConditions() ...
[16:21:04.374]  - include = ‘immediateCondition’
[16:21:04.374]  - exclude = 
[16:21:04.374]  - resignal = FALSE
[16:21:04.374]  - Number of conditions: 4
[16:21:04.374] signalConditions() ... done
[16:21:04.374] Future state: ‘finished’
[16:21:04.375] result() for MulticoreFuture ...
[16:21:04.375] result() for MulticoreFuture ... done
[16:21:04.375] signalConditions() ...
[16:21:04.375]  - include = ‘condition’
[16:21:04.375]  - exclude = ‘immediateCondition’
[16:21:04.375]  - resignal = TRUE
[16:21:04.375]  - Number of conditions: 4
[16:21:04.375]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.358] result() for MulticoreFuture ...
[16:21:04.376]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.358] result() for MulticoreFuture ... done
[16:21:04.376]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.359] result() for MulticoreFuture ...
[16:21:04.376]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.359] result() for MulticoreFuture ... done
[16:21:04.376] signalConditions() ... done
value(b) = 2
[16:21:04.377] result() for MulticoreFuture ...
[16:21:04.377] result() for MulticoreFuture ... done
[16:21:04.377] result() for MulticoreFuture ...
[16:21:04.377] result() for MulticoreFuture ... done
[16:21:04.377] signalConditions() ...
[16:21:04.377]  - include = ‘immediateCondition’
[16:21:04.377]  - exclude = 
[16:21:04.378]  - resignal = FALSE
[16:21:04.378]  - Number of conditions: 4
[16:21:04.378] signalConditions() ... done
[16:21:04.378] Future state: ‘finished’
[16:21:04.378] result() for MulticoreFuture ...
[16:21:04.378] result() for MulticoreFuture ... done
[16:21:04.378] signalConditions() ...
[16:21:04.378]  - include = ‘condition’
[16:21:04.378]  - exclude = ‘immediateCondition’
[16:21:04.379]  - resignal = TRUE
[16:21:04.379]  - Number of conditions: 4
[16:21:04.379]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.358] result() for MulticoreFuture ...
[16:21:04.379]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.358] result() for MulticoreFuture ... done
[16:21:04.379]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.359] result() for MulticoreFuture ...
[16:21:04.379]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.359] result() for MulticoreFuture ... done
[16:21:04.379] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.380] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.380] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:04.381] - globals found: [2] ‘{’, ‘pkg’
[16:21:04.381] Searching for globals ... DONE
[16:21:04.381] Resolving globals: TRUE
[16:21:04.382] Resolving any globals that are futures ...
[16:21:04.382] - globals: [2] ‘{’, ‘pkg’
[16:21:04.382] Resolving any globals that are futures ... DONE
[16:21:04.382] Resolving futures part of globals (recursively) ...
[16:21:04.382] resolve() on list ...
[16:21:04.383]  recursive: 99
[16:21:04.383]  length: 1
[16:21:04.383]  elements: ‘pkg’
[16:21:04.383]  length: 0 (resolved future 1)
[16:21:04.383] resolve() on list ... DONE
[16:21:04.383] - globals: [1] ‘pkg’
[16:21:04.383] Resolving futures part of globals (recursively) ... DONE
[16:21:04.383] The total size of the 1 globals is 112 bytes (112 bytes)
[16:21:04.384] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:21:04.384] - globals: [1] ‘pkg’
[16:21:04.384] 
[16:21:04.384] getGlobalsAndPackages() ... DONE
[16:21:04.385] Packages needed by the future expression (n = 0): <none>
[16:21:04.385] Packages needed by future strategies (n = 0): <none>
[16:21:04.385] {
[16:21:04.385]     {
[16:21:04.385]         {
[16:21:04.385]             ...future.startTime <- base::Sys.time()
[16:21:04.385]             {
[16:21:04.385]                 {
[16:21:04.385]                   {
[16:21:04.385]                     base::local({
[16:21:04.385]                       has_future <- base::requireNamespace("future", 
[16:21:04.385]                         quietly = TRUE)
[16:21:04.385]                       if (has_future) {
[16:21:04.385]                         ns <- base::getNamespace("future")
[16:21:04.385]                         version <- ns[[".package"]][["version"]]
[16:21:04.385]                         if (is.null(version)) 
[16:21:04.385]                           version <- utils::packageVersion("future")
[16:21:04.385]                       }
[16:21:04.385]                       else {
[16:21:04.385]                         version <- NULL
[16:21:04.385]                       }
[16:21:04.385]                       if (!has_future || version < "1.8.0") {
[16:21:04.385]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.385]                           "", base::R.version$version.string), 
[16:21:04.385]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:04.385]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.385]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.385]                             "release", "version")], collapse = " "), 
[16:21:04.385]                           hostname = base::Sys.info()[["nodename"]])
[16:21:04.385]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.385]                           info)
[16:21:04.385]                         info <- base::paste(info, collapse = "; ")
[16:21:04.385]                         if (!has_future) {
[16:21:04.385]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.385]                             info)
[16:21:04.385]                         }
[16:21:04.385]                         else {
[16:21:04.385]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.385]                             info, version)
[16:21:04.385]                         }
[16:21:04.385]                         base::stop(msg)
[16:21:04.385]                       }
[16:21:04.385]                     })
[16:21:04.385]                   }
[16:21:04.385]                   ...future.strategy.old <- future::plan("list")
[16:21:04.385]                   options(future.plan = NULL)
[16:21:04.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.385]                 }
[16:21:04.385]                 ...future.workdir <- getwd()
[16:21:04.385]             }
[16:21:04.385]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.385]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.385]         }
[16:21:04.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.385]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:04.385]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.385]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.385]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.385]             base::names(...future.oldOptions))
[16:21:04.385]     }
[16:21:04.385]     if (FALSE) {
[16:21:04.385]     }
[16:21:04.385]     else {
[16:21:04.385]         if (TRUE) {
[16:21:04.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.385]                 open = "w")
[16:21:04.385]         }
[16:21:04.385]         else {
[16:21:04.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.385]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.385]         }
[16:21:04.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.385]             base::sink(type = "output", split = FALSE)
[16:21:04.385]             base::close(...future.stdout)
[16:21:04.385]         }, add = TRUE)
[16:21:04.385]     }
[16:21:04.385]     ...future.frame <- base::sys.nframe()
[16:21:04.385]     ...future.conditions <- base::list()
[16:21:04.385]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.385]     if (FALSE) {
[16:21:04.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.385]     }
[16:21:04.385]     ...future.result <- base::tryCatch({
[16:21:04.385]         base::withCallingHandlers({
[16:21:04.385]             ...future.value <- base::withVisible(base::local({
[16:21:04.385]                 pkg
[16:21:04.385]             }))
[16:21:04.385]             future::FutureResult(value = ...future.value$value, 
[16:21:04.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.385]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.385]                     ...future.globalenv.names))
[16:21:04.385]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.385]         }, condition = base::local({
[16:21:04.385]             c <- base::c
[16:21:04.385]             inherits <- base::inherits
[16:21:04.385]             invokeRestart <- base::invokeRestart
[16:21:04.385]             length <- base::length
[16:21:04.385]             list <- base::list
[16:21:04.385]             seq.int <- base::seq.int
[16:21:04.385]             signalCondition <- base::signalCondition
[16:21:04.385]             sys.calls <- base::sys.calls
[16:21:04.385]             `[[` <- base::`[[`
[16:21:04.385]             `+` <- base::`+`
[16:21:04.385]             `<<-` <- base::`<<-`
[16:21:04.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.385]                   3L)]
[16:21:04.385]             }
[16:21:04.385]             function(cond) {
[16:21:04.385]                 is_error <- inherits(cond, "error")
[16:21:04.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.385]                   NULL)
[16:21:04.385]                 if (is_error) {
[16:21:04.385]                   sessionInformation <- function() {
[16:21:04.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.385]                       search = base::search(), system = base::Sys.info())
[16:21:04.385]                   }
[16:21:04.385]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.385]                     cond$call), session = sessionInformation(), 
[16:21:04.385]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.385]                   signalCondition(cond)
[16:21:04.385]                 }
[16:21:04.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.385]                 "immediateCondition"))) {
[16:21:04.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.385]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.385]                   if (TRUE && !signal) {
[16:21:04.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.385]                     {
[16:21:04.385]                       inherits <- base::inherits
[16:21:04.385]                       invokeRestart <- base::invokeRestart
[16:21:04.385]                       is.null <- base::is.null
[16:21:04.385]                       muffled <- FALSE
[16:21:04.385]                       if (inherits(cond, "message")) {
[16:21:04.385]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.385]                         if (muffled) 
[16:21:04.385]                           invokeRestart("muffleMessage")
[16:21:04.385]                       }
[16:21:04.385]                       else if (inherits(cond, "warning")) {
[16:21:04.385]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.385]                         if (muffled) 
[16:21:04.385]                           invokeRestart("muffleWarning")
[16:21:04.385]                       }
[16:21:04.385]                       else if (inherits(cond, "condition")) {
[16:21:04.385]                         if (!is.null(pattern)) {
[16:21:04.385]                           computeRestarts <- base::computeRestarts
[16:21:04.385]                           grepl <- base::grepl
[16:21:04.385]                           restarts <- computeRestarts(cond)
[16:21:04.385]                           for (restart in restarts) {
[16:21:04.385]                             name <- restart$name
[16:21:04.385]                             if (is.null(name)) 
[16:21:04.385]                               next
[16:21:04.385]                             if (!grepl(pattern, name)) 
[16:21:04.385]                               next
[16:21:04.385]                             invokeRestart(restart)
[16:21:04.385]                             muffled <- TRUE
[16:21:04.385]                             break
[16:21:04.385]                           }
[16:21:04.385]                         }
[16:21:04.385]                       }
[16:21:04.385]                       invisible(muffled)
[16:21:04.385]                     }
[16:21:04.385]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.385]                   }
[16:21:04.385]                 }
[16:21:04.385]                 else {
[16:21:04.385]                   if (TRUE) {
[16:21:04.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.385]                     {
[16:21:04.385]                       inherits <- base::inherits
[16:21:04.385]                       invokeRestart <- base::invokeRestart
[16:21:04.385]                       is.null <- base::is.null
[16:21:04.385]                       muffled <- FALSE
[16:21:04.385]                       if (inherits(cond, "message")) {
[16:21:04.385]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.385]                         if (muffled) 
[16:21:04.385]                           invokeRestart("muffleMessage")
[16:21:04.385]                       }
[16:21:04.385]                       else if (inherits(cond, "warning")) {
[16:21:04.385]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.385]                         if (muffled) 
[16:21:04.385]                           invokeRestart("muffleWarning")
[16:21:04.385]                       }
[16:21:04.385]                       else if (inherits(cond, "condition")) {
[16:21:04.385]                         if (!is.null(pattern)) {
[16:21:04.385]                           computeRestarts <- base::computeRestarts
[16:21:04.385]                           grepl <- base::grepl
[16:21:04.385]                           restarts <- computeRestarts(cond)
[16:21:04.385]                           for (restart in restarts) {
[16:21:04.385]                             name <- restart$name
[16:21:04.385]                             if (is.null(name)) 
[16:21:04.385]                               next
[16:21:04.385]                             if (!grepl(pattern, name)) 
[16:21:04.385]                               next
[16:21:04.385]                             invokeRestart(restart)
[16:21:04.385]                             muffled <- TRUE
[16:21:04.385]                             break
[16:21:04.385]                           }
[16:21:04.385]                         }
[16:21:04.385]                       }
[16:21:04.385]                       invisible(muffled)
[16:21:04.385]                     }
[16:21:04.385]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.385]                   }
[16:21:04.385]                 }
[16:21:04.385]             }
[16:21:04.385]         }))
[16:21:04.385]     }, error = function(ex) {
[16:21:04.385]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.385]                 ...future.rng), started = ...future.startTime, 
[16:21:04.385]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.385]             version = "1.8"), class = "FutureResult")
[16:21:04.385]     }, finally = {
[16:21:04.385]         if (!identical(...future.workdir, getwd())) 
[16:21:04.385]             setwd(...future.workdir)
[16:21:04.385]         {
[16:21:04.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.385]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.385]             }
[16:21:04.385]             base::options(...future.oldOptions)
[16:21:04.385]             if (.Platform$OS.type == "windows") {
[16:21:04.385]                 old_names <- names(...future.oldEnvVars)
[16:21:04.385]                 envs <- base::Sys.getenv()
[16:21:04.385]                 names <- names(envs)
[16:21:04.385]                 common <- intersect(names, old_names)
[16:21:04.385]                 added <- setdiff(names, old_names)
[16:21:04.385]                 removed <- setdiff(old_names, names)
[16:21:04.385]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.385]                   envs[common]]
[16:21:04.385]                 NAMES <- toupper(changed)
[16:21:04.385]                 args <- list()
[16:21:04.385]                 for (kk in seq_along(NAMES)) {
[16:21:04.385]                   name <- changed[[kk]]
[16:21:04.385]                   NAME <- NAMES[[kk]]
[16:21:04.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.385]                     next
[16:21:04.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.385]                 }
[16:21:04.385]                 NAMES <- toupper(added)
[16:21:04.385]                 for (kk in seq_along(NAMES)) {
[16:21:04.385]                   name <- added[[kk]]
[16:21:04.385]                   NAME <- NAMES[[kk]]
[16:21:04.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.385]                     next
[16:21:04.385]                   args[[name]] <- ""
[16:21:04.385]                 }
[16:21:04.385]                 NAMES <- toupper(removed)
[16:21:04.385]                 for (kk in seq_along(NAMES)) {
[16:21:04.385]                   name <- removed[[kk]]
[16:21:04.385]                   NAME <- NAMES[[kk]]
[16:21:04.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.385]                     next
[16:21:04.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.385]                 }
[16:21:04.385]                 if (length(args) > 0) 
[16:21:04.385]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.385]             }
[16:21:04.385]             else {
[16:21:04.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.385]             }
[16:21:04.385]             {
[16:21:04.385]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.385]                   0L) {
[16:21:04.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.385]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.385]                   base::options(opts)
[16:21:04.385]                 }
[16:21:04.385]                 {
[16:21:04.385]                   {
[16:21:04.385]                     NULL
[16:21:04.385]                     RNGkind("Mersenne-Twister")
[16:21:04.385]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:04.385]                       inherits = FALSE)
[16:21:04.385]                   }
[16:21:04.385]                   options(future.plan = NULL)
[16:21:04.385]                   if (is.na(NA_character_)) 
[16:21:04.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.385]                     .init = FALSE)
[16:21:04.385]                 }
[16:21:04.385]             }
[16:21:04.385]         }
[16:21:04.385]     })
[16:21:04.385]     if (TRUE) {
[16:21:04.385]         base::sink(type = "output", split = FALSE)
[16:21:04.385]         if (TRUE) {
[16:21:04.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.385]         }
[16:21:04.385]         else {
[16:21:04.385]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.385]         }
[16:21:04.385]         base::close(...future.stdout)
[16:21:04.385]         ...future.stdout <- NULL
[16:21:04.385]     }
[16:21:04.385]     ...future.result$conditions <- ...future.conditions
[16:21:04.385]     ...future.result$finished <- base::Sys.time()
[16:21:04.385]     ...future.result
[16:21:04.385] }
[16:21:04.387] assign_globals() ...
[16:21:04.387] List of 1
[16:21:04.387]  $ pkg: chr "foo"
[16:21:04.387]  - attr(*, "where")=List of 1
[16:21:04.387]   ..$ pkg:<environment: R_EmptyEnv> 
[16:21:04.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.387]  - attr(*, "resolved")= logi TRUE
[16:21:04.387]  - attr(*, "total_size")= num 112
[16:21:04.390] - copied ‘pkg’ to environment
[16:21:04.390] assign_globals() ... done
[16:21:04.390] plan(): Setting new future strategy stack:
[16:21:04.390] List of future strategies:
[16:21:04.390] 1. sequential:
[16:21:04.390]    - args: function (..., envir = parent.frame())
[16:21:04.390]    - tweaked: FALSE
[16:21:04.390]    - call: NULL
[16:21:04.391] plan(): nbrOfWorkers() = 1
[16:21:04.392] plan(): Setting new future strategy stack:
[16:21:04.392] List of future strategies:
[16:21:04.392] 1. multicore:
[16:21:04.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.392]    - tweaked: FALSE
[16:21:04.392]    - call: plan(strategy)
[16:21:04.396] plan(): nbrOfWorkers() = 2
[16:21:04.396] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.397] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.397] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.401] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:04.401] Searching for globals ... DONE
[16:21:04.401] Resolving globals: TRUE
[16:21:04.401] Resolving any globals that are futures ...
[16:21:04.401] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:04.402] Resolving any globals that are futures ... DONE
[16:21:04.402] Resolving futures part of globals (recursively) ...
[16:21:04.402] resolve() on list ...
[16:21:04.402]  recursive: 99
[16:21:04.402]  length: 1
[16:21:04.402]  elements: ‘a’
[16:21:04.403]  length: 0 (resolved future 1)
[16:21:04.403] resolve() on list ... DONE
[16:21:04.403] - globals: [1] ‘a’
[16:21:04.403] Resolving futures part of globals (recursively) ... DONE
[16:21:04.403] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:04.403] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:21:04.403] - globals: [1] ‘a’
[16:21:04.404] 
[16:21:04.404] getGlobalsAndPackages() ... DONE
[16:21:04.404] run() for ‘Future’ ...
[16:21:04.404] - state: ‘created’
[16:21:04.404] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.408] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.408]   - Field: ‘label’
[16:21:04.408]   - Field: ‘local’
[16:21:04.408]   - Field: ‘owner’
[16:21:04.408]   - Field: ‘envir’
[16:21:04.408]   - Field: ‘workers’
[16:21:04.408]   - Field: ‘packages’
[16:21:04.409]   - Field: ‘gc’
[16:21:04.409]   - Field: ‘job’
[16:21:04.409]   - Field: ‘conditions’
[16:21:04.409]   - Field: ‘expr’
[16:21:04.409]   - Field: ‘uuid’
[16:21:04.409]   - Field: ‘seed’
[16:21:04.409]   - Field: ‘version’
[16:21:04.409]   - Field: ‘result’
[16:21:04.409]   - Field: ‘asynchronous’
[16:21:04.409]   - Field: ‘calls’
[16:21:04.410]   - Field: ‘globals’
[16:21:04.410]   - Field: ‘stdout’
[16:21:04.410]   - Field: ‘earlySignal’
[16:21:04.410]   - Field: ‘lazy’
[16:21:04.410]   - Field: ‘state’
[16:21:04.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.410] - Launch lazy future ...
[16:21:04.410] Packages needed by the future expression (n = 0): <none>
[16:21:04.410] Packages needed by future strategies (n = 0): <none>
[16:21:04.411] {
[16:21:04.411]     {
[16:21:04.411]         {
[16:21:04.411]             ...future.startTime <- base::Sys.time()
[16:21:04.411]             {
[16:21:04.411]                 {
[16:21:04.411]                   {
[16:21:04.411]                     {
[16:21:04.411]                       base::local({
[16:21:04.411]                         has_future <- base::requireNamespace("future", 
[16:21:04.411]                           quietly = TRUE)
[16:21:04.411]                         if (has_future) {
[16:21:04.411]                           ns <- base::getNamespace("future")
[16:21:04.411]                           version <- ns[[".package"]][["version"]]
[16:21:04.411]                           if (is.null(version)) 
[16:21:04.411]                             version <- utils::packageVersion("future")
[16:21:04.411]                         }
[16:21:04.411]                         else {
[16:21:04.411]                           version <- NULL
[16:21:04.411]                         }
[16:21:04.411]                         if (!has_future || version < "1.8.0") {
[16:21:04.411]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.411]                             "", base::R.version$version.string), 
[16:21:04.411]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.411]                               "release", "version")], collapse = " "), 
[16:21:04.411]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.411]                             info)
[16:21:04.411]                           info <- base::paste(info, collapse = "; ")
[16:21:04.411]                           if (!has_future) {
[16:21:04.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.411]                               info)
[16:21:04.411]                           }
[16:21:04.411]                           else {
[16:21:04.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.411]                               info, version)
[16:21:04.411]                           }
[16:21:04.411]                           base::stop(msg)
[16:21:04.411]                         }
[16:21:04.411]                       })
[16:21:04.411]                     }
[16:21:04.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.411]                     base::options(mc.cores = 1L)
[16:21:04.411]                   }
[16:21:04.411]                   ...future.strategy.old <- future::plan("list")
[16:21:04.411]                   options(future.plan = NULL)
[16:21:04.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.411]                 }
[16:21:04.411]                 ...future.workdir <- getwd()
[16:21:04.411]             }
[16:21:04.411]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.411]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.411]         }
[16:21:04.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.411]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.411]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.411]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.411]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.411]             base::names(...future.oldOptions))
[16:21:04.411]     }
[16:21:04.411]     if (FALSE) {
[16:21:04.411]     }
[16:21:04.411]     else {
[16:21:04.411]         if (TRUE) {
[16:21:04.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.411]                 open = "w")
[16:21:04.411]         }
[16:21:04.411]         else {
[16:21:04.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.411]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.411]         }
[16:21:04.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.411]             base::sink(type = "output", split = FALSE)
[16:21:04.411]             base::close(...future.stdout)
[16:21:04.411]         }, add = TRUE)
[16:21:04.411]     }
[16:21:04.411]     ...future.frame <- base::sys.nframe()
[16:21:04.411]     ...future.conditions <- base::list()
[16:21:04.411]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.411]     if (FALSE) {
[16:21:04.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.411]     }
[16:21:04.411]     ...future.result <- base::tryCatch({
[16:21:04.411]         base::withCallingHandlers({
[16:21:04.411]             ...future.value <- base::withVisible(base::local({
[16:21:04.411]                 withCallingHandlers({
[16:21:04.411]                   {
[16:21:04.411]                     b <- a
[16:21:04.411]                     a <- 2
[16:21:04.411]                     a * b
[16:21:04.411]                   }
[16:21:04.411]                 }, immediateCondition = function(cond) {
[16:21:04.411]                   save_rds <- function (object, pathname, ...) 
[16:21:04.411]                   {
[16:21:04.411]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.411]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.411]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.411]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.411]                         fi_tmp[["mtime"]])
[16:21:04.411]                     }
[16:21:04.411]                     tryCatch({
[16:21:04.411]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.411]                     }, error = function(ex) {
[16:21:04.411]                       msg <- conditionMessage(ex)
[16:21:04.411]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.411]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.411]                         fi_tmp[["mtime"]], msg)
[16:21:04.411]                       ex$message <- msg
[16:21:04.411]                       stop(ex)
[16:21:04.411]                     })
[16:21:04.411]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.411]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.411]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.411]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.411]                       fi <- file.info(pathname)
[16:21:04.411]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.411]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.411]                         fi[["size"]], fi[["mtime"]])
[16:21:04.411]                       stop(msg)
[16:21:04.411]                     }
[16:21:04.411]                     invisible(pathname)
[16:21:04.411]                   }
[16:21:04.411]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.411]                     rootPath = tempdir()) 
[16:21:04.411]                   {
[16:21:04.411]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.411]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.411]                       tmpdir = path, fileext = ".rds")
[16:21:04.411]                     save_rds(obj, file)
[16:21:04.411]                   }
[16:21:04.411]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.411]                   {
[16:21:04.411]                     inherits <- base::inherits
[16:21:04.411]                     invokeRestart <- base::invokeRestart
[16:21:04.411]                     is.null <- base::is.null
[16:21:04.411]                     muffled <- FALSE
[16:21:04.411]                     if (inherits(cond, "message")) {
[16:21:04.411]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.411]                       if (muffled) 
[16:21:04.411]                         invokeRestart("muffleMessage")
[16:21:04.411]                     }
[16:21:04.411]                     else if (inherits(cond, "warning")) {
[16:21:04.411]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.411]                       if (muffled) 
[16:21:04.411]                         invokeRestart("muffleWarning")
[16:21:04.411]                     }
[16:21:04.411]                     else if (inherits(cond, "condition")) {
[16:21:04.411]                       if (!is.null(pattern)) {
[16:21:04.411]                         computeRestarts <- base::computeRestarts
[16:21:04.411]                         grepl <- base::grepl
[16:21:04.411]                         restarts <- computeRestarts(cond)
[16:21:04.411]                         for (restart in restarts) {
[16:21:04.411]                           name <- restart$name
[16:21:04.411]                           if (is.null(name)) 
[16:21:04.411]                             next
[16:21:04.411]                           if (!grepl(pattern, name)) 
[16:21:04.411]                             next
[16:21:04.411]                           invokeRestart(restart)
[16:21:04.411]                           muffled <- TRUE
[16:21:04.411]                           break
[16:21:04.411]                         }
[16:21:04.411]                       }
[16:21:04.411]                     }
[16:21:04.411]                     invisible(muffled)
[16:21:04.411]                   }
[16:21:04.411]                   muffleCondition(cond)
[16:21:04.411]                 })
[16:21:04.411]             }))
[16:21:04.411]             future::FutureResult(value = ...future.value$value, 
[16:21:04.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.411]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.411]                     ...future.globalenv.names))
[16:21:04.411]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.411]         }, condition = base::local({
[16:21:04.411]             c <- base::c
[16:21:04.411]             inherits <- base::inherits
[16:21:04.411]             invokeRestart <- base::invokeRestart
[16:21:04.411]             length <- base::length
[16:21:04.411]             list <- base::list
[16:21:04.411]             seq.int <- base::seq.int
[16:21:04.411]             signalCondition <- base::signalCondition
[16:21:04.411]             sys.calls <- base::sys.calls
[16:21:04.411]             `[[` <- base::`[[`
[16:21:04.411]             `+` <- base::`+`
[16:21:04.411]             `<<-` <- base::`<<-`
[16:21:04.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.411]                   3L)]
[16:21:04.411]             }
[16:21:04.411]             function(cond) {
[16:21:04.411]                 is_error <- inherits(cond, "error")
[16:21:04.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.411]                   NULL)
[16:21:04.411]                 if (is_error) {
[16:21:04.411]                   sessionInformation <- function() {
[16:21:04.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.411]                       search = base::search(), system = base::Sys.info())
[16:21:04.411]                   }
[16:21:04.411]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.411]                     cond$call), session = sessionInformation(), 
[16:21:04.411]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.411]                   signalCondition(cond)
[16:21:04.411]                 }
[16:21:04.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.411]                 "immediateCondition"))) {
[16:21:04.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.411]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.411]                   if (TRUE && !signal) {
[16:21:04.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.411]                     {
[16:21:04.411]                       inherits <- base::inherits
[16:21:04.411]                       invokeRestart <- base::invokeRestart
[16:21:04.411]                       is.null <- base::is.null
[16:21:04.411]                       muffled <- FALSE
[16:21:04.411]                       if (inherits(cond, "message")) {
[16:21:04.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.411]                         if (muffled) 
[16:21:04.411]                           invokeRestart("muffleMessage")
[16:21:04.411]                       }
[16:21:04.411]                       else if (inherits(cond, "warning")) {
[16:21:04.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.411]                         if (muffled) 
[16:21:04.411]                           invokeRestart("muffleWarning")
[16:21:04.411]                       }
[16:21:04.411]                       else if (inherits(cond, "condition")) {
[16:21:04.411]                         if (!is.null(pattern)) {
[16:21:04.411]                           computeRestarts <- base::computeRestarts
[16:21:04.411]                           grepl <- base::grepl
[16:21:04.411]                           restarts <- computeRestarts(cond)
[16:21:04.411]                           for (restart in restarts) {
[16:21:04.411]                             name <- restart$name
[16:21:04.411]                             if (is.null(name)) 
[16:21:04.411]                               next
[16:21:04.411]                             if (!grepl(pattern, name)) 
[16:21:04.411]                               next
[16:21:04.411]                             invokeRestart(restart)
[16:21:04.411]                             muffled <- TRUE
[16:21:04.411]                             break
[16:21:04.411]                           }
[16:21:04.411]                         }
[16:21:04.411]                       }
[16:21:04.411]                       invisible(muffled)
[16:21:04.411]                     }
[16:21:04.411]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.411]                   }
[16:21:04.411]                 }
[16:21:04.411]                 else {
[16:21:04.411]                   if (TRUE) {
[16:21:04.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.411]                     {
[16:21:04.411]                       inherits <- base::inherits
[16:21:04.411]                       invokeRestart <- base::invokeRestart
[16:21:04.411]                       is.null <- base::is.null
[16:21:04.411]                       muffled <- FALSE
[16:21:04.411]                       if (inherits(cond, "message")) {
[16:21:04.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.411]                         if (muffled) 
[16:21:04.411]                           invokeRestart("muffleMessage")
[16:21:04.411]                       }
[16:21:04.411]                       else if (inherits(cond, "warning")) {
[16:21:04.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.411]                         if (muffled) 
[16:21:04.411]                           invokeRestart("muffleWarning")
[16:21:04.411]                       }
[16:21:04.411]                       else if (inherits(cond, "condition")) {
[16:21:04.411]                         if (!is.null(pattern)) {
[16:21:04.411]                           computeRestarts <- base::computeRestarts
[16:21:04.411]                           grepl <- base::grepl
[16:21:04.411]                           restarts <- computeRestarts(cond)
[16:21:04.411]                           for (restart in restarts) {
[16:21:04.411]                             name <- restart$name
[16:21:04.411]                             if (is.null(name)) 
[16:21:04.411]                               next
[16:21:04.411]                             if (!grepl(pattern, name)) 
[16:21:04.411]                               next
[16:21:04.411]                             invokeRestart(restart)
[16:21:04.411]                             muffled <- TRUE
[16:21:04.411]                             break
[16:21:04.411]                           }
[16:21:04.411]                         }
[16:21:04.411]                       }
[16:21:04.411]                       invisible(muffled)
[16:21:04.411]                     }
[16:21:04.411]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.411]                   }
[16:21:04.411]                 }
[16:21:04.411]             }
[16:21:04.411]         }))
[16:21:04.411]     }, error = function(ex) {
[16:21:04.411]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.411]                 ...future.rng), started = ...future.startTime, 
[16:21:04.411]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.411]             version = "1.8"), class = "FutureResult")
[16:21:04.411]     }, finally = {
[16:21:04.411]         if (!identical(...future.workdir, getwd())) 
[16:21:04.411]             setwd(...future.workdir)
[16:21:04.411]         {
[16:21:04.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.411]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.411]             }
[16:21:04.411]             base::options(...future.oldOptions)
[16:21:04.411]             if (.Platform$OS.type == "windows") {
[16:21:04.411]                 old_names <- names(...future.oldEnvVars)
[16:21:04.411]                 envs <- base::Sys.getenv()
[16:21:04.411]                 names <- names(envs)
[16:21:04.411]                 common <- intersect(names, old_names)
[16:21:04.411]                 added <- setdiff(names, old_names)
[16:21:04.411]                 removed <- setdiff(old_names, names)
[16:21:04.411]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.411]                   envs[common]]
[16:21:04.411]                 NAMES <- toupper(changed)
[16:21:04.411]                 args <- list()
[16:21:04.411]                 for (kk in seq_along(NAMES)) {
[16:21:04.411]                   name <- changed[[kk]]
[16:21:04.411]                   NAME <- NAMES[[kk]]
[16:21:04.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.411]                     next
[16:21:04.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.411]                 }
[16:21:04.411]                 NAMES <- toupper(added)
[16:21:04.411]                 for (kk in seq_along(NAMES)) {
[16:21:04.411]                   name <- added[[kk]]
[16:21:04.411]                   NAME <- NAMES[[kk]]
[16:21:04.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.411]                     next
[16:21:04.411]                   args[[name]] <- ""
[16:21:04.411]                 }
[16:21:04.411]                 NAMES <- toupper(removed)
[16:21:04.411]                 for (kk in seq_along(NAMES)) {
[16:21:04.411]                   name <- removed[[kk]]
[16:21:04.411]                   NAME <- NAMES[[kk]]
[16:21:04.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.411]                     next
[16:21:04.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.411]                 }
[16:21:04.411]                 if (length(args) > 0) 
[16:21:04.411]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.411]             }
[16:21:04.411]             else {
[16:21:04.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.411]             }
[16:21:04.411]             {
[16:21:04.411]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.411]                   0L) {
[16:21:04.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.411]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.411]                   base::options(opts)
[16:21:04.411]                 }
[16:21:04.411]                 {
[16:21:04.411]                   {
[16:21:04.411]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.411]                     NULL
[16:21:04.411]                   }
[16:21:04.411]                   options(future.plan = NULL)
[16:21:04.411]                   if (is.na(NA_character_)) 
[16:21:04.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.411]                     .init = FALSE)
[16:21:04.411]                 }
[16:21:04.411]             }
[16:21:04.411]         }
[16:21:04.411]     })
[16:21:04.411]     if (TRUE) {
[16:21:04.411]         base::sink(type = "output", split = FALSE)
[16:21:04.411]         if (TRUE) {
[16:21:04.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.411]         }
[16:21:04.411]         else {
[16:21:04.411]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.411]         }
[16:21:04.411]         base::close(...future.stdout)
[16:21:04.411]         ...future.stdout <- NULL
[16:21:04.411]     }
[16:21:04.411]     ...future.result$conditions <- ...future.conditions
[16:21:04.411]     ...future.result$finished <- base::Sys.time()
[16:21:04.411]     ...future.result
[16:21:04.411] }
[16:21:04.413] assign_globals() ...
[16:21:04.413] List of 1
[16:21:04.413]  $ a: num 3
[16:21:04.413]  - attr(*, "where")=List of 1
[16:21:04.413]   ..$ a:<environment: R_EmptyEnv> 
[16:21:04.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.413]  - attr(*, "resolved")= logi TRUE
[16:21:04.413]  - attr(*, "total_size")= num 56
[16:21:04.413]  - attr(*, "already-done")= logi TRUE
[16:21:04.416] - copied ‘a’ to environment
[16:21:04.416] assign_globals() ... done
[16:21:04.416] requestCore(): workers = 2
[16:21:04.418] MulticoreFuture started
[16:21:04.418] - Launch lazy future ... done
[16:21:04.419] run() for ‘MulticoreFuture’ ... done
[16:21:04.419] result() for MulticoreFuture ...
[16:21:04.419] plan(): Setting new future strategy stack:
[16:21:04.419] List of future strategies:
[16:21:04.419] 1. sequential:
[16:21:04.419]    - args: function (..., envir = parent.frame())
[16:21:04.419]    - tweaked: FALSE
[16:21:04.419]    - call: NULL
[16:21:04.420] plan(): nbrOfWorkers() = 1
[16:21:04.422] plan(): Setting new future strategy stack:
[16:21:04.422] List of future strategies:
[16:21:04.422] 1. multicore:
[16:21:04.422]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.422]    - tweaked: FALSE
[16:21:04.422]    - call: plan(strategy)
[16:21:04.428] plan(): nbrOfWorkers() = 2
[16:21:04.429] result() for MulticoreFuture ...
[16:21:04.429] result() for MulticoreFuture ... done
[16:21:04.429] result() for MulticoreFuture ... done
[16:21:04.429] result() for MulticoreFuture ...
[16:21:04.429] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.430] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.430] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.433] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:04.433] Searching for globals ... DONE
[16:21:04.442] Resolving globals: TRUE
[16:21:04.442] Resolving any globals that are futures ...
[16:21:04.443] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:04.443] Resolving any globals that are futures ... DONE
[16:21:04.443] Resolving futures part of globals (recursively) ...
[16:21:04.443] resolve() on list ...
[16:21:04.444]  recursive: 99
[16:21:04.444]  length: 1
[16:21:04.444]  elements: ‘a’
[16:21:04.444]  length: 0 (resolved future 1)
[16:21:04.444] resolve() on list ... DONE
[16:21:04.444] - globals: [1] ‘a’
[16:21:04.444] Resolving futures part of globals (recursively) ... DONE
[16:21:04.445] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:04.445] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:21:04.445] - globals: [1] ‘a’
[16:21:04.445] 
[16:21:04.445] getGlobalsAndPackages() ... DONE
[16:21:04.446] run() for ‘Future’ ...
[16:21:04.446] - state: ‘created’
[16:21:04.446] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.450] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.450]   - Field: ‘label’
[16:21:04.450]   - Field: ‘local’
[16:21:04.450]   - Field: ‘owner’
[16:21:04.451]   - Field: ‘envir’
[16:21:04.451]   - Field: ‘workers’
[16:21:04.451]   - Field: ‘packages’
[16:21:04.451]   - Field: ‘gc’
[16:21:04.451]   - Field: ‘job’
[16:21:04.451]   - Field: ‘conditions’
[16:21:04.451]   - Field: ‘expr’
[16:21:04.451]   - Field: ‘uuid’
[16:21:04.452]   - Field: ‘seed’
[16:21:04.452]   - Field: ‘version’
[16:21:04.452]   - Field: ‘result’
[16:21:04.452]   - Field: ‘asynchronous’
[16:21:04.452]   - Field: ‘calls’
[16:21:04.452]   - Field: ‘globals’
[16:21:04.452]   - Field: ‘stdout’
[16:21:04.453]   - Field: ‘earlySignal’
[16:21:04.453]   - Field: ‘lazy’
[16:21:04.453]   - Field: ‘state’
[16:21:04.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.453] - Launch lazy future ...
[16:21:04.453] Packages needed by the future expression (n = 0): <none>
[16:21:04.454] Packages needed by future strategies (n = 0): <none>
[16:21:04.454] {
[16:21:04.454]     {
[16:21:04.454]         {
[16:21:04.454]             ...future.startTime <- base::Sys.time()
[16:21:04.454]             {
[16:21:04.454]                 {
[16:21:04.454]                   {
[16:21:04.454]                     {
[16:21:04.454]                       base::local({
[16:21:04.454]                         has_future <- base::requireNamespace("future", 
[16:21:04.454]                           quietly = TRUE)
[16:21:04.454]                         if (has_future) {
[16:21:04.454]                           ns <- base::getNamespace("future")
[16:21:04.454]                           version <- ns[[".package"]][["version"]]
[16:21:04.454]                           if (is.null(version)) 
[16:21:04.454]                             version <- utils::packageVersion("future")
[16:21:04.454]                         }
[16:21:04.454]                         else {
[16:21:04.454]                           version <- NULL
[16:21:04.454]                         }
[16:21:04.454]                         if (!has_future || version < "1.8.0") {
[16:21:04.454]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.454]                             "", base::R.version$version.string), 
[16:21:04.454]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.454]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.454]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.454]                               "release", "version")], collapse = " "), 
[16:21:04.454]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.454]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.454]                             info)
[16:21:04.454]                           info <- base::paste(info, collapse = "; ")
[16:21:04.454]                           if (!has_future) {
[16:21:04.454]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.454]                               info)
[16:21:04.454]                           }
[16:21:04.454]                           else {
[16:21:04.454]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.454]                               info, version)
[16:21:04.454]                           }
[16:21:04.454]                           base::stop(msg)
[16:21:04.454]                         }
[16:21:04.454]                       })
[16:21:04.454]                     }
[16:21:04.454]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.454]                     base::options(mc.cores = 1L)
[16:21:04.454]                   }
[16:21:04.454]                   ...future.strategy.old <- future::plan("list")
[16:21:04.454]                   options(future.plan = NULL)
[16:21:04.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.454]                 }
[16:21:04.454]                 ...future.workdir <- getwd()
[16:21:04.454]             }
[16:21:04.454]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.454]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.454]         }
[16:21:04.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.454]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.454]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.454]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.454]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.454]             base::names(...future.oldOptions))
[16:21:04.454]     }
[16:21:04.454]     if (FALSE) {
[16:21:04.454]     }
[16:21:04.454]     else {
[16:21:04.454]         if (TRUE) {
[16:21:04.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.454]                 open = "w")
[16:21:04.454]         }
[16:21:04.454]         else {
[16:21:04.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.454]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.454]         }
[16:21:04.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.454]             base::sink(type = "output", split = FALSE)
[16:21:04.454]             base::close(...future.stdout)
[16:21:04.454]         }, add = TRUE)
[16:21:04.454]     }
[16:21:04.454]     ...future.frame <- base::sys.nframe()
[16:21:04.454]     ...future.conditions <- base::list()
[16:21:04.454]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.454]     if (FALSE) {
[16:21:04.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.454]     }
[16:21:04.454]     ...future.result <- base::tryCatch({
[16:21:04.454]         base::withCallingHandlers({
[16:21:04.454]             ...future.value <- base::withVisible(base::local({
[16:21:04.454]                 withCallingHandlers({
[16:21:04.454]                   {
[16:21:04.454]                     b <- a
[16:21:04.454]                     a <- 2
[16:21:04.454]                     a * b
[16:21:04.454]                   }
[16:21:04.454]                 }, immediateCondition = function(cond) {
[16:21:04.454]                   save_rds <- function (object, pathname, ...) 
[16:21:04.454]                   {
[16:21:04.454]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.454]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.454]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.454]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.454]                         fi_tmp[["mtime"]])
[16:21:04.454]                     }
[16:21:04.454]                     tryCatch({
[16:21:04.454]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.454]                     }, error = function(ex) {
[16:21:04.454]                       msg <- conditionMessage(ex)
[16:21:04.454]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.454]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.454]                         fi_tmp[["mtime"]], msg)
[16:21:04.454]                       ex$message <- msg
[16:21:04.454]                       stop(ex)
[16:21:04.454]                     })
[16:21:04.454]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.454]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.454]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.454]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.454]                       fi <- file.info(pathname)
[16:21:04.454]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.454]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.454]                         fi[["size"]], fi[["mtime"]])
[16:21:04.454]                       stop(msg)
[16:21:04.454]                     }
[16:21:04.454]                     invisible(pathname)
[16:21:04.454]                   }
[16:21:04.454]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.454]                     rootPath = tempdir()) 
[16:21:04.454]                   {
[16:21:04.454]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.454]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.454]                       tmpdir = path, fileext = ".rds")
[16:21:04.454]                     save_rds(obj, file)
[16:21:04.454]                   }
[16:21:04.454]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.454]                   {
[16:21:04.454]                     inherits <- base::inherits
[16:21:04.454]                     invokeRestart <- base::invokeRestart
[16:21:04.454]                     is.null <- base::is.null
[16:21:04.454]                     muffled <- FALSE
[16:21:04.454]                     if (inherits(cond, "message")) {
[16:21:04.454]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.454]                       if (muffled) 
[16:21:04.454]                         invokeRestart("muffleMessage")
[16:21:04.454]                     }
[16:21:04.454]                     else if (inherits(cond, "warning")) {
[16:21:04.454]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.454]                       if (muffled) 
[16:21:04.454]                         invokeRestart("muffleWarning")
[16:21:04.454]                     }
[16:21:04.454]                     else if (inherits(cond, "condition")) {
[16:21:04.454]                       if (!is.null(pattern)) {
[16:21:04.454]                         computeRestarts <- base::computeRestarts
[16:21:04.454]                         grepl <- base::grepl
[16:21:04.454]                         restarts <- computeRestarts(cond)
[16:21:04.454]                         for (restart in restarts) {
[16:21:04.454]                           name <- restart$name
[16:21:04.454]                           if (is.null(name)) 
[16:21:04.454]                             next
[16:21:04.454]                           if (!grepl(pattern, name)) 
[16:21:04.454]                             next
[16:21:04.454]                           invokeRestart(restart)
[16:21:04.454]                           muffled <- TRUE
[16:21:04.454]                           break
[16:21:04.454]                         }
[16:21:04.454]                       }
[16:21:04.454]                     }
[16:21:04.454]                     invisible(muffled)
[16:21:04.454]                   }
[16:21:04.454]                   muffleCondition(cond)
[16:21:04.454]                 })
[16:21:04.454]             }))
[16:21:04.454]             future::FutureResult(value = ...future.value$value, 
[16:21:04.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.454]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.454]                     ...future.globalenv.names))
[16:21:04.454]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.454]         }, condition = base::local({
[16:21:04.454]             c <- base::c
[16:21:04.454]             inherits <- base::inherits
[16:21:04.454]             invokeRestart <- base::invokeRestart
[16:21:04.454]             length <- base::length
[16:21:04.454]             list <- base::list
[16:21:04.454]             seq.int <- base::seq.int
[16:21:04.454]             signalCondition <- base::signalCondition
[16:21:04.454]             sys.calls <- base::sys.calls
[16:21:04.454]             `[[` <- base::`[[`
[16:21:04.454]             `+` <- base::`+`
[16:21:04.454]             `<<-` <- base::`<<-`
[16:21:04.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.454]                   3L)]
[16:21:04.454]             }
[16:21:04.454]             function(cond) {
[16:21:04.454]                 is_error <- inherits(cond, "error")
[16:21:04.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.454]                   NULL)
[16:21:04.454]                 if (is_error) {
[16:21:04.454]                   sessionInformation <- function() {
[16:21:04.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.454]                       search = base::search(), system = base::Sys.info())
[16:21:04.454]                   }
[16:21:04.454]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.454]                     cond$call), session = sessionInformation(), 
[16:21:04.454]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.454]                   signalCondition(cond)
[16:21:04.454]                 }
[16:21:04.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.454]                 "immediateCondition"))) {
[16:21:04.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.454]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.454]                   if (TRUE && !signal) {
[16:21:04.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.454]                     {
[16:21:04.454]                       inherits <- base::inherits
[16:21:04.454]                       invokeRestart <- base::invokeRestart
[16:21:04.454]                       is.null <- base::is.null
[16:21:04.454]                       muffled <- FALSE
[16:21:04.454]                       if (inherits(cond, "message")) {
[16:21:04.454]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.454]                         if (muffled) 
[16:21:04.454]                           invokeRestart("muffleMessage")
[16:21:04.454]                       }
[16:21:04.454]                       else if (inherits(cond, "warning")) {
[16:21:04.454]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.454]                         if (muffled) 
[16:21:04.454]                           invokeRestart("muffleWarning")
[16:21:04.454]                       }
[16:21:04.454]                       else if (inherits(cond, "condition")) {
[16:21:04.454]                         if (!is.null(pattern)) {
[16:21:04.454]                           computeRestarts <- base::computeRestarts
[16:21:04.454]                           grepl <- base::grepl
[16:21:04.454]                           restarts <- computeRestarts(cond)
[16:21:04.454]                           for (restart in restarts) {
[16:21:04.454]                             name <- restart$name
[16:21:04.454]                             if (is.null(name)) 
[16:21:04.454]                               next
[16:21:04.454]                             if (!grepl(pattern, name)) 
[16:21:04.454]                               next
[16:21:04.454]                             invokeRestart(restart)
[16:21:04.454]                             muffled <- TRUE
[16:21:04.454]                             break
[16:21:04.454]                           }
[16:21:04.454]                         }
[16:21:04.454]                       }
[16:21:04.454]                       invisible(muffled)
[16:21:04.454]                     }
[16:21:04.454]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.454]                   }
[16:21:04.454]                 }
[16:21:04.454]                 else {
[16:21:04.454]                   if (TRUE) {
[16:21:04.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.454]                     {
[16:21:04.454]                       inherits <- base::inherits
[16:21:04.454]                       invokeRestart <- base::invokeRestart
[16:21:04.454]                       is.null <- base::is.null
[16:21:04.454]                       muffled <- FALSE
[16:21:04.454]                       if (inherits(cond, "message")) {
[16:21:04.454]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.454]                         if (muffled) 
[16:21:04.454]                           invokeRestart("muffleMessage")
[16:21:04.454]                       }
[16:21:04.454]                       else if (inherits(cond, "warning")) {
[16:21:04.454]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.454]                         if (muffled) 
[16:21:04.454]                           invokeRestart("muffleWarning")
[16:21:04.454]                       }
[16:21:04.454]                       else if (inherits(cond, "condition")) {
[16:21:04.454]                         if (!is.null(pattern)) {
[16:21:04.454]                           computeRestarts <- base::computeRestarts
[16:21:04.454]                           grepl <- base::grepl
[16:21:04.454]                           restarts <- computeRestarts(cond)
[16:21:04.454]                           for (restart in restarts) {
[16:21:04.454]                             name <- restart$name
[16:21:04.454]                             if (is.null(name)) 
[16:21:04.454]                               next
[16:21:04.454]                             if (!grepl(pattern, name)) 
[16:21:04.454]                               next
[16:21:04.454]                             invokeRestart(restart)
[16:21:04.454]                             muffled <- TRUE
[16:21:04.454]                             break
[16:21:04.454]                           }
[16:21:04.454]                         }
[16:21:04.454]                       }
[16:21:04.454]                       invisible(muffled)
[16:21:04.454]                     }
[16:21:04.454]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.454]                   }
[16:21:04.454]                 }
[16:21:04.454]             }
[16:21:04.454]         }))
[16:21:04.454]     }, error = function(ex) {
[16:21:04.454]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.454]                 ...future.rng), started = ...future.startTime, 
[16:21:04.454]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.454]             version = "1.8"), class = "FutureResult")
[16:21:04.454]     }, finally = {
[16:21:04.454]         if (!identical(...future.workdir, getwd())) 
[16:21:04.454]             setwd(...future.workdir)
[16:21:04.454]         {
[16:21:04.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.454]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.454]             }
[16:21:04.454]             base::options(...future.oldOptions)
[16:21:04.454]             if (.Platform$OS.type == "windows") {
[16:21:04.454]                 old_names <- names(...future.oldEnvVars)
[16:21:04.454]                 envs <- base::Sys.getenv()
[16:21:04.454]                 names <- names(envs)
[16:21:04.454]                 common <- intersect(names, old_names)
[16:21:04.454]                 added <- setdiff(names, old_names)
[16:21:04.454]                 removed <- setdiff(old_names, names)
[16:21:04.454]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.454]                   envs[common]]
[16:21:04.454]                 NAMES <- toupper(changed)
[16:21:04.454]                 args <- list()
[16:21:04.454]                 for (kk in seq_along(NAMES)) {
[16:21:04.454]                   name <- changed[[kk]]
[16:21:04.454]                   NAME <- NAMES[[kk]]
[16:21:04.454]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.454]                     next
[16:21:04.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.454]                 }
[16:21:04.454]                 NAMES <- toupper(added)
[16:21:04.454]                 for (kk in seq_along(NAMES)) {
[16:21:04.454]                   name <- added[[kk]]
[16:21:04.454]                   NAME <- NAMES[[kk]]
[16:21:04.454]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.454]                     next
[16:21:04.454]                   args[[name]] <- ""
[16:21:04.454]                 }
[16:21:04.454]                 NAMES <- toupper(removed)
[16:21:04.454]                 for (kk in seq_along(NAMES)) {
[16:21:04.454]                   name <- removed[[kk]]
[16:21:04.454]                   NAME <- NAMES[[kk]]
[16:21:04.454]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.454]                     next
[16:21:04.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.454]                 }
[16:21:04.454]                 if (length(args) > 0) 
[16:21:04.454]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.454]             }
[16:21:04.454]             else {
[16:21:04.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.454]             }
[16:21:04.454]             {
[16:21:04.454]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.454]                   0L) {
[16:21:04.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.454]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.454]                   base::options(opts)
[16:21:04.454]                 }
[16:21:04.454]                 {
[16:21:04.454]                   {
[16:21:04.454]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.454]                     NULL
[16:21:04.454]                   }
[16:21:04.454]                   options(future.plan = NULL)
[16:21:04.454]                   if (is.na(NA_character_)) 
[16:21:04.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.454]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.454]                     .init = FALSE)
[16:21:04.454]                 }
[16:21:04.454]             }
[16:21:04.454]         }
[16:21:04.454]     })
[16:21:04.454]     if (TRUE) {
[16:21:04.454]         base::sink(type = "output", split = FALSE)
[16:21:04.454]         if (TRUE) {
[16:21:04.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.454]         }
[16:21:04.454]         else {
[16:21:04.454]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.454]         }
[16:21:04.454]         base::close(...future.stdout)
[16:21:04.454]         ...future.stdout <- NULL
[16:21:04.454]     }
[16:21:04.454]     ...future.result$conditions <- ...future.conditions
[16:21:04.454]     ...future.result$finished <- base::Sys.time()
[16:21:04.454]     ...future.result
[16:21:04.454] }
[16:21:04.456] assign_globals() ...
[16:21:04.457] List of 1
[16:21:04.457]  $ a: num 3
[16:21:04.457]  - attr(*, "where")=List of 1
[16:21:04.457]   ..$ a:<environment: R_EmptyEnv> 
[16:21:04.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.457]  - attr(*, "resolved")= logi TRUE
[16:21:04.457]  - attr(*, "total_size")= num 56
[16:21:04.457]  - attr(*, "already-done")= logi TRUE
[16:21:04.460] - copied ‘a’ to environment
[16:21:04.460] assign_globals() ... done
[16:21:04.460] requestCore(): workers = 2
[16:21:04.462] MulticoreFuture started
[16:21:04.462] - Launch lazy future ... done
[16:21:04.463] run() for ‘MulticoreFuture’ ... done
[16:21:04.463] result() for MulticoreFuture ...
[16:21:04.463] plan(): Setting new future strategy stack:
[16:21:04.463] List of future strategies:
[16:21:04.463] 1. sequential:
[16:21:04.463]    - args: function (..., envir = parent.frame())
[16:21:04.463]    - tweaked: FALSE
[16:21:04.463]    - call: NULL
[16:21:04.464] plan(): nbrOfWorkers() = 1
[16:21:04.467] plan(): Setting new future strategy stack:
[16:21:04.467] List of future strategies:
[16:21:04.467] 1. multicore:
[16:21:04.467]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.467]    - tweaked: FALSE
[16:21:04.467]    - call: plan(strategy)
[16:21:04.472] plan(): nbrOfWorkers() = 2
[16:21:04.473] result() for MulticoreFuture ...
[16:21:04.473] result() for MulticoreFuture ... done
[16:21:04.474] result() for MulticoreFuture ... done
[16:21:04.474] result() for MulticoreFuture ...
[16:21:04.474] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.475] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.475] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.478] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.478] Searching for globals ... DONE
[16:21:04.478] Resolving globals: TRUE
[16:21:04.478] Resolving any globals that are futures ...
[16:21:04.479] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.479] Resolving any globals that are futures ... DONE
[16:21:04.479] Resolving futures part of globals (recursively) ...
[16:21:04.480] resolve() on list ...
[16:21:04.480]  recursive: 99
[16:21:04.480]  length: 2
[16:21:04.480]  elements: ‘a’, ‘ii’
[16:21:04.480]  length: 1 (resolved future 1)
[16:21:04.480]  length: 0 (resolved future 2)
[16:21:04.480] resolve() on list ... DONE
[16:21:04.480] - globals: [2] ‘a’, ‘ii’
[16:21:04.481] Resolving futures part of globals (recursively) ... DONE
[16:21:04.481] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:04.481] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:04.482] - globals: [2] ‘a’, ‘ii’
[16:21:04.482] 
[16:21:04.482] getGlobalsAndPackages() ... DONE
[16:21:04.482] run() for ‘Future’ ...
[16:21:04.482] - state: ‘created’
[16:21:04.482] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.487] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.487]   - Field: ‘label’
[16:21:04.487]   - Field: ‘local’
[16:21:04.487]   - Field: ‘owner’
[16:21:04.487]   - Field: ‘envir’
[16:21:04.487]   - Field: ‘workers’
[16:21:04.488]   - Field: ‘packages’
[16:21:04.488]   - Field: ‘gc’
[16:21:04.488]   - Field: ‘job’
[16:21:04.488]   - Field: ‘conditions’
[16:21:04.488]   - Field: ‘expr’
[16:21:04.488]   - Field: ‘uuid’
[16:21:04.488]   - Field: ‘seed’
[16:21:04.488]   - Field: ‘version’
[16:21:04.489]   - Field: ‘result’
[16:21:04.489]   - Field: ‘asynchronous’
[16:21:04.489]   - Field: ‘calls’
[16:21:04.489]   - Field: ‘globals’
[16:21:04.489]   - Field: ‘stdout’
[16:21:04.489]   - Field: ‘earlySignal’
[16:21:04.489]   - Field: ‘lazy’
[16:21:04.489]   - Field: ‘state’
[16:21:04.490] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.490] - Launch lazy future ...
[16:21:04.490] Packages needed by the future expression (n = 0): <none>
[16:21:04.490] Packages needed by future strategies (n = 0): <none>
[16:21:04.491] {
[16:21:04.491]     {
[16:21:04.491]         {
[16:21:04.491]             ...future.startTime <- base::Sys.time()
[16:21:04.491]             {
[16:21:04.491]                 {
[16:21:04.491]                   {
[16:21:04.491]                     {
[16:21:04.491]                       base::local({
[16:21:04.491]                         has_future <- base::requireNamespace("future", 
[16:21:04.491]                           quietly = TRUE)
[16:21:04.491]                         if (has_future) {
[16:21:04.491]                           ns <- base::getNamespace("future")
[16:21:04.491]                           version <- ns[[".package"]][["version"]]
[16:21:04.491]                           if (is.null(version)) 
[16:21:04.491]                             version <- utils::packageVersion("future")
[16:21:04.491]                         }
[16:21:04.491]                         else {
[16:21:04.491]                           version <- NULL
[16:21:04.491]                         }
[16:21:04.491]                         if (!has_future || version < "1.8.0") {
[16:21:04.491]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.491]                             "", base::R.version$version.string), 
[16:21:04.491]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.491]                               "release", "version")], collapse = " "), 
[16:21:04.491]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.491]                             info)
[16:21:04.491]                           info <- base::paste(info, collapse = "; ")
[16:21:04.491]                           if (!has_future) {
[16:21:04.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.491]                               info)
[16:21:04.491]                           }
[16:21:04.491]                           else {
[16:21:04.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.491]                               info, version)
[16:21:04.491]                           }
[16:21:04.491]                           base::stop(msg)
[16:21:04.491]                         }
[16:21:04.491]                       })
[16:21:04.491]                     }
[16:21:04.491]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.491]                     base::options(mc.cores = 1L)
[16:21:04.491]                   }
[16:21:04.491]                   ...future.strategy.old <- future::plan("list")
[16:21:04.491]                   options(future.plan = NULL)
[16:21:04.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.491]                 }
[16:21:04.491]                 ...future.workdir <- getwd()
[16:21:04.491]             }
[16:21:04.491]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.491]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.491]         }
[16:21:04.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.491]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.491]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.491]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.491]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.491]             base::names(...future.oldOptions))
[16:21:04.491]     }
[16:21:04.491]     if (FALSE) {
[16:21:04.491]     }
[16:21:04.491]     else {
[16:21:04.491]         if (TRUE) {
[16:21:04.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.491]                 open = "w")
[16:21:04.491]         }
[16:21:04.491]         else {
[16:21:04.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.491]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.491]         }
[16:21:04.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.491]             base::sink(type = "output", split = FALSE)
[16:21:04.491]             base::close(...future.stdout)
[16:21:04.491]         }, add = TRUE)
[16:21:04.491]     }
[16:21:04.491]     ...future.frame <- base::sys.nframe()
[16:21:04.491]     ...future.conditions <- base::list()
[16:21:04.491]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.491]     if (FALSE) {
[16:21:04.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.491]     }
[16:21:04.491]     ...future.result <- base::tryCatch({
[16:21:04.491]         base::withCallingHandlers({
[16:21:04.491]             ...future.value <- base::withVisible(base::local({
[16:21:04.491]                 withCallingHandlers({
[16:21:04.491]                   {
[16:21:04.491]                     b <- a * ii
[16:21:04.491]                     a <- 0
[16:21:04.491]                     b
[16:21:04.491]                   }
[16:21:04.491]                 }, immediateCondition = function(cond) {
[16:21:04.491]                   save_rds <- function (object, pathname, ...) 
[16:21:04.491]                   {
[16:21:04.491]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.491]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.491]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.491]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.491]                         fi_tmp[["mtime"]])
[16:21:04.491]                     }
[16:21:04.491]                     tryCatch({
[16:21:04.491]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.491]                     }, error = function(ex) {
[16:21:04.491]                       msg <- conditionMessage(ex)
[16:21:04.491]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.491]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.491]                         fi_tmp[["mtime"]], msg)
[16:21:04.491]                       ex$message <- msg
[16:21:04.491]                       stop(ex)
[16:21:04.491]                     })
[16:21:04.491]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.491]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.491]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.491]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.491]                       fi <- file.info(pathname)
[16:21:04.491]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.491]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.491]                         fi[["size"]], fi[["mtime"]])
[16:21:04.491]                       stop(msg)
[16:21:04.491]                     }
[16:21:04.491]                     invisible(pathname)
[16:21:04.491]                   }
[16:21:04.491]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.491]                     rootPath = tempdir()) 
[16:21:04.491]                   {
[16:21:04.491]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.491]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.491]                       tmpdir = path, fileext = ".rds")
[16:21:04.491]                     save_rds(obj, file)
[16:21:04.491]                   }
[16:21:04.491]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.491]                   {
[16:21:04.491]                     inherits <- base::inherits
[16:21:04.491]                     invokeRestart <- base::invokeRestart
[16:21:04.491]                     is.null <- base::is.null
[16:21:04.491]                     muffled <- FALSE
[16:21:04.491]                     if (inherits(cond, "message")) {
[16:21:04.491]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.491]                       if (muffled) 
[16:21:04.491]                         invokeRestart("muffleMessage")
[16:21:04.491]                     }
[16:21:04.491]                     else if (inherits(cond, "warning")) {
[16:21:04.491]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.491]                       if (muffled) 
[16:21:04.491]                         invokeRestart("muffleWarning")
[16:21:04.491]                     }
[16:21:04.491]                     else if (inherits(cond, "condition")) {
[16:21:04.491]                       if (!is.null(pattern)) {
[16:21:04.491]                         computeRestarts <- base::computeRestarts
[16:21:04.491]                         grepl <- base::grepl
[16:21:04.491]                         restarts <- computeRestarts(cond)
[16:21:04.491]                         for (restart in restarts) {
[16:21:04.491]                           name <- restart$name
[16:21:04.491]                           if (is.null(name)) 
[16:21:04.491]                             next
[16:21:04.491]                           if (!grepl(pattern, name)) 
[16:21:04.491]                             next
[16:21:04.491]                           invokeRestart(restart)
[16:21:04.491]                           muffled <- TRUE
[16:21:04.491]                           break
[16:21:04.491]                         }
[16:21:04.491]                       }
[16:21:04.491]                     }
[16:21:04.491]                     invisible(muffled)
[16:21:04.491]                   }
[16:21:04.491]                   muffleCondition(cond)
[16:21:04.491]                 })
[16:21:04.491]             }))
[16:21:04.491]             future::FutureResult(value = ...future.value$value, 
[16:21:04.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.491]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.491]                     ...future.globalenv.names))
[16:21:04.491]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.491]         }, condition = base::local({
[16:21:04.491]             c <- base::c
[16:21:04.491]             inherits <- base::inherits
[16:21:04.491]             invokeRestart <- base::invokeRestart
[16:21:04.491]             length <- base::length
[16:21:04.491]             list <- base::list
[16:21:04.491]             seq.int <- base::seq.int
[16:21:04.491]             signalCondition <- base::signalCondition
[16:21:04.491]             sys.calls <- base::sys.calls
[16:21:04.491]             `[[` <- base::`[[`
[16:21:04.491]             `+` <- base::`+`
[16:21:04.491]             `<<-` <- base::`<<-`
[16:21:04.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.491]                   3L)]
[16:21:04.491]             }
[16:21:04.491]             function(cond) {
[16:21:04.491]                 is_error <- inherits(cond, "error")
[16:21:04.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.491]                   NULL)
[16:21:04.491]                 if (is_error) {
[16:21:04.491]                   sessionInformation <- function() {
[16:21:04.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.491]                       search = base::search(), system = base::Sys.info())
[16:21:04.491]                   }
[16:21:04.491]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.491]                     cond$call), session = sessionInformation(), 
[16:21:04.491]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.491]                   signalCondition(cond)
[16:21:04.491]                 }
[16:21:04.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.491]                 "immediateCondition"))) {
[16:21:04.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.491]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.491]                   if (TRUE && !signal) {
[16:21:04.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.491]                     {
[16:21:04.491]                       inherits <- base::inherits
[16:21:04.491]                       invokeRestart <- base::invokeRestart
[16:21:04.491]                       is.null <- base::is.null
[16:21:04.491]                       muffled <- FALSE
[16:21:04.491]                       if (inherits(cond, "message")) {
[16:21:04.491]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.491]                         if (muffled) 
[16:21:04.491]                           invokeRestart("muffleMessage")
[16:21:04.491]                       }
[16:21:04.491]                       else if (inherits(cond, "warning")) {
[16:21:04.491]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.491]                         if (muffled) 
[16:21:04.491]                           invokeRestart("muffleWarning")
[16:21:04.491]                       }
[16:21:04.491]                       else if (inherits(cond, "condition")) {
[16:21:04.491]                         if (!is.null(pattern)) {
[16:21:04.491]                           computeRestarts <- base::computeRestarts
[16:21:04.491]                           grepl <- base::grepl
[16:21:04.491]                           restarts <- computeRestarts(cond)
[16:21:04.491]                           for (restart in restarts) {
[16:21:04.491]                             name <- restart$name
[16:21:04.491]                             if (is.null(name)) 
[16:21:04.491]                               next
[16:21:04.491]                             if (!grepl(pattern, name)) 
[16:21:04.491]                               next
[16:21:04.491]                             invokeRestart(restart)
[16:21:04.491]                             muffled <- TRUE
[16:21:04.491]                             break
[16:21:04.491]                           }
[16:21:04.491]                         }
[16:21:04.491]                       }
[16:21:04.491]                       invisible(muffled)
[16:21:04.491]                     }
[16:21:04.491]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.491]                   }
[16:21:04.491]                 }
[16:21:04.491]                 else {
[16:21:04.491]                   if (TRUE) {
[16:21:04.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.491]                     {
[16:21:04.491]                       inherits <- base::inherits
[16:21:04.491]                       invokeRestart <- base::invokeRestart
[16:21:04.491]                       is.null <- base::is.null
[16:21:04.491]                       muffled <- FALSE
[16:21:04.491]                       if (inherits(cond, "message")) {
[16:21:04.491]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.491]                         if (muffled) 
[16:21:04.491]                           invokeRestart("muffleMessage")
[16:21:04.491]                       }
[16:21:04.491]                       else if (inherits(cond, "warning")) {
[16:21:04.491]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.491]                         if (muffled) 
[16:21:04.491]                           invokeRestart("muffleWarning")
[16:21:04.491]                       }
[16:21:04.491]                       else if (inherits(cond, "condition")) {
[16:21:04.491]                         if (!is.null(pattern)) {
[16:21:04.491]                           computeRestarts <- base::computeRestarts
[16:21:04.491]                           grepl <- base::grepl
[16:21:04.491]                           restarts <- computeRestarts(cond)
[16:21:04.491]                           for (restart in restarts) {
[16:21:04.491]                             name <- restart$name
[16:21:04.491]                             if (is.null(name)) 
[16:21:04.491]                               next
[16:21:04.491]                             if (!grepl(pattern, name)) 
[16:21:04.491]                               next
[16:21:04.491]                             invokeRestart(restart)
[16:21:04.491]                             muffled <- TRUE
[16:21:04.491]                             break
[16:21:04.491]                           }
[16:21:04.491]                         }
[16:21:04.491]                       }
[16:21:04.491]                       invisible(muffled)
[16:21:04.491]                     }
[16:21:04.491]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.491]                   }
[16:21:04.491]                 }
[16:21:04.491]             }
[16:21:04.491]         }))
[16:21:04.491]     }, error = function(ex) {
[16:21:04.491]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.491]                 ...future.rng), started = ...future.startTime, 
[16:21:04.491]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.491]             version = "1.8"), class = "FutureResult")
[16:21:04.491]     }, finally = {
[16:21:04.491]         if (!identical(...future.workdir, getwd())) 
[16:21:04.491]             setwd(...future.workdir)
[16:21:04.491]         {
[16:21:04.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.491]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.491]             }
[16:21:04.491]             base::options(...future.oldOptions)
[16:21:04.491]             if (.Platform$OS.type == "windows") {
[16:21:04.491]                 old_names <- names(...future.oldEnvVars)
[16:21:04.491]                 envs <- base::Sys.getenv()
[16:21:04.491]                 names <- names(envs)
[16:21:04.491]                 common <- intersect(names, old_names)
[16:21:04.491]                 added <- setdiff(names, old_names)
[16:21:04.491]                 removed <- setdiff(old_names, names)
[16:21:04.491]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.491]                   envs[common]]
[16:21:04.491]                 NAMES <- toupper(changed)
[16:21:04.491]                 args <- list()
[16:21:04.491]                 for (kk in seq_along(NAMES)) {
[16:21:04.491]                   name <- changed[[kk]]
[16:21:04.491]                   NAME <- NAMES[[kk]]
[16:21:04.491]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.491]                     next
[16:21:04.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.491]                 }
[16:21:04.491]                 NAMES <- toupper(added)
[16:21:04.491]                 for (kk in seq_along(NAMES)) {
[16:21:04.491]                   name <- added[[kk]]
[16:21:04.491]                   NAME <- NAMES[[kk]]
[16:21:04.491]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.491]                     next
[16:21:04.491]                   args[[name]] <- ""
[16:21:04.491]                 }
[16:21:04.491]                 NAMES <- toupper(removed)
[16:21:04.491]                 for (kk in seq_along(NAMES)) {
[16:21:04.491]                   name <- removed[[kk]]
[16:21:04.491]                   NAME <- NAMES[[kk]]
[16:21:04.491]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.491]                     next
[16:21:04.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.491]                 }
[16:21:04.491]                 if (length(args) > 0) 
[16:21:04.491]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.491]             }
[16:21:04.491]             else {
[16:21:04.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.491]             }
[16:21:04.491]             {
[16:21:04.491]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.491]                   0L) {
[16:21:04.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.491]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.491]                   base::options(opts)
[16:21:04.491]                 }
[16:21:04.491]                 {
[16:21:04.491]                   {
[16:21:04.491]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.491]                     NULL
[16:21:04.491]                   }
[16:21:04.491]                   options(future.plan = NULL)
[16:21:04.491]                   if (is.na(NA_character_)) 
[16:21:04.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.491]                     .init = FALSE)
[16:21:04.491]                 }
[16:21:04.491]             }
[16:21:04.491]         }
[16:21:04.491]     })
[16:21:04.491]     if (TRUE) {
[16:21:04.491]         base::sink(type = "output", split = FALSE)
[16:21:04.491]         if (TRUE) {
[16:21:04.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.491]         }
[16:21:04.491]         else {
[16:21:04.491]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.491]         }
[16:21:04.491]         base::close(...future.stdout)
[16:21:04.491]         ...future.stdout <- NULL
[16:21:04.491]     }
[16:21:04.491]     ...future.result$conditions <- ...future.conditions
[16:21:04.491]     ...future.result$finished <- base::Sys.time()
[16:21:04.491]     ...future.result
[16:21:04.491] }
[16:21:04.496] assign_globals() ...
[16:21:04.496] List of 2
[16:21:04.496]  $ a : num 1
[16:21:04.496]  $ ii: int 1
[16:21:04.496]  - attr(*, "where")=List of 2
[16:21:04.496]   ..$ a :<environment: R_EmptyEnv> 
[16:21:04.496]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:04.496]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.496]  - attr(*, "resolved")= logi TRUE
[16:21:04.496]  - attr(*, "total_size")= num 112
[16:21:04.496]  - attr(*, "already-done")= logi TRUE
[16:21:04.500] - copied ‘a’ to environment
[16:21:04.500] - copied ‘ii’ to environment
[16:21:04.500] assign_globals() ... done
[16:21:04.501] requestCore(): workers = 2
[16:21:04.503] MulticoreFuture started
[16:21:04.503] - Launch lazy future ... done
[16:21:04.503] run() for ‘MulticoreFuture’ ... done
[16:21:04.504] plan(): Setting new future strategy stack:
[16:21:04.504] List of future strategies:
[16:21:04.504] 1. sequential:
[16:21:04.504]    - args: function (..., envir = parent.frame())
[16:21:04.504]    - tweaked: FALSE
[16:21:04.504]    - call: NULL
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.505] plan(): nbrOfWorkers() = 1
[16:21:04.505] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.506] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.508] plan(): Setting new future strategy stack:
[16:21:04.508] List of future strategies:
[16:21:04.508] 1. multicore:
[16:21:04.508]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.508]    - tweaked: FALSE
[16:21:04.508]    - call: plan(strategy)
[16:21:04.512] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.513] Searching for globals ... DONE
[16:21:04.513] Resolving globals: TRUE
[16:21:04.513] Resolving any globals that are futures ...
[16:21:04.514] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.514] Resolving any globals that are futures ... DONE
[16:21:04.514] plan(): nbrOfWorkers() = 2
[16:21:04.515] Resolving futures part of globals (recursively) ...
[16:21:04.515] resolve() on list ...
[16:21:04.516]  recursive: 99
[16:21:04.516]  length: 2
[16:21:04.516]  elements: ‘a’, ‘ii’
[16:21:04.516]  length: 1 (resolved future 1)
[16:21:04.517]  length: 0 (resolved future 2)
[16:21:04.517] resolve() on list ... DONE
[16:21:04.517] - globals: [2] ‘a’, ‘ii’
[16:21:04.517] Resolving futures part of globals (recursively) ... DONE
[16:21:04.517] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:04.518] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:04.518] - globals: [2] ‘a’, ‘ii’
[16:21:04.519] 
[16:21:04.519] getGlobalsAndPackages() ... DONE
[16:21:04.519] run() for ‘Future’ ...
[16:21:04.519] - state: ‘created’
[16:21:04.520] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.524] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.524] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.524]   - Field: ‘label’
[16:21:04.525]   - Field: ‘local’
[16:21:04.525]   - Field: ‘owner’
[16:21:04.525]   - Field: ‘envir’
[16:21:04.525]   - Field: ‘workers’
[16:21:04.525]   - Field: ‘packages’
[16:21:04.525]   - Field: ‘gc’
[16:21:04.525]   - Field: ‘job’
[16:21:04.526]   - Field: ‘conditions’
[16:21:04.526]   - Field: ‘expr’
[16:21:04.526]   - Field: ‘uuid’
[16:21:04.526]   - Field: ‘seed’
[16:21:04.526]   - Field: ‘version’
[16:21:04.526]   - Field: ‘result’
[16:21:04.526]   - Field: ‘asynchronous’
[16:21:04.527]   - Field: ‘calls’
[16:21:04.527]   - Field: ‘globals’
[16:21:04.527]   - Field: ‘stdout’
[16:21:04.527]   - Field: ‘earlySignal’
[16:21:04.527]   - Field: ‘lazy’
[16:21:04.527]   - Field: ‘state’
[16:21:04.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.527] - Launch lazy future ...
[16:21:04.528] Packages needed by the future expression (n = 0): <none>
[16:21:04.528] Packages needed by future strategies (n = 0): <none>
[16:21:04.529] {
[16:21:04.529]     {
[16:21:04.529]         {
[16:21:04.529]             ...future.startTime <- base::Sys.time()
[16:21:04.529]             {
[16:21:04.529]                 {
[16:21:04.529]                   {
[16:21:04.529]                     {
[16:21:04.529]                       base::local({
[16:21:04.529]                         has_future <- base::requireNamespace("future", 
[16:21:04.529]                           quietly = TRUE)
[16:21:04.529]                         if (has_future) {
[16:21:04.529]                           ns <- base::getNamespace("future")
[16:21:04.529]                           version <- ns[[".package"]][["version"]]
[16:21:04.529]                           if (is.null(version)) 
[16:21:04.529]                             version <- utils::packageVersion("future")
[16:21:04.529]                         }
[16:21:04.529]                         else {
[16:21:04.529]                           version <- NULL
[16:21:04.529]                         }
[16:21:04.529]                         if (!has_future || version < "1.8.0") {
[16:21:04.529]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.529]                             "", base::R.version$version.string), 
[16:21:04.529]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.529]                               "release", "version")], collapse = " "), 
[16:21:04.529]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.529]                             info)
[16:21:04.529]                           info <- base::paste(info, collapse = "; ")
[16:21:04.529]                           if (!has_future) {
[16:21:04.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.529]                               info)
[16:21:04.529]                           }
[16:21:04.529]                           else {
[16:21:04.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.529]                               info, version)
[16:21:04.529]                           }
[16:21:04.529]                           base::stop(msg)
[16:21:04.529]                         }
[16:21:04.529]                       })
[16:21:04.529]                     }
[16:21:04.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.529]                     base::options(mc.cores = 1L)
[16:21:04.529]                   }
[16:21:04.529]                   ...future.strategy.old <- future::plan("list")
[16:21:04.529]                   options(future.plan = NULL)
[16:21:04.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.529]                 }
[16:21:04.529]                 ...future.workdir <- getwd()
[16:21:04.529]             }
[16:21:04.529]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.529]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.529]         }
[16:21:04.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.529]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.529]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.529]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.529]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.529]             base::names(...future.oldOptions))
[16:21:04.529]     }
[16:21:04.529]     if (FALSE) {
[16:21:04.529]     }
[16:21:04.529]     else {
[16:21:04.529]         if (TRUE) {
[16:21:04.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.529]                 open = "w")
[16:21:04.529]         }
[16:21:04.529]         else {
[16:21:04.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.529]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.529]         }
[16:21:04.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.529]             base::sink(type = "output", split = FALSE)
[16:21:04.529]             base::close(...future.stdout)
[16:21:04.529]         }, add = TRUE)
[16:21:04.529]     }
[16:21:04.529]     ...future.frame <- base::sys.nframe()
[16:21:04.529]     ...future.conditions <- base::list()
[16:21:04.529]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.529]     if (FALSE) {
[16:21:04.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.529]     }
[16:21:04.529]     ...future.result <- base::tryCatch({
[16:21:04.529]         base::withCallingHandlers({
[16:21:04.529]             ...future.value <- base::withVisible(base::local({
[16:21:04.529]                 withCallingHandlers({
[16:21:04.529]                   {
[16:21:04.529]                     b <- a * ii
[16:21:04.529]                     a <- 0
[16:21:04.529]                     b
[16:21:04.529]                   }
[16:21:04.529]                 }, immediateCondition = function(cond) {
[16:21:04.529]                   save_rds <- function (object, pathname, ...) 
[16:21:04.529]                   {
[16:21:04.529]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.529]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.529]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.529]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.529]                         fi_tmp[["mtime"]])
[16:21:04.529]                     }
[16:21:04.529]                     tryCatch({
[16:21:04.529]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.529]                     }, error = function(ex) {
[16:21:04.529]                       msg <- conditionMessage(ex)
[16:21:04.529]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.529]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.529]                         fi_tmp[["mtime"]], msg)
[16:21:04.529]                       ex$message <- msg
[16:21:04.529]                       stop(ex)
[16:21:04.529]                     })
[16:21:04.529]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.529]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.529]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.529]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.529]                       fi <- file.info(pathname)
[16:21:04.529]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.529]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.529]                         fi[["size"]], fi[["mtime"]])
[16:21:04.529]                       stop(msg)
[16:21:04.529]                     }
[16:21:04.529]                     invisible(pathname)
[16:21:04.529]                   }
[16:21:04.529]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.529]                     rootPath = tempdir()) 
[16:21:04.529]                   {
[16:21:04.529]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.529]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.529]                       tmpdir = path, fileext = ".rds")
[16:21:04.529]                     save_rds(obj, file)
[16:21:04.529]                   }
[16:21:04.529]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.529]                   {
[16:21:04.529]                     inherits <- base::inherits
[16:21:04.529]                     invokeRestart <- base::invokeRestart
[16:21:04.529]                     is.null <- base::is.null
[16:21:04.529]                     muffled <- FALSE
[16:21:04.529]                     if (inherits(cond, "message")) {
[16:21:04.529]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.529]                       if (muffled) 
[16:21:04.529]                         invokeRestart("muffleMessage")
[16:21:04.529]                     }
[16:21:04.529]                     else if (inherits(cond, "warning")) {
[16:21:04.529]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.529]                       if (muffled) 
[16:21:04.529]                         invokeRestart("muffleWarning")
[16:21:04.529]                     }
[16:21:04.529]                     else if (inherits(cond, "condition")) {
[16:21:04.529]                       if (!is.null(pattern)) {
[16:21:04.529]                         computeRestarts <- base::computeRestarts
[16:21:04.529]                         grepl <- base::grepl
[16:21:04.529]                         restarts <- computeRestarts(cond)
[16:21:04.529]                         for (restart in restarts) {
[16:21:04.529]                           name <- restart$name
[16:21:04.529]                           if (is.null(name)) 
[16:21:04.529]                             next
[16:21:04.529]                           if (!grepl(pattern, name)) 
[16:21:04.529]                             next
[16:21:04.529]                           invokeRestart(restart)
[16:21:04.529]                           muffled <- TRUE
[16:21:04.529]                           break
[16:21:04.529]                         }
[16:21:04.529]                       }
[16:21:04.529]                     }
[16:21:04.529]                     invisible(muffled)
[16:21:04.529]                   }
[16:21:04.529]                   muffleCondition(cond)
[16:21:04.529]                 })
[16:21:04.529]             }))
[16:21:04.529]             future::FutureResult(value = ...future.value$value, 
[16:21:04.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.529]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.529]                     ...future.globalenv.names))
[16:21:04.529]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.529]         }, condition = base::local({
[16:21:04.529]             c <- base::c
[16:21:04.529]             inherits <- base::inherits
[16:21:04.529]             invokeRestart <- base::invokeRestart
[16:21:04.529]             length <- base::length
[16:21:04.529]             list <- base::list
[16:21:04.529]             seq.int <- base::seq.int
[16:21:04.529]             signalCondition <- base::signalCondition
[16:21:04.529]             sys.calls <- base::sys.calls
[16:21:04.529]             `[[` <- base::`[[`
[16:21:04.529]             `+` <- base::`+`
[16:21:04.529]             `<<-` <- base::`<<-`
[16:21:04.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.529]                   3L)]
[16:21:04.529]             }
[16:21:04.529]             function(cond) {
[16:21:04.529]                 is_error <- inherits(cond, "error")
[16:21:04.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.529]                   NULL)
[16:21:04.529]                 if (is_error) {
[16:21:04.529]                   sessionInformation <- function() {
[16:21:04.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.529]                       search = base::search(), system = base::Sys.info())
[16:21:04.529]                   }
[16:21:04.529]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.529]                     cond$call), session = sessionInformation(), 
[16:21:04.529]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.529]                   signalCondition(cond)
[16:21:04.529]                 }
[16:21:04.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.529]                 "immediateCondition"))) {
[16:21:04.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.529]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.529]                   if (TRUE && !signal) {
[16:21:04.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.529]                     {
[16:21:04.529]                       inherits <- base::inherits
[16:21:04.529]                       invokeRestart <- base::invokeRestart
[16:21:04.529]                       is.null <- base::is.null
[16:21:04.529]                       muffled <- FALSE
[16:21:04.529]                       if (inherits(cond, "message")) {
[16:21:04.529]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.529]                         if (muffled) 
[16:21:04.529]                           invokeRestart("muffleMessage")
[16:21:04.529]                       }
[16:21:04.529]                       else if (inherits(cond, "warning")) {
[16:21:04.529]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.529]                         if (muffled) 
[16:21:04.529]                           invokeRestart("muffleWarning")
[16:21:04.529]                       }
[16:21:04.529]                       else if (inherits(cond, "condition")) {
[16:21:04.529]                         if (!is.null(pattern)) {
[16:21:04.529]                           computeRestarts <- base::computeRestarts
[16:21:04.529]                           grepl <- base::grepl
[16:21:04.529]                           restarts <- computeRestarts(cond)
[16:21:04.529]                           for (restart in restarts) {
[16:21:04.529]                             name <- restart$name
[16:21:04.529]                             if (is.null(name)) 
[16:21:04.529]                               next
[16:21:04.529]                             if (!grepl(pattern, name)) 
[16:21:04.529]                               next
[16:21:04.529]                             invokeRestart(restart)
[16:21:04.529]                             muffled <- TRUE
[16:21:04.529]                             break
[16:21:04.529]                           }
[16:21:04.529]                         }
[16:21:04.529]                       }
[16:21:04.529]                       invisible(muffled)
[16:21:04.529]                     }
[16:21:04.529]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.529]                   }
[16:21:04.529]                 }
[16:21:04.529]                 else {
[16:21:04.529]                   if (TRUE) {
[16:21:04.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.529]                     {
[16:21:04.529]                       inherits <- base::inherits
[16:21:04.529]                       invokeRestart <- base::invokeRestart
[16:21:04.529]                       is.null <- base::is.null
[16:21:04.529]                       muffled <- FALSE
[16:21:04.529]                       if (inherits(cond, "message")) {
[16:21:04.529]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.529]                         if (muffled) 
[16:21:04.529]                           invokeRestart("muffleMessage")
[16:21:04.529]                       }
[16:21:04.529]                       else if (inherits(cond, "warning")) {
[16:21:04.529]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.529]                         if (muffled) 
[16:21:04.529]                           invokeRestart("muffleWarning")
[16:21:04.529]                       }
[16:21:04.529]                       else if (inherits(cond, "condition")) {
[16:21:04.529]                         if (!is.null(pattern)) {
[16:21:04.529]                           computeRestarts <- base::computeRestarts
[16:21:04.529]                           grepl <- base::grepl
[16:21:04.529]                           restarts <- computeRestarts(cond)
[16:21:04.529]                           for (restart in restarts) {
[16:21:04.529]                             name <- restart$name
[16:21:04.529]                             if (is.null(name)) 
[16:21:04.529]                               next
[16:21:04.529]                             if (!grepl(pattern, name)) 
[16:21:04.529]                               next
[16:21:04.529]                             invokeRestart(restart)
[16:21:04.529]                             muffled <- TRUE
[16:21:04.529]                             break
[16:21:04.529]                           }
[16:21:04.529]                         }
[16:21:04.529]                       }
[16:21:04.529]                       invisible(muffled)
[16:21:04.529]                     }
[16:21:04.529]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.529]                   }
[16:21:04.529]                 }
[16:21:04.529]             }
[16:21:04.529]         }))
[16:21:04.529]     }, error = function(ex) {
[16:21:04.529]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.529]                 ...future.rng), started = ...future.startTime, 
[16:21:04.529]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.529]             version = "1.8"), class = "FutureResult")
[16:21:04.529]     }, finally = {
[16:21:04.529]         if (!identical(...future.workdir, getwd())) 
[16:21:04.529]             setwd(...future.workdir)
[16:21:04.529]         {
[16:21:04.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.529]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.529]             }
[16:21:04.529]             base::options(...future.oldOptions)
[16:21:04.529]             if (.Platform$OS.type == "windows") {
[16:21:04.529]                 old_names <- names(...future.oldEnvVars)
[16:21:04.529]                 envs <- base::Sys.getenv()
[16:21:04.529]                 names <- names(envs)
[16:21:04.529]                 common <- intersect(names, old_names)
[16:21:04.529]                 added <- setdiff(names, old_names)
[16:21:04.529]                 removed <- setdiff(old_names, names)
[16:21:04.529]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.529]                   envs[common]]
[16:21:04.529]                 NAMES <- toupper(changed)
[16:21:04.529]                 args <- list()
[16:21:04.529]                 for (kk in seq_along(NAMES)) {
[16:21:04.529]                   name <- changed[[kk]]
[16:21:04.529]                   NAME <- NAMES[[kk]]
[16:21:04.529]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.529]                     next
[16:21:04.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.529]                 }
[16:21:04.529]                 NAMES <- toupper(added)
[16:21:04.529]                 for (kk in seq_along(NAMES)) {
[16:21:04.529]                   name <- added[[kk]]
[16:21:04.529]                   NAME <- NAMES[[kk]]
[16:21:04.529]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.529]                     next
[16:21:04.529]                   args[[name]] <- ""
[16:21:04.529]                 }
[16:21:04.529]                 NAMES <- toupper(removed)
[16:21:04.529]                 for (kk in seq_along(NAMES)) {
[16:21:04.529]                   name <- removed[[kk]]
[16:21:04.529]                   NAME <- NAMES[[kk]]
[16:21:04.529]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.529]                     next
[16:21:04.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.529]                 }
[16:21:04.529]                 if (length(args) > 0) 
[16:21:04.529]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.529]             }
[16:21:04.529]             else {
[16:21:04.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.529]             }
[16:21:04.529]             {
[16:21:04.529]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.529]                   0L) {
[16:21:04.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.529]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.529]                   base::options(opts)
[16:21:04.529]                 }
[16:21:04.529]                 {
[16:21:04.529]                   {
[16:21:04.529]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.529]                     NULL
[16:21:04.529]                   }
[16:21:04.529]                   options(future.plan = NULL)
[16:21:04.529]                   if (is.na(NA_character_)) 
[16:21:04.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.529]                     .init = FALSE)
[16:21:04.529]                 }
[16:21:04.529]             }
[16:21:04.529]         }
[16:21:04.529]     })
[16:21:04.529]     if (TRUE) {
[16:21:04.529]         base::sink(type = "output", split = FALSE)
[16:21:04.529]         if (TRUE) {
[16:21:04.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.529]         }
[16:21:04.529]         else {
[16:21:04.529]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.529]         }
[16:21:04.529]         base::close(...future.stdout)
[16:21:04.529]         ...future.stdout <- NULL
[16:21:04.529]     }
[16:21:04.529]     ...future.result$conditions <- ...future.conditions
[16:21:04.529]     ...future.result$finished <- base::Sys.time()
[16:21:04.529]     ...future.result
[16:21:04.529] }
[16:21:04.532] assign_globals() ...
[16:21:04.532] List of 2
[16:21:04.532]  $ a : num 1
[16:21:04.532]  $ ii: int 2
[16:21:04.532]  - attr(*, "where")=List of 2
[16:21:04.532]   ..$ a :<environment: R_EmptyEnv> 
[16:21:04.532]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:04.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.532]  - attr(*, "resolved")= logi TRUE
[16:21:04.532]  - attr(*, "total_size")= num 112
[16:21:04.532]  - attr(*, "already-done")= logi TRUE
[16:21:04.536] - copied ‘a’ to environment
[16:21:04.536] - copied ‘ii’ to environment
[16:21:04.536] assign_globals() ... done
[16:21:04.537] requestCore(): workers = 2
[16:21:04.539] MulticoreFuture started
[16:21:04.539] - Launch lazy future ... done
[16:21:04.539] run() for ‘MulticoreFuture’ ... done
[16:21:04.540] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.541] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.540] List of future strategies:
[16:21:04.540] 1. sequential:
[16:21:04.540]    - args: function (..., envir = parent.frame())
[16:21:04.540]    - tweaked: FALSE
[16:21:04.540]    - call: NULL
[16:21:04.541] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.541] plan(): nbrOfWorkers() = 1
[16:21:04.544] plan(): Setting new future strategy stack:
[16:21:04.544] List of future strategies:
[16:21:04.544] 1. multicore:
[16:21:04.544]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.544]    - tweaked: FALSE
[16:21:04.544]    - call: plan(strategy)
[16:21:04.545] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.549] plan(): nbrOfWorkers() = 2
[16:21:04.546] Searching for globals ... DONE
[16:21:04.551] Resolving globals: TRUE
[16:21:04.551] Resolving any globals that are futures ...
[16:21:04.551] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.552] Resolving any globals that are futures ... DONE
[16:21:04.553] Resolving futures part of globals (recursively) ...
[16:21:04.553] resolve() on list ...
[16:21:04.553]  recursive: 99
[16:21:04.554]  length: 2
[16:21:04.554]  elements: ‘a’, ‘ii’
[16:21:04.554]  length: 1 (resolved future 1)
[16:21:04.554]  length: 0 (resolved future 2)
[16:21:04.554] resolve() on list ... DONE
[16:21:04.554] - globals: [2] ‘a’, ‘ii’
[16:21:04.555] Resolving futures part of globals (recursively) ... DONE
[16:21:04.555] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:04.556] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:04.556] - globals: [2] ‘a’, ‘ii’
[16:21:04.556] 
[16:21:04.557] getGlobalsAndPackages() ... DONE
[16:21:04.557] run() for ‘Future’ ...
[16:21:04.557] - state: ‘created’
[16:21:04.558] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.562] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.562]   - Field: ‘label’
[16:21:04.563]   - Field: ‘local’
[16:21:04.563]   - Field: ‘owner’
[16:21:04.563]   - Field: ‘envir’
[16:21:04.563]   - Field: ‘workers’
[16:21:04.563]   - Field: ‘packages’
[16:21:04.564]   - Field: ‘gc’
[16:21:04.564]   - Field: ‘job’
[16:21:04.564]   - Field: ‘conditions’
[16:21:04.564]   - Field: ‘expr’
[16:21:04.565]   - Field: ‘uuid’
[16:21:04.565]   - Field: ‘seed’
[16:21:04.565]   - Field: ‘version’
[16:21:04.565]   - Field: ‘result’
[16:21:04.565]   - Field: ‘asynchronous’
[16:21:04.565]   - Field: ‘calls’
[16:21:04.566]   - Field: ‘globals’
[16:21:04.566]   - Field: ‘stdout’
[16:21:04.566]   - Field: ‘earlySignal’
[16:21:04.566]   - Field: ‘lazy’
[16:21:04.566]   - Field: ‘state’
[16:21:04.566] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.567] - Launch lazy future ...
[16:21:04.567] Packages needed by the future expression (n = 0): <none>
[16:21:04.567] Packages needed by future strategies (n = 0): <none>
[16:21:04.568] {
[16:21:04.568]     {
[16:21:04.568]         {
[16:21:04.568]             ...future.startTime <- base::Sys.time()
[16:21:04.568]             {
[16:21:04.568]                 {
[16:21:04.568]                   {
[16:21:04.568]                     {
[16:21:04.568]                       base::local({
[16:21:04.568]                         has_future <- base::requireNamespace("future", 
[16:21:04.568]                           quietly = TRUE)
[16:21:04.568]                         if (has_future) {
[16:21:04.568]                           ns <- base::getNamespace("future")
[16:21:04.568]                           version <- ns[[".package"]][["version"]]
[16:21:04.568]                           if (is.null(version)) 
[16:21:04.568]                             version <- utils::packageVersion("future")
[16:21:04.568]                         }
[16:21:04.568]                         else {
[16:21:04.568]                           version <- NULL
[16:21:04.568]                         }
[16:21:04.568]                         if (!has_future || version < "1.8.0") {
[16:21:04.568]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.568]                             "", base::R.version$version.string), 
[16:21:04.568]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.568]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.568]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.568]                               "release", "version")], collapse = " "), 
[16:21:04.568]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.568]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.568]                             info)
[16:21:04.568]                           info <- base::paste(info, collapse = "; ")
[16:21:04.568]                           if (!has_future) {
[16:21:04.568]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.568]                               info)
[16:21:04.568]                           }
[16:21:04.568]                           else {
[16:21:04.568]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.568]                               info, version)
[16:21:04.568]                           }
[16:21:04.568]                           base::stop(msg)
[16:21:04.568]                         }
[16:21:04.568]                       })
[16:21:04.568]                     }
[16:21:04.568]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.568]                     base::options(mc.cores = 1L)
[16:21:04.568]                   }
[16:21:04.568]                   ...future.strategy.old <- future::plan("list")
[16:21:04.568]                   options(future.plan = NULL)
[16:21:04.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.568]                 }
[16:21:04.568]                 ...future.workdir <- getwd()
[16:21:04.568]             }
[16:21:04.568]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.568]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.568]         }
[16:21:04.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.568]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.568]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.568]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.568]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.568]             base::names(...future.oldOptions))
[16:21:04.568]     }
[16:21:04.568]     if (FALSE) {
[16:21:04.568]     }
[16:21:04.568]     else {
[16:21:04.568]         if (TRUE) {
[16:21:04.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.568]                 open = "w")
[16:21:04.568]         }
[16:21:04.568]         else {
[16:21:04.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.568]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.568]         }
[16:21:04.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.568]             base::sink(type = "output", split = FALSE)
[16:21:04.568]             base::close(...future.stdout)
[16:21:04.568]         }, add = TRUE)
[16:21:04.568]     }
[16:21:04.568]     ...future.frame <- base::sys.nframe()
[16:21:04.568]     ...future.conditions <- base::list()
[16:21:04.568]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.568]     if (FALSE) {
[16:21:04.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.568]     }
[16:21:04.568]     ...future.result <- base::tryCatch({
[16:21:04.568]         base::withCallingHandlers({
[16:21:04.568]             ...future.value <- base::withVisible(base::local({
[16:21:04.568]                 withCallingHandlers({
[16:21:04.568]                   {
[16:21:04.568]                     b <- a * ii
[16:21:04.568]                     a <- 0
[16:21:04.568]                     b
[16:21:04.568]                   }
[16:21:04.568]                 }, immediateCondition = function(cond) {
[16:21:04.568]                   save_rds <- function (object, pathname, ...) 
[16:21:04.568]                   {
[16:21:04.568]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.568]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.568]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.568]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.568]                         fi_tmp[["mtime"]])
[16:21:04.568]                     }
[16:21:04.568]                     tryCatch({
[16:21:04.568]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.568]                     }, error = function(ex) {
[16:21:04.568]                       msg <- conditionMessage(ex)
[16:21:04.568]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.568]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.568]                         fi_tmp[["mtime"]], msg)
[16:21:04.568]                       ex$message <- msg
[16:21:04.568]                       stop(ex)
[16:21:04.568]                     })
[16:21:04.568]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.568]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.568]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.568]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.568]                       fi <- file.info(pathname)
[16:21:04.568]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.568]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.568]                         fi[["size"]], fi[["mtime"]])
[16:21:04.568]                       stop(msg)
[16:21:04.568]                     }
[16:21:04.568]                     invisible(pathname)
[16:21:04.568]                   }
[16:21:04.568]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.568]                     rootPath = tempdir()) 
[16:21:04.568]                   {
[16:21:04.568]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.568]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.568]                       tmpdir = path, fileext = ".rds")
[16:21:04.568]                     save_rds(obj, file)
[16:21:04.568]                   }
[16:21:04.568]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.568]                   {
[16:21:04.568]                     inherits <- base::inherits
[16:21:04.568]                     invokeRestart <- base::invokeRestart
[16:21:04.568]                     is.null <- base::is.null
[16:21:04.568]                     muffled <- FALSE
[16:21:04.568]                     if (inherits(cond, "message")) {
[16:21:04.568]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.568]                       if (muffled) 
[16:21:04.568]                         invokeRestart("muffleMessage")
[16:21:04.568]                     }
[16:21:04.568]                     else if (inherits(cond, "warning")) {
[16:21:04.568]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.568]                       if (muffled) 
[16:21:04.568]                         invokeRestart("muffleWarning")
[16:21:04.568]                     }
[16:21:04.568]                     else if (inherits(cond, "condition")) {
[16:21:04.568]                       if (!is.null(pattern)) {
[16:21:04.568]                         computeRestarts <- base::computeRestarts
[16:21:04.568]                         grepl <- base::grepl
[16:21:04.568]                         restarts <- computeRestarts(cond)
[16:21:04.568]                         for (restart in restarts) {
[16:21:04.568]                           name <- restart$name
[16:21:04.568]                           if (is.null(name)) 
[16:21:04.568]                             next
[16:21:04.568]                           if (!grepl(pattern, name)) 
[16:21:04.568]                             next
[16:21:04.568]                           invokeRestart(restart)
[16:21:04.568]                           muffled <- TRUE
[16:21:04.568]                           break
[16:21:04.568]                         }
[16:21:04.568]                       }
[16:21:04.568]                     }
[16:21:04.568]                     invisible(muffled)
[16:21:04.568]                   }
[16:21:04.568]                   muffleCondition(cond)
[16:21:04.568]                 })
[16:21:04.568]             }))
[16:21:04.568]             future::FutureResult(value = ...future.value$value, 
[16:21:04.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.568]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.568]                     ...future.globalenv.names))
[16:21:04.568]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.568]         }, condition = base::local({
[16:21:04.568]             c <- base::c
[16:21:04.568]             inherits <- base::inherits
[16:21:04.568]             invokeRestart <- base::invokeRestart
[16:21:04.568]             length <- base::length
[16:21:04.568]             list <- base::list
[16:21:04.568]             seq.int <- base::seq.int
[16:21:04.568]             signalCondition <- base::signalCondition
[16:21:04.568]             sys.calls <- base::sys.calls
[16:21:04.568]             `[[` <- base::`[[`
[16:21:04.568]             `+` <- base::`+`
[16:21:04.568]             `<<-` <- base::`<<-`
[16:21:04.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.568]                   3L)]
[16:21:04.568]             }
[16:21:04.568]             function(cond) {
[16:21:04.568]                 is_error <- inherits(cond, "error")
[16:21:04.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.568]                   NULL)
[16:21:04.568]                 if (is_error) {
[16:21:04.568]                   sessionInformation <- function() {
[16:21:04.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.568]                       search = base::search(), system = base::Sys.info())
[16:21:04.568]                   }
[16:21:04.568]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.568]                     cond$call), session = sessionInformation(), 
[16:21:04.568]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.568]                   signalCondition(cond)
[16:21:04.568]                 }
[16:21:04.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.568]                 "immediateCondition"))) {
[16:21:04.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.568]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.568]                   if (TRUE && !signal) {
[16:21:04.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.568]                     {
[16:21:04.568]                       inherits <- base::inherits
[16:21:04.568]                       invokeRestart <- base::invokeRestart
[16:21:04.568]                       is.null <- base::is.null
[16:21:04.568]                       muffled <- FALSE
[16:21:04.568]                       if (inherits(cond, "message")) {
[16:21:04.568]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.568]                         if (muffled) 
[16:21:04.568]                           invokeRestart("muffleMessage")
[16:21:04.568]                       }
[16:21:04.568]                       else if (inherits(cond, "warning")) {
[16:21:04.568]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.568]                         if (muffled) 
[16:21:04.568]                           invokeRestart("muffleWarning")
[16:21:04.568]                       }
[16:21:04.568]                       else if (inherits(cond, "condition")) {
[16:21:04.568]                         if (!is.null(pattern)) {
[16:21:04.568]                           computeRestarts <- base::computeRestarts
[16:21:04.568]                           grepl <- base::grepl
[16:21:04.568]                           restarts <- computeRestarts(cond)
[16:21:04.568]                           for (restart in restarts) {
[16:21:04.568]                             name <- restart$name
[16:21:04.568]                             if (is.null(name)) 
[16:21:04.568]                               next
[16:21:04.568]                             if (!grepl(pattern, name)) 
[16:21:04.568]                               next
[16:21:04.568]                             invokeRestart(restart)
[16:21:04.568]                             muffled <- TRUE
[16:21:04.568]                             break
[16:21:04.568]                           }
[16:21:04.568]                         }
[16:21:04.568]                       }
[16:21:04.568]                       invisible(muffled)
[16:21:04.568]                     }
[16:21:04.568]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.568]                   }
[16:21:04.568]                 }
[16:21:04.568]                 else {
[16:21:04.568]                   if (TRUE) {
[16:21:04.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.568]                     {
[16:21:04.568]                       inherits <- base::inherits
[16:21:04.568]                       invokeRestart <- base::invokeRestart
[16:21:04.568]                       is.null <- base::is.null
[16:21:04.568]                       muffled <- FALSE
[16:21:04.568]                       if (inherits(cond, "message")) {
[16:21:04.568]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.568]                         if (muffled) 
[16:21:04.568]                           invokeRestart("muffleMessage")
[16:21:04.568]                       }
[16:21:04.568]                       else if (inherits(cond, "warning")) {
[16:21:04.568]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.568]                         if (muffled) 
[16:21:04.568]                           invokeRestart("muffleWarning")
[16:21:04.568]                       }
[16:21:04.568]                       else if (inherits(cond, "condition")) {
[16:21:04.568]                         if (!is.null(pattern)) {
[16:21:04.568]                           computeRestarts <- base::computeRestarts
[16:21:04.568]                           grepl <- base::grepl
[16:21:04.568]                           restarts <- computeRestarts(cond)
[16:21:04.568]                           for (restart in restarts) {
[16:21:04.568]                             name <- restart$name
[16:21:04.568]                             if (is.null(name)) 
[16:21:04.568]                               next
[16:21:04.568]                             if (!grepl(pattern, name)) 
[16:21:04.568]                               next
[16:21:04.568]                             invokeRestart(restart)
[16:21:04.568]                             muffled <- TRUE
[16:21:04.568]                             break
[16:21:04.568]                           }
[16:21:04.568]                         }
[16:21:04.568]                       }
[16:21:04.568]                       invisible(muffled)
[16:21:04.568]                     }
[16:21:04.568]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.568]                   }
[16:21:04.568]                 }
[16:21:04.568]             }
[16:21:04.568]         }))
[16:21:04.568]     }, error = function(ex) {
[16:21:04.568]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.568]                 ...future.rng), started = ...future.startTime, 
[16:21:04.568]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.568]             version = "1.8"), class = "FutureResult")
[16:21:04.568]     }, finally = {
[16:21:04.568]         if (!identical(...future.workdir, getwd())) 
[16:21:04.568]             setwd(...future.workdir)
[16:21:04.568]         {
[16:21:04.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.568]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.568]             }
[16:21:04.568]             base::options(...future.oldOptions)
[16:21:04.568]             if (.Platform$OS.type == "windows") {
[16:21:04.568]                 old_names <- names(...future.oldEnvVars)
[16:21:04.568]                 envs <- base::Sys.getenv()
[16:21:04.568]                 names <- names(envs)
[16:21:04.568]                 common <- intersect(names, old_names)
[16:21:04.568]                 added <- setdiff(names, old_names)
[16:21:04.568]                 removed <- setdiff(old_names, names)
[16:21:04.568]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.568]                   envs[common]]
[16:21:04.568]                 NAMES <- toupper(changed)
[16:21:04.568]                 args <- list()
[16:21:04.568]                 for (kk in seq_along(NAMES)) {
[16:21:04.568]                   name <- changed[[kk]]
[16:21:04.568]                   NAME <- NAMES[[kk]]
[16:21:04.568]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.568]                     next
[16:21:04.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.568]                 }
[16:21:04.568]                 NAMES <- toupper(added)
[16:21:04.568]                 for (kk in seq_along(NAMES)) {
[16:21:04.568]                   name <- added[[kk]]
[16:21:04.568]                   NAME <- NAMES[[kk]]
[16:21:04.568]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.568]                     next
[16:21:04.568]                   args[[name]] <- ""
[16:21:04.568]                 }
[16:21:04.568]                 NAMES <- toupper(removed)
[16:21:04.568]                 for (kk in seq_along(NAMES)) {
[16:21:04.568]                   name <- removed[[kk]]
[16:21:04.568]                   NAME <- NAMES[[kk]]
[16:21:04.568]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.568]                     next
[16:21:04.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.568]                 }
[16:21:04.568]                 if (length(args) > 0) 
[16:21:04.568]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.568]             }
[16:21:04.568]             else {
[16:21:04.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.568]             }
[16:21:04.568]             {
[16:21:04.568]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.568]                   0L) {
[16:21:04.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.568]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.568]                   base::options(opts)
[16:21:04.568]                 }
[16:21:04.568]                 {
[16:21:04.568]                   {
[16:21:04.568]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.568]                     NULL
[16:21:04.568]                   }
[16:21:04.568]                   options(future.plan = NULL)
[16:21:04.568]                   if (is.na(NA_character_)) 
[16:21:04.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.568]                     .init = FALSE)
[16:21:04.568]                 }
[16:21:04.568]             }
[16:21:04.568]         }
[16:21:04.568]     })
[16:21:04.568]     if (TRUE) {
[16:21:04.568]         base::sink(type = "output", split = FALSE)
[16:21:04.568]         if (TRUE) {
[16:21:04.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.568]         }
[16:21:04.568]         else {
[16:21:04.568]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.568]         }
[16:21:04.568]         base::close(...future.stdout)
[16:21:04.568]         ...future.stdout <- NULL
[16:21:04.568]     }
[16:21:04.568]     ...future.result$conditions <- ...future.conditions
[16:21:04.568]     ...future.result$finished <- base::Sys.time()
[16:21:04.568]     ...future.result
[16:21:04.568] }
[16:21:04.570] assign_globals() ...
[16:21:04.571] List of 2
[16:21:04.571]  $ a : num 1
[16:21:04.571]  $ ii: int 3
[16:21:04.571]  - attr(*, "where")=List of 2
[16:21:04.571]   ..$ a :<environment: R_EmptyEnv> 
[16:21:04.571]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:04.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.571]  - attr(*, "resolved")= logi TRUE
[16:21:04.571]  - attr(*, "total_size")= num 112
[16:21:04.571]  - attr(*, "already-done")= logi TRUE
[16:21:04.575] - copied ‘a’ to environment
[16:21:04.575] - copied ‘ii’ to environment
[16:21:04.576] assign_globals() ... done
[16:21:04.576] requestCore(): workers = 2
[16:21:04.576] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:04.597] result() for MulticoreFuture ...
[16:21:04.597] result() for MulticoreFuture ...
[16:21:04.600] result() for MulticoreFuture ... done
[16:21:04.600] result() for MulticoreFuture ... done
[16:21:04.600] result() for MulticoreFuture ...
[16:21:04.600] result() for MulticoreFuture ... done
[16:21:04.603] MulticoreFuture started
[16:21:04.603] - Launch lazy future ... done
[16:21:04.603] run() for ‘MulticoreFuture’ ... done
[16:21:04.604] plan(): Setting new future strategy stack:
[16:21:04.604] result() for MulticoreFuture ...
[16:21:04.604] result() for MulticoreFuture ... done
[16:21:04.605] result() for MulticoreFuture ...
[16:21:04.605] result() for MulticoreFuture ... done
[16:21:04.604] List of future strategies:
[16:21:04.604] 1. sequential:
[16:21:04.604]    - args: function (..., envir = parent.frame())
[16:21:04.604]    - tweaked: FALSE
[16:21:04.604]    - call: NULL
[16:21:04.605] result() for MulticoreFuture ...
[16:21:04.605] plan(): nbrOfWorkers() = 1
[16:21:04.607] result() for MulticoreFuture ...
[16:21:04.607] result() for MulticoreFuture ... done
[16:21:04.607] result() for MulticoreFuture ... done
[16:21:04.608] plan(): Setting new future strategy stack:
[16:21:04.608] result() for MulticoreFuture ...
[16:21:04.608] result() for MulticoreFuture ... done
[16:21:04.608] List of future strategies:
[16:21:04.608] 1. multicore:
[16:21:04.608]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.608]    - tweaked: FALSE
[16:21:04.608]    - call: plan(strategy)
[16:21:04.609] result() for MulticoreFuture ...
[16:21:04.615] plan(): nbrOfWorkers() = 2
[16:21:04.615] result() for MulticoreFuture ...
[16:21:04.615] result() for MulticoreFuture ... done
[16:21:04.616] result() for MulticoreFuture ... done
[16:21:04.616] result() for MulticoreFuture ...
[16:21:04.616] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.617] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.617] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.622] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.622] Searching for globals ... DONE
[16:21:04.622] Resolving globals: TRUE
[16:21:04.622] Resolving any globals that are futures ...
[16:21:04.622] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.622] Resolving any globals that are futures ... DONE
[16:21:04.623] Resolving futures part of globals (recursively) ...
[16:21:04.623] resolve() on list ...
[16:21:04.623]  recursive: 99
[16:21:04.623]  length: 2
[16:21:04.624]  elements: ‘a’, ‘ii’
[16:21:04.624]  length: 1 (resolved future 1)
[16:21:04.624]  length: 0 (resolved future 2)
[16:21:04.624] resolve() on list ... DONE
[16:21:04.624] - globals: [2] ‘a’, ‘ii’
[16:21:04.624] Resolving futures part of globals (recursively) ... DONE
[16:21:04.625] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:04.625] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:04.625] - globals: [2] ‘a’, ‘ii’
[16:21:04.625] 
[16:21:04.626] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.626] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.627] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.629] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.629] Searching for globals ... DONE
[16:21:04.629] Resolving globals: TRUE
[16:21:04.629] Resolving any globals that are futures ...
[16:21:04.629] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.629] Resolving any globals that are futures ... DONE
[16:21:04.630] Resolving futures part of globals (recursively) ...
[16:21:04.630] resolve() on list ...
[16:21:04.630]  recursive: 99
[16:21:04.630]  length: 2
[16:21:04.630]  elements: ‘a’, ‘ii’
[16:21:04.631]  length: 1 (resolved future 1)
[16:21:04.631]  length: 0 (resolved future 2)
[16:21:04.631] resolve() on list ... DONE
[16:21:04.631] - globals: [2] ‘a’, ‘ii’
[16:21:04.631] Resolving futures part of globals (recursively) ... DONE
[16:21:04.631] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:04.632] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:04.632] - globals: [2] ‘a’, ‘ii’
[16:21:04.632] 
[16:21:04.632] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.633] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.633] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.635] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.635] Searching for globals ... DONE
[16:21:04.635] Resolving globals: TRUE
[16:21:04.635] Resolving any globals that are futures ...
[16:21:04.635] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:04.635] Resolving any globals that are futures ... DONE
[16:21:04.636] Resolving futures part of globals (recursively) ...
[16:21:04.636] resolve() on list ...
[16:21:04.636]  recursive: 99
[16:21:04.636]  length: 2
[16:21:04.636]  elements: ‘a’, ‘ii’
[16:21:04.636]  length: 1 (resolved future 1)
[16:21:04.637]  length: 0 (resolved future 2)
[16:21:04.637] resolve() on list ... DONE
[16:21:04.637] - globals: [2] ‘a’, ‘ii’
[16:21:04.637] Resolving futures part of globals (recursively) ... DONE
[16:21:04.637] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:04.637] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:04.638] - globals: [2] ‘a’, ‘ii’
[16:21:04.638] 
[16:21:04.638] getGlobalsAndPackages() ... DONE
[16:21:04.638] run() for ‘Future’ ...
[16:21:04.638] - state: ‘created’
[16:21:04.638] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.644] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.645] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.645]   - Field: ‘label’
[16:21:04.645]   - Field: ‘local’
[16:21:04.645]   - Field: ‘owner’
[16:21:04.645]   - Field: ‘envir’
[16:21:04.645]   - Field: ‘workers’
[16:21:04.645]   - Field: ‘packages’
[16:21:04.646]   - Field: ‘gc’
[16:21:04.646]   - Field: ‘job’
[16:21:04.646]   - Field: ‘conditions’
[16:21:04.646]   - Field: ‘expr’
[16:21:04.646]   - Field: ‘uuid’
[16:21:04.646]   - Field: ‘seed’
[16:21:04.646]   - Field: ‘version’
[16:21:04.646]   - Field: ‘result’
[16:21:04.646]   - Field: ‘asynchronous’
[16:21:04.646]   - Field: ‘calls’
[16:21:04.647]   - Field: ‘globals’
[16:21:04.647]   - Field: ‘stdout’
[16:21:04.647]   - Field: ‘earlySignal’
[16:21:04.647]   - Field: ‘lazy’
[16:21:04.647]   - Field: ‘state’
[16:21:04.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.647] - Launch lazy future ...
[16:21:04.648] Packages needed by the future expression (n = 0): <none>
[16:21:04.648] Packages needed by future strategies (n = 0): <none>
[16:21:04.648] {
[16:21:04.648]     {
[16:21:04.648]         {
[16:21:04.648]             ...future.startTime <- base::Sys.time()
[16:21:04.648]             {
[16:21:04.648]                 {
[16:21:04.648]                   {
[16:21:04.648]                     {
[16:21:04.648]                       base::local({
[16:21:04.648]                         has_future <- base::requireNamespace("future", 
[16:21:04.648]                           quietly = TRUE)
[16:21:04.648]                         if (has_future) {
[16:21:04.648]                           ns <- base::getNamespace("future")
[16:21:04.648]                           version <- ns[[".package"]][["version"]]
[16:21:04.648]                           if (is.null(version)) 
[16:21:04.648]                             version <- utils::packageVersion("future")
[16:21:04.648]                         }
[16:21:04.648]                         else {
[16:21:04.648]                           version <- NULL
[16:21:04.648]                         }
[16:21:04.648]                         if (!has_future || version < "1.8.0") {
[16:21:04.648]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.648]                             "", base::R.version$version.string), 
[16:21:04.648]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.648]                               "release", "version")], collapse = " "), 
[16:21:04.648]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.648]                             info)
[16:21:04.648]                           info <- base::paste(info, collapse = "; ")
[16:21:04.648]                           if (!has_future) {
[16:21:04.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.648]                               info)
[16:21:04.648]                           }
[16:21:04.648]                           else {
[16:21:04.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.648]                               info, version)
[16:21:04.648]                           }
[16:21:04.648]                           base::stop(msg)
[16:21:04.648]                         }
[16:21:04.648]                       })
[16:21:04.648]                     }
[16:21:04.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.648]                     base::options(mc.cores = 1L)
[16:21:04.648]                   }
[16:21:04.648]                   ...future.strategy.old <- future::plan("list")
[16:21:04.648]                   options(future.plan = NULL)
[16:21:04.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.648]                 }
[16:21:04.648]                 ...future.workdir <- getwd()
[16:21:04.648]             }
[16:21:04.648]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.648]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.648]         }
[16:21:04.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.648]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.648]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.648]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.648]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.648]             base::names(...future.oldOptions))
[16:21:04.648]     }
[16:21:04.648]     if (FALSE) {
[16:21:04.648]     }
[16:21:04.648]     else {
[16:21:04.648]         if (TRUE) {
[16:21:04.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.648]                 open = "w")
[16:21:04.648]         }
[16:21:04.648]         else {
[16:21:04.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.648]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.648]         }
[16:21:04.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.648]             base::sink(type = "output", split = FALSE)
[16:21:04.648]             base::close(...future.stdout)
[16:21:04.648]         }, add = TRUE)
[16:21:04.648]     }
[16:21:04.648]     ...future.frame <- base::sys.nframe()
[16:21:04.648]     ...future.conditions <- base::list()
[16:21:04.648]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.648]     if (FALSE) {
[16:21:04.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.648]     }
[16:21:04.648]     ...future.result <- base::tryCatch({
[16:21:04.648]         base::withCallingHandlers({
[16:21:04.648]             ...future.value <- base::withVisible(base::local({
[16:21:04.648]                 withCallingHandlers({
[16:21:04.648]                   {
[16:21:04.648]                     b <- a * ii
[16:21:04.648]                     a <- 0
[16:21:04.648]                     b
[16:21:04.648]                   }
[16:21:04.648]                 }, immediateCondition = function(cond) {
[16:21:04.648]                   save_rds <- function (object, pathname, ...) 
[16:21:04.648]                   {
[16:21:04.648]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.648]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.648]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.648]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.648]                         fi_tmp[["mtime"]])
[16:21:04.648]                     }
[16:21:04.648]                     tryCatch({
[16:21:04.648]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.648]                     }, error = function(ex) {
[16:21:04.648]                       msg <- conditionMessage(ex)
[16:21:04.648]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.648]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.648]                         fi_tmp[["mtime"]], msg)
[16:21:04.648]                       ex$message <- msg
[16:21:04.648]                       stop(ex)
[16:21:04.648]                     })
[16:21:04.648]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.648]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.648]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.648]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.648]                       fi <- file.info(pathname)
[16:21:04.648]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.648]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.648]                         fi[["size"]], fi[["mtime"]])
[16:21:04.648]                       stop(msg)
[16:21:04.648]                     }
[16:21:04.648]                     invisible(pathname)
[16:21:04.648]                   }
[16:21:04.648]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.648]                     rootPath = tempdir()) 
[16:21:04.648]                   {
[16:21:04.648]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.648]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.648]                       tmpdir = path, fileext = ".rds")
[16:21:04.648]                     save_rds(obj, file)
[16:21:04.648]                   }
[16:21:04.648]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.648]                   {
[16:21:04.648]                     inherits <- base::inherits
[16:21:04.648]                     invokeRestart <- base::invokeRestart
[16:21:04.648]                     is.null <- base::is.null
[16:21:04.648]                     muffled <- FALSE
[16:21:04.648]                     if (inherits(cond, "message")) {
[16:21:04.648]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.648]                       if (muffled) 
[16:21:04.648]                         invokeRestart("muffleMessage")
[16:21:04.648]                     }
[16:21:04.648]                     else if (inherits(cond, "warning")) {
[16:21:04.648]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.648]                       if (muffled) 
[16:21:04.648]                         invokeRestart("muffleWarning")
[16:21:04.648]                     }
[16:21:04.648]                     else if (inherits(cond, "condition")) {
[16:21:04.648]                       if (!is.null(pattern)) {
[16:21:04.648]                         computeRestarts <- base::computeRestarts
[16:21:04.648]                         grepl <- base::grepl
[16:21:04.648]                         restarts <- computeRestarts(cond)
[16:21:04.648]                         for (restart in restarts) {
[16:21:04.648]                           name <- restart$name
[16:21:04.648]                           if (is.null(name)) 
[16:21:04.648]                             next
[16:21:04.648]                           if (!grepl(pattern, name)) 
[16:21:04.648]                             next
[16:21:04.648]                           invokeRestart(restart)
[16:21:04.648]                           muffled <- TRUE
[16:21:04.648]                           break
[16:21:04.648]                         }
[16:21:04.648]                       }
[16:21:04.648]                     }
[16:21:04.648]                     invisible(muffled)
[16:21:04.648]                   }
[16:21:04.648]                   muffleCondition(cond)
[16:21:04.648]                 })
[16:21:04.648]             }))
[16:21:04.648]             future::FutureResult(value = ...future.value$value, 
[16:21:04.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.648]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.648]                     ...future.globalenv.names))
[16:21:04.648]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.648]         }, condition = base::local({
[16:21:04.648]             c <- base::c
[16:21:04.648]             inherits <- base::inherits
[16:21:04.648]             invokeRestart <- base::invokeRestart
[16:21:04.648]             length <- base::length
[16:21:04.648]             list <- base::list
[16:21:04.648]             seq.int <- base::seq.int
[16:21:04.648]             signalCondition <- base::signalCondition
[16:21:04.648]             sys.calls <- base::sys.calls
[16:21:04.648]             `[[` <- base::`[[`
[16:21:04.648]             `+` <- base::`+`
[16:21:04.648]             `<<-` <- base::`<<-`
[16:21:04.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.648]                   3L)]
[16:21:04.648]             }
[16:21:04.648]             function(cond) {
[16:21:04.648]                 is_error <- inherits(cond, "error")
[16:21:04.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.648]                   NULL)
[16:21:04.648]                 if (is_error) {
[16:21:04.648]                   sessionInformation <- function() {
[16:21:04.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.648]                       search = base::search(), system = base::Sys.info())
[16:21:04.648]                   }
[16:21:04.648]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.648]                     cond$call), session = sessionInformation(), 
[16:21:04.648]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.648]                   signalCondition(cond)
[16:21:04.648]                 }
[16:21:04.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.648]                 "immediateCondition"))) {
[16:21:04.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.648]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.648]                   if (TRUE && !signal) {
[16:21:04.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.648]                     {
[16:21:04.648]                       inherits <- base::inherits
[16:21:04.648]                       invokeRestart <- base::invokeRestart
[16:21:04.648]                       is.null <- base::is.null
[16:21:04.648]                       muffled <- FALSE
[16:21:04.648]                       if (inherits(cond, "message")) {
[16:21:04.648]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.648]                         if (muffled) 
[16:21:04.648]                           invokeRestart("muffleMessage")
[16:21:04.648]                       }
[16:21:04.648]                       else if (inherits(cond, "warning")) {
[16:21:04.648]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.648]                         if (muffled) 
[16:21:04.648]                           invokeRestart("muffleWarning")
[16:21:04.648]                       }
[16:21:04.648]                       else if (inherits(cond, "condition")) {
[16:21:04.648]                         if (!is.null(pattern)) {
[16:21:04.648]                           computeRestarts <- base::computeRestarts
[16:21:04.648]                           grepl <- base::grepl
[16:21:04.648]                           restarts <- computeRestarts(cond)
[16:21:04.648]                           for (restart in restarts) {
[16:21:04.648]                             name <- restart$name
[16:21:04.648]                             if (is.null(name)) 
[16:21:04.648]                               next
[16:21:04.648]                             if (!grepl(pattern, name)) 
[16:21:04.648]                               next
[16:21:04.648]                             invokeRestart(restart)
[16:21:04.648]                             muffled <- TRUE
[16:21:04.648]                             break
[16:21:04.648]                           }
[16:21:04.648]                         }
[16:21:04.648]                       }
[16:21:04.648]                       invisible(muffled)
[16:21:04.648]                     }
[16:21:04.648]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.648]                   }
[16:21:04.648]                 }
[16:21:04.648]                 else {
[16:21:04.648]                   if (TRUE) {
[16:21:04.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.648]                     {
[16:21:04.648]                       inherits <- base::inherits
[16:21:04.648]                       invokeRestart <- base::invokeRestart
[16:21:04.648]                       is.null <- base::is.null
[16:21:04.648]                       muffled <- FALSE
[16:21:04.648]                       if (inherits(cond, "message")) {
[16:21:04.648]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.648]                         if (muffled) 
[16:21:04.648]                           invokeRestart("muffleMessage")
[16:21:04.648]                       }
[16:21:04.648]                       else if (inherits(cond, "warning")) {
[16:21:04.648]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.648]                         if (muffled) 
[16:21:04.648]                           invokeRestart("muffleWarning")
[16:21:04.648]                       }
[16:21:04.648]                       else if (inherits(cond, "condition")) {
[16:21:04.648]                         if (!is.null(pattern)) {
[16:21:04.648]                           computeRestarts <- base::computeRestarts
[16:21:04.648]                           grepl <- base::grepl
[16:21:04.648]                           restarts <- computeRestarts(cond)
[16:21:04.648]                           for (restart in restarts) {
[16:21:04.648]                             name <- restart$name
[16:21:04.648]                             if (is.null(name)) 
[16:21:04.648]                               next
[16:21:04.648]                             if (!grepl(pattern, name)) 
[16:21:04.648]                               next
[16:21:04.648]                             invokeRestart(restart)
[16:21:04.648]                             muffled <- TRUE
[16:21:04.648]                             break
[16:21:04.648]                           }
[16:21:04.648]                         }
[16:21:04.648]                       }
[16:21:04.648]                       invisible(muffled)
[16:21:04.648]                     }
[16:21:04.648]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.648]                   }
[16:21:04.648]                 }
[16:21:04.648]             }
[16:21:04.648]         }))
[16:21:04.648]     }, error = function(ex) {
[16:21:04.648]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.648]                 ...future.rng), started = ...future.startTime, 
[16:21:04.648]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.648]             version = "1.8"), class = "FutureResult")
[16:21:04.648]     }, finally = {
[16:21:04.648]         if (!identical(...future.workdir, getwd())) 
[16:21:04.648]             setwd(...future.workdir)
[16:21:04.648]         {
[16:21:04.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.648]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.648]             }
[16:21:04.648]             base::options(...future.oldOptions)
[16:21:04.648]             if (.Platform$OS.type == "windows") {
[16:21:04.648]                 old_names <- names(...future.oldEnvVars)
[16:21:04.648]                 envs <- base::Sys.getenv()
[16:21:04.648]                 names <- names(envs)
[16:21:04.648]                 common <- intersect(names, old_names)
[16:21:04.648]                 added <- setdiff(names, old_names)
[16:21:04.648]                 removed <- setdiff(old_names, names)
[16:21:04.648]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.648]                   envs[common]]
[16:21:04.648]                 NAMES <- toupper(changed)
[16:21:04.648]                 args <- list()
[16:21:04.648]                 for (kk in seq_along(NAMES)) {
[16:21:04.648]                   name <- changed[[kk]]
[16:21:04.648]                   NAME <- NAMES[[kk]]
[16:21:04.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.648]                     next
[16:21:04.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.648]                 }
[16:21:04.648]                 NAMES <- toupper(added)
[16:21:04.648]                 for (kk in seq_along(NAMES)) {
[16:21:04.648]                   name <- added[[kk]]
[16:21:04.648]                   NAME <- NAMES[[kk]]
[16:21:04.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.648]                     next
[16:21:04.648]                   args[[name]] <- ""
[16:21:04.648]                 }
[16:21:04.648]                 NAMES <- toupper(removed)
[16:21:04.648]                 for (kk in seq_along(NAMES)) {
[16:21:04.648]                   name <- removed[[kk]]
[16:21:04.648]                   NAME <- NAMES[[kk]]
[16:21:04.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.648]                     next
[16:21:04.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.648]                 }
[16:21:04.648]                 if (length(args) > 0) 
[16:21:04.648]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.648]             }
[16:21:04.648]             else {
[16:21:04.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.648]             }
[16:21:04.648]             {
[16:21:04.648]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.648]                   0L) {
[16:21:04.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.648]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.648]                   base::options(opts)
[16:21:04.648]                 }
[16:21:04.648]                 {
[16:21:04.648]                   {
[16:21:04.648]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.648]                     NULL
[16:21:04.648]                   }
[16:21:04.648]                   options(future.plan = NULL)
[16:21:04.648]                   if (is.na(NA_character_)) 
[16:21:04.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.648]                     .init = FALSE)
[16:21:04.648]                 }
[16:21:04.648]             }
[16:21:04.648]         }
[16:21:04.648]     })
[16:21:04.648]     if (TRUE) {
[16:21:04.648]         base::sink(type = "output", split = FALSE)
[16:21:04.648]         if (TRUE) {
[16:21:04.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.648]         }
[16:21:04.648]         else {
[16:21:04.648]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.648]         }
[16:21:04.648]         base::close(...future.stdout)
[16:21:04.648]         ...future.stdout <- NULL
[16:21:04.648]     }
[16:21:04.648]     ...future.result$conditions <- ...future.conditions
[16:21:04.648]     ...future.result$finished <- base::Sys.time()
[16:21:04.648]     ...future.result
[16:21:04.648] }
[16:21:04.651] assign_globals() ...
[16:21:04.651] List of 2
[16:21:04.651]  $ a : num 1
[16:21:04.651]  $ ii: int 1
[16:21:04.651]  - attr(*, "where")=List of 2
[16:21:04.651]   ..$ a :<environment: R_EmptyEnv> 
[16:21:04.651]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:04.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.651]  - attr(*, "resolved")= logi TRUE
[16:21:04.651]  - attr(*, "total_size")= num 112
[16:21:04.651]  - attr(*, "already-done")= logi TRUE
[16:21:04.655] - copied ‘a’ to environment
[16:21:04.655] - copied ‘ii’ to environment
[16:21:04.655] assign_globals() ... done
[16:21:04.655] requestCore(): workers = 2
[16:21:04.657] MulticoreFuture started
[16:21:04.658] - Launch lazy future ... done
[16:21:04.658] run() for ‘MulticoreFuture’ ... done
[16:21:04.658] result() for MulticoreFuture ...
[16:21:04.658] plan(): Setting new future strategy stack:
[16:21:04.659] List of future strategies:
[16:21:04.659] 1. sequential:
[16:21:04.659]    - args: function (..., envir = parent.frame())
[16:21:04.659]    - tweaked: FALSE
[16:21:04.659]    - call: NULL
[16:21:04.660] plan(): nbrOfWorkers() = 1
[16:21:04.663] plan(): Setting new future strategy stack:
[16:21:04.663] List of future strategies:
[16:21:04.663] 1. multicore:
[16:21:04.663]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.663]    - tweaked: FALSE
[16:21:04.663]    - call: plan(strategy)
[16:21:04.669] plan(): nbrOfWorkers() = 2
[16:21:04.670] result() for MulticoreFuture ...
[16:21:04.670] result() for MulticoreFuture ... done
[16:21:04.671] result() for MulticoreFuture ... done
[16:21:04.671] result() for MulticoreFuture ...
[16:21:04.671] result() for MulticoreFuture ... done
[16:21:04.671] run() for ‘Future’ ...
[16:21:04.672] - state: ‘created’
[16:21:04.672] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.676] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.677]   - Field: ‘label’
[16:21:04.677]   - Field: ‘local’
[16:21:04.677]   - Field: ‘owner’
[16:21:04.677]   - Field: ‘envir’
[16:21:04.677]   - Field: ‘workers’
[16:21:04.678]   - Field: ‘packages’
[16:21:04.678]   - Field: ‘gc’
[16:21:04.678]   - Field: ‘job’
[16:21:04.678]   - Field: ‘conditions’
[16:21:04.678]   - Field: ‘expr’
[16:21:04.678]   - Field: ‘uuid’
[16:21:04.678]   - Field: ‘seed’
[16:21:04.678]   - Field: ‘version’
[16:21:04.678]   - Field: ‘result’
[16:21:04.679]   - Field: ‘asynchronous’
[16:21:04.679]   - Field: ‘calls’
[16:21:04.679]   - Field: ‘globals’
[16:21:04.679]   - Field: ‘stdout’
[16:21:04.679]   - Field: ‘earlySignal’
[16:21:04.679]   - Field: ‘lazy’
[16:21:04.679]   - Field: ‘state’
[16:21:04.679] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.680] - Launch lazy future ...
[16:21:04.680] Packages needed by the future expression (n = 0): <none>
[16:21:04.680] Packages needed by future strategies (n = 0): <none>
[16:21:04.681] {
[16:21:04.681]     {
[16:21:04.681]         {
[16:21:04.681]             ...future.startTime <- base::Sys.time()
[16:21:04.681]             {
[16:21:04.681]                 {
[16:21:04.681]                   {
[16:21:04.681]                     {
[16:21:04.681]                       base::local({
[16:21:04.681]                         has_future <- base::requireNamespace("future", 
[16:21:04.681]                           quietly = TRUE)
[16:21:04.681]                         if (has_future) {
[16:21:04.681]                           ns <- base::getNamespace("future")
[16:21:04.681]                           version <- ns[[".package"]][["version"]]
[16:21:04.681]                           if (is.null(version)) 
[16:21:04.681]                             version <- utils::packageVersion("future")
[16:21:04.681]                         }
[16:21:04.681]                         else {
[16:21:04.681]                           version <- NULL
[16:21:04.681]                         }
[16:21:04.681]                         if (!has_future || version < "1.8.0") {
[16:21:04.681]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.681]                             "", base::R.version$version.string), 
[16:21:04.681]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.681]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.681]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.681]                               "release", "version")], collapse = " "), 
[16:21:04.681]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.681]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.681]                             info)
[16:21:04.681]                           info <- base::paste(info, collapse = "; ")
[16:21:04.681]                           if (!has_future) {
[16:21:04.681]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.681]                               info)
[16:21:04.681]                           }
[16:21:04.681]                           else {
[16:21:04.681]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.681]                               info, version)
[16:21:04.681]                           }
[16:21:04.681]                           base::stop(msg)
[16:21:04.681]                         }
[16:21:04.681]                       })
[16:21:04.681]                     }
[16:21:04.681]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.681]                     base::options(mc.cores = 1L)
[16:21:04.681]                   }
[16:21:04.681]                   ...future.strategy.old <- future::plan("list")
[16:21:04.681]                   options(future.plan = NULL)
[16:21:04.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.681]                 }
[16:21:04.681]                 ...future.workdir <- getwd()
[16:21:04.681]             }
[16:21:04.681]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.681]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.681]         }
[16:21:04.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.681]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.681]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.681]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.681]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.681]             base::names(...future.oldOptions))
[16:21:04.681]     }
[16:21:04.681]     if (FALSE) {
[16:21:04.681]     }
[16:21:04.681]     else {
[16:21:04.681]         if (TRUE) {
[16:21:04.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.681]                 open = "w")
[16:21:04.681]         }
[16:21:04.681]         else {
[16:21:04.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.681]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.681]         }
[16:21:04.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.681]             base::sink(type = "output", split = FALSE)
[16:21:04.681]             base::close(...future.stdout)
[16:21:04.681]         }, add = TRUE)
[16:21:04.681]     }
[16:21:04.681]     ...future.frame <- base::sys.nframe()
[16:21:04.681]     ...future.conditions <- base::list()
[16:21:04.681]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.681]     if (FALSE) {
[16:21:04.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.681]     }
[16:21:04.681]     ...future.result <- base::tryCatch({
[16:21:04.681]         base::withCallingHandlers({
[16:21:04.681]             ...future.value <- base::withVisible(base::local({
[16:21:04.681]                 withCallingHandlers({
[16:21:04.681]                   {
[16:21:04.681]                     b <- a * ii
[16:21:04.681]                     a <- 0
[16:21:04.681]                     b
[16:21:04.681]                   }
[16:21:04.681]                 }, immediateCondition = function(cond) {
[16:21:04.681]                   save_rds <- function (object, pathname, ...) 
[16:21:04.681]                   {
[16:21:04.681]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.681]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.681]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.681]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.681]                         fi_tmp[["mtime"]])
[16:21:04.681]                     }
[16:21:04.681]                     tryCatch({
[16:21:04.681]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.681]                     }, error = function(ex) {
[16:21:04.681]                       msg <- conditionMessage(ex)
[16:21:04.681]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.681]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.681]                         fi_tmp[["mtime"]], msg)
[16:21:04.681]                       ex$message <- msg
[16:21:04.681]                       stop(ex)
[16:21:04.681]                     })
[16:21:04.681]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.681]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.681]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.681]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.681]                       fi <- file.info(pathname)
[16:21:04.681]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.681]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.681]                         fi[["size"]], fi[["mtime"]])
[16:21:04.681]                       stop(msg)
[16:21:04.681]                     }
[16:21:04.681]                     invisible(pathname)
[16:21:04.681]                   }
[16:21:04.681]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.681]                     rootPath = tempdir()) 
[16:21:04.681]                   {
[16:21:04.681]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.681]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.681]                       tmpdir = path, fileext = ".rds")
[16:21:04.681]                     save_rds(obj, file)
[16:21:04.681]                   }
[16:21:04.681]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.681]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.681]                   {
[16:21:04.681]                     inherits <- base::inherits
[16:21:04.681]                     invokeRestart <- base::invokeRestart
[16:21:04.681]                     is.null <- base::is.null
[16:21:04.681]                     muffled <- FALSE
[16:21:04.681]                     if (inherits(cond, "message")) {
[16:21:04.681]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.681]                       if (muffled) 
[16:21:04.681]                         invokeRestart("muffleMessage")
[16:21:04.681]                     }
[16:21:04.681]                     else if (inherits(cond, "warning")) {
[16:21:04.681]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.681]                       if (muffled) 
[16:21:04.681]                         invokeRestart("muffleWarning")
[16:21:04.681]                     }
[16:21:04.681]                     else if (inherits(cond, "condition")) {
[16:21:04.681]                       if (!is.null(pattern)) {
[16:21:04.681]                         computeRestarts <- base::computeRestarts
[16:21:04.681]                         grepl <- base::grepl
[16:21:04.681]                         restarts <- computeRestarts(cond)
[16:21:04.681]                         for (restart in restarts) {
[16:21:04.681]                           name <- restart$name
[16:21:04.681]                           if (is.null(name)) 
[16:21:04.681]                             next
[16:21:04.681]                           if (!grepl(pattern, name)) 
[16:21:04.681]                             next
[16:21:04.681]                           invokeRestart(restart)
[16:21:04.681]                           muffled <- TRUE
[16:21:04.681]                           break
[16:21:04.681]                         }
[16:21:04.681]                       }
[16:21:04.681]                     }
[16:21:04.681]                     invisible(muffled)
[16:21:04.681]                   }
[16:21:04.681]                   muffleCondition(cond)
[16:21:04.681]                 })
[16:21:04.681]             }))
[16:21:04.681]             future::FutureResult(value = ...future.value$value, 
[16:21:04.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.681]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.681]                     ...future.globalenv.names))
[16:21:04.681]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.681]         }, condition = base::local({
[16:21:04.681]             c <- base::c
[16:21:04.681]             inherits <- base::inherits
[16:21:04.681]             invokeRestart <- base::invokeRestart
[16:21:04.681]             length <- base::length
[16:21:04.681]             list <- base::list
[16:21:04.681]             seq.int <- base::seq.int
[16:21:04.681]             signalCondition <- base::signalCondition
[16:21:04.681]             sys.calls <- base::sys.calls
[16:21:04.681]             `[[` <- base::`[[`
[16:21:04.681]             `+` <- base::`+`
[16:21:04.681]             `<<-` <- base::`<<-`
[16:21:04.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.681]                   3L)]
[16:21:04.681]             }
[16:21:04.681]             function(cond) {
[16:21:04.681]                 is_error <- inherits(cond, "error")
[16:21:04.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.681]                   NULL)
[16:21:04.681]                 if (is_error) {
[16:21:04.681]                   sessionInformation <- function() {
[16:21:04.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.681]                       search = base::search(), system = base::Sys.info())
[16:21:04.681]                   }
[16:21:04.681]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.681]                     cond$call), session = sessionInformation(), 
[16:21:04.681]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.681]                   signalCondition(cond)
[16:21:04.681]                 }
[16:21:04.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.681]                 "immediateCondition"))) {
[16:21:04.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.681]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.681]                   if (TRUE && !signal) {
[16:21:04.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.681]                     {
[16:21:04.681]                       inherits <- base::inherits
[16:21:04.681]                       invokeRestart <- base::invokeRestart
[16:21:04.681]                       is.null <- base::is.null
[16:21:04.681]                       muffled <- FALSE
[16:21:04.681]                       if (inherits(cond, "message")) {
[16:21:04.681]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.681]                         if (muffled) 
[16:21:04.681]                           invokeRestart("muffleMessage")
[16:21:04.681]                       }
[16:21:04.681]                       else if (inherits(cond, "warning")) {
[16:21:04.681]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.681]                         if (muffled) 
[16:21:04.681]                           invokeRestart("muffleWarning")
[16:21:04.681]                       }
[16:21:04.681]                       else if (inherits(cond, "condition")) {
[16:21:04.681]                         if (!is.null(pattern)) {
[16:21:04.681]                           computeRestarts <- base::computeRestarts
[16:21:04.681]                           grepl <- base::grepl
[16:21:04.681]                           restarts <- computeRestarts(cond)
[16:21:04.681]                           for (restart in restarts) {
[16:21:04.681]                             name <- restart$name
[16:21:04.681]                             if (is.null(name)) 
[16:21:04.681]                               next
[16:21:04.681]                             if (!grepl(pattern, name)) 
[16:21:04.681]                               next
[16:21:04.681]                             invokeRestart(restart)
[16:21:04.681]                             muffled <- TRUE
[16:21:04.681]                             break
[16:21:04.681]                           }
[16:21:04.681]                         }
[16:21:04.681]                       }
[16:21:04.681]                       invisible(muffled)
[16:21:04.681]                     }
[16:21:04.681]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.681]                   }
[16:21:04.681]                 }
[16:21:04.681]                 else {
[16:21:04.681]                   if (TRUE) {
[16:21:04.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.681]                     {
[16:21:04.681]                       inherits <- base::inherits
[16:21:04.681]                       invokeRestart <- base::invokeRestart
[16:21:04.681]                       is.null <- base::is.null
[16:21:04.681]                       muffled <- FALSE
[16:21:04.681]                       if (inherits(cond, "message")) {
[16:21:04.681]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.681]                         if (muffled) 
[16:21:04.681]                           invokeRestart("muffleMessage")
[16:21:04.681]                       }
[16:21:04.681]                       else if (inherits(cond, "warning")) {
[16:21:04.681]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.681]                         if (muffled) 
[16:21:04.681]                           invokeRestart("muffleWarning")
[16:21:04.681]                       }
[16:21:04.681]                       else if (inherits(cond, "condition")) {
[16:21:04.681]                         if (!is.null(pattern)) {
[16:21:04.681]                           computeRestarts <- base::computeRestarts
[16:21:04.681]                           grepl <- base::grepl
[16:21:04.681]                           restarts <- computeRestarts(cond)
[16:21:04.681]                           for (restart in restarts) {
[16:21:04.681]                             name <- restart$name
[16:21:04.681]                             if (is.null(name)) 
[16:21:04.681]                               next
[16:21:04.681]                             if (!grepl(pattern, name)) 
[16:21:04.681]                               next
[16:21:04.681]                             invokeRestart(restart)
[16:21:04.681]                             muffled <- TRUE
[16:21:04.681]                             break
[16:21:04.681]                           }
[16:21:04.681]                         }
[16:21:04.681]                       }
[16:21:04.681]                       invisible(muffled)
[16:21:04.681]                     }
[16:21:04.681]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.681]                   }
[16:21:04.681]                 }
[16:21:04.681]             }
[16:21:04.681]         }))
[16:21:04.681]     }, error = function(ex) {
[16:21:04.681]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.681]                 ...future.rng), started = ...future.startTime, 
[16:21:04.681]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.681]             version = "1.8"), class = "FutureResult")
[16:21:04.681]     }, finally = {
[16:21:04.681]         if (!identical(...future.workdir, getwd())) 
[16:21:04.681]             setwd(...future.workdir)
[16:21:04.681]         {
[16:21:04.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.681]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.681]             }
[16:21:04.681]             base::options(...future.oldOptions)
[16:21:04.681]             if (.Platform$OS.type == "windows") {
[16:21:04.681]                 old_names <- names(...future.oldEnvVars)
[16:21:04.681]                 envs <- base::Sys.getenv()
[16:21:04.681]                 names <- names(envs)
[16:21:04.681]                 common <- intersect(names, old_names)
[16:21:04.681]                 added <- setdiff(names, old_names)
[16:21:04.681]                 removed <- setdiff(old_names, names)
[16:21:04.681]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.681]                   envs[common]]
[16:21:04.681]                 NAMES <- toupper(changed)
[16:21:04.681]                 args <- list()
[16:21:04.681]                 for (kk in seq_along(NAMES)) {
[16:21:04.681]                   name <- changed[[kk]]
[16:21:04.681]                   NAME <- NAMES[[kk]]
[16:21:04.681]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.681]                     next
[16:21:04.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.681]                 }
[16:21:04.681]                 NAMES <- toupper(added)
[16:21:04.681]                 for (kk in seq_along(NAMES)) {
[16:21:04.681]                   name <- added[[kk]]
[16:21:04.681]                   NAME <- NAMES[[kk]]
[16:21:04.681]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.681]                     next
[16:21:04.681]                   args[[name]] <- ""
[16:21:04.681]                 }
[16:21:04.681]                 NAMES <- toupper(removed)
[16:21:04.681]                 for (kk in seq_along(NAMES)) {
[16:21:04.681]                   name <- removed[[kk]]
[16:21:04.681]                   NAME <- NAMES[[kk]]
[16:21:04.681]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.681]                     next
[16:21:04.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.681]                 }
[16:21:04.681]                 if (length(args) > 0) 
[16:21:04.681]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.681]             }
[16:21:04.681]             else {
[16:21:04.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.681]             }
[16:21:04.681]             {
[16:21:04.681]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.681]                   0L) {
[16:21:04.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.681]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.681]                   base::options(opts)
[16:21:04.681]                 }
[16:21:04.681]                 {
[16:21:04.681]                   {
[16:21:04.681]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.681]                     NULL
[16:21:04.681]                   }
[16:21:04.681]                   options(future.plan = NULL)
[16:21:04.681]                   if (is.na(NA_character_)) 
[16:21:04.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.681]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.681]                     .init = FALSE)
[16:21:04.681]                 }
[16:21:04.681]             }
[16:21:04.681]         }
[16:21:04.681]     })
[16:21:04.681]     if (TRUE) {
[16:21:04.681]         base::sink(type = "output", split = FALSE)
[16:21:04.681]         if (TRUE) {
[16:21:04.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.681]         }
[16:21:04.681]         else {
[16:21:04.681]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.681]         }
[16:21:04.681]         base::close(...future.stdout)
[16:21:04.681]         ...future.stdout <- NULL
[16:21:04.681]     }
[16:21:04.681]     ...future.result$conditions <- ...future.conditions
[16:21:04.681]     ...future.result$finished <- base::Sys.time()
[16:21:04.681]     ...future.result
[16:21:04.681] }
[16:21:04.683] assign_globals() ...
[16:21:04.683] List of 2
[16:21:04.683]  $ a : num 1
[16:21:04.683]  $ ii: int 2
[16:21:04.683]  - attr(*, "where")=List of 2
[16:21:04.683]   ..$ a :<environment: R_EmptyEnv> 
[16:21:04.683]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:04.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.683]  - attr(*, "resolved")= logi TRUE
[16:21:04.683]  - attr(*, "total_size")= num 112
[16:21:04.683]  - attr(*, "already-done")= logi TRUE
[16:21:04.687] - copied ‘a’ to environment
[16:21:04.688] - copied ‘ii’ to environment
[16:21:04.688] assign_globals() ... done
[16:21:04.688] requestCore(): workers = 2
[16:21:04.690] MulticoreFuture started
[16:21:04.690] - Launch lazy future ... done
[16:21:04.690] run() for ‘MulticoreFuture’ ... done
[16:21:04.691] result() for MulticoreFuture ...
[16:21:04.691] plan(): Setting new future strategy stack:
[16:21:04.691] List of future strategies:
[16:21:04.691] 1. sequential:
[16:21:04.691]    - args: function (..., envir = parent.frame())
[16:21:04.691]    - tweaked: FALSE
[16:21:04.691]    - call: NULL
[16:21:04.692] plan(): nbrOfWorkers() = 1
[16:21:04.694] plan(): Setting new future strategy stack:
[16:21:04.694] List of future strategies:
[16:21:04.694] 1. multicore:
[16:21:04.694]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.694]    - tweaked: FALSE
[16:21:04.694]    - call: plan(strategy)
[16:21:04.700] plan(): nbrOfWorkers() = 2
[16:21:04.701] result() for MulticoreFuture ...
[16:21:04.701] result() for MulticoreFuture ... done
[16:21:04.701] result() for MulticoreFuture ... done
[16:21:04.701] result() for MulticoreFuture ...
[16:21:04.701] result() for MulticoreFuture ... done
[16:21:04.702] run() for ‘Future’ ...
[16:21:04.702] - state: ‘created’
[16:21:04.702] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.706] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.707]   - Field: ‘label’
[16:21:04.707]   - Field: ‘local’
[16:21:04.707]   - Field: ‘owner’
[16:21:04.707]   - Field: ‘envir’
[16:21:04.707]   - Field: ‘workers’
[16:21:04.707]   - Field: ‘packages’
[16:21:04.708]   - Field: ‘gc’
[16:21:04.708]   - Field: ‘job’
[16:21:04.708]   - Field: ‘conditions’
[16:21:04.708]   - Field: ‘expr’
[16:21:04.708]   - Field: ‘uuid’
[16:21:04.708]   - Field: ‘seed’
[16:21:04.708]   - Field: ‘version’
[16:21:04.709]   - Field: ‘result’
[16:21:04.709]   - Field: ‘asynchronous’
[16:21:04.709]   - Field: ‘calls’
[16:21:04.709]   - Field: ‘globals’
[16:21:04.712]   - Field: ‘stdout’
[16:21:04.712]   - Field: ‘earlySignal’
[16:21:04.712]   - Field: ‘lazy’
[16:21:04.713]   - Field: ‘state’
[16:21:04.713] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.713] - Launch lazy future ...
[16:21:04.713] Packages needed by the future expression (n = 0): <none>
[16:21:04.713] Packages needed by future strategies (n = 0): <none>
[16:21:04.714] {
[16:21:04.714]     {
[16:21:04.714]         {
[16:21:04.714]             ...future.startTime <- base::Sys.time()
[16:21:04.714]             {
[16:21:04.714]                 {
[16:21:04.714]                   {
[16:21:04.714]                     {
[16:21:04.714]                       base::local({
[16:21:04.714]                         has_future <- base::requireNamespace("future", 
[16:21:04.714]                           quietly = TRUE)
[16:21:04.714]                         if (has_future) {
[16:21:04.714]                           ns <- base::getNamespace("future")
[16:21:04.714]                           version <- ns[[".package"]][["version"]]
[16:21:04.714]                           if (is.null(version)) 
[16:21:04.714]                             version <- utils::packageVersion("future")
[16:21:04.714]                         }
[16:21:04.714]                         else {
[16:21:04.714]                           version <- NULL
[16:21:04.714]                         }
[16:21:04.714]                         if (!has_future || version < "1.8.0") {
[16:21:04.714]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.714]                             "", base::R.version$version.string), 
[16:21:04.714]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.714]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.714]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.714]                               "release", "version")], collapse = " "), 
[16:21:04.714]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.714]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.714]                             info)
[16:21:04.714]                           info <- base::paste(info, collapse = "; ")
[16:21:04.714]                           if (!has_future) {
[16:21:04.714]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.714]                               info)
[16:21:04.714]                           }
[16:21:04.714]                           else {
[16:21:04.714]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.714]                               info, version)
[16:21:04.714]                           }
[16:21:04.714]                           base::stop(msg)
[16:21:04.714]                         }
[16:21:04.714]                       })
[16:21:04.714]                     }
[16:21:04.714]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.714]                     base::options(mc.cores = 1L)
[16:21:04.714]                   }
[16:21:04.714]                   ...future.strategy.old <- future::plan("list")
[16:21:04.714]                   options(future.plan = NULL)
[16:21:04.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.714]                 }
[16:21:04.714]                 ...future.workdir <- getwd()
[16:21:04.714]             }
[16:21:04.714]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.714]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.714]         }
[16:21:04.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.714]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.714]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.714]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.714]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.714]             base::names(...future.oldOptions))
[16:21:04.714]     }
[16:21:04.714]     if (FALSE) {
[16:21:04.714]     }
[16:21:04.714]     else {
[16:21:04.714]         if (TRUE) {
[16:21:04.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.714]                 open = "w")
[16:21:04.714]         }
[16:21:04.714]         else {
[16:21:04.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.714]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.714]         }
[16:21:04.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.714]             base::sink(type = "output", split = FALSE)
[16:21:04.714]             base::close(...future.stdout)
[16:21:04.714]         }, add = TRUE)
[16:21:04.714]     }
[16:21:04.714]     ...future.frame <- base::sys.nframe()
[16:21:04.714]     ...future.conditions <- base::list()
[16:21:04.714]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.714]     if (FALSE) {
[16:21:04.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.714]     }
[16:21:04.714]     ...future.result <- base::tryCatch({
[16:21:04.714]         base::withCallingHandlers({
[16:21:04.714]             ...future.value <- base::withVisible(base::local({
[16:21:04.714]                 withCallingHandlers({
[16:21:04.714]                   {
[16:21:04.714]                     b <- a * ii
[16:21:04.714]                     a <- 0
[16:21:04.714]                     b
[16:21:04.714]                   }
[16:21:04.714]                 }, immediateCondition = function(cond) {
[16:21:04.714]                   save_rds <- function (object, pathname, ...) 
[16:21:04.714]                   {
[16:21:04.714]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.714]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.714]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.714]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.714]                         fi_tmp[["mtime"]])
[16:21:04.714]                     }
[16:21:04.714]                     tryCatch({
[16:21:04.714]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.714]                     }, error = function(ex) {
[16:21:04.714]                       msg <- conditionMessage(ex)
[16:21:04.714]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.714]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.714]                         fi_tmp[["mtime"]], msg)
[16:21:04.714]                       ex$message <- msg
[16:21:04.714]                       stop(ex)
[16:21:04.714]                     })
[16:21:04.714]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.714]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.714]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.714]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.714]                       fi <- file.info(pathname)
[16:21:04.714]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.714]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.714]                         fi[["size"]], fi[["mtime"]])
[16:21:04.714]                       stop(msg)
[16:21:04.714]                     }
[16:21:04.714]                     invisible(pathname)
[16:21:04.714]                   }
[16:21:04.714]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.714]                     rootPath = tempdir()) 
[16:21:04.714]                   {
[16:21:04.714]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.714]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.714]                       tmpdir = path, fileext = ".rds")
[16:21:04.714]                     save_rds(obj, file)
[16:21:04.714]                   }
[16:21:04.714]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.714]                   {
[16:21:04.714]                     inherits <- base::inherits
[16:21:04.714]                     invokeRestart <- base::invokeRestart
[16:21:04.714]                     is.null <- base::is.null
[16:21:04.714]                     muffled <- FALSE
[16:21:04.714]                     if (inherits(cond, "message")) {
[16:21:04.714]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.714]                       if (muffled) 
[16:21:04.714]                         invokeRestart("muffleMessage")
[16:21:04.714]                     }
[16:21:04.714]                     else if (inherits(cond, "warning")) {
[16:21:04.714]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.714]                       if (muffled) 
[16:21:04.714]                         invokeRestart("muffleWarning")
[16:21:04.714]                     }
[16:21:04.714]                     else if (inherits(cond, "condition")) {
[16:21:04.714]                       if (!is.null(pattern)) {
[16:21:04.714]                         computeRestarts <- base::computeRestarts
[16:21:04.714]                         grepl <- base::grepl
[16:21:04.714]                         restarts <- computeRestarts(cond)
[16:21:04.714]                         for (restart in restarts) {
[16:21:04.714]                           name <- restart$name
[16:21:04.714]                           if (is.null(name)) 
[16:21:04.714]                             next
[16:21:04.714]                           if (!grepl(pattern, name)) 
[16:21:04.714]                             next
[16:21:04.714]                           invokeRestart(restart)
[16:21:04.714]                           muffled <- TRUE
[16:21:04.714]                           break
[16:21:04.714]                         }
[16:21:04.714]                       }
[16:21:04.714]                     }
[16:21:04.714]                     invisible(muffled)
[16:21:04.714]                   }
[16:21:04.714]                   muffleCondition(cond)
[16:21:04.714]                 })
[16:21:04.714]             }))
[16:21:04.714]             future::FutureResult(value = ...future.value$value, 
[16:21:04.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.714]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.714]                     ...future.globalenv.names))
[16:21:04.714]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.714]         }, condition = base::local({
[16:21:04.714]             c <- base::c
[16:21:04.714]             inherits <- base::inherits
[16:21:04.714]             invokeRestart <- base::invokeRestart
[16:21:04.714]             length <- base::length
[16:21:04.714]             list <- base::list
[16:21:04.714]             seq.int <- base::seq.int
[16:21:04.714]             signalCondition <- base::signalCondition
[16:21:04.714]             sys.calls <- base::sys.calls
[16:21:04.714]             `[[` <- base::`[[`
[16:21:04.714]             `+` <- base::`+`
[16:21:04.714]             `<<-` <- base::`<<-`
[16:21:04.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.714]                   3L)]
[16:21:04.714]             }
[16:21:04.714]             function(cond) {
[16:21:04.714]                 is_error <- inherits(cond, "error")
[16:21:04.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.714]                   NULL)
[16:21:04.714]                 if (is_error) {
[16:21:04.714]                   sessionInformation <- function() {
[16:21:04.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.714]                       search = base::search(), system = base::Sys.info())
[16:21:04.714]                   }
[16:21:04.714]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.714]                     cond$call), session = sessionInformation(), 
[16:21:04.714]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.714]                   signalCondition(cond)
[16:21:04.714]                 }
[16:21:04.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.714]                 "immediateCondition"))) {
[16:21:04.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.714]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.714]                   if (TRUE && !signal) {
[16:21:04.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.714]                     {
[16:21:04.714]                       inherits <- base::inherits
[16:21:04.714]                       invokeRestart <- base::invokeRestart
[16:21:04.714]                       is.null <- base::is.null
[16:21:04.714]                       muffled <- FALSE
[16:21:04.714]                       if (inherits(cond, "message")) {
[16:21:04.714]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.714]                         if (muffled) 
[16:21:04.714]                           invokeRestart("muffleMessage")
[16:21:04.714]                       }
[16:21:04.714]                       else if (inherits(cond, "warning")) {
[16:21:04.714]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.714]                         if (muffled) 
[16:21:04.714]                           invokeRestart("muffleWarning")
[16:21:04.714]                       }
[16:21:04.714]                       else if (inherits(cond, "condition")) {
[16:21:04.714]                         if (!is.null(pattern)) {
[16:21:04.714]                           computeRestarts <- base::computeRestarts
[16:21:04.714]                           grepl <- base::grepl
[16:21:04.714]                           restarts <- computeRestarts(cond)
[16:21:04.714]                           for (restart in restarts) {
[16:21:04.714]                             name <- restart$name
[16:21:04.714]                             if (is.null(name)) 
[16:21:04.714]                               next
[16:21:04.714]                             if (!grepl(pattern, name)) 
[16:21:04.714]                               next
[16:21:04.714]                             invokeRestart(restart)
[16:21:04.714]                             muffled <- TRUE
[16:21:04.714]                             break
[16:21:04.714]                           }
[16:21:04.714]                         }
[16:21:04.714]                       }
[16:21:04.714]                       invisible(muffled)
[16:21:04.714]                     }
[16:21:04.714]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.714]                   }
[16:21:04.714]                 }
[16:21:04.714]                 else {
[16:21:04.714]                   if (TRUE) {
[16:21:04.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.714]                     {
[16:21:04.714]                       inherits <- base::inherits
[16:21:04.714]                       invokeRestart <- base::invokeRestart
[16:21:04.714]                       is.null <- base::is.null
[16:21:04.714]                       muffled <- FALSE
[16:21:04.714]                       if (inherits(cond, "message")) {
[16:21:04.714]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.714]                         if (muffled) 
[16:21:04.714]                           invokeRestart("muffleMessage")
[16:21:04.714]                       }
[16:21:04.714]                       else if (inherits(cond, "warning")) {
[16:21:04.714]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.714]                         if (muffled) 
[16:21:04.714]                           invokeRestart("muffleWarning")
[16:21:04.714]                       }
[16:21:04.714]                       else if (inherits(cond, "condition")) {
[16:21:04.714]                         if (!is.null(pattern)) {
[16:21:04.714]                           computeRestarts <- base::computeRestarts
[16:21:04.714]                           grepl <- base::grepl
[16:21:04.714]                           restarts <- computeRestarts(cond)
[16:21:04.714]                           for (restart in restarts) {
[16:21:04.714]                             name <- restart$name
[16:21:04.714]                             if (is.null(name)) 
[16:21:04.714]                               next
[16:21:04.714]                             if (!grepl(pattern, name)) 
[16:21:04.714]                               next
[16:21:04.714]                             invokeRestart(restart)
[16:21:04.714]                             muffled <- TRUE
[16:21:04.714]                             break
[16:21:04.714]                           }
[16:21:04.714]                         }
[16:21:04.714]                       }
[16:21:04.714]                       invisible(muffled)
[16:21:04.714]                     }
[16:21:04.714]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.714]                   }
[16:21:04.714]                 }
[16:21:04.714]             }
[16:21:04.714]         }))
[16:21:04.714]     }, error = function(ex) {
[16:21:04.714]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.714]                 ...future.rng), started = ...future.startTime, 
[16:21:04.714]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.714]             version = "1.8"), class = "FutureResult")
[16:21:04.714]     }, finally = {
[16:21:04.714]         if (!identical(...future.workdir, getwd())) 
[16:21:04.714]             setwd(...future.workdir)
[16:21:04.714]         {
[16:21:04.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.714]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.714]             }
[16:21:04.714]             base::options(...future.oldOptions)
[16:21:04.714]             if (.Platform$OS.type == "windows") {
[16:21:04.714]                 old_names <- names(...future.oldEnvVars)
[16:21:04.714]                 envs <- base::Sys.getenv()
[16:21:04.714]                 names <- names(envs)
[16:21:04.714]                 common <- intersect(names, old_names)
[16:21:04.714]                 added <- setdiff(names, old_names)
[16:21:04.714]                 removed <- setdiff(old_names, names)
[16:21:04.714]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.714]                   envs[common]]
[16:21:04.714]                 NAMES <- toupper(changed)
[16:21:04.714]                 args <- list()
[16:21:04.714]                 for (kk in seq_along(NAMES)) {
[16:21:04.714]                   name <- changed[[kk]]
[16:21:04.714]                   NAME <- NAMES[[kk]]
[16:21:04.714]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.714]                     next
[16:21:04.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.714]                 }
[16:21:04.714]                 NAMES <- toupper(added)
[16:21:04.714]                 for (kk in seq_along(NAMES)) {
[16:21:04.714]                   name <- added[[kk]]
[16:21:04.714]                   NAME <- NAMES[[kk]]
[16:21:04.714]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.714]                     next
[16:21:04.714]                   args[[name]] <- ""
[16:21:04.714]                 }
[16:21:04.714]                 NAMES <- toupper(removed)
[16:21:04.714]                 for (kk in seq_along(NAMES)) {
[16:21:04.714]                   name <- removed[[kk]]
[16:21:04.714]                   NAME <- NAMES[[kk]]
[16:21:04.714]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.714]                     next
[16:21:04.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.714]                 }
[16:21:04.714]                 if (length(args) > 0) 
[16:21:04.714]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.714]             }
[16:21:04.714]             else {
[16:21:04.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.714]             }
[16:21:04.714]             {
[16:21:04.714]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.714]                   0L) {
[16:21:04.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.714]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.714]                   base::options(opts)
[16:21:04.714]                 }
[16:21:04.714]                 {
[16:21:04.714]                   {
[16:21:04.714]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.714]                     NULL
[16:21:04.714]                   }
[16:21:04.714]                   options(future.plan = NULL)
[16:21:04.714]                   if (is.na(NA_character_)) 
[16:21:04.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.714]                     .init = FALSE)
[16:21:04.714]                 }
[16:21:04.714]             }
[16:21:04.714]         }
[16:21:04.714]     })
[16:21:04.714]     if (TRUE) {
[16:21:04.714]         base::sink(type = "output", split = FALSE)
[16:21:04.714]         if (TRUE) {
[16:21:04.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.714]         }
[16:21:04.714]         else {
[16:21:04.714]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.714]         }
[16:21:04.714]         base::close(...future.stdout)
[16:21:04.714]         ...future.stdout <- NULL
[16:21:04.714]     }
[16:21:04.714]     ...future.result$conditions <- ...future.conditions
[16:21:04.714]     ...future.result$finished <- base::Sys.time()
[16:21:04.714]     ...future.result
[16:21:04.714] }
[16:21:04.717] assign_globals() ...
[16:21:04.717] List of 2
[16:21:04.717]  $ a : num 1
[16:21:04.717]  $ ii: int 3
[16:21:04.717]  - attr(*, "where")=List of 2
[16:21:04.717]   ..$ a :<environment: R_EmptyEnv> 
[16:21:04.717]   ..$ ii:<environment: R_EmptyEnv> 
[16:21:04.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.717]  - attr(*, "resolved")= logi TRUE
[16:21:04.717]  - attr(*, "total_size")= num 112
[16:21:04.717]  - attr(*, "already-done")= logi TRUE
[16:21:04.721] - copied ‘a’ to environment
[16:21:04.721] - copied ‘ii’ to environment
[16:21:04.722] assign_globals() ... done
[16:21:04.722] requestCore(): workers = 2
[16:21:04.724] MulticoreFuture started
[16:21:04.725] - Launch lazy future ... done
[16:21:04.725] run() for ‘MulticoreFuture’ ... done
[16:21:04.726] plan(): Setting new future strategy stack:
[16:21:04.726] result() for MulticoreFuture ...
[16:21:04.726] List of future strategies:
[16:21:04.726] 1. sequential:
[16:21:04.726]    - args: function (..., envir = parent.frame())
[16:21:04.726]    - tweaked: FALSE
[16:21:04.726]    - call: NULL
[16:21:04.727] plan(): nbrOfWorkers() = 1
[16:21:04.730] plan(): Setting new future strategy stack:
[16:21:04.730] List of future strategies:
[16:21:04.730] 1. multicore:
[16:21:04.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.730]    - tweaked: FALSE
[16:21:04.730]    - call: plan(strategy)
[16:21:04.736] plan(): nbrOfWorkers() = 2
[16:21:04.737] result() for MulticoreFuture ...
[16:21:04.738] result() for MulticoreFuture ... done
[16:21:04.738] result() for MulticoreFuture ... done
[16:21:04.738] result() for MulticoreFuture ...
[16:21:04.738] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.739] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.739] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.740] 
[16:21:04.740] Searching for globals ... DONE
[16:21:04.741] - globals: [0] <none>
[16:21:04.741] getGlobalsAndPackages() ... DONE
[16:21:04.741] run() for ‘Future’ ...
[16:21:04.741] - state: ‘created’
[16:21:04.741] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.746] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.746]   - Field: ‘label’
[16:21:04.746]   - Field: ‘local’
[16:21:04.747]   - Field: ‘owner’
[16:21:04.747]   - Field: ‘envir’
[16:21:04.747]   - Field: ‘workers’
[16:21:04.747]   - Field: ‘packages’
[16:21:04.747]   - Field: ‘gc’
[16:21:04.747]   - Field: ‘job’
[16:21:04.747]   - Field: ‘conditions’
[16:21:04.747]   - Field: ‘expr’
[16:21:04.748]   - Field: ‘uuid’
[16:21:04.748]   - Field: ‘seed’
[16:21:04.748]   - Field: ‘version’
[16:21:04.748]   - Field: ‘result’
[16:21:04.748]   - Field: ‘asynchronous’
[16:21:04.748]   - Field: ‘calls’
[16:21:04.748]   - Field: ‘globals’
[16:21:04.748]   - Field: ‘stdout’
[16:21:04.749]   - Field: ‘earlySignal’
[16:21:04.749]   - Field: ‘lazy’
[16:21:04.749]   - Field: ‘state’
[16:21:04.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.749] - Launch lazy future ...
[16:21:04.749] Packages needed by the future expression (n = 0): <none>
[16:21:04.750] Packages needed by future strategies (n = 0): <none>
[16:21:04.750] {
[16:21:04.750]     {
[16:21:04.750]         {
[16:21:04.750]             ...future.startTime <- base::Sys.time()
[16:21:04.750]             {
[16:21:04.750]                 {
[16:21:04.750]                   {
[16:21:04.750]                     {
[16:21:04.750]                       base::local({
[16:21:04.750]                         has_future <- base::requireNamespace("future", 
[16:21:04.750]                           quietly = TRUE)
[16:21:04.750]                         if (has_future) {
[16:21:04.750]                           ns <- base::getNamespace("future")
[16:21:04.750]                           version <- ns[[".package"]][["version"]]
[16:21:04.750]                           if (is.null(version)) 
[16:21:04.750]                             version <- utils::packageVersion("future")
[16:21:04.750]                         }
[16:21:04.750]                         else {
[16:21:04.750]                           version <- NULL
[16:21:04.750]                         }
[16:21:04.750]                         if (!has_future || version < "1.8.0") {
[16:21:04.750]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.750]                             "", base::R.version$version.string), 
[16:21:04.750]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.750]                               "release", "version")], collapse = " "), 
[16:21:04.750]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.750]                             info)
[16:21:04.750]                           info <- base::paste(info, collapse = "; ")
[16:21:04.750]                           if (!has_future) {
[16:21:04.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.750]                               info)
[16:21:04.750]                           }
[16:21:04.750]                           else {
[16:21:04.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.750]                               info, version)
[16:21:04.750]                           }
[16:21:04.750]                           base::stop(msg)
[16:21:04.750]                         }
[16:21:04.750]                       })
[16:21:04.750]                     }
[16:21:04.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.750]                     base::options(mc.cores = 1L)
[16:21:04.750]                   }
[16:21:04.750]                   ...future.strategy.old <- future::plan("list")
[16:21:04.750]                   options(future.plan = NULL)
[16:21:04.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.750]                 }
[16:21:04.750]                 ...future.workdir <- getwd()
[16:21:04.750]             }
[16:21:04.750]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.750]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.750]         }
[16:21:04.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.750]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.750]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.750]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.750]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.750]             base::names(...future.oldOptions))
[16:21:04.750]     }
[16:21:04.750]     if (FALSE) {
[16:21:04.750]     }
[16:21:04.750]     else {
[16:21:04.750]         if (TRUE) {
[16:21:04.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.750]                 open = "w")
[16:21:04.750]         }
[16:21:04.750]         else {
[16:21:04.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.750]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.750]         }
[16:21:04.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.750]             base::sink(type = "output", split = FALSE)
[16:21:04.750]             base::close(...future.stdout)
[16:21:04.750]         }, add = TRUE)
[16:21:04.750]     }
[16:21:04.750]     ...future.frame <- base::sys.nframe()
[16:21:04.750]     ...future.conditions <- base::list()
[16:21:04.750]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.750]     if (FALSE) {
[16:21:04.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.750]     }
[16:21:04.750]     ...future.result <- base::tryCatch({
[16:21:04.750]         base::withCallingHandlers({
[16:21:04.750]             ...future.value <- base::withVisible(base::local({
[16:21:04.750]                 withCallingHandlers({
[16:21:04.750]                   1
[16:21:04.750]                 }, immediateCondition = function(cond) {
[16:21:04.750]                   save_rds <- function (object, pathname, ...) 
[16:21:04.750]                   {
[16:21:04.750]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.750]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.750]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.750]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.750]                         fi_tmp[["mtime"]])
[16:21:04.750]                     }
[16:21:04.750]                     tryCatch({
[16:21:04.750]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.750]                     }, error = function(ex) {
[16:21:04.750]                       msg <- conditionMessage(ex)
[16:21:04.750]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.750]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.750]                         fi_tmp[["mtime"]], msg)
[16:21:04.750]                       ex$message <- msg
[16:21:04.750]                       stop(ex)
[16:21:04.750]                     })
[16:21:04.750]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.750]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.750]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.750]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.750]                       fi <- file.info(pathname)
[16:21:04.750]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.750]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.750]                         fi[["size"]], fi[["mtime"]])
[16:21:04.750]                       stop(msg)
[16:21:04.750]                     }
[16:21:04.750]                     invisible(pathname)
[16:21:04.750]                   }
[16:21:04.750]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.750]                     rootPath = tempdir()) 
[16:21:04.750]                   {
[16:21:04.750]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.750]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.750]                       tmpdir = path, fileext = ".rds")
[16:21:04.750]                     save_rds(obj, file)
[16:21:04.750]                   }
[16:21:04.750]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.750]                   {
[16:21:04.750]                     inherits <- base::inherits
[16:21:04.750]                     invokeRestart <- base::invokeRestart
[16:21:04.750]                     is.null <- base::is.null
[16:21:04.750]                     muffled <- FALSE
[16:21:04.750]                     if (inherits(cond, "message")) {
[16:21:04.750]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.750]                       if (muffled) 
[16:21:04.750]                         invokeRestart("muffleMessage")
[16:21:04.750]                     }
[16:21:04.750]                     else if (inherits(cond, "warning")) {
[16:21:04.750]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.750]                       if (muffled) 
[16:21:04.750]                         invokeRestart("muffleWarning")
[16:21:04.750]                     }
[16:21:04.750]                     else if (inherits(cond, "condition")) {
[16:21:04.750]                       if (!is.null(pattern)) {
[16:21:04.750]                         computeRestarts <- base::computeRestarts
[16:21:04.750]                         grepl <- base::grepl
[16:21:04.750]                         restarts <- computeRestarts(cond)
[16:21:04.750]                         for (restart in restarts) {
[16:21:04.750]                           name <- restart$name
[16:21:04.750]                           if (is.null(name)) 
[16:21:04.750]                             next
[16:21:04.750]                           if (!grepl(pattern, name)) 
[16:21:04.750]                             next
[16:21:04.750]                           invokeRestart(restart)
[16:21:04.750]                           muffled <- TRUE
[16:21:04.750]                           break
[16:21:04.750]                         }
[16:21:04.750]                       }
[16:21:04.750]                     }
[16:21:04.750]                     invisible(muffled)
[16:21:04.750]                   }
[16:21:04.750]                   muffleCondition(cond)
[16:21:04.750]                 })
[16:21:04.750]             }))
[16:21:04.750]             future::FutureResult(value = ...future.value$value, 
[16:21:04.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.750]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.750]                     ...future.globalenv.names))
[16:21:04.750]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.750]         }, condition = base::local({
[16:21:04.750]             c <- base::c
[16:21:04.750]             inherits <- base::inherits
[16:21:04.750]             invokeRestart <- base::invokeRestart
[16:21:04.750]             length <- base::length
[16:21:04.750]             list <- base::list
[16:21:04.750]             seq.int <- base::seq.int
[16:21:04.750]             signalCondition <- base::signalCondition
[16:21:04.750]             sys.calls <- base::sys.calls
[16:21:04.750]             `[[` <- base::`[[`
[16:21:04.750]             `+` <- base::`+`
[16:21:04.750]             `<<-` <- base::`<<-`
[16:21:04.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.750]                   3L)]
[16:21:04.750]             }
[16:21:04.750]             function(cond) {
[16:21:04.750]                 is_error <- inherits(cond, "error")
[16:21:04.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.750]                   NULL)
[16:21:04.750]                 if (is_error) {
[16:21:04.750]                   sessionInformation <- function() {
[16:21:04.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.750]                       search = base::search(), system = base::Sys.info())
[16:21:04.750]                   }
[16:21:04.750]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.750]                     cond$call), session = sessionInformation(), 
[16:21:04.750]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.750]                   signalCondition(cond)
[16:21:04.750]                 }
[16:21:04.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.750]                 "immediateCondition"))) {
[16:21:04.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.750]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.750]                   if (TRUE && !signal) {
[16:21:04.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.750]                     {
[16:21:04.750]                       inherits <- base::inherits
[16:21:04.750]                       invokeRestart <- base::invokeRestart
[16:21:04.750]                       is.null <- base::is.null
[16:21:04.750]                       muffled <- FALSE
[16:21:04.750]                       if (inherits(cond, "message")) {
[16:21:04.750]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.750]                         if (muffled) 
[16:21:04.750]                           invokeRestart("muffleMessage")
[16:21:04.750]                       }
[16:21:04.750]                       else if (inherits(cond, "warning")) {
[16:21:04.750]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.750]                         if (muffled) 
[16:21:04.750]                           invokeRestart("muffleWarning")
[16:21:04.750]                       }
[16:21:04.750]                       else if (inherits(cond, "condition")) {
[16:21:04.750]                         if (!is.null(pattern)) {
[16:21:04.750]                           computeRestarts <- base::computeRestarts
[16:21:04.750]                           grepl <- base::grepl
[16:21:04.750]                           restarts <- computeRestarts(cond)
[16:21:04.750]                           for (restart in restarts) {
[16:21:04.750]                             name <- restart$name
[16:21:04.750]                             if (is.null(name)) 
[16:21:04.750]                               next
[16:21:04.750]                             if (!grepl(pattern, name)) 
[16:21:04.750]                               next
[16:21:04.750]                             invokeRestart(restart)
[16:21:04.750]                             muffled <- TRUE
[16:21:04.750]                             break
[16:21:04.750]                           }
[16:21:04.750]                         }
[16:21:04.750]                       }
[16:21:04.750]                       invisible(muffled)
[16:21:04.750]                     }
[16:21:04.750]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.750]                   }
[16:21:04.750]                 }
[16:21:04.750]                 else {
[16:21:04.750]                   if (TRUE) {
[16:21:04.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.750]                     {
[16:21:04.750]                       inherits <- base::inherits
[16:21:04.750]                       invokeRestart <- base::invokeRestart
[16:21:04.750]                       is.null <- base::is.null
[16:21:04.750]                       muffled <- FALSE
[16:21:04.750]                       if (inherits(cond, "message")) {
[16:21:04.750]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.750]                         if (muffled) 
[16:21:04.750]                           invokeRestart("muffleMessage")
[16:21:04.750]                       }
[16:21:04.750]                       else if (inherits(cond, "warning")) {
[16:21:04.750]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.750]                         if (muffled) 
[16:21:04.750]                           invokeRestart("muffleWarning")
[16:21:04.750]                       }
[16:21:04.750]                       else if (inherits(cond, "condition")) {
[16:21:04.750]                         if (!is.null(pattern)) {
[16:21:04.750]                           computeRestarts <- base::computeRestarts
[16:21:04.750]                           grepl <- base::grepl
[16:21:04.750]                           restarts <- computeRestarts(cond)
[16:21:04.750]                           for (restart in restarts) {
[16:21:04.750]                             name <- restart$name
[16:21:04.750]                             if (is.null(name)) 
[16:21:04.750]                               next
[16:21:04.750]                             if (!grepl(pattern, name)) 
[16:21:04.750]                               next
[16:21:04.750]                             invokeRestart(restart)
[16:21:04.750]                             muffled <- TRUE
[16:21:04.750]                             break
[16:21:04.750]                           }
[16:21:04.750]                         }
[16:21:04.750]                       }
[16:21:04.750]                       invisible(muffled)
[16:21:04.750]                     }
[16:21:04.750]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.750]                   }
[16:21:04.750]                 }
[16:21:04.750]             }
[16:21:04.750]         }))
[16:21:04.750]     }, error = function(ex) {
[16:21:04.750]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.750]                 ...future.rng), started = ...future.startTime, 
[16:21:04.750]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.750]             version = "1.8"), class = "FutureResult")
[16:21:04.750]     }, finally = {
[16:21:04.750]         if (!identical(...future.workdir, getwd())) 
[16:21:04.750]             setwd(...future.workdir)
[16:21:04.750]         {
[16:21:04.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.750]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.750]             }
[16:21:04.750]             base::options(...future.oldOptions)
[16:21:04.750]             if (.Platform$OS.type == "windows") {
[16:21:04.750]                 old_names <- names(...future.oldEnvVars)
[16:21:04.750]                 envs <- base::Sys.getenv()
[16:21:04.750]                 names <- names(envs)
[16:21:04.750]                 common <- intersect(names, old_names)
[16:21:04.750]                 added <- setdiff(names, old_names)
[16:21:04.750]                 removed <- setdiff(old_names, names)
[16:21:04.750]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.750]                   envs[common]]
[16:21:04.750]                 NAMES <- toupper(changed)
[16:21:04.750]                 args <- list()
[16:21:04.750]                 for (kk in seq_along(NAMES)) {
[16:21:04.750]                   name <- changed[[kk]]
[16:21:04.750]                   NAME <- NAMES[[kk]]
[16:21:04.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.750]                     next
[16:21:04.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.750]                 }
[16:21:04.750]                 NAMES <- toupper(added)
[16:21:04.750]                 for (kk in seq_along(NAMES)) {
[16:21:04.750]                   name <- added[[kk]]
[16:21:04.750]                   NAME <- NAMES[[kk]]
[16:21:04.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.750]                     next
[16:21:04.750]                   args[[name]] <- ""
[16:21:04.750]                 }
[16:21:04.750]                 NAMES <- toupper(removed)
[16:21:04.750]                 for (kk in seq_along(NAMES)) {
[16:21:04.750]                   name <- removed[[kk]]
[16:21:04.750]                   NAME <- NAMES[[kk]]
[16:21:04.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.750]                     next
[16:21:04.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.750]                 }
[16:21:04.750]                 if (length(args) > 0) 
[16:21:04.750]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.750]             }
[16:21:04.750]             else {
[16:21:04.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.750]             }
[16:21:04.750]             {
[16:21:04.750]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.750]                   0L) {
[16:21:04.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.750]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.750]                   base::options(opts)
[16:21:04.750]                 }
[16:21:04.750]                 {
[16:21:04.750]                   {
[16:21:04.750]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.750]                     NULL
[16:21:04.750]                   }
[16:21:04.750]                   options(future.plan = NULL)
[16:21:04.750]                   if (is.na(NA_character_)) 
[16:21:04.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.750]                     .init = FALSE)
[16:21:04.750]                 }
[16:21:04.750]             }
[16:21:04.750]         }
[16:21:04.750]     })
[16:21:04.750]     if (TRUE) {
[16:21:04.750]         base::sink(type = "output", split = FALSE)
[16:21:04.750]         if (TRUE) {
[16:21:04.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.750]         }
[16:21:04.750]         else {
[16:21:04.750]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.750]         }
[16:21:04.750]         base::close(...future.stdout)
[16:21:04.750]         ...future.stdout <- NULL
[16:21:04.750]     }
[16:21:04.750]     ...future.result$conditions <- ...future.conditions
[16:21:04.750]     ...future.result$finished <- base::Sys.time()
[16:21:04.750]     ...future.result
[16:21:04.750] }
[16:21:04.753] requestCore(): workers = 2
[16:21:04.755] MulticoreFuture started
[16:21:04.755] - Launch lazy future ... done
[16:21:04.755] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.756] getGlobalsAndPackages() ...
[16:21:04.756] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.756] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.756] List of future strategies:
[16:21:04.756] 1. sequential:
[16:21:04.756]    - args: function (..., envir = parent.frame())
[16:21:04.756]    - tweaked: FALSE
[16:21:04.756]    - call: NULL
[16:21:04.757] plan(): nbrOfWorkers() = 1
[16:21:04.758] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:04.759] Searching for globals ... DONE
[16:21:04.759] Resolving globals: TRUE
[16:21:04.759] Resolving any globals that are futures ...
[16:21:04.759] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:04.759] Resolving any globals that are futures ... DONE
[16:21:04.759] plan(): Setting new future strategy stack:
[16:21:04.760] Resolving futures part of globals (recursively) ...
[16:21:04.760] List of future strategies:
[16:21:04.760] 1. multicore:
[16:21:04.760]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.760]    - tweaked: FALSE
[16:21:04.760]    - call: plan(strategy)
[16:21:04.761] resolve() on list ...
[16:21:04.761]  recursive: 99
[16:21:04.761]  length: 1
[16:21:04.761]  elements: ‘a’
[16:21:04.765] plan(): nbrOfWorkers() = 2
[16:21:04.765] Future #1
[16:21:04.766] result() for MulticoreFuture ...
[16:21:04.767] result() for MulticoreFuture ...
[16:21:04.767] result() for MulticoreFuture ... done
[16:21:04.767] result() for MulticoreFuture ... done
[16:21:04.767] result() for MulticoreFuture ...
[16:21:04.767] result() for MulticoreFuture ... done
[16:21:04.768] A MulticoreFuture was resolved
[16:21:04.768]  length: 0 (resolved future 1)
[16:21:04.768] resolve() on list ... DONE
[16:21:04.768] - globals: [1] ‘a’
[16:21:04.768] Resolving futures part of globals (recursively) ... DONE
[16:21:04.771] The total size of the 1 globals is 1.57 MiB (1647008 bytes)
[16:21:04.771] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:21:04.772] - globals: [1] ‘a’
[16:21:04.772] - packages: [1] ‘future’
[16:21:04.772] getGlobalsAndPackages() ... DONE
[16:21:04.772] run() for ‘Future’ ...
[16:21:04.773] - state: ‘created’
[16:21:04.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.781] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.781] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.781]   - Field: ‘label’
[16:21:04.781]   - Field: ‘local’
[16:21:04.781]   - Field: ‘owner’
[16:21:04.781]   - Field: ‘envir’
[16:21:04.782]   - Field: ‘workers’
[16:21:04.782]   - Field: ‘packages’
[16:21:04.782]   - Field: ‘gc’
[16:21:04.782]   - Field: ‘job’
[16:21:04.782]   - Field: ‘conditions’
[16:21:04.782]   - Field: ‘expr’
[16:21:04.782]   - Field: ‘uuid’
[16:21:04.783]   - Field: ‘seed’
[16:21:04.783]   - Field: ‘version’
[16:21:04.783]   - Field: ‘result’
[16:21:04.783]   - Field: ‘asynchronous’
[16:21:04.783]   - Field: ‘calls’
[16:21:04.783]   - Field: ‘globals’
[16:21:04.783]   - Field: ‘stdout’
[16:21:04.784]   - Field: ‘earlySignal’
[16:21:04.784]   - Field: ‘lazy’
[16:21:04.784]   - Field: ‘state’
[16:21:04.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.784] - Launch lazy future ...
[16:21:04.785] Packages needed by the future expression (n = 1): ‘future’
[16:21:04.785] Packages needed by future strategies (n = 0): <none>
[16:21:04.785] {
[16:21:04.785]     {
[16:21:04.785]         {
[16:21:04.785]             ...future.startTime <- base::Sys.time()
[16:21:04.785]             {
[16:21:04.785]                 {
[16:21:04.785]                   {
[16:21:04.785]                     {
[16:21:04.785]                       {
[16:21:04.785]                         base::local({
[16:21:04.785]                           has_future <- base::requireNamespace("future", 
[16:21:04.785]                             quietly = TRUE)
[16:21:04.785]                           if (has_future) {
[16:21:04.785]                             ns <- base::getNamespace("future")
[16:21:04.785]                             version <- ns[[".package"]][["version"]]
[16:21:04.785]                             if (is.null(version)) 
[16:21:04.785]                               version <- utils::packageVersion("future")
[16:21:04.785]                           }
[16:21:04.785]                           else {
[16:21:04.785]                             version <- NULL
[16:21:04.785]                           }
[16:21:04.785]                           if (!has_future || version < "1.8.0") {
[16:21:04.785]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.785]                               "", base::R.version$version.string), 
[16:21:04.785]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:04.785]                                 base::R.version$platform, 8 * 
[16:21:04.785]                                   base::.Machine$sizeof.pointer), 
[16:21:04.785]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.785]                                 "release", "version")], collapse = " "), 
[16:21:04.785]                               hostname = base::Sys.info()[["nodename"]])
[16:21:04.785]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.785]                               info)
[16:21:04.785]                             info <- base::paste(info, collapse = "; ")
[16:21:04.785]                             if (!has_future) {
[16:21:04.785]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.785]                                 info)
[16:21:04.785]                             }
[16:21:04.785]                             else {
[16:21:04.785]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.785]                                 info, version)
[16:21:04.785]                             }
[16:21:04.785]                             base::stop(msg)
[16:21:04.785]                           }
[16:21:04.785]                         })
[16:21:04.785]                       }
[16:21:04.785]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.785]                       base::options(mc.cores = 1L)
[16:21:04.785]                     }
[16:21:04.785]                     base::local({
[16:21:04.785]                       for (pkg in "future") {
[16:21:04.785]                         base::loadNamespace(pkg)
[16:21:04.785]                         base::library(pkg, character.only = TRUE)
[16:21:04.785]                       }
[16:21:04.785]                     })
[16:21:04.785]                   }
[16:21:04.785]                   ...future.strategy.old <- future::plan("list")
[16:21:04.785]                   options(future.plan = NULL)
[16:21:04.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.785]                 }
[16:21:04.785]                 ...future.workdir <- getwd()
[16:21:04.785]             }
[16:21:04.785]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.785]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.785]         }
[16:21:04.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.785]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.785]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.785]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.785]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.785]             base::names(...future.oldOptions))
[16:21:04.785]     }
[16:21:04.785]     if (FALSE) {
[16:21:04.785]     }
[16:21:04.785]     else {
[16:21:04.785]         if (TRUE) {
[16:21:04.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.785]                 open = "w")
[16:21:04.785]         }
[16:21:04.785]         else {
[16:21:04.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.785]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.785]         }
[16:21:04.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.785]             base::sink(type = "output", split = FALSE)
[16:21:04.785]             base::close(...future.stdout)
[16:21:04.785]         }, add = TRUE)
[16:21:04.785]     }
[16:21:04.785]     ...future.frame <- base::sys.nframe()
[16:21:04.785]     ...future.conditions <- base::list()
[16:21:04.785]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.785]     if (FALSE) {
[16:21:04.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.785]     }
[16:21:04.785]     ...future.result <- base::tryCatch({
[16:21:04.785]         base::withCallingHandlers({
[16:21:04.785]             ...future.value <- base::withVisible(base::local({
[16:21:04.785]                 withCallingHandlers({
[16:21:04.785]                   value(a) + 1
[16:21:04.785]                 }, immediateCondition = function(cond) {
[16:21:04.785]                   save_rds <- function (object, pathname, ...) 
[16:21:04.785]                   {
[16:21:04.785]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.785]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.785]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.785]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.785]                         fi_tmp[["mtime"]])
[16:21:04.785]                     }
[16:21:04.785]                     tryCatch({
[16:21:04.785]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.785]                     }, error = function(ex) {
[16:21:04.785]                       msg <- conditionMessage(ex)
[16:21:04.785]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.785]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.785]                         fi_tmp[["mtime"]], msg)
[16:21:04.785]                       ex$message <- msg
[16:21:04.785]                       stop(ex)
[16:21:04.785]                     })
[16:21:04.785]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.785]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.785]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.785]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.785]                       fi <- file.info(pathname)
[16:21:04.785]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.785]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.785]                         fi[["size"]], fi[["mtime"]])
[16:21:04.785]                       stop(msg)
[16:21:04.785]                     }
[16:21:04.785]                     invisible(pathname)
[16:21:04.785]                   }
[16:21:04.785]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.785]                     rootPath = tempdir()) 
[16:21:04.785]                   {
[16:21:04.785]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.785]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.785]                       tmpdir = path, fileext = ".rds")
[16:21:04.785]                     save_rds(obj, file)
[16:21:04.785]                   }
[16:21:04.785]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.785]                   {
[16:21:04.785]                     inherits <- base::inherits
[16:21:04.785]                     invokeRestart <- base::invokeRestart
[16:21:04.785]                     is.null <- base::is.null
[16:21:04.785]                     muffled <- FALSE
[16:21:04.785]                     if (inherits(cond, "message")) {
[16:21:04.785]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.785]                       if (muffled) 
[16:21:04.785]                         invokeRestart("muffleMessage")
[16:21:04.785]                     }
[16:21:04.785]                     else if (inherits(cond, "warning")) {
[16:21:04.785]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.785]                       if (muffled) 
[16:21:04.785]                         invokeRestart("muffleWarning")
[16:21:04.785]                     }
[16:21:04.785]                     else if (inherits(cond, "condition")) {
[16:21:04.785]                       if (!is.null(pattern)) {
[16:21:04.785]                         computeRestarts <- base::computeRestarts
[16:21:04.785]                         grepl <- base::grepl
[16:21:04.785]                         restarts <- computeRestarts(cond)
[16:21:04.785]                         for (restart in restarts) {
[16:21:04.785]                           name <- restart$name
[16:21:04.785]                           if (is.null(name)) 
[16:21:04.785]                             next
[16:21:04.785]                           if (!grepl(pattern, name)) 
[16:21:04.785]                             next
[16:21:04.785]                           invokeRestart(restart)
[16:21:04.785]                           muffled <- TRUE
[16:21:04.785]                           break
[16:21:04.785]                         }
[16:21:04.785]                       }
[16:21:04.785]                     }
[16:21:04.785]                     invisible(muffled)
[16:21:04.785]                   }
[16:21:04.785]                   muffleCondition(cond)
[16:21:04.785]                 })
[16:21:04.785]             }))
[16:21:04.785]             future::FutureResult(value = ...future.value$value, 
[16:21:04.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.785]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.785]                     ...future.globalenv.names))
[16:21:04.785]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.785]         }, condition = base::local({
[16:21:04.785]             c <- base::c
[16:21:04.785]             inherits <- base::inherits
[16:21:04.785]             invokeRestart <- base::invokeRestart
[16:21:04.785]             length <- base::length
[16:21:04.785]             list <- base::list
[16:21:04.785]             seq.int <- base::seq.int
[16:21:04.785]             signalCondition <- base::signalCondition
[16:21:04.785]             sys.calls <- base::sys.calls
[16:21:04.785]             `[[` <- base::`[[`
[16:21:04.785]             `+` <- base::`+`
[16:21:04.785]             `<<-` <- base::`<<-`
[16:21:04.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.785]                   3L)]
[16:21:04.785]             }
[16:21:04.785]             function(cond) {
[16:21:04.785]                 is_error <- inherits(cond, "error")
[16:21:04.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.785]                   NULL)
[16:21:04.785]                 if (is_error) {
[16:21:04.785]                   sessionInformation <- function() {
[16:21:04.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.785]                       search = base::search(), system = base::Sys.info())
[16:21:04.785]                   }
[16:21:04.785]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.785]                     cond$call), session = sessionInformation(), 
[16:21:04.785]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.785]                   signalCondition(cond)
[16:21:04.785]                 }
[16:21:04.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.785]                 "immediateCondition"))) {
[16:21:04.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.785]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.785]                   if (TRUE && !signal) {
[16:21:04.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.785]                     {
[16:21:04.785]                       inherits <- base::inherits
[16:21:04.785]                       invokeRestart <- base::invokeRestart
[16:21:04.785]                       is.null <- base::is.null
[16:21:04.785]                       muffled <- FALSE
[16:21:04.785]                       if (inherits(cond, "message")) {
[16:21:04.785]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.785]                         if (muffled) 
[16:21:04.785]                           invokeRestart("muffleMessage")
[16:21:04.785]                       }
[16:21:04.785]                       else if (inherits(cond, "warning")) {
[16:21:04.785]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.785]                         if (muffled) 
[16:21:04.785]                           invokeRestart("muffleWarning")
[16:21:04.785]                       }
[16:21:04.785]                       else if (inherits(cond, "condition")) {
[16:21:04.785]                         if (!is.null(pattern)) {
[16:21:04.785]                           computeRestarts <- base::computeRestarts
[16:21:04.785]                           grepl <- base::grepl
[16:21:04.785]                           restarts <- computeRestarts(cond)
[16:21:04.785]                           for (restart in restarts) {
[16:21:04.785]                             name <- restart$name
[16:21:04.785]                             if (is.null(name)) 
[16:21:04.785]                               next
[16:21:04.785]                             if (!grepl(pattern, name)) 
[16:21:04.785]                               next
[16:21:04.785]                             invokeRestart(restart)
[16:21:04.785]                             muffled <- TRUE
[16:21:04.785]                             break
[16:21:04.785]                           }
[16:21:04.785]                         }
[16:21:04.785]                       }
[16:21:04.785]                       invisible(muffled)
[16:21:04.785]                     }
[16:21:04.785]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.785]                   }
[16:21:04.785]                 }
[16:21:04.785]                 else {
[16:21:04.785]                   if (TRUE) {
[16:21:04.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.785]                     {
[16:21:04.785]                       inherits <- base::inherits
[16:21:04.785]                       invokeRestart <- base::invokeRestart
[16:21:04.785]                       is.null <- base::is.null
[16:21:04.785]                       muffled <- FALSE
[16:21:04.785]                       if (inherits(cond, "message")) {
[16:21:04.785]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.785]                         if (muffled) 
[16:21:04.785]                           invokeRestart("muffleMessage")
[16:21:04.785]                       }
[16:21:04.785]                       else if (inherits(cond, "warning")) {
[16:21:04.785]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.785]                         if (muffled) 
[16:21:04.785]                           invokeRestart("muffleWarning")
[16:21:04.785]                       }
[16:21:04.785]                       else if (inherits(cond, "condition")) {
[16:21:04.785]                         if (!is.null(pattern)) {
[16:21:04.785]                           computeRestarts <- base::computeRestarts
[16:21:04.785]                           grepl <- base::grepl
[16:21:04.785]                           restarts <- computeRestarts(cond)
[16:21:04.785]                           for (restart in restarts) {
[16:21:04.785]                             name <- restart$name
[16:21:04.785]                             if (is.null(name)) 
[16:21:04.785]                               next
[16:21:04.785]                             if (!grepl(pattern, name)) 
[16:21:04.785]                               next
[16:21:04.785]                             invokeRestart(restart)
[16:21:04.785]                             muffled <- TRUE
[16:21:04.785]                             break
[16:21:04.785]                           }
[16:21:04.785]                         }
[16:21:04.785]                       }
[16:21:04.785]                       invisible(muffled)
[16:21:04.785]                     }
[16:21:04.785]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.785]                   }
[16:21:04.785]                 }
[16:21:04.785]             }
[16:21:04.785]         }))
[16:21:04.785]     }, error = function(ex) {
[16:21:04.785]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.785]                 ...future.rng), started = ...future.startTime, 
[16:21:04.785]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.785]             version = "1.8"), class = "FutureResult")
[16:21:04.785]     }, finally = {
[16:21:04.785]         if (!identical(...future.workdir, getwd())) 
[16:21:04.785]             setwd(...future.workdir)
[16:21:04.785]         {
[16:21:04.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.785]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.785]             }
[16:21:04.785]             base::options(...future.oldOptions)
[16:21:04.785]             if (.Platform$OS.type == "windows") {
[16:21:04.785]                 old_names <- names(...future.oldEnvVars)
[16:21:04.785]                 envs <- base::Sys.getenv()
[16:21:04.785]                 names <- names(envs)
[16:21:04.785]                 common <- intersect(names, old_names)
[16:21:04.785]                 added <- setdiff(names, old_names)
[16:21:04.785]                 removed <- setdiff(old_names, names)
[16:21:04.785]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.785]                   envs[common]]
[16:21:04.785]                 NAMES <- toupper(changed)
[16:21:04.785]                 args <- list()
[16:21:04.785]                 for (kk in seq_along(NAMES)) {
[16:21:04.785]                   name <- changed[[kk]]
[16:21:04.785]                   NAME <- NAMES[[kk]]
[16:21:04.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.785]                     next
[16:21:04.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.785]                 }
[16:21:04.785]                 NAMES <- toupper(added)
[16:21:04.785]                 for (kk in seq_along(NAMES)) {
[16:21:04.785]                   name <- added[[kk]]
[16:21:04.785]                   NAME <- NAMES[[kk]]
[16:21:04.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.785]                     next
[16:21:04.785]                   args[[name]] <- ""
[16:21:04.785]                 }
[16:21:04.785]                 NAMES <- toupper(removed)
[16:21:04.785]                 for (kk in seq_along(NAMES)) {
[16:21:04.785]                   name <- removed[[kk]]
[16:21:04.785]                   NAME <- NAMES[[kk]]
[16:21:04.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.785]                     next
[16:21:04.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.785]                 }
[16:21:04.785]                 if (length(args) > 0) 
[16:21:04.785]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.785]             }
[16:21:04.785]             else {
[16:21:04.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.785]             }
[16:21:04.785]             {
[16:21:04.785]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.785]                   0L) {
[16:21:04.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.785]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.785]                   base::options(opts)
[16:21:04.785]                 }
[16:21:04.785]                 {
[16:21:04.785]                   {
[16:21:04.785]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.785]                     NULL
[16:21:04.785]                   }
[16:21:04.785]                   options(future.plan = NULL)
[16:21:04.785]                   if (is.na(NA_character_)) 
[16:21:04.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.785]                     .init = FALSE)
[16:21:04.785]                 }
[16:21:04.785]             }
[16:21:04.785]         }
[16:21:04.785]     })
[16:21:04.785]     if (TRUE) {
[16:21:04.785]         base::sink(type = "output", split = FALSE)
[16:21:04.785]         if (TRUE) {
[16:21:04.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.785]         }
[16:21:04.785]         else {
[16:21:04.785]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.785]         }
[16:21:04.785]         base::close(...future.stdout)
[16:21:04.785]         ...future.stdout <- NULL
[16:21:04.785]     }
[16:21:04.785]     ...future.result$conditions <- ...future.conditions
[16:21:04.785]     ...future.result$finished <- base::Sys.time()
[16:21:04.785]     ...future.result
[16:21:04.785] }
[16:21:04.788] assign_globals() ...
[16:21:04.788] List of 1
[16:21:04.788]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x562226d83e88> 
[16:21:04.788]  - attr(*, "where")=List of 1
[16:21:04.788]   ..$ a:<environment: R_EmptyEnv> 
[16:21:04.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.788]  - attr(*, "resolved")= logi TRUE
[16:21:04.788]  - attr(*, "total_size")= num 1647008
[16:21:04.788]  - attr(*, "already-done")= logi TRUE
[16:21:04.791] - copied ‘a’ to environment
[16:21:04.792] assign_globals() ... done
[16:21:04.792] requestCore(): workers = 2
[16:21:04.794] MulticoreFuture started
[16:21:04.794] - Launch lazy future ... done
[16:21:04.795] run() for ‘MulticoreFuture’ ... done
[16:21:04.795] result() for MulticoreFuture ...
[16:21:04.795] plan(): Setting new future strategy stack:
[16:21:04.796] List of future strategies:
[16:21:04.796] 1. sequential:
[16:21:04.796]    - args: function (..., envir = parent.frame())
[16:21:04.796]    - tweaked: FALSE
[16:21:04.796]    - call: NULL
[16:21:04.797] plan(): nbrOfWorkers() = 1
[16:21:04.801] plan(): Setting new future strategy stack:
[16:21:04.801] List of future strategies:
[16:21:04.801] 1. multicore:
[16:21:04.801]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.801]    - tweaked: FALSE
[16:21:04.801]    - call: plan(strategy)
[16:21:04.807] plan(): nbrOfWorkers() = 2
[16:21:04.808] result() for MulticoreFuture ...
[16:21:04.809] result() for MulticoreFuture ... done
[16:21:04.809] signalConditions() ...
[16:21:04.809]  - include = ‘immediateCondition’
[16:21:04.809]  - exclude = 
[16:21:04.809]  - resignal = FALSE
[16:21:04.809]  - Number of conditions: 4
[16:21:04.810] signalConditions() ... done
[16:21:04.810] result() for MulticoreFuture ... done
[16:21:04.810] result() for MulticoreFuture ...
[16:21:04.810] result() for MulticoreFuture ... done
[16:21:04.810] signalConditions() ...
[16:21:04.810]  - include = ‘immediateCondition’
[16:21:04.810]  - exclude = 
[16:21:04.811]  - resignal = FALSE
[16:21:04.811]  - Number of conditions: 4
[16:21:04.811] signalConditions() ... done
[16:21:04.811] Future state: ‘finished’
[16:21:04.811] result() for MulticoreFuture ...
[16:21:04.811] result() for MulticoreFuture ... done
[16:21:04.811] signalConditions() ...
[16:21:04.812]  - include = ‘condition’
[16:21:04.812]  - exclude = ‘immediateCondition’
[16:21:04.812]  - resignal = TRUE
[16:21:04.812]  - Number of conditions: 4
[16:21:04.812]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.798] result() for MulticoreFuture ...
[16:21:04.812]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.799] result() for MulticoreFuture ... done
[16:21:04.813]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.799] result() for MulticoreFuture ...
[16:21:04.813]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.799] result() for MulticoreFuture ... done
[16:21:04.813] signalConditions() ... done
value(b) = 2
[16:21:04.813] result() for MulticoreFuture ...
[16:21:04.813] result() for MulticoreFuture ... done
[16:21:04.813] result() for MulticoreFuture ...
[16:21:04.813] result() for MulticoreFuture ... done
[16:21:04.814] signalConditions() ...
[16:21:04.814]  - include = ‘immediateCondition’
[16:21:04.814]  - exclude = 
[16:21:04.814]  - resignal = FALSE
[16:21:04.814]  - Number of conditions: 4
[16:21:04.814] signalConditions() ... done
[16:21:04.814] Future state: ‘finished’
[16:21:04.814] result() for MulticoreFuture ...
[16:21:04.815] result() for MulticoreFuture ... done
[16:21:04.815] signalConditions() ...
[16:21:04.815]  - include = ‘condition’
[16:21:04.815]  - exclude = ‘immediateCondition’
[16:21:04.815]  - resignal = TRUE
[16:21:04.815]  - Number of conditions: 4
[16:21:04.815]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.798] result() for MulticoreFuture ...
[16:21:04.815]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.799] result() for MulticoreFuture ... done
[16:21:04.815]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.799] result() for MulticoreFuture ...
[16:21:04.816]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.799] result() for MulticoreFuture ... done
[16:21:04.816] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.816] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.816] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.817] 
[16:21:04.817] Searching for globals ... DONE
[16:21:04.817] - globals: [0] <none>
[16:21:04.817] getGlobalsAndPackages() ... DONE
[16:21:04.818] run() for ‘Future’ ...
[16:21:04.818] - state: ‘created’
[16:21:04.818] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.822] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.822] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.823]   - Field: ‘label’
[16:21:04.823]   - Field: ‘local’
[16:21:04.823]   - Field: ‘owner’
[16:21:04.823]   - Field: ‘envir’
[16:21:04.823]   - Field: ‘workers’
[16:21:04.823]   - Field: ‘packages’
[16:21:04.823]   - Field: ‘gc’
[16:21:04.823]   - Field: ‘job’
[16:21:04.824]   - Field: ‘conditions’
[16:21:04.824]   - Field: ‘expr’
[16:21:04.824]   - Field: ‘uuid’
[16:21:04.824]   - Field: ‘seed’
[16:21:04.824]   - Field: ‘version’
[16:21:04.824]   - Field: ‘result’
[16:21:04.824]   - Field: ‘asynchronous’
[16:21:04.824]   - Field: ‘calls’
[16:21:04.825]   - Field: ‘globals’
[16:21:04.825]   - Field: ‘stdout’
[16:21:04.825]   - Field: ‘earlySignal’
[16:21:04.825]   - Field: ‘lazy’
[16:21:04.825]   - Field: ‘state’
[16:21:04.825] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.825] - Launch lazy future ...
[16:21:04.826] Packages needed by the future expression (n = 0): <none>
[16:21:04.826] Packages needed by future strategies (n = 0): <none>
[16:21:04.826] {
[16:21:04.826]     {
[16:21:04.826]         {
[16:21:04.826]             ...future.startTime <- base::Sys.time()
[16:21:04.826]             {
[16:21:04.826]                 {
[16:21:04.826]                   {
[16:21:04.826]                     {
[16:21:04.826]                       base::local({
[16:21:04.826]                         has_future <- base::requireNamespace("future", 
[16:21:04.826]                           quietly = TRUE)
[16:21:04.826]                         if (has_future) {
[16:21:04.826]                           ns <- base::getNamespace("future")
[16:21:04.826]                           version <- ns[[".package"]][["version"]]
[16:21:04.826]                           if (is.null(version)) 
[16:21:04.826]                             version <- utils::packageVersion("future")
[16:21:04.826]                         }
[16:21:04.826]                         else {
[16:21:04.826]                           version <- NULL
[16:21:04.826]                         }
[16:21:04.826]                         if (!has_future || version < "1.8.0") {
[16:21:04.826]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.826]                             "", base::R.version$version.string), 
[16:21:04.826]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.826]                               "release", "version")], collapse = " "), 
[16:21:04.826]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.826]                             info)
[16:21:04.826]                           info <- base::paste(info, collapse = "; ")
[16:21:04.826]                           if (!has_future) {
[16:21:04.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.826]                               info)
[16:21:04.826]                           }
[16:21:04.826]                           else {
[16:21:04.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.826]                               info, version)
[16:21:04.826]                           }
[16:21:04.826]                           base::stop(msg)
[16:21:04.826]                         }
[16:21:04.826]                       })
[16:21:04.826]                     }
[16:21:04.826]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.826]                     base::options(mc.cores = 1L)
[16:21:04.826]                   }
[16:21:04.826]                   ...future.strategy.old <- future::plan("list")
[16:21:04.826]                   options(future.plan = NULL)
[16:21:04.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.826]                 }
[16:21:04.826]                 ...future.workdir <- getwd()
[16:21:04.826]             }
[16:21:04.826]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.826]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.826]         }
[16:21:04.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.826]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.826]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.826]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.826]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.826]             base::names(...future.oldOptions))
[16:21:04.826]     }
[16:21:04.826]     if (FALSE) {
[16:21:04.826]     }
[16:21:04.826]     else {
[16:21:04.826]         if (TRUE) {
[16:21:04.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.826]                 open = "w")
[16:21:04.826]         }
[16:21:04.826]         else {
[16:21:04.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.826]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.826]         }
[16:21:04.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.826]             base::sink(type = "output", split = FALSE)
[16:21:04.826]             base::close(...future.stdout)
[16:21:04.826]         }, add = TRUE)
[16:21:04.826]     }
[16:21:04.826]     ...future.frame <- base::sys.nframe()
[16:21:04.826]     ...future.conditions <- base::list()
[16:21:04.826]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.826]     if (FALSE) {
[16:21:04.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.826]     }
[16:21:04.826]     ...future.result <- base::tryCatch({
[16:21:04.826]         base::withCallingHandlers({
[16:21:04.826]             ...future.value <- base::withVisible(base::local({
[16:21:04.826]                 withCallingHandlers({
[16:21:04.826]                   1
[16:21:04.826]                 }, immediateCondition = function(cond) {
[16:21:04.826]                   save_rds <- function (object, pathname, ...) 
[16:21:04.826]                   {
[16:21:04.826]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.826]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.826]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.826]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.826]                         fi_tmp[["mtime"]])
[16:21:04.826]                     }
[16:21:04.826]                     tryCatch({
[16:21:04.826]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.826]                     }, error = function(ex) {
[16:21:04.826]                       msg <- conditionMessage(ex)
[16:21:04.826]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.826]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.826]                         fi_tmp[["mtime"]], msg)
[16:21:04.826]                       ex$message <- msg
[16:21:04.826]                       stop(ex)
[16:21:04.826]                     })
[16:21:04.826]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.826]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.826]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.826]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.826]                       fi <- file.info(pathname)
[16:21:04.826]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.826]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.826]                         fi[["size"]], fi[["mtime"]])
[16:21:04.826]                       stop(msg)
[16:21:04.826]                     }
[16:21:04.826]                     invisible(pathname)
[16:21:04.826]                   }
[16:21:04.826]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.826]                     rootPath = tempdir()) 
[16:21:04.826]                   {
[16:21:04.826]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.826]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.826]                       tmpdir = path, fileext = ".rds")
[16:21:04.826]                     save_rds(obj, file)
[16:21:04.826]                   }
[16:21:04.826]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.826]                   {
[16:21:04.826]                     inherits <- base::inherits
[16:21:04.826]                     invokeRestart <- base::invokeRestart
[16:21:04.826]                     is.null <- base::is.null
[16:21:04.826]                     muffled <- FALSE
[16:21:04.826]                     if (inherits(cond, "message")) {
[16:21:04.826]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.826]                       if (muffled) 
[16:21:04.826]                         invokeRestart("muffleMessage")
[16:21:04.826]                     }
[16:21:04.826]                     else if (inherits(cond, "warning")) {
[16:21:04.826]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.826]                       if (muffled) 
[16:21:04.826]                         invokeRestart("muffleWarning")
[16:21:04.826]                     }
[16:21:04.826]                     else if (inherits(cond, "condition")) {
[16:21:04.826]                       if (!is.null(pattern)) {
[16:21:04.826]                         computeRestarts <- base::computeRestarts
[16:21:04.826]                         grepl <- base::grepl
[16:21:04.826]                         restarts <- computeRestarts(cond)
[16:21:04.826]                         for (restart in restarts) {
[16:21:04.826]                           name <- restart$name
[16:21:04.826]                           if (is.null(name)) 
[16:21:04.826]                             next
[16:21:04.826]                           if (!grepl(pattern, name)) 
[16:21:04.826]                             next
[16:21:04.826]                           invokeRestart(restart)
[16:21:04.826]                           muffled <- TRUE
[16:21:04.826]                           break
[16:21:04.826]                         }
[16:21:04.826]                       }
[16:21:04.826]                     }
[16:21:04.826]                     invisible(muffled)
[16:21:04.826]                   }
[16:21:04.826]                   muffleCondition(cond)
[16:21:04.826]                 })
[16:21:04.826]             }))
[16:21:04.826]             future::FutureResult(value = ...future.value$value, 
[16:21:04.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.826]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.826]                     ...future.globalenv.names))
[16:21:04.826]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.826]         }, condition = base::local({
[16:21:04.826]             c <- base::c
[16:21:04.826]             inherits <- base::inherits
[16:21:04.826]             invokeRestart <- base::invokeRestart
[16:21:04.826]             length <- base::length
[16:21:04.826]             list <- base::list
[16:21:04.826]             seq.int <- base::seq.int
[16:21:04.826]             signalCondition <- base::signalCondition
[16:21:04.826]             sys.calls <- base::sys.calls
[16:21:04.826]             `[[` <- base::`[[`
[16:21:04.826]             `+` <- base::`+`
[16:21:04.826]             `<<-` <- base::`<<-`
[16:21:04.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.826]                   3L)]
[16:21:04.826]             }
[16:21:04.826]             function(cond) {
[16:21:04.826]                 is_error <- inherits(cond, "error")
[16:21:04.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.826]                   NULL)
[16:21:04.826]                 if (is_error) {
[16:21:04.826]                   sessionInformation <- function() {
[16:21:04.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.826]                       search = base::search(), system = base::Sys.info())
[16:21:04.826]                   }
[16:21:04.826]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.826]                     cond$call), session = sessionInformation(), 
[16:21:04.826]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.826]                   signalCondition(cond)
[16:21:04.826]                 }
[16:21:04.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.826]                 "immediateCondition"))) {
[16:21:04.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.826]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.826]                   if (TRUE && !signal) {
[16:21:04.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.826]                     {
[16:21:04.826]                       inherits <- base::inherits
[16:21:04.826]                       invokeRestart <- base::invokeRestart
[16:21:04.826]                       is.null <- base::is.null
[16:21:04.826]                       muffled <- FALSE
[16:21:04.826]                       if (inherits(cond, "message")) {
[16:21:04.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.826]                         if (muffled) 
[16:21:04.826]                           invokeRestart("muffleMessage")
[16:21:04.826]                       }
[16:21:04.826]                       else if (inherits(cond, "warning")) {
[16:21:04.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.826]                         if (muffled) 
[16:21:04.826]                           invokeRestart("muffleWarning")
[16:21:04.826]                       }
[16:21:04.826]                       else if (inherits(cond, "condition")) {
[16:21:04.826]                         if (!is.null(pattern)) {
[16:21:04.826]                           computeRestarts <- base::computeRestarts
[16:21:04.826]                           grepl <- base::grepl
[16:21:04.826]                           restarts <- computeRestarts(cond)
[16:21:04.826]                           for (restart in restarts) {
[16:21:04.826]                             name <- restart$name
[16:21:04.826]                             if (is.null(name)) 
[16:21:04.826]                               next
[16:21:04.826]                             if (!grepl(pattern, name)) 
[16:21:04.826]                               next
[16:21:04.826]                             invokeRestart(restart)
[16:21:04.826]                             muffled <- TRUE
[16:21:04.826]                             break
[16:21:04.826]                           }
[16:21:04.826]                         }
[16:21:04.826]                       }
[16:21:04.826]                       invisible(muffled)
[16:21:04.826]                     }
[16:21:04.826]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.826]                   }
[16:21:04.826]                 }
[16:21:04.826]                 else {
[16:21:04.826]                   if (TRUE) {
[16:21:04.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.826]                     {
[16:21:04.826]                       inherits <- base::inherits
[16:21:04.826]                       invokeRestart <- base::invokeRestart
[16:21:04.826]                       is.null <- base::is.null
[16:21:04.826]                       muffled <- FALSE
[16:21:04.826]                       if (inherits(cond, "message")) {
[16:21:04.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.826]                         if (muffled) 
[16:21:04.826]                           invokeRestart("muffleMessage")
[16:21:04.826]                       }
[16:21:04.826]                       else if (inherits(cond, "warning")) {
[16:21:04.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.826]                         if (muffled) 
[16:21:04.826]                           invokeRestart("muffleWarning")
[16:21:04.826]                       }
[16:21:04.826]                       else if (inherits(cond, "condition")) {
[16:21:04.826]                         if (!is.null(pattern)) {
[16:21:04.826]                           computeRestarts <- base::computeRestarts
[16:21:04.826]                           grepl <- base::grepl
[16:21:04.826]                           restarts <- computeRestarts(cond)
[16:21:04.826]                           for (restart in restarts) {
[16:21:04.826]                             name <- restart$name
[16:21:04.826]                             if (is.null(name)) 
[16:21:04.826]                               next
[16:21:04.826]                             if (!grepl(pattern, name)) 
[16:21:04.826]                               next
[16:21:04.826]                             invokeRestart(restart)
[16:21:04.826]                             muffled <- TRUE
[16:21:04.826]                             break
[16:21:04.826]                           }
[16:21:04.826]                         }
[16:21:04.826]                       }
[16:21:04.826]                       invisible(muffled)
[16:21:04.826]                     }
[16:21:04.826]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.826]                   }
[16:21:04.826]                 }
[16:21:04.826]             }
[16:21:04.826]         }))
[16:21:04.826]     }, error = function(ex) {
[16:21:04.826]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.826]                 ...future.rng), started = ...future.startTime, 
[16:21:04.826]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.826]             version = "1.8"), class = "FutureResult")
[16:21:04.826]     }, finally = {
[16:21:04.826]         if (!identical(...future.workdir, getwd())) 
[16:21:04.826]             setwd(...future.workdir)
[16:21:04.826]         {
[16:21:04.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.826]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.826]             }
[16:21:04.826]             base::options(...future.oldOptions)
[16:21:04.826]             if (.Platform$OS.type == "windows") {
[16:21:04.826]                 old_names <- names(...future.oldEnvVars)
[16:21:04.826]                 envs <- base::Sys.getenv()
[16:21:04.826]                 names <- names(envs)
[16:21:04.826]                 common <- intersect(names, old_names)
[16:21:04.826]                 added <- setdiff(names, old_names)
[16:21:04.826]                 removed <- setdiff(old_names, names)
[16:21:04.826]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.826]                   envs[common]]
[16:21:04.826]                 NAMES <- toupper(changed)
[16:21:04.826]                 args <- list()
[16:21:04.826]                 for (kk in seq_along(NAMES)) {
[16:21:04.826]                   name <- changed[[kk]]
[16:21:04.826]                   NAME <- NAMES[[kk]]
[16:21:04.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.826]                     next
[16:21:04.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.826]                 }
[16:21:04.826]                 NAMES <- toupper(added)
[16:21:04.826]                 for (kk in seq_along(NAMES)) {
[16:21:04.826]                   name <- added[[kk]]
[16:21:04.826]                   NAME <- NAMES[[kk]]
[16:21:04.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.826]                     next
[16:21:04.826]                   args[[name]] <- ""
[16:21:04.826]                 }
[16:21:04.826]                 NAMES <- toupper(removed)
[16:21:04.826]                 for (kk in seq_along(NAMES)) {
[16:21:04.826]                   name <- removed[[kk]]
[16:21:04.826]                   NAME <- NAMES[[kk]]
[16:21:04.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.826]                     next
[16:21:04.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.826]                 }
[16:21:04.826]                 if (length(args) > 0) 
[16:21:04.826]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.826]             }
[16:21:04.826]             else {
[16:21:04.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.826]             }
[16:21:04.826]             {
[16:21:04.826]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.826]                   0L) {
[16:21:04.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.826]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.826]                   base::options(opts)
[16:21:04.826]                 }
[16:21:04.826]                 {
[16:21:04.826]                   {
[16:21:04.826]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.826]                     NULL
[16:21:04.826]                   }
[16:21:04.826]                   options(future.plan = NULL)
[16:21:04.826]                   if (is.na(NA_character_)) 
[16:21:04.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.826]                     .init = FALSE)
[16:21:04.826]                 }
[16:21:04.826]             }
[16:21:04.826]         }
[16:21:04.826]     })
[16:21:04.826]     if (TRUE) {
[16:21:04.826]         base::sink(type = "output", split = FALSE)
[16:21:04.826]         if (TRUE) {
[16:21:04.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.826]         }
[16:21:04.826]         else {
[16:21:04.826]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.826]         }
[16:21:04.826]         base::close(...future.stdout)
[16:21:04.826]         ...future.stdout <- NULL
[16:21:04.826]     }
[16:21:04.826]     ...future.result$conditions <- ...future.conditions
[16:21:04.826]     ...future.result$finished <- base::Sys.time()
[16:21:04.826]     ...future.result
[16:21:04.826] }
[16:21:04.829] requestCore(): workers = 2
[16:21:04.831] MulticoreFuture started
[16:21:04.831] - Launch lazy future ... done
[16:21:04.832] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.832] getGlobalsAndPackages() ...
[16:21:04.832] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.833] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.833] List of future strategies:
[16:21:04.833] 1. sequential:
[16:21:04.833]    - args: function (..., envir = parent.frame())
[16:21:04.833]    - tweaked: FALSE
[16:21:04.833]    - call: NULL
[16:21:04.833] plan(): nbrOfWorkers() = 1
[16:21:04.835] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:04.835] Searching for globals ... DONE
[16:21:04.835] Resolving globals: TRUE
[16:21:04.835] Resolving any globals that are futures ...
[16:21:04.835] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:04.835] plan(): Setting new future strategy stack:
[16:21:04.836] List of future strategies:
[16:21:04.836] 1. multicore:
[16:21:04.836]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.836]    - tweaked: FALSE
[16:21:04.836]    - call: plan(strategy)
[16:21:04.836] Resolving any globals that are futures ... DONE
[16:21:04.841] Resolving futures part of globals (recursively) ...
[16:21:04.842] resolve() on list ...
[16:21:04.842]  recursive: 99
[16:21:04.842]  length: 1
[16:21:04.843]  elements: ‘a’
[16:21:04.844] plan(): nbrOfWorkers() = 2
[16:21:04.845] Future #1
[16:21:04.845] result() for MulticoreFuture ...
[16:21:04.846] result() for MulticoreFuture ...
[16:21:04.846] result() for MulticoreFuture ... done
[16:21:04.846] result() for MulticoreFuture ... done
[16:21:04.846] result() for MulticoreFuture ...
[16:21:04.847] result() for MulticoreFuture ... done
[16:21:04.847] A MulticoreFuture was resolved
[16:21:04.847]  length: 0 (resolved future 1)
[16:21:04.847] resolve() on list ... DONE
[16:21:04.847] - globals: [1] ‘a’
[16:21:04.848] Resolving futures part of globals (recursively) ... DONE
[16:21:04.851] The total size of the 1 globals is 1.57 MiB (1647008 bytes)
[16:21:04.851] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:21:04.852] - globals: [1] ‘a’
[16:21:04.852] - packages: [1] ‘future’
[16:21:04.852] getGlobalsAndPackages() ... DONE
[16:21:04.853] run() for ‘Future’ ...
[16:21:04.853] - state: ‘created’
[16:21:04.853] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.858] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.858] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.858]   - Field: ‘label’
[16:21:04.858]   - Field: ‘local’
[16:21:04.858]   - Field: ‘owner’
[16:21:04.858]   - Field: ‘envir’
[16:21:04.858]   - Field: ‘workers’
[16:21:04.858]   - Field: ‘packages’
[16:21:04.859]   - Field: ‘gc’
[16:21:04.859]   - Field: ‘job’
[16:21:04.859]   - Field: ‘conditions’
[16:21:04.859]   - Field: ‘expr’
[16:21:04.859]   - Field: ‘uuid’
[16:21:04.859]   - Field: ‘seed’
[16:21:04.859]   - Field: ‘version’
[16:21:04.859]   - Field: ‘result’
[16:21:04.859]   - Field: ‘asynchronous’
[16:21:04.860]   - Field: ‘calls’
[16:21:04.860]   - Field: ‘globals’
[16:21:04.860]   - Field: ‘stdout’
[16:21:04.860]   - Field: ‘earlySignal’
[16:21:04.860]   - Field: ‘lazy’
[16:21:04.860]   - Field: ‘state’
[16:21:04.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.860] - Launch lazy future ...
[16:21:04.861] Packages needed by the future expression (n = 1): ‘future’
[16:21:04.861] Packages needed by future strategies (n = 0): <none>
[16:21:04.861] {
[16:21:04.861]     {
[16:21:04.861]         {
[16:21:04.861]             ...future.startTime <- base::Sys.time()
[16:21:04.861]             {
[16:21:04.861]                 {
[16:21:04.861]                   {
[16:21:04.861]                     {
[16:21:04.861]                       {
[16:21:04.861]                         base::local({
[16:21:04.861]                           has_future <- base::requireNamespace("future", 
[16:21:04.861]                             quietly = TRUE)
[16:21:04.861]                           if (has_future) {
[16:21:04.861]                             ns <- base::getNamespace("future")
[16:21:04.861]                             version <- ns[[".package"]][["version"]]
[16:21:04.861]                             if (is.null(version)) 
[16:21:04.861]                               version <- utils::packageVersion("future")
[16:21:04.861]                           }
[16:21:04.861]                           else {
[16:21:04.861]                             version <- NULL
[16:21:04.861]                           }
[16:21:04.861]                           if (!has_future || version < "1.8.0") {
[16:21:04.861]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.861]                               "", base::R.version$version.string), 
[16:21:04.861]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:04.861]                                 base::R.version$platform, 8 * 
[16:21:04.861]                                   base::.Machine$sizeof.pointer), 
[16:21:04.861]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.861]                                 "release", "version")], collapse = " "), 
[16:21:04.861]                               hostname = base::Sys.info()[["nodename"]])
[16:21:04.861]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.861]                               info)
[16:21:04.861]                             info <- base::paste(info, collapse = "; ")
[16:21:04.861]                             if (!has_future) {
[16:21:04.861]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.861]                                 info)
[16:21:04.861]                             }
[16:21:04.861]                             else {
[16:21:04.861]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.861]                                 info, version)
[16:21:04.861]                             }
[16:21:04.861]                             base::stop(msg)
[16:21:04.861]                           }
[16:21:04.861]                         })
[16:21:04.861]                       }
[16:21:04.861]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.861]                       base::options(mc.cores = 1L)
[16:21:04.861]                     }
[16:21:04.861]                     base::local({
[16:21:04.861]                       for (pkg in "future") {
[16:21:04.861]                         base::loadNamespace(pkg)
[16:21:04.861]                         base::library(pkg, character.only = TRUE)
[16:21:04.861]                       }
[16:21:04.861]                     })
[16:21:04.861]                   }
[16:21:04.861]                   ...future.strategy.old <- future::plan("list")
[16:21:04.861]                   options(future.plan = NULL)
[16:21:04.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.861]                 }
[16:21:04.861]                 ...future.workdir <- getwd()
[16:21:04.861]             }
[16:21:04.861]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.861]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.861]         }
[16:21:04.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.861]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.861]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.861]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.861]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.861]             base::names(...future.oldOptions))
[16:21:04.861]     }
[16:21:04.861]     if (FALSE) {
[16:21:04.861]     }
[16:21:04.861]     else {
[16:21:04.861]         if (TRUE) {
[16:21:04.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.861]                 open = "w")
[16:21:04.861]         }
[16:21:04.861]         else {
[16:21:04.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.861]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.861]         }
[16:21:04.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.861]             base::sink(type = "output", split = FALSE)
[16:21:04.861]             base::close(...future.stdout)
[16:21:04.861]         }, add = TRUE)
[16:21:04.861]     }
[16:21:04.861]     ...future.frame <- base::sys.nframe()
[16:21:04.861]     ...future.conditions <- base::list()
[16:21:04.861]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.861]     if (FALSE) {
[16:21:04.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.861]     }
[16:21:04.861]     ...future.result <- base::tryCatch({
[16:21:04.861]         base::withCallingHandlers({
[16:21:04.861]             ...future.value <- base::withVisible(base::local({
[16:21:04.861]                 withCallingHandlers({
[16:21:04.861]                   value(a) + 1
[16:21:04.861]                 }, immediateCondition = function(cond) {
[16:21:04.861]                   save_rds <- function (object, pathname, ...) 
[16:21:04.861]                   {
[16:21:04.861]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.861]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.861]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.861]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.861]                         fi_tmp[["mtime"]])
[16:21:04.861]                     }
[16:21:04.861]                     tryCatch({
[16:21:04.861]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.861]                     }, error = function(ex) {
[16:21:04.861]                       msg <- conditionMessage(ex)
[16:21:04.861]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.861]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.861]                         fi_tmp[["mtime"]], msg)
[16:21:04.861]                       ex$message <- msg
[16:21:04.861]                       stop(ex)
[16:21:04.861]                     })
[16:21:04.861]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.861]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.861]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.861]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.861]                       fi <- file.info(pathname)
[16:21:04.861]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.861]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.861]                         fi[["size"]], fi[["mtime"]])
[16:21:04.861]                       stop(msg)
[16:21:04.861]                     }
[16:21:04.861]                     invisible(pathname)
[16:21:04.861]                   }
[16:21:04.861]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.861]                     rootPath = tempdir()) 
[16:21:04.861]                   {
[16:21:04.861]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.861]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.861]                       tmpdir = path, fileext = ".rds")
[16:21:04.861]                     save_rds(obj, file)
[16:21:04.861]                   }
[16:21:04.861]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.861]                   {
[16:21:04.861]                     inherits <- base::inherits
[16:21:04.861]                     invokeRestart <- base::invokeRestart
[16:21:04.861]                     is.null <- base::is.null
[16:21:04.861]                     muffled <- FALSE
[16:21:04.861]                     if (inherits(cond, "message")) {
[16:21:04.861]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.861]                       if (muffled) 
[16:21:04.861]                         invokeRestart("muffleMessage")
[16:21:04.861]                     }
[16:21:04.861]                     else if (inherits(cond, "warning")) {
[16:21:04.861]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.861]                       if (muffled) 
[16:21:04.861]                         invokeRestart("muffleWarning")
[16:21:04.861]                     }
[16:21:04.861]                     else if (inherits(cond, "condition")) {
[16:21:04.861]                       if (!is.null(pattern)) {
[16:21:04.861]                         computeRestarts <- base::computeRestarts
[16:21:04.861]                         grepl <- base::grepl
[16:21:04.861]                         restarts <- computeRestarts(cond)
[16:21:04.861]                         for (restart in restarts) {
[16:21:04.861]                           name <- restart$name
[16:21:04.861]                           if (is.null(name)) 
[16:21:04.861]                             next
[16:21:04.861]                           if (!grepl(pattern, name)) 
[16:21:04.861]                             next
[16:21:04.861]                           invokeRestart(restart)
[16:21:04.861]                           muffled <- TRUE
[16:21:04.861]                           break
[16:21:04.861]                         }
[16:21:04.861]                       }
[16:21:04.861]                     }
[16:21:04.861]                     invisible(muffled)
[16:21:04.861]                   }
[16:21:04.861]                   muffleCondition(cond)
[16:21:04.861]                 })
[16:21:04.861]             }))
[16:21:04.861]             future::FutureResult(value = ...future.value$value, 
[16:21:04.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.861]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.861]                     ...future.globalenv.names))
[16:21:04.861]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.861]         }, condition = base::local({
[16:21:04.861]             c <- base::c
[16:21:04.861]             inherits <- base::inherits
[16:21:04.861]             invokeRestart <- base::invokeRestart
[16:21:04.861]             length <- base::length
[16:21:04.861]             list <- base::list
[16:21:04.861]             seq.int <- base::seq.int
[16:21:04.861]             signalCondition <- base::signalCondition
[16:21:04.861]             sys.calls <- base::sys.calls
[16:21:04.861]             `[[` <- base::`[[`
[16:21:04.861]             `+` <- base::`+`
[16:21:04.861]             `<<-` <- base::`<<-`
[16:21:04.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.861]                   3L)]
[16:21:04.861]             }
[16:21:04.861]             function(cond) {
[16:21:04.861]                 is_error <- inherits(cond, "error")
[16:21:04.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.861]                   NULL)
[16:21:04.861]                 if (is_error) {
[16:21:04.861]                   sessionInformation <- function() {
[16:21:04.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.861]                       search = base::search(), system = base::Sys.info())
[16:21:04.861]                   }
[16:21:04.861]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.861]                     cond$call), session = sessionInformation(), 
[16:21:04.861]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.861]                   signalCondition(cond)
[16:21:04.861]                 }
[16:21:04.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.861]                 "immediateCondition"))) {
[16:21:04.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.861]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.861]                   if (TRUE && !signal) {
[16:21:04.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.861]                     {
[16:21:04.861]                       inherits <- base::inherits
[16:21:04.861]                       invokeRestart <- base::invokeRestart
[16:21:04.861]                       is.null <- base::is.null
[16:21:04.861]                       muffled <- FALSE
[16:21:04.861]                       if (inherits(cond, "message")) {
[16:21:04.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.861]                         if (muffled) 
[16:21:04.861]                           invokeRestart("muffleMessage")
[16:21:04.861]                       }
[16:21:04.861]                       else if (inherits(cond, "warning")) {
[16:21:04.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.861]                         if (muffled) 
[16:21:04.861]                           invokeRestart("muffleWarning")
[16:21:04.861]                       }
[16:21:04.861]                       else if (inherits(cond, "condition")) {
[16:21:04.861]                         if (!is.null(pattern)) {
[16:21:04.861]                           computeRestarts <- base::computeRestarts
[16:21:04.861]                           grepl <- base::grepl
[16:21:04.861]                           restarts <- computeRestarts(cond)
[16:21:04.861]                           for (restart in restarts) {
[16:21:04.861]                             name <- restart$name
[16:21:04.861]                             if (is.null(name)) 
[16:21:04.861]                               next
[16:21:04.861]                             if (!grepl(pattern, name)) 
[16:21:04.861]                               next
[16:21:04.861]                             invokeRestart(restart)
[16:21:04.861]                             muffled <- TRUE
[16:21:04.861]                             break
[16:21:04.861]                           }
[16:21:04.861]                         }
[16:21:04.861]                       }
[16:21:04.861]                       invisible(muffled)
[16:21:04.861]                     }
[16:21:04.861]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.861]                   }
[16:21:04.861]                 }
[16:21:04.861]                 else {
[16:21:04.861]                   if (TRUE) {
[16:21:04.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.861]                     {
[16:21:04.861]                       inherits <- base::inherits
[16:21:04.861]                       invokeRestart <- base::invokeRestart
[16:21:04.861]                       is.null <- base::is.null
[16:21:04.861]                       muffled <- FALSE
[16:21:04.861]                       if (inherits(cond, "message")) {
[16:21:04.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.861]                         if (muffled) 
[16:21:04.861]                           invokeRestart("muffleMessage")
[16:21:04.861]                       }
[16:21:04.861]                       else if (inherits(cond, "warning")) {
[16:21:04.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.861]                         if (muffled) 
[16:21:04.861]                           invokeRestart("muffleWarning")
[16:21:04.861]                       }
[16:21:04.861]                       else if (inherits(cond, "condition")) {
[16:21:04.861]                         if (!is.null(pattern)) {
[16:21:04.861]                           computeRestarts <- base::computeRestarts
[16:21:04.861]                           grepl <- base::grepl
[16:21:04.861]                           restarts <- computeRestarts(cond)
[16:21:04.861]                           for (restart in restarts) {
[16:21:04.861]                             name <- restart$name
[16:21:04.861]                             if (is.null(name)) 
[16:21:04.861]                               next
[16:21:04.861]                             if (!grepl(pattern, name)) 
[16:21:04.861]                               next
[16:21:04.861]                             invokeRestart(restart)
[16:21:04.861]                             muffled <- TRUE
[16:21:04.861]                             break
[16:21:04.861]                           }
[16:21:04.861]                         }
[16:21:04.861]                       }
[16:21:04.861]                       invisible(muffled)
[16:21:04.861]                     }
[16:21:04.861]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.861]                   }
[16:21:04.861]                 }
[16:21:04.861]             }
[16:21:04.861]         }))
[16:21:04.861]     }, error = function(ex) {
[16:21:04.861]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.861]                 ...future.rng), started = ...future.startTime, 
[16:21:04.861]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.861]             version = "1.8"), class = "FutureResult")
[16:21:04.861]     }, finally = {
[16:21:04.861]         if (!identical(...future.workdir, getwd())) 
[16:21:04.861]             setwd(...future.workdir)
[16:21:04.861]         {
[16:21:04.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.861]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.861]             }
[16:21:04.861]             base::options(...future.oldOptions)
[16:21:04.861]             if (.Platform$OS.type == "windows") {
[16:21:04.861]                 old_names <- names(...future.oldEnvVars)
[16:21:04.861]                 envs <- base::Sys.getenv()
[16:21:04.861]                 names <- names(envs)
[16:21:04.861]                 common <- intersect(names, old_names)
[16:21:04.861]                 added <- setdiff(names, old_names)
[16:21:04.861]                 removed <- setdiff(old_names, names)
[16:21:04.861]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.861]                   envs[common]]
[16:21:04.861]                 NAMES <- toupper(changed)
[16:21:04.861]                 args <- list()
[16:21:04.861]                 for (kk in seq_along(NAMES)) {
[16:21:04.861]                   name <- changed[[kk]]
[16:21:04.861]                   NAME <- NAMES[[kk]]
[16:21:04.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.861]                     next
[16:21:04.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.861]                 }
[16:21:04.861]                 NAMES <- toupper(added)
[16:21:04.861]                 for (kk in seq_along(NAMES)) {
[16:21:04.861]                   name <- added[[kk]]
[16:21:04.861]                   NAME <- NAMES[[kk]]
[16:21:04.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.861]                     next
[16:21:04.861]                   args[[name]] <- ""
[16:21:04.861]                 }
[16:21:04.861]                 NAMES <- toupper(removed)
[16:21:04.861]                 for (kk in seq_along(NAMES)) {
[16:21:04.861]                   name <- removed[[kk]]
[16:21:04.861]                   NAME <- NAMES[[kk]]
[16:21:04.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.861]                     next
[16:21:04.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.861]                 }
[16:21:04.861]                 if (length(args) > 0) 
[16:21:04.861]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.861]             }
[16:21:04.861]             else {
[16:21:04.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.861]             }
[16:21:04.861]             {
[16:21:04.861]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.861]                   0L) {
[16:21:04.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.861]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.861]                   base::options(opts)
[16:21:04.861]                 }
[16:21:04.861]                 {
[16:21:04.861]                   {
[16:21:04.861]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.861]                     NULL
[16:21:04.861]                   }
[16:21:04.861]                   options(future.plan = NULL)
[16:21:04.861]                   if (is.na(NA_character_)) 
[16:21:04.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.861]                     .init = FALSE)
[16:21:04.861]                 }
[16:21:04.861]             }
[16:21:04.861]         }
[16:21:04.861]     })
[16:21:04.861]     if (TRUE) {
[16:21:04.861]         base::sink(type = "output", split = FALSE)
[16:21:04.861]         if (TRUE) {
[16:21:04.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.861]         }
[16:21:04.861]         else {
[16:21:04.861]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.861]         }
[16:21:04.861]         base::close(...future.stdout)
[16:21:04.861]         ...future.stdout <- NULL
[16:21:04.861]     }
[16:21:04.861]     ...future.result$conditions <- ...future.conditions
[16:21:04.861]     ...future.result$finished <- base::Sys.time()
[16:21:04.861]     ...future.result
[16:21:04.861] }
[16:21:04.864] assign_globals() ...
[16:21:04.864] List of 1
[16:21:04.864]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x562228245c70> 
[16:21:04.864]  - attr(*, "where")=List of 1
[16:21:04.864]   ..$ a:<environment: R_EmptyEnv> 
[16:21:04.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.864]  - attr(*, "resolved")= logi TRUE
[16:21:04.864]  - attr(*, "total_size")= num 1647008
[16:21:04.864]  - attr(*, "already-done")= logi TRUE
[16:21:04.867] - copied ‘a’ to environment
[16:21:04.867] assign_globals() ... done
[16:21:04.867] requestCore(): workers = 2
[16:21:04.870] MulticoreFuture started
[16:21:04.870] - Launch lazy future ... done
[16:21:04.870] run() for ‘MulticoreFuture’ ... done
[16:21:04.870] result() for MulticoreFuture ...
[16:21:04.871] plan(): Setting new future strategy stack:
[16:21:04.871] List of future strategies:
[16:21:04.871] 1. sequential:
[16:21:04.871]    - args: function (..., envir = parent.frame())
[16:21:04.871]    - tweaked: FALSE
[16:21:04.871]    - call: NULL
[16:21:04.872] plan(): nbrOfWorkers() = 1
[16:21:04.876] plan(): Setting new future strategy stack:
[16:21:04.876] List of future strategies:
[16:21:04.876] 1. multicore:
[16:21:04.876]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.876]    - tweaked: FALSE
[16:21:04.876]    - call: plan(strategy)
[16:21:04.881] plan(): nbrOfWorkers() = 2
[16:21:04.882] result() for MulticoreFuture ...
[16:21:04.883] result() for MulticoreFuture ... done
[16:21:04.883] signalConditions() ...
[16:21:04.883]  - include = ‘immediateCondition’
[16:21:04.883]  - exclude = 
[16:21:04.883]  - resignal = FALSE
[16:21:04.883]  - Number of conditions: 4
[16:21:04.884] signalConditions() ... done
[16:21:04.884] result() for MulticoreFuture ... done
[16:21:04.884] result() for MulticoreFuture ...
[16:21:04.884] result() for MulticoreFuture ... done
[16:21:04.884] signalConditions() ...
[16:21:04.884]  - include = ‘immediateCondition’
[16:21:04.885]  - exclude = 
[16:21:04.885]  - resignal = FALSE
[16:21:04.885]  - Number of conditions: 4
[16:21:04.885] signalConditions() ... done
[16:21:04.885] Future state: ‘finished’
[16:21:04.885] result() for MulticoreFuture ...
[16:21:04.886] result() for MulticoreFuture ... done
[16:21:04.886] signalConditions() ...
[16:21:04.886]  - include = ‘condition’
[16:21:04.886]  - exclude = ‘immediateCondition’
[16:21:04.886]  - resignal = TRUE
[16:21:04.886]  - Number of conditions: 4
[16:21:04.886]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.874] result() for MulticoreFuture ...
[16:21:04.886]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.874] result() for MulticoreFuture ... done
[16:21:04.887]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.874] result() for MulticoreFuture ...
[16:21:04.887]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.875] result() for MulticoreFuture ... done
[16:21:04.887] signalConditions() ... done
value(b) = 2
[16:21:04.887] result() for MulticoreFuture ...
[16:21:04.887] result() for MulticoreFuture ... done
[16:21:04.888] result() for MulticoreFuture ...
[16:21:04.888] result() for MulticoreFuture ... done
[16:21:04.888] signalConditions() ...
[16:21:04.888]  - include = ‘immediateCondition’
[16:21:04.888]  - exclude = 
[16:21:04.888]  - resignal = FALSE
[16:21:04.888]  - Number of conditions: 4
[16:21:04.888] signalConditions() ... done
[16:21:04.888] Future state: ‘finished’
[16:21:04.889] result() for MulticoreFuture ...
[16:21:04.889] result() for MulticoreFuture ... done
[16:21:04.889] signalConditions() ...
[16:21:04.889]  - include = ‘condition’
[16:21:04.889]  - exclude = ‘immediateCondition’
[16:21:04.889]  - resignal = TRUE
[16:21:04.889]  - Number of conditions: 4
[16:21:04.889]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.874] result() for MulticoreFuture ...
[16:21:04.890]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.874] result() for MulticoreFuture ... done
[16:21:04.890]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.874] result() for MulticoreFuture ...
[16:21:04.890]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.875] result() for MulticoreFuture ... done
[16:21:04.890] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.890] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.891] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.891] 
[16:21:04.891] Searching for globals ... DONE
[16:21:04.892] - globals: [0] <none>
[16:21:04.892] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.892] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.895] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.897] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:04.897] Searching for globals ... DONE
[16:21:04.897] Resolving globals: TRUE
[16:21:04.897] Resolving any globals that are futures ...
[16:21:04.897] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:04.897] Resolving any globals that are futures ... DONE
[16:21:04.898] Resolving futures part of globals (recursively) ...
[16:21:04.898] resolve() on list ...
[16:21:04.898]  recursive: 99
[16:21:04.899]  length: 1
[16:21:04.899]  elements: ‘a’
[16:21:04.899] run() for ‘Future’ ...
[16:21:04.899] - state: ‘created’
[16:21:04.899] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.904] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.904]   - Field: ‘label’
[16:21:04.904]   - Field: ‘local’
[16:21:04.904]   - Field: ‘owner’
[16:21:04.904]   - Field: ‘envir’
[16:21:04.905]   - Field: ‘workers’
[16:21:04.905]   - Field: ‘packages’
[16:21:04.905]   - Field: ‘gc’
[16:21:04.905]   - Field: ‘job’
[16:21:04.905]   - Field: ‘conditions’
[16:21:04.905]   - Field: ‘expr’
[16:21:04.905]   - Field: ‘uuid’
[16:21:04.906]   - Field: ‘seed’
[16:21:04.906]   - Field: ‘version’
[16:21:04.906]   - Field: ‘result’
[16:21:04.906]   - Field: ‘asynchronous’
[16:21:04.906]   - Field: ‘calls’
[16:21:04.906]   - Field: ‘globals’
[16:21:04.906]   - Field: ‘stdout’
[16:21:04.907]   - Field: ‘earlySignal’
[16:21:04.907]   - Field: ‘lazy’
[16:21:04.907]   - Field: ‘state’
[16:21:04.907] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.907] - Launch lazy future ...
[16:21:04.907] Packages needed by the future expression (n = 0): <none>
[16:21:04.908] Packages needed by future strategies (n = 0): <none>
[16:21:04.908] {
[16:21:04.908]     {
[16:21:04.908]         {
[16:21:04.908]             ...future.startTime <- base::Sys.time()
[16:21:04.908]             {
[16:21:04.908]                 {
[16:21:04.908]                   {
[16:21:04.908]                     {
[16:21:04.908]                       base::local({
[16:21:04.908]                         has_future <- base::requireNamespace("future", 
[16:21:04.908]                           quietly = TRUE)
[16:21:04.908]                         if (has_future) {
[16:21:04.908]                           ns <- base::getNamespace("future")
[16:21:04.908]                           version <- ns[[".package"]][["version"]]
[16:21:04.908]                           if (is.null(version)) 
[16:21:04.908]                             version <- utils::packageVersion("future")
[16:21:04.908]                         }
[16:21:04.908]                         else {
[16:21:04.908]                           version <- NULL
[16:21:04.908]                         }
[16:21:04.908]                         if (!has_future || version < "1.8.0") {
[16:21:04.908]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.908]                             "", base::R.version$version.string), 
[16:21:04.908]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:04.908]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:04.908]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.908]                               "release", "version")], collapse = " "), 
[16:21:04.908]                             hostname = base::Sys.info()[["nodename"]])
[16:21:04.908]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.908]                             info)
[16:21:04.908]                           info <- base::paste(info, collapse = "; ")
[16:21:04.908]                           if (!has_future) {
[16:21:04.908]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.908]                               info)
[16:21:04.908]                           }
[16:21:04.908]                           else {
[16:21:04.908]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.908]                               info, version)
[16:21:04.908]                           }
[16:21:04.908]                           base::stop(msg)
[16:21:04.908]                         }
[16:21:04.908]                       })
[16:21:04.908]                     }
[16:21:04.908]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.908]                     base::options(mc.cores = 1L)
[16:21:04.908]                   }
[16:21:04.908]                   ...future.strategy.old <- future::plan("list")
[16:21:04.908]                   options(future.plan = NULL)
[16:21:04.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.908]                 }
[16:21:04.908]                 ...future.workdir <- getwd()
[16:21:04.908]             }
[16:21:04.908]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.908]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.908]         }
[16:21:04.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.908]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.908]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.908]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.908]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.908]             base::names(...future.oldOptions))
[16:21:04.908]     }
[16:21:04.908]     if (FALSE) {
[16:21:04.908]     }
[16:21:04.908]     else {
[16:21:04.908]         if (TRUE) {
[16:21:04.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.908]                 open = "w")
[16:21:04.908]         }
[16:21:04.908]         else {
[16:21:04.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.908]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.908]         }
[16:21:04.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.908]             base::sink(type = "output", split = FALSE)
[16:21:04.908]             base::close(...future.stdout)
[16:21:04.908]         }, add = TRUE)
[16:21:04.908]     }
[16:21:04.908]     ...future.frame <- base::sys.nframe()
[16:21:04.908]     ...future.conditions <- base::list()
[16:21:04.908]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.908]     if (FALSE) {
[16:21:04.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.908]     }
[16:21:04.908]     ...future.result <- base::tryCatch({
[16:21:04.908]         base::withCallingHandlers({
[16:21:04.908]             ...future.value <- base::withVisible(base::local({
[16:21:04.908]                 withCallingHandlers({
[16:21:04.908]                   1
[16:21:04.908]                 }, immediateCondition = function(cond) {
[16:21:04.908]                   save_rds <- function (object, pathname, ...) 
[16:21:04.908]                   {
[16:21:04.908]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.908]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.908]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.908]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.908]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.908]                         fi_tmp[["mtime"]])
[16:21:04.908]                     }
[16:21:04.908]                     tryCatch({
[16:21:04.908]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.908]                     }, error = function(ex) {
[16:21:04.908]                       msg <- conditionMessage(ex)
[16:21:04.908]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.908]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.908]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.908]                         fi_tmp[["mtime"]], msg)
[16:21:04.908]                       ex$message <- msg
[16:21:04.908]                       stop(ex)
[16:21:04.908]                     })
[16:21:04.908]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.908]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.908]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.908]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.908]                       fi <- file.info(pathname)
[16:21:04.908]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.908]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.908]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.908]                         fi[["size"]], fi[["mtime"]])
[16:21:04.908]                       stop(msg)
[16:21:04.908]                     }
[16:21:04.908]                     invisible(pathname)
[16:21:04.908]                   }
[16:21:04.908]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.908]                     rootPath = tempdir()) 
[16:21:04.908]                   {
[16:21:04.908]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.908]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.908]                       tmpdir = path, fileext = ".rds")
[16:21:04.908]                     save_rds(obj, file)
[16:21:04.908]                   }
[16:21:04.908]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.908]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.908]                   {
[16:21:04.908]                     inherits <- base::inherits
[16:21:04.908]                     invokeRestart <- base::invokeRestart
[16:21:04.908]                     is.null <- base::is.null
[16:21:04.908]                     muffled <- FALSE
[16:21:04.908]                     if (inherits(cond, "message")) {
[16:21:04.908]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.908]                       if (muffled) 
[16:21:04.908]                         invokeRestart("muffleMessage")
[16:21:04.908]                     }
[16:21:04.908]                     else if (inherits(cond, "warning")) {
[16:21:04.908]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.908]                       if (muffled) 
[16:21:04.908]                         invokeRestart("muffleWarning")
[16:21:04.908]                     }
[16:21:04.908]                     else if (inherits(cond, "condition")) {
[16:21:04.908]                       if (!is.null(pattern)) {
[16:21:04.908]                         computeRestarts <- base::computeRestarts
[16:21:04.908]                         grepl <- base::grepl
[16:21:04.908]                         restarts <- computeRestarts(cond)
[16:21:04.908]                         for (restart in restarts) {
[16:21:04.908]                           name <- restart$name
[16:21:04.908]                           if (is.null(name)) 
[16:21:04.908]                             next
[16:21:04.908]                           if (!grepl(pattern, name)) 
[16:21:04.908]                             next
[16:21:04.908]                           invokeRestart(restart)
[16:21:04.908]                           muffled <- TRUE
[16:21:04.908]                           break
[16:21:04.908]                         }
[16:21:04.908]                       }
[16:21:04.908]                     }
[16:21:04.908]                     invisible(muffled)
[16:21:04.908]                   }
[16:21:04.908]                   muffleCondition(cond)
[16:21:04.908]                 })
[16:21:04.908]             }))
[16:21:04.908]             future::FutureResult(value = ...future.value$value, 
[16:21:04.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.908]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.908]                     ...future.globalenv.names))
[16:21:04.908]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.908]         }, condition = base::local({
[16:21:04.908]             c <- base::c
[16:21:04.908]             inherits <- base::inherits
[16:21:04.908]             invokeRestart <- base::invokeRestart
[16:21:04.908]             length <- base::length
[16:21:04.908]             list <- base::list
[16:21:04.908]             seq.int <- base::seq.int
[16:21:04.908]             signalCondition <- base::signalCondition
[16:21:04.908]             sys.calls <- base::sys.calls
[16:21:04.908]             `[[` <- base::`[[`
[16:21:04.908]             `+` <- base::`+`
[16:21:04.908]             `<<-` <- base::`<<-`
[16:21:04.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.908]                   3L)]
[16:21:04.908]             }
[16:21:04.908]             function(cond) {
[16:21:04.908]                 is_error <- inherits(cond, "error")
[16:21:04.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.908]                   NULL)
[16:21:04.908]                 if (is_error) {
[16:21:04.908]                   sessionInformation <- function() {
[16:21:04.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.908]                       search = base::search(), system = base::Sys.info())
[16:21:04.908]                   }
[16:21:04.908]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.908]                     cond$call), session = sessionInformation(), 
[16:21:04.908]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.908]                   signalCondition(cond)
[16:21:04.908]                 }
[16:21:04.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.908]                 "immediateCondition"))) {
[16:21:04.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.908]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.908]                   if (TRUE && !signal) {
[16:21:04.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.908]                     {
[16:21:04.908]                       inherits <- base::inherits
[16:21:04.908]                       invokeRestart <- base::invokeRestart
[16:21:04.908]                       is.null <- base::is.null
[16:21:04.908]                       muffled <- FALSE
[16:21:04.908]                       if (inherits(cond, "message")) {
[16:21:04.908]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.908]                         if (muffled) 
[16:21:04.908]                           invokeRestart("muffleMessage")
[16:21:04.908]                       }
[16:21:04.908]                       else if (inherits(cond, "warning")) {
[16:21:04.908]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.908]                         if (muffled) 
[16:21:04.908]                           invokeRestart("muffleWarning")
[16:21:04.908]                       }
[16:21:04.908]                       else if (inherits(cond, "condition")) {
[16:21:04.908]                         if (!is.null(pattern)) {
[16:21:04.908]                           computeRestarts <- base::computeRestarts
[16:21:04.908]                           grepl <- base::grepl
[16:21:04.908]                           restarts <- computeRestarts(cond)
[16:21:04.908]                           for (restart in restarts) {
[16:21:04.908]                             name <- restart$name
[16:21:04.908]                             if (is.null(name)) 
[16:21:04.908]                               next
[16:21:04.908]                             if (!grepl(pattern, name)) 
[16:21:04.908]                               next
[16:21:04.908]                             invokeRestart(restart)
[16:21:04.908]                             muffled <- TRUE
[16:21:04.908]                             break
[16:21:04.908]                           }
[16:21:04.908]                         }
[16:21:04.908]                       }
[16:21:04.908]                       invisible(muffled)
[16:21:04.908]                     }
[16:21:04.908]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.908]                   }
[16:21:04.908]                 }
[16:21:04.908]                 else {
[16:21:04.908]                   if (TRUE) {
[16:21:04.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.908]                     {
[16:21:04.908]                       inherits <- base::inherits
[16:21:04.908]                       invokeRestart <- base::invokeRestart
[16:21:04.908]                       is.null <- base::is.null
[16:21:04.908]                       muffled <- FALSE
[16:21:04.908]                       if (inherits(cond, "message")) {
[16:21:04.908]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.908]                         if (muffled) 
[16:21:04.908]                           invokeRestart("muffleMessage")
[16:21:04.908]                       }
[16:21:04.908]                       else if (inherits(cond, "warning")) {
[16:21:04.908]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.908]                         if (muffled) 
[16:21:04.908]                           invokeRestart("muffleWarning")
[16:21:04.908]                       }
[16:21:04.908]                       else if (inherits(cond, "condition")) {
[16:21:04.908]                         if (!is.null(pattern)) {
[16:21:04.908]                           computeRestarts <- base::computeRestarts
[16:21:04.908]                           grepl <- base::grepl
[16:21:04.908]                           restarts <- computeRestarts(cond)
[16:21:04.908]                           for (restart in restarts) {
[16:21:04.908]                             name <- restart$name
[16:21:04.908]                             if (is.null(name)) 
[16:21:04.908]                               next
[16:21:04.908]                             if (!grepl(pattern, name)) 
[16:21:04.908]                               next
[16:21:04.908]                             invokeRestart(restart)
[16:21:04.908]                             muffled <- TRUE
[16:21:04.908]                             break
[16:21:04.908]                           }
[16:21:04.908]                         }
[16:21:04.908]                       }
[16:21:04.908]                       invisible(muffled)
[16:21:04.908]                     }
[16:21:04.908]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.908]                   }
[16:21:04.908]                 }
[16:21:04.908]             }
[16:21:04.908]         }))
[16:21:04.908]     }, error = function(ex) {
[16:21:04.908]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.908]                 ...future.rng), started = ...future.startTime, 
[16:21:04.908]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.908]             version = "1.8"), class = "FutureResult")
[16:21:04.908]     }, finally = {
[16:21:04.908]         if (!identical(...future.workdir, getwd())) 
[16:21:04.908]             setwd(...future.workdir)
[16:21:04.908]         {
[16:21:04.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.908]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.908]             }
[16:21:04.908]             base::options(...future.oldOptions)
[16:21:04.908]             if (.Platform$OS.type == "windows") {
[16:21:04.908]                 old_names <- names(...future.oldEnvVars)
[16:21:04.908]                 envs <- base::Sys.getenv()
[16:21:04.908]                 names <- names(envs)
[16:21:04.908]                 common <- intersect(names, old_names)
[16:21:04.908]                 added <- setdiff(names, old_names)
[16:21:04.908]                 removed <- setdiff(old_names, names)
[16:21:04.908]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.908]                   envs[common]]
[16:21:04.908]                 NAMES <- toupper(changed)
[16:21:04.908]                 args <- list()
[16:21:04.908]                 for (kk in seq_along(NAMES)) {
[16:21:04.908]                   name <- changed[[kk]]
[16:21:04.908]                   NAME <- NAMES[[kk]]
[16:21:04.908]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.908]                     next
[16:21:04.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.908]                 }
[16:21:04.908]                 NAMES <- toupper(added)
[16:21:04.908]                 for (kk in seq_along(NAMES)) {
[16:21:04.908]                   name <- added[[kk]]
[16:21:04.908]                   NAME <- NAMES[[kk]]
[16:21:04.908]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.908]                     next
[16:21:04.908]                   args[[name]] <- ""
[16:21:04.908]                 }
[16:21:04.908]                 NAMES <- toupper(removed)
[16:21:04.908]                 for (kk in seq_along(NAMES)) {
[16:21:04.908]                   name <- removed[[kk]]
[16:21:04.908]                   NAME <- NAMES[[kk]]
[16:21:04.908]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.908]                     next
[16:21:04.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.908]                 }
[16:21:04.908]                 if (length(args) > 0) 
[16:21:04.908]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.908]             }
[16:21:04.908]             else {
[16:21:04.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.908]             }
[16:21:04.908]             {
[16:21:04.908]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.908]                   0L) {
[16:21:04.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.908]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.908]                   base::options(opts)
[16:21:04.908]                 }
[16:21:04.908]                 {
[16:21:04.908]                   {
[16:21:04.908]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.908]                     NULL
[16:21:04.908]                   }
[16:21:04.908]                   options(future.plan = NULL)
[16:21:04.908]                   if (is.na(NA_character_)) 
[16:21:04.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.908]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.908]                     .init = FALSE)
[16:21:04.908]                 }
[16:21:04.908]             }
[16:21:04.908]         }
[16:21:04.908]     })
[16:21:04.908]     if (TRUE) {
[16:21:04.908]         base::sink(type = "output", split = FALSE)
[16:21:04.908]         if (TRUE) {
[16:21:04.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.908]         }
[16:21:04.908]         else {
[16:21:04.908]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.908]         }
[16:21:04.908]         base::close(...future.stdout)
[16:21:04.908]         ...future.stdout <- NULL
[16:21:04.908]     }
[16:21:04.908]     ...future.result$conditions <- ...future.conditions
[16:21:04.908]     ...future.result$finished <- base::Sys.time()
[16:21:04.908]     ...future.result
[16:21:04.908] }
[16:21:04.911] requestCore(): workers = 2
[16:21:04.913] MulticoreFuture started
[16:21:04.913] - Launch lazy future ... done
[16:21:04.914] run() for ‘MulticoreFuture’ ... done
[16:21:04.914] plan(): Setting new future strategy stack:
[16:21:04.914] List of future strategies:
[16:21:04.914] 1. sequential:
[16:21:04.914]    - args: function (..., envir = parent.frame())
[16:21:04.914]    - tweaked: FALSE
[16:21:04.914]    - call: NULL
[16:21:04.915] plan(): nbrOfWorkers() = 1
[16:21:04.918] plan(): Setting new future strategy stack:
[16:21:04.918] List of future strategies:
[16:21:04.918] 1. multicore:
[16:21:04.918]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.918]    - tweaked: FALSE
[16:21:04.918]    - call: plan(strategy)
[16:21:04.925] plan(): nbrOfWorkers() = 2
[16:21:04.935] Future #1
[16:21:04.935] result() for MulticoreFuture ...
[16:21:04.936] result() for MulticoreFuture ...
[16:21:04.936] result() for MulticoreFuture ... done
[16:21:04.937] result() for MulticoreFuture ... done
[16:21:04.937] result() for MulticoreFuture ...
[16:21:04.937] result() for MulticoreFuture ... done
[16:21:04.937] A MulticoreFuture was resolved
[16:21:04.937]  length: 0 (resolved future 1)
[16:21:04.937] resolve() on list ... DONE
[16:21:04.938] - globals: [1] ‘a’
[16:21:04.938] Resolving futures part of globals (recursively) ... DONE
[16:21:04.941] The total size of the 1 globals is 1.57 MiB (1647176 bytes)
[16:21:04.941] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:21:04.942] - globals: [1] ‘a’
[16:21:04.942] - packages: [1] ‘future’
[16:21:04.942] getGlobalsAndPackages() ... DONE
[16:21:04.942] run() for ‘Future’ ...
[16:21:04.942] - state: ‘created’
[16:21:04.943] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.947] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.947]   - Field: ‘label’
[16:21:04.947]   - Field: ‘local’
[16:21:04.947]   - Field: ‘owner’
[16:21:04.948]   - Field: ‘envir’
[16:21:04.948]   - Field: ‘workers’
[16:21:04.948]   - Field: ‘packages’
[16:21:04.948]   - Field: ‘gc’
[16:21:04.948]   - Field: ‘job’
[16:21:04.948]   - Field: ‘conditions’
[16:21:04.948]   - Field: ‘expr’
[16:21:04.948]   - Field: ‘uuid’
[16:21:04.949]   - Field: ‘seed’
[16:21:04.949]   - Field: ‘version’
[16:21:04.949]   - Field: ‘result’
[16:21:04.949]   - Field: ‘asynchronous’
[16:21:04.949]   - Field: ‘calls’
[16:21:04.949]   - Field: ‘globals’
[16:21:04.949]   - Field: ‘stdout’
[16:21:04.949]   - Field: ‘earlySignal’
[16:21:04.949]   - Field: ‘lazy’
[16:21:04.950]   - Field: ‘state’
[16:21:04.950] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:04.950] - Launch lazy future ...
[16:21:04.950] Packages needed by the future expression (n = 1): ‘future’
[16:21:04.950] Packages needed by future strategies (n = 0): <none>
[16:21:04.951] {
[16:21:04.951]     {
[16:21:04.951]         {
[16:21:04.951]             ...future.startTime <- base::Sys.time()
[16:21:04.951]             {
[16:21:04.951]                 {
[16:21:04.951]                   {
[16:21:04.951]                     {
[16:21:04.951]                       {
[16:21:04.951]                         base::local({
[16:21:04.951]                           has_future <- base::requireNamespace("future", 
[16:21:04.951]                             quietly = TRUE)
[16:21:04.951]                           if (has_future) {
[16:21:04.951]                             ns <- base::getNamespace("future")
[16:21:04.951]                             version <- ns[[".package"]][["version"]]
[16:21:04.951]                             if (is.null(version)) 
[16:21:04.951]                               version <- utils::packageVersion("future")
[16:21:04.951]                           }
[16:21:04.951]                           else {
[16:21:04.951]                             version <- NULL
[16:21:04.951]                           }
[16:21:04.951]                           if (!has_future || version < "1.8.0") {
[16:21:04.951]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:04.951]                               "", base::R.version$version.string), 
[16:21:04.951]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:04.951]                                 base::R.version$platform, 8 * 
[16:21:04.951]                                   base::.Machine$sizeof.pointer), 
[16:21:04.951]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:04.951]                                 "release", "version")], collapse = " "), 
[16:21:04.951]                               hostname = base::Sys.info()[["nodename"]])
[16:21:04.951]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:04.951]                               info)
[16:21:04.951]                             info <- base::paste(info, collapse = "; ")
[16:21:04.951]                             if (!has_future) {
[16:21:04.951]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:04.951]                                 info)
[16:21:04.951]                             }
[16:21:04.951]                             else {
[16:21:04.951]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:04.951]                                 info, version)
[16:21:04.951]                             }
[16:21:04.951]                             base::stop(msg)
[16:21:04.951]                           }
[16:21:04.951]                         })
[16:21:04.951]                       }
[16:21:04.951]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:04.951]                       base::options(mc.cores = 1L)
[16:21:04.951]                     }
[16:21:04.951]                     base::local({
[16:21:04.951]                       for (pkg in "future") {
[16:21:04.951]                         base::loadNamespace(pkg)
[16:21:04.951]                         base::library(pkg, character.only = TRUE)
[16:21:04.951]                       }
[16:21:04.951]                     })
[16:21:04.951]                   }
[16:21:04.951]                   ...future.strategy.old <- future::plan("list")
[16:21:04.951]                   options(future.plan = NULL)
[16:21:04.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:04.951]                 }
[16:21:04.951]                 ...future.workdir <- getwd()
[16:21:04.951]             }
[16:21:04.951]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:04.951]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:04.951]         }
[16:21:04.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:04.951]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:04.951]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:04.951]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:04.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:04.951]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:04.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:04.951]             base::names(...future.oldOptions))
[16:21:04.951]     }
[16:21:04.951]     if (FALSE) {
[16:21:04.951]     }
[16:21:04.951]     else {
[16:21:04.951]         if (TRUE) {
[16:21:04.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:04.951]                 open = "w")
[16:21:04.951]         }
[16:21:04.951]         else {
[16:21:04.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:04.951]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:04.951]         }
[16:21:04.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:04.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:04.951]             base::sink(type = "output", split = FALSE)
[16:21:04.951]             base::close(...future.stdout)
[16:21:04.951]         }, add = TRUE)
[16:21:04.951]     }
[16:21:04.951]     ...future.frame <- base::sys.nframe()
[16:21:04.951]     ...future.conditions <- base::list()
[16:21:04.951]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:04.951]     if (FALSE) {
[16:21:04.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:04.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:04.951]     }
[16:21:04.951]     ...future.result <- base::tryCatch({
[16:21:04.951]         base::withCallingHandlers({
[16:21:04.951]             ...future.value <- base::withVisible(base::local({
[16:21:04.951]                 withCallingHandlers({
[16:21:04.951]                   value(a) + 1
[16:21:04.951]                 }, immediateCondition = function(cond) {
[16:21:04.951]                   save_rds <- function (object, pathname, ...) 
[16:21:04.951]                   {
[16:21:04.951]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:04.951]                     if (file_test("-f", pathname_tmp)) {
[16:21:04.951]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.951]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:04.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.951]                         fi_tmp[["mtime"]])
[16:21:04.951]                     }
[16:21:04.951]                     tryCatch({
[16:21:04.951]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:04.951]                     }, error = function(ex) {
[16:21:04.951]                       msg <- conditionMessage(ex)
[16:21:04.951]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.951]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:04.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.951]                         fi_tmp[["mtime"]], msg)
[16:21:04.951]                       ex$message <- msg
[16:21:04.951]                       stop(ex)
[16:21:04.951]                     })
[16:21:04.951]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:04.951]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:04.951]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:04.951]                       fi_tmp <- file.info(pathname_tmp)
[16:21:04.951]                       fi <- file.info(pathname)
[16:21:04.951]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:04.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:04.951]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:04.951]                         fi[["size"]], fi[["mtime"]])
[16:21:04.951]                       stop(msg)
[16:21:04.951]                     }
[16:21:04.951]                     invisible(pathname)
[16:21:04.951]                   }
[16:21:04.951]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:04.951]                     rootPath = tempdir()) 
[16:21:04.951]                   {
[16:21:04.951]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:04.951]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:04.951]                       tmpdir = path, fileext = ".rds")
[16:21:04.951]                     save_rds(obj, file)
[16:21:04.951]                   }
[16:21:04.951]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:04.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.951]                   {
[16:21:04.951]                     inherits <- base::inherits
[16:21:04.951]                     invokeRestart <- base::invokeRestart
[16:21:04.951]                     is.null <- base::is.null
[16:21:04.951]                     muffled <- FALSE
[16:21:04.951]                     if (inherits(cond, "message")) {
[16:21:04.951]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:04.951]                       if (muffled) 
[16:21:04.951]                         invokeRestart("muffleMessage")
[16:21:04.951]                     }
[16:21:04.951]                     else if (inherits(cond, "warning")) {
[16:21:04.951]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:04.951]                       if (muffled) 
[16:21:04.951]                         invokeRestart("muffleWarning")
[16:21:04.951]                     }
[16:21:04.951]                     else if (inherits(cond, "condition")) {
[16:21:04.951]                       if (!is.null(pattern)) {
[16:21:04.951]                         computeRestarts <- base::computeRestarts
[16:21:04.951]                         grepl <- base::grepl
[16:21:04.951]                         restarts <- computeRestarts(cond)
[16:21:04.951]                         for (restart in restarts) {
[16:21:04.951]                           name <- restart$name
[16:21:04.951]                           if (is.null(name)) 
[16:21:04.951]                             next
[16:21:04.951]                           if (!grepl(pattern, name)) 
[16:21:04.951]                             next
[16:21:04.951]                           invokeRestart(restart)
[16:21:04.951]                           muffled <- TRUE
[16:21:04.951]                           break
[16:21:04.951]                         }
[16:21:04.951]                       }
[16:21:04.951]                     }
[16:21:04.951]                     invisible(muffled)
[16:21:04.951]                   }
[16:21:04.951]                   muffleCondition(cond)
[16:21:04.951]                 })
[16:21:04.951]             }))
[16:21:04.951]             future::FutureResult(value = ...future.value$value, 
[16:21:04.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.951]                   ...future.rng), globalenv = if (FALSE) 
[16:21:04.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:04.951]                     ...future.globalenv.names))
[16:21:04.951]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:04.951]         }, condition = base::local({
[16:21:04.951]             c <- base::c
[16:21:04.951]             inherits <- base::inherits
[16:21:04.951]             invokeRestart <- base::invokeRestart
[16:21:04.951]             length <- base::length
[16:21:04.951]             list <- base::list
[16:21:04.951]             seq.int <- base::seq.int
[16:21:04.951]             signalCondition <- base::signalCondition
[16:21:04.951]             sys.calls <- base::sys.calls
[16:21:04.951]             `[[` <- base::`[[`
[16:21:04.951]             `+` <- base::`+`
[16:21:04.951]             `<<-` <- base::`<<-`
[16:21:04.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:04.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:04.951]                   3L)]
[16:21:04.951]             }
[16:21:04.951]             function(cond) {
[16:21:04.951]                 is_error <- inherits(cond, "error")
[16:21:04.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:04.951]                   NULL)
[16:21:04.951]                 if (is_error) {
[16:21:04.951]                   sessionInformation <- function() {
[16:21:04.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:04.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:04.951]                       search = base::search(), system = base::Sys.info())
[16:21:04.951]                   }
[16:21:04.951]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:04.951]                     cond$call), session = sessionInformation(), 
[16:21:04.951]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:04.951]                   signalCondition(cond)
[16:21:04.951]                 }
[16:21:04.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:04.951]                 "immediateCondition"))) {
[16:21:04.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:04.951]                   ...future.conditions[[length(...future.conditions) + 
[16:21:04.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:04.951]                   if (TRUE && !signal) {
[16:21:04.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.951]                     {
[16:21:04.951]                       inherits <- base::inherits
[16:21:04.951]                       invokeRestart <- base::invokeRestart
[16:21:04.951]                       is.null <- base::is.null
[16:21:04.951]                       muffled <- FALSE
[16:21:04.951]                       if (inherits(cond, "message")) {
[16:21:04.951]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.951]                         if (muffled) 
[16:21:04.951]                           invokeRestart("muffleMessage")
[16:21:04.951]                       }
[16:21:04.951]                       else if (inherits(cond, "warning")) {
[16:21:04.951]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.951]                         if (muffled) 
[16:21:04.951]                           invokeRestart("muffleWarning")
[16:21:04.951]                       }
[16:21:04.951]                       else if (inherits(cond, "condition")) {
[16:21:04.951]                         if (!is.null(pattern)) {
[16:21:04.951]                           computeRestarts <- base::computeRestarts
[16:21:04.951]                           grepl <- base::grepl
[16:21:04.951]                           restarts <- computeRestarts(cond)
[16:21:04.951]                           for (restart in restarts) {
[16:21:04.951]                             name <- restart$name
[16:21:04.951]                             if (is.null(name)) 
[16:21:04.951]                               next
[16:21:04.951]                             if (!grepl(pattern, name)) 
[16:21:04.951]                               next
[16:21:04.951]                             invokeRestart(restart)
[16:21:04.951]                             muffled <- TRUE
[16:21:04.951]                             break
[16:21:04.951]                           }
[16:21:04.951]                         }
[16:21:04.951]                       }
[16:21:04.951]                       invisible(muffled)
[16:21:04.951]                     }
[16:21:04.951]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.951]                   }
[16:21:04.951]                 }
[16:21:04.951]                 else {
[16:21:04.951]                   if (TRUE) {
[16:21:04.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:04.951]                     {
[16:21:04.951]                       inherits <- base::inherits
[16:21:04.951]                       invokeRestart <- base::invokeRestart
[16:21:04.951]                       is.null <- base::is.null
[16:21:04.951]                       muffled <- FALSE
[16:21:04.951]                       if (inherits(cond, "message")) {
[16:21:04.951]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:04.951]                         if (muffled) 
[16:21:04.951]                           invokeRestart("muffleMessage")
[16:21:04.951]                       }
[16:21:04.951]                       else if (inherits(cond, "warning")) {
[16:21:04.951]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:04.951]                         if (muffled) 
[16:21:04.951]                           invokeRestart("muffleWarning")
[16:21:04.951]                       }
[16:21:04.951]                       else if (inherits(cond, "condition")) {
[16:21:04.951]                         if (!is.null(pattern)) {
[16:21:04.951]                           computeRestarts <- base::computeRestarts
[16:21:04.951]                           grepl <- base::grepl
[16:21:04.951]                           restarts <- computeRestarts(cond)
[16:21:04.951]                           for (restart in restarts) {
[16:21:04.951]                             name <- restart$name
[16:21:04.951]                             if (is.null(name)) 
[16:21:04.951]                               next
[16:21:04.951]                             if (!grepl(pattern, name)) 
[16:21:04.951]                               next
[16:21:04.951]                             invokeRestart(restart)
[16:21:04.951]                             muffled <- TRUE
[16:21:04.951]                             break
[16:21:04.951]                           }
[16:21:04.951]                         }
[16:21:04.951]                       }
[16:21:04.951]                       invisible(muffled)
[16:21:04.951]                     }
[16:21:04.951]                     muffleCondition(cond, pattern = "^muffle")
[16:21:04.951]                   }
[16:21:04.951]                 }
[16:21:04.951]             }
[16:21:04.951]         }))
[16:21:04.951]     }, error = function(ex) {
[16:21:04.951]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:04.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:04.951]                 ...future.rng), started = ...future.startTime, 
[16:21:04.951]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:04.951]             version = "1.8"), class = "FutureResult")
[16:21:04.951]     }, finally = {
[16:21:04.951]         if (!identical(...future.workdir, getwd())) 
[16:21:04.951]             setwd(...future.workdir)
[16:21:04.951]         {
[16:21:04.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:04.951]                 ...future.oldOptions$nwarnings <- NULL
[16:21:04.951]             }
[16:21:04.951]             base::options(...future.oldOptions)
[16:21:04.951]             if (.Platform$OS.type == "windows") {
[16:21:04.951]                 old_names <- names(...future.oldEnvVars)
[16:21:04.951]                 envs <- base::Sys.getenv()
[16:21:04.951]                 names <- names(envs)
[16:21:04.951]                 common <- intersect(names, old_names)
[16:21:04.951]                 added <- setdiff(names, old_names)
[16:21:04.951]                 removed <- setdiff(old_names, names)
[16:21:04.951]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:04.951]                   envs[common]]
[16:21:04.951]                 NAMES <- toupper(changed)
[16:21:04.951]                 args <- list()
[16:21:04.951]                 for (kk in seq_along(NAMES)) {
[16:21:04.951]                   name <- changed[[kk]]
[16:21:04.951]                   NAME <- NAMES[[kk]]
[16:21:04.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.951]                     next
[16:21:04.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.951]                 }
[16:21:04.951]                 NAMES <- toupper(added)
[16:21:04.951]                 for (kk in seq_along(NAMES)) {
[16:21:04.951]                   name <- added[[kk]]
[16:21:04.951]                   NAME <- NAMES[[kk]]
[16:21:04.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.951]                     next
[16:21:04.951]                   args[[name]] <- ""
[16:21:04.951]                 }
[16:21:04.951]                 NAMES <- toupper(removed)
[16:21:04.951]                 for (kk in seq_along(NAMES)) {
[16:21:04.951]                   name <- removed[[kk]]
[16:21:04.951]                   NAME <- NAMES[[kk]]
[16:21:04.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:04.951]                     next
[16:21:04.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:04.951]                 }
[16:21:04.951]                 if (length(args) > 0) 
[16:21:04.951]                   base::do.call(base::Sys.setenv, args = args)
[16:21:04.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:04.951]             }
[16:21:04.951]             else {
[16:21:04.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:04.951]             }
[16:21:04.951]             {
[16:21:04.951]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:04.951]                   0L) {
[16:21:04.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:04.951]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:04.951]                   base::options(opts)
[16:21:04.951]                 }
[16:21:04.951]                 {
[16:21:04.951]                   {
[16:21:04.951]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:04.951]                     NULL
[16:21:04.951]                   }
[16:21:04.951]                   options(future.plan = NULL)
[16:21:04.951]                   if (is.na(NA_character_)) 
[16:21:04.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:04.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:04.951]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:04.951]                     .init = FALSE)
[16:21:04.951]                 }
[16:21:04.951]             }
[16:21:04.951]         }
[16:21:04.951]     })
[16:21:04.951]     if (TRUE) {
[16:21:04.951]         base::sink(type = "output", split = FALSE)
[16:21:04.951]         if (TRUE) {
[16:21:04.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:04.951]         }
[16:21:04.951]         else {
[16:21:04.951]             ...future.result["stdout"] <- base::list(NULL)
[16:21:04.951]         }
[16:21:04.951]         base::close(...future.stdout)
[16:21:04.951]         ...future.stdout <- NULL
[16:21:04.951]     }
[16:21:04.951]     ...future.result$conditions <- ...future.conditions
[16:21:04.951]     ...future.result$finished <- base::Sys.time()
[16:21:04.951]     ...future.result
[16:21:04.951] }
[16:21:04.954] assign_globals() ...
[16:21:04.954] List of 1
[16:21:04.954]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x562228a869a0> 
[16:21:04.954]  - attr(*, "where")=List of 1
[16:21:04.954]   ..$ a:<environment: R_EmptyEnv> 
[16:21:04.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:04.954]  - attr(*, "resolved")= logi TRUE
[16:21:04.954]  - attr(*, "total_size")= num 1647176
[16:21:04.954]  - attr(*, "already-done")= logi TRUE
[16:21:04.957] - copied ‘a’ to environment
[16:21:04.957] assign_globals() ... done
[16:21:04.958] requestCore(): workers = 2
[16:21:04.960] MulticoreFuture started
[16:21:04.960] - Launch lazy future ... done
[16:21:04.960] run() for ‘MulticoreFuture’ ... done
[16:21:04.961] result() for MulticoreFuture ...
[16:21:04.962] plan(): Setting new future strategy stack:
[16:21:04.962] List of future strategies:
[16:21:04.962] 1. sequential:
[16:21:04.962]    - args: function (..., envir = parent.frame())
[16:21:04.962]    - tweaked: FALSE
[16:21:04.962]    - call: NULL
[16:21:04.968] plan(): nbrOfWorkers() = 1
[16:21:04.972] plan(): Setting new future strategy stack:
[16:21:04.972] List of future strategies:
[16:21:04.972] 1. multicore:
[16:21:04.972]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:04.972]    - tweaked: FALSE
[16:21:04.972]    - call: plan(strategy)
[16:21:04.978] plan(): nbrOfWorkers() = 2
[16:21:04.979] result() for MulticoreFuture ...
[16:21:04.979] result() for MulticoreFuture ... done
[16:21:04.980] signalConditions() ...
[16:21:04.980]  - include = ‘immediateCondition’
[16:21:04.980]  - exclude = 
[16:21:04.980]  - resignal = FALSE
[16:21:04.980]  - Number of conditions: 4
[16:21:04.981] signalConditions() ... done
[16:21:04.981] result() for MulticoreFuture ... done
[16:21:04.981] result() for MulticoreFuture ...
[16:21:04.981] result() for MulticoreFuture ... done
[16:21:04.981] signalConditions() ...
[16:21:04.981]  - include = ‘immediateCondition’
[16:21:04.981]  - exclude = 
[16:21:04.982]  - resignal = FALSE
[16:21:04.982]  - Number of conditions: 4
[16:21:04.982] signalConditions() ... done
[16:21:04.982] Future state: ‘finished’
[16:21:04.982] result() for MulticoreFuture ...
[16:21:04.982] result() for MulticoreFuture ... done
[16:21:04.983] signalConditions() ...
[16:21:04.983]  - include = ‘condition’
[16:21:04.983]  - exclude = ‘immediateCondition’
[16:21:04.983]  - resignal = TRUE
[16:21:04.983]  - Number of conditions: 4
[16:21:04.984]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.970] result() for MulticoreFuture ...
[16:21:04.984]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.970] result() for MulticoreFuture ... done
[16:21:04.984]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.970] result() for MulticoreFuture ...
[16:21:04.984]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.971] result() for MulticoreFuture ... done
[16:21:04.984] signalConditions() ... done
value(b) = 2
[16:21:04.985] result() for MulticoreFuture ...
[16:21:04.985] result() for MulticoreFuture ... done
[16:21:04.985] result() for MulticoreFuture ...
[16:21:04.985] result() for MulticoreFuture ... done
[16:21:04.985] signalConditions() ...
[16:21:04.985]  - include = ‘immediateCondition’
[16:21:04.985]  - exclude = 
[16:21:04.985]  - resignal = FALSE
[16:21:04.985]  - Number of conditions: 4
[16:21:04.986] signalConditions() ... done
[16:21:04.986] Future state: ‘finished’
[16:21:04.986] result() for MulticoreFuture ...
[16:21:04.986] result() for MulticoreFuture ... done
[16:21:04.986] signalConditions() ...
[16:21:04.986]  - include = ‘condition’
[16:21:04.986]  - exclude = ‘immediateCondition’
[16:21:04.987]  - resignal = TRUE
[16:21:04.987]  - Number of conditions: 4
[16:21:04.987]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.970] result() for MulticoreFuture ...
[16:21:04.987]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.970] result() for MulticoreFuture ... done
[16:21:04.987]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.970] result() for MulticoreFuture ...
[16:21:04.988]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:04.971] result() for MulticoreFuture ... done
[16:21:04.988] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.988] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.989] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.989] 
[16:21:04.989] Searching for globals ... DONE
[16:21:04.990] - globals: [0] <none>
[16:21:04.990] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:04.990] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:04.990] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:04.991] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:04.991] Searching for globals ... DONE
[16:21:04.992] Resolving globals: TRUE
[16:21:04.992] Resolving any globals that are futures ...
[16:21:04.992] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:04.992] Resolving any globals that are futures ... DONE
[16:21:04.992] Resolving futures part of globals (recursively) ...
[16:21:04.993] resolve() on list ...
[16:21:04.993]  recursive: 99
[16:21:04.993]  length: 1
[16:21:04.993]  elements: ‘a’
[16:21:04.993] run() for ‘Future’ ...
[16:21:04.993] - state: ‘created’
[16:21:04.994] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:04.998] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:04.998] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:04.998]   - Field: ‘label’
[16:21:04.998]   - Field: ‘local’
[16:21:04.998]   - Field: ‘owner’
[16:21:04.998]   - Field: ‘envir’
[16:21:04.998]   - Field: ‘workers’
[16:21:04.999]   - Field: ‘packages’
[16:21:04.999]   - Field: ‘gc’
[16:21:04.999]   - Field: ‘job’
[16:21:04.999]   - Field: ‘conditions’
[16:21:04.999]   - Field: ‘expr’
[16:21:04.999]   - Field: ‘uuid’
[16:21:04.999]   - Field: ‘seed’
[16:21:04.999]   - Field: ‘version’
[16:21:04.999]   - Field: ‘result’
[16:21:05.000]   - Field: ‘asynchronous’
[16:21:05.000]   - Field: ‘calls’
[16:21:05.000]   - Field: ‘globals’
[16:21:05.000]   - Field: ‘stdout’
[16:21:05.000]   - Field: ‘earlySignal’
[16:21:05.000]   - Field: ‘lazy’
[16:21:05.000]   - Field: ‘state’
[16:21:05.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:05.000] - Launch lazy future ...
[16:21:05.001] Packages needed by the future expression (n = 0): <none>
[16:21:05.001] Packages needed by future strategies (n = 0): <none>
[16:21:05.001] {
[16:21:05.001]     {
[16:21:05.001]         {
[16:21:05.001]             ...future.startTime <- base::Sys.time()
[16:21:05.001]             {
[16:21:05.001]                 {
[16:21:05.001]                   {
[16:21:05.001]                     {
[16:21:05.001]                       base::local({
[16:21:05.001]                         has_future <- base::requireNamespace("future", 
[16:21:05.001]                           quietly = TRUE)
[16:21:05.001]                         if (has_future) {
[16:21:05.001]                           ns <- base::getNamespace("future")
[16:21:05.001]                           version <- ns[[".package"]][["version"]]
[16:21:05.001]                           if (is.null(version)) 
[16:21:05.001]                             version <- utils::packageVersion("future")
[16:21:05.001]                         }
[16:21:05.001]                         else {
[16:21:05.001]                           version <- NULL
[16:21:05.001]                         }
[16:21:05.001]                         if (!has_future || version < "1.8.0") {
[16:21:05.001]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.001]                             "", base::R.version$version.string), 
[16:21:05.001]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:05.001]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.001]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.001]                               "release", "version")], collapse = " "), 
[16:21:05.001]                             hostname = base::Sys.info()[["nodename"]])
[16:21:05.001]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.001]                             info)
[16:21:05.001]                           info <- base::paste(info, collapse = "; ")
[16:21:05.001]                           if (!has_future) {
[16:21:05.001]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.001]                               info)
[16:21:05.001]                           }
[16:21:05.001]                           else {
[16:21:05.001]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.001]                               info, version)
[16:21:05.001]                           }
[16:21:05.001]                           base::stop(msg)
[16:21:05.001]                         }
[16:21:05.001]                       })
[16:21:05.001]                     }
[16:21:05.001]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.001]                     base::options(mc.cores = 1L)
[16:21:05.001]                   }
[16:21:05.001]                   ...future.strategy.old <- future::plan("list")
[16:21:05.001]                   options(future.plan = NULL)
[16:21:05.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.001]                 }
[16:21:05.001]                 ...future.workdir <- getwd()
[16:21:05.001]             }
[16:21:05.001]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.001]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.001]         }
[16:21:05.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.001]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:05.001]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.001]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.001]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.001]             base::names(...future.oldOptions))
[16:21:05.001]     }
[16:21:05.001]     if (FALSE) {
[16:21:05.001]     }
[16:21:05.001]     else {
[16:21:05.001]         if (TRUE) {
[16:21:05.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.001]                 open = "w")
[16:21:05.001]         }
[16:21:05.001]         else {
[16:21:05.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.001]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.001]         }
[16:21:05.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.001]             base::sink(type = "output", split = FALSE)
[16:21:05.001]             base::close(...future.stdout)
[16:21:05.001]         }, add = TRUE)
[16:21:05.001]     }
[16:21:05.001]     ...future.frame <- base::sys.nframe()
[16:21:05.001]     ...future.conditions <- base::list()
[16:21:05.001]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.001]     if (FALSE) {
[16:21:05.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.001]     }
[16:21:05.001]     ...future.result <- base::tryCatch({
[16:21:05.001]         base::withCallingHandlers({
[16:21:05.001]             ...future.value <- base::withVisible(base::local({
[16:21:05.001]                 withCallingHandlers({
[16:21:05.001]                   1
[16:21:05.001]                 }, immediateCondition = function(cond) {
[16:21:05.001]                   save_rds <- function (object, pathname, ...) 
[16:21:05.001]                   {
[16:21:05.001]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:05.001]                     if (file_test("-f", pathname_tmp)) {
[16:21:05.001]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.001]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:05.001]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.001]                         fi_tmp[["mtime"]])
[16:21:05.001]                     }
[16:21:05.001]                     tryCatch({
[16:21:05.001]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:05.001]                     }, error = function(ex) {
[16:21:05.001]                       msg <- conditionMessage(ex)
[16:21:05.001]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.001]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:05.001]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.001]                         fi_tmp[["mtime"]], msg)
[16:21:05.001]                       ex$message <- msg
[16:21:05.001]                       stop(ex)
[16:21:05.001]                     })
[16:21:05.001]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:05.001]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:05.001]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:05.001]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.001]                       fi <- file.info(pathname)
[16:21:05.001]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:05.001]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.001]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:05.001]                         fi[["size"]], fi[["mtime"]])
[16:21:05.001]                       stop(msg)
[16:21:05.001]                     }
[16:21:05.001]                     invisible(pathname)
[16:21:05.001]                   }
[16:21:05.001]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:05.001]                     rootPath = tempdir()) 
[16:21:05.001]                   {
[16:21:05.001]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:05.001]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:05.001]                       tmpdir = path, fileext = ".rds")
[16:21:05.001]                     save_rds(obj, file)
[16:21:05.001]                   }
[16:21:05.001]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:05.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.001]                   {
[16:21:05.001]                     inherits <- base::inherits
[16:21:05.001]                     invokeRestart <- base::invokeRestart
[16:21:05.001]                     is.null <- base::is.null
[16:21:05.001]                     muffled <- FALSE
[16:21:05.001]                     if (inherits(cond, "message")) {
[16:21:05.001]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.001]                       if (muffled) 
[16:21:05.001]                         invokeRestart("muffleMessage")
[16:21:05.001]                     }
[16:21:05.001]                     else if (inherits(cond, "warning")) {
[16:21:05.001]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.001]                       if (muffled) 
[16:21:05.001]                         invokeRestart("muffleWarning")
[16:21:05.001]                     }
[16:21:05.001]                     else if (inherits(cond, "condition")) {
[16:21:05.001]                       if (!is.null(pattern)) {
[16:21:05.001]                         computeRestarts <- base::computeRestarts
[16:21:05.001]                         grepl <- base::grepl
[16:21:05.001]                         restarts <- computeRestarts(cond)
[16:21:05.001]                         for (restart in restarts) {
[16:21:05.001]                           name <- restart$name
[16:21:05.001]                           if (is.null(name)) 
[16:21:05.001]                             next
[16:21:05.001]                           if (!grepl(pattern, name)) 
[16:21:05.001]                             next
[16:21:05.001]                           invokeRestart(restart)
[16:21:05.001]                           muffled <- TRUE
[16:21:05.001]                           break
[16:21:05.001]                         }
[16:21:05.001]                       }
[16:21:05.001]                     }
[16:21:05.001]                     invisible(muffled)
[16:21:05.001]                   }
[16:21:05.001]                   muffleCondition(cond)
[16:21:05.001]                 })
[16:21:05.001]             }))
[16:21:05.001]             future::FutureResult(value = ...future.value$value, 
[16:21:05.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.001]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.001]                     ...future.globalenv.names))
[16:21:05.001]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.001]         }, condition = base::local({
[16:21:05.001]             c <- base::c
[16:21:05.001]             inherits <- base::inherits
[16:21:05.001]             invokeRestart <- base::invokeRestart
[16:21:05.001]             length <- base::length
[16:21:05.001]             list <- base::list
[16:21:05.001]             seq.int <- base::seq.int
[16:21:05.001]             signalCondition <- base::signalCondition
[16:21:05.001]             sys.calls <- base::sys.calls
[16:21:05.001]             `[[` <- base::`[[`
[16:21:05.001]             `+` <- base::`+`
[16:21:05.001]             `<<-` <- base::`<<-`
[16:21:05.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.001]                   3L)]
[16:21:05.001]             }
[16:21:05.001]             function(cond) {
[16:21:05.001]                 is_error <- inherits(cond, "error")
[16:21:05.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.001]                   NULL)
[16:21:05.001]                 if (is_error) {
[16:21:05.001]                   sessionInformation <- function() {
[16:21:05.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.001]                       search = base::search(), system = base::Sys.info())
[16:21:05.001]                   }
[16:21:05.001]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.001]                     cond$call), session = sessionInformation(), 
[16:21:05.001]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.001]                   signalCondition(cond)
[16:21:05.001]                 }
[16:21:05.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.001]                 "immediateCondition"))) {
[16:21:05.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.001]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.001]                   if (TRUE && !signal) {
[16:21:05.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.001]                     {
[16:21:05.001]                       inherits <- base::inherits
[16:21:05.001]                       invokeRestart <- base::invokeRestart
[16:21:05.001]                       is.null <- base::is.null
[16:21:05.001]                       muffled <- FALSE
[16:21:05.001]                       if (inherits(cond, "message")) {
[16:21:05.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.001]                         if (muffled) 
[16:21:05.001]                           invokeRestart("muffleMessage")
[16:21:05.001]                       }
[16:21:05.001]                       else if (inherits(cond, "warning")) {
[16:21:05.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.001]                         if (muffled) 
[16:21:05.001]                           invokeRestart("muffleWarning")
[16:21:05.001]                       }
[16:21:05.001]                       else if (inherits(cond, "condition")) {
[16:21:05.001]                         if (!is.null(pattern)) {
[16:21:05.001]                           computeRestarts <- base::computeRestarts
[16:21:05.001]                           grepl <- base::grepl
[16:21:05.001]                           restarts <- computeRestarts(cond)
[16:21:05.001]                           for (restart in restarts) {
[16:21:05.001]                             name <- restart$name
[16:21:05.001]                             if (is.null(name)) 
[16:21:05.001]                               next
[16:21:05.001]                             if (!grepl(pattern, name)) 
[16:21:05.001]                               next
[16:21:05.001]                             invokeRestart(restart)
[16:21:05.001]                             muffled <- TRUE
[16:21:05.001]                             break
[16:21:05.001]                           }
[16:21:05.001]                         }
[16:21:05.001]                       }
[16:21:05.001]                       invisible(muffled)
[16:21:05.001]                     }
[16:21:05.001]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.001]                   }
[16:21:05.001]                 }
[16:21:05.001]                 else {
[16:21:05.001]                   if (TRUE) {
[16:21:05.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.001]                     {
[16:21:05.001]                       inherits <- base::inherits
[16:21:05.001]                       invokeRestart <- base::invokeRestart
[16:21:05.001]                       is.null <- base::is.null
[16:21:05.001]                       muffled <- FALSE
[16:21:05.001]                       if (inherits(cond, "message")) {
[16:21:05.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.001]                         if (muffled) 
[16:21:05.001]                           invokeRestart("muffleMessage")
[16:21:05.001]                       }
[16:21:05.001]                       else if (inherits(cond, "warning")) {
[16:21:05.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.001]                         if (muffled) 
[16:21:05.001]                           invokeRestart("muffleWarning")
[16:21:05.001]                       }
[16:21:05.001]                       else if (inherits(cond, "condition")) {
[16:21:05.001]                         if (!is.null(pattern)) {
[16:21:05.001]                           computeRestarts <- base::computeRestarts
[16:21:05.001]                           grepl <- base::grepl
[16:21:05.001]                           restarts <- computeRestarts(cond)
[16:21:05.001]                           for (restart in restarts) {
[16:21:05.001]                             name <- restart$name
[16:21:05.001]                             if (is.null(name)) 
[16:21:05.001]                               next
[16:21:05.001]                             if (!grepl(pattern, name)) 
[16:21:05.001]                               next
[16:21:05.001]                             invokeRestart(restart)
[16:21:05.001]                             muffled <- TRUE
[16:21:05.001]                             break
[16:21:05.001]                           }
[16:21:05.001]                         }
[16:21:05.001]                       }
[16:21:05.001]                       invisible(muffled)
[16:21:05.001]                     }
[16:21:05.001]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.001]                   }
[16:21:05.001]                 }
[16:21:05.001]             }
[16:21:05.001]         }))
[16:21:05.001]     }, error = function(ex) {
[16:21:05.001]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.001]                 ...future.rng), started = ...future.startTime, 
[16:21:05.001]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.001]             version = "1.8"), class = "FutureResult")
[16:21:05.001]     }, finally = {
[16:21:05.001]         if (!identical(...future.workdir, getwd())) 
[16:21:05.001]             setwd(...future.workdir)
[16:21:05.001]         {
[16:21:05.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.001]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.001]             }
[16:21:05.001]             base::options(...future.oldOptions)
[16:21:05.001]             if (.Platform$OS.type == "windows") {
[16:21:05.001]                 old_names <- names(...future.oldEnvVars)
[16:21:05.001]                 envs <- base::Sys.getenv()
[16:21:05.001]                 names <- names(envs)
[16:21:05.001]                 common <- intersect(names, old_names)
[16:21:05.001]                 added <- setdiff(names, old_names)
[16:21:05.001]                 removed <- setdiff(old_names, names)
[16:21:05.001]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.001]                   envs[common]]
[16:21:05.001]                 NAMES <- toupper(changed)
[16:21:05.001]                 args <- list()
[16:21:05.001]                 for (kk in seq_along(NAMES)) {
[16:21:05.001]                   name <- changed[[kk]]
[16:21:05.001]                   NAME <- NAMES[[kk]]
[16:21:05.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.001]                     next
[16:21:05.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.001]                 }
[16:21:05.001]                 NAMES <- toupper(added)
[16:21:05.001]                 for (kk in seq_along(NAMES)) {
[16:21:05.001]                   name <- added[[kk]]
[16:21:05.001]                   NAME <- NAMES[[kk]]
[16:21:05.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.001]                     next
[16:21:05.001]                   args[[name]] <- ""
[16:21:05.001]                 }
[16:21:05.001]                 NAMES <- toupper(removed)
[16:21:05.001]                 for (kk in seq_along(NAMES)) {
[16:21:05.001]                   name <- removed[[kk]]
[16:21:05.001]                   NAME <- NAMES[[kk]]
[16:21:05.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.001]                     next
[16:21:05.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.001]                 }
[16:21:05.001]                 if (length(args) > 0) 
[16:21:05.001]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.001]             }
[16:21:05.001]             else {
[16:21:05.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.001]             }
[16:21:05.001]             {
[16:21:05.001]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.001]                   0L) {
[16:21:05.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.001]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.001]                   base::options(opts)
[16:21:05.001]                 }
[16:21:05.001]                 {
[16:21:05.001]                   {
[16:21:05.001]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.001]                     NULL
[16:21:05.001]                   }
[16:21:05.001]                   options(future.plan = NULL)
[16:21:05.001]                   if (is.na(NA_character_)) 
[16:21:05.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.001]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.001]                     .init = FALSE)
[16:21:05.001]                 }
[16:21:05.001]             }
[16:21:05.001]         }
[16:21:05.001]     })
[16:21:05.001]     if (TRUE) {
[16:21:05.001]         base::sink(type = "output", split = FALSE)
[16:21:05.001]         if (TRUE) {
[16:21:05.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.001]         }
[16:21:05.001]         else {
[16:21:05.001]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.001]         }
[16:21:05.001]         base::close(...future.stdout)
[16:21:05.001]         ...future.stdout <- NULL
[16:21:05.001]     }
[16:21:05.001]     ...future.result$conditions <- ...future.conditions
[16:21:05.001]     ...future.result$finished <- base::Sys.time()
[16:21:05.001]     ...future.result
[16:21:05.001] }
[16:21:05.004] requestCore(): workers = 2
[16:21:05.006] MulticoreFuture started
[16:21:05.006] - Launch lazy future ... done
[16:21:05.007] run() for ‘MulticoreFuture’ ... done
[16:21:05.007] plan(): Setting new future strategy stack:
[16:21:05.007] List of future strategies:
[16:21:05.007] 1. sequential:
[16:21:05.007]    - args: function (..., envir = parent.frame())
[16:21:05.007]    - tweaked: FALSE
[16:21:05.007]    - call: NULL
[16:21:05.008] plan(): nbrOfWorkers() = 1
[16:21:05.011] plan(): Setting new future strategy stack:
[16:21:05.011] List of future strategies:
[16:21:05.011] 1. multicore:
[16:21:05.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:05.011]    - tweaked: FALSE
[16:21:05.011]    - call: plan(strategy)
[16:21:05.017] plan(): nbrOfWorkers() = 2
[16:21:05.028] Future #1
[16:21:05.028] result() for MulticoreFuture ...
[16:21:05.029] result() for MulticoreFuture ...
[16:21:05.029] result() for MulticoreFuture ... done
[16:21:05.029] result() for MulticoreFuture ... done
[16:21:05.029] result() for MulticoreFuture ...
[16:21:05.030] result() for MulticoreFuture ... done
[16:21:05.030] A MulticoreFuture was resolved
[16:21:05.030]  length: 0 (resolved future 1)
[16:21:05.030] resolve() on list ... DONE
[16:21:05.030] - globals: [1] ‘a’
[16:21:05.030] Resolving futures part of globals (recursively) ... DONE
[16:21:05.033] The total size of the 1 globals is 1.57 MiB (1647176 bytes)
[16:21:05.034] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:21:05.034] - globals: [1] ‘a’
[16:21:05.034] - packages: [1] ‘future’
[16:21:05.034] getGlobalsAndPackages() ... DONE
[16:21:05.035] run() for ‘Future’ ...
[16:21:05.035] - state: ‘created’
[16:21:05.035] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:05.043] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:05.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:05.043]   - Field: ‘label’
[16:21:05.043]   - Field: ‘local’
[16:21:05.043]   - Field: ‘owner’
[16:21:05.044]   - Field: ‘envir’
[16:21:05.044]   - Field: ‘workers’
[16:21:05.044]   - Field: ‘packages’
[16:21:05.044]   - Field: ‘gc’
[16:21:05.044]   - Field: ‘job’
[16:21:05.044]   - Field: ‘conditions’
[16:21:05.044]   - Field: ‘expr’
[16:21:05.045]   - Field: ‘uuid’
[16:21:05.045]   - Field: ‘seed’
[16:21:05.045]   - Field: ‘version’
[16:21:05.045]   - Field: ‘result’
[16:21:05.045]   - Field: ‘asynchronous’
[16:21:05.045]   - Field: ‘calls’
[16:21:05.045]   - Field: ‘globals’
[16:21:05.046]   - Field: ‘stdout’
[16:21:05.046]   - Field: ‘earlySignal’
[16:21:05.046]   - Field: ‘lazy’
[16:21:05.046]   - Field: ‘state’
[16:21:05.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:05.046] - Launch lazy future ...
[16:21:05.047] Packages needed by the future expression (n = 1): ‘future’
[16:21:05.047] Packages needed by future strategies (n = 0): <none>
[16:21:05.048] {
[16:21:05.048]     {
[16:21:05.048]         {
[16:21:05.048]             ...future.startTime <- base::Sys.time()
[16:21:05.048]             {
[16:21:05.048]                 {
[16:21:05.048]                   {
[16:21:05.048]                     {
[16:21:05.048]                       {
[16:21:05.048]                         base::local({
[16:21:05.048]                           has_future <- base::requireNamespace("future", 
[16:21:05.048]                             quietly = TRUE)
[16:21:05.048]                           if (has_future) {
[16:21:05.048]                             ns <- base::getNamespace("future")
[16:21:05.048]                             version <- ns[[".package"]][["version"]]
[16:21:05.048]                             if (is.null(version)) 
[16:21:05.048]                               version <- utils::packageVersion("future")
[16:21:05.048]                           }
[16:21:05.048]                           else {
[16:21:05.048]                             version <- NULL
[16:21:05.048]                           }
[16:21:05.048]                           if (!has_future || version < "1.8.0") {
[16:21:05.048]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.048]                               "", base::R.version$version.string), 
[16:21:05.048]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:05.048]                                 base::R.version$platform, 8 * 
[16:21:05.048]                                   base::.Machine$sizeof.pointer), 
[16:21:05.048]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.048]                                 "release", "version")], collapse = " "), 
[16:21:05.048]                               hostname = base::Sys.info()[["nodename"]])
[16:21:05.048]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.048]                               info)
[16:21:05.048]                             info <- base::paste(info, collapse = "; ")
[16:21:05.048]                             if (!has_future) {
[16:21:05.048]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.048]                                 info)
[16:21:05.048]                             }
[16:21:05.048]                             else {
[16:21:05.048]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.048]                                 info, version)
[16:21:05.048]                             }
[16:21:05.048]                             base::stop(msg)
[16:21:05.048]                           }
[16:21:05.048]                         })
[16:21:05.048]                       }
[16:21:05.048]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.048]                       base::options(mc.cores = 1L)
[16:21:05.048]                     }
[16:21:05.048]                     base::local({
[16:21:05.048]                       for (pkg in "future") {
[16:21:05.048]                         base::loadNamespace(pkg)
[16:21:05.048]                         base::library(pkg, character.only = TRUE)
[16:21:05.048]                       }
[16:21:05.048]                     })
[16:21:05.048]                   }
[16:21:05.048]                   ...future.strategy.old <- future::plan("list")
[16:21:05.048]                   options(future.plan = NULL)
[16:21:05.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.048]                 }
[16:21:05.048]                 ...future.workdir <- getwd()
[16:21:05.048]             }
[16:21:05.048]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.048]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.048]         }
[16:21:05.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.048]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:05.048]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.048]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.048]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.048]             base::names(...future.oldOptions))
[16:21:05.048]     }
[16:21:05.048]     if (FALSE) {
[16:21:05.048]     }
[16:21:05.048]     else {
[16:21:05.048]         if (TRUE) {
[16:21:05.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.048]                 open = "w")
[16:21:05.048]         }
[16:21:05.048]         else {
[16:21:05.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.048]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.048]         }
[16:21:05.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.048]             base::sink(type = "output", split = FALSE)
[16:21:05.048]             base::close(...future.stdout)
[16:21:05.048]         }, add = TRUE)
[16:21:05.048]     }
[16:21:05.048]     ...future.frame <- base::sys.nframe()
[16:21:05.048]     ...future.conditions <- base::list()
[16:21:05.048]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.048]     if (FALSE) {
[16:21:05.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.048]     }
[16:21:05.048]     ...future.result <- base::tryCatch({
[16:21:05.048]         base::withCallingHandlers({
[16:21:05.048]             ...future.value <- base::withVisible(base::local({
[16:21:05.048]                 withCallingHandlers({
[16:21:05.048]                   value(a) + 1
[16:21:05.048]                 }, immediateCondition = function(cond) {
[16:21:05.048]                   save_rds <- function (object, pathname, ...) 
[16:21:05.048]                   {
[16:21:05.048]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:05.048]                     if (file_test("-f", pathname_tmp)) {
[16:21:05.048]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.048]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:05.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.048]                         fi_tmp[["mtime"]])
[16:21:05.048]                     }
[16:21:05.048]                     tryCatch({
[16:21:05.048]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:05.048]                     }, error = function(ex) {
[16:21:05.048]                       msg <- conditionMessage(ex)
[16:21:05.048]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.048]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:05.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.048]                         fi_tmp[["mtime"]], msg)
[16:21:05.048]                       ex$message <- msg
[16:21:05.048]                       stop(ex)
[16:21:05.048]                     })
[16:21:05.048]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:05.048]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:05.048]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:05.048]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.048]                       fi <- file.info(pathname)
[16:21:05.048]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:05.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.048]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:05.048]                         fi[["size"]], fi[["mtime"]])
[16:21:05.048]                       stop(msg)
[16:21:05.048]                     }
[16:21:05.048]                     invisible(pathname)
[16:21:05.048]                   }
[16:21:05.048]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:05.048]                     rootPath = tempdir()) 
[16:21:05.048]                   {
[16:21:05.048]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:05.048]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:05.048]                       tmpdir = path, fileext = ".rds")
[16:21:05.048]                     save_rds(obj, file)
[16:21:05.048]                   }
[16:21:05.048]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:05.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.048]                   {
[16:21:05.048]                     inherits <- base::inherits
[16:21:05.048]                     invokeRestart <- base::invokeRestart
[16:21:05.048]                     is.null <- base::is.null
[16:21:05.048]                     muffled <- FALSE
[16:21:05.048]                     if (inherits(cond, "message")) {
[16:21:05.048]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.048]                       if (muffled) 
[16:21:05.048]                         invokeRestart("muffleMessage")
[16:21:05.048]                     }
[16:21:05.048]                     else if (inherits(cond, "warning")) {
[16:21:05.048]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.048]                       if (muffled) 
[16:21:05.048]                         invokeRestart("muffleWarning")
[16:21:05.048]                     }
[16:21:05.048]                     else if (inherits(cond, "condition")) {
[16:21:05.048]                       if (!is.null(pattern)) {
[16:21:05.048]                         computeRestarts <- base::computeRestarts
[16:21:05.048]                         grepl <- base::grepl
[16:21:05.048]                         restarts <- computeRestarts(cond)
[16:21:05.048]                         for (restart in restarts) {
[16:21:05.048]                           name <- restart$name
[16:21:05.048]                           if (is.null(name)) 
[16:21:05.048]                             next
[16:21:05.048]                           if (!grepl(pattern, name)) 
[16:21:05.048]                             next
[16:21:05.048]                           invokeRestart(restart)
[16:21:05.048]                           muffled <- TRUE
[16:21:05.048]                           break
[16:21:05.048]                         }
[16:21:05.048]                       }
[16:21:05.048]                     }
[16:21:05.048]                     invisible(muffled)
[16:21:05.048]                   }
[16:21:05.048]                   muffleCondition(cond)
[16:21:05.048]                 })
[16:21:05.048]             }))
[16:21:05.048]             future::FutureResult(value = ...future.value$value, 
[16:21:05.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.048]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.048]                     ...future.globalenv.names))
[16:21:05.048]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.048]         }, condition = base::local({
[16:21:05.048]             c <- base::c
[16:21:05.048]             inherits <- base::inherits
[16:21:05.048]             invokeRestart <- base::invokeRestart
[16:21:05.048]             length <- base::length
[16:21:05.048]             list <- base::list
[16:21:05.048]             seq.int <- base::seq.int
[16:21:05.048]             signalCondition <- base::signalCondition
[16:21:05.048]             sys.calls <- base::sys.calls
[16:21:05.048]             `[[` <- base::`[[`
[16:21:05.048]             `+` <- base::`+`
[16:21:05.048]             `<<-` <- base::`<<-`
[16:21:05.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.048]                   3L)]
[16:21:05.048]             }
[16:21:05.048]             function(cond) {
[16:21:05.048]                 is_error <- inherits(cond, "error")
[16:21:05.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.048]                   NULL)
[16:21:05.048]                 if (is_error) {
[16:21:05.048]                   sessionInformation <- function() {
[16:21:05.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.048]                       search = base::search(), system = base::Sys.info())
[16:21:05.048]                   }
[16:21:05.048]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.048]                     cond$call), session = sessionInformation(), 
[16:21:05.048]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.048]                   signalCondition(cond)
[16:21:05.048]                 }
[16:21:05.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.048]                 "immediateCondition"))) {
[16:21:05.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.048]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.048]                   if (TRUE && !signal) {
[16:21:05.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.048]                     {
[16:21:05.048]                       inherits <- base::inherits
[16:21:05.048]                       invokeRestart <- base::invokeRestart
[16:21:05.048]                       is.null <- base::is.null
[16:21:05.048]                       muffled <- FALSE
[16:21:05.048]                       if (inherits(cond, "message")) {
[16:21:05.048]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.048]                         if (muffled) 
[16:21:05.048]                           invokeRestart("muffleMessage")
[16:21:05.048]                       }
[16:21:05.048]                       else if (inherits(cond, "warning")) {
[16:21:05.048]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.048]                         if (muffled) 
[16:21:05.048]                           invokeRestart("muffleWarning")
[16:21:05.048]                       }
[16:21:05.048]                       else if (inherits(cond, "condition")) {
[16:21:05.048]                         if (!is.null(pattern)) {
[16:21:05.048]                           computeRestarts <- base::computeRestarts
[16:21:05.048]                           grepl <- base::grepl
[16:21:05.048]                           restarts <- computeRestarts(cond)
[16:21:05.048]                           for (restart in restarts) {
[16:21:05.048]                             name <- restart$name
[16:21:05.048]                             if (is.null(name)) 
[16:21:05.048]                               next
[16:21:05.048]                             if (!grepl(pattern, name)) 
[16:21:05.048]                               next
[16:21:05.048]                             invokeRestart(restart)
[16:21:05.048]                             muffled <- TRUE
[16:21:05.048]                             break
[16:21:05.048]                           }
[16:21:05.048]                         }
[16:21:05.048]                       }
[16:21:05.048]                       invisible(muffled)
[16:21:05.048]                     }
[16:21:05.048]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.048]                   }
[16:21:05.048]                 }
[16:21:05.048]                 else {
[16:21:05.048]                   if (TRUE) {
[16:21:05.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.048]                     {
[16:21:05.048]                       inherits <- base::inherits
[16:21:05.048]                       invokeRestart <- base::invokeRestart
[16:21:05.048]                       is.null <- base::is.null
[16:21:05.048]                       muffled <- FALSE
[16:21:05.048]                       if (inherits(cond, "message")) {
[16:21:05.048]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.048]                         if (muffled) 
[16:21:05.048]                           invokeRestart("muffleMessage")
[16:21:05.048]                       }
[16:21:05.048]                       else if (inherits(cond, "warning")) {
[16:21:05.048]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.048]                         if (muffled) 
[16:21:05.048]                           invokeRestart("muffleWarning")
[16:21:05.048]                       }
[16:21:05.048]                       else if (inherits(cond, "condition")) {
[16:21:05.048]                         if (!is.null(pattern)) {
[16:21:05.048]                           computeRestarts <- base::computeRestarts
[16:21:05.048]                           grepl <- base::grepl
[16:21:05.048]                           restarts <- computeRestarts(cond)
[16:21:05.048]                           for (restart in restarts) {
[16:21:05.048]                             name <- restart$name
[16:21:05.048]                             if (is.null(name)) 
[16:21:05.048]                               next
[16:21:05.048]                             if (!grepl(pattern, name)) 
[16:21:05.048]                               next
[16:21:05.048]                             invokeRestart(restart)
[16:21:05.048]                             muffled <- TRUE
[16:21:05.048]                             break
[16:21:05.048]                           }
[16:21:05.048]                         }
[16:21:05.048]                       }
[16:21:05.048]                       invisible(muffled)
[16:21:05.048]                     }
[16:21:05.048]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.048]                   }
[16:21:05.048]                 }
[16:21:05.048]             }
[16:21:05.048]         }))
[16:21:05.048]     }, error = function(ex) {
[16:21:05.048]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.048]                 ...future.rng), started = ...future.startTime, 
[16:21:05.048]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.048]             version = "1.8"), class = "FutureResult")
[16:21:05.048]     }, finally = {
[16:21:05.048]         if (!identical(...future.workdir, getwd())) 
[16:21:05.048]             setwd(...future.workdir)
[16:21:05.048]         {
[16:21:05.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.048]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.048]             }
[16:21:05.048]             base::options(...future.oldOptions)
[16:21:05.048]             if (.Platform$OS.type == "windows") {
[16:21:05.048]                 old_names <- names(...future.oldEnvVars)
[16:21:05.048]                 envs <- base::Sys.getenv()
[16:21:05.048]                 names <- names(envs)
[16:21:05.048]                 common <- intersect(names, old_names)
[16:21:05.048]                 added <- setdiff(names, old_names)
[16:21:05.048]                 removed <- setdiff(old_names, names)
[16:21:05.048]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.048]                   envs[common]]
[16:21:05.048]                 NAMES <- toupper(changed)
[16:21:05.048]                 args <- list()
[16:21:05.048]                 for (kk in seq_along(NAMES)) {
[16:21:05.048]                   name <- changed[[kk]]
[16:21:05.048]                   NAME <- NAMES[[kk]]
[16:21:05.048]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.048]                     next
[16:21:05.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.048]                 }
[16:21:05.048]                 NAMES <- toupper(added)
[16:21:05.048]                 for (kk in seq_along(NAMES)) {
[16:21:05.048]                   name <- added[[kk]]
[16:21:05.048]                   NAME <- NAMES[[kk]]
[16:21:05.048]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.048]                     next
[16:21:05.048]                   args[[name]] <- ""
[16:21:05.048]                 }
[16:21:05.048]                 NAMES <- toupper(removed)
[16:21:05.048]                 for (kk in seq_along(NAMES)) {
[16:21:05.048]                   name <- removed[[kk]]
[16:21:05.048]                   NAME <- NAMES[[kk]]
[16:21:05.048]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.048]                     next
[16:21:05.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.048]                 }
[16:21:05.048]                 if (length(args) > 0) 
[16:21:05.048]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.048]             }
[16:21:05.048]             else {
[16:21:05.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.048]             }
[16:21:05.048]             {
[16:21:05.048]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.048]                   0L) {
[16:21:05.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.048]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.048]                   base::options(opts)
[16:21:05.048]                 }
[16:21:05.048]                 {
[16:21:05.048]                   {
[16:21:05.048]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.048]                     NULL
[16:21:05.048]                   }
[16:21:05.048]                   options(future.plan = NULL)
[16:21:05.048]                   if (is.na(NA_character_)) 
[16:21:05.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.048]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.048]                     .init = FALSE)
[16:21:05.048]                 }
[16:21:05.048]             }
[16:21:05.048]         }
[16:21:05.048]     })
[16:21:05.048]     if (TRUE) {
[16:21:05.048]         base::sink(type = "output", split = FALSE)
[16:21:05.048]         if (TRUE) {
[16:21:05.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.048]         }
[16:21:05.048]         else {
[16:21:05.048]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.048]         }
[16:21:05.048]         base::close(...future.stdout)
[16:21:05.048]         ...future.stdout <- NULL
[16:21:05.048]     }
[16:21:05.048]     ...future.result$conditions <- ...future.conditions
[16:21:05.048]     ...future.result$finished <- base::Sys.time()
[16:21:05.048]     ...future.result
[16:21:05.048] }
[16:21:05.050] assign_globals() ...
[16:21:05.050] List of 1
[16:21:05.050]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5622272c5420> 
[16:21:05.050]  - attr(*, "where")=List of 1
[16:21:05.050]   ..$ a:<environment: R_EmptyEnv> 
[16:21:05.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:05.050]  - attr(*, "resolved")= logi TRUE
[16:21:05.050]  - attr(*, "total_size")= num 1647176
[16:21:05.050]  - attr(*, "already-done")= logi TRUE
[16:21:05.054] - copied ‘a’ to environment
[16:21:05.054] assign_globals() ... done
[16:21:05.054] requestCore(): workers = 2
[16:21:05.056] MulticoreFuture started
[16:21:05.057] - Launch lazy future ... done
[16:21:05.057] run() for ‘MulticoreFuture’ ... done
[16:21:05.058] result() for MulticoreFuture ...
[16:21:05.058] plan(): Setting new future strategy stack:
[16:21:05.058] List of future strategies:
[16:21:05.058] 1. sequential:
[16:21:05.058]    - args: function (..., envir = parent.frame())
[16:21:05.058]    - tweaked: FALSE
[16:21:05.058]    - call: NULL
[16:21:05.059] plan(): nbrOfWorkers() = 1
[16:21:05.064] plan(): Setting new future strategy stack:
[16:21:05.064] List of future strategies:
[16:21:05.064] 1. multicore:
[16:21:05.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:05.064]    - tweaked: FALSE
[16:21:05.064]    - call: plan(strategy)
[16:21:05.070] plan(): nbrOfWorkers() = 2
[16:21:05.071] result() for MulticoreFuture ...
[16:21:05.071] result() for MulticoreFuture ... done
[16:21:05.071] signalConditions() ...
[16:21:05.071]  - include = ‘immediateCondition’
[16:21:05.071]  - exclude = 
[16:21:05.071]  - resignal = FALSE
[16:21:05.071]  - Number of conditions: 4
[16:21:05.072] signalConditions() ... done
[16:21:05.072] result() for MulticoreFuture ... done
[16:21:05.072] result() for MulticoreFuture ...
[16:21:05.072] result() for MulticoreFuture ... done
[16:21:05.072] signalConditions() ...
[16:21:05.072]  - include = ‘immediateCondition’
[16:21:05.073]  - exclude = 
[16:21:05.073]  - resignal = FALSE
[16:21:05.073]  - Number of conditions: 4
[16:21:05.073] signalConditions() ... done
[16:21:05.073] Future state: ‘finished’
[16:21:05.073] result() for MulticoreFuture ...
[16:21:05.074] result() for MulticoreFuture ... done
[16:21:05.074] signalConditions() ...
[16:21:05.074]  - include = ‘condition’
[16:21:05.074]  - exclude = ‘immediateCondition’
[16:21:05.074]  - resignal = TRUE
[16:21:05.074]  - Number of conditions: 4
[16:21:05.074]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:05.061] result() for MulticoreFuture ...
[16:21:05.074]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:05.061] result() for MulticoreFuture ... done
[16:21:05.075]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:05.062] result() for MulticoreFuture ...
[16:21:05.075]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:05.062] result() for MulticoreFuture ... done
[16:21:05.075] signalConditions() ... done
value(b) = 2
[16:21:05.075] result() for MulticoreFuture ...
[16:21:05.075] result() for MulticoreFuture ... done
[16:21:05.076] result() for MulticoreFuture ...
[16:21:05.076] result() for MulticoreFuture ... done
[16:21:05.076] signalConditions() ...
[16:21:05.076]  - include = ‘immediateCondition’
[16:21:05.076]  - exclude = 
[16:21:05.076]  - resignal = FALSE
[16:21:05.076]  - Number of conditions: 4
[16:21:05.076] signalConditions() ... done
[16:21:05.076] Future state: ‘finished’
[16:21:05.077] result() for MulticoreFuture ...
[16:21:05.077] result() for MulticoreFuture ... done
[16:21:05.077] signalConditions() ...
[16:21:05.077]  - include = ‘condition’
[16:21:05.077]  - exclude = ‘immediateCondition’
[16:21:05.077]  - resignal = TRUE
[16:21:05.077]  - Number of conditions: 4
[16:21:05.077]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:05.061] result() for MulticoreFuture ...
[16:21:05.078]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:05.061] result() for MulticoreFuture ... done
[16:21:05.078]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:05.062] result() for MulticoreFuture ...
[16:21:05.078]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:05.062] result() for MulticoreFuture ... done
[16:21:05.078] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:05.078] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:05.079] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:05.080] - globals found: [2] ‘{’, ‘pkg’
[16:21:05.080] Searching for globals ... DONE
[16:21:05.080] Resolving globals: TRUE
[16:21:05.080] Resolving any globals that are futures ...
[16:21:05.080] - globals: [2] ‘{’, ‘pkg’
[16:21:05.080] Resolving any globals that are futures ... DONE
[16:21:05.081] Resolving futures part of globals (recursively) ...
[16:21:05.081] resolve() on list ...
[16:21:05.081]  recursive: 99
[16:21:05.081]  length: 1
[16:21:05.081]  elements: ‘pkg’
[16:21:05.082]  length: 0 (resolved future 1)
[16:21:05.082] resolve() on list ... DONE
[16:21:05.082] - globals: [1] ‘pkg’
[16:21:05.082] Resolving futures part of globals (recursively) ... DONE
[16:21:05.082] The total size of the 1 globals is 112 bytes (112 bytes)
[16:21:05.083] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:21:05.083] - globals: [1] ‘pkg’
[16:21:05.083] 
[16:21:05.083] getGlobalsAndPackages() ... DONE
[16:21:05.084] Packages needed by the future expression (n = 0): <none>
[16:21:05.084] Packages needed by future strategies (n = 0): <none>
[16:21:05.084] {
[16:21:05.084]     {
[16:21:05.084]         {
[16:21:05.084]             ...future.startTime <- base::Sys.time()
[16:21:05.084]             {
[16:21:05.084]                 {
[16:21:05.084]                   {
[16:21:05.084]                     base::local({
[16:21:05.084]                       has_future <- base::requireNamespace("future", 
[16:21:05.084]                         quietly = TRUE)
[16:21:05.084]                       if (has_future) {
[16:21:05.084]                         ns <- base::getNamespace("future")
[16:21:05.084]                         version <- ns[[".package"]][["version"]]
[16:21:05.084]                         if (is.null(version)) 
[16:21:05.084]                           version <- utils::packageVersion("future")
[16:21:05.084]                       }
[16:21:05.084]                       else {
[16:21:05.084]                         version <- NULL
[16:21:05.084]                       }
[16:21:05.084]                       if (!has_future || version < "1.8.0") {
[16:21:05.084]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.084]                           "", base::R.version$version.string), 
[16:21:05.084]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:05.084]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.084]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.084]                             "release", "version")], collapse = " "), 
[16:21:05.084]                           hostname = base::Sys.info()[["nodename"]])
[16:21:05.084]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.084]                           info)
[16:21:05.084]                         info <- base::paste(info, collapse = "; ")
[16:21:05.084]                         if (!has_future) {
[16:21:05.084]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.084]                             info)
[16:21:05.084]                         }
[16:21:05.084]                         else {
[16:21:05.084]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.084]                             info, version)
[16:21:05.084]                         }
[16:21:05.084]                         base::stop(msg)
[16:21:05.084]                       }
[16:21:05.084]                     })
[16:21:05.084]                   }
[16:21:05.084]                   ...future.strategy.old <- future::plan("list")
[16:21:05.084]                   options(future.plan = NULL)
[16:21:05.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.084]                 }
[16:21:05.084]                 ...future.workdir <- getwd()
[16:21:05.084]             }
[16:21:05.084]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.084]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.084]         }
[16:21:05.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.084]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:05.084]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.084]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.084]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.084]             base::names(...future.oldOptions))
[16:21:05.084]     }
[16:21:05.084]     if (FALSE) {
[16:21:05.084]     }
[16:21:05.084]     else {
[16:21:05.084]         if (TRUE) {
[16:21:05.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.084]                 open = "w")
[16:21:05.084]         }
[16:21:05.084]         else {
[16:21:05.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.084]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.084]         }
[16:21:05.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.084]             base::sink(type = "output", split = FALSE)
[16:21:05.084]             base::close(...future.stdout)
[16:21:05.084]         }, add = TRUE)
[16:21:05.084]     }
[16:21:05.084]     ...future.frame <- base::sys.nframe()
[16:21:05.084]     ...future.conditions <- base::list()
[16:21:05.084]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.084]     if (FALSE) {
[16:21:05.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.084]     }
[16:21:05.084]     ...future.result <- base::tryCatch({
[16:21:05.084]         base::withCallingHandlers({
[16:21:05.084]             ...future.value <- base::withVisible(base::local({
[16:21:05.084]                 pkg
[16:21:05.084]             }))
[16:21:05.084]             future::FutureResult(value = ...future.value$value, 
[16:21:05.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.084]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.084]                     ...future.globalenv.names))
[16:21:05.084]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.084]         }, condition = base::local({
[16:21:05.084]             c <- base::c
[16:21:05.084]             inherits <- base::inherits
[16:21:05.084]             invokeRestart <- base::invokeRestart
[16:21:05.084]             length <- base::length
[16:21:05.084]             list <- base::list
[16:21:05.084]             seq.int <- base::seq.int
[16:21:05.084]             signalCondition <- base::signalCondition
[16:21:05.084]             sys.calls <- base::sys.calls
[16:21:05.084]             `[[` <- base::`[[`
[16:21:05.084]             `+` <- base::`+`
[16:21:05.084]             `<<-` <- base::`<<-`
[16:21:05.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.084]                   3L)]
[16:21:05.084]             }
[16:21:05.084]             function(cond) {
[16:21:05.084]                 is_error <- inherits(cond, "error")
[16:21:05.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.084]                   NULL)
[16:21:05.084]                 if (is_error) {
[16:21:05.084]                   sessionInformation <- function() {
[16:21:05.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.084]                       search = base::search(), system = base::Sys.info())
[16:21:05.084]                   }
[16:21:05.084]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.084]                     cond$call), session = sessionInformation(), 
[16:21:05.084]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.084]                   signalCondition(cond)
[16:21:05.084]                 }
[16:21:05.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.084]                 "immediateCondition"))) {
[16:21:05.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.084]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.084]                   if (TRUE && !signal) {
[16:21:05.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.084]                     {
[16:21:05.084]                       inherits <- base::inherits
[16:21:05.084]                       invokeRestart <- base::invokeRestart
[16:21:05.084]                       is.null <- base::is.null
[16:21:05.084]                       muffled <- FALSE
[16:21:05.084]                       if (inherits(cond, "message")) {
[16:21:05.084]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.084]                         if (muffled) 
[16:21:05.084]                           invokeRestart("muffleMessage")
[16:21:05.084]                       }
[16:21:05.084]                       else if (inherits(cond, "warning")) {
[16:21:05.084]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.084]                         if (muffled) 
[16:21:05.084]                           invokeRestart("muffleWarning")
[16:21:05.084]                       }
[16:21:05.084]                       else if (inherits(cond, "condition")) {
[16:21:05.084]                         if (!is.null(pattern)) {
[16:21:05.084]                           computeRestarts <- base::computeRestarts
[16:21:05.084]                           grepl <- base::grepl
[16:21:05.084]                           restarts <- computeRestarts(cond)
[16:21:05.084]                           for (restart in restarts) {
[16:21:05.084]                             name <- restart$name
[16:21:05.084]                             if (is.null(name)) 
[16:21:05.084]                               next
[16:21:05.084]                             if (!grepl(pattern, name)) 
[16:21:05.084]                               next
[16:21:05.084]                             invokeRestart(restart)
[16:21:05.084]                             muffled <- TRUE
[16:21:05.084]                             break
[16:21:05.084]                           }
[16:21:05.084]                         }
[16:21:05.084]                       }
[16:21:05.084]                       invisible(muffled)
[16:21:05.084]                     }
[16:21:05.084]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.084]                   }
[16:21:05.084]                 }
[16:21:05.084]                 else {
[16:21:05.084]                   if (TRUE) {
[16:21:05.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.084]                     {
[16:21:05.084]                       inherits <- base::inherits
[16:21:05.084]                       invokeRestart <- base::invokeRestart
[16:21:05.084]                       is.null <- base::is.null
[16:21:05.084]                       muffled <- FALSE
[16:21:05.084]                       if (inherits(cond, "message")) {
[16:21:05.084]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.084]                         if (muffled) 
[16:21:05.084]                           invokeRestart("muffleMessage")
[16:21:05.084]                       }
[16:21:05.084]                       else if (inherits(cond, "warning")) {
[16:21:05.084]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.084]                         if (muffled) 
[16:21:05.084]                           invokeRestart("muffleWarning")
[16:21:05.084]                       }
[16:21:05.084]                       else if (inherits(cond, "condition")) {
[16:21:05.084]                         if (!is.null(pattern)) {
[16:21:05.084]                           computeRestarts <- base::computeRestarts
[16:21:05.084]                           grepl <- base::grepl
[16:21:05.084]                           restarts <- computeRestarts(cond)
[16:21:05.084]                           for (restart in restarts) {
[16:21:05.084]                             name <- restart$name
[16:21:05.084]                             if (is.null(name)) 
[16:21:05.084]                               next
[16:21:05.084]                             if (!grepl(pattern, name)) 
[16:21:05.084]                               next
[16:21:05.084]                             invokeRestart(restart)
[16:21:05.084]                             muffled <- TRUE
[16:21:05.084]                             break
[16:21:05.084]                           }
[16:21:05.084]                         }
[16:21:05.084]                       }
[16:21:05.084]                       invisible(muffled)
[16:21:05.084]                     }
[16:21:05.084]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.084]                   }
[16:21:05.084]                 }
[16:21:05.084]             }
[16:21:05.084]         }))
[16:21:05.084]     }, error = function(ex) {
[16:21:05.084]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.084]                 ...future.rng), started = ...future.startTime, 
[16:21:05.084]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.084]             version = "1.8"), class = "FutureResult")
[16:21:05.084]     }, finally = {
[16:21:05.084]         if (!identical(...future.workdir, getwd())) 
[16:21:05.084]             setwd(...future.workdir)
[16:21:05.084]         {
[16:21:05.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.084]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.084]             }
[16:21:05.084]             base::options(...future.oldOptions)
[16:21:05.084]             if (.Platform$OS.type == "windows") {
[16:21:05.084]                 old_names <- names(...future.oldEnvVars)
[16:21:05.084]                 envs <- base::Sys.getenv()
[16:21:05.084]                 names <- names(envs)
[16:21:05.084]                 common <- intersect(names, old_names)
[16:21:05.084]                 added <- setdiff(names, old_names)
[16:21:05.084]                 removed <- setdiff(old_names, names)
[16:21:05.084]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.084]                   envs[common]]
[16:21:05.084]                 NAMES <- toupper(changed)
[16:21:05.084]                 args <- list()
[16:21:05.084]                 for (kk in seq_along(NAMES)) {
[16:21:05.084]                   name <- changed[[kk]]
[16:21:05.084]                   NAME <- NAMES[[kk]]
[16:21:05.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.084]                     next
[16:21:05.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.084]                 }
[16:21:05.084]                 NAMES <- toupper(added)
[16:21:05.084]                 for (kk in seq_along(NAMES)) {
[16:21:05.084]                   name <- added[[kk]]
[16:21:05.084]                   NAME <- NAMES[[kk]]
[16:21:05.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.084]                     next
[16:21:05.084]                   args[[name]] <- ""
[16:21:05.084]                 }
[16:21:05.084]                 NAMES <- toupper(removed)
[16:21:05.084]                 for (kk in seq_along(NAMES)) {
[16:21:05.084]                   name <- removed[[kk]]
[16:21:05.084]                   NAME <- NAMES[[kk]]
[16:21:05.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.084]                     next
[16:21:05.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.084]                 }
[16:21:05.084]                 if (length(args) > 0) 
[16:21:05.084]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.084]             }
[16:21:05.084]             else {
[16:21:05.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.084]             }
[16:21:05.084]             {
[16:21:05.084]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.084]                   0L) {
[16:21:05.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.084]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.084]                   base::options(opts)
[16:21:05.084]                 }
[16:21:05.084]                 {
[16:21:05.084]                   {
[16:21:05.084]                     NULL
[16:21:05.084]                     RNGkind("Mersenne-Twister")
[16:21:05.084]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:05.084]                       inherits = FALSE)
[16:21:05.084]                   }
[16:21:05.084]                   options(future.plan = NULL)
[16:21:05.084]                   if (is.na(NA_character_)) 
[16:21:05.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.084]                     .init = FALSE)
[16:21:05.084]                 }
[16:21:05.084]             }
[16:21:05.084]         }
[16:21:05.084]     })
[16:21:05.084]     if (TRUE) {
[16:21:05.084]         base::sink(type = "output", split = FALSE)
[16:21:05.084]         if (TRUE) {
[16:21:05.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.084]         }
[16:21:05.084]         else {
[16:21:05.084]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.084]         }
[16:21:05.084]         base::close(...future.stdout)
[16:21:05.084]         ...future.stdout <- NULL
[16:21:05.084]     }
[16:21:05.084]     ...future.result$conditions <- ...future.conditions
[16:21:05.084]     ...future.result$finished <- base::Sys.time()
[16:21:05.084]     ...future.result
[16:21:05.084] }
[16:21:05.086] assign_globals() ...
[16:21:05.087] List of 1
[16:21:05.087]  $ pkg: chr "foo"
[16:21:05.087]  - attr(*, "where")=List of 1
[16:21:05.087]   ..$ pkg:<environment: R_EmptyEnv> 
[16:21:05.087]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:05.087]  - attr(*, "resolved")= logi TRUE
[16:21:05.087]  - attr(*, "total_size")= num 112
[16:21:05.089] - copied ‘pkg’ to environment
[16:21:05.089] assign_globals() ... done
[16:21:05.090] plan(): Setting new future strategy stack:
[16:21:05.090] List of future strategies:
[16:21:05.090] 1. sequential:
[16:21:05.090]    - args: function (..., envir = parent.frame())
[16:21:05.090]    - tweaked: FALSE
[16:21:05.090]    - call: NULL
[16:21:05.090] plan(): nbrOfWorkers() = 1
[16:21:05.094] plan(): Setting new future strategy stack:
[16:21:05.094] List of future strategies:
[16:21:05.094] 1. multicore:
[16:21:05.094]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:05.094]    - tweaked: FALSE
[16:21:05.094]    - call: plan(strategy)
[16:21:05.099] plan(): nbrOfWorkers() = 2
[16:21:05.099] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:05.100] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:05.100] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:05.103] - globals found: [3] ‘{’, ‘<-’, ‘+’
[16:21:05.103] Searching for globals ... DONE
[16:21:05.103] Resolving globals: TRUE
[16:21:05.103] Resolving any globals that are futures ...
[16:21:05.103] - globals: [3] ‘{’, ‘<-’, ‘+’
[16:21:05.103] Resolving any globals that are futures ... DONE
[16:21:05.104] 
[16:21:05.104] 
[16:21:05.104] getGlobalsAndPackages() ... DONE
[16:21:05.104] run() for ‘Future’ ...
[16:21:05.104] - state: ‘created’
[16:21:05.105] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:05.108] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:05.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:05.109]   - Field: ‘label’
[16:21:05.109]   - Field: ‘local’
[16:21:05.109]   - Field: ‘owner’
[16:21:05.109]   - Field: ‘envir’
[16:21:05.109]   - Field: ‘workers’
[16:21:05.109]   - Field: ‘packages’
[16:21:05.109]   - Field: ‘gc’
[16:21:05.109]   - Field: ‘job’
[16:21:05.109]   - Field: ‘conditions’
[16:21:05.110]   - Field: ‘expr’
[16:21:05.110]   - Field: ‘uuid’
[16:21:05.110]   - Field: ‘seed’
[16:21:05.110]   - Field: ‘version’
[16:21:05.110]   - Field: ‘result’
[16:21:05.110]   - Field: ‘asynchronous’
[16:21:05.110]   - Field: ‘calls’
[16:21:05.110]   - Field: ‘globals’
[16:21:05.110]   - Field: ‘stdout’
[16:21:05.110]   - Field: ‘earlySignal’
[16:21:05.111]   - Field: ‘lazy’
[16:21:05.111]   - Field: ‘state’
[16:21:05.111] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:05.111] - Launch lazy future ...
[16:21:05.111] Packages needed by the future expression (n = 0): <none>
[16:21:05.111] Packages needed by future strategies (n = 0): <none>
[16:21:05.112] {
[16:21:05.112]     {
[16:21:05.112]         {
[16:21:05.112]             ...future.startTime <- base::Sys.time()
[16:21:05.112]             {
[16:21:05.112]                 {
[16:21:05.112]                   {
[16:21:05.112]                     {
[16:21:05.112]                       base::local({
[16:21:05.112]                         has_future <- base::requireNamespace("future", 
[16:21:05.112]                           quietly = TRUE)
[16:21:05.112]                         if (has_future) {
[16:21:05.112]                           ns <- base::getNamespace("future")
[16:21:05.112]                           version <- ns[[".package"]][["version"]]
[16:21:05.112]                           if (is.null(version)) 
[16:21:05.112]                             version <- utils::packageVersion("future")
[16:21:05.112]                         }
[16:21:05.112]                         else {
[16:21:05.112]                           version <- NULL
[16:21:05.112]                         }
[16:21:05.112]                         if (!has_future || version < "1.8.0") {
[16:21:05.112]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.112]                             "", base::R.version$version.string), 
[16:21:05.112]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:05.112]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.112]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.112]                               "release", "version")], collapse = " "), 
[16:21:05.112]                             hostname = base::Sys.info()[["nodename"]])
[16:21:05.112]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.112]                             info)
[16:21:05.112]                           info <- base::paste(info, collapse = "; ")
[16:21:05.112]                           if (!has_future) {
[16:21:05.112]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.112]                               info)
[16:21:05.112]                           }
[16:21:05.112]                           else {
[16:21:05.112]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.112]                               info, version)
[16:21:05.112]                           }
[16:21:05.112]                           base::stop(msg)
[16:21:05.112]                         }
[16:21:05.112]                       })
[16:21:05.112]                     }
[16:21:05.112]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.112]                     base::options(mc.cores = 1L)
[16:21:05.112]                   }
[16:21:05.112]                   ...future.strategy.old <- future::plan("list")
[16:21:05.112]                   options(future.plan = NULL)
[16:21:05.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.112]                 }
[16:21:05.112]                 ...future.workdir <- getwd()
[16:21:05.112]             }
[16:21:05.112]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.112]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.112]         }
[16:21:05.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.112]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:05.112]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.112]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.112]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.112]             base::names(...future.oldOptions))
[16:21:05.112]     }
[16:21:05.112]     if (FALSE) {
[16:21:05.112]     }
[16:21:05.112]     else {
[16:21:05.112]         if (TRUE) {
[16:21:05.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.112]                 open = "w")
[16:21:05.112]         }
[16:21:05.112]         else {
[16:21:05.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.112]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.112]         }
[16:21:05.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.112]             base::sink(type = "output", split = FALSE)
[16:21:05.112]             base::close(...future.stdout)
[16:21:05.112]         }, add = TRUE)
[16:21:05.112]     }
[16:21:05.112]     ...future.frame <- base::sys.nframe()
[16:21:05.112]     ...future.conditions <- base::list()
[16:21:05.112]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.112]     if (FALSE) {
[16:21:05.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.112]     }
[16:21:05.112]     ...future.result <- base::tryCatch({
[16:21:05.112]         base::withCallingHandlers({
[16:21:05.112]             ...future.value <- base::withVisible(base::local({
[16:21:05.112]                 withCallingHandlers({
[16:21:05.112]                   {
[16:21:05.112]                     x <- 0
[16:21:05.112]                     x <- x + 1
[16:21:05.112]                     x
[16:21:05.112]                   }
[16:21:05.112]                 }, immediateCondition = function(cond) {
[16:21:05.112]                   save_rds <- function (object, pathname, ...) 
[16:21:05.112]                   {
[16:21:05.112]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:05.112]                     if (file_test("-f", pathname_tmp)) {
[16:21:05.112]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.112]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:05.112]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.112]                         fi_tmp[["mtime"]])
[16:21:05.112]                     }
[16:21:05.112]                     tryCatch({
[16:21:05.112]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:05.112]                     }, error = function(ex) {
[16:21:05.112]                       msg <- conditionMessage(ex)
[16:21:05.112]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.112]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:05.112]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.112]                         fi_tmp[["mtime"]], msg)
[16:21:05.112]                       ex$message <- msg
[16:21:05.112]                       stop(ex)
[16:21:05.112]                     })
[16:21:05.112]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:05.112]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:05.112]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:05.112]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.112]                       fi <- file.info(pathname)
[16:21:05.112]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:05.112]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.112]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:05.112]                         fi[["size"]], fi[["mtime"]])
[16:21:05.112]                       stop(msg)
[16:21:05.112]                     }
[16:21:05.112]                     invisible(pathname)
[16:21:05.112]                   }
[16:21:05.112]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:05.112]                     rootPath = tempdir()) 
[16:21:05.112]                   {
[16:21:05.112]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:05.112]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:05.112]                       tmpdir = path, fileext = ".rds")
[16:21:05.112]                     save_rds(obj, file)
[16:21:05.112]                   }
[16:21:05.112]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:05.112]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.112]                   {
[16:21:05.112]                     inherits <- base::inherits
[16:21:05.112]                     invokeRestart <- base::invokeRestart
[16:21:05.112]                     is.null <- base::is.null
[16:21:05.112]                     muffled <- FALSE
[16:21:05.112]                     if (inherits(cond, "message")) {
[16:21:05.112]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.112]                       if (muffled) 
[16:21:05.112]                         invokeRestart("muffleMessage")
[16:21:05.112]                     }
[16:21:05.112]                     else if (inherits(cond, "warning")) {
[16:21:05.112]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.112]                       if (muffled) 
[16:21:05.112]                         invokeRestart("muffleWarning")
[16:21:05.112]                     }
[16:21:05.112]                     else if (inherits(cond, "condition")) {
[16:21:05.112]                       if (!is.null(pattern)) {
[16:21:05.112]                         computeRestarts <- base::computeRestarts
[16:21:05.112]                         grepl <- base::grepl
[16:21:05.112]                         restarts <- computeRestarts(cond)
[16:21:05.112]                         for (restart in restarts) {
[16:21:05.112]                           name <- restart$name
[16:21:05.112]                           if (is.null(name)) 
[16:21:05.112]                             next
[16:21:05.112]                           if (!grepl(pattern, name)) 
[16:21:05.112]                             next
[16:21:05.112]                           invokeRestart(restart)
[16:21:05.112]                           muffled <- TRUE
[16:21:05.112]                           break
[16:21:05.112]                         }
[16:21:05.112]                       }
[16:21:05.112]                     }
[16:21:05.112]                     invisible(muffled)
[16:21:05.112]                   }
[16:21:05.112]                   muffleCondition(cond)
[16:21:05.112]                 })
[16:21:05.112]             }))
[16:21:05.112]             future::FutureResult(value = ...future.value$value, 
[16:21:05.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.112]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.112]                     ...future.globalenv.names))
[16:21:05.112]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.112]         }, condition = base::local({
[16:21:05.112]             c <- base::c
[16:21:05.112]             inherits <- base::inherits
[16:21:05.112]             invokeRestart <- base::invokeRestart
[16:21:05.112]             length <- base::length
[16:21:05.112]             list <- base::list
[16:21:05.112]             seq.int <- base::seq.int
[16:21:05.112]             signalCondition <- base::signalCondition
[16:21:05.112]             sys.calls <- base::sys.calls
[16:21:05.112]             `[[` <- base::`[[`
[16:21:05.112]             `+` <- base::`+`
[16:21:05.112]             `<<-` <- base::`<<-`
[16:21:05.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.112]                   3L)]
[16:21:05.112]             }
[16:21:05.112]             function(cond) {
[16:21:05.112]                 is_error <- inherits(cond, "error")
[16:21:05.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.112]                   NULL)
[16:21:05.112]                 if (is_error) {
[16:21:05.112]                   sessionInformation <- function() {
[16:21:05.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.112]                       search = base::search(), system = base::Sys.info())
[16:21:05.112]                   }
[16:21:05.112]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.112]                     cond$call), session = sessionInformation(), 
[16:21:05.112]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.112]                   signalCondition(cond)
[16:21:05.112]                 }
[16:21:05.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.112]                 "immediateCondition"))) {
[16:21:05.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.112]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.112]                   if (TRUE && !signal) {
[16:21:05.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.112]                     {
[16:21:05.112]                       inherits <- base::inherits
[16:21:05.112]                       invokeRestart <- base::invokeRestart
[16:21:05.112]                       is.null <- base::is.null
[16:21:05.112]                       muffled <- FALSE
[16:21:05.112]                       if (inherits(cond, "message")) {
[16:21:05.112]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.112]                         if (muffled) 
[16:21:05.112]                           invokeRestart("muffleMessage")
[16:21:05.112]                       }
[16:21:05.112]                       else if (inherits(cond, "warning")) {
[16:21:05.112]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.112]                         if (muffled) 
[16:21:05.112]                           invokeRestart("muffleWarning")
[16:21:05.112]                       }
[16:21:05.112]                       else if (inherits(cond, "condition")) {
[16:21:05.112]                         if (!is.null(pattern)) {
[16:21:05.112]                           computeRestarts <- base::computeRestarts
[16:21:05.112]                           grepl <- base::grepl
[16:21:05.112]                           restarts <- computeRestarts(cond)
[16:21:05.112]                           for (restart in restarts) {
[16:21:05.112]                             name <- restart$name
[16:21:05.112]                             if (is.null(name)) 
[16:21:05.112]                               next
[16:21:05.112]                             if (!grepl(pattern, name)) 
[16:21:05.112]                               next
[16:21:05.112]                             invokeRestart(restart)
[16:21:05.112]                             muffled <- TRUE
[16:21:05.112]                             break
[16:21:05.112]                           }
[16:21:05.112]                         }
[16:21:05.112]                       }
[16:21:05.112]                       invisible(muffled)
[16:21:05.112]                     }
[16:21:05.112]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.112]                   }
[16:21:05.112]                 }
[16:21:05.112]                 else {
[16:21:05.112]                   if (TRUE) {
[16:21:05.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.112]                     {
[16:21:05.112]                       inherits <- base::inherits
[16:21:05.112]                       invokeRestart <- base::invokeRestart
[16:21:05.112]                       is.null <- base::is.null
[16:21:05.112]                       muffled <- FALSE
[16:21:05.112]                       if (inherits(cond, "message")) {
[16:21:05.112]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.112]                         if (muffled) 
[16:21:05.112]                           invokeRestart("muffleMessage")
[16:21:05.112]                       }
[16:21:05.112]                       else if (inherits(cond, "warning")) {
[16:21:05.112]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.112]                         if (muffled) 
[16:21:05.112]                           invokeRestart("muffleWarning")
[16:21:05.112]                       }
[16:21:05.112]                       else if (inherits(cond, "condition")) {
[16:21:05.112]                         if (!is.null(pattern)) {
[16:21:05.112]                           computeRestarts <- base::computeRestarts
[16:21:05.112]                           grepl <- base::grepl
[16:21:05.112]                           restarts <- computeRestarts(cond)
[16:21:05.112]                           for (restart in restarts) {
[16:21:05.112]                             name <- restart$name
[16:21:05.112]                             if (is.null(name)) 
[16:21:05.112]                               next
[16:21:05.112]                             if (!grepl(pattern, name)) 
[16:21:05.112]                               next
[16:21:05.112]                             invokeRestart(restart)
[16:21:05.112]                             muffled <- TRUE
[16:21:05.112]                             break
[16:21:05.112]                           }
[16:21:05.112]                         }
[16:21:05.112]                       }
[16:21:05.112]                       invisible(muffled)
[16:21:05.112]                     }
[16:21:05.112]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.112]                   }
[16:21:05.112]                 }
[16:21:05.112]             }
[16:21:05.112]         }))
[16:21:05.112]     }, error = function(ex) {
[16:21:05.112]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.112]                 ...future.rng), started = ...future.startTime, 
[16:21:05.112]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.112]             version = "1.8"), class = "FutureResult")
[16:21:05.112]     }, finally = {
[16:21:05.112]         if (!identical(...future.workdir, getwd())) 
[16:21:05.112]             setwd(...future.workdir)
[16:21:05.112]         {
[16:21:05.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.112]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.112]             }
[16:21:05.112]             base::options(...future.oldOptions)
[16:21:05.112]             if (.Platform$OS.type == "windows") {
[16:21:05.112]                 old_names <- names(...future.oldEnvVars)
[16:21:05.112]                 envs <- base::Sys.getenv()
[16:21:05.112]                 names <- names(envs)
[16:21:05.112]                 common <- intersect(names, old_names)
[16:21:05.112]                 added <- setdiff(names, old_names)
[16:21:05.112]                 removed <- setdiff(old_names, names)
[16:21:05.112]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.112]                   envs[common]]
[16:21:05.112]                 NAMES <- toupper(changed)
[16:21:05.112]                 args <- list()
[16:21:05.112]                 for (kk in seq_along(NAMES)) {
[16:21:05.112]                   name <- changed[[kk]]
[16:21:05.112]                   NAME <- NAMES[[kk]]
[16:21:05.112]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.112]                     next
[16:21:05.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.112]                 }
[16:21:05.112]                 NAMES <- toupper(added)
[16:21:05.112]                 for (kk in seq_along(NAMES)) {
[16:21:05.112]                   name <- added[[kk]]
[16:21:05.112]                   NAME <- NAMES[[kk]]
[16:21:05.112]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.112]                     next
[16:21:05.112]                   args[[name]] <- ""
[16:21:05.112]                 }
[16:21:05.112]                 NAMES <- toupper(removed)
[16:21:05.112]                 for (kk in seq_along(NAMES)) {
[16:21:05.112]                   name <- removed[[kk]]
[16:21:05.112]                   NAME <- NAMES[[kk]]
[16:21:05.112]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.112]                     next
[16:21:05.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.112]                 }
[16:21:05.112]                 if (length(args) > 0) 
[16:21:05.112]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.112]             }
[16:21:05.112]             else {
[16:21:05.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.112]             }
[16:21:05.112]             {
[16:21:05.112]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.112]                   0L) {
[16:21:05.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.112]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.112]                   base::options(opts)
[16:21:05.112]                 }
[16:21:05.112]                 {
[16:21:05.112]                   {
[16:21:05.112]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.112]                     NULL
[16:21:05.112]                   }
[16:21:05.112]                   options(future.plan = NULL)
[16:21:05.112]                   if (is.na(NA_character_)) 
[16:21:05.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.112]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.112]                     .init = FALSE)
[16:21:05.112]                 }
[16:21:05.112]             }
[16:21:05.112]         }
[16:21:05.112]     })
[16:21:05.112]     if (TRUE) {
[16:21:05.112]         base::sink(type = "output", split = FALSE)
[16:21:05.112]         if (TRUE) {
[16:21:05.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.112]         }
[16:21:05.112]         else {
[16:21:05.112]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.112]         }
[16:21:05.112]         base::close(...future.stdout)
[16:21:05.112]         ...future.stdout <- NULL
[16:21:05.112]     }
[16:21:05.112]     ...future.result$conditions <- ...future.conditions
[16:21:05.112]     ...future.result$finished <- base::Sys.time()
[16:21:05.112]     ...future.result
[16:21:05.112] }
[16:21:05.114] requestCore(): workers = 2
[16:21:05.116] MulticoreFuture started
[16:21:05.117] - Launch lazy future ... done
[16:21:05.117] run() for ‘MulticoreFuture’ ... done
[16:21:05.117] result() for MulticoreFuture ...
[16:21:05.118] plan(): Setting new future strategy stack:
[16:21:05.118] List of future strategies:
[16:21:05.118] 1. sequential:
[16:21:05.118]    - args: function (..., envir = parent.frame())
[16:21:05.118]    - tweaked: FALSE
[16:21:05.118]    - call: NULL
[16:21:05.119] plan(): nbrOfWorkers() = 1
[16:21:05.121] plan(): Setting new future strategy stack:
[16:21:05.121] List of future strategies:
[16:21:05.121] 1. multicore:
[16:21:05.121]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:05.121]    - tweaked: FALSE
[16:21:05.121]    - call: plan(strategy)
[16:21:05.126] plan(): nbrOfWorkers() = 2
[16:21:05.127] result() for MulticoreFuture ...
[16:21:05.127] result() for MulticoreFuture ... done
[16:21:05.128] result() for MulticoreFuture ... done
[16:21:05.128] result() for MulticoreFuture ...
[16:21:05.128] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:05.128] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:05.129] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:05.131] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:21:05.131] Searching for globals ... DONE
[16:21:05.131] Resolving globals: TRUE
[16:21:05.131] Resolving any globals that are futures ...
[16:21:05.131] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:21:05.132] Resolving any globals that are futures ... DONE
[16:21:05.132] Resolving futures part of globals (recursively) ...
[16:21:05.133] resolve() on list ...
[16:21:05.133]  recursive: 99
[16:21:05.133]  length: 1
[16:21:05.133]  elements: ‘x’
[16:21:05.133]  length: 0 (resolved future 1)
[16:21:05.133] resolve() on list ... DONE
[16:21:05.133] - globals: [1] ‘x’
[16:21:05.133] Resolving futures part of globals (recursively) ... DONE
[16:21:05.134] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:05.134] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[16:21:05.134] - globals: [1] ‘x’
[16:21:05.134] 
[16:21:05.134] getGlobalsAndPackages() ... DONE
[16:21:05.135] run() for ‘Future’ ...
[16:21:05.135] - state: ‘created’
[16:21:05.135] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:05.139] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:05.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:05.140]   - Field: ‘label’
[16:21:05.140]   - Field: ‘local’
[16:21:05.140]   - Field: ‘owner’
[16:21:05.140]   - Field: ‘envir’
[16:21:05.140]   - Field: ‘workers’
[16:21:05.140]   - Field: ‘packages’
[16:21:05.140]   - Field: ‘gc’
[16:21:05.140]   - Field: ‘job’
[16:21:05.141]   - Field: ‘conditions’
[16:21:05.141]   - Field: ‘expr’
[16:21:05.141]   - Field: ‘uuid’
[16:21:05.141]   - Field: ‘seed’
[16:21:05.141]   - Field: ‘version’
[16:21:05.141]   - Field: ‘result’
[16:21:05.141]   - Field: ‘asynchronous’
[16:21:05.141]   - Field: ‘calls’
[16:21:05.142]   - Field: ‘globals’
[16:21:05.142]   - Field: ‘stdout’
[16:21:05.142]   - Field: ‘earlySignal’
[16:21:05.142]   - Field: ‘lazy’
[16:21:05.142]   - Field: ‘state’
[16:21:05.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:05.145] - Launch lazy future ...
[16:21:05.145] Packages needed by the future expression (n = 0): <none>
[16:21:05.146] Packages needed by future strategies (n = 0): <none>
[16:21:05.146] {
[16:21:05.146]     {
[16:21:05.146]         {
[16:21:05.146]             ...future.startTime <- base::Sys.time()
[16:21:05.146]             {
[16:21:05.146]                 {
[16:21:05.146]                   {
[16:21:05.146]                     {
[16:21:05.146]                       base::local({
[16:21:05.146]                         has_future <- base::requireNamespace("future", 
[16:21:05.146]                           quietly = TRUE)
[16:21:05.146]                         if (has_future) {
[16:21:05.146]                           ns <- base::getNamespace("future")
[16:21:05.146]                           version <- ns[[".package"]][["version"]]
[16:21:05.146]                           if (is.null(version)) 
[16:21:05.146]                             version <- utils::packageVersion("future")
[16:21:05.146]                         }
[16:21:05.146]                         else {
[16:21:05.146]                           version <- NULL
[16:21:05.146]                         }
[16:21:05.146]                         if (!has_future || version < "1.8.0") {
[16:21:05.146]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.146]                             "", base::R.version$version.string), 
[16:21:05.146]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:05.146]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.146]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.146]                               "release", "version")], collapse = " "), 
[16:21:05.146]                             hostname = base::Sys.info()[["nodename"]])
[16:21:05.146]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.146]                             info)
[16:21:05.146]                           info <- base::paste(info, collapse = "; ")
[16:21:05.146]                           if (!has_future) {
[16:21:05.146]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.146]                               info)
[16:21:05.146]                           }
[16:21:05.146]                           else {
[16:21:05.146]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.146]                               info, version)
[16:21:05.146]                           }
[16:21:05.146]                           base::stop(msg)
[16:21:05.146]                         }
[16:21:05.146]                       })
[16:21:05.146]                     }
[16:21:05.146]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.146]                     base::options(mc.cores = 1L)
[16:21:05.146]                   }
[16:21:05.146]                   ...future.strategy.old <- future::plan("list")
[16:21:05.146]                   options(future.plan = NULL)
[16:21:05.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.146]                 }
[16:21:05.146]                 ...future.workdir <- getwd()
[16:21:05.146]             }
[16:21:05.146]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.146]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.146]         }
[16:21:05.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.146]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:05.146]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.146]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.146]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.146]             base::names(...future.oldOptions))
[16:21:05.146]     }
[16:21:05.146]     if (FALSE) {
[16:21:05.146]     }
[16:21:05.146]     else {
[16:21:05.146]         if (TRUE) {
[16:21:05.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.146]                 open = "w")
[16:21:05.146]         }
[16:21:05.146]         else {
[16:21:05.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.146]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.146]         }
[16:21:05.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.146]             base::sink(type = "output", split = FALSE)
[16:21:05.146]             base::close(...future.stdout)
[16:21:05.146]         }, add = TRUE)
[16:21:05.146]     }
[16:21:05.146]     ...future.frame <- base::sys.nframe()
[16:21:05.146]     ...future.conditions <- base::list()
[16:21:05.146]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.146]     if (FALSE) {
[16:21:05.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.146]     }
[16:21:05.146]     ...future.result <- base::tryCatch({
[16:21:05.146]         base::withCallingHandlers({
[16:21:05.146]             ...future.value <- base::withVisible(base::local({
[16:21:05.146]                 withCallingHandlers({
[16:21:05.146]                   {
[16:21:05.146]                     x <- x + 1
[16:21:05.146]                     x
[16:21:05.146]                   }
[16:21:05.146]                 }, immediateCondition = function(cond) {
[16:21:05.146]                   save_rds <- function (object, pathname, ...) 
[16:21:05.146]                   {
[16:21:05.146]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:05.146]                     if (file_test("-f", pathname_tmp)) {
[16:21:05.146]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.146]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:05.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.146]                         fi_tmp[["mtime"]])
[16:21:05.146]                     }
[16:21:05.146]                     tryCatch({
[16:21:05.146]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:05.146]                     }, error = function(ex) {
[16:21:05.146]                       msg <- conditionMessage(ex)
[16:21:05.146]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.146]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:05.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.146]                         fi_tmp[["mtime"]], msg)
[16:21:05.146]                       ex$message <- msg
[16:21:05.146]                       stop(ex)
[16:21:05.146]                     })
[16:21:05.146]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:05.146]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:05.146]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:05.146]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.146]                       fi <- file.info(pathname)
[16:21:05.146]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:05.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.146]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:05.146]                         fi[["size"]], fi[["mtime"]])
[16:21:05.146]                       stop(msg)
[16:21:05.146]                     }
[16:21:05.146]                     invisible(pathname)
[16:21:05.146]                   }
[16:21:05.146]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:05.146]                     rootPath = tempdir()) 
[16:21:05.146]                   {
[16:21:05.146]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:05.146]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:05.146]                       tmpdir = path, fileext = ".rds")
[16:21:05.146]                     save_rds(obj, file)
[16:21:05.146]                   }
[16:21:05.146]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:05.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.146]                   {
[16:21:05.146]                     inherits <- base::inherits
[16:21:05.146]                     invokeRestart <- base::invokeRestart
[16:21:05.146]                     is.null <- base::is.null
[16:21:05.146]                     muffled <- FALSE
[16:21:05.146]                     if (inherits(cond, "message")) {
[16:21:05.146]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.146]                       if (muffled) 
[16:21:05.146]                         invokeRestart("muffleMessage")
[16:21:05.146]                     }
[16:21:05.146]                     else if (inherits(cond, "warning")) {
[16:21:05.146]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.146]                       if (muffled) 
[16:21:05.146]                         invokeRestart("muffleWarning")
[16:21:05.146]                     }
[16:21:05.146]                     else if (inherits(cond, "condition")) {
[16:21:05.146]                       if (!is.null(pattern)) {
[16:21:05.146]                         computeRestarts <- base::computeRestarts
[16:21:05.146]                         grepl <- base::grepl
[16:21:05.146]                         restarts <- computeRestarts(cond)
[16:21:05.146]                         for (restart in restarts) {
[16:21:05.146]                           name <- restart$name
[16:21:05.146]                           if (is.null(name)) 
[16:21:05.146]                             next
[16:21:05.146]                           if (!grepl(pattern, name)) 
[16:21:05.146]                             next
[16:21:05.146]                           invokeRestart(restart)
[16:21:05.146]                           muffled <- TRUE
[16:21:05.146]                           break
[16:21:05.146]                         }
[16:21:05.146]                       }
[16:21:05.146]                     }
[16:21:05.146]                     invisible(muffled)
[16:21:05.146]                   }
[16:21:05.146]                   muffleCondition(cond)
[16:21:05.146]                 })
[16:21:05.146]             }))
[16:21:05.146]             future::FutureResult(value = ...future.value$value, 
[16:21:05.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.146]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.146]                     ...future.globalenv.names))
[16:21:05.146]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.146]         }, condition = base::local({
[16:21:05.146]             c <- base::c
[16:21:05.146]             inherits <- base::inherits
[16:21:05.146]             invokeRestart <- base::invokeRestart
[16:21:05.146]             length <- base::length
[16:21:05.146]             list <- base::list
[16:21:05.146]             seq.int <- base::seq.int
[16:21:05.146]             signalCondition <- base::signalCondition
[16:21:05.146]             sys.calls <- base::sys.calls
[16:21:05.146]             `[[` <- base::`[[`
[16:21:05.146]             `+` <- base::`+`
[16:21:05.146]             `<<-` <- base::`<<-`
[16:21:05.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.146]                   3L)]
[16:21:05.146]             }
[16:21:05.146]             function(cond) {
[16:21:05.146]                 is_error <- inherits(cond, "error")
[16:21:05.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.146]                   NULL)
[16:21:05.146]                 if (is_error) {
[16:21:05.146]                   sessionInformation <- function() {
[16:21:05.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.146]                       search = base::search(), system = base::Sys.info())
[16:21:05.146]                   }
[16:21:05.146]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.146]                     cond$call), session = sessionInformation(), 
[16:21:05.146]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.146]                   signalCondition(cond)
[16:21:05.146]                 }
[16:21:05.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.146]                 "immediateCondition"))) {
[16:21:05.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.146]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.146]                   if (TRUE && !signal) {
[16:21:05.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.146]                     {
[16:21:05.146]                       inherits <- base::inherits
[16:21:05.146]                       invokeRestart <- base::invokeRestart
[16:21:05.146]                       is.null <- base::is.null
[16:21:05.146]                       muffled <- FALSE
[16:21:05.146]                       if (inherits(cond, "message")) {
[16:21:05.146]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.146]                         if (muffled) 
[16:21:05.146]                           invokeRestart("muffleMessage")
[16:21:05.146]                       }
[16:21:05.146]                       else if (inherits(cond, "warning")) {
[16:21:05.146]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.146]                         if (muffled) 
[16:21:05.146]                           invokeRestart("muffleWarning")
[16:21:05.146]                       }
[16:21:05.146]                       else if (inherits(cond, "condition")) {
[16:21:05.146]                         if (!is.null(pattern)) {
[16:21:05.146]                           computeRestarts <- base::computeRestarts
[16:21:05.146]                           grepl <- base::grepl
[16:21:05.146]                           restarts <- computeRestarts(cond)
[16:21:05.146]                           for (restart in restarts) {
[16:21:05.146]                             name <- restart$name
[16:21:05.146]                             if (is.null(name)) 
[16:21:05.146]                               next
[16:21:05.146]                             if (!grepl(pattern, name)) 
[16:21:05.146]                               next
[16:21:05.146]                             invokeRestart(restart)
[16:21:05.146]                             muffled <- TRUE
[16:21:05.146]                             break
[16:21:05.146]                           }
[16:21:05.146]                         }
[16:21:05.146]                       }
[16:21:05.146]                       invisible(muffled)
[16:21:05.146]                     }
[16:21:05.146]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.146]                   }
[16:21:05.146]                 }
[16:21:05.146]                 else {
[16:21:05.146]                   if (TRUE) {
[16:21:05.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.146]                     {
[16:21:05.146]                       inherits <- base::inherits
[16:21:05.146]                       invokeRestart <- base::invokeRestart
[16:21:05.146]                       is.null <- base::is.null
[16:21:05.146]                       muffled <- FALSE
[16:21:05.146]                       if (inherits(cond, "message")) {
[16:21:05.146]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.146]                         if (muffled) 
[16:21:05.146]                           invokeRestart("muffleMessage")
[16:21:05.146]                       }
[16:21:05.146]                       else if (inherits(cond, "warning")) {
[16:21:05.146]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.146]                         if (muffled) 
[16:21:05.146]                           invokeRestart("muffleWarning")
[16:21:05.146]                       }
[16:21:05.146]                       else if (inherits(cond, "condition")) {
[16:21:05.146]                         if (!is.null(pattern)) {
[16:21:05.146]                           computeRestarts <- base::computeRestarts
[16:21:05.146]                           grepl <- base::grepl
[16:21:05.146]                           restarts <- computeRestarts(cond)
[16:21:05.146]                           for (restart in restarts) {
[16:21:05.146]                             name <- restart$name
[16:21:05.146]                             if (is.null(name)) 
[16:21:05.146]                               next
[16:21:05.146]                             if (!grepl(pattern, name)) 
[16:21:05.146]                               next
[16:21:05.146]                             invokeRestart(restart)
[16:21:05.146]                             muffled <- TRUE
[16:21:05.146]                             break
[16:21:05.146]                           }
[16:21:05.146]                         }
[16:21:05.146]                       }
[16:21:05.146]                       invisible(muffled)
[16:21:05.146]                     }
[16:21:05.146]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.146]                   }
[16:21:05.146]                 }
[16:21:05.146]             }
[16:21:05.146]         }))
[16:21:05.146]     }, error = function(ex) {
[16:21:05.146]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.146]                 ...future.rng), started = ...future.startTime, 
[16:21:05.146]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.146]             version = "1.8"), class = "FutureResult")
[16:21:05.146]     }, finally = {
[16:21:05.146]         if (!identical(...future.workdir, getwd())) 
[16:21:05.146]             setwd(...future.workdir)
[16:21:05.146]         {
[16:21:05.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.146]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.146]             }
[16:21:05.146]             base::options(...future.oldOptions)
[16:21:05.146]             if (.Platform$OS.type == "windows") {
[16:21:05.146]                 old_names <- names(...future.oldEnvVars)
[16:21:05.146]                 envs <- base::Sys.getenv()
[16:21:05.146]                 names <- names(envs)
[16:21:05.146]                 common <- intersect(names, old_names)
[16:21:05.146]                 added <- setdiff(names, old_names)
[16:21:05.146]                 removed <- setdiff(old_names, names)
[16:21:05.146]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.146]                   envs[common]]
[16:21:05.146]                 NAMES <- toupper(changed)
[16:21:05.146]                 args <- list()
[16:21:05.146]                 for (kk in seq_along(NAMES)) {
[16:21:05.146]                   name <- changed[[kk]]
[16:21:05.146]                   NAME <- NAMES[[kk]]
[16:21:05.146]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.146]                     next
[16:21:05.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.146]                 }
[16:21:05.146]                 NAMES <- toupper(added)
[16:21:05.146]                 for (kk in seq_along(NAMES)) {
[16:21:05.146]                   name <- added[[kk]]
[16:21:05.146]                   NAME <- NAMES[[kk]]
[16:21:05.146]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.146]                     next
[16:21:05.146]                   args[[name]] <- ""
[16:21:05.146]                 }
[16:21:05.146]                 NAMES <- toupper(removed)
[16:21:05.146]                 for (kk in seq_along(NAMES)) {
[16:21:05.146]                   name <- removed[[kk]]
[16:21:05.146]                   NAME <- NAMES[[kk]]
[16:21:05.146]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.146]                     next
[16:21:05.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.146]                 }
[16:21:05.146]                 if (length(args) > 0) 
[16:21:05.146]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.146]             }
[16:21:05.146]             else {
[16:21:05.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.146]             }
[16:21:05.146]             {
[16:21:05.146]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.146]                   0L) {
[16:21:05.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.146]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.146]                   base::options(opts)
[16:21:05.146]                 }
[16:21:05.146]                 {
[16:21:05.146]                   {
[16:21:05.146]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.146]                     NULL
[16:21:05.146]                   }
[16:21:05.146]                   options(future.plan = NULL)
[16:21:05.146]                   if (is.na(NA_character_)) 
[16:21:05.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.146]                     .init = FALSE)
[16:21:05.146]                 }
[16:21:05.146]             }
[16:21:05.146]         }
[16:21:05.146]     })
[16:21:05.146]     if (TRUE) {
[16:21:05.146]         base::sink(type = "output", split = FALSE)
[16:21:05.146]         if (TRUE) {
[16:21:05.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.146]         }
[16:21:05.146]         else {
[16:21:05.146]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.146]         }
[16:21:05.146]         base::close(...future.stdout)
[16:21:05.146]         ...future.stdout <- NULL
[16:21:05.146]     }
[16:21:05.146]     ...future.result$conditions <- ...future.conditions
[16:21:05.146]     ...future.result$finished <- base::Sys.time()
[16:21:05.146]     ...future.result
[16:21:05.146] }
[16:21:05.149] assign_globals() ...
[16:21:05.149] List of 1
[16:21:05.149]  $ x: num 1
[16:21:05.149]  - attr(*, "where")=List of 1
[16:21:05.149]   ..$ x:<environment: R_EmptyEnv> 
[16:21:05.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:05.149]  - attr(*, "resolved")= logi TRUE
[16:21:05.149]  - attr(*, "total_size")= num 56
[16:21:05.149]  - attr(*, "already-done")= logi TRUE
[16:21:05.152] - copied ‘x’ to environment
[16:21:05.153] assign_globals() ... done
[16:21:05.153] requestCore(): workers = 2
[16:21:05.155] MulticoreFuture started
[16:21:05.155] - Launch lazy future ... done
[16:21:05.155] run() for ‘MulticoreFuture’ ... done
[16:21:05.156] result() for MulticoreFuture ...
[16:21:05.156] plan(): Setting new future strategy stack:
[16:21:05.156] List of future strategies:
[16:21:05.156] 1. sequential:
[16:21:05.156]    - args: function (..., envir = parent.frame())
[16:21:05.156]    - tweaked: FALSE
[16:21:05.156]    - call: NULL
[16:21:05.157] plan(): nbrOfWorkers() = 1
[16:21:05.161] plan(): Setting new future strategy stack:
[16:21:05.161] List of future strategies:
[16:21:05.161] 1. multicore:
[16:21:05.161]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:05.161]    - tweaked: FALSE
[16:21:05.161]    - call: plan(strategy)
[16:21:05.168] plan(): nbrOfWorkers() = 2
[16:21:05.169] result() for MulticoreFuture ...
[16:21:05.169] result() for MulticoreFuture ... done
[16:21:05.170] result() for MulticoreFuture ... done
[16:21:05.170] result() for MulticoreFuture ...
[16:21:05.170] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:05.171] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:05.171] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:05.174] - globals found: [3] ‘{’, ‘<-’, ‘x’
[16:21:05.174] Searching for globals ... DONE
[16:21:05.175] Resolving globals: TRUE
[16:21:05.175] Resolving any globals that are futures ...
[16:21:05.175] - globals: [3] ‘{’, ‘<-’, ‘x’
[16:21:05.175] Resolving any globals that are futures ... DONE
[16:21:05.176] Resolving futures part of globals (recursively) ...
[16:21:05.176] resolve() on list ...
[16:21:05.176]  recursive: 99
[16:21:05.176]  length: 1
[16:21:05.176]  elements: ‘x’
[16:21:05.177]  length: 0 (resolved future 1)
[16:21:05.177] resolve() on list ... DONE
[16:21:05.177] - globals: [1] ‘x’
[16:21:05.177] Resolving futures part of globals (recursively) ... DONE
[16:21:05.177] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[16:21:05.178] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[16:21:05.178] - globals: [1] ‘x’
[16:21:05.178] 
[16:21:05.178] getGlobalsAndPackages() ... DONE
[16:21:05.178] run() for ‘Future’ ...
[16:21:05.178] - state: ‘created’
[16:21:05.179] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:05.183] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:05.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:05.183]   - Field: ‘label’
[16:21:05.183]   - Field: ‘local’
[16:21:05.183]   - Field: ‘owner’
[16:21:05.183]   - Field: ‘envir’
[16:21:05.183]   - Field: ‘workers’
[16:21:05.184]   - Field: ‘packages’
[16:21:05.184]   - Field: ‘gc’
[16:21:05.184]   - Field: ‘job’
[16:21:05.184]   - Field: ‘conditions’
[16:21:05.184]   - Field: ‘expr’
[16:21:05.184]   - Field: ‘uuid’
[16:21:05.184]   - Field: ‘seed’
[16:21:05.184]   - Field: ‘version’
[16:21:05.185]   - Field: ‘result’
[16:21:05.185]   - Field: ‘asynchronous’
[16:21:05.185]   - Field: ‘calls’
[16:21:05.185]   - Field: ‘globals’
[16:21:05.185]   - Field: ‘stdout’
[16:21:05.185]   - Field: ‘earlySignal’
[16:21:05.185]   - Field: ‘lazy’
[16:21:05.185]   - Field: ‘state’
[16:21:05.185] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:05.186] - Launch lazy future ...
[16:21:05.186] Packages needed by the future expression (n = 0): <none>
[16:21:05.186] Packages needed by future strategies (n = 0): <none>
[16:21:05.186] {
[16:21:05.186]     {
[16:21:05.186]         {
[16:21:05.186]             ...future.startTime <- base::Sys.time()
[16:21:05.186]             {
[16:21:05.186]                 {
[16:21:05.186]                   {
[16:21:05.186]                     {
[16:21:05.186]                       base::local({
[16:21:05.186]                         has_future <- base::requireNamespace("future", 
[16:21:05.186]                           quietly = TRUE)
[16:21:05.186]                         if (has_future) {
[16:21:05.186]                           ns <- base::getNamespace("future")
[16:21:05.186]                           version <- ns[[".package"]][["version"]]
[16:21:05.186]                           if (is.null(version)) 
[16:21:05.186]                             version <- utils::packageVersion("future")
[16:21:05.186]                         }
[16:21:05.186]                         else {
[16:21:05.186]                           version <- NULL
[16:21:05.186]                         }
[16:21:05.186]                         if (!has_future || version < "1.8.0") {
[16:21:05.186]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.186]                             "", base::R.version$version.string), 
[16:21:05.186]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:05.186]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.186]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.186]                               "release", "version")], collapse = " "), 
[16:21:05.186]                             hostname = base::Sys.info()[["nodename"]])
[16:21:05.186]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.186]                             info)
[16:21:05.186]                           info <- base::paste(info, collapse = "; ")
[16:21:05.186]                           if (!has_future) {
[16:21:05.186]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.186]                               info)
[16:21:05.186]                           }
[16:21:05.186]                           else {
[16:21:05.186]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.186]                               info, version)
[16:21:05.186]                           }
[16:21:05.186]                           base::stop(msg)
[16:21:05.186]                         }
[16:21:05.186]                       })
[16:21:05.186]                     }
[16:21:05.186]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.186]                     base::options(mc.cores = 1L)
[16:21:05.186]                   }
[16:21:05.186]                   ...future.strategy.old <- future::plan("list")
[16:21:05.186]                   options(future.plan = NULL)
[16:21:05.186]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.186]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.186]                 }
[16:21:05.186]                 ...future.workdir <- getwd()
[16:21:05.186]             }
[16:21:05.186]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.186]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.186]         }
[16:21:05.186]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.186]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:05.186]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.186]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.186]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.186]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.186]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.186]             base::names(...future.oldOptions))
[16:21:05.186]     }
[16:21:05.186]     if (FALSE) {
[16:21:05.186]     }
[16:21:05.186]     else {
[16:21:05.186]         if (TRUE) {
[16:21:05.186]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.186]                 open = "w")
[16:21:05.186]         }
[16:21:05.186]         else {
[16:21:05.186]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.186]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.186]         }
[16:21:05.186]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.186]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.186]             base::sink(type = "output", split = FALSE)
[16:21:05.186]             base::close(...future.stdout)
[16:21:05.186]         }, add = TRUE)
[16:21:05.186]     }
[16:21:05.186]     ...future.frame <- base::sys.nframe()
[16:21:05.186]     ...future.conditions <- base::list()
[16:21:05.186]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.186]     if (FALSE) {
[16:21:05.186]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.186]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.186]     }
[16:21:05.186]     ...future.result <- base::tryCatch({
[16:21:05.186]         base::withCallingHandlers({
[16:21:05.186]             ...future.value <- base::withVisible(base::local({
[16:21:05.186]                 withCallingHandlers({
[16:21:05.186]                   {
[16:21:05.186]                     x <- x()
[16:21:05.186]                     x
[16:21:05.186]                   }
[16:21:05.186]                 }, immediateCondition = function(cond) {
[16:21:05.186]                   save_rds <- function (object, pathname, ...) 
[16:21:05.186]                   {
[16:21:05.186]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:05.186]                     if (file_test("-f", pathname_tmp)) {
[16:21:05.186]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.186]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:05.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.186]                         fi_tmp[["mtime"]])
[16:21:05.186]                     }
[16:21:05.186]                     tryCatch({
[16:21:05.186]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:05.186]                     }, error = function(ex) {
[16:21:05.186]                       msg <- conditionMessage(ex)
[16:21:05.186]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.186]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:05.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.186]                         fi_tmp[["mtime"]], msg)
[16:21:05.186]                       ex$message <- msg
[16:21:05.186]                       stop(ex)
[16:21:05.186]                     })
[16:21:05.186]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:05.186]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:05.186]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:05.186]                       fi_tmp <- file.info(pathname_tmp)
[16:21:05.186]                       fi <- file.info(pathname)
[16:21:05.186]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:05.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:05.186]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:05.186]                         fi[["size"]], fi[["mtime"]])
[16:21:05.186]                       stop(msg)
[16:21:05.186]                     }
[16:21:05.186]                     invisible(pathname)
[16:21:05.186]                   }
[16:21:05.186]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:05.186]                     rootPath = tempdir()) 
[16:21:05.186]                   {
[16:21:05.186]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:05.186]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:05.186]                       tmpdir = path, fileext = ".rds")
[16:21:05.186]                     save_rds(obj, file)
[16:21:05.186]                   }
[16:21:05.186]                   saveImmediateCondition(cond, path = "/tmp/RtmpQYw8cu/.future/immediateConditions")
[16:21:05.186]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.186]                   {
[16:21:05.186]                     inherits <- base::inherits
[16:21:05.186]                     invokeRestart <- base::invokeRestart
[16:21:05.186]                     is.null <- base::is.null
[16:21:05.186]                     muffled <- FALSE
[16:21:05.186]                     if (inherits(cond, "message")) {
[16:21:05.186]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.186]                       if (muffled) 
[16:21:05.186]                         invokeRestart("muffleMessage")
[16:21:05.186]                     }
[16:21:05.186]                     else if (inherits(cond, "warning")) {
[16:21:05.186]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.186]                       if (muffled) 
[16:21:05.186]                         invokeRestart("muffleWarning")
[16:21:05.186]                     }
[16:21:05.186]                     else if (inherits(cond, "condition")) {
[16:21:05.186]                       if (!is.null(pattern)) {
[16:21:05.186]                         computeRestarts <- base::computeRestarts
[16:21:05.186]                         grepl <- base::grepl
[16:21:05.186]                         restarts <- computeRestarts(cond)
[16:21:05.186]                         for (restart in restarts) {
[16:21:05.186]                           name <- restart$name
[16:21:05.186]                           if (is.null(name)) 
[16:21:05.186]                             next
[16:21:05.186]                           if (!grepl(pattern, name)) 
[16:21:05.186]                             next
[16:21:05.186]                           invokeRestart(restart)
[16:21:05.186]                           muffled <- TRUE
[16:21:05.186]                           break
[16:21:05.186]                         }
[16:21:05.186]                       }
[16:21:05.186]                     }
[16:21:05.186]                     invisible(muffled)
[16:21:05.186]                   }
[16:21:05.186]                   muffleCondition(cond)
[16:21:05.186]                 })
[16:21:05.186]             }))
[16:21:05.186]             future::FutureResult(value = ...future.value$value, 
[16:21:05.186]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.186]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.186]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.186]                     ...future.globalenv.names))
[16:21:05.186]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.186]         }, condition = base::local({
[16:21:05.186]             c <- base::c
[16:21:05.186]             inherits <- base::inherits
[16:21:05.186]             invokeRestart <- base::invokeRestart
[16:21:05.186]             length <- base::length
[16:21:05.186]             list <- base::list
[16:21:05.186]             seq.int <- base::seq.int
[16:21:05.186]             signalCondition <- base::signalCondition
[16:21:05.186]             sys.calls <- base::sys.calls
[16:21:05.186]             `[[` <- base::`[[`
[16:21:05.186]             `+` <- base::`+`
[16:21:05.186]             `<<-` <- base::`<<-`
[16:21:05.186]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.186]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.186]                   3L)]
[16:21:05.186]             }
[16:21:05.186]             function(cond) {
[16:21:05.186]                 is_error <- inherits(cond, "error")
[16:21:05.186]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.186]                   NULL)
[16:21:05.186]                 if (is_error) {
[16:21:05.186]                   sessionInformation <- function() {
[16:21:05.186]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.186]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.186]                       search = base::search(), system = base::Sys.info())
[16:21:05.186]                   }
[16:21:05.186]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.186]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.186]                     cond$call), session = sessionInformation(), 
[16:21:05.186]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.186]                   signalCondition(cond)
[16:21:05.186]                 }
[16:21:05.186]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.186]                 "immediateCondition"))) {
[16:21:05.186]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.186]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.186]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.186]                   if (TRUE && !signal) {
[16:21:05.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.186]                     {
[16:21:05.186]                       inherits <- base::inherits
[16:21:05.186]                       invokeRestart <- base::invokeRestart
[16:21:05.186]                       is.null <- base::is.null
[16:21:05.186]                       muffled <- FALSE
[16:21:05.186]                       if (inherits(cond, "message")) {
[16:21:05.186]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.186]                         if (muffled) 
[16:21:05.186]                           invokeRestart("muffleMessage")
[16:21:05.186]                       }
[16:21:05.186]                       else if (inherits(cond, "warning")) {
[16:21:05.186]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.186]                         if (muffled) 
[16:21:05.186]                           invokeRestart("muffleWarning")
[16:21:05.186]                       }
[16:21:05.186]                       else if (inherits(cond, "condition")) {
[16:21:05.186]                         if (!is.null(pattern)) {
[16:21:05.186]                           computeRestarts <- base::computeRestarts
[16:21:05.186]                           grepl <- base::grepl
[16:21:05.186]                           restarts <- computeRestarts(cond)
[16:21:05.186]                           for (restart in restarts) {
[16:21:05.186]                             name <- restart$name
[16:21:05.186]                             if (is.null(name)) 
[16:21:05.186]                               next
[16:21:05.186]                             if (!grepl(pattern, name)) 
[16:21:05.186]                               next
[16:21:05.186]                             invokeRestart(restart)
[16:21:05.186]                             muffled <- TRUE
[16:21:05.186]                             break
[16:21:05.186]                           }
[16:21:05.186]                         }
[16:21:05.186]                       }
[16:21:05.186]                       invisible(muffled)
[16:21:05.186]                     }
[16:21:05.186]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.186]                   }
[16:21:05.186]                 }
[16:21:05.186]                 else {
[16:21:05.186]                   if (TRUE) {
[16:21:05.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.186]                     {
[16:21:05.186]                       inherits <- base::inherits
[16:21:05.186]                       invokeRestart <- base::invokeRestart
[16:21:05.186]                       is.null <- base::is.null
[16:21:05.186]                       muffled <- FALSE
[16:21:05.186]                       if (inherits(cond, "message")) {
[16:21:05.186]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.186]                         if (muffled) 
[16:21:05.186]                           invokeRestart("muffleMessage")
[16:21:05.186]                       }
[16:21:05.186]                       else if (inherits(cond, "warning")) {
[16:21:05.186]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.186]                         if (muffled) 
[16:21:05.186]                           invokeRestart("muffleWarning")
[16:21:05.186]                       }
[16:21:05.186]                       else if (inherits(cond, "condition")) {
[16:21:05.186]                         if (!is.null(pattern)) {
[16:21:05.186]                           computeRestarts <- base::computeRestarts
[16:21:05.186]                           grepl <- base::grepl
[16:21:05.186]                           restarts <- computeRestarts(cond)
[16:21:05.186]                           for (restart in restarts) {
[16:21:05.186]                             name <- restart$name
[16:21:05.186]                             if (is.null(name)) 
[16:21:05.186]                               next
[16:21:05.186]                             if (!grepl(pattern, name)) 
[16:21:05.186]                               next
[16:21:05.186]                             invokeRestart(restart)
[16:21:05.186]                             muffled <- TRUE
[16:21:05.186]                             break
[16:21:05.186]                           }
[16:21:05.186]                         }
[16:21:05.186]                       }
[16:21:05.186]                       invisible(muffled)
[16:21:05.186]                     }
[16:21:05.186]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.186]                   }
[16:21:05.186]                 }
[16:21:05.186]             }
[16:21:05.186]         }))
[16:21:05.186]     }, error = function(ex) {
[16:21:05.186]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.186]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.186]                 ...future.rng), started = ...future.startTime, 
[16:21:05.186]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.186]             version = "1.8"), class = "FutureResult")
[16:21:05.186]     }, finally = {
[16:21:05.186]         if (!identical(...future.workdir, getwd())) 
[16:21:05.186]             setwd(...future.workdir)
[16:21:05.186]         {
[16:21:05.186]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.186]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.186]             }
[16:21:05.186]             base::options(...future.oldOptions)
[16:21:05.186]             if (.Platform$OS.type == "windows") {
[16:21:05.186]                 old_names <- names(...future.oldEnvVars)
[16:21:05.186]                 envs <- base::Sys.getenv()
[16:21:05.186]                 names <- names(envs)
[16:21:05.186]                 common <- intersect(names, old_names)
[16:21:05.186]                 added <- setdiff(names, old_names)
[16:21:05.186]                 removed <- setdiff(old_names, names)
[16:21:05.186]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.186]                   envs[common]]
[16:21:05.186]                 NAMES <- toupper(changed)
[16:21:05.186]                 args <- list()
[16:21:05.186]                 for (kk in seq_along(NAMES)) {
[16:21:05.186]                   name <- changed[[kk]]
[16:21:05.186]                   NAME <- NAMES[[kk]]
[16:21:05.186]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.186]                     next
[16:21:05.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.186]                 }
[16:21:05.186]                 NAMES <- toupper(added)
[16:21:05.186]                 for (kk in seq_along(NAMES)) {
[16:21:05.186]                   name <- added[[kk]]
[16:21:05.186]                   NAME <- NAMES[[kk]]
[16:21:05.186]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.186]                     next
[16:21:05.186]                   args[[name]] <- ""
[16:21:05.186]                 }
[16:21:05.186]                 NAMES <- toupper(removed)
[16:21:05.186]                 for (kk in seq_along(NAMES)) {
[16:21:05.186]                   name <- removed[[kk]]
[16:21:05.186]                   NAME <- NAMES[[kk]]
[16:21:05.186]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.186]                     next
[16:21:05.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.186]                 }
[16:21:05.186]                 if (length(args) > 0) 
[16:21:05.186]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.186]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.186]             }
[16:21:05.186]             else {
[16:21:05.186]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.186]             }
[16:21:05.186]             {
[16:21:05.186]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.186]                   0L) {
[16:21:05.186]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.186]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.186]                   base::options(opts)
[16:21:05.186]                 }
[16:21:05.186]                 {
[16:21:05.186]                   {
[16:21:05.186]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.186]                     NULL
[16:21:05.186]                   }
[16:21:05.186]                   options(future.plan = NULL)
[16:21:05.186]                   if (is.na(NA_character_)) 
[16:21:05.186]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.186]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.186]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.186]                     .init = FALSE)
[16:21:05.186]                 }
[16:21:05.186]             }
[16:21:05.186]         }
[16:21:05.186]     })
[16:21:05.186]     if (TRUE) {
[16:21:05.186]         base::sink(type = "output", split = FALSE)
[16:21:05.186]         if (TRUE) {
[16:21:05.186]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.186]         }
[16:21:05.186]         else {
[16:21:05.186]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.186]         }
[16:21:05.186]         base::close(...future.stdout)
[16:21:05.186]         ...future.stdout <- NULL
[16:21:05.186]     }
[16:21:05.186]     ...future.result$conditions <- ...future.conditions
[16:21:05.186]     ...future.result$finished <- base::Sys.time()
[16:21:05.186]     ...future.result
[16:21:05.186] }
[16:21:05.189] assign_globals() ...
[16:21:05.189] List of 1
[16:21:05.189]  $ x:function ()  
[16:21:05.189]  - attr(*, "where")=List of 1
[16:21:05.189]   ..$ x:<environment: R_EmptyEnv> 
[16:21:05.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:05.189]  - attr(*, "resolved")= logi TRUE
[16:21:05.189]  - attr(*, "total_size")= num 1032
[16:21:05.189]  - attr(*, "already-done")= logi TRUE
[16:21:05.192] - reassign environment for ‘x’
[16:21:05.192] - copied ‘x’ to environment
[16:21:05.192] assign_globals() ... done
[16:21:05.193] requestCore(): workers = 2
[16:21:05.195] MulticoreFuture started
[16:21:05.195] - Launch lazy future ... done
[16:21:05.195] run() for ‘MulticoreFuture’ ... done
[16:21:05.196] result() for MulticoreFuture ...
[16:21:05.196] plan(): Setting new future strategy stack:
[16:21:05.196] List of future strategies:
[16:21:05.196] 1. sequential:
[16:21:05.196]    - args: function (..., envir = parent.frame())
[16:21:05.196]    - tweaked: FALSE
[16:21:05.196]    - call: NULL
[16:21:05.197] plan(): nbrOfWorkers() = 1
[16:21:05.199] plan(): Setting new future strategy stack:
[16:21:05.199] List of future strategies:
[16:21:05.199] 1. multicore:
[16:21:05.199]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:05.199]    - tweaked: FALSE
[16:21:05.199]    - call: plan(strategy)
[16:21:05.210] plan(): nbrOfWorkers() = 2
[16:21:05.212] result() for MulticoreFuture ...
[16:21:05.212] result() for MulticoreFuture ... done
[16:21:05.212] result() for MulticoreFuture ... done
[16:21:05.212] result() for MulticoreFuture ...
[16:21:05.212] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[16:21:05.213] plan(): Setting new future strategy stack:
[16:21:05.213] List of future strategies:
[16:21:05.213] 1. multisession:
[16:21:05.213]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:05.213]    - tweaked: FALSE
[16:21:05.213]    - call: plan(strategy)
[16:21:05.214] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:21:05.214] multisession:
[16:21:05.214] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:05.214] - tweaked: FALSE
[16:21:05.214] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:05.225] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:05.225] Not searching for globals
[16:21:05.226] - globals: [0] <none>
[16:21:05.226] getGlobalsAndPackages() ... DONE
[16:21:05.227] [local output] makeClusterPSOCK() ...
[16:21:05.273] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:21:05.274] [local output] Base port: 11170
[16:21:05.274] [local output] Getting setup options for 2 cluster nodes ...
[16:21:05.274] [local output]  - Node 1 of 2 ...
[16:21:05.275] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:05.275] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpQYw8cu/worker.rank=1.parallelly.parent=84150.148b612885c44.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpQYw8cu/worker.rank=1.parallelly.parent=84150.148b612885c44.pid")'’
[16:21:05.467] - Possible to infer worker's PID: TRUE
[16:21:05.467] [local output] Rscript port: 11170

[16:21:05.467] [local output]  - Node 2 of 2 ...
[16:21:05.468] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:05.468] [local output] Rscript port: 11170

[16:21:05.469] [local output] Getting setup options for 2 cluster nodes ... done
[16:21:05.469] [local output]  - Parallel setup requested for some PSOCK nodes
[16:21:05.469] [local output] Setting up PSOCK nodes in parallel
[16:21:05.470] List of 36
[16:21:05.470]  $ worker          : chr "localhost"
[16:21:05.470]   ..- attr(*, "localhost")= logi TRUE
[16:21:05.470]  $ master          : chr "localhost"
[16:21:05.470]  $ port            : int 11170
[16:21:05.470]  $ connectTimeout  : num 120
[16:21:05.470]  $ timeout         : num 2592000
[16:21:05.470]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:21:05.470]  $ homogeneous     : logi TRUE
[16:21:05.470]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:21:05.470]  $ rscript_envs    : NULL
[16:21:05.470]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:05.470]  $ rscript_startup : NULL
[16:21:05.470]  $ rscript_sh      : chr "sh"
[16:21:05.470]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:05.470]  $ methods         : logi TRUE
[16:21:05.470]  $ socketOptions   : chr "no-delay"
[16:21:05.470]  $ useXDR          : logi FALSE
[16:21:05.470]  $ outfile         : chr "/dev/null"
[16:21:05.470]  $ renice          : int NA
[16:21:05.470]  $ rshcmd          : NULL
[16:21:05.470]  $ user            : chr(0) 
[16:21:05.470]  $ revtunnel       : logi FALSE
[16:21:05.470]  $ rshlogfile      : NULL
[16:21:05.470]  $ rshopts         : chr(0) 
[16:21:05.470]  $ rank            : int 1
[16:21:05.470]  $ manual          : logi FALSE
[16:21:05.470]  $ dryrun          : logi FALSE
[16:21:05.470]  $ quiet           : logi FALSE
[16:21:05.470]  $ setup_strategy  : chr "parallel"
[16:21:05.470]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:05.470]  $ pidfile         : chr "/tmp/RtmpQYw8cu/worker.rank=1.parallelly.parent=84150.148b612885c44.pid"
[16:21:05.470]  $ rshcmd_label    : NULL
[16:21:05.470]  $ rsh_call        : NULL
[16:21:05.470]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:05.470]  $ localMachine    : logi TRUE
[16:21:05.470]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:21:05.470]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:21:05.470]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:21:05.470]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:21:05.470]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:21:05.470]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:21:05.470]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:21:05.470]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:21:05.470]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:21:05.470]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:21:05.470]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:21:05.470]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:21:05.470]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:21:05.470]  $ arguments       :List of 28
[16:21:05.470]   ..$ worker          : chr "localhost"
[16:21:05.470]   ..$ master          : NULL
[16:21:05.470]   ..$ port            : int 11170
[16:21:05.470]   ..$ connectTimeout  : num 120
[16:21:05.470]   ..$ timeout         : num 2592000
[16:21:05.470]   ..$ rscript         : NULL
[16:21:05.470]   ..$ homogeneous     : NULL
[16:21:05.470]   ..$ rscript_args    : NULL
[16:21:05.470]   ..$ rscript_envs    : NULL
[16:21:05.470]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:05.470]   ..$ rscript_startup : NULL
[16:21:05.470]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:21:05.470]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:05.470]   ..$ methods         : logi TRUE
[16:21:05.470]   ..$ socketOptions   : chr "no-delay"
[16:21:05.470]   ..$ useXDR          : logi FALSE
[16:21:05.470]   ..$ outfile         : chr "/dev/null"
[16:21:05.470]   ..$ renice          : int NA
[16:21:05.470]   ..$ rshcmd          : NULL
[16:21:05.470]   ..$ user            : NULL
[16:21:05.470]   ..$ revtunnel       : logi NA
[16:21:05.470]   ..$ rshlogfile      : NULL
[16:21:05.470]   ..$ rshopts         : NULL
[16:21:05.470]   ..$ rank            : int 1
[16:21:05.470]   ..$ manual          : logi FALSE
[16:21:05.470]   ..$ dryrun          : logi FALSE
[16:21:05.470]   ..$ quiet           : logi FALSE
[16:21:05.470]   ..$ setup_strategy  : chr "parallel"
[16:21:05.470]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:21:05.486] [local output] System call to launch all workers:
[16:21:05.487] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpQYw8cu/worker.rank=1.parallelly.parent=84150.148b612885c44.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11170 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:21:05.487] [local output] Starting PSOCK main server
[16:21:05.492] [local output] Workers launched
[16:21:05.493] [local output] Waiting for workers to connect back
[16:21:05.493]  - [local output] 0 workers out of 2 ready
[16:21:05.733]  - [local output] 0 workers out of 2 ready
[16:21:05.734]  - [local output] 1 workers out of 2 ready
[16:21:05.748]  - [local output] 1 workers out of 2 ready
[16:21:05.748]  - [local output] 2 workers out of 2 ready
[16:21:05.749] [local output] Launching of workers completed
[16:21:05.749] [local output] Collecting session information from workers
[16:21:05.750] [local output]  - Worker #1 of 2
[16:21:05.750] [local output]  - Worker #2 of 2
[16:21:05.750] [local output] makeClusterPSOCK() ... done
[16:21:05.762] Packages needed by the future expression (n = 0): <none>
[16:21:05.762] Packages needed by future strategies (n = 0): <none>
[16:21:05.762] {
[16:21:05.762]     {
[16:21:05.762]         {
[16:21:05.762]             ...future.startTime <- base::Sys.time()
[16:21:05.762]             {
[16:21:05.762]                 {
[16:21:05.762]                   {
[16:21:05.762]                     {
[16:21:05.762]                       base::local({
[16:21:05.762]                         has_future <- base::requireNamespace("future", 
[16:21:05.762]                           quietly = TRUE)
[16:21:05.762]                         if (has_future) {
[16:21:05.762]                           ns <- base::getNamespace("future")
[16:21:05.762]                           version <- ns[[".package"]][["version"]]
[16:21:05.762]                           if (is.null(version)) 
[16:21:05.762]                             version <- utils::packageVersion("future")
[16:21:05.762]                         }
[16:21:05.762]                         else {
[16:21:05.762]                           version <- NULL
[16:21:05.762]                         }
[16:21:05.762]                         if (!has_future || version < "1.8.0") {
[16:21:05.762]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.762]                             "", base::R.version$version.string), 
[16:21:05.762]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:05.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.762]                               "release", "version")], collapse = " "), 
[16:21:05.762]                             hostname = base::Sys.info()[["nodename"]])
[16:21:05.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.762]                             info)
[16:21:05.762]                           info <- base::paste(info, collapse = "; ")
[16:21:05.762]                           if (!has_future) {
[16:21:05.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.762]                               info)
[16:21:05.762]                           }
[16:21:05.762]                           else {
[16:21:05.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.762]                               info, version)
[16:21:05.762]                           }
[16:21:05.762]                           base::stop(msg)
[16:21:05.762]                         }
[16:21:05.762]                       })
[16:21:05.762]                     }
[16:21:05.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.762]                     base::options(mc.cores = 1L)
[16:21:05.762]                   }
[16:21:05.762]                   ...future.strategy.old <- future::plan("list")
[16:21:05.762]                   options(future.plan = NULL)
[16:21:05.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.762]                 }
[16:21:05.762]                 ...future.workdir <- getwd()
[16:21:05.762]             }
[16:21:05.762]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.762]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.762]         }
[16:21:05.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.762]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:05.762]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.762]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.762]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.762]             base::names(...future.oldOptions))
[16:21:05.762]     }
[16:21:05.762]     if (FALSE) {
[16:21:05.762]     }
[16:21:05.762]     else {
[16:21:05.762]         if (TRUE) {
[16:21:05.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.762]                 open = "w")
[16:21:05.762]         }
[16:21:05.762]         else {
[16:21:05.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.762]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.762]         }
[16:21:05.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.762]             base::sink(type = "output", split = FALSE)
[16:21:05.762]             base::close(...future.stdout)
[16:21:05.762]         }, add = TRUE)
[16:21:05.762]     }
[16:21:05.762]     ...future.frame <- base::sys.nframe()
[16:21:05.762]     ...future.conditions <- base::list()
[16:21:05.762]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.762]     if (FALSE) {
[16:21:05.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.762]     }
[16:21:05.762]     ...future.result <- base::tryCatch({
[16:21:05.762]         base::withCallingHandlers({
[16:21:05.762]             ...future.value <- base::withVisible(base::local({
[16:21:05.762]                 ...future.makeSendCondition <- base::local({
[16:21:05.762]                   sendCondition <- NULL
[16:21:05.762]                   function(frame = 1L) {
[16:21:05.762]                     if (is.function(sendCondition)) 
[16:21:05.762]                       return(sendCondition)
[16:21:05.762]                     ns <- getNamespace("parallel")
[16:21:05.762]                     if (exists("sendData", mode = "function", 
[16:21:05.762]                       envir = ns)) {
[16:21:05.762]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:05.762]                         envir = ns)
[16:21:05.762]                       envir <- sys.frame(frame)
[16:21:05.762]                       master <- NULL
[16:21:05.762]                       while (!identical(envir, .GlobalEnv) && 
[16:21:05.762]                         !identical(envir, emptyenv())) {
[16:21:05.762]                         if (exists("master", mode = "list", envir = envir, 
[16:21:05.762]                           inherits = FALSE)) {
[16:21:05.762]                           master <- get("master", mode = "list", 
[16:21:05.762]                             envir = envir, inherits = FALSE)
[16:21:05.762]                           if (inherits(master, c("SOCKnode", 
[16:21:05.762]                             "SOCK0node"))) {
[16:21:05.762]                             sendCondition <<- function(cond) {
[16:21:05.762]                               data <- list(type = "VALUE", value = cond, 
[16:21:05.762]                                 success = TRUE)
[16:21:05.762]                               parallel_sendData(master, data)
[16:21:05.762]                             }
[16:21:05.762]                             return(sendCondition)
[16:21:05.762]                           }
[16:21:05.762]                         }
[16:21:05.762]                         frame <- frame + 1L
[16:21:05.762]                         envir <- sys.frame(frame)
[16:21:05.762]                       }
[16:21:05.762]                     }
[16:21:05.762]                     sendCondition <<- function(cond) NULL
[16:21:05.762]                   }
[16:21:05.762]                 })
[16:21:05.762]                 withCallingHandlers({
[16:21:05.762]                   NA
[16:21:05.762]                 }, immediateCondition = function(cond) {
[16:21:05.762]                   sendCondition <- ...future.makeSendCondition()
[16:21:05.762]                   sendCondition(cond)
[16:21:05.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.762]                   {
[16:21:05.762]                     inherits <- base::inherits
[16:21:05.762]                     invokeRestart <- base::invokeRestart
[16:21:05.762]                     is.null <- base::is.null
[16:21:05.762]                     muffled <- FALSE
[16:21:05.762]                     if (inherits(cond, "message")) {
[16:21:05.762]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.762]                       if (muffled) 
[16:21:05.762]                         invokeRestart("muffleMessage")
[16:21:05.762]                     }
[16:21:05.762]                     else if (inherits(cond, "warning")) {
[16:21:05.762]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.762]                       if (muffled) 
[16:21:05.762]                         invokeRestart("muffleWarning")
[16:21:05.762]                     }
[16:21:05.762]                     else if (inherits(cond, "condition")) {
[16:21:05.762]                       if (!is.null(pattern)) {
[16:21:05.762]                         computeRestarts <- base::computeRestarts
[16:21:05.762]                         grepl <- base::grepl
[16:21:05.762]                         restarts <- computeRestarts(cond)
[16:21:05.762]                         for (restart in restarts) {
[16:21:05.762]                           name <- restart$name
[16:21:05.762]                           if (is.null(name)) 
[16:21:05.762]                             next
[16:21:05.762]                           if (!grepl(pattern, name)) 
[16:21:05.762]                             next
[16:21:05.762]                           invokeRestart(restart)
[16:21:05.762]                           muffled <- TRUE
[16:21:05.762]                           break
[16:21:05.762]                         }
[16:21:05.762]                       }
[16:21:05.762]                     }
[16:21:05.762]                     invisible(muffled)
[16:21:05.762]                   }
[16:21:05.762]                   muffleCondition(cond)
[16:21:05.762]                 })
[16:21:05.762]             }))
[16:21:05.762]             future::FutureResult(value = ...future.value$value, 
[16:21:05.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.762]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.762]                     ...future.globalenv.names))
[16:21:05.762]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.762]         }, condition = base::local({
[16:21:05.762]             c <- base::c
[16:21:05.762]             inherits <- base::inherits
[16:21:05.762]             invokeRestart <- base::invokeRestart
[16:21:05.762]             length <- base::length
[16:21:05.762]             list <- base::list
[16:21:05.762]             seq.int <- base::seq.int
[16:21:05.762]             signalCondition <- base::signalCondition
[16:21:05.762]             sys.calls <- base::sys.calls
[16:21:05.762]             `[[` <- base::`[[`
[16:21:05.762]             `+` <- base::`+`
[16:21:05.762]             `<<-` <- base::`<<-`
[16:21:05.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.762]                   3L)]
[16:21:05.762]             }
[16:21:05.762]             function(cond) {
[16:21:05.762]                 is_error <- inherits(cond, "error")
[16:21:05.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.762]                   NULL)
[16:21:05.762]                 if (is_error) {
[16:21:05.762]                   sessionInformation <- function() {
[16:21:05.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.762]                       search = base::search(), system = base::Sys.info())
[16:21:05.762]                   }
[16:21:05.762]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.762]                     cond$call), session = sessionInformation(), 
[16:21:05.762]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.762]                   signalCondition(cond)
[16:21:05.762]                 }
[16:21:05.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.762]                 "immediateCondition"))) {
[16:21:05.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.762]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.762]                   if (TRUE && !signal) {
[16:21:05.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.762]                     {
[16:21:05.762]                       inherits <- base::inherits
[16:21:05.762]                       invokeRestart <- base::invokeRestart
[16:21:05.762]                       is.null <- base::is.null
[16:21:05.762]                       muffled <- FALSE
[16:21:05.762]                       if (inherits(cond, "message")) {
[16:21:05.762]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.762]                         if (muffled) 
[16:21:05.762]                           invokeRestart("muffleMessage")
[16:21:05.762]                       }
[16:21:05.762]                       else if (inherits(cond, "warning")) {
[16:21:05.762]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.762]                         if (muffled) 
[16:21:05.762]                           invokeRestart("muffleWarning")
[16:21:05.762]                       }
[16:21:05.762]                       else if (inherits(cond, "condition")) {
[16:21:05.762]                         if (!is.null(pattern)) {
[16:21:05.762]                           computeRestarts <- base::computeRestarts
[16:21:05.762]                           grepl <- base::grepl
[16:21:05.762]                           restarts <- computeRestarts(cond)
[16:21:05.762]                           for (restart in restarts) {
[16:21:05.762]                             name <- restart$name
[16:21:05.762]                             if (is.null(name)) 
[16:21:05.762]                               next
[16:21:05.762]                             if (!grepl(pattern, name)) 
[16:21:05.762]                               next
[16:21:05.762]                             invokeRestart(restart)
[16:21:05.762]                             muffled <- TRUE
[16:21:05.762]                             break
[16:21:05.762]                           }
[16:21:05.762]                         }
[16:21:05.762]                       }
[16:21:05.762]                       invisible(muffled)
[16:21:05.762]                     }
[16:21:05.762]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.762]                   }
[16:21:05.762]                 }
[16:21:05.762]                 else {
[16:21:05.762]                   if (TRUE) {
[16:21:05.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.762]                     {
[16:21:05.762]                       inherits <- base::inherits
[16:21:05.762]                       invokeRestart <- base::invokeRestart
[16:21:05.762]                       is.null <- base::is.null
[16:21:05.762]                       muffled <- FALSE
[16:21:05.762]                       if (inherits(cond, "message")) {
[16:21:05.762]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.762]                         if (muffled) 
[16:21:05.762]                           invokeRestart("muffleMessage")
[16:21:05.762]                       }
[16:21:05.762]                       else if (inherits(cond, "warning")) {
[16:21:05.762]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.762]                         if (muffled) 
[16:21:05.762]                           invokeRestart("muffleWarning")
[16:21:05.762]                       }
[16:21:05.762]                       else if (inherits(cond, "condition")) {
[16:21:05.762]                         if (!is.null(pattern)) {
[16:21:05.762]                           computeRestarts <- base::computeRestarts
[16:21:05.762]                           grepl <- base::grepl
[16:21:05.762]                           restarts <- computeRestarts(cond)
[16:21:05.762]                           for (restart in restarts) {
[16:21:05.762]                             name <- restart$name
[16:21:05.762]                             if (is.null(name)) 
[16:21:05.762]                               next
[16:21:05.762]                             if (!grepl(pattern, name)) 
[16:21:05.762]                               next
[16:21:05.762]                             invokeRestart(restart)
[16:21:05.762]                             muffled <- TRUE
[16:21:05.762]                             break
[16:21:05.762]                           }
[16:21:05.762]                         }
[16:21:05.762]                       }
[16:21:05.762]                       invisible(muffled)
[16:21:05.762]                     }
[16:21:05.762]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.762]                   }
[16:21:05.762]                 }
[16:21:05.762]             }
[16:21:05.762]         }))
[16:21:05.762]     }, error = function(ex) {
[16:21:05.762]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.762]                 ...future.rng), started = ...future.startTime, 
[16:21:05.762]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.762]             version = "1.8"), class = "FutureResult")
[16:21:05.762]     }, finally = {
[16:21:05.762]         if (!identical(...future.workdir, getwd())) 
[16:21:05.762]             setwd(...future.workdir)
[16:21:05.762]         {
[16:21:05.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.762]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.762]             }
[16:21:05.762]             base::options(...future.oldOptions)
[16:21:05.762]             if (.Platform$OS.type == "windows") {
[16:21:05.762]                 old_names <- names(...future.oldEnvVars)
[16:21:05.762]                 envs <- base::Sys.getenv()
[16:21:05.762]                 names <- names(envs)
[16:21:05.762]                 common <- intersect(names, old_names)
[16:21:05.762]                 added <- setdiff(names, old_names)
[16:21:05.762]                 removed <- setdiff(old_names, names)
[16:21:05.762]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.762]                   envs[common]]
[16:21:05.762]                 NAMES <- toupper(changed)
[16:21:05.762]                 args <- list()
[16:21:05.762]                 for (kk in seq_along(NAMES)) {
[16:21:05.762]                   name <- changed[[kk]]
[16:21:05.762]                   NAME <- NAMES[[kk]]
[16:21:05.762]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.762]                     next
[16:21:05.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.762]                 }
[16:21:05.762]                 NAMES <- toupper(added)
[16:21:05.762]                 for (kk in seq_along(NAMES)) {
[16:21:05.762]                   name <- added[[kk]]
[16:21:05.762]                   NAME <- NAMES[[kk]]
[16:21:05.762]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.762]                     next
[16:21:05.762]                   args[[name]] <- ""
[16:21:05.762]                 }
[16:21:05.762]                 NAMES <- toupper(removed)
[16:21:05.762]                 for (kk in seq_along(NAMES)) {
[16:21:05.762]                   name <- removed[[kk]]
[16:21:05.762]                   NAME <- NAMES[[kk]]
[16:21:05.762]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.762]                     next
[16:21:05.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.762]                 }
[16:21:05.762]                 if (length(args) > 0) 
[16:21:05.762]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.762]             }
[16:21:05.762]             else {
[16:21:05.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.762]             }
[16:21:05.762]             {
[16:21:05.762]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.762]                   0L) {
[16:21:05.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.762]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.762]                   base::options(opts)
[16:21:05.762]                 }
[16:21:05.762]                 {
[16:21:05.762]                   {
[16:21:05.762]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.762]                     NULL
[16:21:05.762]                   }
[16:21:05.762]                   options(future.plan = NULL)
[16:21:05.762]                   if (is.na(NA_character_)) 
[16:21:05.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.762]                     .init = FALSE)
[16:21:05.762]                 }
[16:21:05.762]             }
[16:21:05.762]         }
[16:21:05.762]     })
[16:21:05.762]     if (TRUE) {
[16:21:05.762]         base::sink(type = "output", split = FALSE)
[16:21:05.762]         if (TRUE) {
[16:21:05.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.762]         }
[16:21:05.762]         else {
[16:21:05.762]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.762]         }
[16:21:05.762]         base::close(...future.stdout)
[16:21:05.762]         ...future.stdout <- NULL
[16:21:05.762]     }
[16:21:05.762]     ...future.result$conditions <- ...future.conditions
[16:21:05.762]     ...future.result$finished <- base::Sys.time()
[16:21:05.762]     ...future.result
[16:21:05.762] }
[16:21:05.815] MultisessionFuture started
[16:21:05.816] result() for ClusterFuture ...
[16:21:05.816] receiveMessageFromWorker() for ClusterFuture ...
[16:21:05.816] - Validating connection of MultisessionFuture
[16:21:05.849] - received message: FutureResult
[16:21:05.849] - Received FutureResult
[16:21:05.849] - Erased future from FutureRegistry
[16:21:05.849] result() for ClusterFuture ...
[16:21:05.849] - result already collected: FutureResult
[16:21:05.850] result() for ClusterFuture ... done
[16:21:05.850] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:05.850] result() for ClusterFuture ... done
[16:21:05.850] result() for ClusterFuture ...
[16:21:05.850] - result already collected: FutureResult
[16:21:05.850] result() for ClusterFuture ... done
[16:21:05.850] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:21:05.854] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:05.855] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:05.855] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:05.857] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:21:05.857] Searching for globals ... DONE
[16:21:05.857] Resolving globals: TRUE
[16:21:05.857] Resolving any globals that are futures ...
[16:21:05.858] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:21:05.858] Resolving any globals that are futures ... DONE
[16:21:05.858] 
[16:21:05.858] 
[16:21:05.858] getGlobalsAndPackages() ... DONE
[16:21:05.859] run() for ‘Future’ ...
[16:21:05.859] - state: ‘created’
[16:21:05.859] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:05.873] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:05.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:05.874]   - Field: ‘node’
[16:21:05.874]   - Field: ‘label’
[16:21:05.874]   - Field: ‘local’
[16:21:05.874]   - Field: ‘owner’
[16:21:05.874]   - Field: ‘envir’
[16:21:05.874]   - Field: ‘workers’
[16:21:05.874]   - Field: ‘packages’
[16:21:05.874]   - Field: ‘gc’
[16:21:05.874]   - Field: ‘conditions’
[16:21:05.875]   - Field: ‘persistent’
[16:21:05.875]   - Field: ‘expr’
[16:21:05.875]   - Field: ‘uuid’
[16:21:05.875]   - Field: ‘seed’
[16:21:05.875]   - Field: ‘version’
[16:21:05.875]   - Field: ‘result’
[16:21:05.875]   - Field: ‘asynchronous’
[16:21:05.875]   - Field: ‘calls’
[16:21:05.876]   - Field: ‘globals’
[16:21:05.876]   - Field: ‘stdout’
[16:21:05.876]   - Field: ‘earlySignal’
[16:21:05.876]   - Field: ‘lazy’
[16:21:05.876]   - Field: ‘state’
[16:21:05.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:05.876] - Launch lazy future ...
[16:21:05.877] Packages needed by the future expression (n = 0): <none>
[16:21:05.877] Packages needed by future strategies (n = 0): <none>
[16:21:05.877] {
[16:21:05.877]     {
[16:21:05.877]         {
[16:21:05.877]             ...future.startTime <- base::Sys.time()
[16:21:05.877]             {
[16:21:05.877]                 {
[16:21:05.877]                   {
[16:21:05.877]                     {
[16:21:05.877]                       base::local({
[16:21:05.877]                         has_future <- base::requireNamespace("future", 
[16:21:05.877]                           quietly = TRUE)
[16:21:05.877]                         if (has_future) {
[16:21:05.877]                           ns <- base::getNamespace("future")
[16:21:05.877]                           version <- ns[[".package"]][["version"]]
[16:21:05.877]                           if (is.null(version)) 
[16:21:05.877]                             version <- utils::packageVersion("future")
[16:21:05.877]                         }
[16:21:05.877]                         else {
[16:21:05.877]                           version <- NULL
[16:21:05.877]                         }
[16:21:05.877]                         if (!has_future || version < "1.8.0") {
[16:21:05.877]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.877]                             "", base::R.version$version.string), 
[16:21:05.877]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:05.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.877]                               "release", "version")], collapse = " "), 
[16:21:05.877]                             hostname = base::Sys.info()[["nodename"]])
[16:21:05.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.877]                             info)
[16:21:05.877]                           info <- base::paste(info, collapse = "; ")
[16:21:05.877]                           if (!has_future) {
[16:21:05.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.877]                               info)
[16:21:05.877]                           }
[16:21:05.877]                           else {
[16:21:05.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.877]                               info, version)
[16:21:05.877]                           }
[16:21:05.877]                           base::stop(msg)
[16:21:05.877]                         }
[16:21:05.877]                       })
[16:21:05.877]                     }
[16:21:05.877]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.877]                     base::options(mc.cores = 1L)
[16:21:05.877]                   }
[16:21:05.877]                   ...future.strategy.old <- future::plan("list")
[16:21:05.877]                   options(future.plan = NULL)
[16:21:05.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.877]                 }
[16:21:05.877]                 ...future.workdir <- getwd()
[16:21:05.877]             }
[16:21:05.877]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.877]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.877]         }
[16:21:05.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.877]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:05.877]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.877]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.877]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.877]             base::names(...future.oldOptions))
[16:21:05.877]     }
[16:21:05.877]     if (FALSE) {
[16:21:05.877]     }
[16:21:05.877]     else {
[16:21:05.877]         if (TRUE) {
[16:21:05.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.877]                 open = "w")
[16:21:05.877]         }
[16:21:05.877]         else {
[16:21:05.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.877]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.877]         }
[16:21:05.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.877]             base::sink(type = "output", split = FALSE)
[16:21:05.877]             base::close(...future.stdout)
[16:21:05.877]         }, add = TRUE)
[16:21:05.877]     }
[16:21:05.877]     ...future.frame <- base::sys.nframe()
[16:21:05.877]     ...future.conditions <- base::list()
[16:21:05.877]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.877]     if (FALSE) {
[16:21:05.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.877]     }
[16:21:05.877]     ...future.result <- base::tryCatch({
[16:21:05.877]         base::withCallingHandlers({
[16:21:05.877]             ...future.value <- base::withVisible(base::local({
[16:21:05.877]                 ...future.makeSendCondition <- base::local({
[16:21:05.877]                   sendCondition <- NULL
[16:21:05.877]                   function(frame = 1L) {
[16:21:05.877]                     if (is.function(sendCondition)) 
[16:21:05.877]                       return(sendCondition)
[16:21:05.877]                     ns <- getNamespace("parallel")
[16:21:05.877]                     if (exists("sendData", mode = "function", 
[16:21:05.877]                       envir = ns)) {
[16:21:05.877]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:05.877]                         envir = ns)
[16:21:05.877]                       envir <- sys.frame(frame)
[16:21:05.877]                       master <- NULL
[16:21:05.877]                       while (!identical(envir, .GlobalEnv) && 
[16:21:05.877]                         !identical(envir, emptyenv())) {
[16:21:05.877]                         if (exists("master", mode = "list", envir = envir, 
[16:21:05.877]                           inherits = FALSE)) {
[16:21:05.877]                           master <- get("master", mode = "list", 
[16:21:05.877]                             envir = envir, inherits = FALSE)
[16:21:05.877]                           if (inherits(master, c("SOCKnode", 
[16:21:05.877]                             "SOCK0node"))) {
[16:21:05.877]                             sendCondition <<- function(cond) {
[16:21:05.877]                               data <- list(type = "VALUE", value = cond, 
[16:21:05.877]                                 success = TRUE)
[16:21:05.877]                               parallel_sendData(master, data)
[16:21:05.877]                             }
[16:21:05.877]                             return(sendCondition)
[16:21:05.877]                           }
[16:21:05.877]                         }
[16:21:05.877]                         frame <- frame + 1L
[16:21:05.877]                         envir <- sys.frame(frame)
[16:21:05.877]                       }
[16:21:05.877]                     }
[16:21:05.877]                     sendCondition <<- function(cond) NULL
[16:21:05.877]                   }
[16:21:05.877]                 })
[16:21:05.877]                 withCallingHandlers({
[16:21:05.877]                   {
[16:21:05.877]                     b <- a
[16:21:05.877]                     a <- 2
[16:21:05.877]                     a * b
[16:21:05.877]                   }
[16:21:05.877]                 }, immediateCondition = function(cond) {
[16:21:05.877]                   sendCondition <- ...future.makeSendCondition()
[16:21:05.877]                   sendCondition(cond)
[16:21:05.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.877]                   {
[16:21:05.877]                     inherits <- base::inherits
[16:21:05.877]                     invokeRestart <- base::invokeRestart
[16:21:05.877]                     is.null <- base::is.null
[16:21:05.877]                     muffled <- FALSE
[16:21:05.877]                     if (inherits(cond, "message")) {
[16:21:05.877]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.877]                       if (muffled) 
[16:21:05.877]                         invokeRestart("muffleMessage")
[16:21:05.877]                     }
[16:21:05.877]                     else if (inherits(cond, "warning")) {
[16:21:05.877]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.877]                       if (muffled) 
[16:21:05.877]                         invokeRestart("muffleWarning")
[16:21:05.877]                     }
[16:21:05.877]                     else if (inherits(cond, "condition")) {
[16:21:05.877]                       if (!is.null(pattern)) {
[16:21:05.877]                         computeRestarts <- base::computeRestarts
[16:21:05.877]                         grepl <- base::grepl
[16:21:05.877]                         restarts <- computeRestarts(cond)
[16:21:05.877]                         for (restart in restarts) {
[16:21:05.877]                           name <- restart$name
[16:21:05.877]                           if (is.null(name)) 
[16:21:05.877]                             next
[16:21:05.877]                           if (!grepl(pattern, name)) 
[16:21:05.877]                             next
[16:21:05.877]                           invokeRestart(restart)
[16:21:05.877]                           muffled <- TRUE
[16:21:05.877]                           break
[16:21:05.877]                         }
[16:21:05.877]                       }
[16:21:05.877]                     }
[16:21:05.877]                     invisible(muffled)
[16:21:05.877]                   }
[16:21:05.877]                   muffleCondition(cond)
[16:21:05.877]                 })
[16:21:05.877]             }))
[16:21:05.877]             future::FutureResult(value = ...future.value$value, 
[16:21:05.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.877]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.877]                     ...future.globalenv.names))
[16:21:05.877]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.877]         }, condition = base::local({
[16:21:05.877]             c <- base::c
[16:21:05.877]             inherits <- base::inherits
[16:21:05.877]             invokeRestart <- base::invokeRestart
[16:21:05.877]             length <- base::length
[16:21:05.877]             list <- base::list
[16:21:05.877]             seq.int <- base::seq.int
[16:21:05.877]             signalCondition <- base::signalCondition
[16:21:05.877]             sys.calls <- base::sys.calls
[16:21:05.877]             `[[` <- base::`[[`
[16:21:05.877]             `+` <- base::`+`
[16:21:05.877]             `<<-` <- base::`<<-`
[16:21:05.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.877]                   3L)]
[16:21:05.877]             }
[16:21:05.877]             function(cond) {
[16:21:05.877]                 is_error <- inherits(cond, "error")
[16:21:05.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.877]                   NULL)
[16:21:05.877]                 if (is_error) {
[16:21:05.877]                   sessionInformation <- function() {
[16:21:05.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.877]                       search = base::search(), system = base::Sys.info())
[16:21:05.877]                   }
[16:21:05.877]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.877]                     cond$call), session = sessionInformation(), 
[16:21:05.877]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.877]                   signalCondition(cond)
[16:21:05.877]                 }
[16:21:05.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.877]                 "immediateCondition"))) {
[16:21:05.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.877]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.877]                   if (TRUE && !signal) {
[16:21:05.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.877]                     {
[16:21:05.877]                       inherits <- base::inherits
[16:21:05.877]                       invokeRestart <- base::invokeRestart
[16:21:05.877]                       is.null <- base::is.null
[16:21:05.877]                       muffled <- FALSE
[16:21:05.877]                       if (inherits(cond, "message")) {
[16:21:05.877]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.877]                         if (muffled) 
[16:21:05.877]                           invokeRestart("muffleMessage")
[16:21:05.877]                       }
[16:21:05.877]                       else if (inherits(cond, "warning")) {
[16:21:05.877]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.877]                         if (muffled) 
[16:21:05.877]                           invokeRestart("muffleWarning")
[16:21:05.877]                       }
[16:21:05.877]                       else if (inherits(cond, "condition")) {
[16:21:05.877]                         if (!is.null(pattern)) {
[16:21:05.877]                           computeRestarts <- base::computeRestarts
[16:21:05.877]                           grepl <- base::grepl
[16:21:05.877]                           restarts <- computeRestarts(cond)
[16:21:05.877]                           for (restart in restarts) {
[16:21:05.877]                             name <- restart$name
[16:21:05.877]                             if (is.null(name)) 
[16:21:05.877]                               next
[16:21:05.877]                             if (!grepl(pattern, name)) 
[16:21:05.877]                               next
[16:21:05.877]                             invokeRestart(restart)
[16:21:05.877]                             muffled <- TRUE
[16:21:05.877]                             break
[16:21:05.877]                           }
[16:21:05.877]                         }
[16:21:05.877]                       }
[16:21:05.877]                       invisible(muffled)
[16:21:05.877]                     }
[16:21:05.877]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.877]                   }
[16:21:05.877]                 }
[16:21:05.877]                 else {
[16:21:05.877]                   if (TRUE) {
[16:21:05.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.877]                     {
[16:21:05.877]                       inherits <- base::inherits
[16:21:05.877]                       invokeRestart <- base::invokeRestart
[16:21:05.877]                       is.null <- base::is.null
[16:21:05.877]                       muffled <- FALSE
[16:21:05.877]                       if (inherits(cond, "message")) {
[16:21:05.877]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.877]                         if (muffled) 
[16:21:05.877]                           invokeRestart("muffleMessage")
[16:21:05.877]                       }
[16:21:05.877]                       else if (inherits(cond, "warning")) {
[16:21:05.877]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.877]                         if (muffled) 
[16:21:05.877]                           invokeRestart("muffleWarning")
[16:21:05.877]                       }
[16:21:05.877]                       else if (inherits(cond, "condition")) {
[16:21:05.877]                         if (!is.null(pattern)) {
[16:21:05.877]                           computeRestarts <- base::computeRestarts
[16:21:05.877]                           grepl <- base::grepl
[16:21:05.877]                           restarts <- computeRestarts(cond)
[16:21:05.877]                           for (restart in restarts) {
[16:21:05.877]                             name <- restart$name
[16:21:05.877]                             if (is.null(name)) 
[16:21:05.877]                               next
[16:21:05.877]                             if (!grepl(pattern, name)) 
[16:21:05.877]                               next
[16:21:05.877]                             invokeRestart(restart)
[16:21:05.877]                             muffled <- TRUE
[16:21:05.877]                             break
[16:21:05.877]                           }
[16:21:05.877]                         }
[16:21:05.877]                       }
[16:21:05.877]                       invisible(muffled)
[16:21:05.877]                     }
[16:21:05.877]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.877]                   }
[16:21:05.877]                 }
[16:21:05.877]             }
[16:21:05.877]         }))
[16:21:05.877]     }, error = function(ex) {
[16:21:05.877]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.877]                 ...future.rng), started = ...future.startTime, 
[16:21:05.877]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.877]             version = "1.8"), class = "FutureResult")
[16:21:05.877]     }, finally = {
[16:21:05.877]         if (!identical(...future.workdir, getwd())) 
[16:21:05.877]             setwd(...future.workdir)
[16:21:05.877]         {
[16:21:05.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.877]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.877]             }
[16:21:05.877]             base::options(...future.oldOptions)
[16:21:05.877]             if (.Platform$OS.type == "windows") {
[16:21:05.877]                 old_names <- names(...future.oldEnvVars)
[16:21:05.877]                 envs <- base::Sys.getenv()
[16:21:05.877]                 names <- names(envs)
[16:21:05.877]                 common <- intersect(names, old_names)
[16:21:05.877]                 added <- setdiff(names, old_names)
[16:21:05.877]                 removed <- setdiff(old_names, names)
[16:21:05.877]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.877]                   envs[common]]
[16:21:05.877]                 NAMES <- toupper(changed)
[16:21:05.877]                 args <- list()
[16:21:05.877]                 for (kk in seq_along(NAMES)) {
[16:21:05.877]                   name <- changed[[kk]]
[16:21:05.877]                   NAME <- NAMES[[kk]]
[16:21:05.877]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.877]                     next
[16:21:05.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.877]                 }
[16:21:05.877]                 NAMES <- toupper(added)
[16:21:05.877]                 for (kk in seq_along(NAMES)) {
[16:21:05.877]                   name <- added[[kk]]
[16:21:05.877]                   NAME <- NAMES[[kk]]
[16:21:05.877]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.877]                     next
[16:21:05.877]                   args[[name]] <- ""
[16:21:05.877]                 }
[16:21:05.877]                 NAMES <- toupper(removed)
[16:21:05.877]                 for (kk in seq_along(NAMES)) {
[16:21:05.877]                   name <- removed[[kk]]
[16:21:05.877]                   NAME <- NAMES[[kk]]
[16:21:05.877]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.877]                     next
[16:21:05.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.877]                 }
[16:21:05.877]                 if (length(args) > 0) 
[16:21:05.877]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.877]             }
[16:21:05.877]             else {
[16:21:05.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.877]             }
[16:21:05.877]             {
[16:21:05.877]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.877]                   0L) {
[16:21:05.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.877]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.877]                   base::options(opts)
[16:21:05.877]                 }
[16:21:05.877]                 {
[16:21:05.877]                   {
[16:21:05.877]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.877]                     NULL
[16:21:05.877]                   }
[16:21:05.877]                   options(future.plan = NULL)
[16:21:05.877]                   if (is.na(NA_character_)) 
[16:21:05.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.877]                     .init = FALSE)
[16:21:05.877]                 }
[16:21:05.877]             }
[16:21:05.877]         }
[16:21:05.877]     })
[16:21:05.877]     if (TRUE) {
[16:21:05.877]         base::sink(type = "output", split = FALSE)
[16:21:05.877]         if (TRUE) {
[16:21:05.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.877]         }
[16:21:05.877]         else {
[16:21:05.877]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.877]         }
[16:21:05.877]         base::close(...future.stdout)
[16:21:05.877]         ...future.stdout <- NULL
[16:21:05.877]     }
[16:21:05.877]     ...future.result$conditions <- ...future.conditions
[16:21:05.877]     ...future.result$finished <- base::Sys.time()
[16:21:05.877]     ...future.result
[16:21:05.877] }
[16:21:05.881] MultisessionFuture started
[16:21:05.881] - Launch lazy future ... done
[16:21:05.881] run() for ‘MultisessionFuture’ ... done
[16:21:05.881] result() for ClusterFuture ...
[16:21:05.881] receiveMessageFromWorker() for ClusterFuture ...
[16:21:05.881] - Validating connection of MultisessionFuture
[16:21:05.886] - received message: FutureResult
[16:21:05.886] - Received FutureResult
[16:21:05.886] - Erased future from FutureRegistry
[16:21:05.887] result() for ClusterFuture ...
[16:21:05.887] - result already collected: FutureResult
[16:21:05.887] result() for ClusterFuture ... done
[16:21:05.887] signalConditions() ...
[16:21:05.887]  - include = ‘immediateCondition’
[16:21:05.887]  - exclude = 
[16:21:05.887]  - resignal = FALSE
[16:21:05.887]  - Number of conditions: 1
[16:21:05.887] signalConditions() ... done
[16:21:05.888] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:05.888] result() for ClusterFuture ... done
[16:21:05.888] result() for ClusterFuture ...
[16:21:05.888] - result already collected: FutureResult
[16:21:05.888] result() for ClusterFuture ... done
[16:21:05.888] signalConditions() ...
[16:21:05.888]  - include = ‘immediateCondition’
[16:21:05.888]  - exclude = 
[16:21:05.888]  - resignal = FALSE
[16:21:05.889]  - Number of conditions: 1
[16:21:05.889] signalConditions() ... done
[16:21:05.889] Future state: ‘finished’
[16:21:05.889] result() for ClusterFuture ...
[16:21:05.889] - result already collected: FutureResult
[16:21:05.889] result() for ClusterFuture ... done
[16:21:05.889] signalConditions() ...
[16:21:05.889]  - include = ‘condition’
[16:21:05.889]  - exclude = ‘immediateCondition’
[16:21:05.890]  - resignal = TRUE
[16:21:05.890]  - Number of conditions: 1
[16:21:05.890]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:21:05.890] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "b478068843b5" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:21:05"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:05.906] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:05.907] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:05.908] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:21:05.908] Searching for globals ... DONE
[16:21:05.909] Resolving globals: TRUE
[16:21:05.909] Resolving any globals that are futures ...
[16:21:05.909] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:21:05.909] Resolving any globals that are futures ... DONE
[16:21:05.909] 
[16:21:05.909] 
[16:21:05.910] getGlobalsAndPackages() ... DONE
[16:21:05.910] run() for ‘Future’ ...
[16:21:05.910] - state: ‘created’
[16:21:05.910] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:05.925] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:05.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:05.925]   - Field: ‘node’
[16:21:05.926]   - Field: ‘label’
[16:21:05.926]   - Field: ‘local’
[16:21:05.926]   - Field: ‘owner’
[16:21:05.926]   - Field: ‘envir’
[16:21:05.926]   - Field: ‘workers’
[16:21:05.926]   - Field: ‘packages’
[16:21:05.926]   - Field: ‘gc’
[16:21:05.926]   - Field: ‘conditions’
[16:21:05.926]   - Field: ‘persistent’
[16:21:05.926]   - Field: ‘expr’
[16:21:05.927]   - Field: ‘uuid’
[16:21:05.927]   - Field: ‘seed’
[16:21:05.927]   - Field: ‘version’
[16:21:05.927]   - Field: ‘result’
[16:21:05.927]   - Field: ‘asynchronous’
[16:21:05.927]   - Field: ‘calls’
[16:21:05.927]   - Field: ‘globals’
[16:21:05.927]   - Field: ‘stdout’
[16:21:05.928]   - Field: ‘earlySignal’
[16:21:05.928]   - Field: ‘lazy’
[16:21:05.928]   - Field: ‘state’
[16:21:05.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:05.928] - Launch lazy future ...
[16:21:05.928] Packages needed by the future expression (n = 0): <none>
[16:21:05.929] Packages needed by future strategies (n = 0): <none>
[16:21:05.929] {
[16:21:05.929]     {
[16:21:05.929]         {
[16:21:05.929]             ...future.startTime <- base::Sys.time()
[16:21:05.929]             {
[16:21:05.929]                 {
[16:21:05.929]                   {
[16:21:05.929]                     {
[16:21:05.929]                       base::local({
[16:21:05.929]                         has_future <- base::requireNamespace("future", 
[16:21:05.929]                           quietly = TRUE)
[16:21:05.929]                         if (has_future) {
[16:21:05.929]                           ns <- base::getNamespace("future")
[16:21:05.929]                           version <- ns[[".package"]][["version"]]
[16:21:05.929]                           if (is.null(version)) 
[16:21:05.929]                             version <- utils::packageVersion("future")
[16:21:05.929]                         }
[16:21:05.929]                         else {
[16:21:05.929]                           version <- NULL
[16:21:05.929]                         }
[16:21:05.929]                         if (!has_future || version < "1.8.0") {
[16:21:05.929]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.929]                             "", base::R.version$version.string), 
[16:21:05.929]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:05.929]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.929]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.929]                               "release", "version")], collapse = " "), 
[16:21:05.929]                             hostname = base::Sys.info()[["nodename"]])
[16:21:05.929]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.929]                             info)
[16:21:05.929]                           info <- base::paste(info, collapse = "; ")
[16:21:05.929]                           if (!has_future) {
[16:21:05.929]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.929]                               info)
[16:21:05.929]                           }
[16:21:05.929]                           else {
[16:21:05.929]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.929]                               info, version)
[16:21:05.929]                           }
[16:21:05.929]                           base::stop(msg)
[16:21:05.929]                         }
[16:21:05.929]                       })
[16:21:05.929]                     }
[16:21:05.929]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.929]                     base::options(mc.cores = 1L)
[16:21:05.929]                   }
[16:21:05.929]                   ...future.strategy.old <- future::plan("list")
[16:21:05.929]                   options(future.plan = NULL)
[16:21:05.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.929]                 }
[16:21:05.929]                 ...future.workdir <- getwd()
[16:21:05.929]             }
[16:21:05.929]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.929]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.929]         }
[16:21:05.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.929]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:05.929]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.929]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.929]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.929]             base::names(...future.oldOptions))
[16:21:05.929]     }
[16:21:05.929]     if (FALSE) {
[16:21:05.929]     }
[16:21:05.929]     else {
[16:21:05.929]         if (TRUE) {
[16:21:05.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.929]                 open = "w")
[16:21:05.929]         }
[16:21:05.929]         else {
[16:21:05.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.929]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.929]         }
[16:21:05.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.929]             base::sink(type = "output", split = FALSE)
[16:21:05.929]             base::close(...future.stdout)
[16:21:05.929]         }, add = TRUE)
[16:21:05.929]     }
[16:21:05.929]     ...future.frame <- base::sys.nframe()
[16:21:05.929]     ...future.conditions <- base::list()
[16:21:05.929]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.929]     if (FALSE) {
[16:21:05.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.929]     }
[16:21:05.929]     ...future.result <- base::tryCatch({
[16:21:05.929]         base::withCallingHandlers({
[16:21:05.929]             ...future.value <- base::withVisible(base::local({
[16:21:05.929]                 ...future.makeSendCondition <- base::local({
[16:21:05.929]                   sendCondition <- NULL
[16:21:05.929]                   function(frame = 1L) {
[16:21:05.929]                     if (is.function(sendCondition)) 
[16:21:05.929]                       return(sendCondition)
[16:21:05.929]                     ns <- getNamespace("parallel")
[16:21:05.929]                     if (exists("sendData", mode = "function", 
[16:21:05.929]                       envir = ns)) {
[16:21:05.929]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:05.929]                         envir = ns)
[16:21:05.929]                       envir <- sys.frame(frame)
[16:21:05.929]                       master <- NULL
[16:21:05.929]                       while (!identical(envir, .GlobalEnv) && 
[16:21:05.929]                         !identical(envir, emptyenv())) {
[16:21:05.929]                         if (exists("master", mode = "list", envir = envir, 
[16:21:05.929]                           inherits = FALSE)) {
[16:21:05.929]                           master <- get("master", mode = "list", 
[16:21:05.929]                             envir = envir, inherits = FALSE)
[16:21:05.929]                           if (inherits(master, c("SOCKnode", 
[16:21:05.929]                             "SOCK0node"))) {
[16:21:05.929]                             sendCondition <<- function(cond) {
[16:21:05.929]                               data <- list(type = "VALUE", value = cond, 
[16:21:05.929]                                 success = TRUE)
[16:21:05.929]                               parallel_sendData(master, data)
[16:21:05.929]                             }
[16:21:05.929]                             return(sendCondition)
[16:21:05.929]                           }
[16:21:05.929]                         }
[16:21:05.929]                         frame <- frame + 1L
[16:21:05.929]                         envir <- sys.frame(frame)
[16:21:05.929]                       }
[16:21:05.929]                     }
[16:21:05.929]                     sendCondition <<- function(cond) NULL
[16:21:05.929]                   }
[16:21:05.929]                 })
[16:21:05.929]                 withCallingHandlers({
[16:21:05.929]                   {
[16:21:05.929]                     b <- a
[16:21:05.929]                     a <- 2
[16:21:05.929]                     a * b
[16:21:05.929]                   }
[16:21:05.929]                 }, immediateCondition = function(cond) {
[16:21:05.929]                   sendCondition <- ...future.makeSendCondition()
[16:21:05.929]                   sendCondition(cond)
[16:21:05.929]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.929]                   {
[16:21:05.929]                     inherits <- base::inherits
[16:21:05.929]                     invokeRestart <- base::invokeRestart
[16:21:05.929]                     is.null <- base::is.null
[16:21:05.929]                     muffled <- FALSE
[16:21:05.929]                     if (inherits(cond, "message")) {
[16:21:05.929]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.929]                       if (muffled) 
[16:21:05.929]                         invokeRestart("muffleMessage")
[16:21:05.929]                     }
[16:21:05.929]                     else if (inherits(cond, "warning")) {
[16:21:05.929]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.929]                       if (muffled) 
[16:21:05.929]                         invokeRestart("muffleWarning")
[16:21:05.929]                     }
[16:21:05.929]                     else if (inherits(cond, "condition")) {
[16:21:05.929]                       if (!is.null(pattern)) {
[16:21:05.929]                         computeRestarts <- base::computeRestarts
[16:21:05.929]                         grepl <- base::grepl
[16:21:05.929]                         restarts <- computeRestarts(cond)
[16:21:05.929]                         for (restart in restarts) {
[16:21:05.929]                           name <- restart$name
[16:21:05.929]                           if (is.null(name)) 
[16:21:05.929]                             next
[16:21:05.929]                           if (!grepl(pattern, name)) 
[16:21:05.929]                             next
[16:21:05.929]                           invokeRestart(restart)
[16:21:05.929]                           muffled <- TRUE
[16:21:05.929]                           break
[16:21:05.929]                         }
[16:21:05.929]                       }
[16:21:05.929]                     }
[16:21:05.929]                     invisible(muffled)
[16:21:05.929]                   }
[16:21:05.929]                   muffleCondition(cond)
[16:21:05.929]                 })
[16:21:05.929]             }))
[16:21:05.929]             future::FutureResult(value = ...future.value$value, 
[16:21:05.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.929]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.929]                     ...future.globalenv.names))
[16:21:05.929]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.929]         }, condition = base::local({
[16:21:05.929]             c <- base::c
[16:21:05.929]             inherits <- base::inherits
[16:21:05.929]             invokeRestart <- base::invokeRestart
[16:21:05.929]             length <- base::length
[16:21:05.929]             list <- base::list
[16:21:05.929]             seq.int <- base::seq.int
[16:21:05.929]             signalCondition <- base::signalCondition
[16:21:05.929]             sys.calls <- base::sys.calls
[16:21:05.929]             `[[` <- base::`[[`
[16:21:05.929]             `+` <- base::`+`
[16:21:05.929]             `<<-` <- base::`<<-`
[16:21:05.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.929]                   3L)]
[16:21:05.929]             }
[16:21:05.929]             function(cond) {
[16:21:05.929]                 is_error <- inherits(cond, "error")
[16:21:05.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.929]                   NULL)
[16:21:05.929]                 if (is_error) {
[16:21:05.929]                   sessionInformation <- function() {
[16:21:05.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.929]                       search = base::search(), system = base::Sys.info())
[16:21:05.929]                   }
[16:21:05.929]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.929]                     cond$call), session = sessionInformation(), 
[16:21:05.929]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.929]                   signalCondition(cond)
[16:21:05.929]                 }
[16:21:05.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.929]                 "immediateCondition"))) {
[16:21:05.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.929]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.929]                   if (TRUE && !signal) {
[16:21:05.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.929]                     {
[16:21:05.929]                       inherits <- base::inherits
[16:21:05.929]                       invokeRestart <- base::invokeRestart
[16:21:05.929]                       is.null <- base::is.null
[16:21:05.929]                       muffled <- FALSE
[16:21:05.929]                       if (inherits(cond, "message")) {
[16:21:05.929]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.929]                         if (muffled) 
[16:21:05.929]                           invokeRestart("muffleMessage")
[16:21:05.929]                       }
[16:21:05.929]                       else if (inherits(cond, "warning")) {
[16:21:05.929]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.929]                         if (muffled) 
[16:21:05.929]                           invokeRestart("muffleWarning")
[16:21:05.929]                       }
[16:21:05.929]                       else if (inherits(cond, "condition")) {
[16:21:05.929]                         if (!is.null(pattern)) {
[16:21:05.929]                           computeRestarts <- base::computeRestarts
[16:21:05.929]                           grepl <- base::grepl
[16:21:05.929]                           restarts <- computeRestarts(cond)
[16:21:05.929]                           for (restart in restarts) {
[16:21:05.929]                             name <- restart$name
[16:21:05.929]                             if (is.null(name)) 
[16:21:05.929]                               next
[16:21:05.929]                             if (!grepl(pattern, name)) 
[16:21:05.929]                               next
[16:21:05.929]                             invokeRestart(restart)
[16:21:05.929]                             muffled <- TRUE
[16:21:05.929]                             break
[16:21:05.929]                           }
[16:21:05.929]                         }
[16:21:05.929]                       }
[16:21:05.929]                       invisible(muffled)
[16:21:05.929]                     }
[16:21:05.929]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.929]                   }
[16:21:05.929]                 }
[16:21:05.929]                 else {
[16:21:05.929]                   if (TRUE) {
[16:21:05.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.929]                     {
[16:21:05.929]                       inherits <- base::inherits
[16:21:05.929]                       invokeRestart <- base::invokeRestart
[16:21:05.929]                       is.null <- base::is.null
[16:21:05.929]                       muffled <- FALSE
[16:21:05.929]                       if (inherits(cond, "message")) {
[16:21:05.929]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.929]                         if (muffled) 
[16:21:05.929]                           invokeRestart("muffleMessage")
[16:21:05.929]                       }
[16:21:05.929]                       else if (inherits(cond, "warning")) {
[16:21:05.929]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.929]                         if (muffled) 
[16:21:05.929]                           invokeRestart("muffleWarning")
[16:21:05.929]                       }
[16:21:05.929]                       else if (inherits(cond, "condition")) {
[16:21:05.929]                         if (!is.null(pattern)) {
[16:21:05.929]                           computeRestarts <- base::computeRestarts
[16:21:05.929]                           grepl <- base::grepl
[16:21:05.929]                           restarts <- computeRestarts(cond)
[16:21:05.929]                           for (restart in restarts) {
[16:21:05.929]                             name <- restart$name
[16:21:05.929]                             if (is.null(name)) 
[16:21:05.929]                               next
[16:21:05.929]                             if (!grepl(pattern, name)) 
[16:21:05.929]                               next
[16:21:05.929]                             invokeRestart(restart)
[16:21:05.929]                             muffled <- TRUE
[16:21:05.929]                             break
[16:21:05.929]                           }
[16:21:05.929]                         }
[16:21:05.929]                       }
[16:21:05.929]                       invisible(muffled)
[16:21:05.929]                     }
[16:21:05.929]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.929]                   }
[16:21:05.929]                 }
[16:21:05.929]             }
[16:21:05.929]         }))
[16:21:05.929]     }, error = function(ex) {
[16:21:05.929]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.929]                 ...future.rng), started = ...future.startTime, 
[16:21:05.929]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.929]             version = "1.8"), class = "FutureResult")
[16:21:05.929]     }, finally = {
[16:21:05.929]         if (!identical(...future.workdir, getwd())) 
[16:21:05.929]             setwd(...future.workdir)
[16:21:05.929]         {
[16:21:05.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.929]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.929]             }
[16:21:05.929]             base::options(...future.oldOptions)
[16:21:05.929]             if (.Platform$OS.type == "windows") {
[16:21:05.929]                 old_names <- names(...future.oldEnvVars)
[16:21:05.929]                 envs <- base::Sys.getenv()
[16:21:05.929]                 names <- names(envs)
[16:21:05.929]                 common <- intersect(names, old_names)
[16:21:05.929]                 added <- setdiff(names, old_names)
[16:21:05.929]                 removed <- setdiff(old_names, names)
[16:21:05.929]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.929]                   envs[common]]
[16:21:05.929]                 NAMES <- toupper(changed)
[16:21:05.929]                 args <- list()
[16:21:05.929]                 for (kk in seq_along(NAMES)) {
[16:21:05.929]                   name <- changed[[kk]]
[16:21:05.929]                   NAME <- NAMES[[kk]]
[16:21:05.929]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.929]                     next
[16:21:05.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.929]                 }
[16:21:05.929]                 NAMES <- toupper(added)
[16:21:05.929]                 for (kk in seq_along(NAMES)) {
[16:21:05.929]                   name <- added[[kk]]
[16:21:05.929]                   NAME <- NAMES[[kk]]
[16:21:05.929]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.929]                     next
[16:21:05.929]                   args[[name]] <- ""
[16:21:05.929]                 }
[16:21:05.929]                 NAMES <- toupper(removed)
[16:21:05.929]                 for (kk in seq_along(NAMES)) {
[16:21:05.929]                   name <- removed[[kk]]
[16:21:05.929]                   NAME <- NAMES[[kk]]
[16:21:05.929]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.929]                     next
[16:21:05.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.929]                 }
[16:21:05.929]                 if (length(args) > 0) 
[16:21:05.929]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.929]             }
[16:21:05.929]             else {
[16:21:05.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.929]             }
[16:21:05.929]             {
[16:21:05.929]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.929]                   0L) {
[16:21:05.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.929]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.929]                   base::options(opts)
[16:21:05.929]                 }
[16:21:05.929]                 {
[16:21:05.929]                   {
[16:21:05.929]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.929]                     NULL
[16:21:05.929]                   }
[16:21:05.929]                   options(future.plan = NULL)
[16:21:05.929]                   if (is.na(NA_character_)) 
[16:21:05.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.929]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.929]                     .init = FALSE)
[16:21:05.929]                 }
[16:21:05.929]             }
[16:21:05.929]         }
[16:21:05.929]     })
[16:21:05.929]     if (TRUE) {
[16:21:05.929]         base::sink(type = "output", split = FALSE)
[16:21:05.929]         if (TRUE) {
[16:21:05.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.929]         }
[16:21:05.929]         else {
[16:21:05.929]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.929]         }
[16:21:05.929]         base::close(...future.stdout)
[16:21:05.929]         ...future.stdout <- NULL
[16:21:05.929]     }
[16:21:05.929]     ...future.result$conditions <- ...future.conditions
[16:21:05.929]     ...future.result$finished <- base::Sys.time()
[16:21:05.929]     ...future.result
[16:21:05.929] }
[16:21:05.932] MultisessionFuture started
[16:21:05.935] - Launch lazy future ... done
[16:21:05.935] run() for ‘MultisessionFuture’ ... done
[16:21:05.935] result() for ClusterFuture ...
[16:21:05.935] receiveMessageFromWorker() for ClusterFuture ...
[16:21:05.935] - Validating connection of MultisessionFuture
[16:21:05.935] - received message: FutureResult
[16:21:05.936] - Received FutureResult
[16:21:05.936] - Erased future from FutureRegistry
[16:21:05.936] result() for ClusterFuture ...
[16:21:05.936] - result already collected: FutureResult
[16:21:05.936] result() for ClusterFuture ... done
[16:21:05.936] signalConditions() ...
[16:21:05.936]  - include = ‘immediateCondition’
[16:21:05.936]  - exclude = 
[16:21:05.936]  - resignal = FALSE
[16:21:05.936]  - Number of conditions: 1
[16:21:05.937] signalConditions() ... done
[16:21:05.937] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:05.937] result() for ClusterFuture ... done
[16:21:05.937] result() for ClusterFuture ...
[16:21:05.937] - result already collected: FutureResult
[16:21:05.937] result() for ClusterFuture ... done
[16:21:05.937] signalConditions() ...
[16:21:05.937]  - include = ‘immediateCondition’
[16:21:05.937]  - exclude = 
[16:21:05.937]  - resignal = FALSE
[16:21:05.937]  - Number of conditions: 1
[16:21:05.937] signalConditions() ... done
[16:21:05.938] Future state: ‘finished’
[16:21:05.938] result() for ClusterFuture ...
[16:21:05.938] - result already collected: FutureResult
[16:21:05.938] result() for ClusterFuture ... done
[16:21:05.938] signalConditions() ...
[16:21:05.938]  - include = ‘condition’
[16:21:05.938]  - exclude = ‘immediateCondition’
[16:21:05.938]  - resignal = TRUE
[16:21:05.938]  - Number of conditions: 1
[16:21:05.938]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:21:05.938] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "b478068843b5" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:21:05"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:05.952] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:05.952] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:05.954] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:05.954] Searching for globals ... DONE
[16:21:05.954] Resolving globals: TRUE
[16:21:05.954] Resolving any globals that are futures ...
[16:21:05.954] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:05.954] Resolving any globals that are futures ... DONE
[16:21:05.955] Resolving futures part of globals (recursively) ...
[16:21:05.955] resolve() on list ...
[16:21:05.955]  recursive: 99
[16:21:05.955]  length: 1
[16:21:05.955]  elements: ‘ii’
[16:21:05.955]  length: 0 (resolved future 1)
[16:21:05.955] resolve() on list ... DONE
[16:21:05.955] - globals: [1] ‘ii’
[16:21:05.955] Resolving futures part of globals (recursively) ... DONE
[16:21:05.956] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:05.956] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:05.956] - globals: [1] ‘ii’
[16:21:05.956] 
[16:21:05.956] getGlobalsAndPackages() ... DONE
[16:21:05.957] run() for ‘Future’ ...
[16:21:05.957] - state: ‘created’
[16:21:05.957] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:05.970] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:05.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:05.971]   - Field: ‘node’
[16:21:05.971]   - Field: ‘label’
[16:21:05.971]   - Field: ‘local’
[16:21:05.971]   - Field: ‘owner’
[16:21:05.971]   - Field: ‘envir’
[16:21:05.971]   - Field: ‘workers’
[16:21:05.971]   - Field: ‘packages’
[16:21:05.971]   - Field: ‘gc’
[16:21:05.971]   - Field: ‘conditions’
[16:21:05.971]   - Field: ‘persistent’
[16:21:05.972]   - Field: ‘expr’
[16:21:05.972]   - Field: ‘uuid’
[16:21:05.972]   - Field: ‘seed’
[16:21:05.972]   - Field: ‘version’
[16:21:05.972]   - Field: ‘result’
[16:21:05.972]   - Field: ‘asynchronous’
[16:21:05.972]   - Field: ‘calls’
[16:21:05.972]   - Field: ‘globals’
[16:21:05.972]   - Field: ‘stdout’
[16:21:05.972]   - Field: ‘earlySignal’
[16:21:05.973]   - Field: ‘lazy’
[16:21:05.973]   - Field: ‘state’
[16:21:05.973] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:05.973] - Launch lazy future ...
[16:21:05.973] Packages needed by the future expression (n = 0): <none>
[16:21:05.973] Packages needed by future strategies (n = 0): <none>
[16:21:05.974] {
[16:21:05.974]     {
[16:21:05.974]         {
[16:21:05.974]             ...future.startTime <- base::Sys.time()
[16:21:05.974]             {
[16:21:05.974]                 {
[16:21:05.974]                   {
[16:21:05.974]                     {
[16:21:05.974]                       base::local({
[16:21:05.974]                         has_future <- base::requireNamespace("future", 
[16:21:05.974]                           quietly = TRUE)
[16:21:05.974]                         if (has_future) {
[16:21:05.974]                           ns <- base::getNamespace("future")
[16:21:05.974]                           version <- ns[[".package"]][["version"]]
[16:21:05.974]                           if (is.null(version)) 
[16:21:05.974]                             version <- utils::packageVersion("future")
[16:21:05.974]                         }
[16:21:05.974]                         else {
[16:21:05.974]                           version <- NULL
[16:21:05.974]                         }
[16:21:05.974]                         if (!has_future || version < "1.8.0") {
[16:21:05.974]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.974]                             "", base::R.version$version.string), 
[16:21:05.974]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:05.974]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.974]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.974]                               "release", "version")], collapse = " "), 
[16:21:05.974]                             hostname = base::Sys.info()[["nodename"]])
[16:21:05.974]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.974]                             info)
[16:21:05.974]                           info <- base::paste(info, collapse = "; ")
[16:21:05.974]                           if (!has_future) {
[16:21:05.974]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.974]                               info)
[16:21:05.974]                           }
[16:21:05.974]                           else {
[16:21:05.974]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.974]                               info, version)
[16:21:05.974]                           }
[16:21:05.974]                           base::stop(msg)
[16:21:05.974]                         }
[16:21:05.974]                       })
[16:21:05.974]                     }
[16:21:05.974]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.974]                     base::options(mc.cores = 1L)
[16:21:05.974]                   }
[16:21:05.974]                   ...future.strategy.old <- future::plan("list")
[16:21:05.974]                   options(future.plan = NULL)
[16:21:05.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.974]                 }
[16:21:05.974]                 ...future.workdir <- getwd()
[16:21:05.974]             }
[16:21:05.974]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.974]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.974]         }
[16:21:05.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.974]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:05.974]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.974]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.974]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.974]             base::names(...future.oldOptions))
[16:21:05.974]     }
[16:21:05.974]     if (FALSE) {
[16:21:05.974]     }
[16:21:05.974]     else {
[16:21:05.974]         if (TRUE) {
[16:21:05.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.974]                 open = "w")
[16:21:05.974]         }
[16:21:05.974]         else {
[16:21:05.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.974]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.974]         }
[16:21:05.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.974]             base::sink(type = "output", split = FALSE)
[16:21:05.974]             base::close(...future.stdout)
[16:21:05.974]         }, add = TRUE)
[16:21:05.974]     }
[16:21:05.974]     ...future.frame <- base::sys.nframe()
[16:21:05.974]     ...future.conditions <- base::list()
[16:21:05.974]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.974]     if (FALSE) {
[16:21:05.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.974]     }
[16:21:05.974]     ...future.result <- base::tryCatch({
[16:21:05.974]         base::withCallingHandlers({
[16:21:05.974]             ...future.value <- base::withVisible(base::local({
[16:21:05.974]                 ...future.makeSendCondition <- base::local({
[16:21:05.974]                   sendCondition <- NULL
[16:21:05.974]                   function(frame = 1L) {
[16:21:05.974]                     if (is.function(sendCondition)) 
[16:21:05.974]                       return(sendCondition)
[16:21:05.974]                     ns <- getNamespace("parallel")
[16:21:05.974]                     if (exists("sendData", mode = "function", 
[16:21:05.974]                       envir = ns)) {
[16:21:05.974]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:05.974]                         envir = ns)
[16:21:05.974]                       envir <- sys.frame(frame)
[16:21:05.974]                       master <- NULL
[16:21:05.974]                       while (!identical(envir, .GlobalEnv) && 
[16:21:05.974]                         !identical(envir, emptyenv())) {
[16:21:05.974]                         if (exists("master", mode = "list", envir = envir, 
[16:21:05.974]                           inherits = FALSE)) {
[16:21:05.974]                           master <- get("master", mode = "list", 
[16:21:05.974]                             envir = envir, inherits = FALSE)
[16:21:05.974]                           if (inherits(master, c("SOCKnode", 
[16:21:05.974]                             "SOCK0node"))) {
[16:21:05.974]                             sendCondition <<- function(cond) {
[16:21:05.974]                               data <- list(type = "VALUE", value = cond, 
[16:21:05.974]                                 success = TRUE)
[16:21:05.974]                               parallel_sendData(master, data)
[16:21:05.974]                             }
[16:21:05.974]                             return(sendCondition)
[16:21:05.974]                           }
[16:21:05.974]                         }
[16:21:05.974]                         frame <- frame + 1L
[16:21:05.974]                         envir <- sys.frame(frame)
[16:21:05.974]                       }
[16:21:05.974]                     }
[16:21:05.974]                     sendCondition <<- function(cond) NULL
[16:21:05.974]                   }
[16:21:05.974]                 })
[16:21:05.974]                 withCallingHandlers({
[16:21:05.974]                   {
[16:21:05.974]                     b <- a * ii
[16:21:05.974]                     a <- 0
[16:21:05.974]                     b
[16:21:05.974]                   }
[16:21:05.974]                 }, immediateCondition = function(cond) {
[16:21:05.974]                   sendCondition <- ...future.makeSendCondition()
[16:21:05.974]                   sendCondition(cond)
[16:21:05.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.974]                   {
[16:21:05.974]                     inherits <- base::inherits
[16:21:05.974]                     invokeRestart <- base::invokeRestart
[16:21:05.974]                     is.null <- base::is.null
[16:21:05.974]                     muffled <- FALSE
[16:21:05.974]                     if (inherits(cond, "message")) {
[16:21:05.974]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.974]                       if (muffled) 
[16:21:05.974]                         invokeRestart("muffleMessage")
[16:21:05.974]                     }
[16:21:05.974]                     else if (inherits(cond, "warning")) {
[16:21:05.974]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.974]                       if (muffled) 
[16:21:05.974]                         invokeRestart("muffleWarning")
[16:21:05.974]                     }
[16:21:05.974]                     else if (inherits(cond, "condition")) {
[16:21:05.974]                       if (!is.null(pattern)) {
[16:21:05.974]                         computeRestarts <- base::computeRestarts
[16:21:05.974]                         grepl <- base::grepl
[16:21:05.974]                         restarts <- computeRestarts(cond)
[16:21:05.974]                         for (restart in restarts) {
[16:21:05.974]                           name <- restart$name
[16:21:05.974]                           if (is.null(name)) 
[16:21:05.974]                             next
[16:21:05.974]                           if (!grepl(pattern, name)) 
[16:21:05.974]                             next
[16:21:05.974]                           invokeRestart(restart)
[16:21:05.974]                           muffled <- TRUE
[16:21:05.974]                           break
[16:21:05.974]                         }
[16:21:05.974]                       }
[16:21:05.974]                     }
[16:21:05.974]                     invisible(muffled)
[16:21:05.974]                   }
[16:21:05.974]                   muffleCondition(cond)
[16:21:05.974]                 })
[16:21:05.974]             }))
[16:21:05.974]             future::FutureResult(value = ...future.value$value, 
[16:21:05.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.974]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.974]                     ...future.globalenv.names))
[16:21:05.974]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.974]         }, condition = base::local({
[16:21:05.974]             c <- base::c
[16:21:05.974]             inherits <- base::inherits
[16:21:05.974]             invokeRestart <- base::invokeRestart
[16:21:05.974]             length <- base::length
[16:21:05.974]             list <- base::list
[16:21:05.974]             seq.int <- base::seq.int
[16:21:05.974]             signalCondition <- base::signalCondition
[16:21:05.974]             sys.calls <- base::sys.calls
[16:21:05.974]             `[[` <- base::`[[`
[16:21:05.974]             `+` <- base::`+`
[16:21:05.974]             `<<-` <- base::`<<-`
[16:21:05.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.974]                   3L)]
[16:21:05.974]             }
[16:21:05.974]             function(cond) {
[16:21:05.974]                 is_error <- inherits(cond, "error")
[16:21:05.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.974]                   NULL)
[16:21:05.974]                 if (is_error) {
[16:21:05.974]                   sessionInformation <- function() {
[16:21:05.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.974]                       search = base::search(), system = base::Sys.info())
[16:21:05.974]                   }
[16:21:05.974]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.974]                     cond$call), session = sessionInformation(), 
[16:21:05.974]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.974]                   signalCondition(cond)
[16:21:05.974]                 }
[16:21:05.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.974]                 "immediateCondition"))) {
[16:21:05.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.974]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.974]                   if (TRUE && !signal) {
[16:21:05.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.974]                     {
[16:21:05.974]                       inherits <- base::inherits
[16:21:05.974]                       invokeRestart <- base::invokeRestart
[16:21:05.974]                       is.null <- base::is.null
[16:21:05.974]                       muffled <- FALSE
[16:21:05.974]                       if (inherits(cond, "message")) {
[16:21:05.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.974]                         if (muffled) 
[16:21:05.974]                           invokeRestart("muffleMessage")
[16:21:05.974]                       }
[16:21:05.974]                       else if (inherits(cond, "warning")) {
[16:21:05.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.974]                         if (muffled) 
[16:21:05.974]                           invokeRestart("muffleWarning")
[16:21:05.974]                       }
[16:21:05.974]                       else if (inherits(cond, "condition")) {
[16:21:05.974]                         if (!is.null(pattern)) {
[16:21:05.974]                           computeRestarts <- base::computeRestarts
[16:21:05.974]                           grepl <- base::grepl
[16:21:05.974]                           restarts <- computeRestarts(cond)
[16:21:05.974]                           for (restart in restarts) {
[16:21:05.974]                             name <- restart$name
[16:21:05.974]                             if (is.null(name)) 
[16:21:05.974]                               next
[16:21:05.974]                             if (!grepl(pattern, name)) 
[16:21:05.974]                               next
[16:21:05.974]                             invokeRestart(restart)
[16:21:05.974]                             muffled <- TRUE
[16:21:05.974]                             break
[16:21:05.974]                           }
[16:21:05.974]                         }
[16:21:05.974]                       }
[16:21:05.974]                       invisible(muffled)
[16:21:05.974]                     }
[16:21:05.974]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.974]                   }
[16:21:05.974]                 }
[16:21:05.974]                 else {
[16:21:05.974]                   if (TRUE) {
[16:21:05.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.974]                     {
[16:21:05.974]                       inherits <- base::inherits
[16:21:05.974]                       invokeRestart <- base::invokeRestart
[16:21:05.974]                       is.null <- base::is.null
[16:21:05.974]                       muffled <- FALSE
[16:21:05.974]                       if (inherits(cond, "message")) {
[16:21:05.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.974]                         if (muffled) 
[16:21:05.974]                           invokeRestart("muffleMessage")
[16:21:05.974]                       }
[16:21:05.974]                       else if (inherits(cond, "warning")) {
[16:21:05.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.974]                         if (muffled) 
[16:21:05.974]                           invokeRestart("muffleWarning")
[16:21:05.974]                       }
[16:21:05.974]                       else if (inherits(cond, "condition")) {
[16:21:05.974]                         if (!is.null(pattern)) {
[16:21:05.974]                           computeRestarts <- base::computeRestarts
[16:21:05.974]                           grepl <- base::grepl
[16:21:05.974]                           restarts <- computeRestarts(cond)
[16:21:05.974]                           for (restart in restarts) {
[16:21:05.974]                             name <- restart$name
[16:21:05.974]                             if (is.null(name)) 
[16:21:05.974]                               next
[16:21:05.974]                             if (!grepl(pattern, name)) 
[16:21:05.974]                               next
[16:21:05.974]                             invokeRestart(restart)
[16:21:05.974]                             muffled <- TRUE
[16:21:05.974]                             break
[16:21:05.974]                           }
[16:21:05.974]                         }
[16:21:05.974]                       }
[16:21:05.974]                       invisible(muffled)
[16:21:05.974]                     }
[16:21:05.974]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.974]                   }
[16:21:05.974]                 }
[16:21:05.974]             }
[16:21:05.974]         }))
[16:21:05.974]     }, error = function(ex) {
[16:21:05.974]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.974]                 ...future.rng), started = ...future.startTime, 
[16:21:05.974]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.974]             version = "1.8"), class = "FutureResult")
[16:21:05.974]     }, finally = {
[16:21:05.974]         if (!identical(...future.workdir, getwd())) 
[16:21:05.974]             setwd(...future.workdir)
[16:21:05.974]         {
[16:21:05.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.974]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.974]             }
[16:21:05.974]             base::options(...future.oldOptions)
[16:21:05.974]             if (.Platform$OS.type == "windows") {
[16:21:05.974]                 old_names <- names(...future.oldEnvVars)
[16:21:05.974]                 envs <- base::Sys.getenv()
[16:21:05.974]                 names <- names(envs)
[16:21:05.974]                 common <- intersect(names, old_names)
[16:21:05.974]                 added <- setdiff(names, old_names)
[16:21:05.974]                 removed <- setdiff(old_names, names)
[16:21:05.974]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.974]                   envs[common]]
[16:21:05.974]                 NAMES <- toupper(changed)
[16:21:05.974]                 args <- list()
[16:21:05.974]                 for (kk in seq_along(NAMES)) {
[16:21:05.974]                   name <- changed[[kk]]
[16:21:05.974]                   NAME <- NAMES[[kk]]
[16:21:05.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.974]                     next
[16:21:05.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.974]                 }
[16:21:05.974]                 NAMES <- toupper(added)
[16:21:05.974]                 for (kk in seq_along(NAMES)) {
[16:21:05.974]                   name <- added[[kk]]
[16:21:05.974]                   NAME <- NAMES[[kk]]
[16:21:05.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.974]                     next
[16:21:05.974]                   args[[name]] <- ""
[16:21:05.974]                 }
[16:21:05.974]                 NAMES <- toupper(removed)
[16:21:05.974]                 for (kk in seq_along(NAMES)) {
[16:21:05.974]                   name <- removed[[kk]]
[16:21:05.974]                   NAME <- NAMES[[kk]]
[16:21:05.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.974]                     next
[16:21:05.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.974]                 }
[16:21:05.974]                 if (length(args) > 0) 
[16:21:05.974]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.974]             }
[16:21:05.974]             else {
[16:21:05.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.974]             }
[16:21:05.974]             {
[16:21:05.974]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.974]                   0L) {
[16:21:05.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.974]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.974]                   base::options(opts)
[16:21:05.974]                 }
[16:21:05.974]                 {
[16:21:05.974]                   {
[16:21:05.974]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.974]                     NULL
[16:21:05.974]                   }
[16:21:05.974]                   options(future.plan = NULL)
[16:21:05.974]                   if (is.na(NA_character_)) 
[16:21:05.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.974]                     .init = FALSE)
[16:21:05.974]                 }
[16:21:05.974]             }
[16:21:05.974]         }
[16:21:05.974]     })
[16:21:05.974]     if (TRUE) {
[16:21:05.974]         base::sink(type = "output", split = FALSE)
[16:21:05.974]         if (TRUE) {
[16:21:05.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.974]         }
[16:21:05.974]         else {
[16:21:05.974]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.974]         }
[16:21:05.974]         base::close(...future.stdout)
[16:21:05.974]         ...future.stdout <- NULL
[16:21:05.974]     }
[16:21:05.974]     ...future.result$conditions <- ...future.conditions
[16:21:05.974]     ...future.result$finished <- base::Sys.time()
[16:21:05.974]     ...future.result
[16:21:05.974] }
[16:21:05.976] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:21:05.976] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:21:05.977] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:21:05.977] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:21:05.977] MultisessionFuture started
[16:21:05.977] - Launch lazy future ... done
[16:21:05.977] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:05.978] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:05.978] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:05.979] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:05.979] Searching for globals ... DONE
[16:21:05.979] Resolving globals: TRUE
[16:21:05.980] Resolving any globals that are futures ...
[16:21:05.980] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:05.980] Resolving any globals that are futures ... DONE
[16:21:05.980] Resolving futures part of globals (recursively) ...
[16:21:05.980] resolve() on list ...
[16:21:05.980]  recursive: 99
[16:21:05.981]  length: 1
[16:21:05.981]  elements: ‘ii’
[16:21:05.981]  length: 0 (resolved future 1)
[16:21:05.981] resolve() on list ... DONE
[16:21:05.981] - globals: [1] ‘ii’
[16:21:05.981] Resolving futures part of globals (recursively) ... DONE
[16:21:05.981] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:05.981] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:05.982] - globals: [1] ‘ii’
[16:21:05.982] 
[16:21:05.982] getGlobalsAndPackages() ... DONE
[16:21:05.982] run() for ‘Future’ ...
[16:21:05.982] - state: ‘created’
[16:21:05.982] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:05.996] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:05.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:05.996]   - Field: ‘node’
[16:21:05.996]   - Field: ‘label’
[16:21:05.996]   - Field: ‘local’
[16:21:05.996]   - Field: ‘owner’
[16:21:05.996]   - Field: ‘envir’
[16:21:05.996]   - Field: ‘workers’
[16:21:05.996]   - Field: ‘packages’
[16:21:05.997]   - Field: ‘gc’
[16:21:05.997]   - Field: ‘conditions’
[16:21:05.997]   - Field: ‘persistent’
[16:21:05.997]   - Field: ‘expr’
[16:21:05.997]   - Field: ‘uuid’
[16:21:05.997]   - Field: ‘seed’
[16:21:05.997]   - Field: ‘version’
[16:21:05.997]   - Field: ‘result’
[16:21:05.997]   - Field: ‘asynchronous’
[16:21:05.997]   - Field: ‘calls’
[16:21:05.997]   - Field: ‘globals’
[16:21:05.998]   - Field: ‘stdout’
[16:21:05.998]   - Field: ‘earlySignal’
[16:21:05.998]   - Field: ‘lazy’
[16:21:05.998]   - Field: ‘state’
[16:21:05.998] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:05.998] - Launch lazy future ...
[16:21:05.998] Packages needed by the future expression (n = 0): <none>
[16:21:05.998] Packages needed by future strategies (n = 0): <none>
[16:21:05.999] {
[16:21:05.999]     {
[16:21:05.999]         {
[16:21:05.999]             ...future.startTime <- base::Sys.time()
[16:21:05.999]             {
[16:21:05.999]                 {
[16:21:05.999]                   {
[16:21:05.999]                     {
[16:21:05.999]                       base::local({
[16:21:05.999]                         has_future <- base::requireNamespace("future", 
[16:21:05.999]                           quietly = TRUE)
[16:21:05.999]                         if (has_future) {
[16:21:05.999]                           ns <- base::getNamespace("future")
[16:21:05.999]                           version <- ns[[".package"]][["version"]]
[16:21:05.999]                           if (is.null(version)) 
[16:21:05.999]                             version <- utils::packageVersion("future")
[16:21:05.999]                         }
[16:21:05.999]                         else {
[16:21:05.999]                           version <- NULL
[16:21:05.999]                         }
[16:21:05.999]                         if (!has_future || version < "1.8.0") {
[16:21:05.999]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:05.999]                             "", base::R.version$version.string), 
[16:21:05.999]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:05.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:05.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:05.999]                               "release", "version")], collapse = " "), 
[16:21:05.999]                             hostname = base::Sys.info()[["nodename"]])
[16:21:05.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:05.999]                             info)
[16:21:05.999]                           info <- base::paste(info, collapse = "; ")
[16:21:05.999]                           if (!has_future) {
[16:21:05.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:05.999]                               info)
[16:21:05.999]                           }
[16:21:05.999]                           else {
[16:21:05.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:05.999]                               info, version)
[16:21:05.999]                           }
[16:21:05.999]                           base::stop(msg)
[16:21:05.999]                         }
[16:21:05.999]                       })
[16:21:05.999]                     }
[16:21:05.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:05.999]                     base::options(mc.cores = 1L)
[16:21:05.999]                   }
[16:21:05.999]                   ...future.strategy.old <- future::plan("list")
[16:21:05.999]                   options(future.plan = NULL)
[16:21:05.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:05.999]                 }
[16:21:05.999]                 ...future.workdir <- getwd()
[16:21:05.999]             }
[16:21:05.999]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:05.999]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:05.999]         }
[16:21:05.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:05.999]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:05.999]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:05.999]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:05.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:05.999]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:05.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:05.999]             base::names(...future.oldOptions))
[16:21:05.999]     }
[16:21:05.999]     if (FALSE) {
[16:21:05.999]     }
[16:21:05.999]     else {
[16:21:05.999]         if (TRUE) {
[16:21:05.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:05.999]                 open = "w")
[16:21:05.999]         }
[16:21:05.999]         else {
[16:21:05.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:05.999]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:05.999]         }
[16:21:05.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:05.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:05.999]             base::sink(type = "output", split = FALSE)
[16:21:05.999]             base::close(...future.stdout)
[16:21:05.999]         }, add = TRUE)
[16:21:05.999]     }
[16:21:05.999]     ...future.frame <- base::sys.nframe()
[16:21:05.999]     ...future.conditions <- base::list()
[16:21:05.999]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:05.999]     if (FALSE) {
[16:21:05.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:05.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:05.999]     }
[16:21:05.999]     ...future.result <- base::tryCatch({
[16:21:05.999]         base::withCallingHandlers({
[16:21:05.999]             ...future.value <- base::withVisible(base::local({
[16:21:05.999]                 ...future.makeSendCondition <- base::local({
[16:21:05.999]                   sendCondition <- NULL
[16:21:05.999]                   function(frame = 1L) {
[16:21:05.999]                     if (is.function(sendCondition)) 
[16:21:05.999]                       return(sendCondition)
[16:21:05.999]                     ns <- getNamespace("parallel")
[16:21:05.999]                     if (exists("sendData", mode = "function", 
[16:21:05.999]                       envir = ns)) {
[16:21:05.999]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:05.999]                         envir = ns)
[16:21:05.999]                       envir <- sys.frame(frame)
[16:21:05.999]                       master <- NULL
[16:21:05.999]                       while (!identical(envir, .GlobalEnv) && 
[16:21:05.999]                         !identical(envir, emptyenv())) {
[16:21:05.999]                         if (exists("master", mode = "list", envir = envir, 
[16:21:05.999]                           inherits = FALSE)) {
[16:21:05.999]                           master <- get("master", mode = "list", 
[16:21:05.999]                             envir = envir, inherits = FALSE)
[16:21:05.999]                           if (inherits(master, c("SOCKnode", 
[16:21:05.999]                             "SOCK0node"))) {
[16:21:05.999]                             sendCondition <<- function(cond) {
[16:21:05.999]                               data <- list(type = "VALUE", value = cond, 
[16:21:05.999]                                 success = TRUE)
[16:21:05.999]                               parallel_sendData(master, data)
[16:21:05.999]                             }
[16:21:05.999]                             return(sendCondition)
[16:21:05.999]                           }
[16:21:05.999]                         }
[16:21:05.999]                         frame <- frame + 1L
[16:21:05.999]                         envir <- sys.frame(frame)
[16:21:05.999]                       }
[16:21:05.999]                     }
[16:21:05.999]                     sendCondition <<- function(cond) NULL
[16:21:05.999]                   }
[16:21:05.999]                 })
[16:21:05.999]                 withCallingHandlers({
[16:21:05.999]                   {
[16:21:05.999]                     b <- a * ii
[16:21:05.999]                     a <- 0
[16:21:05.999]                     b
[16:21:05.999]                   }
[16:21:05.999]                 }, immediateCondition = function(cond) {
[16:21:05.999]                   sendCondition <- ...future.makeSendCondition()
[16:21:05.999]                   sendCondition(cond)
[16:21:05.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.999]                   {
[16:21:05.999]                     inherits <- base::inherits
[16:21:05.999]                     invokeRestart <- base::invokeRestart
[16:21:05.999]                     is.null <- base::is.null
[16:21:05.999]                     muffled <- FALSE
[16:21:05.999]                     if (inherits(cond, "message")) {
[16:21:05.999]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:05.999]                       if (muffled) 
[16:21:05.999]                         invokeRestart("muffleMessage")
[16:21:05.999]                     }
[16:21:05.999]                     else if (inherits(cond, "warning")) {
[16:21:05.999]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:05.999]                       if (muffled) 
[16:21:05.999]                         invokeRestart("muffleWarning")
[16:21:05.999]                     }
[16:21:05.999]                     else if (inherits(cond, "condition")) {
[16:21:05.999]                       if (!is.null(pattern)) {
[16:21:05.999]                         computeRestarts <- base::computeRestarts
[16:21:05.999]                         grepl <- base::grepl
[16:21:05.999]                         restarts <- computeRestarts(cond)
[16:21:05.999]                         for (restart in restarts) {
[16:21:05.999]                           name <- restart$name
[16:21:05.999]                           if (is.null(name)) 
[16:21:05.999]                             next
[16:21:05.999]                           if (!grepl(pattern, name)) 
[16:21:05.999]                             next
[16:21:05.999]                           invokeRestart(restart)
[16:21:05.999]                           muffled <- TRUE
[16:21:05.999]                           break
[16:21:05.999]                         }
[16:21:05.999]                       }
[16:21:05.999]                     }
[16:21:05.999]                     invisible(muffled)
[16:21:05.999]                   }
[16:21:05.999]                   muffleCondition(cond)
[16:21:05.999]                 })
[16:21:05.999]             }))
[16:21:05.999]             future::FutureResult(value = ...future.value$value, 
[16:21:05.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.999]                   ...future.rng), globalenv = if (FALSE) 
[16:21:05.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:05.999]                     ...future.globalenv.names))
[16:21:05.999]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:05.999]         }, condition = base::local({
[16:21:05.999]             c <- base::c
[16:21:05.999]             inherits <- base::inherits
[16:21:05.999]             invokeRestart <- base::invokeRestart
[16:21:05.999]             length <- base::length
[16:21:05.999]             list <- base::list
[16:21:05.999]             seq.int <- base::seq.int
[16:21:05.999]             signalCondition <- base::signalCondition
[16:21:05.999]             sys.calls <- base::sys.calls
[16:21:05.999]             `[[` <- base::`[[`
[16:21:05.999]             `+` <- base::`+`
[16:21:05.999]             `<<-` <- base::`<<-`
[16:21:05.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:05.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:05.999]                   3L)]
[16:21:05.999]             }
[16:21:05.999]             function(cond) {
[16:21:05.999]                 is_error <- inherits(cond, "error")
[16:21:05.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:05.999]                   NULL)
[16:21:05.999]                 if (is_error) {
[16:21:05.999]                   sessionInformation <- function() {
[16:21:05.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:05.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:05.999]                       search = base::search(), system = base::Sys.info())
[16:21:05.999]                   }
[16:21:05.999]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:05.999]                     cond$call), session = sessionInformation(), 
[16:21:05.999]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:05.999]                   signalCondition(cond)
[16:21:05.999]                 }
[16:21:05.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:05.999]                 "immediateCondition"))) {
[16:21:05.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:05.999]                   ...future.conditions[[length(...future.conditions) + 
[16:21:05.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:05.999]                   if (TRUE && !signal) {
[16:21:05.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.999]                     {
[16:21:05.999]                       inherits <- base::inherits
[16:21:05.999]                       invokeRestart <- base::invokeRestart
[16:21:05.999]                       is.null <- base::is.null
[16:21:05.999]                       muffled <- FALSE
[16:21:05.999]                       if (inherits(cond, "message")) {
[16:21:05.999]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.999]                         if (muffled) 
[16:21:05.999]                           invokeRestart("muffleMessage")
[16:21:05.999]                       }
[16:21:05.999]                       else if (inherits(cond, "warning")) {
[16:21:05.999]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.999]                         if (muffled) 
[16:21:05.999]                           invokeRestart("muffleWarning")
[16:21:05.999]                       }
[16:21:05.999]                       else if (inherits(cond, "condition")) {
[16:21:05.999]                         if (!is.null(pattern)) {
[16:21:05.999]                           computeRestarts <- base::computeRestarts
[16:21:05.999]                           grepl <- base::grepl
[16:21:05.999]                           restarts <- computeRestarts(cond)
[16:21:05.999]                           for (restart in restarts) {
[16:21:05.999]                             name <- restart$name
[16:21:05.999]                             if (is.null(name)) 
[16:21:05.999]                               next
[16:21:05.999]                             if (!grepl(pattern, name)) 
[16:21:05.999]                               next
[16:21:05.999]                             invokeRestart(restart)
[16:21:05.999]                             muffled <- TRUE
[16:21:05.999]                             break
[16:21:05.999]                           }
[16:21:05.999]                         }
[16:21:05.999]                       }
[16:21:05.999]                       invisible(muffled)
[16:21:05.999]                     }
[16:21:05.999]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.999]                   }
[16:21:05.999]                 }
[16:21:05.999]                 else {
[16:21:05.999]                   if (TRUE) {
[16:21:05.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:05.999]                     {
[16:21:05.999]                       inherits <- base::inherits
[16:21:05.999]                       invokeRestart <- base::invokeRestart
[16:21:05.999]                       is.null <- base::is.null
[16:21:05.999]                       muffled <- FALSE
[16:21:05.999]                       if (inherits(cond, "message")) {
[16:21:05.999]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:05.999]                         if (muffled) 
[16:21:05.999]                           invokeRestart("muffleMessage")
[16:21:05.999]                       }
[16:21:05.999]                       else if (inherits(cond, "warning")) {
[16:21:05.999]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:05.999]                         if (muffled) 
[16:21:05.999]                           invokeRestart("muffleWarning")
[16:21:05.999]                       }
[16:21:05.999]                       else if (inherits(cond, "condition")) {
[16:21:05.999]                         if (!is.null(pattern)) {
[16:21:05.999]                           computeRestarts <- base::computeRestarts
[16:21:05.999]                           grepl <- base::grepl
[16:21:05.999]                           restarts <- computeRestarts(cond)
[16:21:05.999]                           for (restart in restarts) {
[16:21:05.999]                             name <- restart$name
[16:21:05.999]                             if (is.null(name)) 
[16:21:05.999]                               next
[16:21:05.999]                             if (!grepl(pattern, name)) 
[16:21:05.999]                               next
[16:21:05.999]                             invokeRestart(restart)
[16:21:05.999]                             muffled <- TRUE
[16:21:05.999]                             break
[16:21:05.999]                           }
[16:21:05.999]                         }
[16:21:05.999]                       }
[16:21:05.999]                       invisible(muffled)
[16:21:05.999]                     }
[16:21:05.999]                     muffleCondition(cond, pattern = "^muffle")
[16:21:05.999]                   }
[16:21:05.999]                 }
[16:21:05.999]             }
[16:21:05.999]         }))
[16:21:05.999]     }, error = function(ex) {
[16:21:05.999]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:05.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:05.999]                 ...future.rng), started = ...future.startTime, 
[16:21:05.999]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:05.999]             version = "1.8"), class = "FutureResult")
[16:21:05.999]     }, finally = {
[16:21:05.999]         if (!identical(...future.workdir, getwd())) 
[16:21:05.999]             setwd(...future.workdir)
[16:21:05.999]         {
[16:21:05.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:05.999]                 ...future.oldOptions$nwarnings <- NULL
[16:21:05.999]             }
[16:21:05.999]             base::options(...future.oldOptions)
[16:21:05.999]             if (.Platform$OS.type == "windows") {
[16:21:05.999]                 old_names <- names(...future.oldEnvVars)
[16:21:05.999]                 envs <- base::Sys.getenv()
[16:21:05.999]                 names <- names(envs)
[16:21:05.999]                 common <- intersect(names, old_names)
[16:21:05.999]                 added <- setdiff(names, old_names)
[16:21:05.999]                 removed <- setdiff(old_names, names)
[16:21:05.999]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:05.999]                   envs[common]]
[16:21:05.999]                 NAMES <- toupper(changed)
[16:21:05.999]                 args <- list()
[16:21:05.999]                 for (kk in seq_along(NAMES)) {
[16:21:05.999]                   name <- changed[[kk]]
[16:21:05.999]                   NAME <- NAMES[[kk]]
[16:21:05.999]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.999]                     next
[16:21:05.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.999]                 }
[16:21:05.999]                 NAMES <- toupper(added)
[16:21:05.999]                 for (kk in seq_along(NAMES)) {
[16:21:05.999]                   name <- added[[kk]]
[16:21:05.999]                   NAME <- NAMES[[kk]]
[16:21:05.999]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.999]                     next
[16:21:05.999]                   args[[name]] <- ""
[16:21:05.999]                 }
[16:21:05.999]                 NAMES <- toupper(removed)
[16:21:05.999]                 for (kk in seq_along(NAMES)) {
[16:21:05.999]                   name <- removed[[kk]]
[16:21:05.999]                   NAME <- NAMES[[kk]]
[16:21:05.999]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:05.999]                     next
[16:21:05.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:05.999]                 }
[16:21:05.999]                 if (length(args) > 0) 
[16:21:05.999]                   base::do.call(base::Sys.setenv, args = args)
[16:21:05.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:05.999]             }
[16:21:05.999]             else {
[16:21:05.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:05.999]             }
[16:21:05.999]             {
[16:21:05.999]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:05.999]                   0L) {
[16:21:05.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:05.999]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:05.999]                   base::options(opts)
[16:21:05.999]                 }
[16:21:05.999]                 {
[16:21:05.999]                   {
[16:21:05.999]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:05.999]                     NULL
[16:21:05.999]                   }
[16:21:05.999]                   options(future.plan = NULL)
[16:21:05.999]                   if (is.na(NA_character_)) 
[16:21:05.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:05.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:05.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:05.999]                     .init = FALSE)
[16:21:05.999]                 }
[16:21:05.999]             }
[16:21:05.999]         }
[16:21:05.999]     })
[16:21:05.999]     if (TRUE) {
[16:21:05.999]         base::sink(type = "output", split = FALSE)
[16:21:05.999]         if (TRUE) {
[16:21:05.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:05.999]         }
[16:21:05.999]         else {
[16:21:05.999]             ...future.result["stdout"] <- base::list(NULL)
[16:21:05.999]         }
[16:21:05.999]         base::close(...future.stdout)
[16:21:05.999]         ...future.stdout <- NULL
[16:21:05.999]     }
[16:21:05.999]     ...future.result$conditions <- ...future.conditions
[16:21:05.999]     ...future.result$finished <- base::Sys.time()
[16:21:05.999]     ...future.result
[16:21:05.999] }
[16:21:06.052] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:21:06.053] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:21:06.053] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:21:06.053] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:21:06.054] MultisessionFuture started
[16:21:06.054] - Launch lazy future ... done
[16:21:06.054] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.055] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.055] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.056] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:06.056] Searching for globals ... DONE
[16:21:06.056] Resolving globals: TRUE
[16:21:06.057] Resolving any globals that are futures ...
[16:21:06.057] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:06.057] Resolving any globals that are futures ... DONE
[16:21:06.057] Resolving futures part of globals (recursively) ...
[16:21:06.057] resolve() on list ...
[16:21:06.057]  recursive: 99
[16:21:06.058]  length: 1
[16:21:06.058]  elements: ‘ii’
[16:21:06.058]  length: 0 (resolved future 1)
[16:21:06.058] resolve() on list ... DONE
[16:21:06.058] - globals: [1] ‘ii’
[16:21:06.058] Resolving futures part of globals (recursively) ... DONE
[16:21:06.058] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:06.058] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:06.059] - globals: [1] ‘ii’
[16:21:06.059] 
[16:21:06.059] getGlobalsAndPackages() ... DONE
[16:21:06.059] run() for ‘Future’ ...
[16:21:06.059] - state: ‘created’
[16:21:06.059] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.076] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.077]   - Field: ‘node’
[16:21:06.077]   - Field: ‘label’
[16:21:06.077]   - Field: ‘local’
[16:21:06.077]   - Field: ‘owner’
[16:21:06.077]   - Field: ‘envir’
[16:21:06.077]   - Field: ‘workers’
[16:21:06.078]   - Field: ‘packages’
[16:21:06.078]   - Field: ‘gc’
[16:21:06.078]   - Field: ‘conditions’
[16:21:06.078]   - Field: ‘persistent’
[16:21:06.078]   - Field: ‘expr’
[16:21:06.078]   - Field: ‘uuid’
[16:21:06.079]   - Field: ‘seed’
[16:21:06.079]   - Field: ‘version’
[16:21:06.079]   - Field: ‘result’
[16:21:06.079]   - Field: ‘asynchronous’
[16:21:06.079]   - Field: ‘calls’
[16:21:06.079]   - Field: ‘globals’
[16:21:06.080]   - Field: ‘stdout’
[16:21:06.080]   - Field: ‘earlySignal’
[16:21:06.080]   - Field: ‘lazy’
[16:21:06.080]   - Field: ‘state’
[16:21:06.080] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.080] - Launch lazy future ...
[16:21:06.081] Packages needed by the future expression (n = 0): <none>
[16:21:06.081] Packages needed by future strategies (n = 0): <none>
[16:21:06.082] {
[16:21:06.082]     {
[16:21:06.082]         {
[16:21:06.082]             ...future.startTime <- base::Sys.time()
[16:21:06.082]             {
[16:21:06.082]                 {
[16:21:06.082]                   {
[16:21:06.082]                     {
[16:21:06.082]                       base::local({
[16:21:06.082]                         has_future <- base::requireNamespace("future", 
[16:21:06.082]                           quietly = TRUE)
[16:21:06.082]                         if (has_future) {
[16:21:06.082]                           ns <- base::getNamespace("future")
[16:21:06.082]                           version <- ns[[".package"]][["version"]]
[16:21:06.082]                           if (is.null(version)) 
[16:21:06.082]                             version <- utils::packageVersion("future")
[16:21:06.082]                         }
[16:21:06.082]                         else {
[16:21:06.082]                           version <- NULL
[16:21:06.082]                         }
[16:21:06.082]                         if (!has_future || version < "1.8.0") {
[16:21:06.082]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.082]                             "", base::R.version$version.string), 
[16:21:06.082]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:06.082]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:06.082]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.082]                               "release", "version")], collapse = " "), 
[16:21:06.082]                             hostname = base::Sys.info()[["nodename"]])
[16:21:06.082]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.082]                             info)
[16:21:06.082]                           info <- base::paste(info, collapse = "; ")
[16:21:06.082]                           if (!has_future) {
[16:21:06.082]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.082]                               info)
[16:21:06.082]                           }
[16:21:06.082]                           else {
[16:21:06.082]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.082]                               info, version)
[16:21:06.082]                           }
[16:21:06.082]                           base::stop(msg)
[16:21:06.082]                         }
[16:21:06.082]                       })
[16:21:06.082]                     }
[16:21:06.082]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.082]                     base::options(mc.cores = 1L)
[16:21:06.082]                   }
[16:21:06.082]                   ...future.strategy.old <- future::plan("list")
[16:21:06.082]                   options(future.plan = NULL)
[16:21:06.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.082]                 }
[16:21:06.082]                 ...future.workdir <- getwd()
[16:21:06.082]             }
[16:21:06.082]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.082]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.082]         }
[16:21:06.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.082]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.082]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.082]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.082]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.082]             base::names(...future.oldOptions))
[16:21:06.082]     }
[16:21:06.082]     if (FALSE) {
[16:21:06.082]     }
[16:21:06.082]     else {
[16:21:06.082]         if (TRUE) {
[16:21:06.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.082]                 open = "w")
[16:21:06.082]         }
[16:21:06.082]         else {
[16:21:06.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.082]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.082]         }
[16:21:06.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.082]             base::sink(type = "output", split = FALSE)
[16:21:06.082]             base::close(...future.stdout)
[16:21:06.082]         }, add = TRUE)
[16:21:06.082]     }
[16:21:06.082]     ...future.frame <- base::sys.nframe()
[16:21:06.082]     ...future.conditions <- base::list()
[16:21:06.082]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.082]     if (FALSE) {
[16:21:06.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.082]     }
[16:21:06.082]     ...future.result <- base::tryCatch({
[16:21:06.082]         base::withCallingHandlers({
[16:21:06.082]             ...future.value <- base::withVisible(base::local({
[16:21:06.082]                 ...future.makeSendCondition <- base::local({
[16:21:06.082]                   sendCondition <- NULL
[16:21:06.082]                   function(frame = 1L) {
[16:21:06.082]                     if (is.function(sendCondition)) 
[16:21:06.082]                       return(sendCondition)
[16:21:06.082]                     ns <- getNamespace("parallel")
[16:21:06.082]                     if (exists("sendData", mode = "function", 
[16:21:06.082]                       envir = ns)) {
[16:21:06.082]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.082]                         envir = ns)
[16:21:06.082]                       envir <- sys.frame(frame)
[16:21:06.082]                       master <- NULL
[16:21:06.082]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.082]                         !identical(envir, emptyenv())) {
[16:21:06.082]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.082]                           inherits = FALSE)) {
[16:21:06.082]                           master <- get("master", mode = "list", 
[16:21:06.082]                             envir = envir, inherits = FALSE)
[16:21:06.082]                           if (inherits(master, c("SOCKnode", 
[16:21:06.082]                             "SOCK0node"))) {
[16:21:06.082]                             sendCondition <<- function(cond) {
[16:21:06.082]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.082]                                 success = TRUE)
[16:21:06.082]                               parallel_sendData(master, data)
[16:21:06.082]                             }
[16:21:06.082]                             return(sendCondition)
[16:21:06.082]                           }
[16:21:06.082]                         }
[16:21:06.082]                         frame <- frame + 1L
[16:21:06.082]                         envir <- sys.frame(frame)
[16:21:06.082]                       }
[16:21:06.082]                     }
[16:21:06.082]                     sendCondition <<- function(cond) NULL
[16:21:06.082]                   }
[16:21:06.082]                 })
[16:21:06.082]                 withCallingHandlers({
[16:21:06.082]                   {
[16:21:06.082]                     b <- a * ii
[16:21:06.082]                     a <- 0
[16:21:06.082]                     b
[16:21:06.082]                   }
[16:21:06.082]                 }, immediateCondition = function(cond) {
[16:21:06.082]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.082]                   sendCondition(cond)
[16:21:06.082]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.082]                   {
[16:21:06.082]                     inherits <- base::inherits
[16:21:06.082]                     invokeRestart <- base::invokeRestart
[16:21:06.082]                     is.null <- base::is.null
[16:21:06.082]                     muffled <- FALSE
[16:21:06.082]                     if (inherits(cond, "message")) {
[16:21:06.082]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.082]                       if (muffled) 
[16:21:06.082]                         invokeRestart("muffleMessage")
[16:21:06.082]                     }
[16:21:06.082]                     else if (inherits(cond, "warning")) {
[16:21:06.082]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.082]                       if (muffled) 
[16:21:06.082]                         invokeRestart("muffleWarning")
[16:21:06.082]                     }
[16:21:06.082]                     else if (inherits(cond, "condition")) {
[16:21:06.082]                       if (!is.null(pattern)) {
[16:21:06.082]                         computeRestarts <- base::computeRestarts
[16:21:06.082]                         grepl <- base::grepl
[16:21:06.082]                         restarts <- computeRestarts(cond)
[16:21:06.082]                         for (restart in restarts) {
[16:21:06.082]                           name <- restart$name
[16:21:06.082]                           if (is.null(name)) 
[16:21:06.082]                             next
[16:21:06.082]                           if (!grepl(pattern, name)) 
[16:21:06.082]                             next
[16:21:06.082]                           invokeRestart(restart)
[16:21:06.082]                           muffled <- TRUE
[16:21:06.082]                           break
[16:21:06.082]                         }
[16:21:06.082]                       }
[16:21:06.082]                     }
[16:21:06.082]                     invisible(muffled)
[16:21:06.082]                   }
[16:21:06.082]                   muffleCondition(cond)
[16:21:06.082]                 })
[16:21:06.082]             }))
[16:21:06.082]             future::FutureResult(value = ...future.value$value, 
[16:21:06.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.082]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.082]                     ...future.globalenv.names))
[16:21:06.082]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.082]         }, condition = base::local({
[16:21:06.082]             c <- base::c
[16:21:06.082]             inherits <- base::inherits
[16:21:06.082]             invokeRestart <- base::invokeRestart
[16:21:06.082]             length <- base::length
[16:21:06.082]             list <- base::list
[16:21:06.082]             seq.int <- base::seq.int
[16:21:06.082]             signalCondition <- base::signalCondition
[16:21:06.082]             sys.calls <- base::sys.calls
[16:21:06.082]             `[[` <- base::`[[`
[16:21:06.082]             `+` <- base::`+`
[16:21:06.082]             `<<-` <- base::`<<-`
[16:21:06.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.082]                   3L)]
[16:21:06.082]             }
[16:21:06.082]             function(cond) {
[16:21:06.082]                 is_error <- inherits(cond, "error")
[16:21:06.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.082]                   NULL)
[16:21:06.082]                 if (is_error) {
[16:21:06.082]                   sessionInformation <- function() {
[16:21:06.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.082]                       search = base::search(), system = base::Sys.info())
[16:21:06.082]                   }
[16:21:06.082]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.082]                     cond$call), session = sessionInformation(), 
[16:21:06.082]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.082]                   signalCondition(cond)
[16:21:06.082]                 }
[16:21:06.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.082]                 "immediateCondition"))) {
[16:21:06.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.082]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.082]                   if (TRUE && !signal) {
[16:21:06.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.082]                     {
[16:21:06.082]                       inherits <- base::inherits
[16:21:06.082]                       invokeRestart <- base::invokeRestart
[16:21:06.082]                       is.null <- base::is.null
[16:21:06.082]                       muffled <- FALSE
[16:21:06.082]                       if (inherits(cond, "message")) {
[16:21:06.082]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.082]                         if (muffled) 
[16:21:06.082]                           invokeRestart("muffleMessage")
[16:21:06.082]                       }
[16:21:06.082]                       else if (inherits(cond, "warning")) {
[16:21:06.082]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.082]                         if (muffled) 
[16:21:06.082]                           invokeRestart("muffleWarning")
[16:21:06.082]                       }
[16:21:06.082]                       else if (inherits(cond, "condition")) {
[16:21:06.082]                         if (!is.null(pattern)) {
[16:21:06.082]                           computeRestarts <- base::computeRestarts
[16:21:06.082]                           grepl <- base::grepl
[16:21:06.082]                           restarts <- computeRestarts(cond)
[16:21:06.082]                           for (restart in restarts) {
[16:21:06.082]                             name <- restart$name
[16:21:06.082]                             if (is.null(name)) 
[16:21:06.082]                               next
[16:21:06.082]                             if (!grepl(pattern, name)) 
[16:21:06.082]                               next
[16:21:06.082]                             invokeRestart(restart)
[16:21:06.082]                             muffled <- TRUE
[16:21:06.082]                             break
[16:21:06.082]                           }
[16:21:06.082]                         }
[16:21:06.082]                       }
[16:21:06.082]                       invisible(muffled)
[16:21:06.082]                     }
[16:21:06.082]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.082]                   }
[16:21:06.082]                 }
[16:21:06.082]                 else {
[16:21:06.082]                   if (TRUE) {
[16:21:06.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.082]                     {
[16:21:06.082]                       inherits <- base::inherits
[16:21:06.082]                       invokeRestart <- base::invokeRestart
[16:21:06.082]                       is.null <- base::is.null
[16:21:06.082]                       muffled <- FALSE
[16:21:06.082]                       if (inherits(cond, "message")) {
[16:21:06.082]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.082]                         if (muffled) 
[16:21:06.082]                           invokeRestart("muffleMessage")
[16:21:06.082]                       }
[16:21:06.082]                       else if (inherits(cond, "warning")) {
[16:21:06.082]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.082]                         if (muffled) 
[16:21:06.082]                           invokeRestart("muffleWarning")
[16:21:06.082]                       }
[16:21:06.082]                       else if (inherits(cond, "condition")) {
[16:21:06.082]                         if (!is.null(pattern)) {
[16:21:06.082]                           computeRestarts <- base::computeRestarts
[16:21:06.082]                           grepl <- base::grepl
[16:21:06.082]                           restarts <- computeRestarts(cond)
[16:21:06.082]                           for (restart in restarts) {
[16:21:06.082]                             name <- restart$name
[16:21:06.082]                             if (is.null(name)) 
[16:21:06.082]                               next
[16:21:06.082]                             if (!grepl(pattern, name)) 
[16:21:06.082]                               next
[16:21:06.082]                             invokeRestart(restart)
[16:21:06.082]                             muffled <- TRUE
[16:21:06.082]                             break
[16:21:06.082]                           }
[16:21:06.082]                         }
[16:21:06.082]                       }
[16:21:06.082]                       invisible(muffled)
[16:21:06.082]                     }
[16:21:06.082]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.082]                   }
[16:21:06.082]                 }
[16:21:06.082]             }
[16:21:06.082]         }))
[16:21:06.082]     }, error = function(ex) {
[16:21:06.082]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.082]                 ...future.rng), started = ...future.startTime, 
[16:21:06.082]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.082]             version = "1.8"), class = "FutureResult")
[16:21:06.082]     }, finally = {
[16:21:06.082]         if (!identical(...future.workdir, getwd())) 
[16:21:06.082]             setwd(...future.workdir)
[16:21:06.082]         {
[16:21:06.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.082]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.082]             }
[16:21:06.082]             base::options(...future.oldOptions)
[16:21:06.082]             if (.Platform$OS.type == "windows") {
[16:21:06.082]                 old_names <- names(...future.oldEnvVars)
[16:21:06.082]                 envs <- base::Sys.getenv()
[16:21:06.082]                 names <- names(envs)
[16:21:06.082]                 common <- intersect(names, old_names)
[16:21:06.082]                 added <- setdiff(names, old_names)
[16:21:06.082]                 removed <- setdiff(old_names, names)
[16:21:06.082]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.082]                   envs[common]]
[16:21:06.082]                 NAMES <- toupper(changed)
[16:21:06.082]                 args <- list()
[16:21:06.082]                 for (kk in seq_along(NAMES)) {
[16:21:06.082]                   name <- changed[[kk]]
[16:21:06.082]                   NAME <- NAMES[[kk]]
[16:21:06.082]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.082]                     next
[16:21:06.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.082]                 }
[16:21:06.082]                 NAMES <- toupper(added)
[16:21:06.082]                 for (kk in seq_along(NAMES)) {
[16:21:06.082]                   name <- added[[kk]]
[16:21:06.082]                   NAME <- NAMES[[kk]]
[16:21:06.082]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.082]                     next
[16:21:06.082]                   args[[name]] <- ""
[16:21:06.082]                 }
[16:21:06.082]                 NAMES <- toupper(removed)
[16:21:06.082]                 for (kk in seq_along(NAMES)) {
[16:21:06.082]                   name <- removed[[kk]]
[16:21:06.082]                   NAME <- NAMES[[kk]]
[16:21:06.082]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.082]                     next
[16:21:06.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.082]                 }
[16:21:06.082]                 if (length(args) > 0) 
[16:21:06.082]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.082]             }
[16:21:06.082]             else {
[16:21:06.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.082]             }
[16:21:06.082]             {
[16:21:06.082]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.082]                   0L) {
[16:21:06.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.082]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.082]                   base::options(opts)
[16:21:06.082]                 }
[16:21:06.082]                 {
[16:21:06.082]                   {
[16:21:06.082]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.082]                     NULL
[16:21:06.082]                   }
[16:21:06.082]                   options(future.plan = NULL)
[16:21:06.082]                   if (is.na(NA_character_)) 
[16:21:06.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.082]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.082]                     .init = FALSE)
[16:21:06.082]                 }
[16:21:06.082]             }
[16:21:06.082]         }
[16:21:06.082]     })
[16:21:06.082]     if (TRUE) {
[16:21:06.082]         base::sink(type = "output", split = FALSE)
[16:21:06.082]         if (TRUE) {
[16:21:06.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.082]         }
[16:21:06.082]         else {
[16:21:06.082]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.082]         }
[16:21:06.082]         base::close(...future.stdout)
[16:21:06.082]         ...future.stdout <- NULL
[16:21:06.082]     }
[16:21:06.082]     ...future.result$conditions <- ...future.conditions
[16:21:06.082]     ...future.result$finished <- base::Sys.time()
[16:21:06.082]     ...future.result
[16:21:06.082] }
[16:21:06.085] Poll #1 (0): usedNodes() = 2, workers = 2
[16:21:06.097] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.097] - Validating connection of MultisessionFuture
[16:21:06.098] - received message: FutureResult
[16:21:06.098] - Received FutureResult
[16:21:06.098] - Erased future from FutureRegistry
[16:21:06.098] result() for ClusterFuture ...
[16:21:06.099] - result already collected: FutureResult
[16:21:06.099] result() for ClusterFuture ... done
[16:21:06.099] signalConditions() ...
[16:21:06.099]  - include = ‘immediateCondition’
[16:21:06.099]  - exclude = 
[16:21:06.099]  - resignal = FALSE
[16:21:06.100]  - Number of conditions: 1
[16:21:06.100] signalConditions() ... done
[16:21:06.100] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.100] result() for ClusterFuture ...
[16:21:06.100] - result already collected: FutureResult
[16:21:06.101] result() for ClusterFuture ... done
[16:21:06.101] result() for ClusterFuture ...
[16:21:06.101] - result already collected: FutureResult
[16:21:06.101] result() for ClusterFuture ... done
[16:21:06.101] signalConditions() ...
[16:21:06.101]  - include = ‘immediateCondition’
[16:21:06.101]  - exclude = 
[16:21:06.101]  - resignal = FALSE
[16:21:06.102]  - Number of conditions: 1
[16:21:06.102] signalConditions() ... done
[16:21:06.103] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:21:06.103] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:21:06.104] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:21:06.104] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:21:06.104] MultisessionFuture started
[16:21:06.104] - Launch lazy future ... done
[16:21:06.104] run() for ‘MultisessionFuture’ ... done
[16:21:06.105] result() for ClusterFuture ...
[16:21:06.105] - result already collected: FutureResult
[16:21:06.105] result() for ClusterFuture ... done
[16:21:06.105] result() for ClusterFuture ...
[16:21:06.105] - result already collected: FutureResult
[16:21:06.105] result() for ClusterFuture ... done
[16:21:06.105] signalConditions() ...
[16:21:06.105]  - include = ‘immediateCondition’
[16:21:06.105]  - exclude = 
[16:21:06.106]  - resignal = FALSE
[16:21:06.106]  - Number of conditions: 1
[16:21:06.106] signalConditions() ... done
[16:21:06.106] Future state: ‘finished’
[16:21:06.106] result() for ClusterFuture ...
[16:21:06.106] - result already collected: FutureResult
[16:21:06.106] result() for ClusterFuture ... done
[16:21:06.106] signalConditions() ...
[16:21:06.106]  - include = ‘condition’
[16:21:06.106]  - exclude = ‘immediateCondition’
[16:21:06.107]  - resignal = TRUE
[16:21:06.107]  - Number of conditions: 1
[16:21:06.107]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:21:06.107] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "b478068843b5" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:21:05"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.124] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.124] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.125] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:06.125] Searching for globals ... DONE
[16:21:06.126] Resolving globals: TRUE
[16:21:06.126] Resolving any globals that are futures ...
[16:21:06.126] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:06.126] Resolving any globals that are futures ... DONE
[16:21:06.126] Resolving futures part of globals (recursively) ...
[16:21:06.126] resolve() on list ...
[16:21:06.127]  recursive: 99
[16:21:06.127]  length: 1
[16:21:06.127]  elements: ‘ii’
[16:21:06.127]  length: 0 (resolved future 1)
[16:21:06.127] resolve() on list ... DONE
[16:21:06.127] - globals: [1] ‘ii’
[16:21:06.127] Resolving futures part of globals (recursively) ... DONE
[16:21:06.127] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:06.128] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:06.128] - globals: [1] ‘ii’
[16:21:06.128] 
[16:21:06.128] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.129] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.129] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.130] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:06.130] Searching for globals ... DONE
[16:21:06.130] Resolving globals: TRUE
[16:21:06.130] Resolving any globals that are futures ...
[16:21:06.130] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:06.131] Resolving any globals that are futures ... DONE
[16:21:06.131] Resolving futures part of globals (recursively) ...
[16:21:06.131] resolve() on list ...
[16:21:06.131]  recursive: 99
[16:21:06.131]  length: 1
[16:21:06.131]  elements: ‘ii’
[16:21:06.132]  length: 0 (resolved future 1)
[16:21:06.132] resolve() on list ... DONE
[16:21:06.132] - globals: [1] ‘ii’
[16:21:06.132] Resolving futures part of globals (recursively) ... DONE
[16:21:06.132] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:06.132] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:06.132] - globals: [1] ‘ii’
[16:21:06.133] 
[16:21:06.133] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.133] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.133] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.135] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:06.135] Searching for globals ... DONE
[16:21:06.135] Resolving globals: TRUE
[16:21:06.135] Resolving any globals that are futures ...
[16:21:06.135] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:21:06.135] Resolving any globals that are futures ... DONE
[16:21:06.136] Resolving futures part of globals (recursively) ...
[16:21:06.136] resolve() on list ...
[16:21:06.136]  recursive: 99
[16:21:06.136]  length: 1
[16:21:06.136]  elements: ‘ii’
[16:21:06.136]  length: 0 (resolved future 1)
[16:21:06.136] resolve() on list ... DONE
[16:21:06.136] - globals: [1] ‘ii’
[16:21:06.137] Resolving futures part of globals (recursively) ... DONE
[16:21:06.137] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:06.137] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:21:06.137] - globals: [1] ‘ii’
[16:21:06.137] 
[16:21:06.137] getGlobalsAndPackages() ... DONE
[16:21:06.138] run() for ‘Future’ ...
[16:21:06.138] - state: ‘created’
[16:21:06.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.154] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.154]   - Field: ‘node’
[16:21:06.155]   - Field: ‘label’
[16:21:06.155]   - Field: ‘local’
[16:21:06.155]   - Field: ‘owner’
[16:21:06.155]   - Field: ‘envir’
[16:21:06.155]   - Field: ‘workers’
[16:21:06.155]   - Field: ‘packages’
[16:21:06.155]   - Field: ‘gc’
[16:21:06.155]   - Field: ‘conditions’
[16:21:06.155]   - Field: ‘persistent’
[16:21:06.155]   - Field: ‘expr’
[16:21:06.155]   - Field: ‘uuid’
[16:21:06.156]   - Field: ‘seed’
[16:21:06.156]   - Field: ‘version’
[16:21:06.156]   - Field: ‘result’
[16:21:06.156]   - Field: ‘asynchronous’
[16:21:06.156]   - Field: ‘calls’
[16:21:06.156]   - Field: ‘globals’
[16:21:06.156]   - Field: ‘stdout’
[16:21:06.156]   - Field: ‘earlySignal’
[16:21:06.156]   - Field: ‘lazy’
[16:21:06.156]   - Field: ‘state’
[16:21:06.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.157] - Launch lazy future ...
[16:21:06.157] Packages needed by the future expression (n = 0): <none>
[16:21:06.157] Packages needed by future strategies (n = 0): <none>
[16:21:06.157] {
[16:21:06.157]     {
[16:21:06.157]         {
[16:21:06.157]             ...future.startTime <- base::Sys.time()
[16:21:06.157]             {
[16:21:06.157]                 {
[16:21:06.157]                   {
[16:21:06.157]                     {
[16:21:06.157]                       base::local({
[16:21:06.157]                         has_future <- base::requireNamespace("future", 
[16:21:06.157]                           quietly = TRUE)
[16:21:06.157]                         if (has_future) {
[16:21:06.157]                           ns <- base::getNamespace("future")
[16:21:06.157]                           version <- ns[[".package"]][["version"]]
[16:21:06.157]                           if (is.null(version)) 
[16:21:06.157]                             version <- utils::packageVersion("future")
[16:21:06.157]                         }
[16:21:06.157]                         else {
[16:21:06.157]                           version <- NULL
[16:21:06.157]                         }
[16:21:06.157]                         if (!has_future || version < "1.8.0") {
[16:21:06.157]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.157]                             "", base::R.version$version.string), 
[16:21:06.157]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:06.157]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:06.157]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.157]                               "release", "version")], collapse = " "), 
[16:21:06.157]                             hostname = base::Sys.info()[["nodename"]])
[16:21:06.157]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.157]                             info)
[16:21:06.157]                           info <- base::paste(info, collapse = "; ")
[16:21:06.157]                           if (!has_future) {
[16:21:06.157]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.157]                               info)
[16:21:06.157]                           }
[16:21:06.157]                           else {
[16:21:06.157]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.157]                               info, version)
[16:21:06.157]                           }
[16:21:06.157]                           base::stop(msg)
[16:21:06.157]                         }
[16:21:06.157]                       })
[16:21:06.157]                     }
[16:21:06.157]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.157]                     base::options(mc.cores = 1L)
[16:21:06.157]                   }
[16:21:06.157]                   ...future.strategy.old <- future::plan("list")
[16:21:06.157]                   options(future.plan = NULL)
[16:21:06.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.157]                 }
[16:21:06.157]                 ...future.workdir <- getwd()
[16:21:06.157]             }
[16:21:06.157]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.157]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.157]         }
[16:21:06.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.157]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.157]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.157]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.157]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.157]             base::names(...future.oldOptions))
[16:21:06.157]     }
[16:21:06.157]     if (FALSE) {
[16:21:06.157]     }
[16:21:06.157]     else {
[16:21:06.157]         if (TRUE) {
[16:21:06.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.157]                 open = "w")
[16:21:06.157]         }
[16:21:06.157]         else {
[16:21:06.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.157]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.157]         }
[16:21:06.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.157]             base::sink(type = "output", split = FALSE)
[16:21:06.157]             base::close(...future.stdout)
[16:21:06.157]         }, add = TRUE)
[16:21:06.157]     }
[16:21:06.157]     ...future.frame <- base::sys.nframe()
[16:21:06.157]     ...future.conditions <- base::list()
[16:21:06.157]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.157]     if (FALSE) {
[16:21:06.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.157]     }
[16:21:06.157]     ...future.result <- base::tryCatch({
[16:21:06.157]         base::withCallingHandlers({
[16:21:06.157]             ...future.value <- base::withVisible(base::local({
[16:21:06.157]                 ...future.makeSendCondition <- base::local({
[16:21:06.157]                   sendCondition <- NULL
[16:21:06.157]                   function(frame = 1L) {
[16:21:06.157]                     if (is.function(sendCondition)) 
[16:21:06.157]                       return(sendCondition)
[16:21:06.157]                     ns <- getNamespace("parallel")
[16:21:06.157]                     if (exists("sendData", mode = "function", 
[16:21:06.157]                       envir = ns)) {
[16:21:06.157]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.157]                         envir = ns)
[16:21:06.157]                       envir <- sys.frame(frame)
[16:21:06.157]                       master <- NULL
[16:21:06.157]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.157]                         !identical(envir, emptyenv())) {
[16:21:06.157]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.157]                           inherits = FALSE)) {
[16:21:06.157]                           master <- get("master", mode = "list", 
[16:21:06.157]                             envir = envir, inherits = FALSE)
[16:21:06.157]                           if (inherits(master, c("SOCKnode", 
[16:21:06.157]                             "SOCK0node"))) {
[16:21:06.157]                             sendCondition <<- function(cond) {
[16:21:06.157]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.157]                                 success = TRUE)
[16:21:06.157]                               parallel_sendData(master, data)
[16:21:06.157]                             }
[16:21:06.157]                             return(sendCondition)
[16:21:06.157]                           }
[16:21:06.157]                         }
[16:21:06.157]                         frame <- frame + 1L
[16:21:06.157]                         envir <- sys.frame(frame)
[16:21:06.157]                       }
[16:21:06.157]                     }
[16:21:06.157]                     sendCondition <<- function(cond) NULL
[16:21:06.157]                   }
[16:21:06.157]                 })
[16:21:06.157]                 withCallingHandlers({
[16:21:06.157]                   {
[16:21:06.157]                     b <- a * ii
[16:21:06.157]                     a <- 0
[16:21:06.157]                     b
[16:21:06.157]                   }
[16:21:06.157]                 }, immediateCondition = function(cond) {
[16:21:06.157]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.157]                   sendCondition(cond)
[16:21:06.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.157]                   {
[16:21:06.157]                     inherits <- base::inherits
[16:21:06.157]                     invokeRestart <- base::invokeRestart
[16:21:06.157]                     is.null <- base::is.null
[16:21:06.157]                     muffled <- FALSE
[16:21:06.157]                     if (inherits(cond, "message")) {
[16:21:06.157]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.157]                       if (muffled) 
[16:21:06.157]                         invokeRestart("muffleMessage")
[16:21:06.157]                     }
[16:21:06.157]                     else if (inherits(cond, "warning")) {
[16:21:06.157]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.157]                       if (muffled) 
[16:21:06.157]                         invokeRestart("muffleWarning")
[16:21:06.157]                     }
[16:21:06.157]                     else if (inherits(cond, "condition")) {
[16:21:06.157]                       if (!is.null(pattern)) {
[16:21:06.157]                         computeRestarts <- base::computeRestarts
[16:21:06.157]                         grepl <- base::grepl
[16:21:06.157]                         restarts <- computeRestarts(cond)
[16:21:06.157]                         for (restart in restarts) {
[16:21:06.157]                           name <- restart$name
[16:21:06.157]                           if (is.null(name)) 
[16:21:06.157]                             next
[16:21:06.157]                           if (!grepl(pattern, name)) 
[16:21:06.157]                             next
[16:21:06.157]                           invokeRestart(restart)
[16:21:06.157]                           muffled <- TRUE
[16:21:06.157]                           break
[16:21:06.157]                         }
[16:21:06.157]                       }
[16:21:06.157]                     }
[16:21:06.157]                     invisible(muffled)
[16:21:06.157]                   }
[16:21:06.157]                   muffleCondition(cond)
[16:21:06.157]                 })
[16:21:06.157]             }))
[16:21:06.157]             future::FutureResult(value = ...future.value$value, 
[16:21:06.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.157]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.157]                     ...future.globalenv.names))
[16:21:06.157]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.157]         }, condition = base::local({
[16:21:06.157]             c <- base::c
[16:21:06.157]             inherits <- base::inherits
[16:21:06.157]             invokeRestart <- base::invokeRestart
[16:21:06.157]             length <- base::length
[16:21:06.157]             list <- base::list
[16:21:06.157]             seq.int <- base::seq.int
[16:21:06.157]             signalCondition <- base::signalCondition
[16:21:06.157]             sys.calls <- base::sys.calls
[16:21:06.157]             `[[` <- base::`[[`
[16:21:06.157]             `+` <- base::`+`
[16:21:06.157]             `<<-` <- base::`<<-`
[16:21:06.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.157]                   3L)]
[16:21:06.157]             }
[16:21:06.157]             function(cond) {
[16:21:06.157]                 is_error <- inherits(cond, "error")
[16:21:06.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.157]                   NULL)
[16:21:06.157]                 if (is_error) {
[16:21:06.157]                   sessionInformation <- function() {
[16:21:06.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.157]                       search = base::search(), system = base::Sys.info())
[16:21:06.157]                   }
[16:21:06.157]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.157]                     cond$call), session = sessionInformation(), 
[16:21:06.157]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.157]                   signalCondition(cond)
[16:21:06.157]                 }
[16:21:06.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.157]                 "immediateCondition"))) {
[16:21:06.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.157]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.157]                   if (TRUE && !signal) {
[16:21:06.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.157]                     {
[16:21:06.157]                       inherits <- base::inherits
[16:21:06.157]                       invokeRestart <- base::invokeRestart
[16:21:06.157]                       is.null <- base::is.null
[16:21:06.157]                       muffled <- FALSE
[16:21:06.157]                       if (inherits(cond, "message")) {
[16:21:06.157]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.157]                         if (muffled) 
[16:21:06.157]                           invokeRestart("muffleMessage")
[16:21:06.157]                       }
[16:21:06.157]                       else if (inherits(cond, "warning")) {
[16:21:06.157]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.157]                         if (muffled) 
[16:21:06.157]                           invokeRestart("muffleWarning")
[16:21:06.157]                       }
[16:21:06.157]                       else if (inherits(cond, "condition")) {
[16:21:06.157]                         if (!is.null(pattern)) {
[16:21:06.157]                           computeRestarts <- base::computeRestarts
[16:21:06.157]                           grepl <- base::grepl
[16:21:06.157]                           restarts <- computeRestarts(cond)
[16:21:06.157]                           for (restart in restarts) {
[16:21:06.157]                             name <- restart$name
[16:21:06.157]                             if (is.null(name)) 
[16:21:06.157]                               next
[16:21:06.157]                             if (!grepl(pattern, name)) 
[16:21:06.157]                               next
[16:21:06.157]                             invokeRestart(restart)
[16:21:06.157]                             muffled <- TRUE
[16:21:06.157]                             break
[16:21:06.157]                           }
[16:21:06.157]                         }
[16:21:06.157]                       }
[16:21:06.157]                       invisible(muffled)
[16:21:06.157]                     }
[16:21:06.157]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.157]                   }
[16:21:06.157]                 }
[16:21:06.157]                 else {
[16:21:06.157]                   if (TRUE) {
[16:21:06.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.157]                     {
[16:21:06.157]                       inherits <- base::inherits
[16:21:06.157]                       invokeRestart <- base::invokeRestart
[16:21:06.157]                       is.null <- base::is.null
[16:21:06.157]                       muffled <- FALSE
[16:21:06.157]                       if (inherits(cond, "message")) {
[16:21:06.157]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.157]                         if (muffled) 
[16:21:06.157]                           invokeRestart("muffleMessage")
[16:21:06.157]                       }
[16:21:06.157]                       else if (inherits(cond, "warning")) {
[16:21:06.157]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.157]                         if (muffled) 
[16:21:06.157]                           invokeRestart("muffleWarning")
[16:21:06.157]                       }
[16:21:06.157]                       else if (inherits(cond, "condition")) {
[16:21:06.157]                         if (!is.null(pattern)) {
[16:21:06.157]                           computeRestarts <- base::computeRestarts
[16:21:06.157]                           grepl <- base::grepl
[16:21:06.157]                           restarts <- computeRestarts(cond)
[16:21:06.157]                           for (restart in restarts) {
[16:21:06.157]                             name <- restart$name
[16:21:06.157]                             if (is.null(name)) 
[16:21:06.157]                               next
[16:21:06.157]                             if (!grepl(pattern, name)) 
[16:21:06.157]                               next
[16:21:06.157]                             invokeRestart(restart)
[16:21:06.157]                             muffled <- TRUE
[16:21:06.157]                             break
[16:21:06.157]                           }
[16:21:06.157]                         }
[16:21:06.157]                       }
[16:21:06.157]                       invisible(muffled)
[16:21:06.157]                     }
[16:21:06.157]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.157]                   }
[16:21:06.157]                 }
[16:21:06.157]             }
[16:21:06.157]         }))
[16:21:06.157]     }, error = function(ex) {
[16:21:06.157]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.157]                 ...future.rng), started = ...future.startTime, 
[16:21:06.157]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.157]             version = "1.8"), class = "FutureResult")
[16:21:06.157]     }, finally = {
[16:21:06.157]         if (!identical(...future.workdir, getwd())) 
[16:21:06.157]             setwd(...future.workdir)
[16:21:06.157]         {
[16:21:06.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.157]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.157]             }
[16:21:06.157]             base::options(...future.oldOptions)
[16:21:06.157]             if (.Platform$OS.type == "windows") {
[16:21:06.157]                 old_names <- names(...future.oldEnvVars)
[16:21:06.157]                 envs <- base::Sys.getenv()
[16:21:06.157]                 names <- names(envs)
[16:21:06.157]                 common <- intersect(names, old_names)
[16:21:06.157]                 added <- setdiff(names, old_names)
[16:21:06.157]                 removed <- setdiff(old_names, names)
[16:21:06.157]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.157]                   envs[common]]
[16:21:06.157]                 NAMES <- toupper(changed)
[16:21:06.157]                 args <- list()
[16:21:06.157]                 for (kk in seq_along(NAMES)) {
[16:21:06.157]                   name <- changed[[kk]]
[16:21:06.157]                   NAME <- NAMES[[kk]]
[16:21:06.157]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.157]                     next
[16:21:06.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.157]                 }
[16:21:06.157]                 NAMES <- toupper(added)
[16:21:06.157]                 for (kk in seq_along(NAMES)) {
[16:21:06.157]                   name <- added[[kk]]
[16:21:06.157]                   NAME <- NAMES[[kk]]
[16:21:06.157]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.157]                     next
[16:21:06.157]                   args[[name]] <- ""
[16:21:06.157]                 }
[16:21:06.157]                 NAMES <- toupper(removed)
[16:21:06.157]                 for (kk in seq_along(NAMES)) {
[16:21:06.157]                   name <- removed[[kk]]
[16:21:06.157]                   NAME <- NAMES[[kk]]
[16:21:06.157]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.157]                     next
[16:21:06.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.157]                 }
[16:21:06.157]                 if (length(args) > 0) 
[16:21:06.157]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.157]             }
[16:21:06.157]             else {
[16:21:06.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.157]             }
[16:21:06.157]             {
[16:21:06.157]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.157]                   0L) {
[16:21:06.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.157]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.157]                   base::options(opts)
[16:21:06.157]                 }
[16:21:06.157]                 {
[16:21:06.157]                   {
[16:21:06.157]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.157]                     NULL
[16:21:06.157]                   }
[16:21:06.157]                   options(future.plan = NULL)
[16:21:06.157]                   if (is.na(NA_character_)) 
[16:21:06.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.157]                     .init = FALSE)
[16:21:06.157]                 }
[16:21:06.157]             }
[16:21:06.157]         }
[16:21:06.157]     })
[16:21:06.157]     if (TRUE) {
[16:21:06.157]         base::sink(type = "output", split = FALSE)
[16:21:06.157]         if (TRUE) {
[16:21:06.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.157]         }
[16:21:06.157]         else {
[16:21:06.157]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.157]         }
[16:21:06.157]         base::close(...future.stdout)
[16:21:06.157]         ...future.stdout <- NULL
[16:21:06.157]     }
[16:21:06.157]     ...future.result$conditions <- ...future.conditions
[16:21:06.157]     ...future.result$finished <- base::Sys.time()
[16:21:06.157]     ...future.result
[16:21:06.157] }
[16:21:06.160] Poll #1 (0): usedNodes() = 2, workers = 2
[16:21:06.170] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.170] - Validating connection of MultisessionFuture
[16:21:06.171] - received message: FutureResult
[16:21:06.171] - Received FutureResult
[16:21:06.171] - Erased future from FutureRegistry
[16:21:06.171] result() for ClusterFuture ...
[16:21:06.171] - result already collected: FutureResult
[16:21:06.172] result() for ClusterFuture ... done
[16:21:06.172] signalConditions() ...
[16:21:06.172]  - include = ‘immediateCondition’
[16:21:06.172]  - exclude = 
[16:21:06.172]  - resignal = FALSE
[16:21:06.172]  - Number of conditions: 1
[16:21:06.172] signalConditions() ... done
[16:21:06.172] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.172] result() for ClusterFuture ...
[16:21:06.172] - result already collected: FutureResult
[16:21:06.173] result() for ClusterFuture ... done
[16:21:06.173] result() for ClusterFuture ...
[16:21:06.173] - result already collected: FutureResult
[16:21:06.173] result() for ClusterFuture ... done
[16:21:06.173] signalConditions() ...
[16:21:06.173]  - include = ‘immediateCondition’
[16:21:06.173]  - exclude = 
[16:21:06.173]  - resignal = FALSE
[16:21:06.173]  - Number of conditions: 1
[16:21:06.173] signalConditions() ... done
[16:21:06.174] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:21:06.174] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:21:06.175] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:21:06.175] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:21:06.175] MultisessionFuture started
[16:21:06.175] - Launch lazy future ... done
[16:21:06.175] run() for ‘MultisessionFuture’ ... done
[16:21:06.176] result() for ClusterFuture ...
[16:21:06.176] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.176] - Validating connection of MultisessionFuture
[16:21:06.181] - received message: FutureResult
[16:21:06.182] - Received FutureResult
[16:21:06.182] - Erased future from FutureRegistry
[16:21:06.182] result() for ClusterFuture ...
[16:21:06.182] - result already collected: FutureResult
[16:21:06.182] result() for ClusterFuture ... done
[16:21:06.182] signalConditions() ...
[16:21:06.182]  - include = ‘immediateCondition’
[16:21:06.182]  - exclude = 
[16:21:06.182]  - resignal = FALSE
[16:21:06.182]  - Number of conditions: 1
[16:21:06.182] signalConditions() ... done
[16:21:06.183] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.183] result() for ClusterFuture ... done
[16:21:06.183] result() for ClusterFuture ...
[16:21:06.183] - result already collected: FutureResult
[16:21:06.183] result() for ClusterFuture ... done
[16:21:06.183] signalConditions() ...
[16:21:06.183]  - include = ‘immediateCondition’
[16:21:06.183]  - exclude = 
[16:21:06.183]  - resignal = FALSE
[16:21:06.183]  - Number of conditions: 1
[16:21:06.183] signalConditions() ... done
[16:21:06.183] Future state: ‘finished’
[16:21:06.184] result() for ClusterFuture ...
[16:21:06.184] - result already collected: FutureResult
[16:21:06.184] result() for ClusterFuture ... done
[16:21:06.184] signalConditions() ...
[16:21:06.184]  - include = ‘condition’
[16:21:06.184]  - exclude = ‘immediateCondition’
[16:21:06.184]  - resignal = TRUE
[16:21:06.184]  - Number of conditions: 1
[16:21:06.184]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:21:06.184] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "b478068843b5" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:21:06"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.198] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.198] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.199] 
[16:21:06.199] Searching for globals ... DONE
[16:21:06.199] - globals: [0] <none>
[16:21:06.199] getGlobalsAndPackages() ... DONE
[16:21:06.200] run() for ‘Future’ ...
[16:21:06.200] - state: ‘created’
[16:21:06.200] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.214] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.214] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.214]   - Field: ‘node’
[16:21:06.214]   - Field: ‘label’
[16:21:06.214]   - Field: ‘local’
[16:21:06.214]   - Field: ‘owner’
[16:21:06.215]   - Field: ‘envir’
[16:21:06.215]   - Field: ‘workers’
[16:21:06.215]   - Field: ‘packages’
[16:21:06.215]   - Field: ‘gc’
[16:21:06.215]   - Field: ‘conditions’
[16:21:06.215]   - Field: ‘persistent’
[16:21:06.215]   - Field: ‘expr’
[16:21:06.215]   - Field: ‘uuid’
[16:21:06.215]   - Field: ‘seed’
[16:21:06.215]   - Field: ‘version’
[16:21:06.216]   - Field: ‘result’
[16:21:06.216]   - Field: ‘asynchronous’
[16:21:06.216]   - Field: ‘calls’
[16:21:06.216]   - Field: ‘globals’
[16:21:06.216]   - Field: ‘stdout’
[16:21:06.216]   - Field: ‘earlySignal’
[16:21:06.216]   - Field: ‘lazy’
[16:21:06.216]   - Field: ‘state’
[16:21:06.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.216] - Launch lazy future ...
[16:21:06.217] Packages needed by the future expression (n = 0): <none>
[16:21:06.217] Packages needed by future strategies (n = 0): <none>
[16:21:06.217] {
[16:21:06.217]     {
[16:21:06.217]         {
[16:21:06.217]             ...future.startTime <- base::Sys.time()
[16:21:06.217]             {
[16:21:06.217]                 {
[16:21:06.217]                   {
[16:21:06.217]                     {
[16:21:06.217]                       base::local({
[16:21:06.217]                         has_future <- base::requireNamespace("future", 
[16:21:06.217]                           quietly = TRUE)
[16:21:06.217]                         if (has_future) {
[16:21:06.217]                           ns <- base::getNamespace("future")
[16:21:06.217]                           version <- ns[[".package"]][["version"]]
[16:21:06.217]                           if (is.null(version)) 
[16:21:06.217]                             version <- utils::packageVersion("future")
[16:21:06.217]                         }
[16:21:06.217]                         else {
[16:21:06.217]                           version <- NULL
[16:21:06.217]                         }
[16:21:06.217]                         if (!has_future || version < "1.8.0") {
[16:21:06.217]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.217]                             "", base::R.version$version.string), 
[16:21:06.217]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:06.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:06.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.217]                               "release", "version")], collapse = " "), 
[16:21:06.217]                             hostname = base::Sys.info()[["nodename"]])
[16:21:06.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.217]                             info)
[16:21:06.217]                           info <- base::paste(info, collapse = "; ")
[16:21:06.217]                           if (!has_future) {
[16:21:06.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.217]                               info)
[16:21:06.217]                           }
[16:21:06.217]                           else {
[16:21:06.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.217]                               info, version)
[16:21:06.217]                           }
[16:21:06.217]                           base::stop(msg)
[16:21:06.217]                         }
[16:21:06.217]                       })
[16:21:06.217]                     }
[16:21:06.217]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.217]                     base::options(mc.cores = 1L)
[16:21:06.217]                   }
[16:21:06.217]                   ...future.strategy.old <- future::plan("list")
[16:21:06.217]                   options(future.plan = NULL)
[16:21:06.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.217]                 }
[16:21:06.217]                 ...future.workdir <- getwd()
[16:21:06.217]             }
[16:21:06.217]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.217]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.217]         }
[16:21:06.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.217]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.217]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.217]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.217]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.217]             base::names(...future.oldOptions))
[16:21:06.217]     }
[16:21:06.217]     if (FALSE) {
[16:21:06.217]     }
[16:21:06.217]     else {
[16:21:06.217]         if (TRUE) {
[16:21:06.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.217]                 open = "w")
[16:21:06.217]         }
[16:21:06.217]         else {
[16:21:06.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.217]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.217]         }
[16:21:06.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.217]             base::sink(type = "output", split = FALSE)
[16:21:06.217]             base::close(...future.stdout)
[16:21:06.217]         }, add = TRUE)
[16:21:06.217]     }
[16:21:06.217]     ...future.frame <- base::sys.nframe()
[16:21:06.217]     ...future.conditions <- base::list()
[16:21:06.217]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.217]     if (FALSE) {
[16:21:06.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.217]     }
[16:21:06.217]     ...future.result <- base::tryCatch({
[16:21:06.217]         base::withCallingHandlers({
[16:21:06.217]             ...future.value <- base::withVisible(base::local({
[16:21:06.217]                 ...future.makeSendCondition <- base::local({
[16:21:06.217]                   sendCondition <- NULL
[16:21:06.217]                   function(frame = 1L) {
[16:21:06.217]                     if (is.function(sendCondition)) 
[16:21:06.217]                       return(sendCondition)
[16:21:06.217]                     ns <- getNamespace("parallel")
[16:21:06.217]                     if (exists("sendData", mode = "function", 
[16:21:06.217]                       envir = ns)) {
[16:21:06.217]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.217]                         envir = ns)
[16:21:06.217]                       envir <- sys.frame(frame)
[16:21:06.217]                       master <- NULL
[16:21:06.217]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.217]                         !identical(envir, emptyenv())) {
[16:21:06.217]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.217]                           inherits = FALSE)) {
[16:21:06.217]                           master <- get("master", mode = "list", 
[16:21:06.217]                             envir = envir, inherits = FALSE)
[16:21:06.217]                           if (inherits(master, c("SOCKnode", 
[16:21:06.217]                             "SOCK0node"))) {
[16:21:06.217]                             sendCondition <<- function(cond) {
[16:21:06.217]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.217]                                 success = TRUE)
[16:21:06.217]                               parallel_sendData(master, data)
[16:21:06.217]                             }
[16:21:06.217]                             return(sendCondition)
[16:21:06.217]                           }
[16:21:06.217]                         }
[16:21:06.217]                         frame <- frame + 1L
[16:21:06.217]                         envir <- sys.frame(frame)
[16:21:06.217]                       }
[16:21:06.217]                     }
[16:21:06.217]                     sendCondition <<- function(cond) NULL
[16:21:06.217]                   }
[16:21:06.217]                 })
[16:21:06.217]                 withCallingHandlers({
[16:21:06.217]                   1
[16:21:06.217]                 }, immediateCondition = function(cond) {
[16:21:06.217]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.217]                   sendCondition(cond)
[16:21:06.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.217]                   {
[16:21:06.217]                     inherits <- base::inherits
[16:21:06.217]                     invokeRestart <- base::invokeRestart
[16:21:06.217]                     is.null <- base::is.null
[16:21:06.217]                     muffled <- FALSE
[16:21:06.217]                     if (inherits(cond, "message")) {
[16:21:06.217]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.217]                       if (muffled) 
[16:21:06.217]                         invokeRestart("muffleMessage")
[16:21:06.217]                     }
[16:21:06.217]                     else if (inherits(cond, "warning")) {
[16:21:06.217]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.217]                       if (muffled) 
[16:21:06.217]                         invokeRestart("muffleWarning")
[16:21:06.217]                     }
[16:21:06.217]                     else if (inherits(cond, "condition")) {
[16:21:06.217]                       if (!is.null(pattern)) {
[16:21:06.217]                         computeRestarts <- base::computeRestarts
[16:21:06.217]                         grepl <- base::grepl
[16:21:06.217]                         restarts <- computeRestarts(cond)
[16:21:06.217]                         for (restart in restarts) {
[16:21:06.217]                           name <- restart$name
[16:21:06.217]                           if (is.null(name)) 
[16:21:06.217]                             next
[16:21:06.217]                           if (!grepl(pattern, name)) 
[16:21:06.217]                             next
[16:21:06.217]                           invokeRestart(restart)
[16:21:06.217]                           muffled <- TRUE
[16:21:06.217]                           break
[16:21:06.217]                         }
[16:21:06.217]                       }
[16:21:06.217]                     }
[16:21:06.217]                     invisible(muffled)
[16:21:06.217]                   }
[16:21:06.217]                   muffleCondition(cond)
[16:21:06.217]                 })
[16:21:06.217]             }))
[16:21:06.217]             future::FutureResult(value = ...future.value$value, 
[16:21:06.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.217]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.217]                     ...future.globalenv.names))
[16:21:06.217]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.217]         }, condition = base::local({
[16:21:06.217]             c <- base::c
[16:21:06.217]             inherits <- base::inherits
[16:21:06.217]             invokeRestart <- base::invokeRestart
[16:21:06.217]             length <- base::length
[16:21:06.217]             list <- base::list
[16:21:06.217]             seq.int <- base::seq.int
[16:21:06.217]             signalCondition <- base::signalCondition
[16:21:06.217]             sys.calls <- base::sys.calls
[16:21:06.217]             `[[` <- base::`[[`
[16:21:06.217]             `+` <- base::`+`
[16:21:06.217]             `<<-` <- base::`<<-`
[16:21:06.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.217]                   3L)]
[16:21:06.217]             }
[16:21:06.217]             function(cond) {
[16:21:06.217]                 is_error <- inherits(cond, "error")
[16:21:06.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.217]                   NULL)
[16:21:06.217]                 if (is_error) {
[16:21:06.217]                   sessionInformation <- function() {
[16:21:06.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.217]                       search = base::search(), system = base::Sys.info())
[16:21:06.217]                   }
[16:21:06.217]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.217]                     cond$call), session = sessionInformation(), 
[16:21:06.217]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.217]                   signalCondition(cond)
[16:21:06.217]                 }
[16:21:06.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.217]                 "immediateCondition"))) {
[16:21:06.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.217]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.217]                   if (TRUE && !signal) {
[16:21:06.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.217]                     {
[16:21:06.217]                       inherits <- base::inherits
[16:21:06.217]                       invokeRestart <- base::invokeRestart
[16:21:06.217]                       is.null <- base::is.null
[16:21:06.217]                       muffled <- FALSE
[16:21:06.217]                       if (inherits(cond, "message")) {
[16:21:06.217]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.217]                         if (muffled) 
[16:21:06.217]                           invokeRestart("muffleMessage")
[16:21:06.217]                       }
[16:21:06.217]                       else if (inherits(cond, "warning")) {
[16:21:06.217]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.217]                         if (muffled) 
[16:21:06.217]                           invokeRestart("muffleWarning")
[16:21:06.217]                       }
[16:21:06.217]                       else if (inherits(cond, "condition")) {
[16:21:06.217]                         if (!is.null(pattern)) {
[16:21:06.217]                           computeRestarts <- base::computeRestarts
[16:21:06.217]                           grepl <- base::grepl
[16:21:06.217]                           restarts <- computeRestarts(cond)
[16:21:06.217]                           for (restart in restarts) {
[16:21:06.217]                             name <- restart$name
[16:21:06.217]                             if (is.null(name)) 
[16:21:06.217]                               next
[16:21:06.217]                             if (!grepl(pattern, name)) 
[16:21:06.217]                               next
[16:21:06.217]                             invokeRestart(restart)
[16:21:06.217]                             muffled <- TRUE
[16:21:06.217]                             break
[16:21:06.217]                           }
[16:21:06.217]                         }
[16:21:06.217]                       }
[16:21:06.217]                       invisible(muffled)
[16:21:06.217]                     }
[16:21:06.217]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.217]                   }
[16:21:06.217]                 }
[16:21:06.217]                 else {
[16:21:06.217]                   if (TRUE) {
[16:21:06.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.217]                     {
[16:21:06.217]                       inherits <- base::inherits
[16:21:06.217]                       invokeRestart <- base::invokeRestart
[16:21:06.217]                       is.null <- base::is.null
[16:21:06.217]                       muffled <- FALSE
[16:21:06.217]                       if (inherits(cond, "message")) {
[16:21:06.217]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.217]                         if (muffled) 
[16:21:06.217]                           invokeRestart("muffleMessage")
[16:21:06.217]                       }
[16:21:06.217]                       else if (inherits(cond, "warning")) {
[16:21:06.217]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.217]                         if (muffled) 
[16:21:06.217]                           invokeRestart("muffleWarning")
[16:21:06.217]                       }
[16:21:06.217]                       else if (inherits(cond, "condition")) {
[16:21:06.217]                         if (!is.null(pattern)) {
[16:21:06.217]                           computeRestarts <- base::computeRestarts
[16:21:06.217]                           grepl <- base::grepl
[16:21:06.217]                           restarts <- computeRestarts(cond)
[16:21:06.217]                           for (restart in restarts) {
[16:21:06.217]                             name <- restart$name
[16:21:06.217]                             if (is.null(name)) 
[16:21:06.217]                               next
[16:21:06.217]                             if (!grepl(pattern, name)) 
[16:21:06.217]                               next
[16:21:06.217]                             invokeRestart(restart)
[16:21:06.217]                             muffled <- TRUE
[16:21:06.217]                             break
[16:21:06.217]                           }
[16:21:06.217]                         }
[16:21:06.217]                       }
[16:21:06.217]                       invisible(muffled)
[16:21:06.217]                     }
[16:21:06.217]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.217]                   }
[16:21:06.217]                 }
[16:21:06.217]             }
[16:21:06.217]         }))
[16:21:06.217]     }, error = function(ex) {
[16:21:06.217]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.217]                 ...future.rng), started = ...future.startTime, 
[16:21:06.217]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.217]             version = "1.8"), class = "FutureResult")
[16:21:06.217]     }, finally = {
[16:21:06.217]         if (!identical(...future.workdir, getwd())) 
[16:21:06.217]             setwd(...future.workdir)
[16:21:06.217]         {
[16:21:06.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.217]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.217]             }
[16:21:06.217]             base::options(...future.oldOptions)
[16:21:06.217]             if (.Platform$OS.type == "windows") {
[16:21:06.217]                 old_names <- names(...future.oldEnvVars)
[16:21:06.217]                 envs <- base::Sys.getenv()
[16:21:06.217]                 names <- names(envs)
[16:21:06.217]                 common <- intersect(names, old_names)
[16:21:06.217]                 added <- setdiff(names, old_names)
[16:21:06.217]                 removed <- setdiff(old_names, names)
[16:21:06.217]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.217]                   envs[common]]
[16:21:06.217]                 NAMES <- toupper(changed)
[16:21:06.217]                 args <- list()
[16:21:06.217]                 for (kk in seq_along(NAMES)) {
[16:21:06.217]                   name <- changed[[kk]]
[16:21:06.217]                   NAME <- NAMES[[kk]]
[16:21:06.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.217]                     next
[16:21:06.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.217]                 }
[16:21:06.217]                 NAMES <- toupper(added)
[16:21:06.217]                 for (kk in seq_along(NAMES)) {
[16:21:06.217]                   name <- added[[kk]]
[16:21:06.217]                   NAME <- NAMES[[kk]]
[16:21:06.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.217]                     next
[16:21:06.217]                   args[[name]] <- ""
[16:21:06.217]                 }
[16:21:06.217]                 NAMES <- toupper(removed)
[16:21:06.217]                 for (kk in seq_along(NAMES)) {
[16:21:06.217]                   name <- removed[[kk]]
[16:21:06.217]                   NAME <- NAMES[[kk]]
[16:21:06.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.217]                     next
[16:21:06.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.217]                 }
[16:21:06.217]                 if (length(args) > 0) 
[16:21:06.217]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.217]             }
[16:21:06.217]             else {
[16:21:06.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.217]             }
[16:21:06.217]             {
[16:21:06.217]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.217]                   0L) {
[16:21:06.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.217]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.217]                   base::options(opts)
[16:21:06.217]                 }
[16:21:06.217]                 {
[16:21:06.217]                   {
[16:21:06.217]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.217]                     NULL
[16:21:06.217]                   }
[16:21:06.217]                   options(future.plan = NULL)
[16:21:06.217]                   if (is.na(NA_character_)) 
[16:21:06.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.217]                     .init = FALSE)
[16:21:06.217]                 }
[16:21:06.217]             }
[16:21:06.217]         }
[16:21:06.217]     })
[16:21:06.217]     if (TRUE) {
[16:21:06.217]         base::sink(type = "output", split = FALSE)
[16:21:06.217]         if (TRUE) {
[16:21:06.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.217]         }
[16:21:06.217]         else {
[16:21:06.217]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.217]         }
[16:21:06.217]         base::close(...future.stdout)
[16:21:06.217]         ...future.stdout <- NULL
[16:21:06.217]     }
[16:21:06.217]     ...future.result$conditions <- ...future.conditions
[16:21:06.217]     ...future.result$finished <- base::Sys.time()
[16:21:06.217]     ...future.result
[16:21:06.217] }
[16:21:06.220] MultisessionFuture started
[16:21:06.220] - Launch lazy future ... done
[16:21:06.220] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.221] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.221] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.222] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:06.222] Searching for globals ... DONE
[16:21:06.222] Resolving globals: TRUE
[16:21:06.222] Resolving any globals that are futures ...
[16:21:06.222] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:06.222] Resolving any globals that are futures ... DONE
[16:21:06.223] Resolving futures part of globals (recursively) ...
[16:21:06.223] resolve() on list ...
[16:21:06.223]  recursive: 99
[16:21:06.223]  length: 1
[16:21:06.223]  elements: ‘a’
[16:21:06.224] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.224] - Validating connection of MultisessionFuture
[16:21:06.224] - received message: FutureResult
[16:21:06.224] - Received FutureResult
[16:21:06.224] - Erased future from FutureRegistry
[16:21:06.224] result() for ClusterFuture ...
[16:21:06.224] - result already collected: FutureResult
[16:21:06.224] result() for ClusterFuture ... done
[16:21:06.225] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.225] Future #1
[16:21:06.225] result() for ClusterFuture ...
[16:21:06.225] - result already collected: FutureResult
[16:21:06.225] result() for ClusterFuture ... done
[16:21:06.225] result() for ClusterFuture ...
[16:21:06.225] - result already collected: FutureResult
[16:21:06.225] result() for ClusterFuture ... done
[16:21:06.225] A MultisessionFuture was resolved
[16:21:06.225]  length: 0 (resolved future 1)
[16:21:06.226] resolve() on list ... DONE
[16:21:06.226] - globals: [1] ‘a’
[16:21:06.226] Resolving futures part of globals (recursively) ... DONE
[16:21:06.227] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[16:21:06.227] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[16:21:06.227] - globals: [1] ‘a’
[16:21:06.227] - packages: [1] ‘future’
[16:21:06.227] getGlobalsAndPackages() ... DONE
[16:21:06.228] run() for ‘Future’ ...
[16:21:06.228] - state: ‘created’
[16:21:06.228] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.242] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.242]   - Field: ‘node’
[16:21:06.242]   - Field: ‘label’
[16:21:06.242]   - Field: ‘local’
[16:21:06.242]   - Field: ‘owner’
[16:21:06.242]   - Field: ‘envir’
[16:21:06.242]   - Field: ‘workers’
[16:21:06.242]   - Field: ‘packages’
[16:21:06.243]   - Field: ‘gc’
[16:21:06.243]   - Field: ‘conditions’
[16:21:06.243]   - Field: ‘persistent’
[16:21:06.243]   - Field: ‘expr’
[16:21:06.243]   - Field: ‘uuid’
[16:21:06.243]   - Field: ‘seed’
[16:21:06.243]   - Field: ‘version’
[16:21:06.245]   - Field: ‘result’
[16:21:06.245]   - Field: ‘asynchronous’
[16:21:06.245]   - Field: ‘calls’
[16:21:06.246]   - Field: ‘globals’
[16:21:06.246]   - Field: ‘stdout’
[16:21:06.246]   - Field: ‘earlySignal’
[16:21:06.246]   - Field: ‘lazy’
[16:21:06.246]   - Field: ‘state’
[16:21:06.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.246] - Launch lazy future ...
[16:21:06.246] Packages needed by the future expression (n = 1): ‘future’
[16:21:06.246] Packages needed by future strategies (n = 0): <none>
[16:21:06.247] {
[16:21:06.247]     {
[16:21:06.247]         {
[16:21:06.247]             ...future.startTime <- base::Sys.time()
[16:21:06.247]             {
[16:21:06.247]                 {
[16:21:06.247]                   {
[16:21:06.247]                     {
[16:21:06.247]                       {
[16:21:06.247]                         base::local({
[16:21:06.247]                           has_future <- base::requireNamespace("future", 
[16:21:06.247]                             quietly = TRUE)
[16:21:06.247]                           if (has_future) {
[16:21:06.247]                             ns <- base::getNamespace("future")
[16:21:06.247]                             version <- ns[[".package"]][["version"]]
[16:21:06.247]                             if (is.null(version)) 
[16:21:06.247]                               version <- utils::packageVersion("future")
[16:21:06.247]                           }
[16:21:06.247]                           else {
[16:21:06.247]                             version <- NULL
[16:21:06.247]                           }
[16:21:06.247]                           if (!has_future || version < "1.8.0") {
[16:21:06.247]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.247]                               "", base::R.version$version.string), 
[16:21:06.247]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:06.247]                                 base::R.version$platform, 8 * 
[16:21:06.247]                                   base::.Machine$sizeof.pointer), 
[16:21:06.247]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.247]                                 "release", "version")], collapse = " "), 
[16:21:06.247]                               hostname = base::Sys.info()[["nodename"]])
[16:21:06.247]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.247]                               info)
[16:21:06.247]                             info <- base::paste(info, collapse = "; ")
[16:21:06.247]                             if (!has_future) {
[16:21:06.247]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.247]                                 info)
[16:21:06.247]                             }
[16:21:06.247]                             else {
[16:21:06.247]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.247]                                 info, version)
[16:21:06.247]                             }
[16:21:06.247]                             base::stop(msg)
[16:21:06.247]                           }
[16:21:06.247]                         })
[16:21:06.247]                       }
[16:21:06.247]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.247]                       base::options(mc.cores = 1L)
[16:21:06.247]                     }
[16:21:06.247]                     base::local({
[16:21:06.247]                       for (pkg in "future") {
[16:21:06.247]                         base::loadNamespace(pkg)
[16:21:06.247]                         base::library(pkg, character.only = TRUE)
[16:21:06.247]                       }
[16:21:06.247]                     })
[16:21:06.247]                   }
[16:21:06.247]                   ...future.strategy.old <- future::plan("list")
[16:21:06.247]                   options(future.plan = NULL)
[16:21:06.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.247]                 }
[16:21:06.247]                 ...future.workdir <- getwd()
[16:21:06.247]             }
[16:21:06.247]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.247]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.247]         }
[16:21:06.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.247]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.247]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.247]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.247]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.247]             base::names(...future.oldOptions))
[16:21:06.247]     }
[16:21:06.247]     if (FALSE) {
[16:21:06.247]     }
[16:21:06.247]     else {
[16:21:06.247]         if (TRUE) {
[16:21:06.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.247]                 open = "w")
[16:21:06.247]         }
[16:21:06.247]         else {
[16:21:06.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.247]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.247]         }
[16:21:06.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.247]             base::sink(type = "output", split = FALSE)
[16:21:06.247]             base::close(...future.stdout)
[16:21:06.247]         }, add = TRUE)
[16:21:06.247]     }
[16:21:06.247]     ...future.frame <- base::sys.nframe()
[16:21:06.247]     ...future.conditions <- base::list()
[16:21:06.247]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.247]     if (FALSE) {
[16:21:06.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.247]     }
[16:21:06.247]     ...future.result <- base::tryCatch({
[16:21:06.247]         base::withCallingHandlers({
[16:21:06.247]             ...future.value <- base::withVisible(base::local({
[16:21:06.247]                 ...future.makeSendCondition <- base::local({
[16:21:06.247]                   sendCondition <- NULL
[16:21:06.247]                   function(frame = 1L) {
[16:21:06.247]                     if (is.function(sendCondition)) 
[16:21:06.247]                       return(sendCondition)
[16:21:06.247]                     ns <- getNamespace("parallel")
[16:21:06.247]                     if (exists("sendData", mode = "function", 
[16:21:06.247]                       envir = ns)) {
[16:21:06.247]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.247]                         envir = ns)
[16:21:06.247]                       envir <- sys.frame(frame)
[16:21:06.247]                       master <- NULL
[16:21:06.247]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.247]                         !identical(envir, emptyenv())) {
[16:21:06.247]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.247]                           inherits = FALSE)) {
[16:21:06.247]                           master <- get("master", mode = "list", 
[16:21:06.247]                             envir = envir, inherits = FALSE)
[16:21:06.247]                           if (inherits(master, c("SOCKnode", 
[16:21:06.247]                             "SOCK0node"))) {
[16:21:06.247]                             sendCondition <<- function(cond) {
[16:21:06.247]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.247]                                 success = TRUE)
[16:21:06.247]                               parallel_sendData(master, data)
[16:21:06.247]                             }
[16:21:06.247]                             return(sendCondition)
[16:21:06.247]                           }
[16:21:06.247]                         }
[16:21:06.247]                         frame <- frame + 1L
[16:21:06.247]                         envir <- sys.frame(frame)
[16:21:06.247]                       }
[16:21:06.247]                     }
[16:21:06.247]                     sendCondition <<- function(cond) NULL
[16:21:06.247]                   }
[16:21:06.247]                 })
[16:21:06.247]                 withCallingHandlers({
[16:21:06.247]                   value(a) + 1
[16:21:06.247]                 }, immediateCondition = function(cond) {
[16:21:06.247]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.247]                   sendCondition(cond)
[16:21:06.247]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.247]                   {
[16:21:06.247]                     inherits <- base::inherits
[16:21:06.247]                     invokeRestart <- base::invokeRestart
[16:21:06.247]                     is.null <- base::is.null
[16:21:06.247]                     muffled <- FALSE
[16:21:06.247]                     if (inherits(cond, "message")) {
[16:21:06.247]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.247]                       if (muffled) 
[16:21:06.247]                         invokeRestart("muffleMessage")
[16:21:06.247]                     }
[16:21:06.247]                     else if (inherits(cond, "warning")) {
[16:21:06.247]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.247]                       if (muffled) 
[16:21:06.247]                         invokeRestart("muffleWarning")
[16:21:06.247]                     }
[16:21:06.247]                     else if (inherits(cond, "condition")) {
[16:21:06.247]                       if (!is.null(pattern)) {
[16:21:06.247]                         computeRestarts <- base::computeRestarts
[16:21:06.247]                         grepl <- base::grepl
[16:21:06.247]                         restarts <- computeRestarts(cond)
[16:21:06.247]                         for (restart in restarts) {
[16:21:06.247]                           name <- restart$name
[16:21:06.247]                           if (is.null(name)) 
[16:21:06.247]                             next
[16:21:06.247]                           if (!grepl(pattern, name)) 
[16:21:06.247]                             next
[16:21:06.247]                           invokeRestart(restart)
[16:21:06.247]                           muffled <- TRUE
[16:21:06.247]                           break
[16:21:06.247]                         }
[16:21:06.247]                       }
[16:21:06.247]                     }
[16:21:06.247]                     invisible(muffled)
[16:21:06.247]                   }
[16:21:06.247]                   muffleCondition(cond)
[16:21:06.247]                 })
[16:21:06.247]             }))
[16:21:06.247]             future::FutureResult(value = ...future.value$value, 
[16:21:06.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.247]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.247]                     ...future.globalenv.names))
[16:21:06.247]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.247]         }, condition = base::local({
[16:21:06.247]             c <- base::c
[16:21:06.247]             inherits <- base::inherits
[16:21:06.247]             invokeRestart <- base::invokeRestart
[16:21:06.247]             length <- base::length
[16:21:06.247]             list <- base::list
[16:21:06.247]             seq.int <- base::seq.int
[16:21:06.247]             signalCondition <- base::signalCondition
[16:21:06.247]             sys.calls <- base::sys.calls
[16:21:06.247]             `[[` <- base::`[[`
[16:21:06.247]             `+` <- base::`+`
[16:21:06.247]             `<<-` <- base::`<<-`
[16:21:06.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.247]                   3L)]
[16:21:06.247]             }
[16:21:06.247]             function(cond) {
[16:21:06.247]                 is_error <- inherits(cond, "error")
[16:21:06.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.247]                   NULL)
[16:21:06.247]                 if (is_error) {
[16:21:06.247]                   sessionInformation <- function() {
[16:21:06.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.247]                       search = base::search(), system = base::Sys.info())
[16:21:06.247]                   }
[16:21:06.247]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.247]                     cond$call), session = sessionInformation(), 
[16:21:06.247]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.247]                   signalCondition(cond)
[16:21:06.247]                 }
[16:21:06.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.247]                 "immediateCondition"))) {
[16:21:06.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.247]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.247]                   if (TRUE && !signal) {
[16:21:06.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.247]                     {
[16:21:06.247]                       inherits <- base::inherits
[16:21:06.247]                       invokeRestart <- base::invokeRestart
[16:21:06.247]                       is.null <- base::is.null
[16:21:06.247]                       muffled <- FALSE
[16:21:06.247]                       if (inherits(cond, "message")) {
[16:21:06.247]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.247]                         if (muffled) 
[16:21:06.247]                           invokeRestart("muffleMessage")
[16:21:06.247]                       }
[16:21:06.247]                       else if (inherits(cond, "warning")) {
[16:21:06.247]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.247]                         if (muffled) 
[16:21:06.247]                           invokeRestart("muffleWarning")
[16:21:06.247]                       }
[16:21:06.247]                       else if (inherits(cond, "condition")) {
[16:21:06.247]                         if (!is.null(pattern)) {
[16:21:06.247]                           computeRestarts <- base::computeRestarts
[16:21:06.247]                           grepl <- base::grepl
[16:21:06.247]                           restarts <- computeRestarts(cond)
[16:21:06.247]                           for (restart in restarts) {
[16:21:06.247]                             name <- restart$name
[16:21:06.247]                             if (is.null(name)) 
[16:21:06.247]                               next
[16:21:06.247]                             if (!grepl(pattern, name)) 
[16:21:06.247]                               next
[16:21:06.247]                             invokeRestart(restart)
[16:21:06.247]                             muffled <- TRUE
[16:21:06.247]                             break
[16:21:06.247]                           }
[16:21:06.247]                         }
[16:21:06.247]                       }
[16:21:06.247]                       invisible(muffled)
[16:21:06.247]                     }
[16:21:06.247]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.247]                   }
[16:21:06.247]                 }
[16:21:06.247]                 else {
[16:21:06.247]                   if (TRUE) {
[16:21:06.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.247]                     {
[16:21:06.247]                       inherits <- base::inherits
[16:21:06.247]                       invokeRestart <- base::invokeRestart
[16:21:06.247]                       is.null <- base::is.null
[16:21:06.247]                       muffled <- FALSE
[16:21:06.247]                       if (inherits(cond, "message")) {
[16:21:06.247]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.247]                         if (muffled) 
[16:21:06.247]                           invokeRestart("muffleMessage")
[16:21:06.247]                       }
[16:21:06.247]                       else if (inherits(cond, "warning")) {
[16:21:06.247]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.247]                         if (muffled) 
[16:21:06.247]                           invokeRestart("muffleWarning")
[16:21:06.247]                       }
[16:21:06.247]                       else if (inherits(cond, "condition")) {
[16:21:06.247]                         if (!is.null(pattern)) {
[16:21:06.247]                           computeRestarts <- base::computeRestarts
[16:21:06.247]                           grepl <- base::grepl
[16:21:06.247]                           restarts <- computeRestarts(cond)
[16:21:06.247]                           for (restart in restarts) {
[16:21:06.247]                             name <- restart$name
[16:21:06.247]                             if (is.null(name)) 
[16:21:06.247]                               next
[16:21:06.247]                             if (!grepl(pattern, name)) 
[16:21:06.247]                               next
[16:21:06.247]                             invokeRestart(restart)
[16:21:06.247]                             muffled <- TRUE
[16:21:06.247]                             break
[16:21:06.247]                           }
[16:21:06.247]                         }
[16:21:06.247]                       }
[16:21:06.247]                       invisible(muffled)
[16:21:06.247]                     }
[16:21:06.247]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.247]                   }
[16:21:06.247]                 }
[16:21:06.247]             }
[16:21:06.247]         }))
[16:21:06.247]     }, error = function(ex) {
[16:21:06.247]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.247]                 ...future.rng), started = ...future.startTime, 
[16:21:06.247]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.247]             version = "1.8"), class = "FutureResult")
[16:21:06.247]     }, finally = {
[16:21:06.247]         if (!identical(...future.workdir, getwd())) 
[16:21:06.247]             setwd(...future.workdir)
[16:21:06.247]         {
[16:21:06.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.247]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.247]             }
[16:21:06.247]             base::options(...future.oldOptions)
[16:21:06.247]             if (.Platform$OS.type == "windows") {
[16:21:06.247]                 old_names <- names(...future.oldEnvVars)
[16:21:06.247]                 envs <- base::Sys.getenv()
[16:21:06.247]                 names <- names(envs)
[16:21:06.247]                 common <- intersect(names, old_names)
[16:21:06.247]                 added <- setdiff(names, old_names)
[16:21:06.247]                 removed <- setdiff(old_names, names)
[16:21:06.247]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.247]                   envs[common]]
[16:21:06.247]                 NAMES <- toupper(changed)
[16:21:06.247]                 args <- list()
[16:21:06.247]                 for (kk in seq_along(NAMES)) {
[16:21:06.247]                   name <- changed[[kk]]
[16:21:06.247]                   NAME <- NAMES[[kk]]
[16:21:06.247]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.247]                     next
[16:21:06.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.247]                 }
[16:21:06.247]                 NAMES <- toupper(added)
[16:21:06.247]                 for (kk in seq_along(NAMES)) {
[16:21:06.247]                   name <- added[[kk]]
[16:21:06.247]                   NAME <- NAMES[[kk]]
[16:21:06.247]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.247]                     next
[16:21:06.247]                   args[[name]] <- ""
[16:21:06.247]                 }
[16:21:06.247]                 NAMES <- toupper(removed)
[16:21:06.247]                 for (kk in seq_along(NAMES)) {
[16:21:06.247]                   name <- removed[[kk]]
[16:21:06.247]                   NAME <- NAMES[[kk]]
[16:21:06.247]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.247]                     next
[16:21:06.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.247]                 }
[16:21:06.247]                 if (length(args) > 0) 
[16:21:06.247]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.247]             }
[16:21:06.247]             else {
[16:21:06.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.247]             }
[16:21:06.247]             {
[16:21:06.247]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.247]                   0L) {
[16:21:06.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.247]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.247]                   base::options(opts)
[16:21:06.247]                 }
[16:21:06.247]                 {
[16:21:06.247]                   {
[16:21:06.247]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.247]                     NULL
[16:21:06.247]                   }
[16:21:06.247]                   options(future.plan = NULL)
[16:21:06.247]                   if (is.na(NA_character_)) 
[16:21:06.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.247]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.247]                     .init = FALSE)
[16:21:06.247]                 }
[16:21:06.247]             }
[16:21:06.247]         }
[16:21:06.247]     })
[16:21:06.247]     if (TRUE) {
[16:21:06.247]         base::sink(type = "output", split = FALSE)
[16:21:06.247]         if (TRUE) {
[16:21:06.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.247]         }
[16:21:06.247]         else {
[16:21:06.247]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.247]         }
[16:21:06.247]         base::close(...future.stdout)
[16:21:06.247]         ...future.stdout <- NULL
[16:21:06.247]     }
[16:21:06.247]     ...future.result$conditions <- ...future.conditions
[16:21:06.247]     ...future.result$finished <- base::Sys.time()
[16:21:06.247]     ...future.result
[16:21:06.247] }
[16:21:06.250] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[16:21:06.250] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[16:21:06.305] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[16:21:06.305] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[16:21:06.305] MultisessionFuture started
[16:21:06.305] - Launch lazy future ... done
[16:21:06.306] run() for ‘MultisessionFuture’ ... done
[16:21:06.306] result() for ClusterFuture ...
[16:21:06.306] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.306] - Validating connection of MultisessionFuture
[16:21:06.354] - received message: FutureResult
[16:21:06.355] - Received FutureResult
[16:21:06.355] - Erased future from FutureRegistry
[16:21:06.355] result() for ClusterFuture ...
[16:21:06.355] - result already collected: FutureResult
[16:21:06.355] result() for ClusterFuture ... done
[16:21:06.355] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.355] result() for ClusterFuture ... done
[16:21:06.355] result() for ClusterFuture ...
[16:21:06.356] - result already collected: FutureResult
[16:21:06.356] result() for ClusterFuture ... done
value(b) = 2
[16:21:06.356] result() for ClusterFuture ...
[16:21:06.356] - result already collected: FutureResult
[16:21:06.356] result() for ClusterFuture ... done
[16:21:06.356] result() for ClusterFuture ...
[16:21:06.356] - result already collected: FutureResult
[16:21:06.356] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.357] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.357] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.357] 
[16:21:06.357] Searching for globals ... DONE
[16:21:06.357] - globals: [0] <none>
[16:21:06.358] getGlobalsAndPackages() ... DONE
[16:21:06.358] run() for ‘Future’ ...
[16:21:06.358] - state: ‘created’
[16:21:06.358] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.373]   - Field: ‘node’
[16:21:06.373]   - Field: ‘label’
[16:21:06.373]   - Field: ‘local’
[16:21:06.373]   - Field: ‘owner’
[16:21:06.373]   - Field: ‘envir’
[16:21:06.373]   - Field: ‘workers’
[16:21:06.373]   - Field: ‘packages’
[16:21:06.373]   - Field: ‘gc’
[16:21:06.373]   - Field: ‘conditions’
[16:21:06.373]   - Field: ‘persistent’
[16:21:06.373]   - Field: ‘expr’
[16:21:06.374]   - Field: ‘uuid’
[16:21:06.374]   - Field: ‘seed’
[16:21:06.374]   - Field: ‘version’
[16:21:06.374]   - Field: ‘result’
[16:21:06.374]   - Field: ‘asynchronous’
[16:21:06.374]   - Field: ‘calls’
[16:21:06.374]   - Field: ‘globals’
[16:21:06.374]   - Field: ‘stdout’
[16:21:06.374]   - Field: ‘earlySignal’
[16:21:06.374]   - Field: ‘lazy’
[16:21:06.374]   - Field: ‘state’
[16:21:06.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.375] - Launch lazy future ...
[16:21:06.375] Packages needed by the future expression (n = 0): <none>
[16:21:06.375] Packages needed by future strategies (n = 0): <none>
[16:21:06.375] {
[16:21:06.375]     {
[16:21:06.375]         {
[16:21:06.375]             ...future.startTime <- base::Sys.time()
[16:21:06.375]             {
[16:21:06.375]                 {
[16:21:06.375]                   {
[16:21:06.375]                     {
[16:21:06.375]                       base::local({
[16:21:06.375]                         has_future <- base::requireNamespace("future", 
[16:21:06.375]                           quietly = TRUE)
[16:21:06.375]                         if (has_future) {
[16:21:06.375]                           ns <- base::getNamespace("future")
[16:21:06.375]                           version <- ns[[".package"]][["version"]]
[16:21:06.375]                           if (is.null(version)) 
[16:21:06.375]                             version <- utils::packageVersion("future")
[16:21:06.375]                         }
[16:21:06.375]                         else {
[16:21:06.375]                           version <- NULL
[16:21:06.375]                         }
[16:21:06.375]                         if (!has_future || version < "1.8.0") {
[16:21:06.375]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.375]                             "", base::R.version$version.string), 
[16:21:06.375]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:06.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:06.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.375]                               "release", "version")], collapse = " "), 
[16:21:06.375]                             hostname = base::Sys.info()[["nodename"]])
[16:21:06.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.375]                             info)
[16:21:06.375]                           info <- base::paste(info, collapse = "; ")
[16:21:06.375]                           if (!has_future) {
[16:21:06.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.375]                               info)
[16:21:06.375]                           }
[16:21:06.375]                           else {
[16:21:06.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.375]                               info, version)
[16:21:06.375]                           }
[16:21:06.375]                           base::stop(msg)
[16:21:06.375]                         }
[16:21:06.375]                       })
[16:21:06.375]                     }
[16:21:06.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.375]                     base::options(mc.cores = 1L)
[16:21:06.375]                   }
[16:21:06.375]                   ...future.strategy.old <- future::plan("list")
[16:21:06.375]                   options(future.plan = NULL)
[16:21:06.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.375]                 }
[16:21:06.375]                 ...future.workdir <- getwd()
[16:21:06.375]             }
[16:21:06.375]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.375]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.375]         }
[16:21:06.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.375]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.375]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.375]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.375]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.375]             base::names(...future.oldOptions))
[16:21:06.375]     }
[16:21:06.375]     if (FALSE) {
[16:21:06.375]     }
[16:21:06.375]     else {
[16:21:06.375]         if (TRUE) {
[16:21:06.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.375]                 open = "w")
[16:21:06.375]         }
[16:21:06.375]         else {
[16:21:06.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.375]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.375]         }
[16:21:06.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.375]             base::sink(type = "output", split = FALSE)
[16:21:06.375]             base::close(...future.stdout)
[16:21:06.375]         }, add = TRUE)
[16:21:06.375]     }
[16:21:06.375]     ...future.frame <- base::sys.nframe()
[16:21:06.375]     ...future.conditions <- base::list()
[16:21:06.375]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.375]     if (FALSE) {
[16:21:06.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.375]     }
[16:21:06.375]     ...future.result <- base::tryCatch({
[16:21:06.375]         base::withCallingHandlers({
[16:21:06.375]             ...future.value <- base::withVisible(base::local({
[16:21:06.375]                 ...future.makeSendCondition <- base::local({
[16:21:06.375]                   sendCondition <- NULL
[16:21:06.375]                   function(frame = 1L) {
[16:21:06.375]                     if (is.function(sendCondition)) 
[16:21:06.375]                       return(sendCondition)
[16:21:06.375]                     ns <- getNamespace("parallel")
[16:21:06.375]                     if (exists("sendData", mode = "function", 
[16:21:06.375]                       envir = ns)) {
[16:21:06.375]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.375]                         envir = ns)
[16:21:06.375]                       envir <- sys.frame(frame)
[16:21:06.375]                       master <- NULL
[16:21:06.375]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.375]                         !identical(envir, emptyenv())) {
[16:21:06.375]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.375]                           inherits = FALSE)) {
[16:21:06.375]                           master <- get("master", mode = "list", 
[16:21:06.375]                             envir = envir, inherits = FALSE)
[16:21:06.375]                           if (inherits(master, c("SOCKnode", 
[16:21:06.375]                             "SOCK0node"))) {
[16:21:06.375]                             sendCondition <<- function(cond) {
[16:21:06.375]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.375]                                 success = TRUE)
[16:21:06.375]                               parallel_sendData(master, data)
[16:21:06.375]                             }
[16:21:06.375]                             return(sendCondition)
[16:21:06.375]                           }
[16:21:06.375]                         }
[16:21:06.375]                         frame <- frame + 1L
[16:21:06.375]                         envir <- sys.frame(frame)
[16:21:06.375]                       }
[16:21:06.375]                     }
[16:21:06.375]                     sendCondition <<- function(cond) NULL
[16:21:06.375]                   }
[16:21:06.375]                 })
[16:21:06.375]                 withCallingHandlers({
[16:21:06.375]                   1
[16:21:06.375]                 }, immediateCondition = function(cond) {
[16:21:06.375]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.375]                   sendCondition(cond)
[16:21:06.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.375]                   {
[16:21:06.375]                     inherits <- base::inherits
[16:21:06.375]                     invokeRestart <- base::invokeRestart
[16:21:06.375]                     is.null <- base::is.null
[16:21:06.375]                     muffled <- FALSE
[16:21:06.375]                     if (inherits(cond, "message")) {
[16:21:06.375]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.375]                       if (muffled) 
[16:21:06.375]                         invokeRestart("muffleMessage")
[16:21:06.375]                     }
[16:21:06.375]                     else if (inherits(cond, "warning")) {
[16:21:06.375]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.375]                       if (muffled) 
[16:21:06.375]                         invokeRestart("muffleWarning")
[16:21:06.375]                     }
[16:21:06.375]                     else if (inherits(cond, "condition")) {
[16:21:06.375]                       if (!is.null(pattern)) {
[16:21:06.375]                         computeRestarts <- base::computeRestarts
[16:21:06.375]                         grepl <- base::grepl
[16:21:06.375]                         restarts <- computeRestarts(cond)
[16:21:06.375]                         for (restart in restarts) {
[16:21:06.375]                           name <- restart$name
[16:21:06.375]                           if (is.null(name)) 
[16:21:06.375]                             next
[16:21:06.375]                           if (!grepl(pattern, name)) 
[16:21:06.375]                             next
[16:21:06.375]                           invokeRestart(restart)
[16:21:06.375]                           muffled <- TRUE
[16:21:06.375]                           break
[16:21:06.375]                         }
[16:21:06.375]                       }
[16:21:06.375]                     }
[16:21:06.375]                     invisible(muffled)
[16:21:06.375]                   }
[16:21:06.375]                   muffleCondition(cond)
[16:21:06.375]                 })
[16:21:06.375]             }))
[16:21:06.375]             future::FutureResult(value = ...future.value$value, 
[16:21:06.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.375]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.375]                     ...future.globalenv.names))
[16:21:06.375]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.375]         }, condition = base::local({
[16:21:06.375]             c <- base::c
[16:21:06.375]             inherits <- base::inherits
[16:21:06.375]             invokeRestart <- base::invokeRestart
[16:21:06.375]             length <- base::length
[16:21:06.375]             list <- base::list
[16:21:06.375]             seq.int <- base::seq.int
[16:21:06.375]             signalCondition <- base::signalCondition
[16:21:06.375]             sys.calls <- base::sys.calls
[16:21:06.375]             `[[` <- base::`[[`
[16:21:06.375]             `+` <- base::`+`
[16:21:06.375]             `<<-` <- base::`<<-`
[16:21:06.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.375]                   3L)]
[16:21:06.375]             }
[16:21:06.375]             function(cond) {
[16:21:06.375]                 is_error <- inherits(cond, "error")
[16:21:06.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.375]                   NULL)
[16:21:06.375]                 if (is_error) {
[16:21:06.375]                   sessionInformation <- function() {
[16:21:06.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.375]                       search = base::search(), system = base::Sys.info())
[16:21:06.375]                   }
[16:21:06.375]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.375]                     cond$call), session = sessionInformation(), 
[16:21:06.375]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.375]                   signalCondition(cond)
[16:21:06.375]                 }
[16:21:06.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.375]                 "immediateCondition"))) {
[16:21:06.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.375]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.375]                   if (TRUE && !signal) {
[16:21:06.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.375]                     {
[16:21:06.375]                       inherits <- base::inherits
[16:21:06.375]                       invokeRestart <- base::invokeRestart
[16:21:06.375]                       is.null <- base::is.null
[16:21:06.375]                       muffled <- FALSE
[16:21:06.375]                       if (inherits(cond, "message")) {
[16:21:06.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.375]                         if (muffled) 
[16:21:06.375]                           invokeRestart("muffleMessage")
[16:21:06.375]                       }
[16:21:06.375]                       else if (inherits(cond, "warning")) {
[16:21:06.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.375]                         if (muffled) 
[16:21:06.375]                           invokeRestart("muffleWarning")
[16:21:06.375]                       }
[16:21:06.375]                       else if (inherits(cond, "condition")) {
[16:21:06.375]                         if (!is.null(pattern)) {
[16:21:06.375]                           computeRestarts <- base::computeRestarts
[16:21:06.375]                           grepl <- base::grepl
[16:21:06.375]                           restarts <- computeRestarts(cond)
[16:21:06.375]                           for (restart in restarts) {
[16:21:06.375]                             name <- restart$name
[16:21:06.375]                             if (is.null(name)) 
[16:21:06.375]                               next
[16:21:06.375]                             if (!grepl(pattern, name)) 
[16:21:06.375]                               next
[16:21:06.375]                             invokeRestart(restart)
[16:21:06.375]                             muffled <- TRUE
[16:21:06.375]                             break
[16:21:06.375]                           }
[16:21:06.375]                         }
[16:21:06.375]                       }
[16:21:06.375]                       invisible(muffled)
[16:21:06.375]                     }
[16:21:06.375]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.375]                   }
[16:21:06.375]                 }
[16:21:06.375]                 else {
[16:21:06.375]                   if (TRUE) {
[16:21:06.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.375]                     {
[16:21:06.375]                       inherits <- base::inherits
[16:21:06.375]                       invokeRestart <- base::invokeRestart
[16:21:06.375]                       is.null <- base::is.null
[16:21:06.375]                       muffled <- FALSE
[16:21:06.375]                       if (inherits(cond, "message")) {
[16:21:06.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.375]                         if (muffled) 
[16:21:06.375]                           invokeRestart("muffleMessage")
[16:21:06.375]                       }
[16:21:06.375]                       else if (inherits(cond, "warning")) {
[16:21:06.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.375]                         if (muffled) 
[16:21:06.375]                           invokeRestart("muffleWarning")
[16:21:06.375]                       }
[16:21:06.375]                       else if (inherits(cond, "condition")) {
[16:21:06.375]                         if (!is.null(pattern)) {
[16:21:06.375]                           computeRestarts <- base::computeRestarts
[16:21:06.375]                           grepl <- base::grepl
[16:21:06.375]                           restarts <- computeRestarts(cond)
[16:21:06.375]                           for (restart in restarts) {
[16:21:06.375]                             name <- restart$name
[16:21:06.375]                             if (is.null(name)) 
[16:21:06.375]                               next
[16:21:06.375]                             if (!grepl(pattern, name)) 
[16:21:06.375]                               next
[16:21:06.375]                             invokeRestart(restart)
[16:21:06.375]                             muffled <- TRUE
[16:21:06.375]                             break
[16:21:06.375]                           }
[16:21:06.375]                         }
[16:21:06.375]                       }
[16:21:06.375]                       invisible(muffled)
[16:21:06.375]                     }
[16:21:06.375]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.375]                   }
[16:21:06.375]                 }
[16:21:06.375]             }
[16:21:06.375]         }))
[16:21:06.375]     }, error = function(ex) {
[16:21:06.375]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.375]                 ...future.rng), started = ...future.startTime, 
[16:21:06.375]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.375]             version = "1.8"), class = "FutureResult")
[16:21:06.375]     }, finally = {
[16:21:06.375]         if (!identical(...future.workdir, getwd())) 
[16:21:06.375]             setwd(...future.workdir)
[16:21:06.375]         {
[16:21:06.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.375]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.375]             }
[16:21:06.375]             base::options(...future.oldOptions)
[16:21:06.375]             if (.Platform$OS.type == "windows") {
[16:21:06.375]                 old_names <- names(...future.oldEnvVars)
[16:21:06.375]                 envs <- base::Sys.getenv()
[16:21:06.375]                 names <- names(envs)
[16:21:06.375]                 common <- intersect(names, old_names)
[16:21:06.375]                 added <- setdiff(names, old_names)
[16:21:06.375]                 removed <- setdiff(old_names, names)
[16:21:06.375]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.375]                   envs[common]]
[16:21:06.375]                 NAMES <- toupper(changed)
[16:21:06.375]                 args <- list()
[16:21:06.375]                 for (kk in seq_along(NAMES)) {
[16:21:06.375]                   name <- changed[[kk]]
[16:21:06.375]                   NAME <- NAMES[[kk]]
[16:21:06.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.375]                     next
[16:21:06.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.375]                 }
[16:21:06.375]                 NAMES <- toupper(added)
[16:21:06.375]                 for (kk in seq_along(NAMES)) {
[16:21:06.375]                   name <- added[[kk]]
[16:21:06.375]                   NAME <- NAMES[[kk]]
[16:21:06.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.375]                     next
[16:21:06.375]                   args[[name]] <- ""
[16:21:06.375]                 }
[16:21:06.375]                 NAMES <- toupper(removed)
[16:21:06.375]                 for (kk in seq_along(NAMES)) {
[16:21:06.375]                   name <- removed[[kk]]
[16:21:06.375]                   NAME <- NAMES[[kk]]
[16:21:06.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.375]                     next
[16:21:06.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.375]                 }
[16:21:06.375]                 if (length(args) > 0) 
[16:21:06.375]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.375]             }
[16:21:06.375]             else {
[16:21:06.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.375]             }
[16:21:06.375]             {
[16:21:06.375]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.375]                   0L) {
[16:21:06.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.375]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.375]                   base::options(opts)
[16:21:06.375]                 }
[16:21:06.375]                 {
[16:21:06.375]                   {
[16:21:06.375]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.375]                     NULL
[16:21:06.375]                   }
[16:21:06.375]                   options(future.plan = NULL)
[16:21:06.375]                   if (is.na(NA_character_)) 
[16:21:06.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.375]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.375]                     .init = FALSE)
[16:21:06.375]                 }
[16:21:06.375]             }
[16:21:06.375]         }
[16:21:06.375]     })
[16:21:06.375]     if (TRUE) {
[16:21:06.375]         base::sink(type = "output", split = FALSE)
[16:21:06.375]         if (TRUE) {
[16:21:06.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.375]         }
[16:21:06.375]         else {
[16:21:06.375]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.375]         }
[16:21:06.375]         base::close(...future.stdout)
[16:21:06.375]         ...future.stdout <- NULL
[16:21:06.375]     }
[16:21:06.375]     ...future.result$conditions <- ...future.conditions
[16:21:06.375]     ...future.result$finished <- base::Sys.time()
[16:21:06.375]     ...future.result
[16:21:06.375] }
[16:21:06.378] MultisessionFuture started
[16:21:06.379] - Launch lazy future ... done
[16:21:06.379] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.379] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.379] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.380] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:06.380] Searching for globals ... DONE
[16:21:06.380] Resolving globals: TRUE
[16:21:06.380] Resolving any globals that are futures ...
[16:21:06.381] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:06.381] Resolving any globals that are futures ... DONE
[16:21:06.381] Resolving futures part of globals (recursively) ...
[16:21:06.381] resolve() on list ...
[16:21:06.381]  recursive: 99
[16:21:06.381]  length: 1
[16:21:06.381]  elements: ‘a’
[16:21:06.425] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.425] - Validating connection of MultisessionFuture
[16:21:06.426] - received message: FutureResult
[16:21:06.426] - Received FutureResult
[16:21:06.426] - Erased future from FutureRegistry
[16:21:06.427] result() for ClusterFuture ...
[16:21:06.427] - result already collected: FutureResult
[16:21:06.427] result() for ClusterFuture ... done
[16:21:06.427] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.427] Future #1
[16:21:06.428] result() for ClusterFuture ...
[16:21:06.428] - result already collected: FutureResult
[16:21:06.428] result() for ClusterFuture ... done
[16:21:06.428] result() for ClusterFuture ...
[16:21:06.429] - result already collected: FutureResult
[16:21:06.429] result() for ClusterFuture ... done
[16:21:06.429] A MultisessionFuture was resolved
[16:21:06.430]  length: 0 (resolved future 1)
[16:21:06.430] resolve() on list ... DONE
[16:21:06.430] - globals: [1] ‘a’
[16:21:06.430] Resolving futures part of globals (recursively) ... DONE
[16:21:06.432] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[16:21:06.432] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[16:21:06.433] - globals: [1] ‘a’
[16:21:06.433] - packages: [1] ‘future’
[16:21:06.433] getGlobalsAndPackages() ... DONE
[16:21:06.434] run() for ‘Future’ ...
[16:21:06.434] - state: ‘created’
[16:21:06.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.458] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.458]   - Field: ‘node’
[16:21:06.458]   - Field: ‘label’
[16:21:06.458]   - Field: ‘local’
[16:21:06.458]   - Field: ‘owner’
[16:21:06.459]   - Field: ‘envir’
[16:21:06.459]   - Field: ‘workers’
[16:21:06.459]   - Field: ‘packages’
[16:21:06.459]   - Field: ‘gc’
[16:21:06.459]   - Field: ‘conditions’
[16:21:06.459]   - Field: ‘persistent’
[16:21:06.460]   - Field: ‘expr’
[16:21:06.460]   - Field: ‘uuid’
[16:21:06.460]   - Field: ‘seed’
[16:21:06.460]   - Field: ‘version’
[16:21:06.460]   - Field: ‘result’
[16:21:06.460]   - Field: ‘asynchronous’
[16:21:06.461]   - Field: ‘calls’
[16:21:06.461]   - Field: ‘globals’
[16:21:06.461]   - Field: ‘stdout’
[16:21:06.461]   - Field: ‘earlySignal’
[16:21:06.461]   - Field: ‘lazy’
[16:21:06.461]   - Field: ‘state’
[16:21:06.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.462] - Launch lazy future ...
[16:21:06.462] Packages needed by the future expression (n = 1): ‘future’
[16:21:06.462] Packages needed by future strategies (n = 0): <none>
[16:21:06.463] {
[16:21:06.463]     {
[16:21:06.463]         {
[16:21:06.463]             ...future.startTime <- base::Sys.time()
[16:21:06.463]             {
[16:21:06.463]                 {
[16:21:06.463]                   {
[16:21:06.463]                     {
[16:21:06.463]                       {
[16:21:06.463]                         base::local({
[16:21:06.463]                           has_future <- base::requireNamespace("future", 
[16:21:06.463]                             quietly = TRUE)
[16:21:06.463]                           if (has_future) {
[16:21:06.463]                             ns <- base::getNamespace("future")
[16:21:06.463]                             version <- ns[[".package"]][["version"]]
[16:21:06.463]                             if (is.null(version)) 
[16:21:06.463]                               version <- utils::packageVersion("future")
[16:21:06.463]                           }
[16:21:06.463]                           else {
[16:21:06.463]                             version <- NULL
[16:21:06.463]                           }
[16:21:06.463]                           if (!has_future || version < "1.8.0") {
[16:21:06.463]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.463]                               "", base::R.version$version.string), 
[16:21:06.463]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:06.463]                                 base::R.version$platform, 8 * 
[16:21:06.463]                                   base::.Machine$sizeof.pointer), 
[16:21:06.463]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.463]                                 "release", "version")], collapse = " "), 
[16:21:06.463]                               hostname = base::Sys.info()[["nodename"]])
[16:21:06.463]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.463]                               info)
[16:21:06.463]                             info <- base::paste(info, collapse = "; ")
[16:21:06.463]                             if (!has_future) {
[16:21:06.463]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.463]                                 info)
[16:21:06.463]                             }
[16:21:06.463]                             else {
[16:21:06.463]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.463]                                 info, version)
[16:21:06.463]                             }
[16:21:06.463]                             base::stop(msg)
[16:21:06.463]                           }
[16:21:06.463]                         })
[16:21:06.463]                       }
[16:21:06.463]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.463]                       base::options(mc.cores = 1L)
[16:21:06.463]                     }
[16:21:06.463]                     base::local({
[16:21:06.463]                       for (pkg in "future") {
[16:21:06.463]                         base::loadNamespace(pkg)
[16:21:06.463]                         base::library(pkg, character.only = TRUE)
[16:21:06.463]                       }
[16:21:06.463]                     })
[16:21:06.463]                   }
[16:21:06.463]                   ...future.strategy.old <- future::plan("list")
[16:21:06.463]                   options(future.plan = NULL)
[16:21:06.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.463]                 }
[16:21:06.463]                 ...future.workdir <- getwd()
[16:21:06.463]             }
[16:21:06.463]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.463]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.463]         }
[16:21:06.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.463]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.463]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.463]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.463]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.463]             base::names(...future.oldOptions))
[16:21:06.463]     }
[16:21:06.463]     if (FALSE) {
[16:21:06.463]     }
[16:21:06.463]     else {
[16:21:06.463]         if (TRUE) {
[16:21:06.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.463]                 open = "w")
[16:21:06.463]         }
[16:21:06.463]         else {
[16:21:06.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.463]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.463]         }
[16:21:06.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.463]             base::sink(type = "output", split = FALSE)
[16:21:06.463]             base::close(...future.stdout)
[16:21:06.463]         }, add = TRUE)
[16:21:06.463]     }
[16:21:06.463]     ...future.frame <- base::sys.nframe()
[16:21:06.463]     ...future.conditions <- base::list()
[16:21:06.463]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.463]     if (FALSE) {
[16:21:06.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.463]     }
[16:21:06.463]     ...future.result <- base::tryCatch({
[16:21:06.463]         base::withCallingHandlers({
[16:21:06.463]             ...future.value <- base::withVisible(base::local({
[16:21:06.463]                 ...future.makeSendCondition <- base::local({
[16:21:06.463]                   sendCondition <- NULL
[16:21:06.463]                   function(frame = 1L) {
[16:21:06.463]                     if (is.function(sendCondition)) 
[16:21:06.463]                       return(sendCondition)
[16:21:06.463]                     ns <- getNamespace("parallel")
[16:21:06.463]                     if (exists("sendData", mode = "function", 
[16:21:06.463]                       envir = ns)) {
[16:21:06.463]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.463]                         envir = ns)
[16:21:06.463]                       envir <- sys.frame(frame)
[16:21:06.463]                       master <- NULL
[16:21:06.463]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.463]                         !identical(envir, emptyenv())) {
[16:21:06.463]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.463]                           inherits = FALSE)) {
[16:21:06.463]                           master <- get("master", mode = "list", 
[16:21:06.463]                             envir = envir, inherits = FALSE)
[16:21:06.463]                           if (inherits(master, c("SOCKnode", 
[16:21:06.463]                             "SOCK0node"))) {
[16:21:06.463]                             sendCondition <<- function(cond) {
[16:21:06.463]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.463]                                 success = TRUE)
[16:21:06.463]                               parallel_sendData(master, data)
[16:21:06.463]                             }
[16:21:06.463]                             return(sendCondition)
[16:21:06.463]                           }
[16:21:06.463]                         }
[16:21:06.463]                         frame <- frame + 1L
[16:21:06.463]                         envir <- sys.frame(frame)
[16:21:06.463]                       }
[16:21:06.463]                     }
[16:21:06.463]                     sendCondition <<- function(cond) NULL
[16:21:06.463]                   }
[16:21:06.463]                 })
[16:21:06.463]                 withCallingHandlers({
[16:21:06.463]                   value(a) + 1
[16:21:06.463]                 }, immediateCondition = function(cond) {
[16:21:06.463]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.463]                   sendCondition(cond)
[16:21:06.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.463]                   {
[16:21:06.463]                     inherits <- base::inherits
[16:21:06.463]                     invokeRestart <- base::invokeRestart
[16:21:06.463]                     is.null <- base::is.null
[16:21:06.463]                     muffled <- FALSE
[16:21:06.463]                     if (inherits(cond, "message")) {
[16:21:06.463]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.463]                       if (muffled) 
[16:21:06.463]                         invokeRestart("muffleMessage")
[16:21:06.463]                     }
[16:21:06.463]                     else if (inherits(cond, "warning")) {
[16:21:06.463]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.463]                       if (muffled) 
[16:21:06.463]                         invokeRestart("muffleWarning")
[16:21:06.463]                     }
[16:21:06.463]                     else if (inherits(cond, "condition")) {
[16:21:06.463]                       if (!is.null(pattern)) {
[16:21:06.463]                         computeRestarts <- base::computeRestarts
[16:21:06.463]                         grepl <- base::grepl
[16:21:06.463]                         restarts <- computeRestarts(cond)
[16:21:06.463]                         for (restart in restarts) {
[16:21:06.463]                           name <- restart$name
[16:21:06.463]                           if (is.null(name)) 
[16:21:06.463]                             next
[16:21:06.463]                           if (!grepl(pattern, name)) 
[16:21:06.463]                             next
[16:21:06.463]                           invokeRestart(restart)
[16:21:06.463]                           muffled <- TRUE
[16:21:06.463]                           break
[16:21:06.463]                         }
[16:21:06.463]                       }
[16:21:06.463]                     }
[16:21:06.463]                     invisible(muffled)
[16:21:06.463]                   }
[16:21:06.463]                   muffleCondition(cond)
[16:21:06.463]                 })
[16:21:06.463]             }))
[16:21:06.463]             future::FutureResult(value = ...future.value$value, 
[16:21:06.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.463]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.463]                     ...future.globalenv.names))
[16:21:06.463]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.463]         }, condition = base::local({
[16:21:06.463]             c <- base::c
[16:21:06.463]             inherits <- base::inherits
[16:21:06.463]             invokeRestart <- base::invokeRestart
[16:21:06.463]             length <- base::length
[16:21:06.463]             list <- base::list
[16:21:06.463]             seq.int <- base::seq.int
[16:21:06.463]             signalCondition <- base::signalCondition
[16:21:06.463]             sys.calls <- base::sys.calls
[16:21:06.463]             `[[` <- base::`[[`
[16:21:06.463]             `+` <- base::`+`
[16:21:06.463]             `<<-` <- base::`<<-`
[16:21:06.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.463]                   3L)]
[16:21:06.463]             }
[16:21:06.463]             function(cond) {
[16:21:06.463]                 is_error <- inherits(cond, "error")
[16:21:06.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.463]                   NULL)
[16:21:06.463]                 if (is_error) {
[16:21:06.463]                   sessionInformation <- function() {
[16:21:06.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.463]                       search = base::search(), system = base::Sys.info())
[16:21:06.463]                   }
[16:21:06.463]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.463]                     cond$call), session = sessionInformation(), 
[16:21:06.463]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.463]                   signalCondition(cond)
[16:21:06.463]                 }
[16:21:06.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.463]                 "immediateCondition"))) {
[16:21:06.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.463]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.463]                   if (TRUE && !signal) {
[16:21:06.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.463]                     {
[16:21:06.463]                       inherits <- base::inherits
[16:21:06.463]                       invokeRestart <- base::invokeRestart
[16:21:06.463]                       is.null <- base::is.null
[16:21:06.463]                       muffled <- FALSE
[16:21:06.463]                       if (inherits(cond, "message")) {
[16:21:06.463]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.463]                         if (muffled) 
[16:21:06.463]                           invokeRestart("muffleMessage")
[16:21:06.463]                       }
[16:21:06.463]                       else if (inherits(cond, "warning")) {
[16:21:06.463]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.463]                         if (muffled) 
[16:21:06.463]                           invokeRestart("muffleWarning")
[16:21:06.463]                       }
[16:21:06.463]                       else if (inherits(cond, "condition")) {
[16:21:06.463]                         if (!is.null(pattern)) {
[16:21:06.463]                           computeRestarts <- base::computeRestarts
[16:21:06.463]                           grepl <- base::grepl
[16:21:06.463]                           restarts <- computeRestarts(cond)
[16:21:06.463]                           for (restart in restarts) {
[16:21:06.463]                             name <- restart$name
[16:21:06.463]                             if (is.null(name)) 
[16:21:06.463]                               next
[16:21:06.463]                             if (!grepl(pattern, name)) 
[16:21:06.463]                               next
[16:21:06.463]                             invokeRestart(restart)
[16:21:06.463]                             muffled <- TRUE
[16:21:06.463]                             break
[16:21:06.463]                           }
[16:21:06.463]                         }
[16:21:06.463]                       }
[16:21:06.463]                       invisible(muffled)
[16:21:06.463]                     }
[16:21:06.463]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.463]                   }
[16:21:06.463]                 }
[16:21:06.463]                 else {
[16:21:06.463]                   if (TRUE) {
[16:21:06.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.463]                     {
[16:21:06.463]                       inherits <- base::inherits
[16:21:06.463]                       invokeRestart <- base::invokeRestart
[16:21:06.463]                       is.null <- base::is.null
[16:21:06.463]                       muffled <- FALSE
[16:21:06.463]                       if (inherits(cond, "message")) {
[16:21:06.463]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.463]                         if (muffled) 
[16:21:06.463]                           invokeRestart("muffleMessage")
[16:21:06.463]                       }
[16:21:06.463]                       else if (inherits(cond, "warning")) {
[16:21:06.463]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.463]                         if (muffled) 
[16:21:06.463]                           invokeRestart("muffleWarning")
[16:21:06.463]                       }
[16:21:06.463]                       else if (inherits(cond, "condition")) {
[16:21:06.463]                         if (!is.null(pattern)) {
[16:21:06.463]                           computeRestarts <- base::computeRestarts
[16:21:06.463]                           grepl <- base::grepl
[16:21:06.463]                           restarts <- computeRestarts(cond)
[16:21:06.463]                           for (restart in restarts) {
[16:21:06.463]                             name <- restart$name
[16:21:06.463]                             if (is.null(name)) 
[16:21:06.463]                               next
[16:21:06.463]                             if (!grepl(pattern, name)) 
[16:21:06.463]                               next
[16:21:06.463]                             invokeRestart(restart)
[16:21:06.463]                             muffled <- TRUE
[16:21:06.463]                             break
[16:21:06.463]                           }
[16:21:06.463]                         }
[16:21:06.463]                       }
[16:21:06.463]                       invisible(muffled)
[16:21:06.463]                     }
[16:21:06.463]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.463]                   }
[16:21:06.463]                 }
[16:21:06.463]             }
[16:21:06.463]         }))
[16:21:06.463]     }, error = function(ex) {
[16:21:06.463]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.463]                 ...future.rng), started = ...future.startTime, 
[16:21:06.463]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.463]             version = "1.8"), class = "FutureResult")
[16:21:06.463]     }, finally = {
[16:21:06.463]         if (!identical(...future.workdir, getwd())) 
[16:21:06.463]             setwd(...future.workdir)
[16:21:06.463]         {
[16:21:06.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.463]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.463]             }
[16:21:06.463]             base::options(...future.oldOptions)
[16:21:06.463]             if (.Platform$OS.type == "windows") {
[16:21:06.463]                 old_names <- names(...future.oldEnvVars)
[16:21:06.463]                 envs <- base::Sys.getenv()
[16:21:06.463]                 names <- names(envs)
[16:21:06.463]                 common <- intersect(names, old_names)
[16:21:06.463]                 added <- setdiff(names, old_names)
[16:21:06.463]                 removed <- setdiff(old_names, names)
[16:21:06.463]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.463]                   envs[common]]
[16:21:06.463]                 NAMES <- toupper(changed)
[16:21:06.463]                 args <- list()
[16:21:06.463]                 for (kk in seq_along(NAMES)) {
[16:21:06.463]                   name <- changed[[kk]]
[16:21:06.463]                   NAME <- NAMES[[kk]]
[16:21:06.463]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.463]                     next
[16:21:06.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.463]                 }
[16:21:06.463]                 NAMES <- toupper(added)
[16:21:06.463]                 for (kk in seq_along(NAMES)) {
[16:21:06.463]                   name <- added[[kk]]
[16:21:06.463]                   NAME <- NAMES[[kk]]
[16:21:06.463]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.463]                     next
[16:21:06.463]                   args[[name]] <- ""
[16:21:06.463]                 }
[16:21:06.463]                 NAMES <- toupper(removed)
[16:21:06.463]                 for (kk in seq_along(NAMES)) {
[16:21:06.463]                   name <- removed[[kk]]
[16:21:06.463]                   NAME <- NAMES[[kk]]
[16:21:06.463]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.463]                     next
[16:21:06.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.463]                 }
[16:21:06.463]                 if (length(args) > 0) 
[16:21:06.463]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.463]             }
[16:21:06.463]             else {
[16:21:06.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.463]             }
[16:21:06.463]             {
[16:21:06.463]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.463]                   0L) {
[16:21:06.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.463]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.463]                   base::options(opts)
[16:21:06.463]                 }
[16:21:06.463]                 {
[16:21:06.463]                   {
[16:21:06.463]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.463]                     NULL
[16:21:06.463]                   }
[16:21:06.463]                   options(future.plan = NULL)
[16:21:06.463]                   if (is.na(NA_character_)) 
[16:21:06.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.463]                     .init = FALSE)
[16:21:06.463]                 }
[16:21:06.463]             }
[16:21:06.463]         }
[16:21:06.463]     })
[16:21:06.463]     if (TRUE) {
[16:21:06.463]         base::sink(type = "output", split = FALSE)
[16:21:06.463]         if (TRUE) {
[16:21:06.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.463]         }
[16:21:06.463]         else {
[16:21:06.463]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.463]         }
[16:21:06.463]         base::close(...future.stdout)
[16:21:06.463]         ...future.stdout <- NULL
[16:21:06.463]     }
[16:21:06.463]     ...future.result$conditions <- ...future.conditions
[16:21:06.463]     ...future.result$finished <- base::Sys.time()
[16:21:06.463]     ...future.result
[16:21:06.463] }
[16:21:06.468] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[16:21:06.469] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[16:21:06.521] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[16:21:06.521] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[16:21:06.521] MultisessionFuture started
[16:21:06.522] - Launch lazy future ... done
[16:21:06.522] run() for ‘MultisessionFuture’ ... done
[16:21:06.522] result() for ClusterFuture ...
[16:21:06.522] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.522] - Validating connection of MultisessionFuture
[16:21:06.567] - received message: FutureResult
[16:21:06.567] - Received FutureResult
[16:21:06.567] - Erased future from FutureRegistry
[16:21:06.567] result() for ClusterFuture ...
[16:21:06.567] - result already collected: FutureResult
[16:21:06.567] result() for ClusterFuture ... done
[16:21:06.567] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.567] result() for ClusterFuture ... done
[16:21:06.568] result() for ClusterFuture ...
[16:21:06.568] - result already collected: FutureResult
[16:21:06.568] result() for ClusterFuture ... done
value(b) = 2
[16:21:06.568] result() for ClusterFuture ...
[16:21:06.568] - result already collected: FutureResult
[16:21:06.568] result() for ClusterFuture ... done
[16:21:06.568] result() for ClusterFuture ...
[16:21:06.568] - result already collected: FutureResult
[16:21:06.568] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.569] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.569] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.570] 
[16:21:06.570] Searching for globals ... DONE
[16:21:06.570] - globals: [0] <none>
[16:21:06.570] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.570] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.570] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.571] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:06.571] Searching for globals ... DONE
[16:21:06.571] Resolving globals: TRUE
[16:21:06.572] Resolving any globals that are futures ...
[16:21:06.572] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:06.572] Resolving any globals that are futures ... DONE
[16:21:06.572] Resolving futures part of globals (recursively) ...
[16:21:06.572] resolve() on list ...
[16:21:06.572]  recursive: 99
[16:21:06.573]  length: 1
[16:21:06.573]  elements: ‘a’
[16:21:06.573] run() for ‘Future’ ...
[16:21:06.573] - state: ‘created’
[16:21:06.573] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.588] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.588]   - Field: ‘node’
[16:21:06.588]   - Field: ‘label’
[16:21:06.588]   - Field: ‘local’
[16:21:06.588]   - Field: ‘owner’
[16:21:06.588]   - Field: ‘envir’
[16:21:06.588]   - Field: ‘workers’
[16:21:06.588]   - Field: ‘packages’
[16:21:06.588]   - Field: ‘gc’
[16:21:06.589]   - Field: ‘conditions’
[16:21:06.589]   - Field: ‘persistent’
[16:21:06.589]   - Field: ‘expr’
[16:21:06.589]   - Field: ‘uuid’
[16:21:06.589]   - Field: ‘seed’
[16:21:06.589]   - Field: ‘version’
[16:21:06.589]   - Field: ‘result’
[16:21:06.589]   - Field: ‘asynchronous’
[16:21:06.589]   - Field: ‘calls’
[16:21:06.589]   - Field: ‘globals’
[16:21:06.589]   - Field: ‘stdout’
[16:21:06.590]   - Field: ‘earlySignal’
[16:21:06.590]   - Field: ‘lazy’
[16:21:06.590]   - Field: ‘state’
[16:21:06.590] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.590] - Launch lazy future ...
[16:21:06.590] Packages needed by the future expression (n = 0): <none>
[16:21:06.590] Packages needed by future strategies (n = 0): <none>
[16:21:06.591] {
[16:21:06.591]     {
[16:21:06.591]         {
[16:21:06.591]             ...future.startTime <- base::Sys.time()
[16:21:06.591]             {
[16:21:06.591]                 {
[16:21:06.591]                   {
[16:21:06.591]                     {
[16:21:06.591]                       base::local({
[16:21:06.591]                         has_future <- base::requireNamespace("future", 
[16:21:06.591]                           quietly = TRUE)
[16:21:06.591]                         if (has_future) {
[16:21:06.591]                           ns <- base::getNamespace("future")
[16:21:06.591]                           version <- ns[[".package"]][["version"]]
[16:21:06.591]                           if (is.null(version)) 
[16:21:06.591]                             version <- utils::packageVersion("future")
[16:21:06.591]                         }
[16:21:06.591]                         else {
[16:21:06.591]                           version <- NULL
[16:21:06.591]                         }
[16:21:06.591]                         if (!has_future || version < "1.8.0") {
[16:21:06.591]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.591]                             "", base::R.version$version.string), 
[16:21:06.591]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:06.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:06.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.591]                               "release", "version")], collapse = " "), 
[16:21:06.591]                             hostname = base::Sys.info()[["nodename"]])
[16:21:06.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.591]                             info)
[16:21:06.591]                           info <- base::paste(info, collapse = "; ")
[16:21:06.591]                           if (!has_future) {
[16:21:06.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.591]                               info)
[16:21:06.591]                           }
[16:21:06.591]                           else {
[16:21:06.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.591]                               info, version)
[16:21:06.591]                           }
[16:21:06.591]                           base::stop(msg)
[16:21:06.591]                         }
[16:21:06.591]                       })
[16:21:06.591]                     }
[16:21:06.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.591]                     base::options(mc.cores = 1L)
[16:21:06.591]                   }
[16:21:06.591]                   ...future.strategy.old <- future::plan("list")
[16:21:06.591]                   options(future.plan = NULL)
[16:21:06.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.591]                 }
[16:21:06.591]                 ...future.workdir <- getwd()
[16:21:06.591]             }
[16:21:06.591]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.591]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.591]         }
[16:21:06.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.591]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.591]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.591]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.591]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.591]             base::names(...future.oldOptions))
[16:21:06.591]     }
[16:21:06.591]     if (FALSE) {
[16:21:06.591]     }
[16:21:06.591]     else {
[16:21:06.591]         if (TRUE) {
[16:21:06.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.591]                 open = "w")
[16:21:06.591]         }
[16:21:06.591]         else {
[16:21:06.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.591]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.591]         }
[16:21:06.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.591]             base::sink(type = "output", split = FALSE)
[16:21:06.591]             base::close(...future.stdout)
[16:21:06.591]         }, add = TRUE)
[16:21:06.591]     }
[16:21:06.591]     ...future.frame <- base::sys.nframe()
[16:21:06.591]     ...future.conditions <- base::list()
[16:21:06.591]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.591]     if (FALSE) {
[16:21:06.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.591]     }
[16:21:06.591]     ...future.result <- base::tryCatch({
[16:21:06.591]         base::withCallingHandlers({
[16:21:06.591]             ...future.value <- base::withVisible(base::local({
[16:21:06.591]                 ...future.makeSendCondition <- base::local({
[16:21:06.591]                   sendCondition <- NULL
[16:21:06.591]                   function(frame = 1L) {
[16:21:06.591]                     if (is.function(sendCondition)) 
[16:21:06.591]                       return(sendCondition)
[16:21:06.591]                     ns <- getNamespace("parallel")
[16:21:06.591]                     if (exists("sendData", mode = "function", 
[16:21:06.591]                       envir = ns)) {
[16:21:06.591]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.591]                         envir = ns)
[16:21:06.591]                       envir <- sys.frame(frame)
[16:21:06.591]                       master <- NULL
[16:21:06.591]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.591]                         !identical(envir, emptyenv())) {
[16:21:06.591]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.591]                           inherits = FALSE)) {
[16:21:06.591]                           master <- get("master", mode = "list", 
[16:21:06.591]                             envir = envir, inherits = FALSE)
[16:21:06.591]                           if (inherits(master, c("SOCKnode", 
[16:21:06.591]                             "SOCK0node"))) {
[16:21:06.591]                             sendCondition <<- function(cond) {
[16:21:06.591]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.591]                                 success = TRUE)
[16:21:06.591]                               parallel_sendData(master, data)
[16:21:06.591]                             }
[16:21:06.591]                             return(sendCondition)
[16:21:06.591]                           }
[16:21:06.591]                         }
[16:21:06.591]                         frame <- frame + 1L
[16:21:06.591]                         envir <- sys.frame(frame)
[16:21:06.591]                       }
[16:21:06.591]                     }
[16:21:06.591]                     sendCondition <<- function(cond) NULL
[16:21:06.591]                   }
[16:21:06.591]                 })
[16:21:06.591]                 withCallingHandlers({
[16:21:06.591]                   1
[16:21:06.591]                 }, immediateCondition = function(cond) {
[16:21:06.591]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.591]                   sendCondition(cond)
[16:21:06.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.591]                   {
[16:21:06.591]                     inherits <- base::inherits
[16:21:06.591]                     invokeRestart <- base::invokeRestart
[16:21:06.591]                     is.null <- base::is.null
[16:21:06.591]                     muffled <- FALSE
[16:21:06.591]                     if (inherits(cond, "message")) {
[16:21:06.591]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.591]                       if (muffled) 
[16:21:06.591]                         invokeRestart("muffleMessage")
[16:21:06.591]                     }
[16:21:06.591]                     else if (inherits(cond, "warning")) {
[16:21:06.591]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.591]                       if (muffled) 
[16:21:06.591]                         invokeRestart("muffleWarning")
[16:21:06.591]                     }
[16:21:06.591]                     else if (inherits(cond, "condition")) {
[16:21:06.591]                       if (!is.null(pattern)) {
[16:21:06.591]                         computeRestarts <- base::computeRestarts
[16:21:06.591]                         grepl <- base::grepl
[16:21:06.591]                         restarts <- computeRestarts(cond)
[16:21:06.591]                         for (restart in restarts) {
[16:21:06.591]                           name <- restart$name
[16:21:06.591]                           if (is.null(name)) 
[16:21:06.591]                             next
[16:21:06.591]                           if (!grepl(pattern, name)) 
[16:21:06.591]                             next
[16:21:06.591]                           invokeRestart(restart)
[16:21:06.591]                           muffled <- TRUE
[16:21:06.591]                           break
[16:21:06.591]                         }
[16:21:06.591]                       }
[16:21:06.591]                     }
[16:21:06.591]                     invisible(muffled)
[16:21:06.591]                   }
[16:21:06.591]                   muffleCondition(cond)
[16:21:06.591]                 })
[16:21:06.591]             }))
[16:21:06.591]             future::FutureResult(value = ...future.value$value, 
[16:21:06.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.591]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.591]                     ...future.globalenv.names))
[16:21:06.591]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.591]         }, condition = base::local({
[16:21:06.591]             c <- base::c
[16:21:06.591]             inherits <- base::inherits
[16:21:06.591]             invokeRestart <- base::invokeRestart
[16:21:06.591]             length <- base::length
[16:21:06.591]             list <- base::list
[16:21:06.591]             seq.int <- base::seq.int
[16:21:06.591]             signalCondition <- base::signalCondition
[16:21:06.591]             sys.calls <- base::sys.calls
[16:21:06.591]             `[[` <- base::`[[`
[16:21:06.591]             `+` <- base::`+`
[16:21:06.591]             `<<-` <- base::`<<-`
[16:21:06.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.591]                   3L)]
[16:21:06.591]             }
[16:21:06.591]             function(cond) {
[16:21:06.591]                 is_error <- inherits(cond, "error")
[16:21:06.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.591]                   NULL)
[16:21:06.591]                 if (is_error) {
[16:21:06.591]                   sessionInformation <- function() {
[16:21:06.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.591]                       search = base::search(), system = base::Sys.info())
[16:21:06.591]                   }
[16:21:06.591]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.591]                     cond$call), session = sessionInformation(), 
[16:21:06.591]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.591]                   signalCondition(cond)
[16:21:06.591]                 }
[16:21:06.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.591]                 "immediateCondition"))) {
[16:21:06.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.591]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.591]                   if (TRUE && !signal) {
[16:21:06.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.591]                     {
[16:21:06.591]                       inherits <- base::inherits
[16:21:06.591]                       invokeRestart <- base::invokeRestart
[16:21:06.591]                       is.null <- base::is.null
[16:21:06.591]                       muffled <- FALSE
[16:21:06.591]                       if (inherits(cond, "message")) {
[16:21:06.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.591]                         if (muffled) 
[16:21:06.591]                           invokeRestart("muffleMessage")
[16:21:06.591]                       }
[16:21:06.591]                       else if (inherits(cond, "warning")) {
[16:21:06.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.591]                         if (muffled) 
[16:21:06.591]                           invokeRestart("muffleWarning")
[16:21:06.591]                       }
[16:21:06.591]                       else if (inherits(cond, "condition")) {
[16:21:06.591]                         if (!is.null(pattern)) {
[16:21:06.591]                           computeRestarts <- base::computeRestarts
[16:21:06.591]                           grepl <- base::grepl
[16:21:06.591]                           restarts <- computeRestarts(cond)
[16:21:06.591]                           for (restart in restarts) {
[16:21:06.591]                             name <- restart$name
[16:21:06.591]                             if (is.null(name)) 
[16:21:06.591]                               next
[16:21:06.591]                             if (!grepl(pattern, name)) 
[16:21:06.591]                               next
[16:21:06.591]                             invokeRestart(restart)
[16:21:06.591]                             muffled <- TRUE
[16:21:06.591]                             break
[16:21:06.591]                           }
[16:21:06.591]                         }
[16:21:06.591]                       }
[16:21:06.591]                       invisible(muffled)
[16:21:06.591]                     }
[16:21:06.591]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.591]                   }
[16:21:06.591]                 }
[16:21:06.591]                 else {
[16:21:06.591]                   if (TRUE) {
[16:21:06.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.591]                     {
[16:21:06.591]                       inherits <- base::inherits
[16:21:06.591]                       invokeRestart <- base::invokeRestart
[16:21:06.591]                       is.null <- base::is.null
[16:21:06.591]                       muffled <- FALSE
[16:21:06.591]                       if (inherits(cond, "message")) {
[16:21:06.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.591]                         if (muffled) 
[16:21:06.591]                           invokeRestart("muffleMessage")
[16:21:06.591]                       }
[16:21:06.591]                       else if (inherits(cond, "warning")) {
[16:21:06.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.591]                         if (muffled) 
[16:21:06.591]                           invokeRestart("muffleWarning")
[16:21:06.591]                       }
[16:21:06.591]                       else if (inherits(cond, "condition")) {
[16:21:06.591]                         if (!is.null(pattern)) {
[16:21:06.591]                           computeRestarts <- base::computeRestarts
[16:21:06.591]                           grepl <- base::grepl
[16:21:06.591]                           restarts <- computeRestarts(cond)
[16:21:06.591]                           for (restart in restarts) {
[16:21:06.591]                             name <- restart$name
[16:21:06.591]                             if (is.null(name)) 
[16:21:06.591]                               next
[16:21:06.591]                             if (!grepl(pattern, name)) 
[16:21:06.591]                               next
[16:21:06.591]                             invokeRestart(restart)
[16:21:06.591]                             muffled <- TRUE
[16:21:06.591]                             break
[16:21:06.591]                           }
[16:21:06.591]                         }
[16:21:06.591]                       }
[16:21:06.591]                       invisible(muffled)
[16:21:06.591]                     }
[16:21:06.591]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.591]                   }
[16:21:06.591]                 }
[16:21:06.591]             }
[16:21:06.591]         }))
[16:21:06.591]     }, error = function(ex) {
[16:21:06.591]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.591]                 ...future.rng), started = ...future.startTime, 
[16:21:06.591]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.591]             version = "1.8"), class = "FutureResult")
[16:21:06.591]     }, finally = {
[16:21:06.591]         if (!identical(...future.workdir, getwd())) 
[16:21:06.591]             setwd(...future.workdir)
[16:21:06.591]         {
[16:21:06.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.591]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.591]             }
[16:21:06.591]             base::options(...future.oldOptions)
[16:21:06.591]             if (.Platform$OS.type == "windows") {
[16:21:06.591]                 old_names <- names(...future.oldEnvVars)
[16:21:06.591]                 envs <- base::Sys.getenv()
[16:21:06.591]                 names <- names(envs)
[16:21:06.591]                 common <- intersect(names, old_names)
[16:21:06.591]                 added <- setdiff(names, old_names)
[16:21:06.591]                 removed <- setdiff(old_names, names)
[16:21:06.591]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.591]                   envs[common]]
[16:21:06.591]                 NAMES <- toupper(changed)
[16:21:06.591]                 args <- list()
[16:21:06.591]                 for (kk in seq_along(NAMES)) {
[16:21:06.591]                   name <- changed[[kk]]
[16:21:06.591]                   NAME <- NAMES[[kk]]
[16:21:06.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.591]                     next
[16:21:06.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.591]                 }
[16:21:06.591]                 NAMES <- toupper(added)
[16:21:06.591]                 for (kk in seq_along(NAMES)) {
[16:21:06.591]                   name <- added[[kk]]
[16:21:06.591]                   NAME <- NAMES[[kk]]
[16:21:06.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.591]                     next
[16:21:06.591]                   args[[name]] <- ""
[16:21:06.591]                 }
[16:21:06.591]                 NAMES <- toupper(removed)
[16:21:06.591]                 for (kk in seq_along(NAMES)) {
[16:21:06.591]                   name <- removed[[kk]]
[16:21:06.591]                   NAME <- NAMES[[kk]]
[16:21:06.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.591]                     next
[16:21:06.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.591]                 }
[16:21:06.591]                 if (length(args) > 0) 
[16:21:06.591]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.591]             }
[16:21:06.591]             else {
[16:21:06.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.591]             }
[16:21:06.591]             {
[16:21:06.591]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.591]                   0L) {
[16:21:06.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.591]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.591]                   base::options(opts)
[16:21:06.591]                 }
[16:21:06.591]                 {
[16:21:06.591]                   {
[16:21:06.591]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.591]                     NULL
[16:21:06.591]                   }
[16:21:06.591]                   options(future.plan = NULL)
[16:21:06.591]                   if (is.na(NA_character_)) 
[16:21:06.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.591]                     .init = FALSE)
[16:21:06.591]                 }
[16:21:06.591]             }
[16:21:06.591]         }
[16:21:06.591]     })
[16:21:06.591]     if (TRUE) {
[16:21:06.591]         base::sink(type = "output", split = FALSE)
[16:21:06.591]         if (TRUE) {
[16:21:06.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.591]         }
[16:21:06.591]         else {
[16:21:06.591]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.591]         }
[16:21:06.591]         base::close(...future.stdout)
[16:21:06.591]         ...future.stdout <- NULL
[16:21:06.591]     }
[16:21:06.591]     ...future.result$conditions <- ...future.conditions
[16:21:06.591]     ...future.result$finished <- base::Sys.time()
[16:21:06.591]     ...future.result
[16:21:06.591] }
[16:21:06.594] MultisessionFuture started
[16:21:06.594] - Launch lazy future ... done
[16:21:06.594] run() for ‘MultisessionFuture’ ... done
[16:21:06.638] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.638] - Validating connection of MultisessionFuture
[16:21:06.639] - received message: FutureResult
[16:21:06.639] - Received FutureResult
[16:21:06.639] - Erased future from FutureRegistry
[16:21:06.639] result() for ClusterFuture ...
[16:21:06.639] - result already collected: FutureResult
[16:21:06.639] result() for ClusterFuture ... done
[16:21:06.639] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.639] Future #1
[16:21:06.639] result() for ClusterFuture ...
[16:21:06.640] - result already collected: FutureResult
[16:21:06.640] result() for ClusterFuture ... done
[16:21:06.640] result() for ClusterFuture ...
[16:21:06.640] - result already collected: FutureResult
[16:21:06.640] result() for ClusterFuture ... done
[16:21:06.640] A MultisessionFuture was resolved
[16:21:06.640]  length: 0 (resolved future 1)
[16:21:06.640] resolve() on list ... DONE
[16:21:06.640] - globals: [1] ‘a’
[16:21:06.641] Resolving futures part of globals (recursively) ... DONE
[16:21:06.641] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[16:21:06.642] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[16:21:06.642] - globals: [1] ‘a’
[16:21:06.642] - packages: [1] ‘future’
[16:21:06.642] getGlobalsAndPackages() ... DONE
[16:21:06.643] run() for ‘Future’ ...
[16:21:06.643] - state: ‘created’
[16:21:06.643] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.658] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.658] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.658]   - Field: ‘node’
[16:21:06.658]   - Field: ‘label’
[16:21:06.658]   - Field: ‘local’
[16:21:06.658]   - Field: ‘owner’
[16:21:06.658]   - Field: ‘envir’
[16:21:06.658]   - Field: ‘workers’
[16:21:06.658]   - Field: ‘packages’
[16:21:06.658]   - Field: ‘gc’
[16:21:06.659]   - Field: ‘conditions’
[16:21:06.659]   - Field: ‘persistent’
[16:21:06.659]   - Field: ‘expr’
[16:21:06.659]   - Field: ‘uuid’
[16:21:06.659]   - Field: ‘seed’
[16:21:06.659]   - Field: ‘version’
[16:21:06.659]   - Field: ‘result’
[16:21:06.659]   - Field: ‘asynchronous’
[16:21:06.659]   - Field: ‘calls’
[16:21:06.659]   - Field: ‘globals’
[16:21:06.659]   - Field: ‘stdout’
[16:21:06.660]   - Field: ‘earlySignal’
[16:21:06.660]   - Field: ‘lazy’
[16:21:06.660]   - Field: ‘state’
[16:21:06.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.660] - Launch lazy future ...
[16:21:06.660] Packages needed by the future expression (n = 1): ‘future’
[16:21:06.660] Packages needed by future strategies (n = 0): <none>
[16:21:06.661] {
[16:21:06.661]     {
[16:21:06.661]         {
[16:21:06.661]             ...future.startTime <- base::Sys.time()
[16:21:06.661]             {
[16:21:06.661]                 {
[16:21:06.661]                   {
[16:21:06.661]                     {
[16:21:06.661]                       {
[16:21:06.661]                         base::local({
[16:21:06.661]                           has_future <- base::requireNamespace("future", 
[16:21:06.661]                             quietly = TRUE)
[16:21:06.661]                           if (has_future) {
[16:21:06.661]                             ns <- base::getNamespace("future")
[16:21:06.661]                             version <- ns[[".package"]][["version"]]
[16:21:06.661]                             if (is.null(version)) 
[16:21:06.661]                               version <- utils::packageVersion("future")
[16:21:06.661]                           }
[16:21:06.661]                           else {
[16:21:06.661]                             version <- NULL
[16:21:06.661]                           }
[16:21:06.661]                           if (!has_future || version < "1.8.0") {
[16:21:06.661]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.661]                               "", base::R.version$version.string), 
[16:21:06.661]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:06.661]                                 base::R.version$platform, 8 * 
[16:21:06.661]                                   base::.Machine$sizeof.pointer), 
[16:21:06.661]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.661]                                 "release", "version")], collapse = " "), 
[16:21:06.661]                               hostname = base::Sys.info()[["nodename"]])
[16:21:06.661]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.661]                               info)
[16:21:06.661]                             info <- base::paste(info, collapse = "; ")
[16:21:06.661]                             if (!has_future) {
[16:21:06.661]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.661]                                 info)
[16:21:06.661]                             }
[16:21:06.661]                             else {
[16:21:06.661]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.661]                                 info, version)
[16:21:06.661]                             }
[16:21:06.661]                             base::stop(msg)
[16:21:06.661]                           }
[16:21:06.661]                         })
[16:21:06.661]                       }
[16:21:06.661]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.661]                       base::options(mc.cores = 1L)
[16:21:06.661]                     }
[16:21:06.661]                     base::local({
[16:21:06.661]                       for (pkg in "future") {
[16:21:06.661]                         base::loadNamespace(pkg)
[16:21:06.661]                         base::library(pkg, character.only = TRUE)
[16:21:06.661]                       }
[16:21:06.661]                     })
[16:21:06.661]                   }
[16:21:06.661]                   ...future.strategy.old <- future::plan("list")
[16:21:06.661]                   options(future.plan = NULL)
[16:21:06.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.661]                 }
[16:21:06.661]                 ...future.workdir <- getwd()
[16:21:06.661]             }
[16:21:06.661]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.661]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.661]         }
[16:21:06.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.661]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.661]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.661]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.661]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.661]             base::names(...future.oldOptions))
[16:21:06.661]     }
[16:21:06.661]     if (FALSE) {
[16:21:06.661]     }
[16:21:06.661]     else {
[16:21:06.661]         if (TRUE) {
[16:21:06.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.661]                 open = "w")
[16:21:06.661]         }
[16:21:06.661]         else {
[16:21:06.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.661]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.661]         }
[16:21:06.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.661]             base::sink(type = "output", split = FALSE)
[16:21:06.661]             base::close(...future.stdout)
[16:21:06.661]         }, add = TRUE)
[16:21:06.661]     }
[16:21:06.661]     ...future.frame <- base::sys.nframe()
[16:21:06.661]     ...future.conditions <- base::list()
[16:21:06.661]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.661]     if (FALSE) {
[16:21:06.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.661]     }
[16:21:06.661]     ...future.result <- base::tryCatch({
[16:21:06.661]         base::withCallingHandlers({
[16:21:06.661]             ...future.value <- base::withVisible(base::local({
[16:21:06.661]                 ...future.makeSendCondition <- base::local({
[16:21:06.661]                   sendCondition <- NULL
[16:21:06.661]                   function(frame = 1L) {
[16:21:06.661]                     if (is.function(sendCondition)) 
[16:21:06.661]                       return(sendCondition)
[16:21:06.661]                     ns <- getNamespace("parallel")
[16:21:06.661]                     if (exists("sendData", mode = "function", 
[16:21:06.661]                       envir = ns)) {
[16:21:06.661]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.661]                         envir = ns)
[16:21:06.661]                       envir <- sys.frame(frame)
[16:21:06.661]                       master <- NULL
[16:21:06.661]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.661]                         !identical(envir, emptyenv())) {
[16:21:06.661]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.661]                           inherits = FALSE)) {
[16:21:06.661]                           master <- get("master", mode = "list", 
[16:21:06.661]                             envir = envir, inherits = FALSE)
[16:21:06.661]                           if (inherits(master, c("SOCKnode", 
[16:21:06.661]                             "SOCK0node"))) {
[16:21:06.661]                             sendCondition <<- function(cond) {
[16:21:06.661]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.661]                                 success = TRUE)
[16:21:06.661]                               parallel_sendData(master, data)
[16:21:06.661]                             }
[16:21:06.661]                             return(sendCondition)
[16:21:06.661]                           }
[16:21:06.661]                         }
[16:21:06.661]                         frame <- frame + 1L
[16:21:06.661]                         envir <- sys.frame(frame)
[16:21:06.661]                       }
[16:21:06.661]                     }
[16:21:06.661]                     sendCondition <<- function(cond) NULL
[16:21:06.661]                   }
[16:21:06.661]                 })
[16:21:06.661]                 withCallingHandlers({
[16:21:06.661]                   value(a) + 1
[16:21:06.661]                 }, immediateCondition = function(cond) {
[16:21:06.661]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.661]                   sendCondition(cond)
[16:21:06.661]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.661]                   {
[16:21:06.661]                     inherits <- base::inherits
[16:21:06.661]                     invokeRestart <- base::invokeRestart
[16:21:06.661]                     is.null <- base::is.null
[16:21:06.661]                     muffled <- FALSE
[16:21:06.661]                     if (inherits(cond, "message")) {
[16:21:06.661]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.661]                       if (muffled) 
[16:21:06.661]                         invokeRestart("muffleMessage")
[16:21:06.661]                     }
[16:21:06.661]                     else if (inherits(cond, "warning")) {
[16:21:06.661]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.661]                       if (muffled) 
[16:21:06.661]                         invokeRestart("muffleWarning")
[16:21:06.661]                     }
[16:21:06.661]                     else if (inherits(cond, "condition")) {
[16:21:06.661]                       if (!is.null(pattern)) {
[16:21:06.661]                         computeRestarts <- base::computeRestarts
[16:21:06.661]                         grepl <- base::grepl
[16:21:06.661]                         restarts <- computeRestarts(cond)
[16:21:06.661]                         for (restart in restarts) {
[16:21:06.661]                           name <- restart$name
[16:21:06.661]                           if (is.null(name)) 
[16:21:06.661]                             next
[16:21:06.661]                           if (!grepl(pattern, name)) 
[16:21:06.661]                             next
[16:21:06.661]                           invokeRestart(restart)
[16:21:06.661]                           muffled <- TRUE
[16:21:06.661]                           break
[16:21:06.661]                         }
[16:21:06.661]                       }
[16:21:06.661]                     }
[16:21:06.661]                     invisible(muffled)
[16:21:06.661]                   }
[16:21:06.661]                   muffleCondition(cond)
[16:21:06.661]                 })
[16:21:06.661]             }))
[16:21:06.661]             future::FutureResult(value = ...future.value$value, 
[16:21:06.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.661]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.661]                     ...future.globalenv.names))
[16:21:06.661]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.661]         }, condition = base::local({
[16:21:06.661]             c <- base::c
[16:21:06.661]             inherits <- base::inherits
[16:21:06.661]             invokeRestart <- base::invokeRestart
[16:21:06.661]             length <- base::length
[16:21:06.661]             list <- base::list
[16:21:06.661]             seq.int <- base::seq.int
[16:21:06.661]             signalCondition <- base::signalCondition
[16:21:06.661]             sys.calls <- base::sys.calls
[16:21:06.661]             `[[` <- base::`[[`
[16:21:06.661]             `+` <- base::`+`
[16:21:06.661]             `<<-` <- base::`<<-`
[16:21:06.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.661]                   3L)]
[16:21:06.661]             }
[16:21:06.661]             function(cond) {
[16:21:06.661]                 is_error <- inherits(cond, "error")
[16:21:06.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.661]                   NULL)
[16:21:06.661]                 if (is_error) {
[16:21:06.661]                   sessionInformation <- function() {
[16:21:06.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.661]                       search = base::search(), system = base::Sys.info())
[16:21:06.661]                   }
[16:21:06.661]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.661]                     cond$call), session = sessionInformation(), 
[16:21:06.661]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.661]                   signalCondition(cond)
[16:21:06.661]                 }
[16:21:06.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.661]                 "immediateCondition"))) {
[16:21:06.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.661]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.661]                   if (TRUE && !signal) {
[16:21:06.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.661]                     {
[16:21:06.661]                       inherits <- base::inherits
[16:21:06.661]                       invokeRestart <- base::invokeRestart
[16:21:06.661]                       is.null <- base::is.null
[16:21:06.661]                       muffled <- FALSE
[16:21:06.661]                       if (inherits(cond, "message")) {
[16:21:06.661]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.661]                         if (muffled) 
[16:21:06.661]                           invokeRestart("muffleMessage")
[16:21:06.661]                       }
[16:21:06.661]                       else if (inherits(cond, "warning")) {
[16:21:06.661]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.661]                         if (muffled) 
[16:21:06.661]                           invokeRestart("muffleWarning")
[16:21:06.661]                       }
[16:21:06.661]                       else if (inherits(cond, "condition")) {
[16:21:06.661]                         if (!is.null(pattern)) {
[16:21:06.661]                           computeRestarts <- base::computeRestarts
[16:21:06.661]                           grepl <- base::grepl
[16:21:06.661]                           restarts <- computeRestarts(cond)
[16:21:06.661]                           for (restart in restarts) {
[16:21:06.661]                             name <- restart$name
[16:21:06.661]                             if (is.null(name)) 
[16:21:06.661]                               next
[16:21:06.661]                             if (!grepl(pattern, name)) 
[16:21:06.661]                               next
[16:21:06.661]                             invokeRestart(restart)
[16:21:06.661]                             muffled <- TRUE
[16:21:06.661]                             break
[16:21:06.661]                           }
[16:21:06.661]                         }
[16:21:06.661]                       }
[16:21:06.661]                       invisible(muffled)
[16:21:06.661]                     }
[16:21:06.661]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.661]                   }
[16:21:06.661]                 }
[16:21:06.661]                 else {
[16:21:06.661]                   if (TRUE) {
[16:21:06.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.661]                     {
[16:21:06.661]                       inherits <- base::inherits
[16:21:06.661]                       invokeRestart <- base::invokeRestart
[16:21:06.661]                       is.null <- base::is.null
[16:21:06.661]                       muffled <- FALSE
[16:21:06.661]                       if (inherits(cond, "message")) {
[16:21:06.661]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.661]                         if (muffled) 
[16:21:06.661]                           invokeRestart("muffleMessage")
[16:21:06.661]                       }
[16:21:06.661]                       else if (inherits(cond, "warning")) {
[16:21:06.661]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.661]                         if (muffled) 
[16:21:06.661]                           invokeRestart("muffleWarning")
[16:21:06.661]                       }
[16:21:06.661]                       else if (inherits(cond, "condition")) {
[16:21:06.661]                         if (!is.null(pattern)) {
[16:21:06.661]                           computeRestarts <- base::computeRestarts
[16:21:06.661]                           grepl <- base::grepl
[16:21:06.661]                           restarts <- computeRestarts(cond)
[16:21:06.661]                           for (restart in restarts) {
[16:21:06.661]                             name <- restart$name
[16:21:06.661]                             if (is.null(name)) 
[16:21:06.661]                               next
[16:21:06.661]                             if (!grepl(pattern, name)) 
[16:21:06.661]                               next
[16:21:06.661]                             invokeRestart(restart)
[16:21:06.661]                             muffled <- TRUE
[16:21:06.661]                             break
[16:21:06.661]                           }
[16:21:06.661]                         }
[16:21:06.661]                       }
[16:21:06.661]                       invisible(muffled)
[16:21:06.661]                     }
[16:21:06.661]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.661]                   }
[16:21:06.661]                 }
[16:21:06.661]             }
[16:21:06.661]         }))
[16:21:06.661]     }, error = function(ex) {
[16:21:06.661]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.661]                 ...future.rng), started = ...future.startTime, 
[16:21:06.661]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.661]             version = "1.8"), class = "FutureResult")
[16:21:06.661]     }, finally = {
[16:21:06.661]         if (!identical(...future.workdir, getwd())) 
[16:21:06.661]             setwd(...future.workdir)
[16:21:06.661]         {
[16:21:06.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.661]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.661]             }
[16:21:06.661]             base::options(...future.oldOptions)
[16:21:06.661]             if (.Platform$OS.type == "windows") {
[16:21:06.661]                 old_names <- names(...future.oldEnvVars)
[16:21:06.661]                 envs <- base::Sys.getenv()
[16:21:06.661]                 names <- names(envs)
[16:21:06.661]                 common <- intersect(names, old_names)
[16:21:06.661]                 added <- setdiff(names, old_names)
[16:21:06.661]                 removed <- setdiff(old_names, names)
[16:21:06.661]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.661]                   envs[common]]
[16:21:06.661]                 NAMES <- toupper(changed)
[16:21:06.661]                 args <- list()
[16:21:06.661]                 for (kk in seq_along(NAMES)) {
[16:21:06.661]                   name <- changed[[kk]]
[16:21:06.661]                   NAME <- NAMES[[kk]]
[16:21:06.661]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.661]                     next
[16:21:06.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.661]                 }
[16:21:06.661]                 NAMES <- toupper(added)
[16:21:06.661]                 for (kk in seq_along(NAMES)) {
[16:21:06.661]                   name <- added[[kk]]
[16:21:06.661]                   NAME <- NAMES[[kk]]
[16:21:06.661]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.661]                     next
[16:21:06.661]                   args[[name]] <- ""
[16:21:06.661]                 }
[16:21:06.661]                 NAMES <- toupper(removed)
[16:21:06.661]                 for (kk in seq_along(NAMES)) {
[16:21:06.661]                   name <- removed[[kk]]
[16:21:06.661]                   NAME <- NAMES[[kk]]
[16:21:06.661]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.661]                     next
[16:21:06.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.661]                 }
[16:21:06.661]                 if (length(args) > 0) 
[16:21:06.661]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.661]             }
[16:21:06.661]             else {
[16:21:06.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.661]             }
[16:21:06.661]             {
[16:21:06.661]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.661]                   0L) {
[16:21:06.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.661]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.661]                   base::options(opts)
[16:21:06.661]                 }
[16:21:06.661]                 {
[16:21:06.661]                   {
[16:21:06.661]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.661]                     NULL
[16:21:06.661]                   }
[16:21:06.661]                   options(future.plan = NULL)
[16:21:06.661]                   if (is.na(NA_character_)) 
[16:21:06.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.661]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.661]                     .init = FALSE)
[16:21:06.661]                 }
[16:21:06.661]             }
[16:21:06.661]         }
[16:21:06.661]     })
[16:21:06.661]     if (TRUE) {
[16:21:06.661]         base::sink(type = "output", split = FALSE)
[16:21:06.661]         if (TRUE) {
[16:21:06.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.661]         }
[16:21:06.661]         else {
[16:21:06.661]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.661]         }
[16:21:06.661]         base::close(...future.stdout)
[16:21:06.661]         ...future.stdout <- NULL
[16:21:06.661]     }
[16:21:06.661]     ...future.result$conditions <- ...future.conditions
[16:21:06.661]     ...future.result$finished <- base::Sys.time()
[16:21:06.661]     ...future.result
[16:21:06.661] }
[16:21:06.664] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[16:21:06.665] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[16:21:06.717] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[16:21:06.717] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[16:21:06.717] MultisessionFuture started
[16:21:06.717] - Launch lazy future ... done
[16:21:06.718] run() for ‘MultisessionFuture’ ... done
[16:21:06.718] result() for ClusterFuture ...
[16:21:06.718] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.718] - Validating connection of MultisessionFuture
[16:21:06.763] - received message: FutureResult
[16:21:06.763] - Received FutureResult
[16:21:06.763] - Erased future from FutureRegistry
[16:21:06.763] result() for ClusterFuture ...
[16:21:06.763] - result already collected: FutureResult
[16:21:06.763] result() for ClusterFuture ... done
[16:21:06.763] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.763] result() for ClusterFuture ... done
[16:21:06.763] result() for ClusterFuture ...
[16:21:06.764] - result already collected: FutureResult
[16:21:06.764] result() for ClusterFuture ... done
value(b) = 2
[16:21:06.764] result() for ClusterFuture ...
[16:21:06.764] - result already collected: FutureResult
[16:21:06.764] result() for ClusterFuture ... done
[16:21:06.764] result() for ClusterFuture ...
[16:21:06.764] - result already collected: FutureResult
[16:21:06.764] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.765] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.765] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.765] 
[16:21:06.766] Searching for globals ... DONE
[16:21:06.766] - globals: [0] <none>
[16:21:06.766] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.766] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.766] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.767] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:06.767] Searching for globals ... DONE
[16:21:06.767] Resolving globals: TRUE
[16:21:06.768] Resolving any globals that are futures ...
[16:21:06.768] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:06.768] Resolving any globals that are futures ... DONE
[16:21:06.768] Resolving futures part of globals (recursively) ...
[16:21:06.768] resolve() on list ...
[16:21:06.769]  recursive: 99
[16:21:06.769]  length: 1
[16:21:06.769]  elements: ‘a’
[16:21:06.769] run() for ‘Future’ ...
[16:21:06.769] - state: ‘created’
[16:21:06.769] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.785] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.786]   - Field: ‘node’
[16:21:06.786]   - Field: ‘label’
[16:21:06.786]   - Field: ‘local’
[16:21:06.786]   - Field: ‘owner’
[16:21:06.786]   - Field: ‘envir’
[16:21:06.786]   - Field: ‘workers’
[16:21:06.786]   - Field: ‘packages’
[16:21:06.786]   - Field: ‘gc’
[16:21:06.786]   - Field: ‘conditions’
[16:21:06.787]   - Field: ‘persistent’
[16:21:06.787]   - Field: ‘expr’
[16:21:06.787]   - Field: ‘uuid’
[16:21:06.787]   - Field: ‘seed’
[16:21:06.787]   - Field: ‘version’
[16:21:06.787]   - Field: ‘result’
[16:21:06.787]   - Field: ‘asynchronous’
[16:21:06.787]   - Field: ‘calls’
[16:21:06.787]   - Field: ‘globals’
[16:21:06.787]   - Field: ‘stdout’
[16:21:06.787]   - Field: ‘earlySignal’
[16:21:06.788]   - Field: ‘lazy’
[16:21:06.788]   - Field: ‘state’
[16:21:06.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.788] - Launch lazy future ...
[16:21:06.788] Packages needed by the future expression (n = 0): <none>
[16:21:06.788] Packages needed by future strategies (n = 0): <none>
[16:21:06.789] {
[16:21:06.789]     {
[16:21:06.789]         {
[16:21:06.789]             ...future.startTime <- base::Sys.time()
[16:21:06.789]             {
[16:21:06.789]                 {
[16:21:06.789]                   {
[16:21:06.789]                     {
[16:21:06.789]                       base::local({
[16:21:06.789]                         has_future <- base::requireNamespace("future", 
[16:21:06.789]                           quietly = TRUE)
[16:21:06.789]                         if (has_future) {
[16:21:06.789]                           ns <- base::getNamespace("future")
[16:21:06.789]                           version <- ns[[".package"]][["version"]]
[16:21:06.789]                           if (is.null(version)) 
[16:21:06.789]                             version <- utils::packageVersion("future")
[16:21:06.789]                         }
[16:21:06.789]                         else {
[16:21:06.789]                           version <- NULL
[16:21:06.789]                         }
[16:21:06.789]                         if (!has_future || version < "1.8.0") {
[16:21:06.789]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.789]                             "", base::R.version$version.string), 
[16:21:06.789]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:06.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:06.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.789]                               "release", "version")], collapse = " "), 
[16:21:06.789]                             hostname = base::Sys.info()[["nodename"]])
[16:21:06.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.789]                             info)
[16:21:06.789]                           info <- base::paste(info, collapse = "; ")
[16:21:06.789]                           if (!has_future) {
[16:21:06.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.789]                               info)
[16:21:06.789]                           }
[16:21:06.789]                           else {
[16:21:06.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.789]                               info, version)
[16:21:06.789]                           }
[16:21:06.789]                           base::stop(msg)
[16:21:06.789]                         }
[16:21:06.789]                       })
[16:21:06.789]                     }
[16:21:06.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.789]                     base::options(mc.cores = 1L)
[16:21:06.789]                   }
[16:21:06.789]                   ...future.strategy.old <- future::plan("list")
[16:21:06.789]                   options(future.plan = NULL)
[16:21:06.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.789]                 }
[16:21:06.789]                 ...future.workdir <- getwd()
[16:21:06.789]             }
[16:21:06.789]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.789]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.789]         }
[16:21:06.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.789]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.789]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.789]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.789]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.789]             base::names(...future.oldOptions))
[16:21:06.789]     }
[16:21:06.789]     if (FALSE) {
[16:21:06.789]     }
[16:21:06.789]     else {
[16:21:06.789]         if (TRUE) {
[16:21:06.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.789]                 open = "w")
[16:21:06.789]         }
[16:21:06.789]         else {
[16:21:06.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.789]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.789]         }
[16:21:06.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.789]             base::sink(type = "output", split = FALSE)
[16:21:06.789]             base::close(...future.stdout)
[16:21:06.789]         }, add = TRUE)
[16:21:06.789]     }
[16:21:06.789]     ...future.frame <- base::sys.nframe()
[16:21:06.789]     ...future.conditions <- base::list()
[16:21:06.789]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.789]     if (FALSE) {
[16:21:06.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.789]     }
[16:21:06.789]     ...future.result <- base::tryCatch({
[16:21:06.789]         base::withCallingHandlers({
[16:21:06.789]             ...future.value <- base::withVisible(base::local({
[16:21:06.789]                 ...future.makeSendCondition <- base::local({
[16:21:06.789]                   sendCondition <- NULL
[16:21:06.789]                   function(frame = 1L) {
[16:21:06.789]                     if (is.function(sendCondition)) 
[16:21:06.789]                       return(sendCondition)
[16:21:06.789]                     ns <- getNamespace("parallel")
[16:21:06.789]                     if (exists("sendData", mode = "function", 
[16:21:06.789]                       envir = ns)) {
[16:21:06.789]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.789]                         envir = ns)
[16:21:06.789]                       envir <- sys.frame(frame)
[16:21:06.789]                       master <- NULL
[16:21:06.789]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.789]                         !identical(envir, emptyenv())) {
[16:21:06.789]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.789]                           inherits = FALSE)) {
[16:21:06.789]                           master <- get("master", mode = "list", 
[16:21:06.789]                             envir = envir, inherits = FALSE)
[16:21:06.789]                           if (inherits(master, c("SOCKnode", 
[16:21:06.789]                             "SOCK0node"))) {
[16:21:06.789]                             sendCondition <<- function(cond) {
[16:21:06.789]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.789]                                 success = TRUE)
[16:21:06.789]                               parallel_sendData(master, data)
[16:21:06.789]                             }
[16:21:06.789]                             return(sendCondition)
[16:21:06.789]                           }
[16:21:06.789]                         }
[16:21:06.789]                         frame <- frame + 1L
[16:21:06.789]                         envir <- sys.frame(frame)
[16:21:06.789]                       }
[16:21:06.789]                     }
[16:21:06.789]                     sendCondition <<- function(cond) NULL
[16:21:06.789]                   }
[16:21:06.789]                 })
[16:21:06.789]                 withCallingHandlers({
[16:21:06.789]                   1
[16:21:06.789]                 }, immediateCondition = function(cond) {
[16:21:06.789]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.789]                   sendCondition(cond)
[16:21:06.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.789]                   {
[16:21:06.789]                     inherits <- base::inherits
[16:21:06.789]                     invokeRestart <- base::invokeRestart
[16:21:06.789]                     is.null <- base::is.null
[16:21:06.789]                     muffled <- FALSE
[16:21:06.789]                     if (inherits(cond, "message")) {
[16:21:06.789]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.789]                       if (muffled) 
[16:21:06.789]                         invokeRestart("muffleMessage")
[16:21:06.789]                     }
[16:21:06.789]                     else if (inherits(cond, "warning")) {
[16:21:06.789]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.789]                       if (muffled) 
[16:21:06.789]                         invokeRestart("muffleWarning")
[16:21:06.789]                     }
[16:21:06.789]                     else if (inherits(cond, "condition")) {
[16:21:06.789]                       if (!is.null(pattern)) {
[16:21:06.789]                         computeRestarts <- base::computeRestarts
[16:21:06.789]                         grepl <- base::grepl
[16:21:06.789]                         restarts <- computeRestarts(cond)
[16:21:06.789]                         for (restart in restarts) {
[16:21:06.789]                           name <- restart$name
[16:21:06.789]                           if (is.null(name)) 
[16:21:06.789]                             next
[16:21:06.789]                           if (!grepl(pattern, name)) 
[16:21:06.789]                             next
[16:21:06.789]                           invokeRestart(restart)
[16:21:06.789]                           muffled <- TRUE
[16:21:06.789]                           break
[16:21:06.789]                         }
[16:21:06.789]                       }
[16:21:06.789]                     }
[16:21:06.789]                     invisible(muffled)
[16:21:06.789]                   }
[16:21:06.789]                   muffleCondition(cond)
[16:21:06.789]                 })
[16:21:06.789]             }))
[16:21:06.789]             future::FutureResult(value = ...future.value$value, 
[16:21:06.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.789]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.789]                     ...future.globalenv.names))
[16:21:06.789]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.789]         }, condition = base::local({
[16:21:06.789]             c <- base::c
[16:21:06.789]             inherits <- base::inherits
[16:21:06.789]             invokeRestart <- base::invokeRestart
[16:21:06.789]             length <- base::length
[16:21:06.789]             list <- base::list
[16:21:06.789]             seq.int <- base::seq.int
[16:21:06.789]             signalCondition <- base::signalCondition
[16:21:06.789]             sys.calls <- base::sys.calls
[16:21:06.789]             `[[` <- base::`[[`
[16:21:06.789]             `+` <- base::`+`
[16:21:06.789]             `<<-` <- base::`<<-`
[16:21:06.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.789]                   3L)]
[16:21:06.789]             }
[16:21:06.789]             function(cond) {
[16:21:06.789]                 is_error <- inherits(cond, "error")
[16:21:06.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.789]                   NULL)
[16:21:06.789]                 if (is_error) {
[16:21:06.789]                   sessionInformation <- function() {
[16:21:06.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.789]                       search = base::search(), system = base::Sys.info())
[16:21:06.789]                   }
[16:21:06.789]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.789]                     cond$call), session = sessionInformation(), 
[16:21:06.789]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.789]                   signalCondition(cond)
[16:21:06.789]                 }
[16:21:06.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.789]                 "immediateCondition"))) {
[16:21:06.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.789]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.789]                   if (TRUE && !signal) {
[16:21:06.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.789]                     {
[16:21:06.789]                       inherits <- base::inherits
[16:21:06.789]                       invokeRestart <- base::invokeRestart
[16:21:06.789]                       is.null <- base::is.null
[16:21:06.789]                       muffled <- FALSE
[16:21:06.789]                       if (inherits(cond, "message")) {
[16:21:06.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.789]                         if (muffled) 
[16:21:06.789]                           invokeRestart("muffleMessage")
[16:21:06.789]                       }
[16:21:06.789]                       else if (inherits(cond, "warning")) {
[16:21:06.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.789]                         if (muffled) 
[16:21:06.789]                           invokeRestart("muffleWarning")
[16:21:06.789]                       }
[16:21:06.789]                       else if (inherits(cond, "condition")) {
[16:21:06.789]                         if (!is.null(pattern)) {
[16:21:06.789]                           computeRestarts <- base::computeRestarts
[16:21:06.789]                           grepl <- base::grepl
[16:21:06.789]                           restarts <- computeRestarts(cond)
[16:21:06.789]                           for (restart in restarts) {
[16:21:06.789]                             name <- restart$name
[16:21:06.789]                             if (is.null(name)) 
[16:21:06.789]                               next
[16:21:06.789]                             if (!grepl(pattern, name)) 
[16:21:06.789]                               next
[16:21:06.789]                             invokeRestart(restart)
[16:21:06.789]                             muffled <- TRUE
[16:21:06.789]                             break
[16:21:06.789]                           }
[16:21:06.789]                         }
[16:21:06.789]                       }
[16:21:06.789]                       invisible(muffled)
[16:21:06.789]                     }
[16:21:06.789]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.789]                   }
[16:21:06.789]                 }
[16:21:06.789]                 else {
[16:21:06.789]                   if (TRUE) {
[16:21:06.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.789]                     {
[16:21:06.789]                       inherits <- base::inherits
[16:21:06.789]                       invokeRestart <- base::invokeRestart
[16:21:06.789]                       is.null <- base::is.null
[16:21:06.789]                       muffled <- FALSE
[16:21:06.789]                       if (inherits(cond, "message")) {
[16:21:06.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.789]                         if (muffled) 
[16:21:06.789]                           invokeRestart("muffleMessage")
[16:21:06.789]                       }
[16:21:06.789]                       else if (inherits(cond, "warning")) {
[16:21:06.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.789]                         if (muffled) 
[16:21:06.789]                           invokeRestart("muffleWarning")
[16:21:06.789]                       }
[16:21:06.789]                       else if (inherits(cond, "condition")) {
[16:21:06.789]                         if (!is.null(pattern)) {
[16:21:06.789]                           computeRestarts <- base::computeRestarts
[16:21:06.789]                           grepl <- base::grepl
[16:21:06.789]                           restarts <- computeRestarts(cond)
[16:21:06.789]                           for (restart in restarts) {
[16:21:06.789]                             name <- restart$name
[16:21:06.789]                             if (is.null(name)) 
[16:21:06.789]                               next
[16:21:06.789]                             if (!grepl(pattern, name)) 
[16:21:06.789]                               next
[16:21:06.789]                             invokeRestart(restart)
[16:21:06.789]                             muffled <- TRUE
[16:21:06.789]                             break
[16:21:06.789]                           }
[16:21:06.789]                         }
[16:21:06.789]                       }
[16:21:06.789]                       invisible(muffled)
[16:21:06.789]                     }
[16:21:06.789]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.789]                   }
[16:21:06.789]                 }
[16:21:06.789]             }
[16:21:06.789]         }))
[16:21:06.789]     }, error = function(ex) {
[16:21:06.789]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.789]                 ...future.rng), started = ...future.startTime, 
[16:21:06.789]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.789]             version = "1.8"), class = "FutureResult")
[16:21:06.789]     }, finally = {
[16:21:06.789]         if (!identical(...future.workdir, getwd())) 
[16:21:06.789]             setwd(...future.workdir)
[16:21:06.789]         {
[16:21:06.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.789]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.789]             }
[16:21:06.789]             base::options(...future.oldOptions)
[16:21:06.789]             if (.Platform$OS.type == "windows") {
[16:21:06.789]                 old_names <- names(...future.oldEnvVars)
[16:21:06.789]                 envs <- base::Sys.getenv()
[16:21:06.789]                 names <- names(envs)
[16:21:06.789]                 common <- intersect(names, old_names)
[16:21:06.789]                 added <- setdiff(names, old_names)
[16:21:06.789]                 removed <- setdiff(old_names, names)
[16:21:06.789]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.789]                   envs[common]]
[16:21:06.789]                 NAMES <- toupper(changed)
[16:21:06.789]                 args <- list()
[16:21:06.789]                 for (kk in seq_along(NAMES)) {
[16:21:06.789]                   name <- changed[[kk]]
[16:21:06.789]                   NAME <- NAMES[[kk]]
[16:21:06.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.789]                     next
[16:21:06.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.789]                 }
[16:21:06.789]                 NAMES <- toupper(added)
[16:21:06.789]                 for (kk in seq_along(NAMES)) {
[16:21:06.789]                   name <- added[[kk]]
[16:21:06.789]                   NAME <- NAMES[[kk]]
[16:21:06.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.789]                     next
[16:21:06.789]                   args[[name]] <- ""
[16:21:06.789]                 }
[16:21:06.789]                 NAMES <- toupper(removed)
[16:21:06.789]                 for (kk in seq_along(NAMES)) {
[16:21:06.789]                   name <- removed[[kk]]
[16:21:06.789]                   NAME <- NAMES[[kk]]
[16:21:06.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.789]                     next
[16:21:06.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.789]                 }
[16:21:06.789]                 if (length(args) > 0) 
[16:21:06.789]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.789]             }
[16:21:06.789]             else {
[16:21:06.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.789]             }
[16:21:06.789]             {
[16:21:06.789]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.789]                   0L) {
[16:21:06.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.789]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.789]                   base::options(opts)
[16:21:06.789]                 }
[16:21:06.789]                 {
[16:21:06.789]                   {
[16:21:06.789]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.789]                     NULL
[16:21:06.789]                   }
[16:21:06.789]                   options(future.plan = NULL)
[16:21:06.789]                   if (is.na(NA_character_)) 
[16:21:06.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.789]                     .init = FALSE)
[16:21:06.789]                 }
[16:21:06.789]             }
[16:21:06.789]         }
[16:21:06.789]     })
[16:21:06.789]     if (TRUE) {
[16:21:06.789]         base::sink(type = "output", split = FALSE)
[16:21:06.789]         if (TRUE) {
[16:21:06.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.789]         }
[16:21:06.789]         else {
[16:21:06.789]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.789]         }
[16:21:06.789]         base::close(...future.stdout)
[16:21:06.789]         ...future.stdout <- NULL
[16:21:06.789]     }
[16:21:06.789]     ...future.result$conditions <- ...future.conditions
[16:21:06.789]     ...future.result$finished <- base::Sys.time()
[16:21:06.789]     ...future.result
[16:21:06.789] }
[16:21:06.791] MultisessionFuture started
[16:21:06.792] - Launch lazy future ... done
[16:21:06.792] run() for ‘MultisessionFuture’ ... done
[16:21:06.834] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.834] - Validating connection of MultisessionFuture
[16:21:06.835] - received message: FutureResult
[16:21:06.835] - Received FutureResult
[16:21:06.835] - Erased future from FutureRegistry
[16:21:06.835] result() for ClusterFuture ...
[16:21:06.835] - result already collected: FutureResult
[16:21:06.835] result() for ClusterFuture ... done
[16:21:06.835] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.835] Future #1
[16:21:06.835] result() for ClusterFuture ...
[16:21:06.836] - result already collected: FutureResult
[16:21:06.836] result() for ClusterFuture ... done
[16:21:06.836] result() for ClusterFuture ...
[16:21:06.836] - result already collected: FutureResult
[16:21:06.836] result() for ClusterFuture ... done
[16:21:06.836] A MultisessionFuture was resolved
[16:21:06.836]  length: 0 (resolved future 1)
[16:21:06.836] resolve() on list ... DONE
[16:21:06.836] - globals: [1] ‘a’
[16:21:06.837] Resolving futures part of globals (recursively) ... DONE
[16:21:06.837] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[16:21:06.838] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[16:21:06.838] - globals: [1] ‘a’
[16:21:06.838] - packages: [1] ‘future’
[16:21:06.838] getGlobalsAndPackages() ... DONE
[16:21:06.838] run() for ‘Future’ ...
[16:21:06.839] - state: ‘created’
[16:21:06.839] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.854] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.854]   - Field: ‘node’
[16:21:06.854]   - Field: ‘label’
[16:21:06.854]   - Field: ‘local’
[16:21:06.854]   - Field: ‘owner’
[16:21:06.854]   - Field: ‘envir’
[16:21:06.854]   - Field: ‘workers’
[16:21:06.854]   - Field: ‘packages’
[16:21:06.854]   - Field: ‘gc’
[16:21:06.854]   - Field: ‘conditions’
[16:21:06.855]   - Field: ‘persistent’
[16:21:06.855]   - Field: ‘expr’
[16:21:06.855]   - Field: ‘uuid’
[16:21:06.855]   - Field: ‘seed’
[16:21:06.855]   - Field: ‘version’
[16:21:06.855]   - Field: ‘result’
[16:21:06.855]   - Field: ‘asynchronous’
[16:21:06.855]   - Field: ‘calls’
[16:21:06.855]   - Field: ‘globals’
[16:21:06.855]   - Field: ‘stdout’
[16:21:06.855]   - Field: ‘earlySignal’
[16:21:06.856]   - Field: ‘lazy’
[16:21:06.856]   - Field: ‘state’
[16:21:06.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.856] - Launch lazy future ...
[16:21:06.856] Packages needed by the future expression (n = 1): ‘future’
[16:21:06.856] Packages needed by future strategies (n = 0): <none>
[16:21:06.857] {
[16:21:06.857]     {
[16:21:06.857]         {
[16:21:06.857]             ...future.startTime <- base::Sys.time()
[16:21:06.857]             {
[16:21:06.857]                 {
[16:21:06.857]                   {
[16:21:06.857]                     {
[16:21:06.857]                       {
[16:21:06.857]                         base::local({
[16:21:06.857]                           has_future <- base::requireNamespace("future", 
[16:21:06.857]                             quietly = TRUE)
[16:21:06.857]                           if (has_future) {
[16:21:06.857]                             ns <- base::getNamespace("future")
[16:21:06.857]                             version <- ns[[".package"]][["version"]]
[16:21:06.857]                             if (is.null(version)) 
[16:21:06.857]                               version <- utils::packageVersion("future")
[16:21:06.857]                           }
[16:21:06.857]                           else {
[16:21:06.857]                             version <- NULL
[16:21:06.857]                           }
[16:21:06.857]                           if (!has_future || version < "1.8.0") {
[16:21:06.857]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.857]                               "", base::R.version$version.string), 
[16:21:06.857]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:06.857]                                 base::R.version$platform, 8 * 
[16:21:06.857]                                   base::.Machine$sizeof.pointer), 
[16:21:06.857]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.857]                                 "release", "version")], collapse = " "), 
[16:21:06.857]                               hostname = base::Sys.info()[["nodename"]])
[16:21:06.857]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.857]                               info)
[16:21:06.857]                             info <- base::paste(info, collapse = "; ")
[16:21:06.857]                             if (!has_future) {
[16:21:06.857]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.857]                                 info)
[16:21:06.857]                             }
[16:21:06.857]                             else {
[16:21:06.857]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.857]                                 info, version)
[16:21:06.857]                             }
[16:21:06.857]                             base::stop(msg)
[16:21:06.857]                           }
[16:21:06.857]                         })
[16:21:06.857]                       }
[16:21:06.857]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.857]                       base::options(mc.cores = 1L)
[16:21:06.857]                     }
[16:21:06.857]                     base::local({
[16:21:06.857]                       for (pkg in "future") {
[16:21:06.857]                         base::loadNamespace(pkg)
[16:21:06.857]                         base::library(pkg, character.only = TRUE)
[16:21:06.857]                       }
[16:21:06.857]                     })
[16:21:06.857]                   }
[16:21:06.857]                   ...future.strategy.old <- future::plan("list")
[16:21:06.857]                   options(future.plan = NULL)
[16:21:06.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.857]                 }
[16:21:06.857]                 ...future.workdir <- getwd()
[16:21:06.857]             }
[16:21:06.857]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.857]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.857]         }
[16:21:06.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.857]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.857]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.857]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.857]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.857]             base::names(...future.oldOptions))
[16:21:06.857]     }
[16:21:06.857]     if (FALSE) {
[16:21:06.857]     }
[16:21:06.857]     else {
[16:21:06.857]         if (TRUE) {
[16:21:06.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.857]                 open = "w")
[16:21:06.857]         }
[16:21:06.857]         else {
[16:21:06.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.857]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.857]         }
[16:21:06.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.857]             base::sink(type = "output", split = FALSE)
[16:21:06.857]             base::close(...future.stdout)
[16:21:06.857]         }, add = TRUE)
[16:21:06.857]     }
[16:21:06.857]     ...future.frame <- base::sys.nframe()
[16:21:06.857]     ...future.conditions <- base::list()
[16:21:06.857]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.857]     if (FALSE) {
[16:21:06.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.857]     }
[16:21:06.857]     ...future.result <- base::tryCatch({
[16:21:06.857]         base::withCallingHandlers({
[16:21:06.857]             ...future.value <- base::withVisible(base::local({
[16:21:06.857]                 ...future.makeSendCondition <- base::local({
[16:21:06.857]                   sendCondition <- NULL
[16:21:06.857]                   function(frame = 1L) {
[16:21:06.857]                     if (is.function(sendCondition)) 
[16:21:06.857]                       return(sendCondition)
[16:21:06.857]                     ns <- getNamespace("parallel")
[16:21:06.857]                     if (exists("sendData", mode = "function", 
[16:21:06.857]                       envir = ns)) {
[16:21:06.857]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.857]                         envir = ns)
[16:21:06.857]                       envir <- sys.frame(frame)
[16:21:06.857]                       master <- NULL
[16:21:06.857]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.857]                         !identical(envir, emptyenv())) {
[16:21:06.857]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.857]                           inherits = FALSE)) {
[16:21:06.857]                           master <- get("master", mode = "list", 
[16:21:06.857]                             envir = envir, inherits = FALSE)
[16:21:06.857]                           if (inherits(master, c("SOCKnode", 
[16:21:06.857]                             "SOCK0node"))) {
[16:21:06.857]                             sendCondition <<- function(cond) {
[16:21:06.857]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.857]                                 success = TRUE)
[16:21:06.857]                               parallel_sendData(master, data)
[16:21:06.857]                             }
[16:21:06.857]                             return(sendCondition)
[16:21:06.857]                           }
[16:21:06.857]                         }
[16:21:06.857]                         frame <- frame + 1L
[16:21:06.857]                         envir <- sys.frame(frame)
[16:21:06.857]                       }
[16:21:06.857]                     }
[16:21:06.857]                     sendCondition <<- function(cond) NULL
[16:21:06.857]                   }
[16:21:06.857]                 })
[16:21:06.857]                 withCallingHandlers({
[16:21:06.857]                   value(a) + 1
[16:21:06.857]                 }, immediateCondition = function(cond) {
[16:21:06.857]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.857]                   sendCondition(cond)
[16:21:06.857]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.857]                   {
[16:21:06.857]                     inherits <- base::inherits
[16:21:06.857]                     invokeRestart <- base::invokeRestart
[16:21:06.857]                     is.null <- base::is.null
[16:21:06.857]                     muffled <- FALSE
[16:21:06.857]                     if (inherits(cond, "message")) {
[16:21:06.857]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.857]                       if (muffled) 
[16:21:06.857]                         invokeRestart("muffleMessage")
[16:21:06.857]                     }
[16:21:06.857]                     else if (inherits(cond, "warning")) {
[16:21:06.857]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.857]                       if (muffled) 
[16:21:06.857]                         invokeRestart("muffleWarning")
[16:21:06.857]                     }
[16:21:06.857]                     else if (inherits(cond, "condition")) {
[16:21:06.857]                       if (!is.null(pattern)) {
[16:21:06.857]                         computeRestarts <- base::computeRestarts
[16:21:06.857]                         grepl <- base::grepl
[16:21:06.857]                         restarts <- computeRestarts(cond)
[16:21:06.857]                         for (restart in restarts) {
[16:21:06.857]                           name <- restart$name
[16:21:06.857]                           if (is.null(name)) 
[16:21:06.857]                             next
[16:21:06.857]                           if (!grepl(pattern, name)) 
[16:21:06.857]                             next
[16:21:06.857]                           invokeRestart(restart)
[16:21:06.857]                           muffled <- TRUE
[16:21:06.857]                           break
[16:21:06.857]                         }
[16:21:06.857]                       }
[16:21:06.857]                     }
[16:21:06.857]                     invisible(muffled)
[16:21:06.857]                   }
[16:21:06.857]                   muffleCondition(cond)
[16:21:06.857]                 })
[16:21:06.857]             }))
[16:21:06.857]             future::FutureResult(value = ...future.value$value, 
[16:21:06.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.857]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.857]                     ...future.globalenv.names))
[16:21:06.857]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.857]         }, condition = base::local({
[16:21:06.857]             c <- base::c
[16:21:06.857]             inherits <- base::inherits
[16:21:06.857]             invokeRestart <- base::invokeRestart
[16:21:06.857]             length <- base::length
[16:21:06.857]             list <- base::list
[16:21:06.857]             seq.int <- base::seq.int
[16:21:06.857]             signalCondition <- base::signalCondition
[16:21:06.857]             sys.calls <- base::sys.calls
[16:21:06.857]             `[[` <- base::`[[`
[16:21:06.857]             `+` <- base::`+`
[16:21:06.857]             `<<-` <- base::`<<-`
[16:21:06.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.857]                   3L)]
[16:21:06.857]             }
[16:21:06.857]             function(cond) {
[16:21:06.857]                 is_error <- inherits(cond, "error")
[16:21:06.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.857]                   NULL)
[16:21:06.857]                 if (is_error) {
[16:21:06.857]                   sessionInformation <- function() {
[16:21:06.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.857]                       search = base::search(), system = base::Sys.info())
[16:21:06.857]                   }
[16:21:06.857]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.857]                     cond$call), session = sessionInformation(), 
[16:21:06.857]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.857]                   signalCondition(cond)
[16:21:06.857]                 }
[16:21:06.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.857]                 "immediateCondition"))) {
[16:21:06.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.857]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.857]                   if (TRUE && !signal) {
[16:21:06.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.857]                     {
[16:21:06.857]                       inherits <- base::inherits
[16:21:06.857]                       invokeRestart <- base::invokeRestart
[16:21:06.857]                       is.null <- base::is.null
[16:21:06.857]                       muffled <- FALSE
[16:21:06.857]                       if (inherits(cond, "message")) {
[16:21:06.857]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.857]                         if (muffled) 
[16:21:06.857]                           invokeRestart("muffleMessage")
[16:21:06.857]                       }
[16:21:06.857]                       else if (inherits(cond, "warning")) {
[16:21:06.857]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.857]                         if (muffled) 
[16:21:06.857]                           invokeRestart("muffleWarning")
[16:21:06.857]                       }
[16:21:06.857]                       else if (inherits(cond, "condition")) {
[16:21:06.857]                         if (!is.null(pattern)) {
[16:21:06.857]                           computeRestarts <- base::computeRestarts
[16:21:06.857]                           grepl <- base::grepl
[16:21:06.857]                           restarts <- computeRestarts(cond)
[16:21:06.857]                           for (restart in restarts) {
[16:21:06.857]                             name <- restart$name
[16:21:06.857]                             if (is.null(name)) 
[16:21:06.857]                               next
[16:21:06.857]                             if (!grepl(pattern, name)) 
[16:21:06.857]                               next
[16:21:06.857]                             invokeRestart(restart)
[16:21:06.857]                             muffled <- TRUE
[16:21:06.857]                             break
[16:21:06.857]                           }
[16:21:06.857]                         }
[16:21:06.857]                       }
[16:21:06.857]                       invisible(muffled)
[16:21:06.857]                     }
[16:21:06.857]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.857]                   }
[16:21:06.857]                 }
[16:21:06.857]                 else {
[16:21:06.857]                   if (TRUE) {
[16:21:06.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.857]                     {
[16:21:06.857]                       inherits <- base::inherits
[16:21:06.857]                       invokeRestart <- base::invokeRestart
[16:21:06.857]                       is.null <- base::is.null
[16:21:06.857]                       muffled <- FALSE
[16:21:06.857]                       if (inherits(cond, "message")) {
[16:21:06.857]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.857]                         if (muffled) 
[16:21:06.857]                           invokeRestart("muffleMessage")
[16:21:06.857]                       }
[16:21:06.857]                       else if (inherits(cond, "warning")) {
[16:21:06.857]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.857]                         if (muffled) 
[16:21:06.857]                           invokeRestart("muffleWarning")
[16:21:06.857]                       }
[16:21:06.857]                       else if (inherits(cond, "condition")) {
[16:21:06.857]                         if (!is.null(pattern)) {
[16:21:06.857]                           computeRestarts <- base::computeRestarts
[16:21:06.857]                           grepl <- base::grepl
[16:21:06.857]                           restarts <- computeRestarts(cond)
[16:21:06.857]                           for (restart in restarts) {
[16:21:06.857]                             name <- restart$name
[16:21:06.857]                             if (is.null(name)) 
[16:21:06.857]                               next
[16:21:06.857]                             if (!grepl(pattern, name)) 
[16:21:06.857]                               next
[16:21:06.857]                             invokeRestart(restart)
[16:21:06.857]                             muffled <- TRUE
[16:21:06.857]                             break
[16:21:06.857]                           }
[16:21:06.857]                         }
[16:21:06.857]                       }
[16:21:06.857]                       invisible(muffled)
[16:21:06.857]                     }
[16:21:06.857]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.857]                   }
[16:21:06.857]                 }
[16:21:06.857]             }
[16:21:06.857]         }))
[16:21:06.857]     }, error = function(ex) {
[16:21:06.857]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.857]                 ...future.rng), started = ...future.startTime, 
[16:21:06.857]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.857]             version = "1.8"), class = "FutureResult")
[16:21:06.857]     }, finally = {
[16:21:06.857]         if (!identical(...future.workdir, getwd())) 
[16:21:06.857]             setwd(...future.workdir)
[16:21:06.857]         {
[16:21:06.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.857]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.857]             }
[16:21:06.857]             base::options(...future.oldOptions)
[16:21:06.857]             if (.Platform$OS.type == "windows") {
[16:21:06.857]                 old_names <- names(...future.oldEnvVars)
[16:21:06.857]                 envs <- base::Sys.getenv()
[16:21:06.857]                 names <- names(envs)
[16:21:06.857]                 common <- intersect(names, old_names)
[16:21:06.857]                 added <- setdiff(names, old_names)
[16:21:06.857]                 removed <- setdiff(old_names, names)
[16:21:06.857]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.857]                   envs[common]]
[16:21:06.857]                 NAMES <- toupper(changed)
[16:21:06.857]                 args <- list()
[16:21:06.857]                 for (kk in seq_along(NAMES)) {
[16:21:06.857]                   name <- changed[[kk]]
[16:21:06.857]                   NAME <- NAMES[[kk]]
[16:21:06.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.857]                     next
[16:21:06.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.857]                 }
[16:21:06.857]                 NAMES <- toupper(added)
[16:21:06.857]                 for (kk in seq_along(NAMES)) {
[16:21:06.857]                   name <- added[[kk]]
[16:21:06.857]                   NAME <- NAMES[[kk]]
[16:21:06.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.857]                     next
[16:21:06.857]                   args[[name]] <- ""
[16:21:06.857]                 }
[16:21:06.857]                 NAMES <- toupper(removed)
[16:21:06.857]                 for (kk in seq_along(NAMES)) {
[16:21:06.857]                   name <- removed[[kk]]
[16:21:06.857]                   NAME <- NAMES[[kk]]
[16:21:06.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.857]                     next
[16:21:06.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.857]                 }
[16:21:06.857]                 if (length(args) > 0) 
[16:21:06.857]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.857]             }
[16:21:06.857]             else {
[16:21:06.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.857]             }
[16:21:06.857]             {
[16:21:06.857]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.857]                   0L) {
[16:21:06.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.857]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.857]                   base::options(opts)
[16:21:06.857]                 }
[16:21:06.857]                 {
[16:21:06.857]                   {
[16:21:06.857]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.857]                     NULL
[16:21:06.857]                   }
[16:21:06.857]                   options(future.plan = NULL)
[16:21:06.857]                   if (is.na(NA_character_)) 
[16:21:06.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.857]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.857]                     .init = FALSE)
[16:21:06.857]                 }
[16:21:06.857]             }
[16:21:06.857]         }
[16:21:06.857]     })
[16:21:06.857]     if (TRUE) {
[16:21:06.857]         base::sink(type = "output", split = FALSE)
[16:21:06.857]         if (TRUE) {
[16:21:06.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.857]         }
[16:21:06.857]         else {
[16:21:06.857]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.857]         }
[16:21:06.857]         base::close(...future.stdout)
[16:21:06.857]         ...future.stdout <- NULL
[16:21:06.857]     }
[16:21:06.857]     ...future.result$conditions <- ...future.conditions
[16:21:06.857]     ...future.result$finished <- base::Sys.time()
[16:21:06.857]     ...future.result
[16:21:06.857] }
[16:21:06.859] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[16:21:06.860] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[16:21:06.913] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[16:21:06.913] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[16:21:06.913] MultisessionFuture started
[16:21:06.913] - Launch lazy future ... done
[16:21:06.914] run() for ‘MultisessionFuture’ ... done
[16:21:06.914] result() for ClusterFuture ...
[16:21:06.914] receiveMessageFromWorker() for ClusterFuture ...
[16:21:06.914] - Validating connection of MultisessionFuture
[16:21:06.958] - received message: FutureResult
[16:21:06.959] - Received FutureResult
[16:21:06.959] - Erased future from FutureRegistry
[16:21:06.959] result() for ClusterFuture ...
[16:21:06.959] - result already collected: FutureResult
[16:21:06.959] result() for ClusterFuture ... done
[16:21:06.959] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:06.959] result() for ClusterFuture ... done
[16:21:06.959] result() for ClusterFuture ...
[16:21:06.959] - result already collected: FutureResult
[16:21:06.959] result() for ClusterFuture ... done
value(b) = 2
[16:21:06.960] result() for ClusterFuture ...
[16:21:06.960] - result already collected: FutureResult
[16:21:06.960] result() for ClusterFuture ... done
[16:21:06.960] result() for ClusterFuture ...
[16:21:06.960] - result already collected: FutureResult
[16:21:06.960] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.960] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.961] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:21:06.962] - globals found: [2] ‘{’, ‘pkg’
[16:21:06.962] Searching for globals ... DONE
[16:21:06.962] Resolving globals: TRUE
[16:21:06.962] Resolving any globals that are futures ...
[16:21:06.962] - globals: [2] ‘{’, ‘pkg’
[16:21:06.962] Resolving any globals that are futures ... DONE
[16:21:06.962] Resolving futures part of globals (recursively) ...
[16:21:06.963] resolve() on list ...
[16:21:06.963]  recursive: 99
[16:21:06.963]  length: 1
[16:21:06.963]  elements: ‘pkg’
[16:21:06.963]  length: 0 (resolved future 1)
[16:21:06.963] resolve() on list ... DONE
[16:21:06.963] - globals: [1] ‘pkg’
[16:21:06.963] Resolving futures part of globals (recursively) ... DONE
[16:21:06.963] The total size of the 1 globals is 112 bytes (112 bytes)
[16:21:06.964] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:21:06.964] - globals: [1] ‘pkg’
[16:21:06.964] 
[16:21:06.964] getGlobalsAndPackages() ... DONE
[16:21:06.964] Packages needed by the future expression (n = 0): <none>
[16:21:06.965] Packages needed by future strategies (n = 0): <none>
[16:21:06.965] {
[16:21:06.965]     {
[16:21:06.965]         {
[16:21:06.965]             ...future.startTime <- base::Sys.time()
[16:21:06.965]             {
[16:21:06.965]                 {
[16:21:06.965]                   {
[16:21:06.965]                     base::local({
[16:21:06.965]                       has_future <- base::requireNamespace("future", 
[16:21:06.965]                         quietly = TRUE)
[16:21:06.965]                       if (has_future) {
[16:21:06.965]                         ns <- base::getNamespace("future")
[16:21:06.965]                         version <- ns[[".package"]][["version"]]
[16:21:06.965]                         if (is.null(version)) 
[16:21:06.965]                           version <- utils::packageVersion("future")
[16:21:06.965]                       }
[16:21:06.965]                       else {
[16:21:06.965]                         version <- NULL
[16:21:06.965]                       }
[16:21:06.965]                       if (!has_future || version < "1.8.0") {
[16:21:06.965]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.965]                           "", base::R.version$version.string), 
[16:21:06.965]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:06.965]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:06.965]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.965]                             "release", "version")], collapse = " "), 
[16:21:06.965]                           hostname = base::Sys.info()[["nodename"]])
[16:21:06.965]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.965]                           info)
[16:21:06.965]                         info <- base::paste(info, collapse = "; ")
[16:21:06.965]                         if (!has_future) {
[16:21:06.965]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.965]                             info)
[16:21:06.965]                         }
[16:21:06.965]                         else {
[16:21:06.965]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.965]                             info, version)
[16:21:06.965]                         }
[16:21:06.965]                         base::stop(msg)
[16:21:06.965]                       }
[16:21:06.965]                     })
[16:21:06.965]                   }
[16:21:06.965]                   ...future.strategy.old <- future::plan("list")
[16:21:06.965]                   options(future.plan = NULL)
[16:21:06.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.965]                 }
[16:21:06.965]                 ...future.workdir <- getwd()
[16:21:06.965]             }
[16:21:06.965]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.965]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.965]         }
[16:21:06.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.965]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:21:06.965]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.965]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.965]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.965]             base::names(...future.oldOptions))
[16:21:06.965]     }
[16:21:06.965]     if (FALSE) {
[16:21:06.965]     }
[16:21:06.965]     else {
[16:21:06.965]         if (TRUE) {
[16:21:06.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.965]                 open = "w")
[16:21:06.965]         }
[16:21:06.965]         else {
[16:21:06.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.965]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.965]         }
[16:21:06.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.965]             base::sink(type = "output", split = FALSE)
[16:21:06.965]             base::close(...future.stdout)
[16:21:06.965]         }, add = TRUE)
[16:21:06.965]     }
[16:21:06.965]     ...future.frame <- base::sys.nframe()
[16:21:06.965]     ...future.conditions <- base::list()
[16:21:06.965]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.965]     if (FALSE) {
[16:21:06.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.965]     }
[16:21:06.965]     ...future.result <- base::tryCatch({
[16:21:06.965]         base::withCallingHandlers({
[16:21:06.965]             ...future.value <- base::withVisible(base::local({
[16:21:06.965]                 pkg
[16:21:06.965]             }))
[16:21:06.965]             future::FutureResult(value = ...future.value$value, 
[16:21:06.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.965]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.965]                     ...future.globalenv.names))
[16:21:06.965]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.965]         }, condition = base::local({
[16:21:06.965]             c <- base::c
[16:21:06.965]             inherits <- base::inherits
[16:21:06.965]             invokeRestart <- base::invokeRestart
[16:21:06.965]             length <- base::length
[16:21:06.965]             list <- base::list
[16:21:06.965]             seq.int <- base::seq.int
[16:21:06.965]             signalCondition <- base::signalCondition
[16:21:06.965]             sys.calls <- base::sys.calls
[16:21:06.965]             `[[` <- base::`[[`
[16:21:06.965]             `+` <- base::`+`
[16:21:06.965]             `<<-` <- base::`<<-`
[16:21:06.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.965]                   3L)]
[16:21:06.965]             }
[16:21:06.965]             function(cond) {
[16:21:06.965]                 is_error <- inherits(cond, "error")
[16:21:06.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.965]                   NULL)
[16:21:06.965]                 if (is_error) {
[16:21:06.965]                   sessionInformation <- function() {
[16:21:06.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.965]                       search = base::search(), system = base::Sys.info())
[16:21:06.965]                   }
[16:21:06.965]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.965]                     cond$call), session = sessionInformation(), 
[16:21:06.965]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.965]                   signalCondition(cond)
[16:21:06.965]                 }
[16:21:06.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.965]                 "immediateCondition"))) {
[16:21:06.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.965]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.965]                   if (TRUE && !signal) {
[16:21:06.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.965]                     {
[16:21:06.965]                       inherits <- base::inherits
[16:21:06.965]                       invokeRestart <- base::invokeRestart
[16:21:06.965]                       is.null <- base::is.null
[16:21:06.965]                       muffled <- FALSE
[16:21:06.965]                       if (inherits(cond, "message")) {
[16:21:06.965]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.965]                         if (muffled) 
[16:21:06.965]                           invokeRestart("muffleMessage")
[16:21:06.965]                       }
[16:21:06.965]                       else if (inherits(cond, "warning")) {
[16:21:06.965]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.965]                         if (muffled) 
[16:21:06.965]                           invokeRestart("muffleWarning")
[16:21:06.965]                       }
[16:21:06.965]                       else if (inherits(cond, "condition")) {
[16:21:06.965]                         if (!is.null(pattern)) {
[16:21:06.965]                           computeRestarts <- base::computeRestarts
[16:21:06.965]                           grepl <- base::grepl
[16:21:06.965]                           restarts <- computeRestarts(cond)
[16:21:06.965]                           for (restart in restarts) {
[16:21:06.965]                             name <- restart$name
[16:21:06.965]                             if (is.null(name)) 
[16:21:06.965]                               next
[16:21:06.965]                             if (!grepl(pattern, name)) 
[16:21:06.965]                               next
[16:21:06.965]                             invokeRestart(restart)
[16:21:06.965]                             muffled <- TRUE
[16:21:06.965]                             break
[16:21:06.965]                           }
[16:21:06.965]                         }
[16:21:06.965]                       }
[16:21:06.965]                       invisible(muffled)
[16:21:06.965]                     }
[16:21:06.965]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.965]                   }
[16:21:06.965]                 }
[16:21:06.965]                 else {
[16:21:06.965]                   if (TRUE) {
[16:21:06.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.965]                     {
[16:21:06.965]                       inherits <- base::inherits
[16:21:06.965]                       invokeRestart <- base::invokeRestart
[16:21:06.965]                       is.null <- base::is.null
[16:21:06.965]                       muffled <- FALSE
[16:21:06.965]                       if (inherits(cond, "message")) {
[16:21:06.965]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.965]                         if (muffled) 
[16:21:06.965]                           invokeRestart("muffleMessage")
[16:21:06.965]                       }
[16:21:06.965]                       else if (inherits(cond, "warning")) {
[16:21:06.965]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.965]                         if (muffled) 
[16:21:06.965]                           invokeRestart("muffleWarning")
[16:21:06.965]                       }
[16:21:06.965]                       else if (inherits(cond, "condition")) {
[16:21:06.965]                         if (!is.null(pattern)) {
[16:21:06.965]                           computeRestarts <- base::computeRestarts
[16:21:06.965]                           grepl <- base::grepl
[16:21:06.965]                           restarts <- computeRestarts(cond)
[16:21:06.965]                           for (restart in restarts) {
[16:21:06.965]                             name <- restart$name
[16:21:06.965]                             if (is.null(name)) 
[16:21:06.965]                               next
[16:21:06.965]                             if (!grepl(pattern, name)) 
[16:21:06.965]                               next
[16:21:06.965]                             invokeRestart(restart)
[16:21:06.965]                             muffled <- TRUE
[16:21:06.965]                             break
[16:21:06.965]                           }
[16:21:06.965]                         }
[16:21:06.965]                       }
[16:21:06.965]                       invisible(muffled)
[16:21:06.965]                     }
[16:21:06.965]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.965]                   }
[16:21:06.965]                 }
[16:21:06.965]             }
[16:21:06.965]         }))
[16:21:06.965]     }, error = function(ex) {
[16:21:06.965]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.965]                 ...future.rng), started = ...future.startTime, 
[16:21:06.965]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.965]             version = "1.8"), class = "FutureResult")
[16:21:06.965]     }, finally = {
[16:21:06.965]         if (!identical(...future.workdir, getwd())) 
[16:21:06.965]             setwd(...future.workdir)
[16:21:06.965]         {
[16:21:06.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.965]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.965]             }
[16:21:06.965]             base::options(...future.oldOptions)
[16:21:06.965]             if (.Platform$OS.type == "windows") {
[16:21:06.965]                 old_names <- names(...future.oldEnvVars)
[16:21:06.965]                 envs <- base::Sys.getenv()
[16:21:06.965]                 names <- names(envs)
[16:21:06.965]                 common <- intersect(names, old_names)
[16:21:06.965]                 added <- setdiff(names, old_names)
[16:21:06.965]                 removed <- setdiff(old_names, names)
[16:21:06.965]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.965]                   envs[common]]
[16:21:06.965]                 NAMES <- toupper(changed)
[16:21:06.965]                 args <- list()
[16:21:06.965]                 for (kk in seq_along(NAMES)) {
[16:21:06.965]                   name <- changed[[kk]]
[16:21:06.965]                   NAME <- NAMES[[kk]]
[16:21:06.965]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.965]                     next
[16:21:06.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.965]                 }
[16:21:06.965]                 NAMES <- toupper(added)
[16:21:06.965]                 for (kk in seq_along(NAMES)) {
[16:21:06.965]                   name <- added[[kk]]
[16:21:06.965]                   NAME <- NAMES[[kk]]
[16:21:06.965]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.965]                     next
[16:21:06.965]                   args[[name]] <- ""
[16:21:06.965]                 }
[16:21:06.965]                 NAMES <- toupper(removed)
[16:21:06.965]                 for (kk in seq_along(NAMES)) {
[16:21:06.965]                   name <- removed[[kk]]
[16:21:06.965]                   NAME <- NAMES[[kk]]
[16:21:06.965]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.965]                     next
[16:21:06.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.965]                 }
[16:21:06.965]                 if (length(args) > 0) 
[16:21:06.965]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.965]             }
[16:21:06.965]             else {
[16:21:06.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.965]             }
[16:21:06.965]             {
[16:21:06.965]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.965]                   0L) {
[16:21:06.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.965]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.965]                   base::options(opts)
[16:21:06.965]                 }
[16:21:06.965]                 {
[16:21:06.965]                   {
[16:21:06.965]                     NULL
[16:21:06.965]                     RNGkind("Mersenne-Twister")
[16:21:06.965]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:06.965]                       inherits = FALSE)
[16:21:06.965]                   }
[16:21:06.965]                   options(future.plan = NULL)
[16:21:06.965]                   if (is.na(NA_character_)) 
[16:21:06.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.965]                     .init = FALSE)
[16:21:06.965]                 }
[16:21:06.965]             }
[16:21:06.965]         }
[16:21:06.965]     })
[16:21:06.965]     if (TRUE) {
[16:21:06.965]         base::sink(type = "output", split = FALSE)
[16:21:06.965]         if (TRUE) {
[16:21:06.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.965]         }
[16:21:06.965]         else {
[16:21:06.965]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.965]         }
[16:21:06.965]         base::close(...future.stdout)
[16:21:06.965]         ...future.stdout <- NULL
[16:21:06.965]     }
[16:21:06.965]     ...future.result$conditions <- ...future.conditions
[16:21:06.965]     ...future.result$finished <- base::Sys.time()
[16:21:06.965]     ...future.result
[16:21:06.965] }
[16:21:06.967] assign_globals() ...
[16:21:06.967] List of 1
[16:21:06.967]  $ pkg: chr "foo"
[16:21:06.967]  - attr(*, "where")=List of 1
[16:21:06.967]   ..$ pkg:<environment: R_EmptyEnv> 
[16:21:06.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:06.967]  - attr(*, "resolved")= logi TRUE
[16:21:06.967]  - attr(*, "total_size")= num 112
[16:21:06.969] - copied ‘pkg’ to environment
[16:21:06.969] assign_globals() ... done
[16:21:06.969] plan(): Setting new future strategy stack:
[16:21:06.969] List of future strategies:
[16:21:06.969] 1. sequential:
[16:21:06.969]    - args: function (..., envir = parent.frame())
[16:21:06.969]    - tweaked: FALSE
[16:21:06.969]    - call: NULL
[16:21:06.970] plan(): nbrOfWorkers() = 1
[16:21:06.970] plan(): Setting new future strategy stack:
[16:21:06.971] List of future strategies:
[16:21:06.971] 1. multisession:
[16:21:06.971]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:06.971]    - tweaked: FALSE
[16:21:06.971]    - call: plan(strategy)
[16:21:06.974] plan(): nbrOfWorkers() = 2
[16:21:06.974] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:06.975] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:06.975] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:06.977] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:06.977] Searching for globals ... DONE
[16:21:06.977] Resolving globals: TRUE
[16:21:06.977] Resolving any globals that are futures ...
[16:21:06.978] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:06.978] Resolving any globals that are futures ... DONE
[16:21:06.978] Resolving futures part of globals (recursively) ...
[16:21:06.978] resolve() on list ...
[16:21:06.978]  recursive: 99
[16:21:06.978]  length: 1
[16:21:06.978]  elements: ‘a’
[16:21:06.979]  length: 0 (resolved future 1)
[16:21:06.979] resolve() on list ... DONE
[16:21:06.979] - globals: [1] ‘a’
[16:21:06.979] Resolving futures part of globals (recursively) ... DONE
[16:21:06.979] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:06.979] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:21:06.979] - globals: [1] ‘a’
[16:21:06.980] 
[16:21:06.980] getGlobalsAndPackages() ... DONE
[16:21:06.980] run() for ‘Future’ ...
[16:21:06.980] - state: ‘created’
[16:21:06.980] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:06.994] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:06.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:06.994]   - Field: ‘node’
[16:21:06.994]   - Field: ‘label’
[16:21:06.994]   - Field: ‘local’
[16:21:06.994]   - Field: ‘owner’
[16:21:06.994]   - Field: ‘envir’
[16:21:06.994]   - Field: ‘workers’
[16:21:06.995]   - Field: ‘packages’
[16:21:06.995]   - Field: ‘gc’
[16:21:06.995]   - Field: ‘conditions’
[16:21:06.995]   - Field: ‘persistent’
[16:21:06.995]   - Field: ‘expr’
[16:21:06.995]   - Field: ‘uuid’
[16:21:06.995]   - Field: ‘seed’
[16:21:06.995]   - Field: ‘version’
[16:21:06.995]   - Field: ‘result’
[16:21:06.995]   - Field: ‘asynchronous’
[16:21:06.995]   - Field: ‘calls’
[16:21:06.996]   - Field: ‘globals’
[16:21:06.996]   - Field: ‘stdout’
[16:21:06.996]   - Field: ‘earlySignal’
[16:21:06.996]   - Field: ‘lazy’
[16:21:06.996]   - Field: ‘state’
[16:21:06.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:06.996] - Launch lazy future ...
[16:21:06.996] Packages needed by the future expression (n = 0): <none>
[16:21:06.997] Packages needed by future strategies (n = 0): <none>
[16:21:06.997] {
[16:21:06.997]     {
[16:21:06.997]         {
[16:21:06.997]             ...future.startTime <- base::Sys.time()
[16:21:06.997]             {
[16:21:06.997]                 {
[16:21:06.997]                   {
[16:21:06.997]                     {
[16:21:06.997]                       base::local({
[16:21:06.997]                         has_future <- base::requireNamespace("future", 
[16:21:06.997]                           quietly = TRUE)
[16:21:06.997]                         if (has_future) {
[16:21:06.997]                           ns <- base::getNamespace("future")
[16:21:06.997]                           version <- ns[[".package"]][["version"]]
[16:21:06.997]                           if (is.null(version)) 
[16:21:06.997]                             version <- utils::packageVersion("future")
[16:21:06.997]                         }
[16:21:06.997]                         else {
[16:21:06.997]                           version <- NULL
[16:21:06.997]                         }
[16:21:06.997]                         if (!has_future || version < "1.8.0") {
[16:21:06.997]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:06.997]                             "", base::R.version$version.string), 
[16:21:06.997]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:06.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:06.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:06.997]                               "release", "version")], collapse = " "), 
[16:21:06.997]                             hostname = base::Sys.info()[["nodename"]])
[16:21:06.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:06.997]                             info)
[16:21:06.997]                           info <- base::paste(info, collapse = "; ")
[16:21:06.997]                           if (!has_future) {
[16:21:06.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:06.997]                               info)
[16:21:06.997]                           }
[16:21:06.997]                           else {
[16:21:06.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:06.997]                               info, version)
[16:21:06.997]                           }
[16:21:06.997]                           base::stop(msg)
[16:21:06.997]                         }
[16:21:06.997]                       })
[16:21:06.997]                     }
[16:21:06.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:06.997]                     base::options(mc.cores = 1L)
[16:21:06.997]                   }
[16:21:06.997]                   ...future.strategy.old <- future::plan("list")
[16:21:06.997]                   options(future.plan = NULL)
[16:21:06.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:06.997]                 }
[16:21:06.997]                 ...future.workdir <- getwd()
[16:21:06.997]             }
[16:21:06.997]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:06.997]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:06.997]         }
[16:21:06.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:06.997]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:06.997]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:06.997]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:06.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:06.997]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:06.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:06.997]             base::names(...future.oldOptions))
[16:21:06.997]     }
[16:21:06.997]     if (FALSE) {
[16:21:06.997]     }
[16:21:06.997]     else {
[16:21:06.997]         if (TRUE) {
[16:21:06.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:06.997]                 open = "w")
[16:21:06.997]         }
[16:21:06.997]         else {
[16:21:06.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:06.997]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:06.997]         }
[16:21:06.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:06.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:06.997]             base::sink(type = "output", split = FALSE)
[16:21:06.997]             base::close(...future.stdout)
[16:21:06.997]         }, add = TRUE)
[16:21:06.997]     }
[16:21:06.997]     ...future.frame <- base::sys.nframe()
[16:21:06.997]     ...future.conditions <- base::list()
[16:21:06.997]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:06.997]     if (FALSE) {
[16:21:06.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:06.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:06.997]     }
[16:21:06.997]     ...future.result <- base::tryCatch({
[16:21:06.997]         base::withCallingHandlers({
[16:21:06.997]             ...future.value <- base::withVisible(base::local({
[16:21:06.997]                 ...future.makeSendCondition <- base::local({
[16:21:06.997]                   sendCondition <- NULL
[16:21:06.997]                   function(frame = 1L) {
[16:21:06.997]                     if (is.function(sendCondition)) 
[16:21:06.997]                       return(sendCondition)
[16:21:06.997]                     ns <- getNamespace("parallel")
[16:21:06.997]                     if (exists("sendData", mode = "function", 
[16:21:06.997]                       envir = ns)) {
[16:21:06.997]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:06.997]                         envir = ns)
[16:21:06.997]                       envir <- sys.frame(frame)
[16:21:06.997]                       master <- NULL
[16:21:06.997]                       while (!identical(envir, .GlobalEnv) && 
[16:21:06.997]                         !identical(envir, emptyenv())) {
[16:21:06.997]                         if (exists("master", mode = "list", envir = envir, 
[16:21:06.997]                           inherits = FALSE)) {
[16:21:06.997]                           master <- get("master", mode = "list", 
[16:21:06.997]                             envir = envir, inherits = FALSE)
[16:21:06.997]                           if (inherits(master, c("SOCKnode", 
[16:21:06.997]                             "SOCK0node"))) {
[16:21:06.997]                             sendCondition <<- function(cond) {
[16:21:06.997]                               data <- list(type = "VALUE", value = cond, 
[16:21:06.997]                                 success = TRUE)
[16:21:06.997]                               parallel_sendData(master, data)
[16:21:06.997]                             }
[16:21:06.997]                             return(sendCondition)
[16:21:06.997]                           }
[16:21:06.997]                         }
[16:21:06.997]                         frame <- frame + 1L
[16:21:06.997]                         envir <- sys.frame(frame)
[16:21:06.997]                       }
[16:21:06.997]                     }
[16:21:06.997]                     sendCondition <<- function(cond) NULL
[16:21:06.997]                   }
[16:21:06.997]                 })
[16:21:06.997]                 withCallingHandlers({
[16:21:06.997]                   {
[16:21:06.997]                     b <- a
[16:21:06.997]                     a <- 2
[16:21:06.997]                     a * b
[16:21:06.997]                   }
[16:21:06.997]                 }, immediateCondition = function(cond) {
[16:21:06.997]                   sendCondition <- ...future.makeSendCondition()
[16:21:06.997]                   sendCondition(cond)
[16:21:06.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.997]                   {
[16:21:06.997]                     inherits <- base::inherits
[16:21:06.997]                     invokeRestart <- base::invokeRestart
[16:21:06.997]                     is.null <- base::is.null
[16:21:06.997]                     muffled <- FALSE
[16:21:06.997]                     if (inherits(cond, "message")) {
[16:21:06.997]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:06.997]                       if (muffled) 
[16:21:06.997]                         invokeRestart("muffleMessage")
[16:21:06.997]                     }
[16:21:06.997]                     else if (inherits(cond, "warning")) {
[16:21:06.997]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:06.997]                       if (muffled) 
[16:21:06.997]                         invokeRestart("muffleWarning")
[16:21:06.997]                     }
[16:21:06.997]                     else if (inherits(cond, "condition")) {
[16:21:06.997]                       if (!is.null(pattern)) {
[16:21:06.997]                         computeRestarts <- base::computeRestarts
[16:21:06.997]                         grepl <- base::grepl
[16:21:06.997]                         restarts <- computeRestarts(cond)
[16:21:06.997]                         for (restart in restarts) {
[16:21:06.997]                           name <- restart$name
[16:21:06.997]                           if (is.null(name)) 
[16:21:06.997]                             next
[16:21:06.997]                           if (!grepl(pattern, name)) 
[16:21:06.997]                             next
[16:21:06.997]                           invokeRestart(restart)
[16:21:06.997]                           muffled <- TRUE
[16:21:06.997]                           break
[16:21:06.997]                         }
[16:21:06.997]                       }
[16:21:06.997]                     }
[16:21:06.997]                     invisible(muffled)
[16:21:06.997]                   }
[16:21:06.997]                   muffleCondition(cond)
[16:21:06.997]                 })
[16:21:06.997]             }))
[16:21:06.997]             future::FutureResult(value = ...future.value$value, 
[16:21:06.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.997]                   ...future.rng), globalenv = if (FALSE) 
[16:21:06.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:06.997]                     ...future.globalenv.names))
[16:21:06.997]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:06.997]         }, condition = base::local({
[16:21:06.997]             c <- base::c
[16:21:06.997]             inherits <- base::inherits
[16:21:06.997]             invokeRestart <- base::invokeRestart
[16:21:06.997]             length <- base::length
[16:21:06.997]             list <- base::list
[16:21:06.997]             seq.int <- base::seq.int
[16:21:06.997]             signalCondition <- base::signalCondition
[16:21:06.997]             sys.calls <- base::sys.calls
[16:21:06.997]             `[[` <- base::`[[`
[16:21:06.997]             `+` <- base::`+`
[16:21:06.997]             `<<-` <- base::`<<-`
[16:21:06.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:06.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:06.997]                   3L)]
[16:21:06.997]             }
[16:21:06.997]             function(cond) {
[16:21:06.997]                 is_error <- inherits(cond, "error")
[16:21:06.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:06.997]                   NULL)
[16:21:06.997]                 if (is_error) {
[16:21:06.997]                   sessionInformation <- function() {
[16:21:06.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:06.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:06.997]                       search = base::search(), system = base::Sys.info())
[16:21:06.997]                   }
[16:21:06.997]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:06.997]                     cond$call), session = sessionInformation(), 
[16:21:06.997]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:06.997]                   signalCondition(cond)
[16:21:06.997]                 }
[16:21:06.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:06.997]                 "immediateCondition"))) {
[16:21:06.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:06.997]                   ...future.conditions[[length(...future.conditions) + 
[16:21:06.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:06.997]                   if (TRUE && !signal) {
[16:21:06.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.997]                     {
[16:21:06.997]                       inherits <- base::inherits
[16:21:06.997]                       invokeRestart <- base::invokeRestart
[16:21:06.997]                       is.null <- base::is.null
[16:21:06.997]                       muffled <- FALSE
[16:21:06.997]                       if (inherits(cond, "message")) {
[16:21:06.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.997]                         if (muffled) 
[16:21:06.997]                           invokeRestart("muffleMessage")
[16:21:06.997]                       }
[16:21:06.997]                       else if (inherits(cond, "warning")) {
[16:21:06.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.997]                         if (muffled) 
[16:21:06.997]                           invokeRestart("muffleWarning")
[16:21:06.997]                       }
[16:21:06.997]                       else if (inherits(cond, "condition")) {
[16:21:06.997]                         if (!is.null(pattern)) {
[16:21:06.997]                           computeRestarts <- base::computeRestarts
[16:21:06.997]                           grepl <- base::grepl
[16:21:06.997]                           restarts <- computeRestarts(cond)
[16:21:06.997]                           for (restart in restarts) {
[16:21:06.997]                             name <- restart$name
[16:21:06.997]                             if (is.null(name)) 
[16:21:06.997]                               next
[16:21:06.997]                             if (!grepl(pattern, name)) 
[16:21:06.997]                               next
[16:21:06.997]                             invokeRestart(restart)
[16:21:06.997]                             muffled <- TRUE
[16:21:06.997]                             break
[16:21:06.997]                           }
[16:21:06.997]                         }
[16:21:06.997]                       }
[16:21:06.997]                       invisible(muffled)
[16:21:06.997]                     }
[16:21:06.997]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.997]                   }
[16:21:06.997]                 }
[16:21:06.997]                 else {
[16:21:06.997]                   if (TRUE) {
[16:21:06.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:06.997]                     {
[16:21:06.997]                       inherits <- base::inherits
[16:21:06.997]                       invokeRestart <- base::invokeRestart
[16:21:06.997]                       is.null <- base::is.null
[16:21:06.997]                       muffled <- FALSE
[16:21:06.997]                       if (inherits(cond, "message")) {
[16:21:06.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:06.997]                         if (muffled) 
[16:21:06.997]                           invokeRestart("muffleMessage")
[16:21:06.997]                       }
[16:21:06.997]                       else if (inherits(cond, "warning")) {
[16:21:06.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:06.997]                         if (muffled) 
[16:21:06.997]                           invokeRestart("muffleWarning")
[16:21:06.997]                       }
[16:21:06.997]                       else if (inherits(cond, "condition")) {
[16:21:06.997]                         if (!is.null(pattern)) {
[16:21:06.997]                           computeRestarts <- base::computeRestarts
[16:21:06.997]                           grepl <- base::grepl
[16:21:06.997]                           restarts <- computeRestarts(cond)
[16:21:06.997]                           for (restart in restarts) {
[16:21:06.997]                             name <- restart$name
[16:21:06.997]                             if (is.null(name)) 
[16:21:06.997]                               next
[16:21:06.997]                             if (!grepl(pattern, name)) 
[16:21:06.997]                               next
[16:21:06.997]                             invokeRestart(restart)
[16:21:06.997]                             muffled <- TRUE
[16:21:06.997]                             break
[16:21:06.997]                           }
[16:21:06.997]                         }
[16:21:06.997]                       }
[16:21:06.997]                       invisible(muffled)
[16:21:06.997]                     }
[16:21:06.997]                     muffleCondition(cond, pattern = "^muffle")
[16:21:06.997]                   }
[16:21:06.997]                 }
[16:21:06.997]             }
[16:21:06.997]         }))
[16:21:06.997]     }, error = function(ex) {
[16:21:06.997]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:06.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:06.997]                 ...future.rng), started = ...future.startTime, 
[16:21:06.997]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:06.997]             version = "1.8"), class = "FutureResult")
[16:21:06.997]     }, finally = {
[16:21:06.997]         if (!identical(...future.workdir, getwd())) 
[16:21:06.997]             setwd(...future.workdir)
[16:21:06.997]         {
[16:21:06.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:06.997]                 ...future.oldOptions$nwarnings <- NULL
[16:21:06.997]             }
[16:21:06.997]             base::options(...future.oldOptions)
[16:21:06.997]             if (.Platform$OS.type == "windows") {
[16:21:06.997]                 old_names <- names(...future.oldEnvVars)
[16:21:06.997]                 envs <- base::Sys.getenv()
[16:21:06.997]                 names <- names(envs)
[16:21:06.997]                 common <- intersect(names, old_names)
[16:21:06.997]                 added <- setdiff(names, old_names)
[16:21:06.997]                 removed <- setdiff(old_names, names)
[16:21:06.997]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:06.997]                   envs[common]]
[16:21:06.997]                 NAMES <- toupper(changed)
[16:21:06.997]                 args <- list()
[16:21:06.997]                 for (kk in seq_along(NAMES)) {
[16:21:06.997]                   name <- changed[[kk]]
[16:21:06.997]                   NAME <- NAMES[[kk]]
[16:21:06.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.997]                     next
[16:21:06.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.997]                 }
[16:21:06.997]                 NAMES <- toupper(added)
[16:21:06.997]                 for (kk in seq_along(NAMES)) {
[16:21:06.997]                   name <- added[[kk]]
[16:21:06.997]                   NAME <- NAMES[[kk]]
[16:21:06.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.997]                     next
[16:21:06.997]                   args[[name]] <- ""
[16:21:06.997]                 }
[16:21:06.997]                 NAMES <- toupper(removed)
[16:21:06.997]                 for (kk in seq_along(NAMES)) {
[16:21:06.997]                   name <- removed[[kk]]
[16:21:06.997]                   NAME <- NAMES[[kk]]
[16:21:06.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:06.997]                     next
[16:21:06.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:06.997]                 }
[16:21:06.997]                 if (length(args) > 0) 
[16:21:06.997]                   base::do.call(base::Sys.setenv, args = args)
[16:21:06.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:06.997]             }
[16:21:06.997]             else {
[16:21:06.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:06.997]             }
[16:21:06.997]             {
[16:21:06.997]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:06.997]                   0L) {
[16:21:06.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:06.997]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:06.997]                   base::options(opts)
[16:21:06.997]                 }
[16:21:06.997]                 {
[16:21:06.997]                   {
[16:21:06.997]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:06.997]                     NULL
[16:21:06.997]                   }
[16:21:06.997]                   options(future.plan = NULL)
[16:21:06.997]                   if (is.na(NA_character_)) 
[16:21:06.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:06.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:06.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:06.997]                     .init = FALSE)
[16:21:06.997]                 }
[16:21:06.997]             }
[16:21:06.997]         }
[16:21:06.997]     })
[16:21:06.997]     if (TRUE) {
[16:21:06.997]         base::sink(type = "output", split = FALSE)
[16:21:06.997]         if (TRUE) {
[16:21:06.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:06.997]         }
[16:21:06.997]         else {
[16:21:06.997]             ...future.result["stdout"] <- base::list(NULL)
[16:21:06.997]         }
[16:21:06.997]         base::close(...future.stdout)
[16:21:06.997]         ...future.stdout <- NULL
[16:21:06.997]     }
[16:21:06.997]     ...future.result$conditions <- ...future.conditions
[16:21:06.997]     ...future.result$finished <- base::Sys.time()
[16:21:06.997]     ...future.result
[16:21:06.997] }
[16:21:06.999] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:21:07.000] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:21:07.000] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:21:07.000] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:21:07.001] MultisessionFuture started
[16:21:07.001] - Launch lazy future ... done
[16:21:07.001] run() for ‘MultisessionFuture’ ... done
[16:21:07.001] result() for ClusterFuture ...
[16:21:07.001] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.001] - Validating connection of MultisessionFuture
[16:21:07.046] - received message: FutureResult
[16:21:07.046] - Received FutureResult
[16:21:07.046] - Erased future from FutureRegistry
[16:21:07.047] result() for ClusterFuture ...
[16:21:07.047] - result already collected: FutureResult
[16:21:07.047] result() for ClusterFuture ... done
[16:21:07.047] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.047] result() for ClusterFuture ... done
[16:21:07.047] result() for ClusterFuture ...
[16:21:07.047] - result already collected: FutureResult
[16:21:07.047] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.048] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.048] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.050] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:07.050] Searching for globals ... DONE
[16:21:07.050] Resolving globals: TRUE
[16:21:07.050] Resolving any globals that are futures ...
[16:21:07.050] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:21:07.050] Resolving any globals that are futures ... DONE
[16:21:07.051] Resolving futures part of globals (recursively) ...
[16:21:07.051] resolve() on list ...
[16:21:07.051]  recursive: 99
[16:21:07.051]  length: 1
[16:21:07.051]  elements: ‘a’
[16:21:07.051]  length: 0 (resolved future 1)
[16:21:07.051] resolve() on list ... DONE
[16:21:07.051] - globals: [1] ‘a’
[16:21:07.051] Resolving futures part of globals (recursively) ... DONE
[16:21:07.052] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:07.052] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:21:07.052] - globals: [1] ‘a’
[16:21:07.052] 
[16:21:07.052] getGlobalsAndPackages() ... DONE
[16:21:07.053] run() for ‘Future’ ...
[16:21:07.053] - state: ‘created’
[16:21:07.053] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.067] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.067]   - Field: ‘node’
[16:21:07.067]   - Field: ‘label’
[16:21:07.067]   - Field: ‘local’
[16:21:07.067]   - Field: ‘owner’
[16:21:07.067]   - Field: ‘envir’
[16:21:07.067]   - Field: ‘workers’
[16:21:07.067]   - Field: ‘packages’
[16:21:07.068]   - Field: ‘gc’
[16:21:07.068]   - Field: ‘conditions’
[16:21:07.068]   - Field: ‘persistent’
[16:21:07.068]   - Field: ‘expr’
[16:21:07.068]   - Field: ‘uuid’
[16:21:07.068]   - Field: ‘seed’
[16:21:07.068]   - Field: ‘version’
[16:21:07.068]   - Field: ‘result’
[16:21:07.068]   - Field: ‘asynchronous’
[16:21:07.068]   - Field: ‘calls’
[16:21:07.068]   - Field: ‘globals’
[16:21:07.069]   - Field: ‘stdout’
[16:21:07.069]   - Field: ‘earlySignal’
[16:21:07.069]   - Field: ‘lazy’
[16:21:07.069]   - Field: ‘state’
[16:21:07.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.069] - Launch lazy future ...
[16:21:07.069] Packages needed by the future expression (n = 0): <none>
[16:21:07.069] Packages needed by future strategies (n = 0): <none>
[16:21:07.070] {
[16:21:07.070]     {
[16:21:07.070]         {
[16:21:07.070]             ...future.startTime <- base::Sys.time()
[16:21:07.070]             {
[16:21:07.070]                 {
[16:21:07.070]                   {
[16:21:07.070]                     {
[16:21:07.070]                       base::local({
[16:21:07.070]                         has_future <- base::requireNamespace("future", 
[16:21:07.070]                           quietly = TRUE)
[16:21:07.070]                         if (has_future) {
[16:21:07.070]                           ns <- base::getNamespace("future")
[16:21:07.070]                           version <- ns[[".package"]][["version"]]
[16:21:07.070]                           if (is.null(version)) 
[16:21:07.070]                             version <- utils::packageVersion("future")
[16:21:07.070]                         }
[16:21:07.070]                         else {
[16:21:07.070]                           version <- NULL
[16:21:07.070]                         }
[16:21:07.070]                         if (!has_future || version < "1.8.0") {
[16:21:07.070]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.070]                             "", base::R.version$version.string), 
[16:21:07.070]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.070]                               "release", "version")], collapse = " "), 
[16:21:07.070]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.070]                             info)
[16:21:07.070]                           info <- base::paste(info, collapse = "; ")
[16:21:07.070]                           if (!has_future) {
[16:21:07.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.070]                               info)
[16:21:07.070]                           }
[16:21:07.070]                           else {
[16:21:07.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.070]                               info, version)
[16:21:07.070]                           }
[16:21:07.070]                           base::stop(msg)
[16:21:07.070]                         }
[16:21:07.070]                       })
[16:21:07.070]                     }
[16:21:07.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.070]                     base::options(mc.cores = 1L)
[16:21:07.070]                   }
[16:21:07.070]                   ...future.strategy.old <- future::plan("list")
[16:21:07.070]                   options(future.plan = NULL)
[16:21:07.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.070]                 }
[16:21:07.070]                 ...future.workdir <- getwd()
[16:21:07.070]             }
[16:21:07.070]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.070]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.070]         }
[16:21:07.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.070]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.070]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.070]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.070]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.070]             base::names(...future.oldOptions))
[16:21:07.070]     }
[16:21:07.070]     if (FALSE) {
[16:21:07.070]     }
[16:21:07.070]     else {
[16:21:07.070]         if (TRUE) {
[16:21:07.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.070]                 open = "w")
[16:21:07.070]         }
[16:21:07.070]         else {
[16:21:07.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.070]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.070]         }
[16:21:07.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.070]             base::sink(type = "output", split = FALSE)
[16:21:07.070]             base::close(...future.stdout)
[16:21:07.070]         }, add = TRUE)
[16:21:07.070]     }
[16:21:07.070]     ...future.frame <- base::sys.nframe()
[16:21:07.070]     ...future.conditions <- base::list()
[16:21:07.070]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.070]     if (FALSE) {
[16:21:07.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.070]     }
[16:21:07.070]     ...future.result <- base::tryCatch({
[16:21:07.070]         base::withCallingHandlers({
[16:21:07.070]             ...future.value <- base::withVisible(base::local({
[16:21:07.070]                 ...future.makeSendCondition <- base::local({
[16:21:07.070]                   sendCondition <- NULL
[16:21:07.070]                   function(frame = 1L) {
[16:21:07.070]                     if (is.function(sendCondition)) 
[16:21:07.070]                       return(sendCondition)
[16:21:07.070]                     ns <- getNamespace("parallel")
[16:21:07.070]                     if (exists("sendData", mode = "function", 
[16:21:07.070]                       envir = ns)) {
[16:21:07.070]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.070]                         envir = ns)
[16:21:07.070]                       envir <- sys.frame(frame)
[16:21:07.070]                       master <- NULL
[16:21:07.070]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.070]                         !identical(envir, emptyenv())) {
[16:21:07.070]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.070]                           inherits = FALSE)) {
[16:21:07.070]                           master <- get("master", mode = "list", 
[16:21:07.070]                             envir = envir, inherits = FALSE)
[16:21:07.070]                           if (inherits(master, c("SOCKnode", 
[16:21:07.070]                             "SOCK0node"))) {
[16:21:07.070]                             sendCondition <<- function(cond) {
[16:21:07.070]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.070]                                 success = TRUE)
[16:21:07.070]                               parallel_sendData(master, data)
[16:21:07.070]                             }
[16:21:07.070]                             return(sendCondition)
[16:21:07.070]                           }
[16:21:07.070]                         }
[16:21:07.070]                         frame <- frame + 1L
[16:21:07.070]                         envir <- sys.frame(frame)
[16:21:07.070]                       }
[16:21:07.070]                     }
[16:21:07.070]                     sendCondition <<- function(cond) NULL
[16:21:07.070]                   }
[16:21:07.070]                 })
[16:21:07.070]                 withCallingHandlers({
[16:21:07.070]                   {
[16:21:07.070]                     b <- a
[16:21:07.070]                     a <- 2
[16:21:07.070]                     a * b
[16:21:07.070]                   }
[16:21:07.070]                 }, immediateCondition = function(cond) {
[16:21:07.070]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.070]                   sendCondition(cond)
[16:21:07.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.070]                   {
[16:21:07.070]                     inherits <- base::inherits
[16:21:07.070]                     invokeRestart <- base::invokeRestart
[16:21:07.070]                     is.null <- base::is.null
[16:21:07.070]                     muffled <- FALSE
[16:21:07.070]                     if (inherits(cond, "message")) {
[16:21:07.070]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.070]                       if (muffled) 
[16:21:07.070]                         invokeRestart("muffleMessage")
[16:21:07.070]                     }
[16:21:07.070]                     else if (inherits(cond, "warning")) {
[16:21:07.070]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.070]                       if (muffled) 
[16:21:07.070]                         invokeRestart("muffleWarning")
[16:21:07.070]                     }
[16:21:07.070]                     else if (inherits(cond, "condition")) {
[16:21:07.070]                       if (!is.null(pattern)) {
[16:21:07.070]                         computeRestarts <- base::computeRestarts
[16:21:07.070]                         grepl <- base::grepl
[16:21:07.070]                         restarts <- computeRestarts(cond)
[16:21:07.070]                         for (restart in restarts) {
[16:21:07.070]                           name <- restart$name
[16:21:07.070]                           if (is.null(name)) 
[16:21:07.070]                             next
[16:21:07.070]                           if (!grepl(pattern, name)) 
[16:21:07.070]                             next
[16:21:07.070]                           invokeRestart(restart)
[16:21:07.070]                           muffled <- TRUE
[16:21:07.070]                           break
[16:21:07.070]                         }
[16:21:07.070]                       }
[16:21:07.070]                     }
[16:21:07.070]                     invisible(muffled)
[16:21:07.070]                   }
[16:21:07.070]                   muffleCondition(cond)
[16:21:07.070]                 })
[16:21:07.070]             }))
[16:21:07.070]             future::FutureResult(value = ...future.value$value, 
[16:21:07.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.070]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.070]                     ...future.globalenv.names))
[16:21:07.070]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.070]         }, condition = base::local({
[16:21:07.070]             c <- base::c
[16:21:07.070]             inherits <- base::inherits
[16:21:07.070]             invokeRestart <- base::invokeRestart
[16:21:07.070]             length <- base::length
[16:21:07.070]             list <- base::list
[16:21:07.070]             seq.int <- base::seq.int
[16:21:07.070]             signalCondition <- base::signalCondition
[16:21:07.070]             sys.calls <- base::sys.calls
[16:21:07.070]             `[[` <- base::`[[`
[16:21:07.070]             `+` <- base::`+`
[16:21:07.070]             `<<-` <- base::`<<-`
[16:21:07.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.070]                   3L)]
[16:21:07.070]             }
[16:21:07.070]             function(cond) {
[16:21:07.070]                 is_error <- inherits(cond, "error")
[16:21:07.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.070]                   NULL)
[16:21:07.070]                 if (is_error) {
[16:21:07.070]                   sessionInformation <- function() {
[16:21:07.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.070]                       search = base::search(), system = base::Sys.info())
[16:21:07.070]                   }
[16:21:07.070]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.070]                     cond$call), session = sessionInformation(), 
[16:21:07.070]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.070]                   signalCondition(cond)
[16:21:07.070]                 }
[16:21:07.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.070]                 "immediateCondition"))) {
[16:21:07.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.070]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.070]                   if (TRUE && !signal) {
[16:21:07.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.070]                     {
[16:21:07.070]                       inherits <- base::inherits
[16:21:07.070]                       invokeRestart <- base::invokeRestart
[16:21:07.070]                       is.null <- base::is.null
[16:21:07.070]                       muffled <- FALSE
[16:21:07.070]                       if (inherits(cond, "message")) {
[16:21:07.070]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.070]                         if (muffled) 
[16:21:07.070]                           invokeRestart("muffleMessage")
[16:21:07.070]                       }
[16:21:07.070]                       else if (inherits(cond, "warning")) {
[16:21:07.070]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.070]                         if (muffled) 
[16:21:07.070]                           invokeRestart("muffleWarning")
[16:21:07.070]                       }
[16:21:07.070]                       else if (inherits(cond, "condition")) {
[16:21:07.070]                         if (!is.null(pattern)) {
[16:21:07.070]                           computeRestarts <- base::computeRestarts
[16:21:07.070]                           grepl <- base::grepl
[16:21:07.070]                           restarts <- computeRestarts(cond)
[16:21:07.070]                           for (restart in restarts) {
[16:21:07.070]                             name <- restart$name
[16:21:07.070]                             if (is.null(name)) 
[16:21:07.070]                               next
[16:21:07.070]                             if (!grepl(pattern, name)) 
[16:21:07.070]                               next
[16:21:07.070]                             invokeRestart(restart)
[16:21:07.070]                             muffled <- TRUE
[16:21:07.070]                             break
[16:21:07.070]                           }
[16:21:07.070]                         }
[16:21:07.070]                       }
[16:21:07.070]                       invisible(muffled)
[16:21:07.070]                     }
[16:21:07.070]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.070]                   }
[16:21:07.070]                 }
[16:21:07.070]                 else {
[16:21:07.070]                   if (TRUE) {
[16:21:07.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.070]                     {
[16:21:07.070]                       inherits <- base::inherits
[16:21:07.070]                       invokeRestart <- base::invokeRestart
[16:21:07.070]                       is.null <- base::is.null
[16:21:07.070]                       muffled <- FALSE
[16:21:07.070]                       if (inherits(cond, "message")) {
[16:21:07.070]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.070]                         if (muffled) 
[16:21:07.070]                           invokeRestart("muffleMessage")
[16:21:07.070]                       }
[16:21:07.070]                       else if (inherits(cond, "warning")) {
[16:21:07.070]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.070]                         if (muffled) 
[16:21:07.070]                           invokeRestart("muffleWarning")
[16:21:07.070]                       }
[16:21:07.070]                       else if (inherits(cond, "condition")) {
[16:21:07.070]                         if (!is.null(pattern)) {
[16:21:07.070]                           computeRestarts <- base::computeRestarts
[16:21:07.070]                           grepl <- base::grepl
[16:21:07.070]                           restarts <- computeRestarts(cond)
[16:21:07.070]                           for (restart in restarts) {
[16:21:07.070]                             name <- restart$name
[16:21:07.070]                             if (is.null(name)) 
[16:21:07.070]                               next
[16:21:07.070]                             if (!grepl(pattern, name)) 
[16:21:07.070]                               next
[16:21:07.070]                             invokeRestart(restart)
[16:21:07.070]                             muffled <- TRUE
[16:21:07.070]                             break
[16:21:07.070]                           }
[16:21:07.070]                         }
[16:21:07.070]                       }
[16:21:07.070]                       invisible(muffled)
[16:21:07.070]                     }
[16:21:07.070]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.070]                   }
[16:21:07.070]                 }
[16:21:07.070]             }
[16:21:07.070]         }))
[16:21:07.070]     }, error = function(ex) {
[16:21:07.070]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.070]                 ...future.rng), started = ...future.startTime, 
[16:21:07.070]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.070]             version = "1.8"), class = "FutureResult")
[16:21:07.070]     }, finally = {
[16:21:07.070]         if (!identical(...future.workdir, getwd())) 
[16:21:07.070]             setwd(...future.workdir)
[16:21:07.070]         {
[16:21:07.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.070]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.070]             }
[16:21:07.070]             base::options(...future.oldOptions)
[16:21:07.070]             if (.Platform$OS.type == "windows") {
[16:21:07.070]                 old_names <- names(...future.oldEnvVars)
[16:21:07.070]                 envs <- base::Sys.getenv()
[16:21:07.070]                 names <- names(envs)
[16:21:07.070]                 common <- intersect(names, old_names)
[16:21:07.070]                 added <- setdiff(names, old_names)
[16:21:07.070]                 removed <- setdiff(old_names, names)
[16:21:07.070]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.070]                   envs[common]]
[16:21:07.070]                 NAMES <- toupper(changed)
[16:21:07.070]                 args <- list()
[16:21:07.070]                 for (kk in seq_along(NAMES)) {
[16:21:07.070]                   name <- changed[[kk]]
[16:21:07.070]                   NAME <- NAMES[[kk]]
[16:21:07.070]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.070]                     next
[16:21:07.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.070]                 }
[16:21:07.070]                 NAMES <- toupper(added)
[16:21:07.070]                 for (kk in seq_along(NAMES)) {
[16:21:07.070]                   name <- added[[kk]]
[16:21:07.070]                   NAME <- NAMES[[kk]]
[16:21:07.070]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.070]                     next
[16:21:07.070]                   args[[name]] <- ""
[16:21:07.070]                 }
[16:21:07.070]                 NAMES <- toupper(removed)
[16:21:07.070]                 for (kk in seq_along(NAMES)) {
[16:21:07.070]                   name <- removed[[kk]]
[16:21:07.070]                   NAME <- NAMES[[kk]]
[16:21:07.070]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.070]                     next
[16:21:07.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.070]                 }
[16:21:07.070]                 if (length(args) > 0) 
[16:21:07.070]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.070]             }
[16:21:07.070]             else {
[16:21:07.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.070]             }
[16:21:07.070]             {
[16:21:07.070]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.070]                   0L) {
[16:21:07.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.070]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.070]                   base::options(opts)
[16:21:07.070]                 }
[16:21:07.070]                 {
[16:21:07.070]                   {
[16:21:07.070]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.070]                     NULL
[16:21:07.070]                   }
[16:21:07.070]                   options(future.plan = NULL)
[16:21:07.070]                   if (is.na(NA_character_)) 
[16:21:07.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.070]                     .init = FALSE)
[16:21:07.070]                 }
[16:21:07.070]             }
[16:21:07.070]         }
[16:21:07.070]     })
[16:21:07.070]     if (TRUE) {
[16:21:07.070]         base::sink(type = "output", split = FALSE)
[16:21:07.070]         if (TRUE) {
[16:21:07.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.070]         }
[16:21:07.070]         else {
[16:21:07.070]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.070]         }
[16:21:07.070]         base::close(...future.stdout)
[16:21:07.070]         ...future.stdout <- NULL
[16:21:07.070]     }
[16:21:07.070]     ...future.result$conditions <- ...future.conditions
[16:21:07.070]     ...future.result$finished <- base::Sys.time()
[16:21:07.070]     ...future.result
[16:21:07.070] }
[16:21:07.072] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:21:07.073] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:21:07.073] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:21:07.073] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:21:07.074] MultisessionFuture started
[16:21:07.074] - Launch lazy future ... done
[16:21:07.074] run() for ‘MultisessionFuture’ ... done
[16:21:07.074] result() for ClusterFuture ...
[16:21:07.074] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.074] - Validating connection of MultisessionFuture
[16:21:07.118] - received message: FutureResult
[16:21:07.118] - Received FutureResult
[16:21:07.118] - Erased future from FutureRegistry
[16:21:07.119] result() for ClusterFuture ...
[16:21:07.119] - result already collected: FutureResult
[16:21:07.119] result() for ClusterFuture ... done
[16:21:07.119] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.119] result() for ClusterFuture ... done
[16:21:07.119] result() for ClusterFuture ...
[16:21:07.119] - result already collected: FutureResult
[16:21:07.119] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.120] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.120] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.122] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.122] Searching for globals ... DONE
[16:21:07.122] Resolving globals: TRUE
[16:21:07.122] Resolving any globals that are futures ...
[16:21:07.122] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.122] Resolving any globals that are futures ... DONE
[16:21:07.123] Resolving futures part of globals (recursively) ...
[16:21:07.123] resolve() on list ...
[16:21:07.123]  recursive: 99
[16:21:07.123]  length: 2
[16:21:07.123]  elements: ‘a’, ‘ii’
[16:21:07.123]  length: 1 (resolved future 1)
[16:21:07.124]  length: 0 (resolved future 2)
[16:21:07.124] resolve() on list ... DONE
[16:21:07.124] - globals: [2] ‘a’, ‘ii’
[16:21:07.124] Resolving futures part of globals (recursively) ... DONE
[16:21:07.124] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:07.124] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:07.125] - globals: [2] ‘a’, ‘ii’
[16:21:07.125] 
[16:21:07.125] getGlobalsAndPackages() ... DONE
[16:21:07.125] run() for ‘Future’ ...
[16:21:07.125] - state: ‘created’
[16:21:07.125] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.141] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.141]   - Field: ‘node’
[16:21:07.141]   - Field: ‘label’
[16:21:07.141]   - Field: ‘local’
[16:21:07.142]   - Field: ‘owner’
[16:21:07.142]   - Field: ‘envir’
[16:21:07.142]   - Field: ‘workers’
[16:21:07.142]   - Field: ‘packages’
[16:21:07.142]   - Field: ‘gc’
[16:21:07.142]   - Field: ‘conditions’
[16:21:07.142]   - Field: ‘persistent’
[16:21:07.142]   - Field: ‘expr’
[16:21:07.142]   - Field: ‘uuid’
[16:21:07.142]   - Field: ‘seed’
[16:21:07.142]   - Field: ‘version’
[16:21:07.143]   - Field: ‘result’
[16:21:07.143]   - Field: ‘asynchronous’
[16:21:07.143]   - Field: ‘calls’
[16:21:07.143]   - Field: ‘globals’
[16:21:07.143]   - Field: ‘stdout’
[16:21:07.143]   - Field: ‘earlySignal’
[16:21:07.143]   - Field: ‘lazy’
[16:21:07.143]   - Field: ‘state’
[16:21:07.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.143] - Launch lazy future ...
[16:21:07.144] Packages needed by the future expression (n = 0): <none>
[16:21:07.144] Packages needed by future strategies (n = 0): <none>
[16:21:07.144] {
[16:21:07.144]     {
[16:21:07.144]         {
[16:21:07.144]             ...future.startTime <- base::Sys.time()
[16:21:07.144]             {
[16:21:07.144]                 {
[16:21:07.144]                   {
[16:21:07.144]                     {
[16:21:07.144]                       base::local({
[16:21:07.144]                         has_future <- base::requireNamespace("future", 
[16:21:07.144]                           quietly = TRUE)
[16:21:07.144]                         if (has_future) {
[16:21:07.144]                           ns <- base::getNamespace("future")
[16:21:07.144]                           version <- ns[[".package"]][["version"]]
[16:21:07.144]                           if (is.null(version)) 
[16:21:07.144]                             version <- utils::packageVersion("future")
[16:21:07.144]                         }
[16:21:07.144]                         else {
[16:21:07.144]                           version <- NULL
[16:21:07.144]                         }
[16:21:07.144]                         if (!has_future || version < "1.8.0") {
[16:21:07.144]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.144]                             "", base::R.version$version.string), 
[16:21:07.144]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.144]                               "release", "version")], collapse = " "), 
[16:21:07.144]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.144]                             info)
[16:21:07.144]                           info <- base::paste(info, collapse = "; ")
[16:21:07.144]                           if (!has_future) {
[16:21:07.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.144]                               info)
[16:21:07.144]                           }
[16:21:07.144]                           else {
[16:21:07.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.144]                               info, version)
[16:21:07.144]                           }
[16:21:07.144]                           base::stop(msg)
[16:21:07.144]                         }
[16:21:07.144]                       })
[16:21:07.144]                     }
[16:21:07.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.144]                     base::options(mc.cores = 1L)
[16:21:07.144]                   }
[16:21:07.144]                   ...future.strategy.old <- future::plan("list")
[16:21:07.144]                   options(future.plan = NULL)
[16:21:07.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.144]                 }
[16:21:07.144]                 ...future.workdir <- getwd()
[16:21:07.144]             }
[16:21:07.144]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.144]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.144]         }
[16:21:07.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.144]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.144]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.144]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.144]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.144]             base::names(...future.oldOptions))
[16:21:07.144]     }
[16:21:07.144]     if (FALSE) {
[16:21:07.144]     }
[16:21:07.144]     else {
[16:21:07.144]         if (TRUE) {
[16:21:07.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.144]                 open = "w")
[16:21:07.144]         }
[16:21:07.144]         else {
[16:21:07.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.144]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.144]         }
[16:21:07.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.144]             base::sink(type = "output", split = FALSE)
[16:21:07.144]             base::close(...future.stdout)
[16:21:07.144]         }, add = TRUE)
[16:21:07.144]     }
[16:21:07.144]     ...future.frame <- base::sys.nframe()
[16:21:07.144]     ...future.conditions <- base::list()
[16:21:07.144]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.144]     if (FALSE) {
[16:21:07.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.144]     }
[16:21:07.144]     ...future.result <- base::tryCatch({
[16:21:07.144]         base::withCallingHandlers({
[16:21:07.144]             ...future.value <- base::withVisible(base::local({
[16:21:07.144]                 ...future.makeSendCondition <- base::local({
[16:21:07.144]                   sendCondition <- NULL
[16:21:07.144]                   function(frame = 1L) {
[16:21:07.144]                     if (is.function(sendCondition)) 
[16:21:07.144]                       return(sendCondition)
[16:21:07.144]                     ns <- getNamespace("parallel")
[16:21:07.144]                     if (exists("sendData", mode = "function", 
[16:21:07.144]                       envir = ns)) {
[16:21:07.144]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.144]                         envir = ns)
[16:21:07.144]                       envir <- sys.frame(frame)
[16:21:07.144]                       master <- NULL
[16:21:07.144]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.144]                         !identical(envir, emptyenv())) {
[16:21:07.144]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.144]                           inherits = FALSE)) {
[16:21:07.144]                           master <- get("master", mode = "list", 
[16:21:07.144]                             envir = envir, inherits = FALSE)
[16:21:07.144]                           if (inherits(master, c("SOCKnode", 
[16:21:07.144]                             "SOCK0node"))) {
[16:21:07.144]                             sendCondition <<- function(cond) {
[16:21:07.144]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.144]                                 success = TRUE)
[16:21:07.144]                               parallel_sendData(master, data)
[16:21:07.144]                             }
[16:21:07.144]                             return(sendCondition)
[16:21:07.144]                           }
[16:21:07.144]                         }
[16:21:07.144]                         frame <- frame + 1L
[16:21:07.144]                         envir <- sys.frame(frame)
[16:21:07.144]                       }
[16:21:07.144]                     }
[16:21:07.144]                     sendCondition <<- function(cond) NULL
[16:21:07.144]                   }
[16:21:07.144]                 })
[16:21:07.144]                 withCallingHandlers({
[16:21:07.144]                   {
[16:21:07.144]                     b <- a * ii
[16:21:07.144]                     a <- 0
[16:21:07.144]                     b
[16:21:07.144]                   }
[16:21:07.144]                 }, immediateCondition = function(cond) {
[16:21:07.144]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.144]                   sendCondition(cond)
[16:21:07.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.144]                   {
[16:21:07.144]                     inherits <- base::inherits
[16:21:07.144]                     invokeRestart <- base::invokeRestart
[16:21:07.144]                     is.null <- base::is.null
[16:21:07.144]                     muffled <- FALSE
[16:21:07.144]                     if (inherits(cond, "message")) {
[16:21:07.144]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.144]                       if (muffled) 
[16:21:07.144]                         invokeRestart("muffleMessage")
[16:21:07.144]                     }
[16:21:07.144]                     else if (inherits(cond, "warning")) {
[16:21:07.144]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.144]                       if (muffled) 
[16:21:07.144]                         invokeRestart("muffleWarning")
[16:21:07.144]                     }
[16:21:07.144]                     else if (inherits(cond, "condition")) {
[16:21:07.144]                       if (!is.null(pattern)) {
[16:21:07.144]                         computeRestarts <- base::computeRestarts
[16:21:07.144]                         grepl <- base::grepl
[16:21:07.144]                         restarts <- computeRestarts(cond)
[16:21:07.144]                         for (restart in restarts) {
[16:21:07.144]                           name <- restart$name
[16:21:07.144]                           if (is.null(name)) 
[16:21:07.144]                             next
[16:21:07.144]                           if (!grepl(pattern, name)) 
[16:21:07.144]                             next
[16:21:07.144]                           invokeRestart(restart)
[16:21:07.144]                           muffled <- TRUE
[16:21:07.144]                           break
[16:21:07.144]                         }
[16:21:07.144]                       }
[16:21:07.144]                     }
[16:21:07.144]                     invisible(muffled)
[16:21:07.144]                   }
[16:21:07.144]                   muffleCondition(cond)
[16:21:07.144]                 })
[16:21:07.144]             }))
[16:21:07.144]             future::FutureResult(value = ...future.value$value, 
[16:21:07.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.144]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.144]                     ...future.globalenv.names))
[16:21:07.144]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.144]         }, condition = base::local({
[16:21:07.144]             c <- base::c
[16:21:07.144]             inherits <- base::inherits
[16:21:07.144]             invokeRestart <- base::invokeRestart
[16:21:07.144]             length <- base::length
[16:21:07.144]             list <- base::list
[16:21:07.144]             seq.int <- base::seq.int
[16:21:07.144]             signalCondition <- base::signalCondition
[16:21:07.144]             sys.calls <- base::sys.calls
[16:21:07.144]             `[[` <- base::`[[`
[16:21:07.144]             `+` <- base::`+`
[16:21:07.144]             `<<-` <- base::`<<-`
[16:21:07.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.144]                   3L)]
[16:21:07.144]             }
[16:21:07.144]             function(cond) {
[16:21:07.144]                 is_error <- inherits(cond, "error")
[16:21:07.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.144]                   NULL)
[16:21:07.144]                 if (is_error) {
[16:21:07.144]                   sessionInformation <- function() {
[16:21:07.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.144]                       search = base::search(), system = base::Sys.info())
[16:21:07.144]                   }
[16:21:07.144]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.144]                     cond$call), session = sessionInformation(), 
[16:21:07.144]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.144]                   signalCondition(cond)
[16:21:07.144]                 }
[16:21:07.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.144]                 "immediateCondition"))) {
[16:21:07.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.144]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.144]                   if (TRUE && !signal) {
[16:21:07.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.144]                     {
[16:21:07.144]                       inherits <- base::inherits
[16:21:07.144]                       invokeRestart <- base::invokeRestart
[16:21:07.144]                       is.null <- base::is.null
[16:21:07.144]                       muffled <- FALSE
[16:21:07.144]                       if (inherits(cond, "message")) {
[16:21:07.144]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.144]                         if (muffled) 
[16:21:07.144]                           invokeRestart("muffleMessage")
[16:21:07.144]                       }
[16:21:07.144]                       else if (inherits(cond, "warning")) {
[16:21:07.144]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.144]                         if (muffled) 
[16:21:07.144]                           invokeRestart("muffleWarning")
[16:21:07.144]                       }
[16:21:07.144]                       else if (inherits(cond, "condition")) {
[16:21:07.144]                         if (!is.null(pattern)) {
[16:21:07.144]                           computeRestarts <- base::computeRestarts
[16:21:07.144]                           grepl <- base::grepl
[16:21:07.144]                           restarts <- computeRestarts(cond)
[16:21:07.144]                           for (restart in restarts) {
[16:21:07.144]                             name <- restart$name
[16:21:07.144]                             if (is.null(name)) 
[16:21:07.144]                               next
[16:21:07.144]                             if (!grepl(pattern, name)) 
[16:21:07.144]                               next
[16:21:07.144]                             invokeRestart(restart)
[16:21:07.144]                             muffled <- TRUE
[16:21:07.144]                             break
[16:21:07.144]                           }
[16:21:07.144]                         }
[16:21:07.144]                       }
[16:21:07.144]                       invisible(muffled)
[16:21:07.144]                     }
[16:21:07.144]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.144]                   }
[16:21:07.144]                 }
[16:21:07.144]                 else {
[16:21:07.144]                   if (TRUE) {
[16:21:07.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.144]                     {
[16:21:07.144]                       inherits <- base::inherits
[16:21:07.144]                       invokeRestart <- base::invokeRestart
[16:21:07.144]                       is.null <- base::is.null
[16:21:07.144]                       muffled <- FALSE
[16:21:07.144]                       if (inherits(cond, "message")) {
[16:21:07.144]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.144]                         if (muffled) 
[16:21:07.144]                           invokeRestart("muffleMessage")
[16:21:07.144]                       }
[16:21:07.144]                       else if (inherits(cond, "warning")) {
[16:21:07.144]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.144]                         if (muffled) 
[16:21:07.144]                           invokeRestart("muffleWarning")
[16:21:07.144]                       }
[16:21:07.144]                       else if (inherits(cond, "condition")) {
[16:21:07.144]                         if (!is.null(pattern)) {
[16:21:07.144]                           computeRestarts <- base::computeRestarts
[16:21:07.144]                           grepl <- base::grepl
[16:21:07.144]                           restarts <- computeRestarts(cond)
[16:21:07.144]                           for (restart in restarts) {
[16:21:07.144]                             name <- restart$name
[16:21:07.144]                             if (is.null(name)) 
[16:21:07.144]                               next
[16:21:07.144]                             if (!grepl(pattern, name)) 
[16:21:07.144]                               next
[16:21:07.144]                             invokeRestart(restart)
[16:21:07.144]                             muffled <- TRUE
[16:21:07.144]                             break
[16:21:07.144]                           }
[16:21:07.144]                         }
[16:21:07.144]                       }
[16:21:07.144]                       invisible(muffled)
[16:21:07.144]                     }
[16:21:07.144]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.144]                   }
[16:21:07.144]                 }
[16:21:07.144]             }
[16:21:07.144]         }))
[16:21:07.144]     }, error = function(ex) {
[16:21:07.144]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.144]                 ...future.rng), started = ...future.startTime, 
[16:21:07.144]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.144]             version = "1.8"), class = "FutureResult")
[16:21:07.144]     }, finally = {
[16:21:07.144]         if (!identical(...future.workdir, getwd())) 
[16:21:07.144]             setwd(...future.workdir)
[16:21:07.144]         {
[16:21:07.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.144]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.144]             }
[16:21:07.144]             base::options(...future.oldOptions)
[16:21:07.144]             if (.Platform$OS.type == "windows") {
[16:21:07.144]                 old_names <- names(...future.oldEnvVars)
[16:21:07.144]                 envs <- base::Sys.getenv()
[16:21:07.144]                 names <- names(envs)
[16:21:07.144]                 common <- intersect(names, old_names)
[16:21:07.144]                 added <- setdiff(names, old_names)
[16:21:07.144]                 removed <- setdiff(old_names, names)
[16:21:07.144]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.144]                   envs[common]]
[16:21:07.144]                 NAMES <- toupper(changed)
[16:21:07.144]                 args <- list()
[16:21:07.144]                 for (kk in seq_along(NAMES)) {
[16:21:07.144]                   name <- changed[[kk]]
[16:21:07.144]                   NAME <- NAMES[[kk]]
[16:21:07.144]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.144]                     next
[16:21:07.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.144]                 }
[16:21:07.144]                 NAMES <- toupper(added)
[16:21:07.144]                 for (kk in seq_along(NAMES)) {
[16:21:07.144]                   name <- added[[kk]]
[16:21:07.144]                   NAME <- NAMES[[kk]]
[16:21:07.144]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.144]                     next
[16:21:07.144]                   args[[name]] <- ""
[16:21:07.144]                 }
[16:21:07.144]                 NAMES <- toupper(removed)
[16:21:07.144]                 for (kk in seq_along(NAMES)) {
[16:21:07.144]                   name <- removed[[kk]]
[16:21:07.144]                   NAME <- NAMES[[kk]]
[16:21:07.144]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.144]                     next
[16:21:07.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.144]                 }
[16:21:07.144]                 if (length(args) > 0) 
[16:21:07.144]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.144]             }
[16:21:07.144]             else {
[16:21:07.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.144]             }
[16:21:07.144]             {
[16:21:07.144]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.144]                   0L) {
[16:21:07.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.144]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.144]                   base::options(opts)
[16:21:07.144]                 }
[16:21:07.144]                 {
[16:21:07.144]                   {
[16:21:07.144]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.144]                     NULL
[16:21:07.144]                   }
[16:21:07.144]                   options(future.plan = NULL)
[16:21:07.144]                   if (is.na(NA_character_)) 
[16:21:07.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.144]                     .init = FALSE)
[16:21:07.144]                 }
[16:21:07.144]             }
[16:21:07.144]         }
[16:21:07.144]     })
[16:21:07.144]     if (TRUE) {
[16:21:07.144]         base::sink(type = "output", split = FALSE)
[16:21:07.144]         if (TRUE) {
[16:21:07.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.144]         }
[16:21:07.144]         else {
[16:21:07.144]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.144]         }
[16:21:07.144]         base::close(...future.stdout)
[16:21:07.144]         ...future.stdout <- NULL
[16:21:07.144]     }
[16:21:07.144]     ...future.result$conditions <- ...future.conditions
[16:21:07.144]     ...future.result$finished <- base::Sys.time()
[16:21:07.144]     ...future.result
[16:21:07.144] }
[16:21:07.147] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[16:21:07.147] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:21:07.147] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:21:07.147] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:21:07.148] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:21:07.148] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[16:21:07.148] MultisessionFuture started
[16:21:07.148] - Launch lazy future ... done
[16:21:07.148] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.149] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.149] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.151] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.151] Searching for globals ... DONE
[16:21:07.151] Resolving globals: TRUE
[16:21:07.151] Resolving any globals that are futures ...
[16:21:07.151] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.151] Resolving any globals that are futures ... DONE
[16:21:07.152] Resolving futures part of globals (recursively) ...
[16:21:07.152] resolve() on list ...
[16:21:07.152]  recursive: 99
[16:21:07.152]  length: 2
[16:21:07.152]  elements: ‘a’, ‘ii’
[16:21:07.152]  length: 1 (resolved future 1)
[16:21:07.152]  length: 0 (resolved future 2)
[16:21:07.152] resolve() on list ... DONE
[16:21:07.153] - globals: [2] ‘a’, ‘ii’
[16:21:07.153] Resolving futures part of globals (recursively) ... DONE
[16:21:07.153] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:07.153] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:07.153] - globals: [2] ‘a’, ‘ii’
[16:21:07.153] 
[16:21:07.153] getGlobalsAndPackages() ... DONE
[16:21:07.154] run() for ‘Future’ ...
[16:21:07.154] - state: ‘created’
[16:21:07.154] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.168] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.168] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.168]   - Field: ‘node’
[16:21:07.168]   - Field: ‘label’
[16:21:07.168]   - Field: ‘local’
[16:21:07.168]   - Field: ‘owner’
[16:21:07.168]   - Field: ‘envir’
[16:21:07.168]   - Field: ‘workers’
[16:21:07.169]   - Field: ‘packages’
[16:21:07.169]   - Field: ‘gc’
[16:21:07.169]   - Field: ‘conditions’
[16:21:07.169]   - Field: ‘persistent’
[16:21:07.169]   - Field: ‘expr’
[16:21:07.169]   - Field: ‘uuid’
[16:21:07.169]   - Field: ‘seed’
[16:21:07.169]   - Field: ‘version’
[16:21:07.169]   - Field: ‘result’
[16:21:07.169]   - Field: ‘asynchronous’
[16:21:07.169]   - Field: ‘calls’
[16:21:07.170]   - Field: ‘globals’
[16:21:07.170]   - Field: ‘stdout’
[16:21:07.170]   - Field: ‘earlySignal’
[16:21:07.170]   - Field: ‘lazy’
[16:21:07.170]   - Field: ‘state’
[16:21:07.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.170] - Launch lazy future ...
[16:21:07.170] Packages needed by the future expression (n = 0): <none>
[16:21:07.170] Packages needed by future strategies (n = 0): <none>
[16:21:07.171] {
[16:21:07.171]     {
[16:21:07.171]         {
[16:21:07.171]             ...future.startTime <- base::Sys.time()
[16:21:07.171]             {
[16:21:07.171]                 {
[16:21:07.171]                   {
[16:21:07.171]                     {
[16:21:07.171]                       base::local({
[16:21:07.171]                         has_future <- base::requireNamespace("future", 
[16:21:07.171]                           quietly = TRUE)
[16:21:07.171]                         if (has_future) {
[16:21:07.171]                           ns <- base::getNamespace("future")
[16:21:07.171]                           version <- ns[[".package"]][["version"]]
[16:21:07.171]                           if (is.null(version)) 
[16:21:07.171]                             version <- utils::packageVersion("future")
[16:21:07.171]                         }
[16:21:07.171]                         else {
[16:21:07.171]                           version <- NULL
[16:21:07.171]                         }
[16:21:07.171]                         if (!has_future || version < "1.8.0") {
[16:21:07.171]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.171]                             "", base::R.version$version.string), 
[16:21:07.171]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.171]                               "release", "version")], collapse = " "), 
[16:21:07.171]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.171]                             info)
[16:21:07.171]                           info <- base::paste(info, collapse = "; ")
[16:21:07.171]                           if (!has_future) {
[16:21:07.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.171]                               info)
[16:21:07.171]                           }
[16:21:07.171]                           else {
[16:21:07.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.171]                               info, version)
[16:21:07.171]                           }
[16:21:07.171]                           base::stop(msg)
[16:21:07.171]                         }
[16:21:07.171]                       })
[16:21:07.171]                     }
[16:21:07.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.171]                     base::options(mc.cores = 1L)
[16:21:07.171]                   }
[16:21:07.171]                   ...future.strategy.old <- future::plan("list")
[16:21:07.171]                   options(future.plan = NULL)
[16:21:07.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.171]                 }
[16:21:07.171]                 ...future.workdir <- getwd()
[16:21:07.171]             }
[16:21:07.171]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.171]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.171]         }
[16:21:07.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.171]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.171]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.171]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.171]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.171]             base::names(...future.oldOptions))
[16:21:07.171]     }
[16:21:07.171]     if (FALSE) {
[16:21:07.171]     }
[16:21:07.171]     else {
[16:21:07.171]         if (TRUE) {
[16:21:07.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.171]                 open = "w")
[16:21:07.171]         }
[16:21:07.171]         else {
[16:21:07.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.171]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.171]         }
[16:21:07.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.171]             base::sink(type = "output", split = FALSE)
[16:21:07.171]             base::close(...future.stdout)
[16:21:07.171]         }, add = TRUE)
[16:21:07.171]     }
[16:21:07.171]     ...future.frame <- base::sys.nframe()
[16:21:07.171]     ...future.conditions <- base::list()
[16:21:07.171]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.171]     if (FALSE) {
[16:21:07.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.171]     }
[16:21:07.171]     ...future.result <- base::tryCatch({
[16:21:07.171]         base::withCallingHandlers({
[16:21:07.171]             ...future.value <- base::withVisible(base::local({
[16:21:07.171]                 ...future.makeSendCondition <- base::local({
[16:21:07.171]                   sendCondition <- NULL
[16:21:07.171]                   function(frame = 1L) {
[16:21:07.171]                     if (is.function(sendCondition)) 
[16:21:07.171]                       return(sendCondition)
[16:21:07.171]                     ns <- getNamespace("parallel")
[16:21:07.171]                     if (exists("sendData", mode = "function", 
[16:21:07.171]                       envir = ns)) {
[16:21:07.171]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.171]                         envir = ns)
[16:21:07.171]                       envir <- sys.frame(frame)
[16:21:07.171]                       master <- NULL
[16:21:07.171]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.171]                         !identical(envir, emptyenv())) {
[16:21:07.171]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.171]                           inherits = FALSE)) {
[16:21:07.171]                           master <- get("master", mode = "list", 
[16:21:07.171]                             envir = envir, inherits = FALSE)
[16:21:07.171]                           if (inherits(master, c("SOCKnode", 
[16:21:07.171]                             "SOCK0node"))) {
[16:21:07.171]                             sendCondition <<- function(cond) {
[16:21:07.171]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.171]                                 success = TRUE)
[16:21:07.171]                               parallel_sendData(master, data)
[16:21:07.171]                             }
[16:21:07.171]                             return(sendCondition)
[16:21:07.171]                           }
[16:21:07.171]                         }
[16:21:07.171]                         frame <- frame + 1L
[16:21:07.171]                         envir <- sys.frame(frame)
[16:21:07.171]                       }
[16:21:07.171]                     }
[16:21:07.171]                     sendCondition <<- function(cond) NULL
[16:21:07.171]                   }
[16:21:07.171]                 })
[16:21:07.171]                 withCallingHandlers({
[16:21:07.171]                   {
[16:21:07.171]                     b <- a * ii
[16:21:07.171]                     a <- 0
[16:21:07.171]                     b
[16:21:07.171]                   }
[16:21:07.171]                 }, immediateCondition = function(cond) {
[16:21:07.171]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.171]                   sendCondition(cond)
[16:21:07.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.171]                   {
[16:21:07.171]                     inherits <- base::inherits
[16:21:07.171]                     invokeRestart <- base::invokeRestart
[16:21:07.171]                     is.null <- base::is.null
[16:21:07.171]                     muffled <- FALSE
[16:21:07.171]                     if (inherits(cond, "message")) {
[16:21:07.171]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.171]                       if (muffled) 
[16:21:07.171]                         invokeRestart("muffleMessage")
[16:21:07.171]                     }
[16:21:07.171]                     else if (inherits(cond, "warning")) {
[16:21:07.171]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.171]                       if (muffled) 
[16:21:07.171]                         invokeRestart("muffleWarning")
[16:21:07.171]                     }
[16:21:07.171]                     else if (inherits(cond, "condition")) {
[16:21:07.171]                       if (!is.null(pattern)) {
[16:21:07.171]                         computeRestarts <- base::computeRestarts
[16:21:07.171]                         grepl <- base::grepl
[16:21:07.171]                         restarts <- computeRestarts(cond)
[16:21:07.171]                         for (restart in restarts) {
[16:21:07.171]                           name <- restart$name
[16:21:07.171]                           if (is.null(name)) 
[16:21:07.171]                             next
[16:21:07.171]                           if (!grepl(pattern, name)) 
[16:21:07.171]                             next
[16:21:07.171]                           invokeRestart(restart)
[16:21:07.171]                           muffled <- TRUE
[16:21:07.171]                           break
[16:21:07.171]                         }
[16:21:07.171]                       }
[16:21:07.171]                     }
[16:21:07.171]                     invisible(muffled)
[16:21:07.171]                   }
[16:21:07.171]                   muffleCondition(cond)
[16:21:07.171]                 })
[16:21:07.171]             }))
[16:21:07.171]             future::FutureResult(value = ...future.value$value, 
[16:21:07.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.171]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.171]                     ...future.globalenv.names))
[16:21:07.171]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.171]         }, condition = base::local({
[16:21:07.171]             c <- base::c
[16:21:07.171]             inherits <- base::inherits
[16:21:07.171]             invokeRestart <- base::invokeRestart
[16:21:07.171]             length <- base::length
[16:21:07.171]             list <- base::list
[16:21:07.171]             seq.int <- base::seq.int
[16:21:07.171]             signalCondition <- base::signalCondition
[16:21:07.171]             sys.calls <- base::sys.calls
[16:21:07.171]             `[[` <- base::`[[`
[16:21:07.171]             `+` <- base::`+`
[16:21:07.171]             `<<-` <- base::`<<-`
[16:21:07.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.171]                   3L)]
[16:21:07.171]             }
[16:21:07.171]             function(cond) {
[16:21:07.171]                 is_error <- inherits(cond, "error")
[16:21:07.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.171]                   NULL)
[16:21:07.171]                 if (is_error) {
[16:21:07.171]                   sessionInformation <- function() {
[16:21:07.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.171]                       search = base::search(), system = base::Sys.info())
[16:21:07.171]                   }
[16:21:07.171]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.171]                     cond$call), session = sessionInformation(), 
[16:21:07.171]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.171]                   signalCondition(cond)
[16:21:07.171]                 }
[16:21:07.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.171]                 "immediateCondition"))) {
[16:21:07.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.171]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.171]                   if (TRUE && !signal) {
[16:21:07.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.171]                     {
[16:21:07.171]                       inherits <- base::inherits
[16:21:07.171]                       invokeRestart <- base::invokeRestart
[16:21:07.171]                       is.null <- base::is.null
[16:21:07.171]                       muffled <- FALSE
[16:21:07.171]                       if (inherits(cond, "message")) {
[16:21:07.171]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.171]                         if (muffled) 
[16:21:07.171]                           invokeRestart("muffleMessage")
[16:21:07.171]                       }
[16:21:07.171]                       else if (inherits(cond, "warning")) {
[16:21:07.171]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.171]                         if (muffled) 
[16:21:07.171]                           invokeRestart("muffleWarning")
[16:21:07.171]                       }
[16:21:07.171]                       else if (inherits(cond, "condition")) {
[16:21:07.171]                         if (!is.null(pattern)) {
[16:21:07.171]                           computeRestarts <- base::computeRestarts
[16:21:07.171]                           grepl <- base::grepl
[16:21:07.171]                           restarts <- computeRestarts(cond)
[16:21:07.171]                           for (restart in restarts) {
[16:21:07.171]                             name <- restart$name
[16:21:07.171]                             if (is.null(name)) 
[16:21:07.171]                               next
[16:21:07.171]                             if (!grepl(pattern, name)) 
[16:21:07.171]                               next
[16:21:07.171]                             invokeRestart(restart)
[16:21:07.171]                             muffled <- TRUE
[16:21:07.171]                             break
[16:21:07.171]                           }
[16:21:07.171]                         }
[16:21:07.171]                       }
[16:21:07.171]                       invisible(muffled)
[16:21:07.171]                     }
[16:21:07.171]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.171]                   }
[16:21:07.171]                 }
[16:21:07.171]                 else {
[16:21:07.171]                   if (TRUE) {
[16:21:07.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.171]                     {
[16:21:07.171]                       inherits <- base::inherits
[16:21:07.171]                       invokeRestart <- base::invokeRestart
[16:21:07.171]                       is.null <- base::is.null
[16:21:07.171]                       muffled <- FALSE
[16:21:07.171]                       if (inherits(cond, "message")) {
[16:21:07.171]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.171]                         if (muffled) 
[16:21:07.171]                           invokeRestart("muffleMessage")
[16:21:07.171]                       }
[16:21:07.171]                       else if (inherits(cond, "warning")) {
[16:21:07.171]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.171]                         if (muffled) 
[16:21:07.171]                           invokeRestart("muffleWarning")
[16:21:07.171]                       }
[16:21:07.171]                       else if (inherits(cond, "condition")) {
[16:21:07.171]                         if (!is.null(pattern)) {
[16:21:07.171]                           computeRestarts <- base::computeRestarts
[16:21:07.171]                           grepl <- base::grepl
[16:21:07.171]                           restarts <- computeRestarts(cond)
[16:21:07.171]                           for (restart in restarts) {
[16:21:07.171]                             name <- restart$name
[16:21:07.171]                             if (is.null(name)) 
[16:21:07.171]                               next
[16:21:07.171]                             if (!grepl(pattern, name)) 
[16:21:07.171]                               next
[16:21:07.171]                             invokeRestart(restart)
[16:21:07.171]                             muffled <- TRUE
[16:21:07.171]                             break
[16:21:07.171]                           }
[16:21:07.171]                         }
[16:21:07.171]                       }
[16:21:07.171]                       invisible(muffled)
[16:21:07.171]                     }
[16:21:07.171]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.171]                   }
[16:21:07.171]                 }
[16:21:07.171]             }
[16:21:07.171]         }))
[16:21:07.171]     }, error = function(ex) {
[16:21:07.171]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.171]                 ...future.rng), started = ...future.startTime, 
[16:21:07.171]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.171]             version = "1.8"), class = "FutureResult")
[16:21:07.171]     }, finally = {
[16:21:07.171]         if (!identical(...future.workdir, getwd())) 
[16:21:07.171]             setwd(...future.workdir)
[16:21:07.171]         {
[16:21:07.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.171]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.171]             }
[16:21:07.171]             base::options(...future.oldOptions)
[16:21:07.171]             if (.Platform$OS.type == "windows") {
[16:21:07.171]                 old_names <- names(...future.oldEnvVars)
[16:21:07.171]                 envs <- base::Sys.getenv()
[16:21:07.171]                 names <- names(envs)
[16:21:07.171]                 common <- intersect(names, old_names)
[16:21:07.171]                 added <- setdiff(names, old_names)
[16:21:07.171]                 removed <- setdiff(old_names, names)
[16:21:07.171]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.171]                   envs[common]]
[16:21:07.171]                 NAMES <- toupper(changed)
[16:21:07.171]                 args <- list()
[16:21:07.171]                 for (kk in seq_along(NAMES)) {
[16:21:07.171]                   name <- changed[[kk]]
[16:21:07.171]                   NAME <- NAMES[[kk]]
[16:21:07.171]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.171]                     next
[16:21:07.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.171]                 }
[16:21:07.171]                 NAMES <- toupper(added)
[16:21:07.171]                 for (kk in seq_along(NAMES)) {
[16:21:07.171]                   name <- added[[kk]]
[16:21:07.171]                   NAME <- NAMES[[kk]]
[16:21:07.171]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.171]                     next
[16:21:07.171]                   args[[name]] <- ""
[16:21:07.171]                 }
[16:21:07.171]                 NAMES <- toupper(removed)
[16:21:07.171]                 for (kk in seq_along(NAMES)) {
[16:21:07.171]                   name <- removed[[kk]]
[16:21:07.171]                   NAME <- NAMES[[kk]]
[16:21:07.171]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.171]                     next
[16:21:07.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.171]                 }
[16:21:07.171]                 if (length(args) > 0) 
[16:21:07.171]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.171]             }
[16:21:07.171]             else {
[16:21:07.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.171]             }
[16:21:07.171]             {
[16:21:07.171]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.171]                   0L) {
[16:21:07.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.171]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.171]                   base::options(opts)
[16:21:07.171]                 }
[16:21:07.171]                 {
[16:21:07.171]                   {
[16:21:07.171]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.171]                     NULL
[16:21:07.171]                   }
[16:21:07.171]                   options(future.plan = NULL)
[16:21:07.171]                   if (is.na(NA_character_)) 
[16:21:07.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.171]                     .init = FALSE)
[16:21:07.171]                 }
[16:21:07.171]             }
[16:21:07.171]         }
[16:21:07.171]     })
[16:21:07.171]     if (TRUE) {
[16:21:07.171]         base::sink(type = "output", split = FALSE)
[16:21:07.171]         if (TRUE) {
[16:21:07.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.171]         }
[16:21:07.171]         else {
[16:21:07.171]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.171]         }
[16:21:07.171]         base::close(...future.stdout)
[16:21:07.171]         ...future.stdout <- NULL
[16:21:07.171]     }
[16:21:07.171]     ...future.result$conditions <- ...future.conditions
[16:21:07.171]     ...future.result$finished <- base::Sys.time()
[16:21:07.171]     ...future.result
[16:21:07.171] }
[16:21:07.173] Poll #1 (0): usedNodes() = 2, workers = 2
[16:21:07.184] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.184] - Validating connection of MultisessionFuture
[16:21:07.184] - received message: FutureResult
[16:21:07.184] - Received FutureResult
[16:21:07.185] - Erased future from FutureRegistry
[16:21:07.185] result() for ClusterFuture ...
[16:21:07.185] - result already collected: FutureResult
[16:21:07.185] result() for ClusterFuture ... done
[16:21:07.185] signalConditions() ...
[16:21:07.185]  - include = ‘immediateCondition’
[16:21:07.185]  - exclude = 
[16:21:07.185]  - resignal = FALSE
[16:21:07.185]  - Number of conditions: 1
[16:21:07.185] signalConditions() ... done
[16:21:07.185] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.186] result() for ClusterFuture ...
[16:21:07.186] - result already collected: FutureResult
[16:21:07.186] result() for ClusterFuture ... done
[16:21:07.186] result() for ClusterFuture ...
[16:21:07.186] - result already collected: FutureResult
[16:21:07.186] result() for ClusterFuture ... done
[16:21:07.186] signalConditions() ...
[16:21:07.186]  - include = ‘immediateCondition’
[16:21:07.186]  - exclude = 
[16:21:07.186]  - resignal = FALSE
[16:21:07.186]  - Number of conditions: 1
[16:21:07.187] signalConditions() ... done
[16:21:07.187] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:21:07.187] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:21:07.188] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:21:07.188] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:21:07.188] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:21:07.189] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:21:07.189] MultisessionFuture started
[16:21:07.189] - Launch lazy future ... done
[16:21:07.189] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.190] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.190] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.193] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.193] Searching for globals ... DONE
[16:21:07.193] Resolving globals: TRUE
[16:21:07.193] Resolving any globals that are futures ...
[16:21:07.193] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.193] Resolving any globals that are futures ... DONE
[16:21:07.194] Resolving futures part of globals (recursively) ...
[16:21:07.194] resolve() on list ...
[16:21:07.194]  recursive: 99
[16:21:07.194]  length: 2
[16:21:07.194]  elements: ‘a’, ‘ii’
[16:21:07.194]  length: 1 (resolved future 1)
[16:21:07.194]  length: 0 (resolved future 2)
[16:21:07.194] resolve() on list ... DONE
[16:21:07.195] - globals: [2] ‘a’, ‘ii’
[16:21:07.195] Resolving futures part of globals (recursively) ... DONE
[16:21:07.195] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:07.195] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:07.195] - globals: [2] ‘a’, ‘ii’
[16:21:07.195] 
[16:21:07.195] getGlobalsAndPackages() ... DONE
[16:21:07.196] run() for ‘Future’ ...
[16:21:07.196] - state: ‘created’
[16:21:07.196] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.210] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.210] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.210]   - Field: ‘node’
[16:21:07.210]   - Field: ‘label’
[16:21:07.210]   - Field: ‘local’
[16:21:07.210]   - Field: ‘owner’
[16:21:07.211]   - Field: ‘envir’
[16:21:07.211]   - Field: ‘workers’
[16:21:07.211]   - Field: ‘packages’
[16:21:07.211]   - Field: ‘gc’
[16:21:07.211]   - Field: ‘conditions’
[16:21:07.211]   - Field: ‘persistent’
[16:21:07.211]   - Field: ‘expr’
[16:21:07.211]   - Field: ‘uuid’
[16:21:07.211]   - Field: ‘seed’
[16:21:07.211]   - Field: ‘version’
[16:21:07.211]   - Field: ‘result’
[16:21:07.212]   - Field: ‘asynchronous’
[16:21:07.212]   - Field: ‘calls’
[16:21:07.212]   - Field: ‘globals’
[16:21:07.212]   - Field: ‘stdout’
[16:21:07.212]   - Field: ‘earlySignal’
[16:21:07.212]   - Field: ‘lazy’
[16:21:07.212]   - Field: ‘state’
[16:21:07.212] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.212] - Launch lazy future ...
[16:21:07.213] Packages needed by the future expression (n = 0): <none>
[16:21:07.213] Packages needed by future strategies (n = 0): <none>
[16:21:07.213] {
[16:21:07.213]     {
[16:21:07.213]         {
[16:21:07.213]             ...future.startTime <- base::Sys.time()
[16:21:07.213]             {
[16:21:07.213]                 {
[16:21:07.213]                   {
[16:21:07.213]                     {
[16:21:07.213]                       base::local({
[16:21:07.213]                         has_future <- base::requireNamespace("future", 
[16:21:07.213]                           quietly = TRUE)
[16:21:07.213]                         if (has_future) {
[16:21:07.213]                           ns <- base::getNamespace("future")
[16:21:07.213]                           version <- ns[[".package"]][["version"]]
[16:21:07.213]                           if (is.null(version)) 
[16:21:07.213]                             version <- utils::packageVersion("future")
[16:21:07.213]                         }
[16:21:07.213]                         else {
[16:21:07.213]                           version <- NULL
[16:21:07.213]                         }
[16:21:07.213]                         if (!has_future || version < "1.8.0") {
[16:21:07.213]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.213]                             "", base::R.version$version.string), 
[16:21:07.213]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.213]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.213]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.213]                               "release", "version")], collapse = " "), 
[16:21:07.213]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.213]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.213]                             info)
[16:21:07.213]                           info <- base::paste(info, collapse = "; ")
[16:21:07.213]                           if (!has_future) {
[16:21:07.213]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.213]                               info)
[16:21:07.213]                           }
[16:21:07.213]                           else {
[16:21:07.213]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.213]                               info, version)
[16:21:07.213]                           }
[16:21:07.213]                           base::stop(msg)
[16:21:07.213]                         }
[16:21:07.213]                       })
[16:21:07.213]                     }
[16:21:07.213]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.213]                     base::options(mc.cores = 1L)
[16:21:07.213]                   }
[16:21:07.213]                   ...future.strategy.old <- future::plan("list")
[16:21:07.213]                   options(future.plan = NULL)
[16:21:07.213]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.213]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.213]                 }
[16:21:07.213]                 ...future.workdir <- getwd()
[16:21:07.213]             }
[16:21:07.213]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.213]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.213]         }
[16:21:07.213]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.213]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.213]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.213]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.213]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.213]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.213]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.213]             base::names(...future.oldOptions))
[16:21:07.213]     }
[16:21:07.213]     if (FALSE) {
[16:21:07.213]     }
[16:21:07.213]     else {
[16:21:07.213]         if (TRUE) {
[16:21:07.213]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.213]                 open = "w")
[16:21:07.213]         }
[16:21:07.213]         else {
[16:21:07.213]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.213]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.213]         }
[16:21:07.213]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.213]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.213]             base::sink(type = "output", split = FALSE)
[16:21:07.213]             base::close(...future.stdout)
[16:21:07.213]         }, add = TRUE)
[16:21:07.213]     }
[16:21:07.213]     ...future.frame <- base::sys.nframe()
[16:21:07.213]     ...future.conditions <- base::list()
[16:21:07.213]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.213]     if (FALSE) {
[16:21:07.213]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.213]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.213]     }
[16:21:07.213]     ...future.result <- base::tryCatch({
[16:21:07.213]         base::withCallingHandlers({
[16:21:07.213]             ...future.value <- base::withVisible(base::local({
[16:21:07.213]                 ...future.makeSendCondition <- base::local({
[16:21:07.213]                   sendCondition <- NULL
[16:21:07.213]                   function(frame = 1L) {
[16:21:07.213]                     if (is.function(sendCondition)) 
[16:21:07.213]                       return(sendCondition)
[16:21:07.213]                     ns <- getNamespace("parallel")
[16:21:07.213]                     if (exists("sendData", mode = "function", 
[16:21:07.213]                       envir = ns)) {
[16:21:07.213]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.213]                         envir = ns)
[16:21:07.213]                       envir <- sys.frame(frame)
[16:21:07.213]                       master <- NULL
[16:21:07.213]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.213]                         !identical(envir, emptyenv())) {
[16:21:07.213]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.213]                           inherits = FALSE)) {
[16:21:07.213]                           master <- get("master", mode = "list", 
[16:21:07.213]                             envir = envir, inherits = FALSE)
[16:21:07.213]                           if (inherits(master, c("SOCKnode", 
[16:21:07.213]                             "SOCK0node"))) {
[16:21:07.213]                             sendCondition <<- function(cond) {
[16:21:07.213]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.213]                                 success = TRUE)
[16:21:07.213]                               parallel_sendData(master, data)
[16:21:07.213]                             }
[16:21:07.213]                             return(sendCondition)
[16:21:07.213]                           }
[16:21:07.213]                         }
[16:21:07.213]                         frame <- frame + 1L
[16:21:07.213]                         envir <- sys.frame(frame)
[16:21:07.213]                       }
[16:21:07.213]                     }
[16:21:07.213]                     sendCondition <<- function(cond) NULL
[16:21:07.213]                   }
[16:21:07.213]                 })
[16:21:07.213]                 withCallingHandlers({
[16:21:07.213]                   {
[16:21:07.213]                     b <- a * ii
[16:21:07.213]                     a <- 0
[16:21:07.213]                     b
[16:21:07.213]                   }
[16:21:07.213]                 }, immediateCondition = function(cond) {
[16:21:07.213]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.213]                   sendCondition(cond)
[16:21:07.213]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.213]                   {
[16:21:07.213]                     inherits <- base::inherits
[16:21:07.213]                     invokeRestart <- base::invokeRestart
[16:21:07.213]                     is.null <- base::is.null
[16:21:07.213]                     muffled <- FALSE
[16:21:07.213]                     if (inherits(cond, "message")) {
[16:21:07.213]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.213]                       if (muffled) 
[16:21:07.213]                         invokeRestart("muffleMessage")
[16:21:07.213]                     }
[16:21:07.213]                     else if (inherits(cond, "warning")) {
[16:21:07.213]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.213]                       if (muffled) 
[16:21:07.213]                         invokeRestart("muffleWarning")
[16:21:07.213]                     }
[16:21:07.213]                     else if (inherits(cond, "condition")) {
[16:21:07.213]                       if (!is.null(pattern)) {
[16:21:07.213]                         computeRestarts <- base::computeRestarts
[16:21:07.213]                         grepl <- base::grepl
[16:21:07.213]                         restarts <- computeRestarts(cond)
[16:21:07.213]                         for (restart in restarts) {
[16:21:07.213]                           name <- restart$name
[16:21:07.213]                           if (is.null(name)) 
[16:21:07.213]                             next
[16:21:07.213]                           if (!grepl(pattern, name)) 
[16:21:07.213]                             next
[16:21:07.213]                           invokeRestart(restart)
[16:21:07.213]                           muffled <- TRUE
[16:21:07.213]                           break
[16:21:07.213]                         }
[16:21:07.213]                       }
[16:21:07.213]                     }
[16:21:07.213]                     invisible(muffled)
[16:21:07.213]                   }
[16:21:07.213]                   muffleCondition(cond)
[16:21:07.213]                 })
[16:21:07.213]             }))
[16:21:07.213]             future::FutureResult(value = ...future.value$value, 
[16:21:07.213]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.213]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.213]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.213]                     ...future.globalenv.names))
[16:21:07.213]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.213]         }, condition = base::local({
[16:21:07.213]             c <- base::c
[16:21:07.213]             inherits <- base::inherits
[16:21:07.213]             invokeRestart <- base::invokeRestart
[16:21:07.213]             length <- base::length
[16:21:07.213]             list <- base::list
[16:21:07.213]             seq.int <- base::seq.int
[16:21:07.213]             signalCondition <- base::signalCondition
[16:21:07.213]             sys.calls <- base::sys.calls
[16:21:07.213]             `[[` <- base::`[[`
[16:21:07.213]             `+` <- base::`+`
[16:21:07.213]             `<<-` <- base::`<<-`
[16:21:07.213]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.213]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.213]                   3L)]
[16:21:07.213]             }
[16:21:07.213]             function(cond) {
[16:21:07.213]                 is_error <- inherits(cond, "error")
[16:21:07.213]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.213]                   NULL)
[16:21:07.213]                 if (is_error) {
[16:21:07.213]                   sessionInformation <- function() {
[16:21:07.213]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.213]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.213]                       search = base::search(), system = base::Sys.info())
[16:21:07.213]                   }
[16:21:07.213]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.213]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.213]                     cond$call), session = sessionInformation(), 
[16:21:07.213]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.213]                   signalCondition(cond)
[16:21:07.213]                 }
[16:21:07.213]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.213]                 "immediateCondition"))) {
[16:21:07.213]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.213]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.213]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.213]                   if (TRUE && !signal) {
[16:21:07.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.213]                     {
[16:21:07.213]                       inherits <- base::inherits
[16:21:07.213]                       invokeRestart <- base::invokeRestart
[16:21:07.213]                       is.null <- base::is.null
[16:21:07.213]                       muffled <- FALSE
[16:21:07.213]                       if (inherits(cond, "message")) {
[16:21:07.213]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.213]                         if (muffled) 
[16:21:07.213]                           invokeRestart("muffleMessage")
[16:21:07.213]                       }
[16:21:07.213]                       else if (inherits(cond, "warning")) {
[16:21:07.213]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.213]                         if (muffled) 
[16:21:07.213]                           invokeRestart("muffleWarning")
[16:21:07.213]                       }
[16:21:07.213]                       else if (inherits(cond, "condition")) {
[16:21:07.213]                         if (!is.null(pattern)) {
[16:21:07.213]                           computeRestarts <- base::computeRestarts
[16:21:07.213]                           grepl <- base::grepl
[16:21:07.213]                           restarts <- computeRestarts(cond)
[16:21:07.213]                           for (restart in restarts) {
[16:21:07.213]                             name <- restart$name
[16:21:07.213]                             if (is.null(name)) 
[16:21:07.213]                               next
[16:21:07.213]                             if (!grepl(pattern, name)) 
[16:21:07.213]                               next
[16:21:07.213]                             invokeRestart(restart)
[16:21:07.213]                             muffled <- TRUE
[16:21:07.213]                             break
[16:21:07.213]                           }
[16:21:07.213]                         }
[16:21:07.213]                       }
[16:21:07.213]                       invisible(muffled)
[16:21:07.213]                     }
[16:21:07.213]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.213]                   }
[16:21:07.213]                 }
[16:21:07.213]                 else {
[16:21:07.213]                   if (TRUE) {
[16:21:07.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.213]                     {
[16:21:07.213]                       inherits <- base::inherits
[16:21:07.213]                       invokeRestart <- base::invokeRestart
[16:21:07.213]                       is.null <- base::is.null
[16:21:07.213]                       muffled <- FALSE
[16:21:07.213]                       if (inherits(cond, "message")) {
[16:21:07.213]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.213]                         if (muffled) 
[16:21:07.213]                           invokeRestart("muffleMessage")
[16:21:07.213]                       }
[16:21:07.213]                       else if (inherits(cond, "warning")) {
[16:21:07.213]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.213]                         if (muffled) 
[16:21:07.213]                           invokeRestart("muffleWarning")
[16:21:07.213]                       }
[16:21:07.213]                       else if (inherits(cond, "condition")) {
[16:21:07.213]                         if (!is.null(pattern)) {
[16:21:07.213]                           computeRestarts <- base::computeRestarts
[16:21:07.213]                           grepl <- base::grepl
[16:21:07.213]                           restarts <- computeRestarts(cond)
[16:21:07.213]                           for (restart in restarts) {
[16:21:07.213]                             name <- restart$name
[16:21:07.213]                             if (is.null(name)) 
[16:21:07.213]                               next
[16:21:07.213]                             if (!grepl(pattern, name)) 
[16:21:07.213]                               next
[16:21:07.213]                             invokeRestart(restart)
[16:21:07.213]                             muffled <- TRUE
[16:21:07.213]                             break
[16:21:07.213]                           }
[16:21:07.213]                         }
[16:21:07.213]                       }
[16:21:07.213]                       invisible(muffled)
[16:21:07.213]                     }
[16:21:07.213]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.213]                   }
[16:21:07.213]                 }
[16:21:07.213]             }
[16:21:07.213]         }))
[16:21:07.213]     }, error = function(ex) {
[16:21:07.213]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.213]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.213]                 ...future.rng), started = ...future.startTime, 
[16:21:07.213]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.213]             version = "1.8"), class = "FutureResult")
[16:21:07.213]     }, finally = {
[16:21:07.213]         if (!identical(...future.workdir, getwd())) 
[16:21:07.213]             setwd(...future.workdir)
[16:21:07.213]         {
[16:21:07.213]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.213]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.213]             }
[16:21:07.213]             base::options(...future.oldOptions)
[16:21:07.213]             if (.Platform$OS.type == "windows") {
[16:21:07.213]                 old_names <- names(...future.oldEnvVars)
[16:21:07.213]                 envs <- base::Sys.getenv()
[16:21:07.213]                 names <- names(envs)
[16:21:07.213]                 common <- intersect(names, old_names)
[16:21:07.213]                 added <- setdiff(names, old_names)
[16:21:07.213]                 removed <- setdiff(old_names, names)
[16:21:07.213]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.213]                   envs[common]]
[16:21:07.213]                 NAMES <- toupper(changed)
[16:21:07.213]                 args <- list()
[16:21:07.213]                 for (kk in seq_along(NAMES)) {
[16:21:07.213]                   name <- changed[[kk]]
[16:21:07.213]                   NAME <- NAMES[[kk]]
[16:21:07.213]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.213]                     next
[16:21:07.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.213]                 }
[16:21:07.213]                 NAMES <- toupper(added)
[16:21:07.213]                 for (kk in seq_along(NAMES)) {
[16:21:07.213]                   name <- added[[kk]]
[16:21:07.213]                   NAME <- NAMES[[kk]]
[16:21:07.213]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.213]                     next
[16:21:07.213]                   args[[name]] <- ""
[16:21:07.213]                 }
[16:21:07.213]                 NAMES <- toupper(removed)
[16:21:07.213]                 for (kk in seq_along(NAMES)) {
[16:21:07.213]                   name <- removed[[kk]]
[16:21:07.213]                   NAME <- NAMES[[kk]]
[16:21:07.213]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.213]                     next
[16:21:07.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.213]                 }
[16:21:07.213]                 if (length(args) > 0) 
[16:21:07.213]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.213]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.213]             }
[16:21:07.213]             else {
[16:21:07.213]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.213]             }
[16:21:07.213]             {
[16:21:07.213]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.213]                   0L) {
[16:21:07.213]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.213]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.213]                   base::options(opts)
[16:21:07.213]                 }
[16:21:07.213]                 {
[16:21:07.213]                   {
[16:21:07.213]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.213]                     NULL
[16:21:07.213]                   }
[16:21:07.213]                   options(future.plan = NULL)
[16:21:07.213]                   if (is.na(NA_character_)) 
[16:21:07.213]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.213]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.213]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.213]                     .init = FALSE)
[16:21:07.213]                 }
[16:21:07.213]             }
[16:21:07.213]         }
[16:21:07.213]     })
[16:21:07.213]     if (TRUE) {
[16:21:07.213]         base::sink(type = "output", split = FALSE)
[16:21:07.213]         if (TRUE) {
[16:21:07.213]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.213]         }
[16:21:07.213]         else {
[16:21:07.213]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.213]         }
[16:21:07.213]         base::close(...future.stdout)
[16:21:07.213]         ...future.stdout <- NULL
[16:21:07.213]     }
[16:21:07.213]     ...future.result$conditions <- ...future.conditions
[16:21:07.213]     ...future.result$finished <- base::Sys.time()
[16:21:07.213]     ...future.result
[16:21:07.213] }
[16:21:07.215] Poll #1 (0): usedNodes() = 2, workers = 2
[16:21:07.226] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.226] - Validating connection of MultisessionFuture
[16:21:07.226] - received message: FutureResult
[16:21:07.226] - Received FutureResult
[16:21:07.226] - Erased future from FutureRegistry
[16:21:07.226] result() for ClusterFuture ...
[16:21:07.226] - result already collected: FutureResult
[16:21:07.227] result() for ClusterFuture ... done
[16:21:07.227] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.227] result() for ClusterFuture ...
[16:21:07.227] - result already collected: FutureResult
[16:21:07.227] result() for ClusterFuture ... done
[16:21:07.227] result() for ClusterFuture ...
[16:21:07.227] - result already collected: FutureResult
[16:21:07.227] result() for ClusterFuture ... done
[16:21:07.228] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[16:21:07.228] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:21:07.228] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:21:07.229] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:21:07.229] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:21:07.229] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[16:21:07.230] MultisessionFuture started
[16:21:07.230] - Launch lazy future ... done
[16:21:07.230] run() for ‘MultisessionFuture’ ... done
[16:21:07.230] result() for ClusterFuture ...
[16:21:07.230] - result already collected: FutureResult
[16:21:07.230] result() for ClusterFuture ... done
[16:21:07.230] result() for ClusterFuture ...
[16:21:07.230] - result already collected: FutureResult
[16:21:07.230] result() for ClusterFuture ... done
[16:21:07.231] result() for ClusterFuture ...
[16:21:07.231] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.231] - Validating connection of MultisessionFuture
[16:21:07.231] - received message: FutureResult
[16:21:07.231] - Received FutureResult
[16:21:07.231] - Erased future from FutureRegistry
[16:21:07.231] result() for ClusterFuture ...
[16:21:07.231] - result already collected: FutureResult
[16:21:07.231] result() for ClusterFuture ... done
[16:21:07.231] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.232] result() for ClusterFuture ... done
[16:21:07.232] result() for ClusterFuture ...
[16:21:07.232] - result already collected: FutureResult
[16:21:07.232] result() for ClusterFuture ... done
[16:21:07.232] result() for ClusterFuture ...
[16:21:07.232] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.232] - Validating connection of MultisessionFuture
[16:21:07.274] - received message: FutureResult
[16:21:07.274] - Received FutureResult
[16:21:07.274] - Erased future from FutureRegistry
[16:21:07.274] result() for ClusterFuture ...
[16:21:07.275] - result already collected: FutureResult
[16:21:07.275] result() for ClusterFuture ... done
[16:21:07.275] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.275] result() for ClusterFuture ... done
[16:21:07.275] result() for ClusterFuture ...
[16:21:07.275] - result already collected: FutureResult
[16:21:07.275] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.276] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.276] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.278] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.278] Searching for globals ... DONE
[16:21:07.278] Resolving globals: TRUE
[16:21:07.278] Resolving any globals that are futures ...
[16:21:07.278] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.279] Resolving any globals that are futures ... DONE
[16:21:07.279] Resolving futures part of globals (recursively) ...
[16:21:07.279] resolve() on list ...
[16:21:07.279]  recursive: 99
[16:21:07.279]  length: 2
[16:21:07.279]  elements: ‘a’, ‘ii’
[16:21:07.280]  length: 1 (resolved future 1)
[16:21:07.280]  length: 0 (resolved future 2)
[16:21:07.280] resolve() on list ... DONE
[16:21:07.280] - globals: [2] ‘a’, ‘ii’
[16:21:07.280] Resolving futures part of globals (recursively) ... DONE
[16:21:07.280] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:07.280] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:07.281] - globals: [2] ‘a’, ‘ii’
[16:21:07.281] 
[16:21:07.281] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.281] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.282] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.283] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.283] Searching for globals ... DONE
[16:21:07.284] Resolving globals: TRUE
[16:21:07.284] Resolving any globals that are futures ...
[16:21:07.284] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.284] Resolving any globals that are futures ... DONE
[16:21:07.284] Resolving futures part of globals (recursively) ...
[16:21:07.284] resolve() on list ...
[16:21:07.285]  recursive: 99
[16:21:07.285]  length: 2
[16:21:07.285]  elements: ‘a’, ‘ii’
[16:21:07.285]  length: 1 (resolved future 1)
[16:21:07.285]  length: 0 (resolved future 2)
[16:21:07.285] resolve() on list ... DONE
[16:21:07.285] - globals: [2] ‘a’, ‘ii’
[16:21:07.285] Resolving futures part of globals (recursively) ... DONE
[16:21:07.285] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:07.286] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:07.286] - globals: [2] ‘a’, ‘ii’
[16:21:07.286] 
[16:21:07.286] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.287] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.287] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.289] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.289] Searching for globals ... DONE
[16:21:07.289] Resolving globals: TRUE
[16:21:07.289] Resolving any globals that are futures ...
[16:21:07.289] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:21:07.289] Resolving any globals that are futures ... DONE
[16:21:07.289] Resolving futures part of globals (recursively) ...
[16:21:07.290] resolve() on list ...
[16:21:07.290]  recursive: 99
[16:21:07.290]  length: 2
[16:21:07.290]  elements: ‘a’, ‘ii’
[16:21:07.290]  length: 1 (resolved future 1)
[16:21:07.290]  length: 0 (resolved future 2)
[16:21:07.290] resolve() on list ... DONE
[16:21:07.290] - globals: [2] ‘a’, ‘ii’
[16:21:07.290] Resolving futures part of globals (recursively) ... DONE
[16:21:07.291] The total size of the 2 globals is 112 bytes (112 bytes)
[16:21:07.291] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:21:07.291] - globals: [2] ‘a’, ‘ii’
[16:21:07.291] 
[16:21:07.291] getGlobalsAndPackages() ... DONE
[16:21:07.292] run() for ‘Future’ ...
[16:21:07.292] - state: ‘created’
[16:21:07.292] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.306] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.306]   - Field: ‘node’
[16:21:07.306]   - Field: ‘label’
[16:21:07.307]   - Field: ‘local’
[16:21:07.307]   - Field: ‘owner’
[16:21:07.307]   - Field: ‘envir’
[16:21:07.307]   - Field: ‘workers’
[16:21:07.307]   - Field: ‘packages’
[16:21:07.307]   - Field: ‘gc’
[16:21:07.307]   - Field: ‘conditions’
[16:21:07.307]   - Field: ‘persistent’
[16:21:07.307]   - Field: ‘expr’
[16:21:07.307]   - Field: ‘uuid’
[16:21:07.307]   - Field: ‘seed’
[16:21:07.308]   - Field: ‘version’
[16:21:07.308]   - Field: ‘result’
[16:21:07.308]   - Field: ‘asynchronous’
[16:21:07.308]   - Field: ‘calls’
[16:21:07.308]   - Field: ‘globals’
[16:21:07.308]   - Field: ‘stdout’
[16:21:07.308]   - Field: ‘earlySignal’
[16:21:07.308]   - Field: ‘lazy’
[16:21:07.308]   - Field: ‘state’
[16:21:07.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.309] - Launch lazy future ...
[16:21:07.309] Packages needed by the future expression (n = 0): <none>
[16:21:07.309] Packages needed by future strategies (n = 0): <none>
[16:21:07.309] {
[16:21:07.309]     {
[16:21:07.309]         {
[16:21:07.309]             ...future.startTime <- base::Sys.time()
[16:21:07.309]             {
[16:21:07.309]                 {
[16:21:07.309]                   {
[16:21:07.309]                     {
[16:21:07.309]                       base::local({
[16:21:07.309]                         has_future <- base::requireNamespace("future", 
[16:21:07.309]                           quietly = TRUE)
[16:21:07.309]                         if (has_future) {
[16:21:07.309]                           ns <- base::getNamespace("future")
[16:21:07.309]                           version <- ns[[".package"]][["version"]]
[16:21:07.309]                           if (is.null(version)) 
[16:21:07.309]                             version <- utils::packageVersion("future")
[16:21:07.309]                         }
[16:21:07.309]                         else {
[16:21:07.309]                           version <- NULL
[16:21:07.309]                         }
[16:21:07.309]                         if (!has_future || version < "1.8.0") {
[16:21:07.309]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.309]                             "", base::R.version$version.string), 
[16:21:07.309]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.309]                               "release", "version")], collapse = " "), 
[16:21:07.309]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.309]                             info)
[16:21:07.309]                           info <- base::paste(info, collapse = "; ")
[16:21:07.309]                           if (!has_future) {
[16:21:07.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.309]                               info)
[16:21:07.309]                           }
[16:21:07.309]                           else {
[16:21:07.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.309]                               info, version)
[16:21:07.309]                           }
[16:21:07.309]                           base::stop(msg)
[16:21:07.309]                         }
[16:21:07.309]                       })
[16:21:07.309]                     }
[16:21:07.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.309]                     base::options(mc.cores = 1L)
[16:21:07.309]                   }
[16:21:07.309]                   ...future.strategy.old <- future::plan("list")
[16:21:07.309]                   options(future.plan = NULL)
[16:21:07.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.309]                 }
[16:21:07.309]                 ...future.workdir <- getwd()
[16:21:07.309]             }
[16:21:07.309]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.309]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.309]         }
[16:21:07.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.309]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.309]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.309]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.309]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.309]             base::names(...future.oldOptions))
[16:21:07.309]     }
[16:21:07.309]     if (FALSE) {
[16:21:07.309]     }
[16:21:07.309]     else {
[16:21:07.309]         if (TRUE) {
[16:21:07.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.309]                 open = "w")
[16:21:07.309]         }
[16:21:07.309]         else {
[16:21:07.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.309]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.309]         }
[16:21:07.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.309]             base::sink(type = "output", split = FALSE)
[16:21:07.309]             base::close(...future.stdout)
[16:21:07.309]         }, add = TRUE)
[16:21:07.309]     }
[16:21:07.309]     ...future.frame <- base::sys.nframe()
[16:21:07.309]     ...future.conditions <- base::list()
[16:21:07.309]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.309]     if (FALSE) {
[16:21:07.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.309]     }
[16:21:07.309]     ...future.result <- base::tryCatch({
[16:21:07.309]         base::withCallingHandlers({
[16:21:07.309]             ...future.value <- base::withVisible(base::local({
[16:21:07.309]                 ...future.makeSendCondition <- base::local({
[16:21:07.309]                   sendCondition <- NULL
[16:21:07.309]                   function(frame = 1L) {
[16:21:07.309]                     if (is.function(sendCondition)) 
[16:21:07.309]                       return(sendCondition)
[16:21:07.309]                     ns <- getNamespace("parallel")
[16:21:07.309]                     if (exists("sendData", mode = "function", 
[16:21:07.309]                       envir = ns)) {
[16:21:07.309]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.309]                         envir = ns)
[16:21:07.309]                       envir <- sys.frame(frame)
[16:21:07.309]                       master <- NULL
[16:21:07.309]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.309]                         !identical(envir, emptyenv())) {
[16:21:07.309]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.309]                           inherits = FALSE)) {
[16:21:07.309]                           master <- get("master", mode = "list", 
[16:21:07.309]                             envir = envir, inherits = FALSE)
[16:21:07.309]                           if (inherits(master, c("SOCKnode", 
[16:21:07.309]                             "SOCK0node"))) {
[16:21:07.309]                             sendCondition <<- function(cond) {
[16:21:07.309]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.309]                                 success = TRUE)
[16:21:07.309]                               parallel_sendData(master, data)
[16:21:07.309]                             }
[16:21:07.309]                             return(sendCondition)
[16:21:07.309]                           }
[16:21:07.309]                         }
[16:21:07.309]                         frame <- frame + 1L
[16:21:07.309]                         envir <- sys.frame(frame)
[16:21:07.309]                       }
[16:21:07.309]                     }
[16:21:07.309]                     sendCondition <<- function(cond) NULL
[16:21:07.309]                   }
[16:21:07.309]                 })
[16:21:07.309]                 withCallingHandlers({
[16:21:07.309]                   {
[16:21:07.309]                     b <- a * ii
[16:21:07.309]                     a <- 0
[16:21:07.309]                     b
[16:21:07.309]                   }
[16:21:07.309]                 }, immediateCondition = function(cond) {
[16:21:07.309]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.309]                   sendCondition(cond)
[16:21:07.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.309]                   {
[16:21:07.309]                     inherits <- base::inherits
[16:21:07.309]                     invokeRestart <- base::invokeRestart
[16:21:07.309]                     is.null <- base::is.null
[16:21:07.309]                     muffled <- FALSE
[16:21:07.309]                     if (inherits(cond, "message")) {
[16:21:07.309]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.309]                       if (muffled) 
[16:21:07.309]                         invokeRestart("muffleMessage")
[16:21:07.309]                     }
[16:21:07.309]                     else if (inherits(cond, "warning")) {
[16:21:07.309]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.309]                       if (muffled) 
[16:21:07.309]                         invokeRestart("muffleWarning")
[16:21:07.309]                     }
[16:21:07.309]                     else if (inherits(cond, "condition")) {
[16:21:07.309]                       if (!is.null(pattern)) {
[16:21:07.309]                         computeRestarts <- base::computeRestarts
[16:21:07.309]                         grepl <- base::grepl
[16:21:07.309]                         restarts <- computeRestarts(cond)
[16:21:07.309]                         for (restart in restarts) {
[16:21:07.309]                           name <- restart$name
[16:21:07.309]                           if (is.null(name)) 
[16:21:07.309]                             next
[16:21:07.309]                           if (!grepl(pattern, name)) 
[16:21:07.309]                             next
[16:21:07.309]                           invokeRestart(restart)
[16:21:07.309]                           muffled <- TRUE
[16:21:07.309]                           break
[16:21:07.309]                         }
[16:21:07.309]                       }
[16:21:07.309]                     }
[16:21:07.309]                     invisible(muffled)
[16:21:07.309]                   }
[16:21:07.309]                   muffleCondition(cond)
[16:21:07.309]                 })
[16:21:07.309]             }))
[16:21:07.309]             future::FutureResult(value = ...future.value$value, 
[16:21:07.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.309]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.309]                     ...future.globalenv.names))
[16:21:07.309]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.309]         }, condition = base::local({
[16:21:07.309]             c <- base::c
[16:21:07.309]             inherits <- base::inherits
[16:21:07.309]             invokeRestart <- base::invokeRestart
[16:21:07.309]             length <- base::length
[16:21:07.309]             list <- base::list
[16:21:07.309]             seq.int <- base::seq.int
[16:21:07.309]             signalCondition <- base::signalCondition
[16:21:07.309]             sys.calls <- base::sys.calls
[16:21:07.309]             `[[` <- base::`[[`
[16:21:07.309]             `+` <- base::`+`
[16:21:07.309]             `<<-` <- base::`<<-`
[16:21:07.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.309]                   3L)]
[16:21:07.309]             }
[16:21:07.309]             function(cond) {
[16:21:07.309]                 is_error <- inherits(cond, "error")
[16:21:07.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.309]                   NULL)
[16:21:07.309]                 if (is_error) {
[16:21:07.309]                   sessionInformation <- function() {
[16:21:07.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.309]                       search = base::search(), system = base::Sys.info())
[16:21:07.309]                   }
[16:21:07.309]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.309]                     cond$call), session = sessionInformation(), 
[16:21:07.309]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.309]                   signalCondition(cond)
[16:21:07.309]                 }
[16:21:07.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.309]                 "immediateCondition"))) {
[16:21:07.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.309]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.309]                   if (TRUE && !signal) {
[16:21:07.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.309]                     {
[16:21:07.309]                       inherits <- base::inherits
[16:21:07.309]                       invokeRestart <- base::invokeRestart
[16:21:07.309]                       is.null <- base::is.null
[16:21:07.309]                       muffled <- FALSE
[16:21:07.309]                       if (inherits(cond, "message")) {
[16:21:07.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.309]                         if (muffled) 
[16:21:07.309]                           invokeRestart("muffleMessage")
[16:21:07.309]                       }
[16:21:07.309]                       else if (inherits(cond, "warning")) {
[16:21:07.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.309]                         if (muffled) 
[16:21:07.309]                           invokeRestart("muffleWarning")
[16:21:07.309]                       }
[16:21:07.309]                       else if (inherits(cond, "condition")) {
[16:21:07.309]                         if (!is.null(pattern)) {
[16:21:07.309]                           computeRestarts <- base::computeRestarts
[16:21:07.309]                           grepl <- base::grepl
[16:21:07.309]                           restarts <- computeRestarts(cond)
[16:21:07.309]                           for (restart in restarts) {
[16:21:07.309]                             name <- restart$name
[16:21:07.309]                             if (is.null(name)) 
[16:21:07.309]                               next
[16:21:07.309]                             if (!grepl(pattern, name)) 
[16:21:07.309]                               next
[16:21:07.309]                             invokeRestart(restart)
[16:21:07.309]                             muffled <- TRUE
[16:21:07.309]                             break
[16:21:07.309]                           }
[16:21:07.309]                         }
[16:21:07.309]                       }
[16:21:07.309]                       invisible(muffled)
[16:21:07.309]                     }
[16:21:07.309]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.309]                   }
[16:21:07.309]                 }
[16:21:07.309]                 else {
[16:21:07.309]                   if (TRUE) {
[16:21:07.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.309]                     {
[16:21:07.309]                       inherits <- base::inherits
[16:21:07.309]                       invokeRestart <- base::invokeRestart
[16:21:07.309]                       is.null <- base::is.null
[16:21:07.309]                       muffled <- FALSE
[16:21:07.309]                       if (inherits(cond, "message")) {
[16:21:07.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.309]                         if (muffled) 
[16:21:07.309]                           invokeRestart("muffleMessage")
[16:21:07.309]                       }
[16:21:07.309]                       else if (inherits(cond, "warning")) {
[16:21:07.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.309]                         if (muffled) 
[16:21:07.309]                           invokeRestart("muffleWarning")
[16:21:07.309]                       }
[16:21:07.309]                       else if (inherits(cond, "condition")) {
[16:21:07.309]                         if (!is.null(pattern)) {
[16:21:07.309]                           computeRestarts <- base::computeRestarts
[16:21:07.309]                           grepl <- base::grepl
[16:21:07.309]                           restarts <- computeRestarts(cond)
[16:21:07.309]                           for (restart in restarts) {
[16:21:07.309]                             name <- restart$name
[16:21:07.309]                             if (is.null(name)) 
[16:21:07.309]                               next
[16:21:07.309]                             if (!grepl(pattern, name)) 
[16:21:07.309]                               next
[16:21:07.309]                             invokeRestart(restart)
[16:21:07.309]                             muffled <- TRUE
[16:21:07.309]                             break
[16:21:07.309]                           }
[16:21:07.309]                         }
[16:21:07.309]                       }
[16:21:07.309]                       invisible(muffled)
[16:21:07.309]                     }
[16:21:07.309]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.309]                   }
[16:21:07.309]                 }
[16:21:07.309]             }
[16:21:07.309]         }))
[16:21:07.309]     }, error = function(ex) {
[16:21:07.309]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.309]                 ...future.rng), started = ...future.startTime, 
[16:21:07.309]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.309]             version = "1.8"), class = "FutureResult")
[16:21:07.309]     }, finally = {
[16:21:07.309]         if (!identical(...future.workdir, getwd())) 
[16:21:07.309]             setwd(...future.workdir)
[16:21:07.309]         {
[16:21:07.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.309]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.309]             }
[16:21:07.309]             base::options(...future.oldOptions)
[16:21:07.309]             if (.Platform$OS.type == "windows") {
[16:21:07.309]                 old_names <- names(...future.oldEnvVars)
[16:21:07.309]                 envs <- base::Sys.getenv()
[16:21:07.309]                 names <- names(envs)
[16:21:07.309]                 common <- intersect(names, old_names)
[16:21:07.309]                 added <- setdiff(names, old_names)
[16:21:07.309]                 removed <- setdiff(old_names, names)
[16:21:07.309]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.309]                   envs[common]]
[16:21:07.309]                 NAMES <- toupper(changed)
[16:21:07.309]                 args <- list()
[16:21:07.309]                 for (kk in seq_along(NAMES)) {
[16:21:07.309]                   name <- changed[[kk]]
[16:21:07.309]                   NAME <- NAMES[[kk]]
[16:21:07.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.309]                     next
[16:21:07.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.309]                 }
[16:21:07.309]                 NAMES <- toupper(added)
[16:21:07.309]                 for (kk in seq_along(NAMES)) {
[16:21:07.309]                   name <- added[[kk]]
[16:21:07.309]                   NAME <- NAMES[[kk]]
[16:21:07.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.309]                     next
[16:21:07.309]                   args[[name]] <- ""
[16:21:07.309]                 }
[16:21:07.309]                 NAMES <- toupper(removed)
[16:21:07.309]                 for (kk in seq_along(NAMES)) {
[16:21:07.309]                   name <- removed[[kk]]
[16:21:07.309]                   NAME <- NAMES[[kk]]
[16:21:07.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.309]                     next
[16:21:07.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.309]                 }
[16:21:07.309]                 if (length(args) > 0) 
[16:21:07.309]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.309]             }
[16:21:07.309]             else {
[16:21:07.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.309]             }
[16:21:07.309]             {
[16:21:07.309]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.309]                   0L) {
[16:21:07.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.309]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.309]                   base::options(opts)
[16:21:07.309]                 }
[16:21:07.309]                 {
[16:21:07.309]                   {
[16:21:07.309]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.309]                     NULL
[16:21:07.309]                   }
[16:21:07.309]                   options(future.plan = NULL)
[16:21:07.309]                   if (is.na(NA_character_)) 
[16:21:07.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.309]                     .init = FALSE)
[16:21:07.309]                 }
[16:21:07.309]             }
[16:21:07.309]         }
[16:21:07.309]     })
[16:21:07.309]     if (TRUE) {
[16:21:07.309]         base::sink(type = "output", split = FALSE)
[16:21:07.309]         if (TRUE) {
[16:21:07.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.309]         }
[16:21:07.309]         else {
[16:21:07.309]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.309]         }
[16:21:07.309]         base::close(...future.stdout)
[16:21:07.309]         ...future.stdout <- NULL
[16:21:07.309]     }
[16:21:07.309]     ...future.result$conditions <- ...future.conditions
[16:21:07.309]     ...future.result$finished <- base::Sys.time()
[16:21:07.309]     ...future.result
[16:21:07.309] }
[16:21:07.312] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:21:07.312] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:21:07.315] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:21:07.315] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:21:07.316] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:21:07.316] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:21:07.316] MultisessionFuture started
[16:21:07.316] - Launch lazy future ... done
[16:21:07.316] run() for ‘MultisessionFuture’ ... done
[16:21:07.317] result() for ClusterFuture ...
[16:21:07.317] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.317] - Validating connection of MultisessionFuture
[16:21:07.318] - received message: FutureResult
[16:21:07.318] - Received FutureResult
[16:21:07.318] - Erased future from FutureRegistry
[16:21:07.318] result() for ClusterFuture ...
[16:21:07.318] - result already collected: FutureResult
[16:21:07.318] result() for ClusterFuture ... done
[16:21:07.318] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.318] result() for ClusterFuture ... done
[16:21:07.319] result() for ClusterFuture ...
[16:21:07.319] - result already collected: FutureResult
[16:21:07.319] result() for ClusterFuture ... done
[16:21:07.319] run() for ‘Future’ ...
[16:21:07.319] - state: ‘created’
[16:21:07.319] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.333] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.334]   - Field: ‘node’
[16:21:07.334]   - Field: ‘label’
[16:21:07.334]   - Field: ‘local’
[16:21:07.334]   - Field: ‘owner’
[16:21:07.334]   - Field: ‘envir’
[16:21:07.334]   - Field: ‘workers’
[16:21:07.334]   - Field: ‘packages’
[16:21:07.334]   - Field: ‘gc’
[16:21:07.334]   - Field: ‘conditions’
[16:21:07.335]   - Field: ‘persistent’
[16:21:07.335]   - Field: ‘expr’
[16:21:07.335]   - Field: ‘uuid’
[16:21:07.335]   - Field: ‘seed’
[16:21:07.335]   - Field: ‘version’
[16:21:07.335]   - Field: ‘result’
[16:21:07.335]   - Field: ‘asynchronous’
[16:21:07.335]   - Field: ‘calls’
[16:21:07.335]   - Field: ‘globals’
[16:21:07.335]   - Field: ‘stdout’
[16:21:07.335]   - Field: ‘earlySignal’
[16:21:07.335]   - Field: ‘lazy’
[16:21:07.336]   - Field: ‘state’
[16:21:07.336] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.336] - Launch lazy future ...
[16:21:07.336] Packages needed by the future expression (n = 0): <none>
[16:21:07.336] Packages needed by future strategies (n = 0): <none>
[16:21:07.337] {
[16:21:07.337]     {
[16:21:07.337]         {
[16:21:07.337]             ...future.startTime <- base::Sys.time()
[16:21:07.337]             {
[16:21:07.337]                 {
[16:21:07.337]                   {
[16:21:07.337]                     {
[16:21:07.337]                       base::local({
[16:21:07.337]                         has_future <- base::requireNamespace("future", 
[16:21:07.337]                           quietly = TRUE)
[16:21:07.337]                         if (has_future) {
[16:21:07.337]                           ns <- base::getNamespace("future")
[16:21:07.337]                           version <- ns[[".package"]][["version"]]
[16:21:07.337]                           if (is.null(version)) 
[16:21:07.337]                             version <- utils::packageVersion("future")
[16:21:07.337]                         }
[16:21:07.337]                         else {
[16:21:07.337]                           version <- NULL
[16:21:07.337]                         }
[16:21:07.337]                         if (!has_future || version < "1.8.0") {
[16:21:07.337]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.337]                             "", base::R.version$version.string), 
[16:21:07.337]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.337]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.337]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.337]                               "release", "version")], collapse = " "), 
[16:21:07.337]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.337]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.337]                             info)
[16:21:07.337]                           info <- base::paste(info, collapse = "; ")
[16:21:07.337]                           if (!has_future) {
[16:21:07.337]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.337]                               info)
[16:21:07.337]                           }
[16:21:07.337]                           else {
[16:21:07.337]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.337]                               info, version)
[16:21:07.337]                           }
[16:21:07.337]                           base::stop(msg)
[16:21:07.337]                         }
[16:21:07.337]                       })
[16:21:07.337]                     }
[16:21:07.337]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.337]                     base::options(mc.cores = 1L)
[16:21:07.337]                   }
[16:21:07.337]                   ...future.strategy.old <- future::plan("list")
[16:21:07.337]                   options(future.plan = NULL)
[16:21:07.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.337]                 }
[16:21:07.337]                 ...future.workdir <- getwd()
[16:21:07.337]             }
[16:21:07.337]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.337]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.337]         }
[16:21:07.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.337]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.337]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.337]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.337]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.337]             base::names(...future.oldOptions))
[16:21:07.337]     }
[16:21:07.337]     if (FALSE) {
[16:21:07.337]     }
[16:21:07.337]     else {
[16:21:07.337]         if (TRUE) {
[16:21:07.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.337]                 open = "w")
[16:21:07.337]         }
[16:21:07.337]         else {
[16:21:07.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.337]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.337]         }
[16:21:07.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.337]             base::sink(type = "output", split = FALSE)
[16:21:07.337]             base::close(...future.stdout)
[16:21:07.337]         }, add = TRUE)
[16:21:07.337]     }
[16:21:07.337]     ...future.frame <- base::sys.nframe()
[16:21:07.337]     ...future.conditions <- base::list()
[16:21:07.337]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.337]     if (FALSE) {
[16:21:07.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.337]     }
[16:21:07.337]     ...future.result <- base::tryCatch({
[16:21:07.337]         base::withCallingHandlers({
[16:21:07.337]             ...future.value <- base::withVisible(base::local({
[16:21:07.337]                 ...future.makeSendCondition <- base::local({
[16:21:07.337]                   sendCondition <- NULL
[16:21:07.337]                   function(frame = 1L) {
[16:21:07.337]                     if (is.function(sendCondition)) 
[16:21:07.337]                       return(sendCondition)
[16:21:07.337]                     ns <- getNamespace("parallel")
[16:21:07.337]                     if (exists("sendData", mode = "function", 
[16:21:07.337]                       envir = ns)) {
[16:21:07.337]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.337]                         envir = ns)
[16:21:07.337]                       envir <- sys.frame(frame)
[16:21:07.337]                       master <- NULL
[16:21:07.337]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.337]                         !identical(envir, emptyenv())) {
[16:21:07.337]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.337]                           inherits = FALSE)) {
[16:21:07.337]                           master <- get("master", mode = "list", 
[16:21:07.337]                             envir = envir, inherits = FALSE)
[16:21:07.337]                           if (inherits(master, c("SOCKnode", 
[16:21:07.337]                             "SOCK0node"))) {
[16:21:07.337]                             sendCondition <<- function(cond) {
[16:21:07.337]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.337]                                 success = TRUE)
[16:21:07.337]                               parallel_sendData(master, data)
[16:21:07.337]                             }
[16:21:07.337]                             return(sendCondition)
[16:21:07.337]                           }
[16:21:07.337]                         }
[16:21:07.337]                         frame <- frame + 1L
[16:21:07.337]                         envir <- sys.frame(frame)
[16:21:07.337]                       }
[16:21:07.337]                     }
[16:21:07.337]                     sendCondition <<- function(cond) NULL
[16:21:07.337]                   }
[16:21:07.337]                 })
[16:21:07.337]                 withCallingHandlers({
[16:21:07.337]                   {
[16:21:07.337]                     b <- a * ii
[16:21:07.337]                     a <- 0
[16:21:07.337]                     b
[16:21:07.337]                   }
[16:21:07.337]                 }, immediateCondition = function(cond) {
[16:21:07.337]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.337]                   sendCondition(cond)
[16:21:07.337]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.337]                   {
[16:21:07.337]                     inherits <- base::inherits
[16:21:07.337]                     invokeRestart <- base::invokeRestart
[16:21:07.337]                     is.null <- base::is.null
[16:21:07.337]                     muffled <- FALSE
[16:21:07.337]                     if (inherits(cond, "message")) {
[16:21:07.337]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.337]                       if (muffled) 
[16:21:07.337]                         invokeRestart("muffleMessage")
[16:21:07.337]                     }
[16:21:07.337]                     else if (inherits(cond, "warning")) {
[16:21:07.337]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.337]                       if (muffled) 
[16:21:07.337]                         invokeRestart("muffleWarning")
[16:21:07.337]                     }
[16:21:07.337]                     else if (inherits(cond, "condition")) {
[16:21:07.337]                       if (!is.null(pattern)) {
[16:21:07.337]                         computeRestarts <- base::computeRestarts
[16:21:07.337]                         grepl <- base::grepl
[16:21:07.337]                         restarts <- computeRestarts(cond)
[16:21:07.337]                         for (restart in restarts) {
[16:21:07.337]                           name <- restart$name
[16:21:07.337]                           if (is.null(name)) 
[16:21:07.337]                             next
[16:21:07.337]                           if (!grepl(pattern, name)) 
[16:21:07.337]                             next
[16:21:07.337]                           invokeRestart(restart)
[16:21:07.337]                           muffled <- TRUE
[16:21:07.337]                           break
[16:21:07.337]                         }
[16:21:07.337]                       }
[16:21:07.337]                     }
[16:21:07.337]                     invisible(muffled)
[16:21:07.337]                   }
[16:21:07.337]                   muffleCondition(cond)
[16:21:07.337]                 })
[16:21:07.337]             }))
[16:21:07.337]             future::FutureResult(value = ...future.value$value, 
[16:21:07.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.337]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.337]                     ...future.globalenv.names))
[16:21:07.337]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.337]         }, condition = base::local({
[16:21:07.337]             c <- base::c
[16:21:07.337]             inherits <- base::inherits
[16:21:07.337]             invokeRestart <- base::invokeRestart
[16:21:07.337]             length <- base::length
[16:21:07.337]             list <- base::list
[16:21:07.337]             seq.int <- base::seq.int
[16:21:07.337]             signalCondition <- base::signalCondition
[16:21:07.337]             sys.calls <- base::sys.calls
[16:21:07.337]             `[[` <- base::`[[`
[16:21:07.337]             `+` <- base::`+`
[16:21:07.337]             `<<-` <- base::`<<-`
[16:21:07.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.337]                   3L)]
[16:21:07.337]             }
[16:21:07.337]             function(cond) {
[16:21:07.337]                 is_error <- inherits(cond, "error")
[16:21:07.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.337]                   NULL)
[16:21:07.337]                 if (is_error) {
[16:21:07.337]                   sessionInformation <- function() {
[16:21:07.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.337]                       search = base::search(), system = base::Sys.info())
[16:21:07.337]                   }
[16:21:07.337]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.337]                     cond$call), session = sessionInformation(), 
[16:21:07.337]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.337]                   signalCondition(cond)
[16:21:07.337]                 }
[16:21:07.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.337]                 "immediateCondition"))) {
[16:21:07.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.337]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.337]                   if (TRUE && !signal) {
[16:21:07.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.337]                     {
[16:21:07.337]                       inherits <- base::inherits
[16:21:07.337]                       invokeRestart <- base::invokeRestart
[16:21:07.337]                       is.null <- base::is.null
[16:21:07.337]                       muffled <- FALSE
[16:21:07.337]                       if (inherits(cond, "message")) {
[16:21:07.337]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.337]                         if (muffled) 
[16:21:07.337]                           invokeRestart("muffleMessage")
[16:21:07.337]                       }
[16:21:07.337]                       else if (inherits(cond, "warning")) {
[16:21:07.337]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.337]                         if (muffled) 
[16:21:07.337]                           invokeRestart("muffleWarning")
[16:21:07.337]                       }
[16:21:07.337]                       else if (inherits(cond, "condition")) {
[16:21:07.337]                         if (!is.null(pattern)) {
[16:21:07.337]                           computeRestarts <- base::computeRestarts
[16:21:07.337]                           grepl <- base::grepl
[16:21:07.337]                           restarts <- computeRestarts(cond)
[16:21:07.337]                           for (restart in restarts) {
[16:21:07.337]                             name <- restart$name
[16:21:07.337]                             if (is.null(name)) 
[16:21:07.337]                               next
[16:21:07.337]                             if (!grepl(pattern, name)) 
[16:21:07.337]                               next
[16:21:07.337]                             invokeRestart(restart)
[16:21:07.337]                             muffled <- TRUE
[16:21:07.337]                             break
[16:21:07.337]                           }
[16:21:07.337]                         }
[16:21:07.337]                       }
[16:21:07.337]                       invisible(muffled)
[16:21:07.337]                     }
[16:21:07.337]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.337]                   }
[16:21:07.337]                 }
[16:21:07.337]                 else {
[16:21:07.337]                   if (TRUE) {
[16:21:07.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.337]                     {
[16:21:07.337]                       inherits <- base::inherits
[16:21:07.337]                       invokeRestart <- base::invokeRestart
[16:21:07.337]                       is.null <- base::is.null
[16:21:07.337]                       muffled <- FALSE
[16:21:07.337]                       if (inherits(cond, "message")) {
[16:21:07.337]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.337]                         if (muffled) 
[16:21:07.337]                           invokeRestart("muffleMessage")
[16:21:07.337]                       }
[16:21:07.337]                       else if (inherits(cond, "warning")) {
[16:21:07.337]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.337]                         if (muffled) 
[16:21:07.337]                           invokeRestart("muffleWarning")
[16:21:07.337]                       }
[16:21:07.337]                       else if (inherits(cond, "condition")) {
[16:21:07.337]                         if (!is.null(pattern)) {
[16:21:07.337]                           computeRestarts <- base::computeRestarts
[16:21:07.337]                           grepl <- base::grepl
[16:21:07.337]                           restarts <- computeRestarts(cond)
[16:21:07.337]                           for (restart in restarts) {
[16:21:07.337]                             name <- restart$name
[16:21:07.337]                             if (is.null(name)) 
[16:21:07.337]                               next
[16:21:07.337]                             if (!grepl(pattern, name)) 
[16:21:07.337]                               next
[16:21:07.337]                             invokeRestart(restart)
[16:21:07.337]                             muffled <- TRUE
[16:21:07.337]                             break
[16:21:07.337]                           }
[16:21:07.337]                         }
[16:21:07.337]                       }
[16:21:07.337]                       invisible(muffled)
[16:21:07.337]                     }
[16:21:07.337]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.337]                   }
[16:21:07.337]                 }
[16:21:07.337]             }
[16:21:07.337]         }))
[16:21:07.337]     }, error = function(ex) {
[16:21:07.337]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.337]                 ...future.rng), started = ...future.startTime, 
[16:21:07.337]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.337]             version = "1.8"), class = "FutureResult")
[16:21:07.337]     }, finally = {
[16:21:07.337]         if (!identical(...future.workdir, getwd())) 
[16:21:07.337]             setwd(...future.workdir)
[16:21:07.337]         {
[16:21:07.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.337]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.337]             }
[16:21:07.337]             base::options(...future.oldOptions)
[16:21:07.337]             if (.Platform$OS.type == "windows") {
[16:21:07.337]                 old_names <- names(...future.oldEnvVars)
[16:21:07.337]                 envs <- base::Sys.getenv()
[16:21:07.337]                 names <- names(envs)
[16:21:07.337]                 common <- intersect(names, old_names)
[16:21:07.337]                 added <- setdiff(names, old_names)
[16:21:07.337]                 removed <- setdiff(old_names, names)
[16:21:07.337]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.337]                   envs[common]]
[16:21:07.337]                 NAMES <- toupper(changed)
[16:21:07.337]                 args <- list()
[16:21:07.337]                 for (kk in seq_along(NAMES)) {
[16:21:07.337]                   name <- changed[[kk]]
[16:21:07.337]                   NAME <- NAMES[[kk]]
[16:21:07.337]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.337]                     next
[16:21:07.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.337]                 }
[16:21:07.337]                 NAMES <- toupper(added)
[16:21:07.337]                 for (kk in seq_along(NAMES)) {
[16:21:07.337]                   name <- added[[kk]]
[16:21:07.337]                   NAME <- NAMES[[kk]]
[16:21:07.337]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.337]                     next
[16:21:07.337]                   args[[name]] <- ""
[16:21:07.337]                 }
[16:21:07.337]                 NAMES <- toupper(removed)
[16:21:07.337]                 for (kk in seq_along(NAMES)) {
[16:21:07.337]                   name <- removed[[kk]]
[16:21:07.337]                   NAME <- NAMES[[kk]]
[16:21:07.337]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.337]                     next
[16:21:07.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.337]                 }
[16:21:07.337]                 if (length(args) > 0) 
[16:21:07.337]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.337]             }
[16:21:07.337]             else {
[16:21:07.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.337]             }
[16:21:07.337]             {
[16:21:07.337]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.337]                   0L) {
[16:21:07.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.337]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.337]                   base::options(opts)
[16:21:07.337]                 }
[16:21:07.337]                 {
[16:21:07.337]                   {
[16:21:07.337]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.337]                     NULL
[16:21:07.337]                   }
[16:21:07.337]                   options(future.plan = NULL)
[16:21:07.337]                   if (is.na(NA_character_)) 
[16:21:07.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.337]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.337]                     .init = FALSE)
[16:21:07.337]                 }
[16:21:07.337]             }
[16:21:07.337]         }
[16:21:07.337]     })
[16:21:07.337]     if (TRUE) {
[16:21:07.337]         base::sink(type = "output", split = FALSE)
[16:21:07.337]         if (TRUE) {
[16:21:07.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.337]         }
[16:21:07.337]         else {
[16:21:07.337]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.337]         }
[16:21:07.337]         base::close(...future.stdout)
[16:21:07.337]         ...future.stdout <- NULL
[16:21:07.337]     }
[16:21:07.337]     ...future.result$conditions <- ...future.conditions
[16:21:07.337]     ...future.result$finished <- base::Sys.time()
[16:21:07.337]     ...future.result
[16:21:07.337] }
[16:21:07.339] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:21:07.339] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:21:07.339] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:21:07.340] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:21:07.340] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:21:07.340] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:21:07.341] MultisessionFuture started
[16:21:07.341] - Launch lazy future ... done
[16:21:07.341] run() for ‘MultisessionFuture’ ... done
[16:21:07.341] result() for ClusterFuture ...
[16:21:07.341] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.341] - Validating connection of MultisessionFuture
[16:21:07.342] - received message: FutureResult
[16:21:07.342] - Received FutureResult
[16:21:07.342] - Erased future from FutureRegistry
[16:21:07.342] result() for ClusterFuture ...
[16:21:07.342] - result already collected: FutureResult
[16:21:07.342] result() for ClusterFuture ... done
[16:21:07.343] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.343] result() for ClusterFuture ... done
[16:21:07.343] result() for ClusterFuture ...
[16:21:07.343] - result already collected: FutureResult
[16:21:07.343] result() for ClusterFuture ... done
[16:21:07.343] run() for ‘Future’ ...
[16:21:07.343] - state: ‘created’
[16:21:07.343] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.358]   - Field: ‘node’
[16:21:07.358]   - Field: ‘label’
[16:21:07.358]   - Field: ‘local’
[16:21:07.358]   - Field: ‘owner’
[16:21:07.358]   - Field: ‘envir’
[16:21:07.358]   - Field: ‘workers’
[16:21:07.358]   - Field: ‘packages’
[16:21:07.358]   - Field: ‘gc’
[16:21:07.358]   - Field: ‘conditions’
[16:21:07.358]   - Field: ‘persistent’
[16:21:07.359]   - Field: ‘expr’
[16:21:07.359]   - Field: ‘uuid’
[16:21:07.359]   - Field: ‘seed’
[16:21:07.359]   - Field: ‘version’
[16:21:07.359]   - Field: ‘result’
[16:21:07.359]   - Field: ‘asynchronous’
[16:21:07.359]   - Field: ‘calls’
[16:21:07.359]   - Field: ‘globals’
[16:21:07.359]   - Field: ‘stdout’
[16:21:07.359]   - Field: ‘earlySignal’
[16:21:07.359]   - Field: ‘lazy’
[16:21:07.360]   - Field: ‘state’
[16:21:07.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.360] - Launch lazy future ...
[16:21:07.360] Packages needed by the future expression (n = 0): <none>
[16:21:07.360] Packages needed by future strategies (n = 0): <none>
[16:21:07.361] {
[16:21:07.361]     {
[16:21:07.361]         {
[16:21:07.361]             ...future.startTime <- base::Sys.time()
[16:21:07.361]             {
[16:21:07.361]                 {
[16:21:07.361]                   {
[16:21:07.361]                     {
[16:21:07.361]                       base::local({
[16:21:07.361]                         has_future <- base::requireNamespace("future", 
[16:21:07.361]                           quietly = TRUE)
[16:21:07.361]                         if (has_future) {
[16:21:07.361]                           ns <- base::getNamespace("future")
[16:21:07.361]                           version <- ns[[".package"]][["version"]]
[16:21:07.361]                           if (is.null(version)) 
[16:21:07.361]                             version <- utils::packageVersion("future")
[16:21:07.361]                         }
[16:21:07.361]                         else {
[16:21:07.361]                           version <- NULL
[16:21:07.361]                         }
[16:21:07.361]                         if (!has_future || version < "1.8.0") {
[16:21:07.361]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.361]                             "", base::R.version$version.string), 
[16:21:07.361]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.361]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.361]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.361]                               "release", "version")], collapse = " "), 
[16:21:07.361]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.361]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.361]                             info)
[16:21:07.361]                           info <- base::paste(info, collapse = "; ")
[16:21:07.361]                           if (!has_future) {
[16:21:07.361]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.361]                               info)
[16:21:07.361]                           }
[16:21:07.361]                           else {
[16:21:07.361]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.361]                               info, version)
[16:21:07.361]                           }
[16:21:07.361]                           base::stop(msg)
[16:21:07.361]                         }
[16:21:07.361]                       })
[16:21:07.361]                     }
[16:21:07.361]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.361]                     base::options(mc.cores = 1L)
[16:21:07.361]                   }
[16:21:07.361]                   ...future.strategy.old <- future::plan("list")
[16:21:07.361]                   options(future.plan = NULL)
[16:21:07.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.361]                 }
[16:21:07.361]                 ...future.workdir <- getwd()
[16:21:07.361]             }
[16:21:07.361]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.361]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.361]         }
[16:21:07.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.361]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.361]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.361]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.361]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.361]             base::names(...future.oldOptions))
[16:21:07.361]     }
[16:21:07.361]     if (FALSE) {
[16:21:07.361]     }
[16:21:07.361]     else {
[16:21:07.361]         if (TRUE) {
[16:21:07.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.361]                 open = "w")
[16:21:07.361]         }
[16:21:07.361]         else {
[16:21:07.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.361]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.361]         }
[16:21:07.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.361]             base::sink(type = "output", split = FALSE)
[16:21:07.361]             base::close(...future.stdout)
[16:21:07.361]         }, add = TRUE)
[16:21:07.361]     }
[16:21:07.361]     ...future.frame <- base::sys.nframe()
[16:21:07.361]     ...future.conditions <- base::list()
[16:21:07.361]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.361]     if (FALSE) {
[16:21:07.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.361]     }
[16:21:07.361]     ...future.result <- base::tryCatch({
[16:21:07.361]         base::withCallingHandlers({
[16:21:07.361]             ...future.value <- base::withVisible(base::local({
[16:21:07.361]                 ...future.makeSendCondition <- base::local({
[16:21:07.361]                   sendCondition <- NULL
[16:21:07.361]                   function(frame = 1L) {
[16:21:07.361]                     if (is.function(sendCondition)) 
[16:21:07.361]                       return(sendCondition)
[16:21:07.361]                     ns <- getNamespace("parallel")
[16:21:07.361]                     if (exists("sendData", mode = "function", 
[16:21:07.361]                       envir = ns)) {
[16:21:07.361]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.361]                         envir = ns)
[16:21:07.361]                       envir <- sys.frame(frame)
[16:21:07.361]                       master <- NULL
[16:21:07.361]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.361]                         !identical(envir, emptyenv())) {
[16:21:07.361]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.361]                           inherits = FALSE)) {
[16:21:07.361]                           master <- get("master", mode = "list", 
[16:21:07.361]                             envir = envir, inherits = FALSE)
[16:21:07.361]                           if (inherits(master, c("SOCKnode", 
[16:21:07.361]                             "SOCK0node"))) {
[16:21:07.361]                             sendCondition <<- function(cond) {
[16:21:07.361]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.361]                                 success = TRUE)
[16:21:07.361]                               parallel_sendData(master, data)
[16:21:07.361]                             }
[16:21:07.361]                             return(sendCondition)
[16:21:07.361]                           }
[16:21:07.361]                         }
[16:21:07.361]                         frame <- frame + 1L
[16:21:07.361]                         envir <- sys.frame(frame)
[16:21:07.361]                       }
[16:21:07.361]                     }
[16:21:07.361]                     sendCondition <<- function(cond) NULL
[16:21:07.361]                   }
[16:21:07.361]                 })
[16:21:07.361]                 withCallingHandlers({
[16:21:07.361]                   {
[16:21:07.361]                     b <- a * ii
[16:21:07.361]                     a <- 0
[16:21:07.361]                     b
[16:21:07.361]                   }
[16:21:07.361]                 }, immediateCondition = function(cond) {
[16:21:07.361]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.361]                   sendCondition(cond)
[16:21:07.361]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.361]                   {
[16:21:07.361]                     inherits <- base::inherits
[16:21:07.361]                     invokeRestart <- base::invokeRestart
[16:21:07.361]                     is.null <- base::is.null
[16:21:07.361]                     muffled <- FALSE
[16:21:07.361]                     if (inherits(cond, "message")) {
[16:21:07.361]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.361]                       if (muffled) 
[16:21:07.361]                         invokeRestart("muffleMessage")
[16:21:07.361]                     }
[16:21:07.361]                     else if (inherits(cond, "warning")) {
[16:21:07.361]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.361]                       if (muffled) 
[16:21:07.361]                         invokeRestart("muffleWarning")
[16:21:07.361]                     }
[16:21:07.361]                     else if (inherits(cond, "condition")) {
[16:21:07.361]                       if (!is.null(pattern)) {
[16:21:07.361]                         computeRestarts <- base::computeRestarts
[16:21:07.361]                         grepl <- base::grepl
[16:21:07.361]                         restarts <- computeRestarts(cond)
[16:21:07.361]                         for (restart in restarts) {
[16:21:07.361]                           name <- restart$name
[16:21:07.361]                           if (is.null(name)) 
[16:21:07.361]                             next
[16:21:07.361]                           if (!grepl(pattern, name)) 
[16:21:07.361]                             next
[16:21:07.361]                           invokeRestart(restart)
[16:21:07.361]                           muffled <- TRUE
[16:21:07.361]                           break
[16:21:07.361]                         }
[16:21:07.361]                       }
[16:21:07.361]                     }
[16:21:07.361]                     invisible(muffled)
[16:21:07.361]                   }
[16:21:07.361]                   muffleCondition(cond)
[16:21:07.361]                 })
[16:21:07.361]             }))
[16:21:07.361]             future::FutureResult(value = ...future.value$value, 
[16:21:07.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.361]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.361]                     ...future.globalenv.names))
[16:21:07.361]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.361]         }, condition = base::local({
[16:21:07.361]             c <- base::c
[16:21:07.361]             inherits <- base::inherits
[16:21:07.361]             invokeRestart <- base::invokeRestart
[16:21:07.361]             length <- base::length
[16:21:07.361]             list <- base::list
[16:21:07.361]             seq.int <- base::seq.int
[16:21:07.361]             signalCondition <- base::signalCondition
[16:21:07.361]             sys.calls <- base::sys.calls
[16:21:07.361]             `[[` <- base::`[[`
[16:21:07.361]             `+` <- base::`+`
[16:21:07.361]             `<<-` <- base::`<<-`
[16:21:07.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.361]                   3L)]
[16:21:07.361]             }
[16:21:07.361]             function(cond) {
[16:21:07.361]                 is_error <- inherits(cond, "error")
[16:21:07.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.361]                   NULL)
[16:21:07.361]                 if (is_error) {
[16:21:07.361]                   sessionInformation <- function() {
[16:21:07.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.361]                       search = base::search(), system = base::Sys.info())
[16:21:07.361]                   }
[16:21:07.361]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.361]                     cond$call), session = sessionInformation(), 
[16:21:07.361]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.361]                   signalCondition(cond)
[16:21:07.361]                 }
[16:21:07.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.361]                 "immediateCondition"))) {
[16:21:07.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.361]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.361]                   if (TRUE && !signal) {
[16:21:07.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.361]                     {
[16:21:07.361]                       inherits <- base::inherits
[16:21:07.361]                       invokeRestart <- base::invokeRestart
[16:21:07.361]                       is.null <- base::is.null
[16:21:07.361]                       muffled <- FALSE
[16:21:07.361]                       if (inherits(cond, "message")) {
[16:21:07.361]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.361]                         if (muffled) 
[16:21:07.361]                           invokeRestart("muffleMessage")
[16:21:07.361]                       }
[16:21:07.361]                       else if (inherits(cond, "warning")) {
[16:21:07.361]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.361]                         if (muffled) 
[16:21:07.361]                           invokeRestart("muffleWarning")
[16:21:07.361]                       }
[16:21:07.361]                       else if (inherits(cond, "condition")) {
[16:21:07.361]                         if (!is.null(pattern)) {
[16:21:07.361]                           computeRestarts <- base::computeRestarts
[16:21:07.361]                           grepl <- base::grepl
[16:21:07.361]                           restarts <- computeRestarts(cond)
[16:21:07.361]                           for (restart in restarts) {
[16:21:07.361]                             name <- restart$name
[16:21:07.361]                             if (is.null(name)) 
[16:21:07.361]                               next
[16:21:07.361]                             if (!grepl(pattern, name)) 
[16:21:07.361]                               next
[16:21:07.361]                             invokeRestart(restart)
[16:21:07.361]                             muffled <- TRUE
[16:21:07.361]                             break
[16:21:07.361]                           }
[16:21:07.361]                         }
[16:21:07.361]                       }
[16:21:07.361]                       invisible(muffled)
[16:21:07.361]                     }
[16:21:07.361]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.361]                   }
[16:21:07.361]                 }
[16:21:07.361]                 else {
[16:21:07.361]                   if (TRUE) {
[16:21:07.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.361]                     {
[16:21:07.361]                       inherits <- base::inherits
[16:21:07.361]                       invokeRestart <- base::invokeRestart
[16:21:07.361]                       is.null <- base::is.null
[16:21:07.361]                       muffled <- FALSE
[16:21:07.361]                       if (inherits(cond, "message")) {
[16:21:07.361]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.361]                         if (muffled) 
[16:21:07.361]                           invokeRestart("muffleMessage")
[16:21:07.361]                       }
[16:21:07.361]                       else if (inherits(cond, "warning")) {
[16:21:07.361]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.361]                         if (muffled) 
[16:21:07.361]                           invokeRestart("muffleWarning")
[16:21:07.361]                       }
[16:21:07.361]                       else if (inherits(cond, "condition")) {
[16:21:07.361]                         if (!is.null(pattern)) {
[16:21:07.361]                           computeRestarts <- base::computeRestarts
[16:21:07.361]                           grepl <- base::grepl
[16:21:07.361]                           restarts <- computeRestarts(cond)
[16:21:07.361]                           for (restart in restarts) {
[16:21:07.361]                             name <- restart$name
[16:21:07.361]                             if (is.null(name)) 
[16:21:07.361]                               next
[16:21:07.361]                             if (!grepl(pattern, name)) 
[16:21:07.361]                               next
[16:21:07.361]                             invokeRestart(restart)
[16:21:07.361]                             muffled <- TRUE
[16:21:07.361]                             break
[16:21:07.361]                           }
[16:21:07.361]                         }
[16:21:07.361]                       }
[16:21:07.361]                       invisible(muffled)
[16:21:07.361]                     }
[16:21:07.361]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.361]                   }
[16:21:07.361]                 }
[16:21:07.361]             }
[16:21:07.361]         }))
[16:21:07.361]     }, error = function(ex) {
[16:21:07.361]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.361]                 ...future.rng), started = ...future.startTime, 
[16:21:07.361]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.361]             version = "1.8"), class = "FutureResult")
[16:21:07.361]     }, finally = {
[16:21:07.361]         if (!identical(...future.workdir, getwd())) 
[16:21:07.361]             setwd(...future.workdir)
[16:21:07.361]         {
[16:21:07.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.361]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.361]             }
[16:21:07.361]             base::options(...future.oldOptions)
[16:21:07.361]             if (.Platform$OS.type == "windows") {
[16:21:07.361]                 old_names <- names(...future.oldEnvVars)
[16:21:07.361]                 envs <- base::Sys.getenv()
[16:21:07.361]                 names <- names(envs)
[16:21:07.361]                 common <- intersect(names, old_names)
[16:21:07.361]                 added <- setdiff(names, old_names)
[16:21:07.361]                 removed <- setdiff(old_names, names)
[16:21:07.361]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.361]                   envs[common]]
[16:21:07.361]                 NAMES <- toupper(changed)
[16:21:07.361]                 args <- list()
[16:21:07.361]                 for (kk in seq_along(NAMES)) {
[16:21:07.361]                   name <- changed[[kk]]
[16:21:07.361]                   NAME <- NAMES[[kk]]
[16:21:07.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.361]                     next
[16:21:07.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.361]                 }
[16:21:07.361]                 NAMES <- toupper(added)
[16:21:07.361]                 for (kk in seq_along(NAMES)) {
[16:21:07.361]                   name <- added[[kk]]
[16:21:07.361]                   NAME <- NAMES[[kk]]
[16:21:07.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.361]                     next
[16:21:07.361]                   args[[name]] <- ""
[16:21:07.361]                 }
[16:21:07.361]                 NAMES <- toupper(removed)
[16:21:07.361]                 for (kk in seq_along(NAMES)) {
[16:21:07.361]                   name <- removed[[kk]]
[16:21:07.361]                   NAME <- NAMES[[kk]]
[16:21:07.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.361]                     next
[16:21:07.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.361]                 }
[16:21:07.361]                 if (length(args) > 0) 
[16:21:07.361]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.361]             }
[16:21:07.361]             else {
[16:21:07.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.361]             }
[16:21:07.361]             {
[16:21:07.361]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.361]                   0L) {
[16:21:07.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.361]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.361]                   base::options(opts)
[16:21:07.361]                 }
[16:21:07.361]                 {
[16:21:07.361]                   {
[16:21:07.361]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.361]                     NULL
[16:21:07.361]                   }
[16:21:07.361]                   options(future.plan = NULL)
[16:21:07.361]                   if (is.na(NA_character_)) 
[16:21:07.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.361]                     .init = FALSE)
[16:21:07.361]                 }
[16:21:07.361]             }
[16:21:07.361]         }
[16:21:07.361]     })
[16:21:07.361]     if (TRUE) {
[16:21:07.361]         base::sink(type = "output", split = FALSE)
[16:21:07.361]         if (TRUE) {
[16:21:07.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.361]         }
[16:21:07.361]         else {
[16:21:07.361]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.361]         }
[16:21:07.361]         base::close(...future.stdout)
[16:21:07.361]         ...future.stdout <- NULL
[16:21:07.361]     }
[16:21:07.361]     ...future.result$conditions <- ...future.conditions
[16:21:07.361]     ...future.result$finished <- base::Sys.time()
[16:21:07.361]     ...future.result
[16:21:07.361] }
[16:21:07.363] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:21:07.363] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:21:07.363] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:21:07.364] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:21:07.364] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:21:07.364] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:21:07.365] MultisessionFuture started
[16:21:07.365] - Launch lazy future ... done
[16:21:07.365] run() for ‘MultisessionFuture’ ... done
[16:21:07.365] result() for ClusterFuture ...
[16:21:07.365] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.365] - Validating connection of MultisessionFuture
[16:21:07.366] - received message: FutureResult
[16:21:07.366] - Received FutureResult
[16:21:07.366] - Erased future from FutureRegistry
[16:21:07.366] result() for ClusterFuture ...
[16:21:07.366] - result already collected: FutureResult
[16:21:07.366] result() for ClusterFuture ... done
[16:21:07.367] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.367] result() for ClusterFuture ... done
[16:21:07.367] result() for ClusterFuture ...
[16:21:07.367] - result already collected: FutureResult
[16:21:07.367] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.367] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.367] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.368] 
[16:21:07.368] Searching for globals ... DONE
[16:21:07.368] - globals: [0] <none>
[16:21:07.368] getGlobalsAndPackages() ... DONE
[16:21:07.368] run() for ‘Future’ ...
[16:21:07.369] - state: ‘created’
[16:21:07.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.382] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.382]   - Field: ‘node’
[16:21:07.382]   - Field: ‘label’
[16:21:07.383]   - Field: ‘local’
[16:21:07.383]   - Field: ‘owner’
[16:21:07.383]   - Field: ‘envir’
[16:21:07.383]   - Field: ‘workers’
[16:21:07.383]   - Field: ‘packages’
[16:21:07.383]   - Field: ‘gc’
[16:21:07.383]   - Field: ‘conditions’
[16:21:07.383]   - Field: ‘persistent’
[16:21:07.383]   - Field: ‘expr’
[16:21:07.383]   - Field: ‘uuid’
[16:21:07.384]   - Field: ‘seed’
[16:21:07.384]   - Field: ‘version’
[16:21:07.384]   - Field: ‘result’
[16:21:07.384]   - Field: ‘asynchronous’
[16:21:07.384]   - Field: ‘calls’
[16:21:07.384]   - Field: ‘globals’
[16:21:07.384]   - Field: ‘stdout’
[16:21:07.384]   - Field: ‘earlySignal’
[16:21:07.384]   - Field: ‘lazy’
[16:21:07.384]   - Field: ‘state’
[16:21:07.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.385] - Launch lazy future ...
[16:21:07.385] Packages needed by the future expression (n = 0): <none>
[16:21:07.385] Packages needed by future strategies (n = 0): <none>
[16:21:07.385] {
[16:21:07.385]     {
[16:21:07.385]         {
[16:21:07.385]             ...future.startTime <- base::Sys.time()
[16:21:07.385]             {
[16:21:07.385]                 {
[16:21:07.385]                   {
[16:21:07.385]                     {
[16:21:07.385]                       base::local({
[16:21:07.385]                         has_future <- base::requireNamespace("future", 
[16:21:07.385]                           quietly = TRUE)
[16:21:07.385]                         if (has_future) {
[16:21:07.385]                           ns <- base::getNamespace("future")
[16:21:07.385]                           version <- ns[[".package"]][["version"]]
[16:21:07.385]                           if (is.null(version)) 
[16:21:07.385]                             version <- utils::packageVersion("future")
[16:21:07.385]                         }
[16:21:07.385]                         else {
[16:21:07.385]                           version <- NULL
[16:21:07.385]                         }
[16:21:07.385]                         if (!has_future || version < "1.8.0") {
[16:21:07.385]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.385]                             "", base::R.version$version.string), 
[16:21:07.385]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.385]                               "release", "version")], collapse = " "), 
[16:21:07.385]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.385]                             info)
[16:21:07.385]                           info <- base::paste(info, collapse = "; ")
[16:21:07.385]                           if (!has_future) {
[16:21:07.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.385]                               info)
[16:21:07.385]                           }
[16:21:07.385]                           else {
[16:21:07.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.385]                               info, version)
[16:21:07.385]                           }
[16:21:07.385]                           base::stop(msg)
[16:21:07.385]                         }
[16:21:07.385]                       })
[16:21:07.385]                     }
[16:21:07.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.385]                     base::options(mc.cores = 1L)
[16:21:07.385]                   }
[16:21:07.385]                   ...future.strategy.old <- future::plan("list")
[16:21:07.385]                   options(future.plan = NULL)
[16:21:07.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.385]                 }
[16:21:07.385]                 ...future.workdir <- getwd()
[16:21:07.385]             }
[16:21:07.385]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.385]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.385]         }
[16:21:07.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.385]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.385]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.385]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.385]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.385]             base::names(...future.oldOptions))
[16:21:07.385]     }
[16:21:07.385]     if (FALSE) {
[16:21:07.385]     }
[16:21:07.385]     else {
[16:21:07.385]         if (TRUE) {
[16:21:07.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.385]                 open = "w")
[16:21:07.385]         }
[16:21:07.385]         else {
[16:21:07.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.385]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.385]         }
[16:21:07.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.385]             base::sink(type = "output", split = FALSE)
[16:21:07.385]             base::close(...future.stdout)
[16:21:07.385]         }, add = TRUE)
[16:21:07.385]     }
[16:21:07.385]     ...future.frame <- base::sys.nframe()
[16:21:07.385]     ...future.conditions <- base::list()
[16:21:07.385]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.385]     if (FALSE) {
[16:21:07.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.385]     }
[16:21:07.385]     ...future.result <- base::tryCatch({
[16:21:07.385]         base::withCallingHandlers({
[16:21:07.385]             ...future.value <- base::withVisible(base::local({
[16:21:07.385]                 ...future.makeSendCondition <- base::local({
[16:21:07.385]                   sendCondition <- NULL
[16:21:07.385]                   function(frame = 1L) {
[16:21:07.385]                     if (is.function(sendCondition)) 
[16:21:07.385]                       return(sendCondition)
[16:21:07.385]                     ns <- getNamespace("parallel")
[16:21:07.385]                     if (exists("sendData", mode = "function", 
[16:21:07.385]                       envir = ns)) {
[16:21:07.385]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.385]                         envir = ns)
[16:21:07.385]                       envir <- sys.frame(frame)
[16:21:07.385]                       master <- NULL
[16:21:07.385]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.385]                         !identical(envir, emptyenv())) {
[16:21:07.385]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.385]                           inherits = FALSE)) {
[16:21:07.385]                           master <- get("master", mode = "list", 
[16:21:07.385]                             envir = envir, inherits = FALSE)
[16:21:07.385]                           if (inherits(master, c("SOCKnode", 
[16:21:07.385]                             "SOCK0node"))) {
[16:21:07.385]                             sendCondition <<- function(cond) {
[16:21:07.385]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.385]                                 success = TRUE)
[16:21:07.385]                               parallel_sendData(master, data)
[16:21:07.385]                             }
[16:21:07.385]                             return(sendCondition)
[16:21:07.385]                           }
[16:21:07.385]                         }
[16:21:07.385]                         frame <- frame + 1L
[16:21:07.385]                         envir <- sys.frame(frame)
[16:21:07.385]                       }
[16:21:07.385]                     }
[16:21:07.385]                     sendCondition <<- function(cond) NULL
[16:21:07.385]                   }
[16:21:07.385]                 })
[16:21:07.385]                 withCallingHandlers({
[16:21:07.385]                   1
[16:21:07.385]                 }, immediateCondition = function(cond) {
[16:21:07.385]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.385]                   sendCondition(cond)
[16:21:07.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.385]                   {
[16:21:07.385]                     inherits <- base::inherits
[16:21:07.385]                     invokeRestart <- base::invokeRestart
[16:21:07.385]                     is.null <- base::is.null
[16:21:07.385]                     muffled <- FALSE
[16:21:07.385]                     if (inherits(cond, "message")) {
[16:21:07.385]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.385]                       if (muffled) 
[16:21:07.385]                         invokeRestart("muffleMessage")
[16:21:07.385]                     }
[16:21:07.385]                     else if (inherits(cond, "warning")) {
[16:21:07.385]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.385]                       if (muffled) 
[16:21:07.385]                         invokeRestart("muffleWarning")
[16:21:07.385]                     }
[16:21:07.385]                     else if (inherits(cond, "condition")) {
[16:21:07.385]                       if (!is.null(pattern)) {
[16:21:07.385]                         computeRestarts <- base::computeRestarts
[16:21:07.385]                         grepl <- base::grepl
[16:21:07.385]                         restarts <- computeRestarts(cond)
[16:21:07.385]                         for (restart in restarts) {
[16:21:07.385]                           name <- restart$name
[16:21:07.385]                           if (is.null(name)) 
[16:21:07.385]                             next
[16:21:07.385]                           if (!grepl(pattern, name)) 
[16:21:07.385]                             next
[16:21:07.385]                           invokeRestart(restart)
[16:21:07.385]                           muffled <- TRUE
[16:21:07.385]                           break
[16:21:07.385]                         }
[16:21:07.385]                       }
[16:21:07.385]                     }
[16:21:07.385]                     invisible(muffled)
[16:21:07.385]                   }
[16:21:07.385]                   muffleCondition(cond)
[16:21:07.385]                 })
[16:21:07.385]             }))
[16:21:07.385]             future::FutureResult(value = ...future.value$value, 
[16:21:07.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.385]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.385]                     ...future.globalenv.names))
[16:21:07.385]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.385]         }, condition = base::local({
[16:21:07.385]             c <- base::c
[16:21:07.385]             inherits <- base::inherits
[16:21:07.385]             invokeRestart <- base::invokeRestart
[16:21:07.385]             length <- base::length
[16:21:07.385]             list <- base::list
[16:21:07.385]             seq.int <- base::seq.int
[16:21:07.385]             signalCondition <- base::signalCondition
[16:21:07.385]             sys.calls <- base::sys.calls
[16:21:07.385]             `[[` <- base::`[[`
[16:21:07.385]             `+` <- base::`+`
[16:21:07.385]             `<<-` <- base::`<<-`
[16:21:07.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.385]                   3L)]
[16:21:07.385]             }
[16:21:07.385]             function(cond) {
[16:21:07.385]                 is_error <- inherits(cond, "error")
[16:21:07.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.385]                   NULL)
[16:21:07.385]                 if (is_error) {
[16:21:07.385]                   sessionInformation <- function() {
[16:21:07.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.385]                       search = base::search(), system = base::Sys.info())
[16:21:07.385]                   }
[16:21:07.385]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.385]                     cond$call), session = sessionInformation(), 
[16:21:07.385]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.385]                   signalCondition(cond)
[16:21:07.385]                 }
[16:21:07.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.385]                 "immediateCondition"))) {
[16:21:07.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.385]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.385]                   if (TRUE && !signal) {
[16:21:07.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.385]                     {
[16:21:07.385]                       inherits <- base::inherits
[16:21:07.385]                       invokeRestart <- base::invokeRestart
[16:21:07.385]                       is.null <- base::is.null
[16:21:07.385]                       muffled <- FALSE
[16:21:07.385]                       if (inherits(cond, "message")) {
[16:21:07.385]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.385]                         if (muffled) 
[16:21:07.385]                           invokeRestart("muffleMessage")
[16:21:07.385]                       }
[16:21:07.385]                       else if (inherits(cond, "warning")) {
[16:21:07.385]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.385]                         if (muffled) 
[16:21:07.385]                           invokeRestart("muffleWarning")
[16:21:07.385]                       }
[16:21:07.385]                       else if (inherits(cond, "condition")) {
[16:21:07.385]                         if (!is.null(pattern)) {
[16:21:07.385]                           computeRestarts <- base::computeRestarts
[16:21:07.385]                           grepl <- base::grepl
[16:21:07.385]                           restarts <- computeRestarts(cond)
[16:21:07.385]                           for (restart in restarts) {
[16:21:07.385]                             name <- restart$name
[16:21:07.385]                             if (is.null(name)) 
[16:21:07.385]                               next
[16:21:07.385]                             if (!grepl(pattern, name)) 
[16:21:07.385]                               next
[16:21:07.385]                             invokeRestart(restart)
[16:21:07.385]                             muffled <- TRUE
[16:21:07.385]                             break
[16:21:07.385]                           }
[16:21:07.385]                         }
[16:21:07.385]                       }
[16:21:07.385]                       invisible(muffled)
[16:21:07.385]                     }
[16:21:07.385]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.385]                   }
[16:21:07.385]                 }
[16:21:07.385]                 else {
[16:21:07.385]                   if (TRUE) {
[16:21:07.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.385]                     {
[16:21:07.385]                       inherits <- base::inherits
[16:21:07.385]                       invokeRestart <- base::invokeRestart
[16:21:07.385]                       is.null <- base::is.null
[16:21:07.385]                       muffled <- FALSE
[16:21:07.385]                       if (inherits(cond, "message")) {
[16:21:07.385]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.385]                         if (muffled) 
[16:21:07.385]                           invokeRestart("muffleMessage")
[16:21:07.385]                       }
[16:21:07.385]                       else if (inherits(cond, "warning")) {
[16:21:07.385]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.385]                         if (muffled) 
[16:21:07.385]                           invokeRestart("muffleWarning")
[16:21:07.385]                       }
[16:21:07.385]                       else if (inherits(cond, "condition")) {
[16:21:07.385]                         if (!is.null(pattern)) {
[16:21:07.385]                           computeRestarts <- base::computeRestarts
[16:21:07.385]                           grepl <- base::grepl
[16:21:07.385]                           restarts <- computeRestarts(cond)
[16:21:07.385]                           for (restart in restarts) {
[16:21:07.385]                             name <- restart$name
[16:21:07.385]                             if (is.null(name)) 
[16:21:07.385]                               next
[16:21:07.385]                             if (!grepl(pattern, name)) 
[16:21:07.385]                               next
[16:21:07.385]                             invokeRestart(restart)
[16:21:07.385]                             muffled <- TRUE
[16:21:07.385]                             break
[16:21:07.385]                           }
[16:21:07.385]                         }
[16:21:07.385]                       }
[16:21:07.385]                       invisible(muffled)
[16:21:07.385]                     }
[16:21:07.385]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.385]                   }
[16:21:07.385]                 }
[16:21:07.385]             }
[16:21:07.385]         }))
[16:21:07.385]     }, error = function(ex) {
[16:21:07.385]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.385]                 ...future.rng), started = ...future.startTime, 
[16:21:07.385]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.385]             version = "1.8"), class = "FutureResult")
[16:21:07.385]     }, finally = {
[16:21:07.385]         if (!identical(...future.workdir, getwd())) 
[16:21:07.385]             setwd(...future.workdir)
[16:21:07.385]         {
[16:21:07.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.385]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.385]             }
[16:21:07.385]             base::options(...future.oldOptions)
[16:21:07.385]             if (.Platform$OS.type == "windows") {
[16:21:07.385]                 old_names <- names(...future.oldEnvVars)
[16:21:07.385]                 envs <- base::Sys.getenv()
[16:21:07.385]                 names <- names(envs)
[16:21:07.385]                 common <- intersect(names, old_names)
[16:21:07.385]                 added <- setdiff(names, old_names)
[16:21:07.385]                 removed <- setdiff(old_names, names)
[16:21:07.385]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.385]                   envs[common]]
[16:21:07.385]                 NAMES <- toupper(changed)
[16:21:07.385]                 args <- list()
[16:21:07.385]                 for (kk in seq_along(NAMES)) {
[16:21:07.385]                   name <- changed[[kk]]
[16:21:07.385]                   NAME <- NAMES[[kk]]
[16:21:07.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.385]                     next
[16:21:07.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.385]                 }
[16:21:07.385]                 NAMES <- toupper(added)
[16:21:07.385]                 for (kk in seq_along(NAMES)) {
[16:21:07.385]                   name <- added[[kk]]
[16:21:07.385]                   NAME <- NAMES[[kk]]
[16:21:07.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.385]                     next
[16:21:07.385]                   args[[name]] <- ""
[16:21:07.385]                 }
[16:21:07.385]                 NAMES <- toupper(removed)
[16:21:07.385]                 for (kk in seq_along(NAMES)) {
[16:21:07.385]                   name <- removed[[kk]]
[16:21:07.385]                   NAME <- NAMES[[kk]]
[16:21:07.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.385]                     next
[16:21:07.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.385]                 }
[16:21:07.385]                 if (length(args) > 0) 
[16:21:07.385]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.385]             }
[16:21:07.385]             else {
[16:21:07.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.385]             }
[16:21:07.385]             {
[16:21:07.385]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.385]                   0L) {
[16:21:07.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.385]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.385]                   base::options(opts)
[16:21:07.385]                 }
[16:21:07.385]                 {
[16:21:07.385]                   {
[16:21:07.385]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.385]                     NULL
[16:21:07.385]                   }
[16:21:07.385]                   options(future.plan = NULL)
[16:21:07.385]                   if (is.na(NA_character_)) 
[16:21:07.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.385]                     .init = FALSE)
[16:21:07.385]                 }
[16:21:07.385]             }
[16:21:07.385]         }
[16:21:07.385]     })
[16:21:07.385]     if (TRUE) {
[16:21:07.385]         base::sink(type = "output", split = FALSE)
[16:21:07.385]         if (TRUE) {
[16:21:07.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.385]         }
[16:21:07.385]         else {
[16:21:07.385]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.385]         }
[16:21:07.385]         base::close(...future.stdout)
[16:21:07.385]         ...future.stdout <- NULL
[16:21:07.385]     }
[16:21:07.385]     ...future.result$conditions <- ...future.conditions
[16:21:07.385]     ...future.result$finished <- base::Sys.time()
[16:21:07.385]     ...future.result
[16:21:07.385] }
[16:21:07.388] MultisessionFuture started
[16:21:07.388] - Launch lazy future ... done
[16:21:07.388] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.389] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.389] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.390] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:07.390] Searching for globals ... DONE
[16:21:07.391] Resolving globals: TRUE
[16:21:07.391] Resolving any globals that are futures ...
[16:21:07.391] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:07.391] Resolving any globals that are futures ... DONE
[16:21:07.391] Resolving futures part of globals (recursively) ...
[16:21:07.391] resolve() on list ...
[16:21:07.392]  recursive: 99
[16:21:07.392]  length: 1
[16:21:07.392]  elements: ‘a’
[16:21:07.392] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.392] - Validating connection of MultisessionFuture
[16:21:07.393] - received message: FutureResult
[16:21:07.393] - Received FutureResult
[16:21:07.393] - Erased future from FutureRegistry
[16:21:07.393] result() for ClusterFuture ...
[16:21:07.393] - result already collected: FutureResult
[16:21:07.393] result() for ClusterFuture ... done
[16:21:07.393] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.393] Future #1
[16:21:07.393] result() for ClusterFuture ...
[16:21:07.393] - result already collected: FutureResult
[16:21:07.393] result() for ClusterFuture ... done
[16:21:07.394] result() for ClusterFuture ...
[16:21:07.394] - result already collected: FutureResult
[16:21:07.394] result() for ClusterFuture ... done
[16:21:07.394] A MultisessionFuture was resolved
[16:21:07.394]  length: 0 (resolved future 1)
[16:21:07.394] resolve() on list ... DONE
[16:21:07.394] - globals: [1] ‘a’
[16:21:07.394] Resolving futures part of globals (recursively) ... DONE
[16:21:07.396] The total size of the 1 globals is 1.57 MiB (1646728 bytes)
[16:21:07.397] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:21:07.397] - globals: [1] ‘a’
[16:21:07.397] - packages: [1] ‘future’
[16:21:07.397] getGlobalsAndPackages() ... DONE
[16:21:07.397] run() for ‘Future’ ...
[16:21:07.397] - state: ‘created’
[16:21:07.398] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.411] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.411] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.412]   - Field: ‘node’
[16:21:07.412]   - Field: ‘label’
[16:21:07.412]   - Field: ‘local’
[16:21:07.412]   - Field: ‘owner’
[16:21:07.412]   - Field: ‘envir’
[16:21:07.412]   - Field: ‘workers’
[16:21:07.412]   - Field: ‘packages’
[16:21:07.412]   - Field: ‘gc’
[16:21:07.412]   - Field: ‘conditions’
[16:21:07.413]   - Field: ‘persistent’
[16:21:07.413]   - Field: ‘expr’
[16:21:07.413]   - Field: ‘uuid’
[16:21:07.413]   - Field: ‘seed’
[16:21:07.413]   - Field: ‘version’
[16:21:07.413]   - Field: ‘result’
[16:21:07.413]   - Field: ‘asynchronous’
[16:21:07.413]   - Field: ‘calls’
[16:21:07.413]   - Field: ‘globals’
[16:21:07.413]   - Field: ‘stdout’
[16:21:07.413]   - Field: ‘earlySignal’
[16:21:07.414]   - Field: ‘lazy’
[16:21:07.414]   - Field: ‘state’
[16:21:07.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.414] - Launch lazy future ...
[16:21:07.414] Packages needed by the future expression (n = 1): ‘future’
[16:21:07.414] Packages needed by future strategies (n = 0): <none>
[16:21:07.415] {
[16:21:07.415]     {
[16:21:07.415]         {
[16:21:07.415]             ...future.startTime <- base::Sys.time()
[16:21:07.415]             {
[16:21:07.415]                 {
[16:21:07.415]                   {
[16:21:07.415]                     {
[16:21:07.415]                       {
[16:21:07.415]                         base::local({
[16:21:07.415]                           has_future <- base::requireNamespace("future", 
[16:21:07.415]                             quietly = TRUE)
[16:21:07.415]                           if (has_future) {
[16:21:07.415]                             ns <- base::getNamespace("future")
[16:21:07.415]                             version <- ns[[".package"]][["version"]]
[16:21:07.415]                             if (is.null(version)) 
[16:21:07.415]                               version <- utils::packageVersion("future")
[16:21:07.415]                           }
[16:21:07.415]                           else {
[16:21:07.415]                             version <- NULL
[16:21:07.415]                           }
[16:21:07.415]                           if (!has_future || version < "1.8.0") {
[16:21:07.415]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.415]                               "", base::R.version$version.string), 
[16:21:07.415]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:07.415]                                 base::R.version$platform, 8 * 
[16:21:07.415]                                   base::.Machine$sizeof.pointer), 
[16:21:07.415]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.415]                                 "release", "version")], collapse = " "), 
[16:21:07.415]                               hostname = base::Sys.info()[["nodename"]])
[16:21:07.415]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.415]                               info)
[16:21:07.415]                             info <- base::paste(info, collapse = "; ")
[16:21:07.415]                             if (!has_future) {
[16:21:07.415]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.415]                                 info)
[16:21:07.415]                             }
[16:21:07.415]                             else {
[16:21:07.415]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.415]                                 info, version)
[16:21:07.415]                             }
[16:21:07.415]                             base::stop(msg)
[16:21:07.415]                           }
[16:21:07.415]                         })
[16:21:07.415]                       }
[16:21:07.415]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.415]                       base::options(mc.cores = 1L)
[16:21:07.415]                     }
[16:21:07.415]                     base::local({
[16:21:07.415]                       for (pkg in "future") {
[16:21:07.415]                         base::loadNamespace(pkg)
[16:21:07.415]                         base::library(pkg, character.only = TRUE)
[16:21:07.415]                       }
[16:21:07.415]                     })
[16:21:07.415]                   }
[16:21:07.415]                   ...future.strategy.old <- future::plan("list")
[16:21:07.415]                   options(future.plan = NULL)
[16:21:07.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.415]                 }
[16:21:07.415]                 ...future.workdir <- getwd()
[16:21:07.415]             }
[16:21:07.415]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.415]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.415]         }
[16:21:07.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.415]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.415]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.415]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.415]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.415]             base::names(...future.oldOptions))
[16:21:07.415]     }
[16:21:07.415]     if (FALSE) {
[16:21:07.415]     }
[16:21:07.415]     else {
[16:21:07.415]         if (TRUE) {
[16:21:07.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.415]                 open = "w")
[16:21:07.415]         }
[16:21:07.415]         else {
[16:21:07.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.415]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.415]         }
[16:21:07.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.415]             base::sink(type = "output", split = FALSE)
[16:21:07.415]             base::close(...future.stdout)
[16:21:07.415]         }, add = TRUE)
[16:21:07.415]     }
[16:21:07.415]     ...future.frame <- base::sys.nframe()
[16:21:07.415]     ...future.conditions <- base::list()
[16:21:07.415]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.415]     if (FALSE) {
[16:21:07.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.415]     }
[16:21:07.415]     ...future.result <- base::tryCatch({
[16:21:07.415]         base::withCallingHandlers({
[16:21:07.415]             ...future.value <- base::withVisible(base::local({
[16:21:07.415]                 ...future.makeSendCondition <- base::local({
[16:21:07.415]                   sendCondition <- NULL
[16:21:07.415]                   function(frame = 1L) {
[16:21:07.415]                     if (is.function(sendCondition)) 
[16:21:07.415]                       return(sendCondition)
[16:21:07.415]                     ns <- getNamespace("parallel")
[16:21:07.415]                     if (exists("sendData", mode = "function", 
[16:21:07.415]                       envir = ns)) {
[16:21:07.415]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.415]                         envir = ns)
[16:21:07.415]                       envir <- sys.frame(frame)
[16:21:07.415]                       master <- NULL
[16:21:07.415]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.415]                         !identical(envir, emptyenv())) {
[16:21:07.415]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.415]                           inherits = FALSE)) {
[16:21:07.415]                           master <- get("master", mode = "list", 
[16:21:07.415]                             envir = envir, inherits = FALSE)
[16:21:07.415]                           if (inherits(master, c("SOCKnode", 
[16:21:07.415]                             "SOCK0node"))) {
[16:21:07.415]                             sendCondition <<- function(cond) {
[16:21:07.415]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.415]                                 success = TRUE)
[16:21:07.415]                               parallel_sendData(master, data)
[16:21:07.415]                             }
[16:21:07.415]                             return(sendCondition)
[16:21:07.415]                           }
[16:21:07.415]                         }
[16:21:07.415]                         frame <- frame + 1L
[16:21:07.415]                         envir <- sys.frame(frame)
[16:21:07.415]                       }
[16:21:07.415]                     }
[16:21:07.415]                     sendCondition <<- function(cond) NULL
[16:21:07.415]                   }
[16:21:07.415]                 })
[16:21:07.415]                 withCallingHandlers({
[16:21:07.415]                   value(a) + 1
[16:21:07.415]                 }, immediateCondition = function(cond) {
[16:21:07.415]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.415]                   sendCondition(cond)
[16:21:07.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.415]                   {
[16:21:07.415]                     inherits <- base::inherits
[16:21:07.415]                     invokeRestart <- base::invokeRestart
[16:21:07.415]                     is.null <- base::is.null
[16:21:07.415]                     muffled <- FALSE
[16:21:07.415]                     if (inherits(cond, "message")) {
[16:21:07.415]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.415]                       if (muffled) 
[16:21:07.415]                         invokeRestart("muffleMessage")
[16:21:07.415]                     }
[16:21:07.415]                     else if (inherits(cond, "warning")) {
[16:21:07.415]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.415]                       if (muffled) 
[16:21:07.415]                         invokeRestart("muffleWarning")
[16:21:07.415]                     }
[16:21:07.415]                     else if (inherits(cond, "condition")) {
[16:21:07.415]                       if (!is.null(pattern)) {
[16:21:07.415]                         computeRestarts <- base::computeRestarts
[16:21:07.415]                         grepl <- base::grepl
[16:21:07.415]                         restarts <- computeRestarts(cond)
[16:21:07.415]                         for (restart in restarts) {
[16:21:07.415]                           name <- restart$name
[16:21:07.415]                           if (is.null(name)) 
[16:21:07.415]                             next
[16:21:07.415]                           if (!grepl(pattern, name)) 
[16:21:07.415]                             next
[16:21:07.415]                           invokeRestart(restart)
[16:21:07.415]                           muffled <- TRUE
[16:21:07.415]                           break
[16:21:07.415]                         }
[16:21:07.415]                       }
[16:21:07.415]                     }
[16:21:07.415]                     invisible(muffled)
[16:21:07.415]                   }
[16:21:07.415]                   muffleCondition(cond)
[16:21:07.415]                 })
[16:21:07.415]             }))
[16:21:07.415]             future::FutureResult(value = ...future.value$value, 
[16:21:07.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.415]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.415]                     ...future.globalenv.names))
[16:21:07.415]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.415]         }, condition = base::local({
[16:21:07.415]             c <- base::c
[16:21:07.415]             inherits <- base::inherits
[16:21:07.415]             invokeRestart <- base::invokeRestart
[16:21:07.415]             length <- base::length
[16:21:07.415]             list <- base::list
[16:21:07.415]             seq.int <- base::seq.int
[16:21:07.415]             signalCondition <- base::signalCondition
[16:21:07.415]             sys.calls <- base::sys.calls
[16:21:07.415]             `[[` <- base::`[[`
[16:21:07.415]             `+` <- base::`+`
[16:21:07.415]             `<<-` <- base::`<<-`
[16:21:07.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.415]                   3L)]
[16:21:07.415]             }
[16:21:07.415]             function(cond) {
[16:21:07.415]                 is_error <- inherits(cond, "error")
[16:21:07.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.415]                   NULL)
[16:21:07.415]                 if (is_error) {
[16:21:07.415]                   sessionInformation <- function() {
[16:21:07.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.415]                       search = base::search(), system = base::Sys.info())
[16:21:07.415]                   }
[16:21:07.415]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.415]                     cond$call), session = sessionInformation(), 
[16:21:07.415]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.415]                   signalCondition(cond)
[16:21:07.415]                 }
[16:21:07.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.415]                 "immediateCondition"))) {
[16:21:07.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.415]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.415]                   if (TRUE && !signal) {
[16:21:07.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.415]                     {
[16:21:07.415]                       inherits <- base::inherits
[16:21:07.415]                       invokeRestart <- base::invokeRestart
[16:21:07.415]                       is.null <- base::is.null
[16:21:07.415]                       muffled <- FALSE
[16:21:07.415]                       if (inherits(cond, "message")) {
[16:21:07.415]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.415]                         if (muffled) 
[16:21:07.415]                           invokeRestart("muffleMessage")
[16:21:07.415]                       }
[16:21:07.415]                       else if (inherits(cond, "warning")) {
[16:21:07.415]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.415]                         if (muffled) 
[16:21:07.415]                           invokeRestart("muffleWarning")
[16:21:07.415]                       }
[16:21:07.415]                       else if (inherits(cond, "condition")) {
[16:21:07.415]                         if (!is.null(pattern)) {
[16:21:07.415]                           computeRestarts <- base::computeRestarts
[16:21:07.415]                           grepl <- base::grepl
[16:21:07.415]                           restarts <- computeRestarts(cond)
[16:21:07.415]                           for (restart in restarts) {
[16:21:07.415]                             name <- restart$name
[16:21:07.415]                             if (is.null(name)) 
[16:21:07.415]                               next
[16:21:07.415]                             if (!grepl(pattern, name)) 
[16:21:07.415]                               next
[16:21:07.415]                             invokeRestart(restart)
[16:21:07.415]                             muffled <- TRUE
[16:21:07.415]                             break
[16:21:07.415]                           }
[16:21:07.415]                         }
[16:21:07.415]                       }
[16:21:07.415]                       invisible(muffled)
[16:21:07.415]                     }
[16:21:07.415]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.415]                   }
[16:21:07.415]                 }
[16:21:07.415]                 else {
[16:21:07.415]                   if (TRUE) {
[16:21:07.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.415]                     {
[16:21:07.415]                       inherits <- base::inherits
[16:21:07.415]                       invokeRestart <- base::invokeRestart
[16:21:07.415]                       is.null <- base::is.null
[16:21:07.415]                       muffled <- FALSE
[16:21:07.415]                       if (inherits(cond, "message")) {
[16:21:07.415]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.415]                         if (muffled) 
[16:21:07.415]                           invokeRestart("muffleMessage")
[16:21:07.415]                       }
[16:21:07.415]                       else if (inherits(cond, "warning")) {
[16:21:07.415]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.415]                         if (muffled) 
[16:21:07.415]                           invokeRestart("muffleWarning")
[16:21:07.415]                       }
[16:21:07.415]                       else if (inherits(cond, "condition")) {
[16:21:07.415]                         if (!is.null(pattern)) {
[16:21:07.415]                           computeRestarts <- base::computeRestarts
[16:21:07.415]                           grepl <- base::grepl
[16:21:07.415]                           restarts <- computeRestarts(cond)
[16:21:07.415]                           for (restart in restarts) {
[16:21:07.415]                             name <- restart$name
[16:21:07.415]                             if (is.null(name)) 
[16:21:07.415]                               next
[16:21:07.415]                             if (!grepl(pattern, name)) 
[16:21:07.415]                               next
[16:21:07.415]                             invokeRestart(restart)
[16:21:07.415]                             muffled <- TRUE
[16:21:07.415]                             break
[16:21:07.415]                           }
[16:21:07.415]                         }
[16:21:07.415]                       }
[16:21:07.415]                       invisible(muffled)
[16:21:07.415]                     }
[16:21:07.415]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.415]                   }
[16:21:07.415]                 }
[16:21:07.415]             }
[16:21:07.415]         }))
[16:21:07.415]     }, error = function(ex) {
[16:21:07.415]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.415]                 ...future.rng), started = ...future.startTime, 
[16:21:07.415]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.415]             version = "1.8"), class = "FutureResult")
[16:21:07.415]     }, finally = {
[16:21:07.415]         if (!identical(...future.workdir, getwd())) 
[16:21:07.415]             setwd(...future.workdir)
[16:21:07.415]         {
[16:21:07.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.415]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.415]             }
[16:21:07.415]             base::options(...future.oldOptions)
[16:21:07.415]             if (.Platform$OS.type == "windows") {
[16:21:07.415]                 old_names <- names(...future.oldEnvVars)
[16:21:07.415]                 envs <- base::Sys.getenv()
[16:21:07.415]                 names <- names(envs)
[16:21:07.415]                 common <- intersect(names, old_names)
[16:21:07.415]                 added <- setdiff(names, old_names)
[16:21:07.415]                 removed <- setdiff(old_names, names)
[16:21:07.415]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.415]                   envs[common]]
[16:21:07.415]                 NAMES <- toupper(changed)
[16:21:07.415]                 args <- list()
[16:21:07.415]                 for (kk in seq_along(NAMES)) {
[16:21:07.415]                   name <- changed[[kk]]
[16:21:07.415]                   NAME <- NAMES[[kk]]
[16:21:07.415]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.415]                     next
[16:21:07.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.415]                 }
[16:21:07.415]                 NAMES <- toupper(added)
[16:21:07.415]                 for (kk in seq_along(NAMES)) {
[16:21:07.415]                   name <- added[[kk]]
[16:21:07.415]                   NAME <- NAMES[[kk]]
[16:21:07.415]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.415]                     next
[16:21:07.415]                   args[[name]] <- ""
[16:21:07.415]                 }
[16:21:07.415]                 NAMES <- toupper(removed)
[16:21:07.415]                 for (kk in seq_along(NAMES)) {
[16:21:07.415]                   name <- removed[[kk]]
[16:21:07.415]                   NAME <- NAMES[[kk]]
[16:21:07.415]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.415]                     next
[16:21:07.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.415]                 }
[16:21:07.415]                 if (length(args) > 0) 
[16:21:07.415]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.415]             }
[16:21:07.415]             else {
[16:21:07.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.415]             }
[16:21:07.415]             {
[16:21:07.415]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.415]                   0L) {
[16:21:07.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.415]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.415]                   base::options(opts)
[16:21:07.415]                 }
[16:21:07.415]                 {
[16:21:07.415]                   {
[16:21:07.415]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.415]                     NULL
[16:21:07.415]                   }
[16:21:07.415]                   options(future.plan = NULL)
[16:21:07.415]                   if (is.na(NA_character_)) 
[16:21:07.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.415]                     .init = FALSE)
[16:21:07.415]                 }
[16:21:07.415]             }
[16:21:07.415]         }
[16:21:07.415]     })
[16:21:07.415]     if (TRUE) {
[16:21:07.415]         base::sink(type = "output", split = FALSE)
[16:21:07.415]         if (TRUE) {
[16:21:07.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.415]         }
[16:21:07.415]         else {
[16:21:07.415]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.415]         }
[16:21:07.415]         base::close(...future.stdout)
[16:21:07.415]         ...future.stdout <- NULL
[16:21:07.415]     }
[16:21:07.415]     ...future.result$conditions <- ...future.conditions
[16:21:07.415]     ...future.result$finished <- base::Sys.time()
[16:21:07.415]     ...future.result
[16:21:07.415] }
[16:21:07.417] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[16:21:07.419] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[16:21:07.473] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[16:21:07.473] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[16:21:07.473] MultisessionFuture started
[16:21:07.473] - Launch lazy future ... done
[16:21:07.474] run() for ‘MultisessionFuture’ ... done
[16:21:07.474] result() for ClusterFuture ...
[16:21:07.474] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.474] - Validating connection of MultisessionFuture
[16:21:07.522] - received message: FutureResult
[16:21:07.522] - Received FutureResult
[16:21:07.522] - Erased future from FutureRegistry
[16:21:07.522] result() for ClusterFuture ...
[16:21:07.522] - result already collected: FutureResult
[16:21:07.523] result() for ClusterFuture ... done
[16:21:07.523] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.523] result() for ClusterFuture ... done
[16:21:07.523] result() for ClusterFuture ...
[16:21:07.523] - result already collected: FutureResult
[16:21:07.523] result() for ClusterFuture ... done
value(b) = 2
[16:21:07.523] result() for ClusterFuture ...
[16:21:07.523] - result already collected: FutureResult
[16:21:07.523] result() for ClusterFuture ... done
[16:21:07.523] result() for ClusterFuture ...
[16:21:07.524] - result already collected: FutureResult
[16:21:07.524] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.524] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.524] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.525] 
[16:21:07.525] Searching for globals ... DONE
[16:21:07.525] - globals: [0] <none>
[16:21:07.525] getGlobalsAndPackages() ... DONE
[16:21:07.525] run() for ‘Future’ ...
[16:21:07.525] - state: ‘created’
[16:21:07.525] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.540] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.540]   - Field: ‘node’
[16:21:07.540]   - Field: ‘label’
[16:21:07.540]   - Field: ‘local’
[16:21:07.540]   - Field: ‘owner’
[16:21:07.540]   - Field: ‘envir’
[16:21:07.540]   - Field: ‘workers’
[16:21:07.540]   - Field: ‘packages’
[16:21:07.541]   - Field: ‘gc’
[16:21:07.541]   - Field: ‘conditions’
[16:21:07.541]   - Field: ‘persistent’
[16:21:07.541]   - Field: ‘expr’
[16:21:07.541]   - Field: ‘uuid’
[16:21:07.541]   - Field: ‘seed’
[16:21:07.541]   - Field: ‘version’
[16:21:07.541]   - Field: ‘result’
[16:21:07.541]   - Field: ‘asynchronous’
[16:21:07.541]   - Field: ‘calls’
[16:21:07.541]   - Field: ‘globals’
[16:21:07.542]   - Field: ‘stdout’
[16:21:07.542]   - Field: ‘earlySignal’
[16:21:07.542]   - Field: ‘lazy’
[16:21:07.542]   - Field: ‘state’
[16:21:07.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.542] - Launch lazy future ...
[16:21:07.542] Packages needed by the future expression (n = 0): <none>
[16:21:07.542] Packages needed by future strategies (n = 0): <none>
[16:21:07.543] {
[16:21:07.543]     {
[16:21:07.543]         {
[16:21:07.543]             ...future.startTime <- base::Sys.time()
[16:21:07.543]             {
[16:21:07.543]                 {
[16:21:07.543]                   {
[16:21:07.543]                     {
[16:21:07.543]                       base::local({
[16:21:07.543]                         has_future <- base::requireNamespace("future", 
[16:21:07.543]                           quietly = TRUE)
[16:21:07.543]                         if (has_future) {
[16:21:07.543]                           ns <- base::getNamespace("future")
[16:21:07.543]                           version <- ns[[".package"]][["version"]]
[16:21:07.543]                           if (is.null(version)) 
[16:21:07.543]                             version <- utils::packageVersion("future")
[16:21:07.543]                         }
[16:21:07.543]                         else {
[16:21:07.543]                           version <- NULL
[16:21:07.543]                         }
[16:21:07.543]                         if (!has_future || version < "1.8.0") {
[16:21:07.543]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.543]                             "", base::R.version$version.string), 
[16:21:07.543]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.543]                               "release", "version")], collapse = " "), 
[16:21:07.543]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.543]                             info)
[16:21:07.543]                           info <- base::paste(info, collapse = "; ")
[16:21:07.543]                           if (!has_future) {
[16:21:07.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.543]                               info)
[16:21:07.543]                           }
[16:21:07.543]                           else {
[16:21:07.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.543]                               info, version)
[16:21:07.543]                           }
[16:21:07.543]                           base::stop(msg)
[16:21:07.543]                         }
[16:21:07.543]                       })
[16:21:07.543]                     }
[16:21:07.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.543]                     base::options(mc.cores = 1L)
[16:21:07.543]                   }
[16:21:07.543]                   ...future.strategy.old <- future::plan("list")
[16:21:07.543]                   options(future.plan = NULL)
[16:21:07.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.543]                 }
[16:21:07.543]                 ...future.workdir <- getwd()
[16:21:07.543]             }
[16:21:07.543]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.543]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.543]         }
[16:21:07.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.543]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.543]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.543]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.543]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.543]             base::names(...future.oldOptions))
[16:21:07.543]     }
[16:21:07.543]     if (FALSE) {
[16:21:07.543]     }
[16:21:07.543]     else {
[16:21:07.543]         if (TRUE) {
[16:21:07.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.543]                 open = "w")
[16:21:07.543]         }
[16:21:07.543]         else {
[16:21:07.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.543]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.543]         }
[16:21:07.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.543]             base::sink(type = "output", split = FALSE)
[16:21:07.543]             base::close(...future.stdout)
[16:21:07.543]         }, add = TRUE)
[16:21:07.543]     }
[16:21:07.543]     ...future.frame <- base::sys.nframe()
[16:21:07.543]     ...future.conditions <- base::list()
[16:21:07.543]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.543]     if (FALSE) {
[16:21:07.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.543]     }
[16:21:07.543]     ...future.result <- base::tryCatch({
[16:21:07.543]         base::withCallingHandlers({
[16:21:07.543]             ...future.value <- base::withVisible(base::local({
[16:21:07.543]                 ...future.makeSendCondition <- base::local({
[16:21:07.543]                   sendCondition <- NULL
[16:21:07.543]                   function(frame = 1L) {
[16:21:07.543]                     if (is.function(sendCondition)) 
[16:21:07.543]                       return(sendCondition)
[16:21:07.543]                     ns <- getNamespace("parallel")
[16:21:07.543]                     if (exists("sendData", mode = "function", 
[16:21:07.543]                       envir = ns)) {
[16:21:07.543]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.543]                         envir = ns)
[16:21:07.543]                       envir <- sys.frame(frame)
[16:21:07.543]                       master <- NULL
[16:21:07.543]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.543]                         !identical(envir, emptyenv())) {
[16:21:07.543]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.543]                           inherits = FALSE)) {
[16:21:07.543]                           master <- get("master", mode = "list", 
[16:21:07.543]                             envir = envir, inherits = FALSE)
[16:21:07.543]                           if (inherits(master, c("SOCKnode", 
[16:21:07.543]                             "SOCK0node"))) {
[16:21:07.543]                             sendCondition <<- function(cond) {
[16:21:07.543]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.543]                                 success = TRUE)
[16:21:07.543]                               parallel_sendData(master, data)
[16:21:07.543]                             }
[16:21:07.543]                             return(sendCondition)
[16:21:07.543]                           }
[16:21:07.543]                         }
[16:21:07.543]                         frame <- frame + 1L
[16:21:07.543]                         envir <- sys.frame(frame)
[16:21:07.543]                       }
[16:21:07.543]                     }
[16:21:07.543]                     sendCondition <<- function(cond) NULL
[16:21:07.543]                   }
[16:21:07.543]                 })
[16:21:07.543]                 withCallingHandlers({
[16:21:07.543]                   1
[16:21:07.543]                 }, immediateCondition = function(cond) {
[16:21:07.543]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.543]                   sendCondition(cond)
[16:21:07.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.543]                   {
[16:21:07.543]                     inherits <- base::inherits
[16:21:07.543]                     invokeRestart <- base::invokeRestart
[16:21:07.543]                     is.null <- base::is.null
[16:21:07.543]                     muffled <- FALSE
[16:21:07.543]                     if (inherits(cond, "message")) {
[16:21:07.543]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.543]                       if (muffled) 
[16:21:07.543]                         invokeRestart("muffleMessage")
[16:21:07.543]                     }
[16:21:07.543]                     else if (inherits(cond, "warning")) {
[16:21:07.543]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.543]                       if (muffled) 
[16:21:07.543]                         invokeRestart("muffleWarning")
[16:21:07.543]                     }
[16:21:07.543]                     else if (inherits(cond, "condition")) {
[16:21:07.543]                       if (!is.null(pattern)) {
[16:21:07.543]                         computeRestarts <- base::computeRestarts
[16:21:07.543]                         grepl <- base::grepl
[16:21:07.543]                         restarts <- computeRestarts(cond)
[16:21:07.543]                         for (restart in restarts) {
[16:21:07.543]                           name <- restart$name
[16:21:07.543]                           if (is.null(name)) 
[16:21:07.543]                             next
[16:21:07.543]                           if (!grepl(pattern, name)) 
[16:21:07.543]                             next
[16:21:07.543]                           invokeRestart(restart)
[16:21:07.543]                           muffled <- TRUE
[16:21:07.543]                           break
[16:21:07.543]                         }
[16:21:07.543]                       }
[16:21:07.543]                     }
[16:21:07.543]                     invisible(muffled)
[16:21:07.543]                   }
[16:21:07.543]                   muffleCondition(cond)
[16:21:07.543]                 })
[16:21:07.543]             }))
[16:21:07.543]             future::FutureResult(value = ...future.value$value, 
[16:21:07.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.543]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.543]                     ...future.globalenv.names))
[16:21:07.543]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.543]         }, condition = base::local({
[16:21:07.543]             c <- base::c
[16:21:07.543]             inherits <- base::inherits
[16:21:07.543]             invokeRestart <- base::invokeRestart
[16:21:07.543]             length <- base::length
[16:21:07.543]             list <- base::list
[16:21:07.543]             seq.int <- base::seq.int
[16:21:07.543]             signalCondition <- base::signalCondition
[16:21:07.543]             sys.calls <- base::sys.calls
[16:21:07.543]             `[[` <- base::`[[`
[16:21:07.543]             `+` <- base::`+`
[16:21:07.543]             `<<-` <- base::`<<-`
[16:21:07.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.543]                   3L)]
[16:21:07.543]             }
[16:21:07.543]             function(cond) {
[16:21:07.543]                 is_error <- inherits(cond, "error")
[16:21:07.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.543]                   NULL)
[16:21:07.543]                 if (is_error) {
[16:21:07.543]                   sessionInformation <- function() {
[16:21:07.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.543]                       search = base::search(), system = base::Sys.info())
[16:21:07.543]                   }
[16:21:07.543]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.543]                     cond$call), session = sessionInformation(), 
[16:21:07.543]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.543]                   signalCondition(cond)
[16:21:07.543]                 }
[16:21:07.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.543]                 "immediateCondition"))) {
[16:21:07.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.543]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.543]                   if (TRUE && !signal) {
[16:21:07.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.543]                     {
[16:21:07.543]                       inherits <- base::inherits
[16:21:07.543]                       invokeRestart <- base::invokeRestart
[16:21:07.543]                       is.null <- base::is.null
[16:21:07.543]                       muffled <- FALSE
[16:21:07.543]                       if (inherits(cond, "message")) {
[16:21:07.543]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.543]                         if (muffled) 
[16:21:07.543]                           invokeRestart("muffleMessage")
[16:21:07.543]                       }
[16:21:07.543]                       else if (inherits(cond, "warning")) {
[16:21:07.543]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.543]                         if (muffled) 
[16:21:07.543]                           invokeRestart("muffleWarning")
[16:21:07.543]                       }
[16:21:07.543]                       else if (inherits(cond, "condition")) {
[16:21:07.543]                         if (!is.null(pattern)) {
[16:21:07.543]                           computeRestarts <- base::computeRestarts
[16:21:07.543]                           grepl <- base::grepl
[16:21:07.543]                           restarts <- computeRestarts(cond)
[16:21:07.543]                           for (restart in restarts) {
[16:21:07.543]                             name <- restart$name
[16:21:07.543]                             if (is.null(name)) 
[16:21:07.543]                               next
[16:21:07.543]                             if (!grepl(pattern, name)) 
[16:21:07.543]                               next
[16:21:07.543]                             invokeRestart(restart)
[16:21:07.543]                             muffled <- TRUE
[16:21:07.543]                             break
[16:21:07.543]                           }
[16:21:07.543]                         }
[16:21:07.543]                       }
[16:21:07.543]                       invisible(muffled)
[16:21:07.543]                     }
[16:21:07.543]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.543]                   }
[16:21:07.543]                 }
[16:21:07.543]                 else {
[16:21:07.543]                   if (TRUE) {
[16:21:07.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.543]                     {
[16:21:07.543]                       inherits <- base::inherits
[16:21:07.543]                       invokeRestart <- base::invokeRestart
[16:21:07.543]                       is.null <- base::is.null
[16:21:07.543]                       muffled <- FALSE
[16:21:07.543]                       if (inherits(cond, "message")) {
[16:21:07.543]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.543]                         if (muffled) 
[16:21:07.543]                           invokeRestart("muffleMessage")
[16:21:07.543]                       }
[16:21:07.543]                       else if (inherits(cond, "warning")) {
[16:21:07.543]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.543]                         if (muffled) 
[16:21:07.543]                           invokeRestart("muffleWarning")
[16:21:07.543]                       }
[16:21:07.543]                       else if (inherits(cond, "condition")) {
[16:21:07.543]                         if (!is.null(pattern)) {
[16:21:07.543]                           computeRestarts <- base::computeRestarts
[16:21:07.543]                           grepl <- base::grepl
[16:21:07.543]                           restarts <- computeRestarts(cond)
[16:21:07.543]                           for (restart in restarts) {
[16:21:07.543]                             name <- restart$name
[16:21:07.543]                             if (is.null(name)) 
[16:21:07.543]                               next
[16:21:07.543]                             if (!grepl(pattern, name)) 
[16:21:07.543]                               next
[16:21:07.543]                             invokeRestart(restart)
[16:21:07.543]                             muffled <- TRUE
[16:21:07.543]                             break
[16:21:07.543]                           }
[16:21:07.543]                         }
[16:21:07.543]                       }
[16:21:07.543]                       invisible(muffled)
[16:21:07.543]                     }
[16:21:07.543]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.543]                   }
[16:21:07.543]                 }
[16:21:07.543]             }
[16:21:07.543]         }))
[16:21:07.543]     }, error = function(ex) {
[16:21:07.543]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.543]                 ...future.rng), started = ...future.startTime, 
[16:21:07.543]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.543]             version = "1.8"), class = "FutureResult")
[16:21:07.543]     }, finally = {
[16:21:07.543]         if (!identical(...future.workdir, getwd())) 
[16:21:07.543]             setwd(...future.workdir)
[16:21:07.543]         {
[16:21:07.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.543]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.543]             }
[16:21:07.543]             base::options(...future.oldOptions)
[16:21:07.543]             if (.Platform$OS.type == "windows") {
[16:21:07.543]                 old_names <- names(...future.oldEnvVars)
[16:21:07.543]                 envs <- base::Sys.getenv()
[16:21:07.543]                 names <- names(envs)
[16:21:07.543]                 common <- intersect(names, old_names)
[16:21:07.543]                 added <- setdiff(names, old_names)
[16:21:07.543]                 removed <- setdiff(old_names, names)
[16:21:07.543]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.543]                   envs[common]]
[16:21:07.543]                 NAMES <- toupper(changed)
[16:21:07.543]                 args <- list()
[16:21:07.543]                 for (kk in seq_along(NAMES)) {
[16:21:07.543]                   name <- changed[[kk]]
[16:21:07.543]                   NAME <- NAMES[[kk]]
[16:21:07.543]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.543]                     next
[16:21:07.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.543]                 }
[16:21:07.543]                 NAMES <- toupper(added)
[16:21:07.543]                 for (kk in seq_along(NAMES)) {
[16:21:07.543]                   name <- added[[kk]]
[16:21:07.543]                   NAME <- NAMES[[kk]]
[16:21:07.543]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.543]                     next
[16:21:07.543]                   args[[name]] <- ""
[16:21:07.543]                 }
[16:21:07.543]                 NAMES <- toupper(removed)
[16:21:07.543]                 for (kk in seq_along(NAMES)) {
[16:21:07.543]                   name <- removed[[kk]]
[16:21:07.543]                   NAME <- NAMES[[kk]]
[16:21:07.543]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.543]                     next
[16:21:07.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.543]                 }
[16:21:07.543]                 if (length(args) > 0) 
[16:21:07.543]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.543]             }
[16:21:07.543]             else {
[16:21:07.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.543]             }
[16:21:07.543]             {
[16:21:07.543]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.543]                   0L) {
[16:21:07.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.543]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.543]                   base::options(opts)
[16:21:07.543]                 }
[16:21:07.543]                 {
[16:21:07.543]                   {
[16:21:07.543]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.543]                     NULL
[16:21:07.543]                   }
[16:21:07.543]                   options(future.plan = NULL)
[16:21:07.543]                   if (is.na(NA_character_)) 
[16:21:07.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.543]                     .init = FALSE)
[16:21:07.543]                 }
[16:21:07.543]             }
[16:21:07.543]         }
[16:21:07.543]     })
[16:21:07.543]     if (TRUE) {
[16:21:07.543]         base::sink(type = "output", split = FALSE)
[16:21:07.543]         if (TRUE) {
[16:21:07.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.543]         }
[16:21:07.543]         else {
[16:21:07.543]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.543]         }
[16:21:07.543]         base::close(...future.stdout)
[16:21:07.543]         ...future.stdout <- NULL
[16:21:07.543]     }
[16:21:07.543]     ...future.result$conditions <- ...future.conditions
[16:21:07.543]     ...future.result$finished <- base::Sys.time()
[16:21:07.543]     ...future.result
[16:21:07.543] }
[16:21:07.546] MultisessionFuture started
[16:21:07.546] - Launch lazy future ... done
[16:21:07.546] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.546] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.547] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.547] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:07.547] Searching for globals ... DONE
[16:21:07.548] Resolving globals: TRUE
[16:21:07.548] Resolving any globals that are futures ...
[16:21:07.548] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:07.548] Resolving any globals that are futures ... DONE
[16:21:07.548] Resolving futures part of globals (recursively) ...
[16:21:07.548] resolve() on list ...
[16:21:07.549]  recursive: 99
[16:21:07.549]  length: 1
[16:21:07.549]  elements: ‘a’
[16:21:07.590] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.590] - Validating connection of MultisessionFuture
[16:21:07.591] - received message: FutureResult
[16:21:07.591] - Received FutureResult
[16:21:07.591] - Erased future from FutureRegistry
[16:21:07.591] result() for ClusterFuture ...
[16:21:07.591] - result already collected: FutureResult
[16:21:07.591] result() for ClusterFuture ... done
[16:21:07.591] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.591] Future #1
[16:21:07.591] result() for ClusterFuture ...
[16:21:07.591] - result already collected: FutureResult
[16:21:07.592] result() for ClusterFuture ... done
[16:21:07.592] result() for ClusterFuture ...
[16:21:07.592] - result already collected: FutureResult
[16:21:07.592] result() for ClusterFuture ... done
[16:21:07.592] A MultisessionFuture was resolved
[16:21:07.592]  length: 0 (resolved future 1)
[16:21:07.592] resolve() on list ... DONE
[16:21:07.592] - globals: [1] ‘a’
[16:21:07.592] Resolving futures part of globals (recursively) ... DONE
[16:21:07.597] The total size of the 1 globals is 1.57 MiB (1646728 bytes)
[16:21:07.597] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:21:07.597] - globals: [1] ‘a’
[16:21:07.598] - packages: [1] ‘future’
[16:21:07.598] getGlobalsAndPackages() ... DONE
[16:21:07.598] run() for ‘Future’ ...
[16:21:07.598] - state: ‘created’
[16:21:07.598] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.612] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.612]   - Field: ‘node’
[16:21:07.613]   - Field: ‘label’
[16:21:07.613]   - Field: ‘local’
[16:21:07.613]   - Field: ‘owner’
[16:21:07.613]   - Field: ‘envir’
[16:21:07.613]   - Field: ‘workers’
[16:21:07.613]   - Field: ‘packages’
[16:21:07.613]   - Field: ‘gc’
[16:21:07.613]   - Field: ‘conditions’
[16:21:07.613]   - Field: ‘persistent’
[16:21:07.613]   - Field: ‘expr’
[16:21:07.613]   - Field: ‘uuid’
[16:21:07.613]   - Field: ‘seed’
[16:21:07.614]   - Field: ‘version’
[16:21:07.614]   - Field: ‘result’
[16:21:07.614]   - Field: ‘asynchronous’
[16:21:07.614]   - Field: ‘calls’
[16:21:07.614]   - Field: ‘globals’
[16:21:07.614]   - Field: ‘stdout’
[16:21:07.614]   - Field: ‘earlySignal’
[16:21:07.614]   - Field: ‘lazy’
[16:21:07.614]   - Field: ‘state’
[16:21:07.614] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.614] - Launch lazy future ...
[16:21:07.615] Packages needed by the future expression (n = 1): ‘future’
[16:21:07.615] Packages needed by future strategies (n = 0): <none>
[16:21:07.615] {
[16:21:07.615]     {
[16:21:07.615]         {
[16:21:07.615]             ...future.startTime <- base::Sys.time()
[16:21:07.615]             {
[16:21:07.615]                 {
[16:21:07.615]                   {
[16:21:07.615]                     {
[16:21:07.615]                       {
[16:21:07.615]                         base::local({
[16:21:07.615]                           has_future <- base::requireNamespace("future", 
[16:21:07.615]                             quietly = TRUE)
[16:21:07.615]                           if (has_future) {
[16:21:07.615]                             ns <- base::getNamespace("future")
[16:21:07.615]                             version <- ns[[".package"]][["version"]]
[16:21:07.615]                             if (is.null(version)) 
[16:21:07.615]                               version <- utils::packageVersion("future")
[16:21:07.615]                           }
[16:21:07.615]                           else {
[16:21:07.615]                             version <- NULL
[16:21:07.615]                           }
[16:21:07.615]                           if (!has_future || version < "1.8.0") {
[16:21:07.615]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.615]                               "", base::R.version$version.string), 
[16:21:07.615]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:07.615]                                 base::R.version$platform, 8 * 
[16:21:07.615]                                   base::.Machine$sizeof.pointer), 
[16:21:07.615]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.615]                                 "release", "version")], collapse = " "), 
[16:21:07.615]                               hostname = base::Sys.info()[["nodename"]])
[16:21:07.615]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.615]                               info)
[16:21:07.615]                             info <- base::paste(info, collapse = "; ")
[16:21:07.615]                             if (!has_future) {
[16:21:07.615]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.615]                                 info)
[16:21:07.615]                             }
[16:21:07.615]                             else {
[16:21:07.615]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.615]                                 info, version)
[16:21:07.615]                             }
[16:21:07.615]                             base::stop(msg)
[16:21:07.615]                           }
[16:21:07.615]                         })
[16:21:07.615]                       }
[16:21:07.615]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.615]                       base::options(mc.cores = 1L)
[16:21:07.615]                     }
[16:21:07.615]                     base::local({
[16:21:07.615]                       for (pkg in "future") {
[16:21:07.615]                         base::loadNamespace(pkg)
[16:21:07.615]                         base::library(pkg, character.only = TRUE)
[16:21:07.615]                       }
[16:21:07.615]                     })
[16:21:07.615]                   }
[16:21:07.615]                   ...future.strategy.old <- future::plan("list")
[16:21:07.615]                   options(future.plan = NULL)
[16:21:07.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.615]                 }
[16:21:07.615]                 ...future.workdir <- getwd()
[16:21:07.615]             }
[16:21:07.615]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.615]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.615]         }
[16:21:07.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.615]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.615]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.615]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.615]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.615]             base::names(...future.oldOptions))
[16:21:07.615]     }
[16:21:07.615]     if (FALSE) {
[16:21:07.615]     }
[16:21:07.615]     else {
[16:21:07.615]         if (TRUE) {
[16:21:07.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.615]                 open = "w")
[16:21:07.615]         }
[16:21:07.615]         else {
[16:21:07.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.615]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.615]         }
[16:21:07.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.615]             base::sink(type = "output", split = FALSE)
[16:21:07.615]             base::close(...future.stdout)
[16:21:07.615]         }, add = TRUE)
[16:21:07.615]     }
[16:21:07.615]     ...future.frame <- base::sys.nframe()
[16:21:07.615]     ...future.conditions <- base::list()
[16:21:07.615]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.615]     if (FALSE) {
[16:21:07.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.615]     }
[16:21:07.615]     ...future.result <- base::tryCatch({
[16:21:07.615]         base::withCallingHandlers({
[16:21:07.615]             ...future.value <- base::withVisible(base::local({
[16:21:07.615]                 ...future.makeSendCondition <- base::local({
[16:21:07.615]                   sendCondition <- NULL
[16:21:07.615]                   function(frame = 1L) {
[16:21:07.615]                     if (is.function(sendCondition)) 
[16:21:07.615]                       return(sendCondition)
[16:21:07.615]                     ns <- getNamespace("parallel")
[16:21:07.615]                     if (exists("sendData", mode = "function", 
[16:21:07.615]                       envir = ns)) {
[16:21:07.615]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.615]                         envir = ns)
[16:21:07.615]                       envir <- sys.frame(frame)
[16:21:07.615]                       master <- NULL
[16:21:07.615]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.615]                         !identical(envir, emptyenv())) {
[16:21:07.615]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.615]                           inherits = FALSE)) {
[16:21:07.615]                           master <- get("master", mode = "list", 
[16:21:07.615]                             envir = envir, inherits = FALSE)
[16:21:07.615]                           if (inherits(master, c("SOCKnode", 
[16:21:07.615]                             "SOCK0node"))) {
[16:21:07.615]                             sendCondition <<- function(cond) {
[16:21:07.615]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.615]                                 success = TRUE)
[16:21:07.615]                               parallel_sendData(master, data)
[16:21:07.615]                             }
[16:21:07.615]                             return(sendCondition)
[16:21:07.615]                           }
[16:21:07.615]                         }
[16:21:07.615]                         frame <- frame + 1L
[16:21:07.615]                         envir <- sys.frame(frame)
[16:21:07.615]                       }
[16:21:07.615]                     }
[16:21:07.615]                     sendCondition <<- function(cond) NULL
[16:21:07.615]                   }
[16:21:07.615]                 })
[16:21:07.615]                 withCallingHandlers({
[16:21:07.615]                   value(a) + 1
[16:21:07.615]                 }, immediateCondition = function(cond) {
[16:21:07.615]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.615]                   sendCondition(cond)
[16:21:07.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.615]                   {
[16:21:07.615]                     inherits <- base::inherits
[16:21:07.615]                     invokeRestart <- base::invokeRestart
[16:21:07.615]                     is.null <- base::is.null
[16:21:07.615]                     muffled <- FALSE
[16:21:07.615]                     if (inherits(cond, "message")) {
[16:21:07.615]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.615]                       if (muffled) 
[16:21:07.615]                         invokeRestart("muffleMessage")
[16:21:07.615]                     }
[16:21:07.615]                     else if (inherits(cond, "warning")) {
[16:21:07.615]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.615]                       if (muffled) 
[16:21:07.615]                         invokeRestart("muffleWarning")
[16:21:07.615]                     }
[16:21:07.615]                     else if (inherits(cond, "condition")) {
[16:21:07.615]                       if (!is.null(pattern)) {
[16:21:07.615]                         computeRestarts <- base::computeRestarts
[16:21:07.615]                         grepl <- base::grepl
[16:21:07.615]                         restarts <- computeRestarts(cond)
[16:21:07.615]                         for (restart in restarts) {
[16:21:07.615]                           name <- restart$name
[16:21:07.615]                           if (is.null(name)) 
[16:21:07.615]                             next
[16:21:07.615]                           if (!grepl(pattern, name)) 
[16:21:07.615]                             next
[16:21:07.615]                           invokeRestart(restart)
[16:21:07.615]                           muffled <- TRUE
[16:21:07.615]                           break
[16:21:07.615]                         }
[16:21:07.615]                       }
[16:21:07.615]                     }
[16:21:07.615]                     invisible(muffled)
[16:21:07.615]                   }
[16:21:07.615]                   muffleCondition(cond)
[16:21:07.615]                 })
[16:21:07.615]             }))
[16:21:07.615]             future::FutureResult(value = ...future.value$value, 
[16:21:07.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.615]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.615]                     ...future.globalenv.names))
[16:21:07.615]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.615]         }, condition = base::local({
[16:21:07.615]             c <- base::c
[16:21:07.615]             inherits <- base::inherits
[16:21:07.615]             invokeRestart <- base::invokeRestart
[16:21:07.615]             length <- base::length
[16:21:07.615]             list <- base::list
[16:21:07.615]             seq.int <- base::seq.int
[16:21:07.615]             signalCondition <- base::signalCondition
[16:21:07.615]             sys.calls <- base::sys.calls
[16:21:07.615]             `[[` <- base::`[[`
[16:21:07.615]             `+` <- base::`+`
[16:21:07.615]             `<<-` <- base::`<<-`
[16:21:07.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.615]                   3L)]
[16:21:07.615]             }
[16:21:07.615]             function(cond) {
[16:21:07.615]                 is_error <- inherits(cond, "error")
[16:21:07.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.615]                   NULL)
[16:21:07.615]                 if (is_error) {
[16:21:07.615]                   sessionInformation <- function() {
[16:21:07.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.615]                       search = base::search(), system = base::Sys.info())
[16:21:07.615]                   }
[16:21:07.615]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.615]                     cond$call), session = sessionInformation(), 
[16:21:07.615]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.615]                   signalCondition(cond)
[16:21:07.615]                 }
[16:21:07.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.615]                 "immediateCondition"))) {
[16:21:07.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.615]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.615]                   if (TRUE && !signal) {
[16:21:07.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.615]                     {
[16:21:07.615]                       inherits <- base::inherits
[16:21:07.615]                       invokeRestart <- base::invokeRestart
[16:21:07.615]                       is.null <- base::is.null
[16:21:07.615]                       muffled <- FALSE
[16:21:07.615]                       if (inherits(cond, "message")) {
[16:21:07.615]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.615]                         if (muffled) 
[16:21:07.615]                           invokeRestart("muffleMessage")
[16:21:07.615]                       }
[16:21:07.615]                       else if (inherits(cond, "warning")) {
[16:21:07.615]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.615]                         if (muffled) 
[16:21:07.615]                           invokeRestart("muffleWarning")
[16:21:07.615]                       }
[16:21:07.615]                       else if (inherits(cond, "condition")) {
[16:21:07.615]                         if (!is.null(pattern)) {
[16:21:07.615]                           computeRestarts <- base::computeRestarts
[16:21:07.615]                           grepl <- base::grepl
[16:21:07.615]                           restarts <- computeRestarts(cond)
[16:21:07.615]                           for (restart in restarts) {
[16:21:07.615]                             name <- restart$name
[16:21:07.615]                             if (is.null(name)) 
[16:21:07.615]                               next
[16:21:07.615]                             if (!grepl(pattern, name)) 
[16:21:07.615]                               next
[16:21:07.615]                             invokeRestart(restart)
[16:21:07.615]                             muffled <- TRUE
[16:21:07.615]                             break
[16:21:07.615]                           }
[16:21:07.615]                         }
[16:21:07.615]                       }
[16:21:07.615]                       invisible(muffled)
[16:21:07.615]                     }
[16:21:07.615]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.615]                   }
[16:21:07.615]                 }
[16:21:07.615]                 else {
[16:21:07.615]                   if (TRUE) {
[16:21:07.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.615]                     {
[16:21:07.615]                       inherits <- base::inherits
[16:21:07.615]                       invokeRestart <- base::invokeRestart
[16:21:07.615]                       is.null <- base::is.null
[16:21:07.615]                       muffled <- FALSE
[16:21:07.615]                       if (inherits(cond, "message")) {
[16:21:07.615]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.615]                         if (muffled) 
[16:21:07.615]                           invokeRestart("muffleMessage")
[16:21:07.615]                       }
[16:21:07.615]                       else if (inherits(cond, "warning")) {
[16:21:07.615]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.615]                         if (muffled) 
[16:21:07.615]                           invokeRestart("muffleWarning")
[16:21:07.615]                       }
[16:21:07.615]                       else if (inherits(cond, "condition")) {
[16:21:07.615]                         if (!is.null(pattern)) {
[16:21:07.615]                           computeRestarts <- base::computeRestarts
[16:21:07.615]                           grepl <- base::grepl
[16:21:07.615]                           restarts <- computeRestarts(cond)
[16:21:07.615]                           for (restart in restarts) {
[16:21:07.615]                             name <- restart$name
[16:21:07.615]                             if (is.null(name)) 
[16:21:07.615]                               next
[16:21:07.615]                             if (!grepl(pattern, name)) 
[16:21:07.615]                               next
[16:21:07.615]                             invokeRestart(restart)
[16:21:07.615]                             muffled <- TRUE
[16:21:07.615]                             break
[16:21:07.615]                           }
[16:21:07.615]                         }
[16:21:07.615]                       }
[16:21:07.615]                       invisible(muffled)
[16:21:07.615]                     }
[16:21:07.615]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.615]                   }
[16:21:07.615]                 }
[16:21:07.615]             }
[16:21:07.615]         }))
[16:21:07.615]     }, error = function(ex) {
[16:21:07.615]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.615]                 ...future.rng), started = ...future.startTime, 
[16:21:07.615]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.615]             version = "1.8"), class = "FutureResult")
[16:21:07.615]     }, finally = {
[16:21:07.615]         if (!identical(...future.workdir, getwd())) 
[16:21:07.615]             setwd(...future.workdir)
[16:21:07.615]         {
[16:21:07.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.615]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.615]             }
[16:21:07.615]             base::options(...future.oldOptions)
[16:21:07.615]             if (.Platform$OS.type == "windows") {
[16:21:07.615]                 old_names <- names(...future.oldEnvVars)
[16:21:07.615]                 envs <- base::Sys.getenv()
[16:21:07.615]                 names <- names(envs)
[16:21:07.615]                 common <- intersect(names, old_names)
[16:21:07.615]                 added <- setdiff(names, old_names)
[16:21:07.615]                 removed <- setdiff(old_names, names)
[16:21:07.615]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.615]                   envs[common]]
[16:21:07.615]                 NAMES <- toupper(changed)
[16:21:07.615]                 args <- list()
[16:21:07.615]                 for (kk in seq_along(NAMES)) {
[16:21:07.615]                   name <- changed[[kk]]
[16:21:07.615]                   NAME <- NAMES[[kk]]
[16:21:07.615]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.615]                     next
[16:21:07.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.615]                 }
[16:21:07.615]                 NAMES <- toupper(added)
[16:21:07.615]                 for (kk in seq_along(NAMES)) {
[16:21:07.615]                   name <- added[[kk]]
[16:21:07.615]                   NAME <- NAMES[[kk]]
[16:21:07.615]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.615]                     next
[16:21:07.615]                   args[[name]] <- ""
[16:21:07.615]                 }
[16:21:07.615]                 NAMES <- toupper(removed)
[16:21:07.615]                 for (kk in seq_along(NAMES)) {
[16:21:07.615]                   name <- removed[[kk]]
[16:21:07.615]                   NAME <- NAMES[[kk]]
[16:21:07.615]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.615]                     next
[16:21:07.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.615]                 }
[16:21:07.615]                 if (length(args) > 0) 
[16:21:07.615]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.615]             }
[16:21:07.615]             else {
[16:21:07.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.615]             }
[16:21:07.615]             {
[16:21:07.615]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.615]                   0L) {
[16:21:07.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.615]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.615]                   base::options(opts)
[16:21:07.615]                 }
[16:21:07.615]                 {
[16:21:07.615]                   {
[16:21:07.615]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.615]                     NULL
[16:21:07.615]                   }
[16:21:07.615]                   options(future.plan = NULL)
[16:21:07.615]                   if (is.na(NA_character_)) 
[16:21:07.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.615]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.615]                     .init = FALSE)
[16:21:07.615]                 }
[16:21:07.615]             }
[16:21:07.615]         }
[16:21:07.615]     })
[16:21:07.615]     if (TRUE) {
[16:21:07.615]         base::sink(type = "output", split = FALSE)
[16:21:07.615]         if (TRUE) {
[16:21:07.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.615]         }
[16:21:07.615]         else {
[16:21:07.615]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.615]         }
[16:21:07.615]         base::close(...future.stdout)
[16:21:07.615]         ...future.stdout <- NULL
[16:21:07.615]     }
[16:21:07.615]     ...future.result$conditions <- ...future.conditions
[16:21:07.615]     ...future.result$finished <- base::Sys.time()
[16:21:07.615]     ...future.result
[16:21:07.615] }
[16:21:07.618] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[16:21:07.620] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[16:21:07.673] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[16:21:07.673] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[16:21:07.673] MultisessionFuture started
[16:21:07.673] - Launch lazy future ... done
[16:21:07.674] run() for ‘MultisessionFuture’ ... done
[16:21:07.674] result() for ClusterFuture ...
[16:21:07.674] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.674] - Validating connection of MultisessionFuture
[16:21:07.718] - received message: FutureResult
[16:21:07.719] - Received FutureResult
[16:21:07.719] - Erased future from FutureRegistry
[16:21:07.719] result() for ClusterFuture ...
[16:21:07.719] - result already collected: FutureResult
[16:21:07.719] result() for ClusterFuture ... done
[16:21:07.719] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.719] result() for ClusterFuture ... done
[16:21:07.719] result() for ClusterFuture ...
[16:21:07.719] - result already collected: FutureResult
[16:21:07.719] result() for ClusterFuture ... done
value(b) = 2
[16:21:07.720] result() for ClusterFuture ...
[16:21:07.720] - result already collected: FutureResult
[16:21:07.720] result() for ClusterFuture ... done
[16:21:07.720] result() for ClusterFuture ...
[16:21:07.720] - result already collected: FutureResult
[16:21:07.720] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.720] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.721] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.721] 
[16:21:07.721] Searching for globals ... DONE
[16:21:07.721] - globals: [0] <none>
[16:21:07.721] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.722] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.722] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.723] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:07.723] Searching for globals ... DONE
[16:21:07.723] Resolving globals: TRUE
[16:21:07.723] Resolving any globals that are futures ...
[16:21:07.723] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:07.723] Resolving any globals that are futures ... DONE
[16:21:07.723] Resolving futures part of globals (recursively) ...
[16:21:07.724] resolve() on list ...
[16:21:07.724]  recursive: 99
[16:21:07.724]  length: 1
[16:21:07.724]  elements: ‘a’
[16:21:07.724] run() for ‘Future’ ...
[16:21:07.724] - state: ‘created’
[16:21:07.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.740] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.740]   - Field: ‘node’
[16:21:07.741]   - Field: ‘label’
[16:21:07.741]   - Field: ‘local’
[16:21:07.741]   - Field: ‘owner’
[16:21:07.741]   - Field: ‘envir’
[16:21:07.741]   - Field: ‘workers’
[16:21:07.741]   - Field: ‘packages’
[16:21:07.741]   - Field: ‘gc’
[16:21:07.741]   - Field: ‘conditions’
[16:21:07.741]   - Field: ‘persistent’
[16:21:07.741]   - Field: ‘expr’
[16:21:07.742]   - Field: ‘uuid’
[16:21:07.742]   - Field: ‘seed’
[16:21:07.742]   - Field: ‘version’
[16:21:07.742]   - Field: ‘result’
[16:21:07.742]   - Field: ‘asynchronous’
[16:21:07.742]   - Field: ‘calls’
[16:21:07.742]   - Field: ‘globals’
[16:21:07.742]   - Field: ‘stdout’
[16:21:07.742]   - Field: ‘earlySignal’
[16:21:07.742]   - Field: ‘lazy’
[16:21:07.742]   - Field: ‘state’
[16:21:07.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.743] - Launch lazy future ...
[16:21:07.743] Packages needed by the future expression (n = 0): <none>
[16:21:07.743] Packages needed by future strategies (n = 0): <none>
[16:21:07.743] {
[16:21:07.743]     {
[16:21:07.743]         {
[16:21:07.743]             ...future.startTime <- base::Sys.time()
[16:21:07.743]             {
[16:21:07.743]                 {
[16:21:07.743]                   {
[16:21:07.743]                     {
[16:21:07.743]                       base::local({
[16:21:07.743]                         has_future <- base::requireNamespace("future", 
[16:21:07.743]                           quietly = TRUE)
[16:21:07.743]                         if (has_future) {
[16:21:07.743]                           ns <- base::getNamespace("future")
[16:21:07.743]                           version <- ns[[".package"]][["version"]]
[16:21:07.743]                           if (is.null(version)) 
[16:21:07.743]                             version <- utils::packageVersion("future")
[16:21:07.743]                         }
[16:21:07.743]                         else {
[16:21:07.743]                           version <- NULL
[16:21:07.743]                         }
[16:21:07.743]                         if (!has_future || version < "1.8.0") {
[16:21:07.743]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.743]                             "", base::R.version$version.string), 
[16:21:07.743]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.743]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.743]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.743]                               "release", "version")], collapse = " "), 
[16:21:07.743]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.743]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.743]                             info)
[16:21:07.743]                           info <- base::paste(info, collapse = "; ")
[16:21:07.743]                           if (!has_future) {
[16:21:07.743]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.743]                               info)
[16:21:07.743]                           }
[16:21:07.743]                           else {
[16:21:07.743]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.743]                               info, version)
[16:21:07.743]                           }
[16:21:07.743]                           base::stop(msg)
[16:21:07.743]                         }
[16:21:07.743]                       })
[16:21:07.743]                     }
[16:21:07.743]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.743]                     base::options(mc.cores = 1L)
[16:21:07.743]                   }
[16:21:07.743]                   ...future.strategy.old <- future::plan("list")
[16:21:07.743]                   options(future.plan = NULL)
[16:21:07.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.743]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.743]                 }
[16:21:07.743]                 ...future.workdir <- getwd()
[16:21:07.743]             }
[16:21:07.743]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.743]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.743]         }
[16:21:07.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.743]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.743]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.743]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.743]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.743]             base::names(...future.oldOptions))
[16:21:07.743]     }
[16:21:07.743]     if (FALSE) {
[16:21:07.743]     }
[16:21:07.743]     else {
[16:21:07.743]         if (TRUE) {
[16:21:07.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.743]                 open = "w")
[16:21:07.743]         }
[16:21:07.743]         else {
[16:21:07.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.743]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.743]         }
[16:21:07.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.743]             base::sink(type = "output", split = FALSE)
[16:21:07.743]             base::close(...future.stdout)
[16:21:07.743]         }, add = TRUE)
[16:21:07.743]     }
[16:21:07.743]     ...future.frame <- base::sys.nframe()
[16:21:07.743]     ...future.conditions <- base::list()
[16:21:07.743]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.743]     if (FALSE) {
[16:21:07.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.743]     }
[16:21:07.743]     ...future.result <- base::tryCatch({
[16:21:07.743]         base::withCallingHandlers({
[16:21:07.743]             ...future.value <- base::withVisible(base::local({
[16:21:07.743]                 ...future.makeSendCondition <- base::local({
[16:21:07.743]                   sendCondition <- NULL
[16:21:07.743]                   function(frame = 1L) {
[16:21:07.743]                     if (is.function(sendCondition)) 
[16:21:07.743]                       return(sendCondition)
[16:21:07.743]                     ns <- getNamespace("parallel")
[16:21:07.743]                     if (exists("sendData", mode = "function", 
[16:21:07.743]                       envir = ns)) {
[16:21:07.743]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.743]                         envir = ns)
[16:21:07.743]                       envir <- sys.frame(frame)
[16:21:07.743]                       master <- NULL
[16:21:07.743]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.743]                         !identical(envir, emptyenv())) {
[16:21:07.743]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.743]                           inherits = FALSE)) {
[16:21:07.743]                           master <- get("master", mode = "list", 
[16:21:07.743]                             envir = envir, inherits = FALSE)
[16:21:07.743]                           if (inherits(master, c("SOCKnode", 
[16:21:07.743]                             "SOCK0node"))) {
[16:21:07.743]                             sendCondition <<- function(cond) {
[16:21:07.743]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.743]                                 success = TRUE)
[16:21:07.743]                               parallel_sendData(master, data)
[16:21:07.743]                             }
[16:21:07.743]                             return(sendCondition)
[16:21:07.743]                           }
[16:21:07.743]                         }
[16:21:07.743]                         frame <- frame + 1L
[16:21:07.743]                         envir <- sys.frame(frame)
[16:21:07.743]                       }
[16:21:07.743]                     }
[16:21:07.743]                     sendCondition <<- function(cond) NULL
[16:21:07.743]                   }
[16:21:07.743]                 })
[16:21:07.743]                 withCallingHandlers({
[16:21:07.743]                   1
[16:21:07.743]                 }, immediateCondition = function(cond) {
[16:21:07.743]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.743]                   sendCondition(cond)
[16:21:07.743]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.743]                   {
[16:21:07.743]                     inherits <- base::inherits
[16:21:07.743]                     invokeRestart <- base::invokeRestart
[16:21:07.743]                     is.null <- base::is.null
[16:21:07.743]                     muffled <- FALSE
[16:21:07.743]                     if (inherits(cond, "message")) {
[16:21:07.743]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.743]                       if (muffled) 
[16:21:07.743]                         invokeRestart("muffleMessage")
[16:21:07.743]                     }
[16:21:07.743]                     else if (inherits(cond, "warning")) {
[16:21:07.743]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.743]                       if (muffled) 
[16:21:07.743]                         invokeRestart("muffleWarning")
[16:21:07.743]                     }
[16:21:07.743]                     else if (inherits(cond, "condition")) {
[16:21:07.743]                       if (!is.null(pattern)) {
[16:21:07.743]                         computeRestarts <- base::computeRestarts
[16:21:07.743]                         grepl <- base::grepl
[16:21:07.743]                         restarts <- computeRestarts(cond)
[16:21:07.743]                         for (restart in restarts) {
[16:21:07.743]                           name <- restart$name
[16:21:07.743]                           if (is.null(name)) 
[16:21:07.743]                             next
[16:21:07.743]                           if (!grepl(pattern, name)) 
[16:21:07.743]                             next
[16:21:07.743]                           invokeRestart(restart)
[16:21:07.743]                           muffled <- TRUE
[16:21:07.743]                           break
[16:21:07.743]                         }
[16:21:07.743]                       }
[16:21:07.743]                     }
[16:21:07.743]                     invisible(muffled)
[16:21:07.743]                   }
[16:21:07.743]                   muffleCondition(cond)
[16:21:07.743]                 })
[16:21:07.743]             }))
[16:21:07.743]             future::FutureResult(value = ...future.value$value, 
[16:21:07.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.743]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.743]                     ...future.globalenv.names))
[16:21:07.743]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.743]         }, condition = base::local({
[16:21:07.743]             c <- base::c
[16:21:07.743]             inherits <- base::inherits
[16:21:07.743]             invokeRestart <- base::invokeRestart
[16:21:07.743]             length <- base::length
[16:21:07.743]             list <- base::list
[16:21:07.743]             seq.int <- base::seq.int
[16:21:07.743]             signalCondition <- base::signalCondition
[16:21:07.743]             sys.calls <- base::sys.calls
[16:21:07.743]             `[[` <- base::`[[`
[16:21:07.743]             `+` <- base::`+`
[16:21:07.743]             `<<-` <- base::`<<-`
[16:21:07.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.743]                   3L)]
[16:21:07.743]             }
[16:21:07.743]             function(cond) {
[16:21:07.743]                 is_error <- inherits(cond, "error")
[16:21:07.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.743]                   NULL)
[16:21:07.743]                 if (is_error) {
[16:21:07.743]                   sessionInformation <- function() {
[16:21:07.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.743]                       search = base::search(), system = base::Sys.info())
[16:21:07.743]                   }
[16:21:07.743]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.743]                     cond$call), session = sessionInformation(), 
[16:21:07.743]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.743]                   signalCondition(cond)
[16:21:07.743]                 }
[16:21:07.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.743]                 "immediateCondition"))) {
[16:21:07.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.743]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.743]                   if (TRUE && !signal) {
[16:21:07.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.743]                     {
[16:21:07.743]                       inherits <- base::inherits
[16:21:07.743]                       invokeRestart <- base::invokeRestart
[16:21:07.743]                       is.null <- base::is.null
[16:21:07.743]                       muffled <- FALSE
[16:21:07.743]                       if (inherits(cond, "message")) {
[16:21:07.743]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.743]                         if (muffled) 
[16:21:07.743]                           invokeRestart("muffleMessage")
[16:21:07.743]                       }
[16:21:07.743]                       else if (inherits(cond, "warning")) {
[16:21:07.743]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.743]                         if (muffled) 
[16:21:07.743]                           invokeRestart("muffleWarning")
[16:21:07.743]                       }
[16:21:07.743]                       else if (inherits(cond, "condition")) {
[16:21:07.743]                         if (!is.null(pattern)) {
[16:21:07.743]                           computeRestarts <- base::computeRestarts
[16:21:07.743]                           grepl <- base::grepl
[16:21:07.743]                           restarts <- computeRestarts(cond)
[16:21:07.743]                           for (restart in restarts) {
[16:21:07.743]                             name <- restart$name
[16:21:07.743]                             if (is.null(name)) 
[16:21:07.743]                               next
[16:21:07.743]                             if (!grepl(pattern, name)) 
[16:21:07.743]                               next
[16:21:07.743]                             invokeRestart(restart)
[16:21:07.743]                             muffled <- TRUE
[16:21:07.743]                             break
[16:21:07.743]                           }
[16:21:07.743]                         }
[16:21:07.743]                       }
[16:21:07.743]                       invisible(muffled)
[16:21:07.743]                     }
[16:21:07.743]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.743]                   }
[16:21:07.743]                 }
[16:21:07.743]                 else {
[16:21:07.743]                   if (TRUE) {
[16:21:07.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.743]                     {
[16:21:07.743]                       inherits <- base::inherits
[16:21:07.743]                       invokeRestart <- base::invokeRestart
[16:21:07.743]                       is.null <- base::is.null
[16:21:07.743]                       muffled <- FALSE
[16:21:07.743]                       if (inherits(cond, "message")) {
[16:21:07.743]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.743]                         if (muffled) 
[16:21:07.743]                           invokeRestart("muffleMessage")
[16:21:07.743]                       }
[16:21:07.743]                       else if (inherits(cond, "warning")) {
[16:21:07.743]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.743]                         if (muffled) 
[16:21:07.743]                           invokeRestart("muffleWarning")
[16:21:07.743]                       }
[16:21:07.743]                       else if (inherits(cond, "condition")) {
[16:21:07.743]                         if (!is.null(pattern)) {
[16:21:07.743]                           computeRestarts <- base::computeRestarts
[16:21:07.743]                           grepl <- base::grepl
[16:21:07.743]                           restarts <- computeRestarts(cond)
[16:21:07.743]                           for (restart in restarts) {
[16:21:07.743]                             name <- restart$name
[16:21:07.743]                             if (is.null(name)) 
[16:21:07.743]                               next
[16:21:07.743]                             if (!grepl(pattern, name)) 
[16:21:07.743]                               next
[16:21:07.743]                             invokeRestart(restart)
[16:21:07.743]                             muffled <- TRUE
[16:21:07.743]                             break
[16:21:07.743]                           }
[16:21:07.743]                         }
[16:21:07.743]                       }
[16:21:07.743]                       invisible(muffled)
[16:21:07.743]                     }
[16:21:07.743]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.743]                   }
[16:21:07.743]                 }
[16:21:07.743]             }
[16:21:07.743]         }))
[16:21:07.743]     }, error = function(ex) {
[16:21:07.743]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.743]                 ...future.rng), started = ...future.startTime, 
[16:21:07.743]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.743]             version = "1.8"), class = "FutureResult")
[16:21:07.743]     }, finally = {
[16:21:07.743]         if (!identical(...future.workdir, getwd())) 
[16:21:07.743]             setwd(...future.workdir)
[16:21:07.743]         {
[16:21:07.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.743]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.743]             }
[16:21:07.743]             base::options(...future.oldOptions)
[16:21:07.743]             if (.Platform$OS.type == "windows") {
[16:21:07.743]                 old_names <- names(...future.oldEnvVars)
[16:21:07.743]                 envs <- base::Sys.getenv()
[16:21:07.743]                 names <- names(envs)
[16:21:07.743]                 common <- intersect(names, old_names)
[16:21:07.743]                 added <- setdiff(names, old_names)
[16:21:07.743]                 removed <- setdiff(old_names, names)
[16:21:07.743]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.743]                   envs[common]]
[16:21:07.743]                 NAMES <- toupper(changed)
[16:21:07.743]                 args <- list()
[16:21:07.743]                 for (kk in seq_along(NAMES)) {
[16:21:07.743]                   name <- changed[[kk]]
[16:21:07.743]                   NAME <- NAMES[[kk]]
[16:21:07.743]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.743]                     next
[16:21:07.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.743]                 }
[16:21:07.743]                 NAMES <- toupper(added)
[16:21:07.743]                 for (kk in seq_along(NAMES)) {
[16:21:07.743]                   name <- added[[kk]]
[16:21:07.743]                   NAME <- NAMES[[kk]]
[16:21:07.743]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.743]                     next
[16:21:07.743]                   args[[name]] <- ""
[16:21:07.743]                 }
[16:21:07.743]                 NAMES <- toupper(removed)
[16:21:07.743]                 for (kk in seq_along(NAMES)) {
[16:21:07.743]                   name <- removed[[kk]]
[16:21:07.743]                   NAME <- NAMES[[kk]]
[16:21:07.743]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.743]                     next
[16:21:07.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.743]                 }
[16:21:07.743]                 if (length(args) > 0) 
[16:21:07.743]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.743]             }
[16:21:07.743]             else {
[16:21:07.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.743]             }
[16:21:07.743]             {
[16:21:07.743]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.743]                   0L) {
[16:21:07.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.743]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.743]                   base::options(opts)
[16:21:07.743]                 }
[16:21:07.743]                 {
[16:21:07.743]                   {
[16:21:07.743]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.743]                     NULL
[16:21:07.743]                   }
[16:21:07.743]                   options(future.plan = NULL)
[16:21:07.743]                   if (is.na(NA_character_)) 
[16:21:07.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.743]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.743]                     .init = FALSE)
[16:21:07.743]                 }
[16:21:07.743]             }
[16:21:07.743]         }
[16:21:07.743]     })
[16:21:07.743]     if (TRUE) {
[16:21:07.743]         base::sink(type = "output", split = FALSE)
[16:21:07.743]         if (TRUE) {
[16:21:07.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.743]         }
[16:21:07.743]         else {
[16:21:07.743]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.743]         }
[16:21:07.743]         base::close(...future.stdout)
[16:21:07.743]         ...future.stdout <- NULL
[16:21:07.743]     }
[16:21:07.743]     ...future.result$conditions <- ...future.conditions
[16:21:07.743]     ...future.result$finished <- base::Sys.time()
[16:21:07.743]     ...future.result
[16:21:07.743] }
[16:21:07.746] MultisessionFuture started
[16:21:07.747] - Launch lazy future ... done
[16:21:07.747] run() for ‘MultisessionFuture’ ... done
[16:21:07.790] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.790] - Validating connection of MultisessionFuture
[16:21:07.790] - received message: FutureResult
[16:21:07.791] - Received FutureResult
[16:21:07.791] - Erased future from FutureRegistry
[16:21:07.791] result() for ClusterFuture ...
[16:21:07.791] - result already collected: FutureResult
[16:21:07.791] result() for ClusterFuture ... done
[16:21:07.791] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.791] Future #1
[16:21:07.791] result() for ClusterFuture ...
[16:21:07.791] - result already collected: FutureResult
[16:21:07.791] result() for ClusterFuture ... done
[16:21:07.791] result() for ClusterFuture ...
[16:21:07.792] - result already collected: FutureResult
[16:21:07.792] result() for ClusterFuture ... done
[16:21:07.792] A MultisessionFuture was resolved
[16:21:07.792]  length: 0 (resolved future 1)
[16:21:07.792] resolve() on list ... DONE
[16:21:07.792] - globals: [1] ‘a’
[16:21:07.792] Resolving futures part of globals (recursively) ... DONE
[16:21:07.794] The total size of the 1 globals is 1.57 MiB (1646896 bytes)
[16:21:07.795] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:21:07.795] - globals: [1] ‘a’
[16:21:07.795] - packages: [1] ‘future’
[16:21:07.795] getGlobalsAndPackages() ... DONE
[16:21:07.795] run() for ‘Future’ ...
[16:21:07.795] - state: ‘created’
[16:21:07.796] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.810]   - Field: ‘node’
[16:21:07.810]   - Field: ‘label’
[16:21:07.810]   - Field: ‘local’
[16:21:07.810]   - Field: ‘owner’
[16:21:07.810]   - Field: ‘envir’
[16:21:07.810]   - Field: ‘workers’
[16:21:07.810]   - Field: ‘packages’
[16:21:07.810]   - Field: ‘gc’
[16:21:07.811]   - Field: ‘conditions’
[16:21:07.811]   - Field: ‘persistent’
[16:21:07.811]   - Field: ‘expr’
[16:21:07.811]   - Field: ‘uuid’
[16:21:07.811]   - Field: ‘seed’
[16:21:07.811]   - Field: ‘version’
[16:21:07.811]   - Field: ‘result’
[16:21:07.811]   - Field: ‘asynchronous’
[16:21:07.811]   - Field: ‘calls’
[16:21:07.811]   - Field: ‘globals’
[16:21:07.812]   - Field: ‘stdout’
[16:21:07.812]   - Field: ‘earlySignal’
[16:21:07.812]   - Field: ‘lazy’
[16:21:07.812]   - Field: ‘state’
[16:21:07.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.812] - Launch lazy future ...
[16:21:07.812] Packages needed by the future expression (n = 1): ‘future’
[16:21:07.812] Packages needed by future strategies (n = 0): <none>
[16:21:07.813] {
[16:21:07.813]     {
[16:21:07.813]         {
[16:21:07.813]             ...future.startTime <- base::Sys.time()
[16:21:07.813]             {
[16:21:07.813]                 {
[16:21:07.813]                   {
[16:21:07.813]                     {
[16:21:07.813]                       {
[16:21:07.813]                         base::local({
[16:21:07.813]                           has_future <- base::requireNamespace("future", 
[16:21:07.813]                             quietly = TRUE)
[16:21:07.813]                           if (has_future) {
[16:21:07.813]                             ns <- base::getNamespace("future")
[16:21:07.813]                             version <- ns[[".package"]][["version"]]
[16:21:07.813]                             if (is.null(version)) 
[16:21:07.813]                               version <- utils::packageVersion("future")
[16:21:07.813]                           }
[16:21:07.813]                           else {
[16:21:07.813]                             version <- NULL
[16:21:07.813]                           }
[16:21:07.813]                           if (!has_future || version < "1.8.0") {
[16:21:07.813]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.813]                               "", base::R.version$version.string), 
[16:21:07.813]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:07.813]                                 base::R.version$platform, 8 * 
[16:21:07.813]                                   base::.Machine$sizeof.pointer), 
[16:21:07.813]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.813]                                 "release", "version")], collapse = " "), 
[16:21:07.813]                               hostname = base::Sys.info()[["nodename"]])
[16:21:07.813]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.813]                               info)
[16:21:07.813]                             info <- base::paste(info, collapse = "; ")
[16:21:07.813]                             if (!has_future) {
[16:21:07.813]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.813]                                 info)
[16:21:07.813]                             }
[16:21:07.813]                             else {
[16:21:07.813]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.813]                                 info, version)
[16:21:07.813]                             }
[16:21:07.813]                             base::stop(msg)
[16:21:07.813]                           }
[16:21:07.813]                         })
[16:21:07.813]                       }
[16:21:07.813]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.813]                       base::options(mc.cores = 1L)
[16:21:07.813]                     }
[16:21:07.813]                     base::local({
[16:21:07.813]                       for (pkg in "future") {
[16:21:07.813]                         base::loadNamespace(pkg)
[16:21:07.813]                         base::library(pkg, character.only = TRUE)
[16:21:07.813]                       }
[16:21:07.813]                     })
[16:21:07.813]                   }
[16:21:07.813]                   ...future.strategy.old <- future::plan("list")
[16:21:07.813]                   options(future.plan = NULL)
[16:21:07.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.813]                 }
[16:21:07.813]                 ...future.workdir <- getwd()
[16:21:07.813]             }
[16:21:07.813]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.813]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.813]         }
[16:21:07.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.813]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.813]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.813]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.813]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.813]             base::names(...future.oldOptions))
[16:21:07.813]     }
[16:21:07.813]     if (FALSE) {
[16:21:07.813]     }
[16:21:07.813]     else {
[16:21:07.813]         if (TRUE) {
[16:21:07.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.813]                 open = "w")
[16:21:07.813]         }
[16:21:07.813]         else {
[16:21:07.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.813]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.813]         }
[16:21:07.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.813]             base::sink(type = "output", split = FALSE)
[16:21:07.813]             base::close(...future.stdout)
[16:21:07.813]         }, add = TRUE)
[16:21:07.813]     }
[16:21:07.813]     ...future.frame <- base::sys.nframe()
[16:21:07.813]     ...future.conditions <- base::list()
[16:21:07.813]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.813]     if (FALSE) {
[16:21:07.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.813]     }
[16:21:07.813]     ...future.result <- base::tryCatch({
[16:21:07.813]         base::withCallingHandlers({
[16:21:07.813]             ...future.value <- base::withVisible(base::local({
[16:21:07.813]                 ...future.makeSendCondition <- base::local({
[16:21:07.813]                   sendCondition <- NULL
[16:21:07.813]                   function(frame = 1L) {
[16:21:07.813]                     if (is.function(sendCondition)) 
[16:21:07.813]                       return(sendCondition)
[16:21:07.813]                     ns <- getNamespace("parallel")
[16:21:07.813]                     if (exists("sendData", mode = "function", 
[16:21:07.813]                       envir = ns)) {
[16:21:07.813]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.813]                         envir = ns)
[16:21:07.813]                       envir <- sys.frame(frame)
[16:21:07.813]                       master <- NULL
[16:21:07.813]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.813]                         !identical(envir, emptyenv())) {
[16:21:07.813]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.813]                           inherits = FALSE)) {
[16:21:07.813]                           master <- get("master", mode = "list", 
[16:21:07.813]                             envir = envir, inherits = FALSE)
[16:21:07.813]                           if (inherits(master, c("SOCKnode", 
[16:21:07.813]                             "SOCK0node"))) {
[16:21:07.813]                             sendCondition <<- function(cond) {
[16:21:07.813]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.813]                                 success = TRUE)
[16:21:07.813]                               parallel_sendData(master, data)
[16:21:07.813]                             }
[16:21:07.813]                             return(sendCondition)
[16:21:07.813]                           }
[16:21:07.813]                         }
[16:21:07.813]                         frame <- frame + 1L
[16:21:07.813]                         envir <- sys.frame(frame)
[16:21:07.813]                       }
[16:21:07.813]                     }
[16:21:07.813]                     sendCondition <<- function(cond) NULL
[16:21:07.813]                   }
[16:21:07.813]                 })
[16:21:07.813]                 withCallingHandlers({
[16:21:07.813]                   value(a) + 1
[16:21:07.813]                 }, immediateCondition = function(cond) {
[16:21:07.813]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.813]                   sendCondition(cond)
[16:21:07.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.813]                   {
[16:21:07.813]                     inherits <- base::inherits
[16:21:07.813]                     invokeRestart <- base::invokeRestart
[16:21:07.813]                     is.null <- base::is.null
[16:21:07.813]                     muffled <- FALSE
[16:21:07.813]                     if (inherits(cond, "message")) {
[16:21:07.813]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.813]                       if (muffled) 
[16:21:07.813]                         invokeRestart("muffleMessage")
[16:21:07.813]                     }
[16:21:07.813]                     else if (inherits(cond, "warning")) {
[16:21:07.813]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.813]                       if (muffled) 
[16:21:07.813]                         invokeRestart("muffleWarning")
[16:21:07.813]                     }
[16:21:07.813]                     else if (inherits(cond, "condition")) {
[16:21:07.813]                       if (!is.null(pattern)) {
[16:21:07.813]                         computeRestarts <- base::computeRestarts
[16:21:07.813]                         grepl <- base::grepl
[16:21:07.813]                         restarts <- computeRestarts(cond)
[16:21:07.813]                         for (restart in restarts) {
[16:21:07.813]                           name <- restart$name
[16:21:07.813]                           if (is.null(name)) 
[16:21:07.813]                             next
[16:21:07.813]                           if (!grepl(pattern, name)) 
[16:21:07.813]                             next
[16:21:07.813]                           invokeRestart(restart)
[16:21:07.813]                           muffled <- TRUE
[16:21:07.813]                           break
[16:21:07.813]                         }
[16:21:07.813]                       }
[16:21:07.813]                     }
[16:21:07.813]                     invisible(muffled)
[16:21:07.813]                   }
[16:21:07.813]                   muffleCondition(cond)
[16:21:07.813]                 })
[16:21:07.813]             }))
[16:21:07.813]             future::FutureResult(value = ...future.value$value, 
[16:21:07.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.813]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.813]                     ...future.globalenv.names))
[16:21:07.813]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.813]         }, condition = base::local({
[16:21:07.813]             c <- base::c
[16:21:07.813]             inherits <- base::inherits
[16:21:07.813]             invokeRestart <- base::invokeRestart
[16:21:07.813]             length <- base::length
[16:21:07.813]             list <- base::list
[16:21:07.813]             seq.int <- base::seq.int
[16:21:07.813]             signalCondition <- base::signalCondition
[16:21:07.813]             sys.calls <- base::sys.calls
[16:21:07.813]             `[[` <- base::`[[`
[16:21:07.813]             `+` <- base::`+`
[16:21:07.813]             `<<-` <- base::`<<-`
[16:21:07.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.813]                   3L)]
[16:21:07.813]             }
[16:21:07.813]             function(cond) {
[16:21:07.813]                 is_error <- inherits(cond, "error")
[16:21:07.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.813]                   NULL)
[16:21:07.813]                 if (is_error) {
[16:21:07.813]                   sessionInformation <- function() {
[16:21:07.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.813]                       search = base::search(), system = base::Sys.info())
[16:21:07.813]                   }
[16:21:07.813]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.813]                     cond$call), session = sessionInformation(), 
[16:21:07.813]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.813]                   signalCondition(cond)
[16:21:07.813]                 }
[16:21:07.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.813]                 "immediateCondition"))) {
[16:21:07.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.813]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.813]                   if (TRUE && !signal) {
[16:21:07.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.813]                     {
[16:21:07.813]                       inherits <- base::inherits
[16:21:07.813]                       invokeRestart <- base::invokeRestart
[16:21:07.813]                       is.null <- base::is.null
[16:21:07.813]                       muffled <- FALSE
[16:21:07.813]                       if (inherits(cond, "message")) {
[16:21:07.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.813]                         if (muffled) 
[16:21:07.813]                           invokeRestart("muffleMessage")
[16:21:07.813]                       }
[16:21:07.813]                       else if (inherits(cond, "warning")) {
[16:21:07.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.813]                         if (muffled) 
[16:21:07.813]                           invokeRestart("muffleWarning")
[16:21:07.813]                       }
[16:21:07.813]                       else if (inherits(cond, "condition")) {
[16:21:07.813]                         if (!is.null(pattern)) {
[16:21:07.813]                           computeRestarts <- base::computeRestarts
[16:21:07.813]                           grepl <- base::grepl
[16:21:07.813]                           restarts <- computeRestarts(cond)
[16:21:07.813]                           for (restart in restarts) {
[16:21:07.813]                             name <- restart$name
[16:21:07.813]                             if (is.null(name)) 
[16:21:07.813]                               next
[16:21:07.813]                             if (!grepl(pattern, name)) 
[16:21:07.813]                               next
[16:21:07.813]                             invokeRestart(restart)
[16:21:07.813]                             muffled <- TRUE
[16:21:07.813]                             break
[16:21:07.813]                           }
[16:21:07.813]                         }
[16:21:07.813]                       }
[16:21:07.813]                       invisible(muffled)
[16:21:07.813]                     }
[16:21:07.813]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.813]                   }
[16:21:07.813]                 }
[16:21:07.813]                 else {
[16:21:07.813]                   if (TRUE) {
[16:21:07.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.813]                     {
[16:21:07.813]                       inherits <- base::inherits
[16:21:07.813]                       invokeRestart <- base::invokeRestart
[16:21:07.813]                       is.null <- base::is.null
[16:21:07.813]                       muffled <- FALSE
[16:21:07.813]                       if (inherits(cond, "message")) {
[16:21:07.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.813]                         if (muffled) 
[16:21:07.813]                           invokeRestart("muffleMessage")
[16:21:07.813]                       }
[16:21:07.813]                       else if (inherits(cond, "warning")) {
[16:21:07.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.813]                         if (muffled) 
[16:21:07.813]                           invokeRestart("muffleWarning")
[16:21:07.813]                       }
[16:21:07.813]                       else if (inherits(cond, "condition")) {
[16:21:07.813]                         if (!is.null(pattern)) {
[16:21:07.813]                           computeRestarts <- base::computeRestarts
[16:21:07.813]                           grepl <- base::grepl
[16:21:07.813]                           restarts <- computeRestarts(cond)
[16:21:07.813]                           for (restart in restarts) {
[16:21:07.813]                             name <- restart$name
[16:21:07.813]                             if (is.null(name)) 
[16:21:07.813]                               next
[16:21:07.813]                             if (!grepl(pattern, name)) 
[16:21:07.813]                               next
[16:21:07.813]                             invokeRestart(restart)
[16:21:07.813]                             muffled <- TRUE
[16:21:07.813]                             break
[16:21:07.813]                           }
[16:21:07.813]                         }
[16:21:07.813]                       }
[16:21:07.813]                       invisible(muffled)
[16:21:07.813]                     }
[16:21:07.813]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.813]                   }
[16:21:07.813]                 }
[16:21:07.813]             }
[16:21:07.813]         }))
[16:21:07.813]     }, error = function(ex) {
[16:21:07.813]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.813]                 ...future.rng), started = ...future.startTime, 
[16:21:07.813]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.813]             version = "1.8"), class = "FutureResult")
[16:21:07.813]     }, finally = {
[16:21:07.813]         if (!identical(...future.workdir, getwd())) 
[16:21:07.813]             setwd(...future.workdir)
[16:21:07.813]         {
[16:21:07.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.813]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.813]             }
[16:21:07.813]             base::options(...future.oldOptions)
[16:21:07.813]             if (.Platform$OS.type == "windows") {
[16:21:07.813]                 old_names <- names(...future.oldEnvVars)
[16:21:07.813]                 envs <- base::Sys.getenv()
[16:21:07.813]                 names <- names(envs)
[16:21:07.813]                 common <- intersect(names, old_names)
[16:21:07.813]                 added <- setdiff(names, old_names)
[16:21:07.813]                 removed <- setdiff(old_names, names)
[16:21:07.813]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.813]                   envs[common]]
[16:21:07.813]                 NAMES <- toupper(changed)
[16:21:07.813]                 args <- list()
[16:21:07.813]                 for (kk in seq_along(NAMES)) {
[16:21:07.813]                   name <- changed[[kk]]
[16:21:07.813]                   NAME <- NAMES[[kk]]
[16:21:07.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.813]                     next
[16:21:07.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.813]                 }
[16:21:07.813]                 NAMES <- toupper(added)
[16:21:07.813]                 for (kk in seq_along(NAMES)) {
[16:21:07.813]                   name <- added[[kk]]
[16:21:07.813]                   NAME <- NAMES[[kk]]
[16:21:07.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.813]                     next
[16:21:07.813]                   args[[name]] <- ""
[16:21:07.813]                 }
[16:21:07.813]                 NAMES <- toupper(removed)
[16:21:07.813]                 for (kk in seq_along(NAMES)) {
[16:21:07.813]                   name <- removed[[kk]]
[16:21:07.813]                   NAME <- NAMES[[kk]]
[16:21:07.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.813]                     next
[16:21:07.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.813]                 }
[16:21:07.813]                 if (length(args) > 0) 
[16:21:07.813]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.813]             }
[16:21:07.813]             else {
[16:21:07.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.813]             }
[16:21:07.813]             {
[16:21:07.813]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.813]                   0L) {
[16:21:07.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.813]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.813]                   base::options(opts)
[16:21:07.813]                 }
[16:21:07.813]                 {
[16:21:07.813]                   {
[16:21:07.813]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.813]                     NULL
[16:21:07.813]                   }
[16:21:07.813]                   options(future.plan = NULL)
[16:21:07.813]                   if (is.na(NA_character_)) 
[16:21:07.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.813]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.813]                     .init = FALSE)
[16:21:07.813]                 }
[16:21:07.813]             }
[16:21:07.813]         }
[16:21:07.813]     })
[16:21:07.813]     if (TRUE) {
[16:21:07.813]         base::sink(type = "output", split = FALSE)
[16:21:07.813]         if (TRUE) {
[16:21:07.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.813]         }
[16:21:07.813]         else {
[16:21:07.813]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.813]         }
[16:21:07.813]         base::close(...future.stdout)
[16:21:07.813]         ...future.stdout <- NULL
[16:21:07.813]     }
[16:21:07.813]     ...future.result$conditions <- ...future.conditions
[16:21:07.813]     ...future.result$finished <- base::Sys.time()
[16:21:07.813]     ...future.result
[16:21:07.813] }
[16:21:07.815] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[16:21:07.817] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[16:21:07.869] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[16:21:07.869] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[16:21:07.870] MultisessionFuture started
[16:21:07.870] - Launch lazy future ... done
[16:21:07.870] run() for ‘MultisessionFuture’ ... done
[16:21:07.870] result() for ClusterFuture ...
[16:21:07.870] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.870] - Validating connection of MultisessionFuture
[16:21:07.914] - received message: FutureResult
[16:21:07.915] - Received FutureResult
[16:21:07.915] - Erased future from FutureRegistry
[16:21:07.915] result() for ClusterFuture ...
[16:21:07.915] - result already collected: FutureResult
[16:21:07.915] result() for ClusterFuture ... done
[16:21:07.915] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.915] result() for ClusterFuture ... done
[16:21:07.915] result() for ClusterFuture ...
[16:21:07.915] - result already collected: FutureResult
[16:21:07.916] result() for ClusterFuture ... done
value(b) = 2
[16:21:07.916] result() for ClusterFuture ...
[16:21:07.916] - result already collected: FutureResult
[16:21:07.916] result() for ClusterFuture ... done
[16:21:07.916] result() for ClusterFuture ...
[16:21:07.916] - result already collected: FutureResult
[16:21:07.916] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.916] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.917] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.917] 
[16:21:07.917] Searching for globals ... DONE
[16:21:07.917] - globals: [0] <none>
[16:21:07.917] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:07.918] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:07.918] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:07.919] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:21:07.919] Searching for globals ... DONE
[16:21:07.919] Resolving globals: TRUE
[16:21:07.919] Resolving any globals that are futures ...
[16:21:07.919] - globals: [3] ‘+’, ‘value’, ‘a’
[16:21:07.919] Resolving any globals that are futures ... DONE
[16:21:07.920] Resolving futures part of globals (recursively) ...
[16:21:07.920] resolve() on list ...
[16:21:07.920]  recursive: 99
[16:21:07.920]  length: 1
[16:21:07.920]  elements: ‘a’
[16:21:07.920] run() for ‘Future’ ...
[16:21:07.920] - state: ‘created’
[16:21:07.921] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:07.935] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:07.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:07.935]   - Field: ‘node’
[16:21:07.935]   - Field: ‘label’
[16:21:07.935]   - Field: ‘local’
[16:21:07.935]   - Field: ‘owner’
[16:21:07.936]   - Field: ‘envir’
[16:21:07.936]   - Field: ‘workers’
[16:21:07.936]   - Field: ‘packages’
[16:21:07.936]   - Field: ‘gc’
[16:21:07.936]   - Field: ‘conditions’
[16:21:07.936]   - Field: ‘persistent’
[16:21:07.936]   - Field: ‘expr’
[16:21:07.936]   - Field: ‘uuid’
[16:21:07.936]   - Field: ‘seed’
[16:21:07.936]   - Field: ‘version’
[16:21:07.937]   - Field: ‘result’
[16:21:07.937]   - Field: ‘asynchronous’
[16:21:07.937]   - Field: ‘calls’
[16:21:07.937]   - Field: ‘globals’
[16:21:07.937]   - Field: ‘stdout’
[16:21:07.937]   - Field: ‘earlySignal’
[16:21:07.937]   - Field: ‘lazy’
[16:21:07.937]   - Field: ‘state’
[16:21:07.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:07.937] - Launch lazy future ...
[16:21:07.938] Packages needed by the future expression (n = 0): <none>
[16:21:07.938] Packages needed by future strategies (n = 0): <none>
[16:21:07.938] {
[16:21:07.938]     {
[16:21:07.938]         {
[16:21:07.938]             ...future.startTime <- base::Sys.time()
[16:21:07.938]             {
[16:21:07.938]                 {
[16:21:07.938]                   {
[16:21:07.938]                     {
[16:21:07.938]                       base::local({
[16:21:07.938]                         has_future <- base::requireNamespace("future", 
[16:21:07.938]                           quietly = TRUE)
[16:21:07.938]                         if (has_future) {
[16:21:07.938]                           ns <- base::getNamespace("future")
[16:21:07.938]                           version <- ns[[".package"]][["version"]]
[16:21:07.938]                           if (is.null(version)) 
[16:21:07.938]                             version <- utils::packageVersion("future")
[16:21:07.938]                         }
[16:21:07.938]                         else {
[16:21:07.938]                           version <- NULL
[16:21:07.938]                         }
[16:21:07.938]                         if (!has_future || version < "1.8.0") {
[16:21:07.938]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:07.938]                             "", base::R.version$version.string), 
[16:21:07.938]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:07.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:07.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:07.938]                               "release", "version")], collapse = " "), 
[16:21:07.938]                             hostname = base::Sys.info()[["nodename"]])
[16:21:07.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:07.938]                             info)
[16:21:07.938]                           info <- base::paste(info, collapse = "; ")
[16:21:07.938]                           if (!has_future) {
[16:21:07.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:07.938]                               info)
[16:21:07.938]                           }
[16:21:07.938]                           else {
[16:21:07.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:07.938]                               info, version)
[16:21:07.938]                           }
[16:21:07.938]                           base::stop(msg)
[16:21:07.938]                         }
[16:21:07.938]                       })
[16:21:07.938]                     }
[16:21:07.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:07.938]                     base::options(mc.cores = 1L)
[16:21:07.938]                   }
[16:21:07.938]                   ...future.strategy.old <- future::plan("list")
[16:21:07.938]                   options(future.plan = NULL)
[16:21:07.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:07.938]                 }
[16:21:07.938]                 ...future.workdir <- getwd()
[16:21:07.938]             }
[16:21:07.938]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:07.938]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:07.938]         }
[16:21:07.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:07.938]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:07.938]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:07.938]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:07.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:07.938]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:07.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:07.938]             base::names(...future.oldOptions))
[16:21:07.938]     }
[16:21:07.938]     if (FALSE) {
[16:21:07.938]     }
[16:21:07.938]     else {
[16:21:07.938]         if (TRUE) {
[16:21:07.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:07.938]                 open = "w")
[16:21:07.938]         }
[16:21:07.938]         else {
[16:21:07.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:07.938]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:07.938]         }
[16:21:07.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:07.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:07.938]             base::sink(type = "output", split = FALSE)
[16:21:07.938]             base::close(...future.stdout)
[16:21:07.938]         }, add = TRUE)
[16:21:07.938]     }
[16:21:07.938]     ...future.frame <- base::sys.nframe()
[16:21:07.938]     ...future.conditions <- base::list()
[16:21:07.938]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:07.938]     if (FALSE) {
[16:21:07.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:07.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:07.938]     }
[16:21:07.938]     ...future.result <- base::tryCatch({
[16:21:07.938]         base::withCallingHandlers({
[16:21:07.938]             ...future.value <- base::withVisible(base::local({
[16:21:07.938]                 ...future.makeSendCondition <- base::local({
[16:21:07.938]                   sendCondition <- NULL
[16:21:07.938]                   function(frame = 1L) {
[16:21:07.938]                     if (is.function(sendCondition)) 
[16:21:07.938]                       return(sendCondition)
[16:21:07.938]                     ns <- getNamespace("parallel")
[16:21:07.938]                     if (exists("sendData", mode = "function", 
[16:21:07.938]                       envir = ns)) {
[16:21:07.938]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:07.938]                         envir = ns)
[16:21:07.938]                       envir <- sys.frame(frame)
[16:21:07.938]                       master <- NULL
[16:21:07.938]                       while (!identical(envir, .GlobalEnv) && 
[16:21:07.938]                         !identical(envir, emptyenv())) {
[16:21:07.938]                         if (exists("master", mode = "list", envir = envir, 
[16:21:07.938]                           inherits = FALSE)) {
[16:21:07.938]                           master <- get("master", mode = "list", 
[16:21:07.938]                             envir = envir, inherits = FALSE)
[16:21:07.938]                           if (inherits(master, c("SOCKnode", 
[16:21:07.938]                             "SOCK0node"))) {
[16:21:07.938]                             sendCondition <<- function(cond) {
[16:21:07.938]                               data <- list(type = "VALUE", value = cond, 
[16:21:07.938]                                 success = TRUE)
[16:21:07.938]                               parallel_sendData(master, data)
[16:21:07.938]                             }
[16:21:07.938]                             return(sendCondition)
[16:21:07.938]                           }
[16:21:07.938]                         }
[16:21:07.938]                         frame <- frame + 1L
[16:21:07.938]                         envir <- sys.frame(frame)
[16:21:07.938]                       }
[16:21:07.938]                     }
[16:21:07.938]                     sendCondition <<- function(cond) NULL
[16:21:07.938]                   }
[16:21:07.938]                 })
[16:21:07.938]                 withCallingHandlers({
[16:21:07.938]                   1
[16:21:07.938]                 }, immediateCondition = function(cond) {
[16:21:07.938]                   sendCondition <- ...future.makeSendCondition()
[16:21:07.938]                   sendCondition(cond)
[16:21:07.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.938]                   {
[16:21:07.938]                     inherits <- base::inherits
[16:21:07.938]                     invokeRestart <- base::invokeRestart
[16:21:07.938]                     is.null <- base::is.null
[16:21:07.938]                     muffled <- FALSE
[16:21:07.938]                     if (inherits(cond, "message")) {
[16:21:07.938]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:07.938]                       if (muffled) 
[16:21:07.938]                         invokeRestart("muffleMessage")
[16:21:07.938]                     }
[16:21:07.938]                     else if (inherits(cond, "warning")) {
[16:21:07.938]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:07.938]                       if (muffled) 
[16:21:07.938]                         invokeRestart("muffleWarning")
[16:21:07.938]                     }
[16:21:07.938]                     else if (inherits(cond, "condition")) {
[16:21:07.938]                       if (!is.null(pattern)) {
[16:21:07.938]                         computeRestarts <- base::computeRestarts
[16:21:07.938]                         grepl <- base::grepl
[16:21:07.938]                         restarts <- computeRestarts(cond)
[16:21:07.938]                         for (restart in restarts) {
[16:21:07.938]                           name <- restart$name
[16:21:07.938]                           if (is.null(name)) 
[16:21:07.938]                             next
[16:21:07.938]                           if (!grepl(pattern, name)) 
[16:21:07.938]                             next
[16:21:07.938]                           invokeRestart(restart)
[16:21:07.938]                           muffled <- TRUE
[16:21:07.938]                           break
[16:21:07.938]                         }
[16:21:07.938]                       }
[16:21:07.938]                     }
[16:21:07.938]                     invisible(muffled)
[16:21:07.938]                   }
[16:21:07.938]                   muffleCondition(cond)
[16:21:07.938]                 })
[16:21:07.938]             }))
[16:21:07.938]             future::FutureResult(value = ...future.value$value, 
[16:21:07.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.938]                   ...future.rng), globalenv = if (FALSE) 
[16:21:07.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:07.938]                     ...future.globalenv.names))
[16:21:07.938]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:07.938]         }, condition = base::local({
[16:21:07.938]             c <- base::c
[16:21:07.938]             inherits <- base::inherits
[16:21:07.938]             invokeRestart <- base::invokeRestart
[16:21:07.938]             length <- base::length
[16:21:07.938]             list <- base::list
[16:21:07.938]             seq.int <- base::seq.int
[16:21:07.938]             signalCondition <- base::signalCondition
[16:21:07.938]             sys.calls <- base::sys.calls
[16:21:07.938]             `[[` <- base::`[[`
[16:21:07.938]             `+` <- base::`+`
[16:21:07.938]             `<<-` <- base::`<<-`
[16:21:07.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:07.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:07.938]                   3L)]
[16:21:07.938]             }
[16:21:07.938]             function(cond) {
[16:21:07.938]                 is_error <- inherits(cond, "error")
[16:21:07.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:07.938]                   NULL)
[16:21:07.938]                 if (is_error) {
[16:21:07.938]                   sessionInformation <- function() {
[16:21:07.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:07.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:07.938]                       search = base::search(), system = base::Sys.info())
[16:21:07.938]                   }
[16:21:07.938]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:07.938]                     cond$call), session = sessionInformation(), 
[16:21:07.938]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:07.938]                   signalCondition(cond)
[16:21:07.938]                 }
[16:21:07.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:07.938]                 "immediateCondition"))) {
[16:21:07.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:07.938]                   ...future.conditions[[length(...future.conditions) + 
[16:21:07.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:07.938]                   if (TRUE && !signal) {
[16:21:07.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.938]                     {
[16:21:07.938]                       inherits <- base::inherits
[16:21:07.938]                       invokeRestart <- base::invokeRestart
[16:21:07.938]                       is.null <- base::is.null
[16:21:07.938]                       muffled <- FALSE
[16:21:07.938]                       if (inherits(cond, "message")) {
[16:21:07.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.938]                         if (muffled) 
[16:21:07.938]                           invokeRestart("muffleMessage")
[16:21:07.938]                       }
[16:21:07.938]                       else if (inherits(cond, "warning")) {
[16:21:07.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.938]                         if (muffled) 
[16:21:07.938]                           invokeRestart("muffleWarning")
[16:21:07.938]                       }
[16:21:07.938]                       else if (inherits(cond, "condition")) {
[16:21:07.938]                         if (!is.null(pattern)) {
[16:21:07.938]                           computeRestarts <- base::computeRestarts
[16:21:07.938]                           grepl <- base::grepl
[16:21:07.938]                           restarts <- computeRestarts(cond)
[16:21:07.938]                           for (restart in restarts) {
[16:21:07.938]                             name <- restart$name
[16:21:07.938]                             if (is.null(name)) 
[16:21:07.938]                               next
[16:21:07.938]                             if (!grepl(pattern, name)) 
[16:21:07.938]                               next
[16:21:07.938]                             invokeRestart(restart)
[16:21:07.938]                             muffled <- TRUE
[16:21:07.938]                             break
[16:21:07.938]                           }
[16:21:07.938]                         }
[16:21:07.938]                       }
[16:21:07.938]                       invisible(muffled)
[16:21:07.938]                     }
[16:21:07.938]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.938]                   }
[16:21:07.938]                 }
[16:21:07.938]                 else {
[16:21:07.938]                   if (TRUE) {
[16:21:07.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:07.938]                     {
[16:21:07.938]                       inherits <- base::inherits
[16:21:07.938]                       invokeRestart <- base::invokeRestart
[16:21:07.938]                       is.null <- base::is.null
[16:21:07.938]                       muffled <- FALSE
[16:21:07.938]                       if (inherits(cond, "message")) {
[16:21:07.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:07.938]                         if (muffled) 
[16:21:07.938]                           invokeRestart("muffleMessage")
[16:21:07.938]                       }
[16:21:07.938]                       else if (inherits(cond, "warning")) {
[16:21:07.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:07.938]                         if (muffled) 
[16:21:07.938]                           invokeRestart("muffleWarning")
[16:21:07.938]                       }
[16:21:07.938]                       else if (inherits(cond, "condition")) {
[16:21:07.938]                         if (!is.null(pattern)) {
[16:21:07.938]                           computeRestarts <- base::computeRestarts
[16:21:07.938]                           grepl <- base::grepl
[16:21:07.938]                           restarts <- computeRestarts(cond)
[16:21:07.938]                           for (restart in restarts) {
[16:21:07.938]                             name <- restart$name
[16:21:07.938]                             if (is.null(name)) 
[16:21:07.938]                               next
[16:21:07.938]                             if (!grepl(pattern, name)) 
[16:21:07.938]                               next
[16:21:07.938]                             invokeRestart(restart)
[16:21:07.938]                             muffled <- TRUE
[16:21:07.938]                             break
[16:21:07.938]                           }
[16:21:07.938]                         }
[16:21:07.938]                       }
[16:21:07.938]                       invisible(muffled)
[16:21:07.938]                     }
[16:21:07.938]                     muffleCondition(cond, pattern = "^muffle")
[16:21:07.938]                   }
[16:21:07.938]                 }
[16:21:07.938]             }
[16:21:07.938]         }))
[16:21:07.938]     }, error = function(ex) {
[16:21:07.938]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:07.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:07.938]                 ...future.rng), started = ...future.startTime, 
[16:21:07.938]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:07.938]             version = "1.8"), class = "FutureResult")
[16:21:07.938]     }, finally = {
[16:21:07.938]         if (!identical(...future.workdir, getwd())) 
[16:21:07.938]             setwd(...future.workdir)
[16:21:07.938]         {
[16:21:07.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:07.938]                 ...future.oldOptions$nwarnings <- NULL
[16:21:07.938]             }
[16:21:07.938]             base::options(...future.oldOptions)
[16:21:07.938]             if (.Platform$OS.type == "windows") {
[16:21:07.938]                 old_names <- names(...future.oldEnvVars)
[16:21:07.938]                 envs <- base::Sys.getenv()
[16:21:07.938]                 names <- names(envs)
[16:21:07.938]                 common <- intersect(names, old_names)
[16:21:07.938]                 added <- setdiff(names, old_names)
[16:21:07.938]                 removed <- setdiff(old_names, names)
[16:21:07.938]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:07.938]                   envs[common]]
[16:21:07.938]                 NAMES <- toupper(changed)
[16:21:07.938]                 args <- list()
[16:21:07.938]                 for (kk in seq_along(NAMES)) {
[16:21:07.938]                   name <- changed[[kk]]
[16:21:07.938]                   NAME <- NAMES[[kk]]
[16:21:07.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.938]                     next
[16:21:07.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.938]                 }
[16:21:07.938]                 NAMES <- toupper(added)
[16:21:07.938]                 for (kk in seq_along(NAMES)) {
[16:21:07.938]                   name <- added[[kk]]
[16:21:07.938]                   NAME <- NAMES[[kk]]
[16:21:07.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.938]                     next
[16:21:07.938]                   args[[name]] <- ""
[16:21:07.938]                 }
[16:21:07.938]                 NAMES <- toupper(removed)
[16:21:07.938]                 for (kk in seq_along(NAMES)) {
[16:21:07.938]                   name <- removed[[kk]]
[16:21:07.938]                   NAME <- NAMES[[kk]]
[16:21:07.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:07.938]                     next
[16:21:07.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:07.938]                 }
[16:21:07.938]                 if (length(args) > 0) 
[16:21:07.938]                   base::do.call(base::Sys.setenv, args = args)
[16:21:07.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:07.938]             }
[16:21:07.938]             else {
[16:21:07.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:07.938]             }
[16:21:07.938]             {
[16:21:07.938]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:07.938]                   0L) {
[16:21:07.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:07.938]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:07.938]                   base::options(opts)
[16:21:07.938]                 }
[16:21:07.938]                 {
[16:21:07.938]                   {
[16:21:07.938]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:07.938]                     NULL
[16:21:07.938]                   }
[16:21:07.938]                   options(future.plan = NULL)
[16:21:07.938]                   if (is.na(NA_character_)) 
[16:21:07.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:07.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:07.938]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:07.938]                     .init = FALSE)
[16:21:07.938]                 }
[16:21:07.938]             }
[16:21:07.938]         }
[16:21:07.938]     })
[16:21:07.938]     if (TRUE) {
[16:21:07.938]         base::sink(type = "output", split = FALSE)
[16:21:07.938]         if (TRUE) {
[16:21:07.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:07.938]         }
[16:21:07.938]         else {
[16:21:07.938]             ...future.result["stdout"] <- base::list(NULL)
[16:21:07.938]         }
[16:21:07.938]         base::close(...future.stdout)
[16:21:07.938]         ...future.stdout <- NULL
[16:21:07.938]     }
[16:21:07.938]     ...future.result$conditions <- ...future.conditions
[16:21:07.938]     ...future.result$finished <- base::Sys.time()
[16:21:07.938]     ...future.result
[16:21:07.938] }
[16:21:07.941] MultisessionFuture started
[16:21:07.941] - Launch lazy future ... done
[16:21:07.941] run() for ‘MultisessionFuture’ ... done
[16:21:07.986] receiveMessageFromWorker() for ClusterFuture ...
[16:21:07.986] - Validating connection of MultisessionFuture
[16:21:07.986] - received message: FutureResult
[16:21:07.987] - Received FutureResult
[16:21:07.987] - Erased future from FutureRegistry
[16:21:07.987] result() for ClusterFuture ...
[16:21:07.987] - result already collected: FutureResult
[16:21:07.987] result() for ClusterFuture ... done
[16:21:07.987] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:07.987] Future #1
[16:21:07.987] result() for ClusterFuture ...
[16:21:07.987] - result already collected: FutureResult
[16:21:07.988] result() for ClusterFuture ... done
[16:21:07.988] result() for ClusterFuture ...
[16:21:07.988] - result already collected: FutureResult
[16:21:07.988] result() for ClusterFuture ... done
[16:21:07.988] A MultisessionFuture was resolved
[16:21:07.988]  length: 0 (resolved future 1)
[16:21:07.988] resolve() on list ... DONE
[16:21:07.988] - globals: [1] ‘a’
[16:21:07.988] Resolving futures part of globals (recursively) ... DONE
[16:21:07.990] The total size of the 1 globals is 1.57 MiB (1646896 bytes)
[16:21:07.991] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:21:07.991] - globals: [1] ‘a’
[16:21:07.991] - packages: [1] ‘future’
[16:21:07.991] getGlobalsAndPackages() ... DONE
[16:21:07.991] run() for ‘Future’ ...
[16:21:07.992] - state: ‘created’
[16:21:07.992] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:08.006] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:08.006] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:08.006]   - Field: ‘node’
[16:21:08.006]   - Field: ‘label’
[16:21:08.007]   - Field: ‘local’
[16:21:08.007]   - Field: ‘owner’
[16:21:08.007]   - Field: ‘envir’
[16:21:08.007]   - Field: ‘workers’
[16:21:08.007]   - Field: ‘packages’
[16:21:08.007]   - Field: ‘gc’
[16:21:08.007]   - Field: ‘conditions’
[16:21:08.007]   - Field: ‘persistent’
[16:21:08.007]   - Field: ‘expr’
[16:21:08.007]   - Field: ‘uuid’
[16:21:08.007]   - Field: ‘seed’
[16:21:08.008]   - Field: ‘version’
[16:21:08.008]   - Field: ‘result’
[16:21:08.008]   - Field: ‘asynchronous’
[16:21:08.008]   - Field: ‘calls’
[16:21:08.008]   - Field: ‘globals’
[16:21:08.008]   - Field: ‘stdout’
[16:21:08.008]   - Field: ‘earlySignal’
[16:21:08.008]   - Field: ‘lazy’
[16:21:08.011]   - Field: ‘state’
[16:21:08.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:08.011] - Launch lazy future ...
[16:21:08.011] Packages needed by the future expression (n = 1): ‘future’
[16:21:08.012] Packages needed by future strategies (n = 0): <none>
[16:21:08.012] {
[16:21:08.012]     {
[16:21:08.012]         {
[16:21:08.012]             ...future.startTime <- base::Sys.time()
[16:21:08.012]             {
[16:21:08.012]                 {
[16:21:08.012]                   {
[16:21:08.012]                     {
[16:21:08.012]                       {
[16:21:08.012]                         base::local({
[16:21:08.012]                           has_future <- base::requireNamespace("future", 
[16:21:08.012]                             quietly = TRUE)
[16:21:08.012]                           if (has_future) {
[16:21:08.012]                             ns <- base::getNamespace("future")
[16:21:08.012]                             version <- ns[[".package"]][["version"]]
[16:21:08.012]                             if (is.null(version)) 
[16:21:08.012]                               version <- utils::packageVersion("future")
[16:21:08.012]                           }
[16:21:08.012]                           else {
[16:21:08.012]                             version <- NULL
[16:21:08.012]                           }
[16:21:08.012]                           if (!has_future || version < "1.8.0") {
[16:21:08.012]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:08.012]                               "", base::R.version$version.string), 
[16:21:08.012]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:08.012]                                 base::R.version$platform, 8 * 
[16:21:08.012]                                   base::.Machine$sizeof.pointer), 
[16:21:08.012]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:08.012]                                 "release", "version")], collapse = " "), 
[16:21:08.012]                               hostname = base::Sys.info()[["nodename"]])
[16:21:08.012]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:08.012]                               info)
[16:21:08.012]                             info <- base::paste(info, collapse = "; ")
[16:21:08.012]                             if (!has_future) {
[16:21:08.012]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:08.012]                                 info)
[16:21:08.012]                             }
[16:21:08.012]                             else {
[16:21:08.012]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:08.012]                                 info, version)
[16:21:08.012]                             }
[16:21:08.012]                             base::stop(msg)
[16:21:08.012]                           }
[16:21:08.012]                         })
[16:21:08.012]                       }
[16:21:08.012]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:08.012]                       base::options(mc.cores = 1L)
[16:21:08.012]                     }
[16:21:08.012]                     base::local({
[16:21:08.012]                       for (pkg in "future") {
[16:21:08.012]                         base::loadNamespace(pkg)
[16:21:08.012]                         base::library(pkg, character.only = TRUE)
[16:21:08.012]                       }
[16:21:08.012]                     })
[16:21:08.012]                   }
[16:21:08.012]                   ...future.strategy.old <- future::plan("list")
[16:21:08.012]                   options(future.plan = NULL)
[16:21:08.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:08.012]                 }
[16:21:08.012]                 ...future.workdir <- getwd()
[16:21:08.012]             }
[16:21:08.012]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:08.012]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:08.012]         }
[16:21:08.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:08.012]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:08.012]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:08.012]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:08.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:08.012]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:08.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:08.012]             base::names(...future.oldOptions))
[16:21:08.012]     }
[16:21:08.012]     if (FALSE) {
[16:21:08.012]     }
[16:21:08.012]     else {
[16:21:08.012]         if (TRUE) {
[16:21:08.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:08.012]                 open = "w")
[16:21:08.012]         }
[16:21:08.012]         else {
[16:21:08.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:08.012]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:08.012]         }
[16:21:08.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:08.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:08.012]             base::sink(type = "output", split = FALSE)
[16:21:08.012]             base::close(...future.stdout)
[16:21:08.012]         }, add = TRUE)
[16:21:08.012]     }
[16:21:08.012]     ...future.frame <- base::sys.nframe()
[16:21:08.012]     ...future.conditions <- base::list()
[16:21:08.012]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:08.012]     if (FALSE) {
[16:21:08.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:08.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:08.012]     }
[16:21:08.012]     ...future.result <- base::tryCatch({
[16:21:08.012]         base::withCallingHandlers({
[16:21:08.012]             ...future.value <- base::withVisible(base::local({
[16:21:08.012]                 ...future.makeSendCondition <- base::local({
[16:21:08.012]                   sendCondition <- NULL
[16:21:08.012]                   function(frame = 1L) {
[16:21:08.012]                     if (is.function(sendCondition)) 
[16:21:08.012]                       return(sendCondition)
[16:21:08.012]                     ns <- getNamespace("parallel")
[16:21:08.012]                     if (exists("sendData", mode = "function", 
[16:21:08.012]                       envir = ns)) {
[16:21:08.012]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:08.012]                         envir = ns)
[16:21:08.012]                       envir <- sys.frame(frame)
[16:21:08.012]                       master <- NULL
[16:21:08.012]                       while (!identical(envir, .GlobalEnv) && 
[16:21:08.012]                         !identical(envir, emptyenv())) {
[16:21:08.012]                         if (exists("master", mode = "list", envir = envir, 
[16:21:08.012]                           inherits = FALSE)) {
[16:21:08.012]                           master <- get("master", mode = "list", 
[16:21:08.012]                             envir = envir, inherits = FALSE)
[16:21:08.012]                           if (inherits(master, c("SOCKnode", 
[16:21:08.012]                             "SOCK0node"))) {
[16:21:08.012]                             sendCondition <<- function(cond) {
[16:21:08.012]                               data <- list(type = "VALUE", value = cond, 
[16:21:08.012]                                 success = TRUE)
[16:21:08.012]                               parallel_sendData(master, data)
[16:21:08.012]                             }
[16:21:08.012]                             return(sendCondition)
[16:21:08.012]                           }
[16:21:08.012]                         }
[16:21:08.012]                         frame <- frame + 1L
[16:21:08.012]                         envir <- sys.frame(frame)
[16:21:08.012]                       }
[16:21:08.012]                     }
[16:21:08.012]                     sendCondition <<- function(cond) NULL
[16:21:08.012]                   }
[16:21:08.012]                 })
[16:21:08.012]                 withCallingHandlers({
[16:21:08.012]                   value(a) + 1
[16:21:08.012]                 }, immediateCondition = function(cond) {
[16:21:08.012]                   sendCondition <- ...future.makeSendCondition()
[16:21:08.012]                   sendCondition(cond)
[16:21:08.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.012]                   {
[16:21:08.012]                     inherits <- base::inherits
[16:21:08.012]                     invokeRestart <- base::invokeRestart
[16:21:08.012]                     is.null <- base::is.null
[16:21:08.012]                     muffled <- FALSE
[16:21:08.012]                     if (inherits(cond, "message")) {
[16:21:08.012]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:08.012]                       if (muffled) 
[16:21:08.012]                         invokeRestart("muffleMessage")
[16:21:08.012]                     }
[16:21:08.012]                     else if (inherits(cond, "warning")) {
[16:21:08.012]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:08.012]                       if (muffled) 
[16:21:08.012]                         invokeRestart("muffleWarning")
[16:21:08.012]                     }
[16:21:08.012]                     else if (inherits(cond, "condition")) {
[16:21:08.012]                       if (!is.null(pattern)) {
[16:21:08.012]                         computeRestarts <- base::computeRestarts
[16:21:08.012]                         grepl <- base::grepl
[16:21:08.012]                         restarts <- computeRestarts(cond)
[16:21:08.012]                         for (restart in restarts) {
[16:21:08.012]                           name <- restart$name
[16:21:08.012]                           if (is.null(name)) 
[16:21:08.012]                             next
[16:21:08.012]                           if (!grepl(pattern, name)) 
[16:21:08.012]                             next
[16:21:08.012]                           invokeRestart(restart)
[16:21:08.012]                           muffled <- TRUE
[16:21:08.012]                           break
[16:21:08.012]                         }
[16:21:08.012]                       }
[16:21:08.012]                     }
[16:21:08.012]                     invisible(muffled)
[16:21:08.012]                   }
[16:21:08.012]                   muffleCondition(cond)
[16:21:08.012]                 })
[16:21:08.012]             }))
[16:21:08.012]             future::FutureResult(value = ...future.value$value, 
[16:21:08.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.012]                   ...future.rng), globalenv = if (FALSE) 
[16:21:08.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:08.012]                     ...future.globalenv.names))
[16:21:08.012]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:08.012]         }, condition = base::local({
[16:21:08.012]             c <- base::c
[16:21:08.012]             inherits <- base::inherits
[16:21:08.012]             invokeRestart <- base::invokeRestart
[16:21:08.012]             length <- base::length
[16:21:08.012]             list <- base::list
[16:21:08.012]             seq.int <- base::seq.int
[16:21:08.012]             signalCondition <- base::signalCondition
[16:21:08.012]             sys.calls <- base::sys.calls
[16:21:08.012]             `[[` <- base::`[[`
[16:21:08.012]             `+` <- base::`+`
[16:21:08.012]             `<<-` <- base::`<<-`
[16:21:08.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:08.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:08.012]                   3L)]
[16:21:08.012]             }
[16:21:08.012]             function(cond) {
[16:21:08.012]                 is_error <- inherits(cond, "error")
[16:21:08.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:08.012]                   NULL)
[16:21:08.012]                 if (is_error) {
[16:21:08.012]                   sessionInformation <- function() {
[16:21:08.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:08.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:08.012]                       search = base::search(), system = base::Sys.info())
[16:21:08.012]                   }
[16:21:08.012]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:08.012]                     cond$call), session = sessionInformation(), 
[16:21:08.012]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:08.012]                   signalCondition(cond)
[16:21:08.012]                 }
[16:21:08.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:08.012]                 "immediateCondition"))) {
[16:21:08.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:08.012]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:08.012]                   if (TRUE && !signal) {
[16:21:08.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.012]                     {
[16:21:08.012]                       inherits <- base::inherits
[16:21:08.012]                       invokeRestart <- base::invokeRestart
[16:21:08.012]                       is.null <- base::is.null
[16:21:08.012]                       muffled <- FALSE
[16:21:08.012]                       if (inherits(cond, "message")) {
[16:21:08.012]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.012]                         if (muffled) 
[16:21:08.012]                           invokeRestart("muffleMessage")
[16:21:08.012]                       }
[16:21:08.012]                       else if (inherits(cond, "warning")) {
[16:21:08.012]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.012]                         if (muffled) 
[16:21:08.012]                           invokeRestart("muffleWarning")
[16:21:08.012]                       }
[16:21:08.012]                       else if (inherits(cond, "condition")) {
[16:21:08.012]                         if (!is.null(pattern)) {
[16:21:08.012]                           computeRestarts <- base::computeRestarts
[16:21:08.012]                           grepl <- base::grepl
[16:21:08.012]                           restarts <- computeRestarts(cond)
[16:21:08.012]                           for (restart in restarts) {
[16:21:08.012]                             name <- restart$name
[16:21:08.012]                             if (is.null(name)) 
[16:21:08.012]                               next
[16:21:08.012]                             if (!grepl(pattern, name)) 
[16:21:08.012]                               next
[16:21:08.012]                             invokeRestart(restart)
[16:21:08.012]                             muffled <- TRUE
[16:21:08.012]                             break
[16:21:08.012]                           }
[16:21:08.012]                         }
[16:21:08.012]                       }
[16:21:08.012]                       invisible(muffled)
[16:21:08.012]                     }
[16:21:08.012]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.012]                   }
[16:21:08.012]                 }
[16:21:08.012]                 else {
[16:21:08.012]                   if (TRUE) {
[16:21:08.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.012]                     {
[16:21:08.012]                       inherits <- base::inherits
[16:21:08.012]                       invokeRestart <- base::invokeRestart
[16:21:08.012]                       is.null <- base::is.null
[16:21:08.012]                       muffled <- FALSE
[16:21:08.012]                       if (inherits(cond, "message")) {
[16:21:08.012]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.012]                         if (muffled) 
[16:21:08.012]                           invokeRestart("muffleMessage")
[16:21:08.012]                       }
[16:21:08.012]                       else if (inherits(cond, "warning")) {
[16:21:08.012]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.012]                         if (muffled) 
[16:21:08.012]                           invokeRestart("muffleWarning")
[16:21:08.012]                       }
[16:21:08.012]                       else if (inherits(cond, "condition")) {
[16:21:08.012]                         if (!is.null(pattern)) {
[16:21:08.012]                           computeRestarts <- base::computeRestarts
[16:21:08.012]                           grepl <- base::grepl
[16:21:08.012]                           restarts <- computeRestarts(cond)
[16:21:08.012]                           for (restart in restarts) {
[16:21:08.012]                             name <- restart$name
[16:21:08.012]                             if (is.null(name)) 
[16:21:08.012]                               next
[16:21:08.012]                             if (!grepl(pattern, name)) 
[16:21:08.012]                               next
[16:21:08.012]                             invokeRestart(restart)
[16:21:08.012]                             muffled <- TRUE
[16:21:08.012]                             break
[16:21:08.012]                           }
[16:21:08.012]                         }
[16:21:08.012]                       }
[16:21:08.012]                       invisible(muffled)
[16:21:08.012]                     }
[16:21:08.012]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.012]                   }
[16:21:08.012]                 }
[16:21:08.012]             }
[16:21:08.012]         }))
[16:21:08.012]     }, error = function(ex) {
[16:21:08.012]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:08.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.012]                 ...future.rng), started = ...future.startTime, 
[16:21:08.012]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:08.012]             version = "1.8"), class = "FutureResult")
[16:21:08.012]     }, finally = {
[16:21:08.012]         if (!identical(...future.workdir, getwd())) 
[16:21:08.012]             setwd(...future.workdir)
[16:21:08.012]         {
[16:21:08.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:08.012]                 ...future.oldOptions$nwarnings <- NULL
[16:21:08.012]             }
[16:21:08.012]             base::options(...future.oldOptions)
[16:21:08.012]             if (.Platform$OS.type == "windows") {
[16:21:08.012]                 old_names <- names(...future.oldEnvVars)
[16:21:08.012]                 envs <- base::Sys.getenv()
[16:21:08.012]                 names <- names(envs)
[16:21:08.012]                 common <- intersect(names, old_names)
[16:21:08.012]                 added <- setdiff(names, old_names)
[16:21:08.012]                 removed <- setdiff(old_names, names)
[16:21:08.012]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:08.012]                   envs[common]]
[16:21:08.012]                 NAMES <- toupper(changed)
[16:21:08.012]                 args <- list()
[16:21:08.012]                 for (kk in seq_along(NAMES)) {
[16:21:08.012]                   name <- changed[[kk]]
[16:21:08.012]                   NAME <- NAMES[[kk]]
[16:21:08.012]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.012]                     next
[16:21:08.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.012]                 }
[16:21:08.012]                 NAMES <- toupper(added)
[16:21:08.012]                 for (kk in seq_along(NAMES)) {
[16:21:08.012]                   name <- added[[kk]]
[16:21:08.012]                   NAME <- NAMES[[kk]]
[16:21:08.012]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.012]                     next
[16:21:08.012]                   args[[name]] <- ""
[16:21:08.012]                 }
[16:21:08.012]                 NAMES <- toupper(removed)
[16:21:08.012]                 for (kk in seq_along(NAMES)) {
[16:21:08.012]                   name <- removed[[kk]]
[16:21:08.012]                   NAME <- NAMES[[kk]]
[16:21:08.012]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.012]                     next
[16:21:08.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.012]                 }
[16:21:08.012]                 if (length(args) > 0) 
[16:21:08.012]                   base::do.call(base::Sys.setenv, args = args)
[16:21:08.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:08.012]             }
[16:21:08.012]             else {
[16:21:08.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:08.012]             }
[16:21:08.012]             {
[16:21:08.012]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:08.012]                   0L) {
[16:21:08.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:08.012]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:08.012]                   base::options(opts)
[16:21:08.012]                 }
[16:21:08.012]                 {
[16:21:08.012]                   {
[16:21:08.012]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:08.012]                     NULL
[16:21:08.012]                   }
[16:21:08.012]                   options(future.plan = NULL)
[16:21:08.012]                   if (is.na(NA_character_)) 
[16:21:08.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:08.012]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:08.012]                     .init = FALSE)
[16:21:08.012]                 }
[16:21:08.012]             }
[16:21:08.012]         }
[16:21:08.012]     })
[16:21:08.012]     if (TRUE) {
[16:21:08.012]         base::sink(type = "output", split = FALSE)
[16:21:08.012]         if (TRUE) {
[16:21:08.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:08.012]         }
[16:21:08.012]         else {
[16:21:08.012]             ...future.result["stdout"] <- base::list(NULL)
[16:21:08.012]         }
[16:21:08.012]         base::close(...future.stdout)
[16:21:08.012]         ...future.stdout <- NULL
[16:21:08.012]     }
[16:21:08.012]     ...future.result$conditions <- ...future.conditions
[16:21:08.012]     ...future.result$finished <- base::Sys.time()
[16:21:08.012]     ...future.result
[16:21:08.012] }
[16:21:08.015] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[16:21:08.017] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[16:21:08.069] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[16:21:08.069] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[16:21:08.070] MultisessionFuture started
[16:21:08.070] - Launch lazy future ... done
[16:21:08.070] run() for ‘MultisessionFuture’ ... done
[16:21:08.070] result() for ClusterFuture ...
[16:21:08.070] receiveMessageFromWorker() for ClusterFuture ...
[16:21:08.070] - Validating connection of MultisessionFuture
[16:21:08.114] - received message: FutureResult
[16:21:08.114] - Received FutureResult
[16:21:08.115] - Erased future from FutureRegistry
[16:21:08.115] result() for ClusterFuture ...
[16:21:08.115] - result already collected: FutureResult
[16:21:08.115] result() for ClusterFuture ... done
[16:21:08.115] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:08.115] result() for ClusterFuture ... done
[16:21:08.115] result() for ClusterFuture ...
[16:21:08.115] - result already collected: FutureResult
[16:21:08.115] result() for ClusterFuture ... done
value(b) = 2
[16:21:08.116] result() for ClusterFuture ...
[16:21:08.116] - result already collected: FutureResult
[16:21:08.116] result() for ClusterFuture ... done
[16:21:08.116] result() for ClusterFuture ...
[16:21:08.116] - result already collected: FutureResult
[16:21:08.116] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:08.116] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:08.117] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:08.117] - globals found: [2] ‘{’, ‘pkg’
[16:21:08.118] Searching for globals ... DONE
[16:21:08.118] Resolving globals: TRUE
[16:21:08.118] Resolving any globals that are futures ...
[16:21:08.118] - globals: [2] ‘{’, ‘pkg’
[16:21:08.118] Resolving any globals that are futures ... DONE
[16:21:08.118] Resolving futures part of globals (recursively) ...
[16:21:08.118] resolve() on list ...
[16:21:08.119]  recursive: 99
[16:21:08.119]  length: 1
[16:21:08.119]  elements: ‘pkg’
[16:21:08.119]  length: 0 (resolved future 1)
[16:21:08.119] resolve() on list ... DONE
[16:21:08.119] - globals: [1] ‘pkg’
[16:21:08.119] Resolving futures part of globals (recursively) ... DONE
[16:21:08.119] The total size of the 1 globals is 112 bytes (112 bytes)
[16:21:08.120] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:21:08.120] - globals: [1] ‘pkg’
[16:21:08.120] 
[16:21:08.120] getGlobalsAndPackages() ... DONE
[16:21:08.120] Packages needed by the future expression (n = 0): <none>
[16:21:08.120] Packages needed by future strategies (n = 0): <none>
[16:21:08.121] {
[16:21:08.121]     {
[16:21:08.121]         {
[16:21:08.121]             ...future.startTime <- base::Sys.time()
[16:21:08.121]             {
[16:21:08.121]                 {
[16:21:08.121]                   {
[16:21:08.121]                     base::local({
[16:21:08.121]                       has_future <- base::requireNamespace("future", 
[16:21:08.121]                         quietly = TRUE)
[16:21:08.121]                       if (has_future) {
[16:21:08.121]                         ns <- base::getNamespace("future")
[16:21:08.121]                         version <- ns[[".package"]][["version"]]
[16:21:08.121]                         if (is.null(version)) 
[16:21:08.121]                           version <- utils::packageVersion("future")
[16:21:08.121]                       }
[16:21:08.121]                       else {
[16:21:08.121]                         version <- NULL
[16:21:08.121]                       }
[16:21:08.121]                       if (!has_future || version < "1.8.0") {
[16:21:08.121]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:08.121]                           "", base::R.version$version.string), 
[16:21:08.121]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:08.121]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:08.121]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:08.121]                             "release", "version")], collapse = " "), 
[16:21:08.121]                           hostname = base::Sys.info()[["nodename"]])
[16:21:08.121]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:08.121]                           info)
[16:21:08.121]                         info <- base::paste(info, collapse = "; ")
[16:21:08.121]                         if (!has_future) {
[16:21:08.121]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:08.121]                             info)
[16:21:08.121]                         }
[16:21:08.121]                         else {
[16:21:08.121]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:08.121]                             info, version)
[16:21:08.121]                         }
[16:21:08.121]                         base::stop(msg)
[16:21:08.121]                       }
[16:21:08.121]                     })
[16:21:08.121]                   }
[16:21:08.121]                   ...future.strategy.old <- future::plan("list")
[16:21:08.121]                   options(future.plan = NULL)
[16:21:08.121]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.121]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:08.121]                 }
[16:21:08.121]                 ...future.workdir <- getwd()
[16:21:08.121]             }
[16:21:08.121]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:08.121]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:08.121]         }
[16:21:08.121]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:08.121]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:08.121]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:08.121]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:08.121]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:08.121]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:08.121]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:08.121]             base::names(...future.oldOptions))
[16:21:08.121]     }
[16:21:08.121]     if (FALSE) {
[16:21:08.121]     }
[16:21:08.121]     else {
[16:21:08.121]         if (TRUE) {
[16:21:08.121]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:08.121]                 open = "w")
[16:21:08.121]         }
[16:21:08.121]         else {
[16:21:08.121]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:08.121]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:08.121]         }
[16:21:08.121]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:08.121]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:08.121]             base::sink(type = "output", split = FALSE)
[16:21:08.121]             base::close(...future.stdout)
[16:21:08.121]         }, add = TRUE)
[16:21:08.121]     }
[16:21:08.121]     ...future.frame <- base::sys.nframe()
[16:21:08.121]     ...future.conditions <- base::list()
[16:21:08.121]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:08.121]     if (FALSE) {
[16:21:08.121]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:08.121]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:08.121]     }
[16:21:08.121]     ...future.result <- base::tryCatch({
[16:21:08.121]         base::withCallingHandlers({
[16:21:08.121]             ...future.value <- base::withVisible(base::local({
[16:21:08.121]                 pkg
[16:21:08.121]             }))
[16:21:08.121]             future::FutureResult(value = ...future.value$value, 
[16:21:08.121]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.121]                   ...future.rng), globalenv = if (FALSE) 
[16:21:08.121]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:08.121]                     ...future.globalenv.names))
[16:21:08.121]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:08.121]         }, condition = base::local({
[16:21:08.121]             c <- base::c
[16:21:08.121]             inherits <- base::inherits
[16:21:08.121]             invokeRestart <- base::invokeRestart
[16:21:08.121]             length <- base::length
[16:21:08.121]             list <- base::list
[16:21:08.121]             seq.int <- base::seq.int
[16:21:08.121]             signalCondition <- base::signalCondition
[16:21:08.121]             sys.calls <- base::sys.calls
[16:21:08.121]             `[[` <- base::`[[`
[16:21:08.121]             `+` <- base::`+`
[16:21:08.121]             `<<-` <- base::`<<-`
[16:21:08.121]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:08.121]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:08.121]                   3L)]
[16:21:08.121]             }
[16:21:08.121]             function(cond) {
[16:21:08.121]                 is_error <- inherits(cond, "error")
[16:21:08.121]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:08.121]                   NULL)
[16:21:08.121]                 if (is_error) {
[16:21:08.121]                   sessionInformation <- function() {
[16:21:08.121]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:08.121]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:08.121]                       search = base::search(), system = base::Sys.info())
[16:21:08.121]                   }
[16:21:08.121]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.121]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:08.121]                     cond$call), session = sessionInformation(), 
[16:21:08.121]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:08.121]                   signalCondition(cond)
[16:21:08.121]                 }
[16:21:08.121]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:08.121]                 "immediateCondition"))) {
[16:21:08.121]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:08.121]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.121]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:08.121]                   if (TRUE && !signal) {
[16:21:08.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.121]                     {
[16:21:08.121]                       inherits <- base::inherits
[16:21:08.121]                       invokeRestart <- base::invokeRestart
[16:21:08.121]                       is.null <- base::is.null
[16:21:08.121]                       muffled <- FALSE
[16:21:08.121]                       if (inherits(cond, "message")) {
[16:21:08.121]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.121]                         if (muffled) 
[16:21:08.121]                           invokeRestart("muffleMessage")
[16:21:08.121]                       }
[16:21:08.121]                       else if (inherits(cond, "warning")) {
[16:21:08.121]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.121]                         if (muffled) 
[16:21:08.121]                           invokeRestart("muffleWarning")
[16:21:08.121]                       }
[16:21:08.121]                       else if (inherits(cond, "condition")) {
[16:21:08.121]                         if (!is.null(pattern)) {
[16:21:08.121]                           computeRestarts <- base::computeRestarts
[16:21:08.121]                           grepl <- base::grepl
[16:21:08.121]                           restarts <- computeRestarts(cond)
[16:21:08.121]                           for (restart in restarts) {
[16:21:08.121]                             name <- restart$name
[16:21:08.121]                             if (is.null(name)) 
[16:21:08.121]                               next
[16:21:08.121]                             if (!grepl(pattern, name)) 
[16:21:08.121]                               next
[16:21:08.121]                             invokeRestart(restart)
[16:21:08.121]                             muffled <- TRUE
[16:21:08.121]                             break
[16:21:08.121]                           }
[16:21:08.121]                         }
[16:21:08.121]                       }
[16:21:08.121]                       invisible(muffled)
[16:21:08.121]                     }
[16:21:08.121]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.121]                   }
[16:21:08.121]                 }
[16:21:08.121]                 else {
[16:21:08.121]                   if (TRUE) {
[16:21:08.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.121]                     {
[16:21:08.121]                       inherits <- base::inherits
[16:21:08.121]                       invokeRestart <- base::invokeRestart
[16:21:08.121]                       is.null <- base::is.null
[16:21:08.121]                       muffled <- FALSE
[16:21:08.121]                       if (inherits(cond, "message")) {
[16:21:08.121]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.121]                         if (muffled) 
[16:21:08.121]                           invokeRestart("muffleMessage")
[16:21:08.121]                       }
[16:21:08.121]                       else if (inherits(cond, "warning")) {
[16:21:08.121]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.121]                         if (muffled) 
[16:21:08.121]                           invokeRestart("muffleWarning")
[16:21:08.121]                       }
[16:21:08.121]                       else if (inherits(cond, "condition")) {
[16:21:08.121]                         if (!is.null(pattern)) {
[16:21:08.121]                           computeRestarts <- base::computeRestarts
[16:21:08.121]                           grepl <- base::grepl
[16:21:08.121]                           restarts <- computeRestarts(cond)
[16:21:08.121]                           for (restart in restarts) {
[16:21:08.121]                             name <- restart$name
[16:21:08.121]                             if (is.null(name)) 
[16:21:08.121]                               next
[16:21:08.121]                             if (!grepl(pattern, name)) 
[16:21:08.121]                               next
[16:21:08.121]                             invokeRestart(restart)
[16:21:08.121]                             muffled <- TRUE
[16:21:08.121]                             break
[16:21:08.121]                           }
[16:21:08.121]                         }
[16:21:08.121]                       }
[16:21:08.121]                       invisible(muffled)
[16:21:08.121]                     }
[16:21:08.121]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.121]                   }
[16:21:08.121]                 }
[16:21:08.121]             }
[16:21:08.121]         }))
[16:21:08.121]     }, error = function(ex) {
[16:21:08.121]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:08.121]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.121]                 ...future.rng), started = ...future.startTime, 
[16:21:08.121]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:08.121]             version = "1.8"), class = "FutureResult")
[16:21:08.121]     }, finally = {
[16:21:08.121]         if (!identical(...future.workdir, getwd())) 
[16:21:08.121]             setwd(...future.workdir)
[16:21:08.121]         {
[16:21:08.121]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:08.121]                 ...future.oldOptions$nwarnings <- NULL
[16:21:08.121]             }
[16:21:08.121]             base::options(...future.oldOptions)
[16:21:08.121]             if (.Platform$OS.type == "windows") {
[16:21:08.121]                 old_names <- names(...future.oldEnvVars)
[16:21:08.121]                 envs <- base::Sys.getenv()
[16:21:08.121]                 names <- names(envs)
[16:21:08.121]                 common <- intersect(names, old_names)
[16:21:08.121]                 added <- setdiff(names, old_names)
[16:21:08.121]                 removed <- setdiff(old_names, names)
[16:21:08.121]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:08.121]                   envs[common]]
[16:21:08.121]                 NAMES <- toupper(changed)
[16:21:08.121]                 args <- list()
[16:21:08.121]                 for (kk in seq_along(NAMES)) {
[16:21:08.121]                   name <- changed[[kk]]
[16:21:08.121]                   NAME <- NAMES[[kk]]
[16:21:08.121]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.121]                     next
[16:21:08.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.121]                 }
[16:21:08.121]                 NAMES <- toupper(added)
[16:21:08.121]                 for (kk in seq_along(NAMES)) {
[16:21:08.121]                   name <- added[[kk]]
[16:21:08.121]                   NAME <- NAMES[[kk]]
[16:21:08.121]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.121]                     next
[16:21:08.121]                   args[[name]] <- ""
[16:21:08.121]                 }
[16:21:08.121]                 NAMES <- toupper(removed)
[16:21:08.121]                 for (kk in seq_along(NAMES)) {
[16:21:08.121]                   name <- removed[[kk]]
[16:21:08.121]                   NAME <- NAMES[[kk]]
[16:21:08.121]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.121]                     next
[16:21:08.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.121]                 }
[16:21:08.121]                 if (length(args) > 0) 
[16:21:08.121]                   base::do.call(base::Sys.setenv, args = args)
[16:21:08.121]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:08.121]             }
[16:21:08.121]             else {
[16:21:08.121]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:08.121]             }
[16:21:08.121]             {
[16:21:08.121]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:08.121]                   0L) {
[16:21:08.121]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:08.121]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:08.121]                   base::options(opts)
[16:21:08.121]                 }
[16:21:08.121]                 {
[16:21:08.121]                   {
[16:21:08.121]                     NULL
[16:21:08.121]                     RNGkind("Mersenne-Twister")
[16:21:08.121]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:08.121]                       inherits = FALSE)
[16:21:08.121]                   }
[16:21:08.121]                   options(future.plan = NULL)
[16:21:08.121]                   if (is.na(NA_character_)) 
[16:21:08.121]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.121]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:08.121]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:08.121]                     .init = FALSE)
[16:21:08.121]                 }
[16:21:08.121]             }
[16:21:08.121]         }
[16:21:08.121]     })
[16:21:08.121]     if (TRUE) {
[16:21:08.121]         base::sink(type = "output", split = FALSE)
[16:21:08.121]         if (TRUE) {
[16:21:08.121]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:08.121]         }
[16:21:08.121]         else {
[16:21:08.121]             ...future.result["stdout"] <- base::list(NULL)
[16:21:08.121]         }
[16:21:08.121]         base::close(...future.stdout)
[16:21:08.121]         ...future.stdout <- NULL
[16:21:08.121]     }
[16:21:08.121]     ...future.result$conditions <- ...future.conditions
[16:21:08.121]     ...future.result$finished <- base::Sys.time()
[16:21:08.121]     ...future.result
[16:21:08.121] }
[16:21:08.123] assign_globals() ...
[16:21:08.123] List of 1
[16:21:08.123]  $ pkg: chr "foo"
[16:21:08.123]  - attr(*, "where")=List of 1
[16:21:08.123]   ..$ pkg:<environment: R_EmptyEnv> 
[16:21:08.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:08.123]  - attr(*, "resolved")= logi TRUE
[16:21:08.123]  - attr(*, "total_size")= num 112
[16:21:08.125] - copied ‘pkg’ to environment
[16:21:08.125] assign_globals() ... done
[16:21:08.125] plan(): Setting new future strategy stack:
[16:21:08.125] List of future strategies:
[16:21:08.125] 1. sequential:
[16:21:08.125]    - args: function (..., envir = parent.frame())
[16:21:08.125]    - tweaked: FALSE
[16:21:08.125]    - call: NULL
[16:21:08.126] plan(): nbrOfWorkers() = 1
[16:21:08.126] plan(): Setting new future strategy stack:
[16:21:08.127] List of future strategies:
[16:21:08.127] 1. multisession:
[16:21:08.127]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:08.127]    - tweaked: FALSE
[16:21:08.127]    - call: plan(strategy)
[16:21:08.130] plan(): nbrOfWorkers() = 2
[16:21:08.130] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:08.131] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:08.131] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:08.133] - globals found: [3] ‘{’, ‘<-’, ‘+’
[16:21:08.133] Searching for globals ... DONE
[16:21:08.133] Resolving globals: TRUE
[16:21:08.133] Resolving any globals that are futures ...
[16:21:08.133] - globals: [3] ‘{’, ‘<-’, ‘+’
[16:21:08.134] Resolving any globals that are futures ... DONE
[16:21:08.134] 
[16:21:08.134] 
[16:21:08.134] getGlobalsAndPackages() ... DONE
[16:21:08.134] run() for ‘Future’ ...
[16:21:08.134] - state: ‘created’
[16:21:08.135] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:08.149] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:08.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:08.149]   - Field: ‘node’
[16:21:08.149]   - Field: ‘label’
[16:21:08.149]   - Field: ‘local’
[16:21:08.150]   - Field: ‘owner’
[16:21:08.150]   - Field: ‘envir’
[16:21:08.150]   - Field: ‘workers’
[16:21:08.150]   - Field: ‘packages’
[16:21:08.150]   - Field: ‘gc’
[16:21:08.150]   - Field: ‘conditions’
[16:21:08.150]   - Field: ‘persistent’
[16:21:08.150]   - Field: ‘expr’
[16:21:08.150]   - Field: ‘uuid’
[16:21:08.150]   - Field: ‘seed’
[16:21:08.150]   - Field: ‘version’
[16:21:08.151]   - Field: ‘result’
[16:21:08.151]   - Field: ‘asynchronous’
[16:21:08.151]   - Field: ‘calls’
[16:21:08.151]   - Field: ‘globals’
[16:21:08.151]   - Field: ‘stdout’
[16:21:08.151]   - Field: ‘earlySignal’
[16:21:08.151]   - Field: ‘lazy’
[16:21:08.151]   - Field: ‘state’
[16:21:08.151] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:08.151] - Launch lazy future ...
[16:21:08.152] Packages needed by the future expression (n = 0): <none>
[16:21:08.152] Packages needed by future strategies (n = 0): <none>
[16:21:08.152] {
[16:21:08.152]     {
[16:21:08.152]         {
[16:21:08.152]             ...future.startTime <- base::Sys.time()
[16:21:08.152]             {
[16:21:08.152]                 {
[16:21:08.152]                   {
[16:21:08.152]                     {
[16:21:08.152]                       base::local({
[16:21:08.152]                         has_future <- base::requireNamespace("future", 
[16:21:08.152]                           quietly = TRUE)
[16:21:08.152]                         if (has_future) {
[16:21:08.152]                           ns <- base::getNamespace("future")
[16:21:08.152]                           version <- ns[[".package"]][["version"]]
[16:21:08.152]                           if (is.null(version)) 
[16:21:08.152]                             version <- utils::packageVersion("future")
[16:21:08.152]                         }
[16:21:08.152]                         else {
[16:21:08.152]                           version <- NULL
[16:21:08.152]                         }
[16:21:08.152]                         if (!has_future || version < "1.8.0") {
[16:21:08.152]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:08.152]                             "", base::R.version$version.string), 
[16:21:08.152]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:08.152]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:08.152]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:08.152]                               "release", "version")], collapse = " "), 
[16:21:08.152]                             hostname = base::Sys.info()[["nodename"]])
[16:21:08.152]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:08.152]                             info)
[16:21:08.152]                           info <- base::paste(info, collapse = "; ")
[16:21:08.152]                           if (!has_future) {
[16:21:08.152]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:08.152]                               info)
[16:21:08.152]                           }
[16:21:08.152]                           else {
[16:21:08.152]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:08.152]                               info, version)
[16:21:08.152]                           }
[16:21:08.152]                           base::stop(msg)
[16:21:08.152]                         }
[16:21:08.152]                       })
[16:21:08.152]                     }
[16:21:08.152]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:08.152]                     base::options(mc.cores = 1L)
[16:21:08.152]                   }
[16:21:08.152]                   ...future.strategy.old <- future::plan("list")
[16:21:08.152]                   options(future.plan = NULL)
[16:21:08.152]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.152]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:08.152]                 }
[16:21:08.152]                 ...future.workdir <- getwd()
[16:21:08.152]             }
[16:21:08.152]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:08.152]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:08.152]         }
[16:21:08.152]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:08.152]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:08.152]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:08.152]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:08.152]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:08.152]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:08.152]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:08.152]             base::names(...future.oldOptions))
[16:21:08.152]     }
[16:21:08.152]     if (FALSE) {
[16:21:08.152]     }
[16:21:08.152]     else {
[16:21:08.152]         if (TRUE) {
[16:21:08.152]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:08.152]                 open = "w")
[16:21:08.152]         }
[16:21:08.152]         else {
[16:21:08.152]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:08.152]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:08.152]         }
[16:21:08.152]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:08.152]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:08.152]             base::sink(type = "output", split = FALSE)
[16:21:08.152]             base::close(...future.stdout)
[16:21:08.152]         }, add = TRUE)
[16:21:08.152]     }
[16:21:08.152]     ...future.frame <- base::sys.nframe()
[16:21:08.152]     ...future.conditions <- base::list()
[16:21:08.152]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:08.152]     if (FALSE) {
[16:21:08.152]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:08.152]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:08.152]     }
[16:21:08.152]     ...future.result <- base::tryCatch({
[16:21:08.152]         base::withCallingHandlers({
[16:21:08.152]             ...future.value <- base::withVisible(base::local({
[16:21:08.152]                 ...future.makeSendCondition <- base::local({
[16:21:08.152]                   sendCondition <- NULL
[16:21:08.152]                   function(frame = 1L) {
[16:21:08.152]                     if (is.function(sendCondition)) 
[16:21:08.152]                       return(sendCondition)
[16:21:08.152]                     ns <- getNamespace("parallel")
[16:21:08.152]                     if (exists("sendData", mode = "function", 
[16:21:08.152]                       envir = ns)) {
[16:21:08.152]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:08.152]                         envir = ns)
[16:21:08.152]                       envir <- sys.frame(frame)
[16:21:08.152]                       master <- NULL
[16:21:08.152]                       while (!identical(envir, .GlobalEnv) && 
[16:21:08.152]                         !identical(envir, emptyenv())) {
[16:21:08.152]                         if (exists("master", mode = "list", envir = envir, 
[16:21:08.152]                           inherits = FALSE)) {
[16:21:08.152]                           master <- get("master", mode = "list", 
[16:21:08.152]                             envir = envir, inherits = FALSE)
[16:21:08.152]                           if (inherits(master, c("SOCKnode", 
[16:21:08.152]                             "SOCK0node"))) {
[16:21:08.152]                             sendCondition <<- function(cond) {
[16:21:08.152]                               data <- list(type = "VALUE", value = cond, 
[16:21:08.152]                                 success = TRUE)
[16:21:08.152]                               parallel_sendData(master, data)
[16:21:08.152]                             }
[16:21:08.152]                             return(sendCondition)
[16:21:08.152]                           }
[16:21:08.152]                         }
[16:21:08.152]                         frame <- frame + 1L
[16:21:08.152]                         envir <- sys.frame(frame)
[16:21:08.152]                       }
[16:21:08.152]                     }
[16:21:08.152]                     sendCondition <<- function(cond) NULL
[16:21:08.152]                   }
[16:21:08.152]                 })
[16:21:08.152]                 withCallingHandlers({
[16:21:08.152]                   {
[16:21:08.152]                     x <- 0
[16:21:08.152]                     x <- x + 1
[16:21:08.152]                     x
[16:21:08.152]                   }
[16:21:08.152]                 }, immediateCondition = function(cond) {
[16:21:08.152]                   sendCondition <- ...future.makeSendCondition()
[16:21:08.152]                   sendCondition(cond)
[16:21:08.152]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.152]                   {
[16:21:08.152]                     inherits <- base::inherits
[16:21:08.152]                     invokeRestart <- base::invokeRestart
[16:21:08.152]                     is.null <- base::is.null
[16:21:08.152]                     muffled <- FALSE
[16:21:08.152]                     if (inherits(cond, "message")) {
[16:21:08.152]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:08.152]                       if (muffled) 
[16:21:08.152]                         invokeRestart("muffleMessage")
[16:21:08.152]                     }
[16:21:08.152]                     else if (inherits(cond, "warning")) {
[16:21:08.152]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:08.152]                       if (muffled) 
[16:21:08.152]                         invokeRestart("muffleWarning")
[16:21:08.152]                     }
[16:21:08.152]                     else if (inherits(cond, "condition")) {
[16:21:08.152]                       if (!is.null(pattern)) {
[16:21:08.152]                         computeRestarts <- base::computeRestarts
[16:21:08.152]                         grepl <- base::grepl
[16:21:08.152]                         restarts <- computeRestarts(cond)
[16:21:08.152]                         for (restart in restarts) {
[16:21:08.152]                           name <- restart$name
[16:21:08.152]                           if (is.null(name)) 
[16:21:08.152]                             next
[16:21:08.152]                           if (!grepl(pattern, name)) 
[16:21:08.152]                             next
[16:21:08.152]                           invokeRestart(restart)
[16:21:08.152]                           muffled <- TRUE
[16:21:08.152]                           break
[16:21:08.152]                         }
[16:21:08.152]                       }
[16:21:08.152]                     }
[16:21:08.152]                     invisible(muffled)
[16:21:08.152]                   }
[16:21:08.152]                   muffleCondition(cond)
[16:21:08.152]                 })
[16:21:08.152]             }))
[16:21:08.152]             future::FutureResult(value = ...future.value$value, 
[16:21:08.152]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.152]                   ...future.rng), globalenv = if (FALSE) 
[16:21:08.152]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:08.152]                     ...future.globalenv.names))
[16:21:08.152]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:08.152]         }, condition = base::local({
[16:21:08.152]             c <- base::c
[16:21:08.152]             inherits <- base::inherits
[16:21:08.152]             invokeRestart <- base::invokeRestart
[16:21:08.152]             length <- base::length
[16:21:08.152]             list <- base::list
[16:21:08.152]             seq.int <- base::seq.int
[16:21:08.152]             signalCondition <- base::signalCondition
[16:21:08.152]             sys.calls <- base::sys.calls
[16:21:08.152]             `[[` <- base::`[[`
[16:21:08.152]             `+` <- base::`+`
[16:21:08.152]             `<<-` <- base::`<<-`
[16:21:08.152]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:08.152]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:08.152]                   3L)]
[16:21:08.152]             }
[16:21:08.152]             function(cond) {
[16:21:08.152]                 is_error <- inherits(cond, "error")
[16:21:08.152]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:08.152]                   NULL)
[16:21:08.152]                 if (is_error) {
[16:21:08.152]                   sessionInformation <- function() {
[16:21:08.152]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:08.152]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:08.152]                       search = base::search(), system = base::Sys.info())
[16:21:08.152]                   }
[16:21:08.152]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.152]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:08.152]                     cond$call), session = sessionInformation(), 
[16:21:08.152]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:08.152]                   signalCondition(cond)
[16:21:08.152]                 }
[16:21:08.152]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:08.152]                 "immediateCondition"))) {
[16:21:08.152]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:08.152]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.152]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:08.152]                   if (TRUE && !signal) {
[16:21:08.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.152]                     {
[16:21:08.152]                       inherits <- base::inherits
[16:21:08.152]                       invokeRestart <- base::invokeRestart
[16:21:08.152]                       is.null <- base::is.null
[16:21:08.152]                       muffled <- FALSE
[16:21:08.152]                       if (inherits(cond, "message")) {
[16:21:08.152]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.152]                         if (muffled) 
[16:21:08.152]                           invokeRestart("muffleMessage")
[16:21:08.152]                       }
[16:21:08.152]                       else if (inherits(cond, "warning")) {
[16:21:08.152]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.152]                         if (muffled) 
[16:21:08.152]                           invokeRestart("muffleWarning")
[16:21:08.152]                       }
[16:21:08.152]                       else if (inherits(cond, "condition")) {
[16:21:08.152]                         if (!is.null(pattern)) {
[16:21:08.152]                           computeRestarts <- base::computeRestarts
[16:21:08.152]                           grepl <- base::grepl
[16:21:08.152]                           restarts <- computeRestarts(cond)
[16:21:08.152]                           for (restart in restarts) {
[16:21:08.152]                             name <- restart$name
[16:21:08.152]                             if (is.null(name)) 
[16:21:08.152]                               next
[16:21:08.152]                             if (!grepl(pattern, name)) 
[16:21:08.152]                               next
[16:21:08.152]                             invokeRestart(restart)
[16:21:08.152]                             muffled <- TRUE
[16:21:08.152]                             break
[16:21:08.152]                           }
[16:21:08.152]                         }
[16:21:08.152]                       }
[16:21:08.152]                       invisible(muffled)
[16:21:08.152]                     }
[16:21:08.152]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.152]                   }
[16:21:08.152]                 }
[16:21:08.152]                 else {
[16:21:08.152]                   if (TRUE) {
[16:21:08.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.152]                     {
[16:21:08.152]                       inherits <- base::inherits
[16:21:08.152]                       invokeRestart <- base::invokeRestart
[16:21:08.152]                       is.null <- base::is.null
[16:21:08.152]                       muffled <- FALSE
[16:21:08.152]                       if (inherits(cond, "message")) {
[16:21:08.152]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.152]                         if (muffled) 
[16:21:08.152]                           invokeRestart("muffleMessage")
[16:21:08.152]                       }
[16:21:08.152]                       else if (inherits(cond, "warning")) {
[16:21:08.152]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.152]                         if (muffled) 
[16:21:08.152]                           invokeRestart("muffleWarning")
[16:21:08.152]                       }
[16:21:08.152]                       else if (inherits(cond, "condition")) {
[16:21:08.152]                         if (!is.null(pattern)) {
[16:21:08.152]                           computeRestarts <- base::computeRestarts
[16:21:08.152]                           grepl <- base::grepl
[16:21:08.152]                           restarts <- computeRestarts(cond)
[16:21:08.152]                           for (restart in restarts) {
[16:21:08.152]                             name <- restart$name
[16:21:08.152]                             if (is.null(name)) 
[16:21:08.152]                               next
[16:21:08.152]                             if (!grepl(pattern, name)) 
[16:21:08.152]                               next
[16:21:08.152]                             invokeRestart(restart)
[16:21:08.152]                             muffled <- TRUE
[16:21:08.152]                             break
[16:21:08.152]                           }
[16:21:08.152]                         }
[16:21:08.152]                       }
[16:21:08.152]                       invisible(muffled)
[16:21:08.152]                     }
[16:21:08.152]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.152]                   }
[16:21:08.152]                 }
[16:21:08.152]             }
[16:21:08.152]         }))
[16:21:08.152]     }, error = function(ex) {
[16:21:08.152]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:08.152]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.152]                 ...future.rng), started = ...future.startTime, 
[16:21:08.152]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:08.152]             version = "1.8"), class = "FutureResult")
[16:21:08.152]     }, finally = {
[16:21:08.152]         if (!identical(...future.workdir, getwd())) 
[16:21:08.152]             setwd(...future.workdir)
[16:21:08.152]         {
[16:21:08.152]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:08.152]                 ...future.oldOptions$nwarnings <- NULL
[16:21:08.152]             }
[16:21:08.152]             base::options(...future.oldOptions)
[16:21:08.152]             if (.Platform$OS.type == "windows") {
[16:21:08.152]                 old_names <- names(...future.oldEnvVars)
[16:21:08.152]                 envs <- base::Sys.getenv()
[16:21:08.152]                 names <- names(envs)
[16:21:08.152]                 common <- intersect(names, old_names)
[16:21:08.152]                 added <- setdiff(names, old_names)
[16:21:08.152]                 removed <- setdiff(old_names, names)
[16:21:08.152]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:08.152]                   envs[common]]
[16:21:08.152]                 NAMES <- toupper(changed)
[16:21:08.152]                 args <- list()
[16:21:08.152]                 for (kk in seq_along(NAMES)) {
[16:21:08.152]                   name <- changed[[kk]]
[16:21:08.152]                   NAME <- NAMES[[kk]]
[16:21:08.152]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.152]                     next
[16:21:08.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.152]                 }
[16:21:08.152]                 NAMES <- toupper(added)
[16:21:08.152]                 for (kk in seq_along(NAMES)) {
[16:21:08.152]                   name <- added[[kk]]
[16:21:08.152]                   NAME <- NAMES[[kk]]
[16:21:08.152]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.152]                     next
[16:21:08.152]                   args[[name]] <- ""
[16:21:08.152]                 }
[16:21:08.152]                 NAMES <- toupper(removed)
[16:21:08.152]                 for (kk in seq_along(NAMES)) {
[16:21:08.152]                   name <- removed[[kk]]
[16:21:08.152]                   NAME <- NAMES[[kk]]
[16:21:08.152]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.152]                     next
[16:21:08.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.152]                 }
[16:21:08.152]                 if (length(args) > 0) 
[16:21:08.152]                   base::do.call(base::Sys.setenv, args = args)
[16:21:08.152]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:08.152]             }
[16:21:08.152]             else {
[16:21:08.152]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:08.152]             }
[16:21:08.152]             {
[16:21:08.152]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:08.152]                   0L) {
[16:21:08.152]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:08.152]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:08.152]                   base::options(opts)
[16:21:08.152]                 }
[16:21:08.152]                 {
[16:21:08.152]                   {
[16:21:08.152]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:08.152]                     NULL
[16:21:08.152]                   }
[16:21:08.152]                   options(future.plan = NULL)
[16:21:08.152]                   if (is.na(NA_character_)) 
[16:21:08.152]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.152]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:08.152]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:08.152]                     .init = FALSE)
[16:21:08.152]                 }
[16:21:08.152]             }
[16:21:08.152]         }
[16:21:08.152]     })
[16:21:08.152]     if (TRUE) {
[16:21:08.152]         base::sink(type = "output", split = FALSE)
[16:21:08.152]         if (TRUE) {
[16:21:08.152]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:08.152]         }
[16:21:08.152]         else {
[16:21:08.152]             ...future.result["stdout"] <- base::list(NULL)
[16:21:08.152]         }
[16:21:08.152]         base::close(...future.stdout)
[16:21:08.152]         ...future.stdout <- NULL
[16:21:08.152]     }
[16:21:08.152]     ...future.result$conditions <- ...future.conditions
[16:21:08.152]     ...future.result$finished <- base::Sys.time()
[16:21:08.152]     ...future.result
[16:21:08.152] }
[16:21:08.155] MultisessionFuture started
[16:21:08.155] - Launch lazy future ... done
[16:21:08.155] run() for ‘MultisessionFuture’ ... done
[16:21:08.155] result() for ClusterFuture ...
[16:21:08.155] receiveMessageFromWorker() for ClusterFuture ...
[16:21:08.156] - Validating connection of MultisessionFuture
[16:21:08.198] - received message: FutureResult
[16:21:08.198] - Received FutureResult
[16:21:08.199] - Erased future from FutureRegistry
[16:21:08.199] result() for ClusterFuture ...
[16:21:08.199] - result already collected: FutureResult
[16:21:08.199] result() for ClusterFuture ... done
[16:21:08.199] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:08.199] result() for ClusterFuture ... done
[16:21:08.199] result() for ClusterFuture ...
[16:21:08.199] - result already collected: FutureResult
[16:21:08.199] result() for ClusterFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:08.200] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:08.200] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:08.201] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:21:08.201] Searching for globals ... DONE
[16:21:08.202] Resolving globals: TRUE
[16:21:08.202] Resolving any globals that are futures ...
[16:21:08.202] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:21:08.202] Resolving any globals that are futures ... DONE
[16:21:08.202] Resolving futures part of globals (recursively) ...
[16:21:08.202] resolve() on list ...
[16:21:08.203]  recursive: 99
[16:21:08.203]  length: 1
[16:21:08.203]  elements: ‘x’
[16:21:08.203]  length: 0 (resolved future 1)
[16:21:08.203] resolve() on list ... DONE
[16:21:08.203] - globals: [1] ‘x’
[16:21:08.203] Resolving futures part of globals (recursively) ... DONE
[16:21:08.203] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:08.204] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[16:21:08.204] - globals: [1] ‘x’
[16:21:08.204] 
[16:21:08.204] getGlobalsAndPackages() ... DONE
[16:21:08.204] run() for ‘Future’ ...
[16:21:08.204] - state: ‘created’
[16:21:08.204] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:08.219] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:08.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:08.219]   - Field: ‘node’
[16:21:08.219]   - Field: ‘label’
[16:21:08.219]   - Field: ‘local’
[16:21:08.219]   - Field: ‘owner’
[16:21:08.219]   - Field: ‘envir’
[16:21:08.219]   - Field: ‘workers’
[16:21:08.219]   - Field: ‘packages’
[16:21:08.219]   - Field: ‘gc’
[16:21:08.220]   - Field: ‘conditions’
[16:21:08.220]   - Field: ‘persistent’
[16:21:08.220]   - Field: ‘expr’
[16:21:08.220]   - Field: ‘uuid’
[16:21:08.220]   - Field: ‘seed’
[16:21:08.220]   - Field: ‘version’
[16:21:08.220]   - Field: ‘result’
[16:21:08.220]   - Field: ‘asynchronous’
[16:21:08.220]   - Field: ‘calls’
[16:21:08.220]   - Field: ‘globals’
[16:21:08.221]   - Field: ‘stdout’
[16:21:08.221]   - Field: ‘earlySignal’
[16:21:08.221]   - Field: ‘lazy’
[16:21:08.221]   - Field: ‘state’
[16:21:08.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:08.221] - Launch lazy future ...
[16:21:08.221] Packages needed by the future expression (n = 0): <none>
[16:21:08.221] Packages needed by future strategies (n = 0): <none>
[16:21:08.222] {
[16:21:08.222]     {
[16:21:08.222]         {
[16:21:08.222]             ...future.startTime <- base::Sys.time()
[16:21:08.222]             {
[16:21:08.222]                 {
[16:21:08.222]                   {
[16:21:08.222]                     {
[16:21:08.222]                       base::local({
[16:21:08.222]                         has_future <- base::requireNamespace("future", 
[16:21:08.222]                           quietly = TRUE)
[16:21:08.222]                         if (has_future) {
[16:21:08.222]                           ns <- base::getNamespace("future")
[16:21:08.222]                           version <- ns[[".package"]][["version"]]
[16:21:08.222]                           if (is.null(version)) 
[16:21:08.222]                             version <- utils::packageVersion("future")
[16:21:08.222]                         }
[16:21:08.222]                         else {
[16:21:08.222]                           version <- NULL
[16:21:08.222]                         }
[16:21:08.222]                         if (!has_future || version < "1.8.0") {
[16:21:08.222]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:08.222]                             "", base::R.version$version.string), 
[16:21:08.222]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:08.222]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:08.222]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:08.222]                               "release", "version")], collapse = " "), 
[16:21:08.222]                             hostname = base::Sys.info()[["nodename"]])
[16:21:08.222]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:08.222]                             info)
[16:21:08.222]                           info <- base::paste(info, collapse = "; ")
[16:21:08.222]                           if (!has_future) {
[16:21:08.222]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:08.222]                               info)
[16:21:08.222]                           }
[16:21:08.222]                           else {
[16:21:08.222]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:08.222]                               info, version)
[16:21:08.222]                           }
[16:21:08.222]                           base::stop(msg)
[16:21:08.222]                         }
[16:21:08.222]                       })
[16:21:08.222]                     }
[16:21:08.222]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:08.222]                     base::options(mc.cores = 1L)
[16:21:08.222]                   }
[16:21:08.222]                   ...future.strategy.old <- future::plan("list")
[16:21:08.222]                   options(future.plan = NULL)
[16:21:08.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:08.222]                 }
[16:21:08.222]                 ...future.workdir <- getwd()
[16:21:08.222]             }
[16:21:08.222]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:08.222]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:08.222]         }
[16:21:08.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:08.222]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:08.222]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:08.222]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:08.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:08.222]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:08.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:08.222]             base::names(...future.oldOptions))
[16:21:08.222]     }
[16:21:08.222]     if (FALSE) {
[16:21:08.222]     }
[16:21:08.222]     else {
[16:21:08.222]         if (TRUE) {
[16:21:08.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:08.222]                 open = "w")
[16:21:08.222]         }
[16:21:08.222]         else {
[16:21:08.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:08.222]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:08.222]         }
[16:21:08.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:08.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:08.222]             base::sink(type = "output", split = FALSE)
[16:21:08.222]             base::close(...future.stdout)
[16:21:08.222]         }, add = TRUE)
[16:21:08.222]     }
[16:21:08.222]     ...future.frame <- base::sys.nframe()
[16:21:08.222]     ...future.conditions <- base::list()
[16:21:08.222]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:08.222]     if (FALSE) {
[16:21:08.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:08.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:08.222]     }
[16:21:08.222]     ...future.result <- base::tryCatch({
[16:21:08.222]         base::withCallingHandlers({
[16:21:08.222]             ...future.value <- base::withVisible(base::local({
[16:21:08.222]                 ...future.makeSendCondition <- base::local({
[16:21:08.222]                   sendCondition <- NULL
[16:21:08.222]                   function(frame = 1L) {
[16:21:08.222]                     if (is.function(sendCondition)) 
[16:21:08.222]                       return(sendCondition)
[16:21:08.222]                     ns <- getNamespace("parallel")
[16:21:08.222]                     if (exists("sendData", mode = "function", 
[16:21:08.222]                       envir = ns)) {
[16:21:08.222]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:08.222]                         envir = ns)
[16:21:08.222]                       envir <- sys.frame(frame)
[16:21:08.222]                       master <- NULL
[16:21:08.222]                       while (!identical(envir, .GlobalEnv) && 
[16:21:08.222]                         !identical(envir, emptyenv())) {
[16:21:08.222]                         if (exists("master", mode = "list", envir = envir, 
[16:21:08.222]                           inherits = FALSE)) {
[16:21:08.222]                           master <- get("master", mode = "list", 
[16:21:08.222]                             envir = envir, inherits = FALSE)
[16:21:08.222]                           if (inherits(master, c("SOCKnode", 
[16:21:08.222]                             "SOCK0node"))) {
[16:21:08.222]                             sendCondition <<- function(cond) {
[16:21:08.222]                               data <- list(type = "VALUE", value = cond, 
[16:21:08.222]                                 success = TRUE)
[16:21:08.222]                               parallel_sendData(master, data)
[16:21:08.222]                             }
[16:21:08.222]                             return(sendCondition)
[16:21:08.222]                           }
[16:21:08.222]                         }
[16:21:08.222]                         frame <- frame + 1L
[16:21:08.222]                         envir <- sys.frame(frame)
[16:21:08.222]                       }
[16:21:08.222]                     }
[16:21:08.222]                     sendCondition <<- function(cond) NULL
[16:21:08.222]                   }
[16:21:08.222]                 })
[16:21:08.222]                 withCallingHandlers({
[16:21:08.222]                   {
[16:21:08.222]                     x <- x + 1
[16:21:08.222]                     x
[16:21:08.222]                   }
[16:21:08.222]                 }, immediateCondition = function(cond) {
[16:21:08.222]                   sendCondition <- ...future.makeSendCondition()
[16:21:08.222]                   sendCondition(cond)
[16:21:08.222]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.222]                   {
[16:21:08.222]                     inherits <- base::inherits
[16:21:08.222]                     invokeRestart <- base::invokeRestart
[16:21:08.222]                     is.null <- base::is.null
[16:21:08.222]                     muffled <- FALSE
[16:21:08.222]                     if (inherits(cond, "message")) {
[16:21:08.222]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:08.222]                       if (muffled) 
[16:21:08.222]                         invokeRestart("muffleMessage")
[16:21:08.222]                     }
[16:21:08.222]                     else if (inherits(cond, "warning")) {
[16:21:08.222]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:08.222]                       if (muffled) 
[16:21:08.222]                         invokeRestart("muffleWarning")
[16:21:08.222]                     }
[16:21:08.222]                     else if (inherits(cond, "condition")) {
[16:21:08.222]                       if (!is.null(pattern)) {
[16:21:08.222]                         computeRestarts <- base::computeRestarts
[16:21:08.222]                         grepl <- base::grepl
[16:21:08.222]                         restarts <- computeRestarts(cond)
[16:21:08.222]                         for (restart in restarts) {
[16:21:08.222]                           name <- restart$name
[16:21:08.222]                           if (is.null(name)) 
[16:21:08.222]                             next
[16:21:08.222]                           if (!grepl(pattern, name)) 
[16:21:08.222]                             next
[16:21:08.222]                           invokeRestart(restart)
[16:21:08.222]                           muffled <- TRUE
[16:21:08.222]                           break
[16:21:08.222]                         }
[16:21:08.222]                       }
[16:21:08.222]                     }
[16:21:08.222]                     invisible(muffled)
[16:21:08.222]                   }
[16:21:08.222]                   muffleCondition(cond)
[16:21:08.222]                 })
[16:21:08.222]             }))
[16:21:08.222]             future::FutureResult(value = ...future.value$value, 
[16:21:08.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.222]                   ...future.rng), globalenv = if (FALSE) 
[16:21:08.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:08.222]                     ...future.globalenv.names))
[16:21:08.222]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:08.222]         }, condition = base::local({
[16:21:08.222]             c <- base::c
[16:21:08.222]             inherits <- base::inherits
[16:21:08.222]             invokeRestart <- base::invokeRestart
[16:21:08.222]             length <- base::length
[16:21:08.222]             list <- base::list
[16:21:08.222]             seq.int <- base::seq.int
[16:21:08.222]             signalCondition <- base::signalCondition
[16:21:08.222]             sys.calls <- base::sys.calls
[16:21:08.222]             `[[` <- base::`[[`
[16:21:08.222]             `+` <- base::`+`
[16:21:08.222]             `<<-` <- base::`<<-`
[16:21:08.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:08.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:08.222]                   3L)]
[16:21:08.222]             }
[16:21:08.222]             function(cond) {
[16:21:08.222]                 is_error <- inherits(cond, "error")
[16:21:08.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:08.222]                   NULL)
[16:21:08.222]                 if (is_error) {
[16:21:08.222]                   sessionInformation <- function() {
[16:21:08.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:08.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:08.222]                       search = base::search(), system = base::Sys.info())
[16:21:08.222]                   }
[16:21:08.222]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:08.222]                     cond$call), session = sessionInformation(), 
[16:21:08.222]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:08.222]                   signalCondition(cond)
[16:21:08.222]                 }
[16:21:08.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:08.222]                 "immediateCondition"))) {
[16:21:08.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:08.222]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:08.222]                   if (TRUE && !signal) {
[16:21:08.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.222]                     {
[16:21:08.222]                       inherits <- base::inherits
[16:21:08.222]                       invokeRestart <- base::invokeRestart
[16:21:08.222]                       is.null <- base::is.null
[16:21:08.222]                       muffled <- FALSE
[16:21:08.222]                       if (inherits(cond, "message")) {
[16:21:08.222]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.222]                         if (muffled) 
[16:21:08.222]                           invokeRestart("muffleMessage")
[16:21:08.222]                       }
[16:21:08.222]                       else if (inherits(cond, "warning")) {
[16:21:08.222]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.222]                         if (muffled) 
[16:21:08.222]                           invokeRestart("muffleWarning")
[16:21:08.222]                       }
[16:21:08.222]                       else if (inherits(cond, "condition")) {
[16:21:08.222]                         if (!is.null(pattern)) {
[16:21:08.222]                           computeRestarts <- base::computeRestarts
[16:21:08.222]                           grepl <- base::grepl
[16:21:08.222]                           restarts <- computeRestarts(cond)
[16:21:08.222]                           for (restart in restarts) {
[16:21:08.222]                             name <- restart$name
[16:21:08.222]                             if (is.null(name)) 
[16:21:08.222]                               next
[16:21:08.222]                             if (!grepl(pattern, name)) 
[16:21:08.222]                               next
[16:21:08.222]                             invokeRestart(restart)
[16:21:08.222]                             muffled <- TRUE
[16:21:08.222]                             break
[16:21:08.222]                           }
[16:21:08.222]                         }
[16:21:08.222]                       }
[16:21:08.222]                       invisible(muffled)
[16:21:08.222]                     }
[16:21:08.222]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.222]                   }
[16:21:08.222]                 }
[16:21:08.222]                 else {
[16:21:08.222]                   if (TRUE) {
[16:21:08.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.222]                     {
[16:21:08.222]                       inherits <- base::inherits
[16:21:08.222]                       invokeRestart <- base::invokeRestart
[16:21:08.222]                       is.null <- base::is.null
[16:21:08.222]                       muffled <- FALSE
[16:21:08.222]                       if (inherits(cond, "message")) {
[16:21:08.222]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.222]                         if (muffled) 
[16:21:08.222]                           invokeRestart("muffleMessage")
[16:21:08.222]                       }
[16:21:08.222]                       else if (inherits(cond, "warning")) {
[16:21:08.222]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.222]                         if (muffled) 
[16:21:08.222]                           invokeRestart("muffleWarning")
[16:21:08.222]                       }
[16:21:08.222]                       else if (inherits(cond, "condition")) {
[16:21:08.222]                         if (!is.null(pattern)) {
[16:21:08.222]                           computeRestarts <- base::computeRestarts
[16:21:08.222]                           grepl <- base::grepl
[16:21:08.222]                           restarts <- computeRestarts(cond)
[16:21:08.222]                           for (restart in restarts) {
[16:21:08.222]                             name <- restart$name
[16:21:08.222]                             if (is.null(name)) 
[16:21:08.222]                               next
[16:21:08.222]                             if (!grepl(pattern, name)) 
[16:21:08.222]                               next
[16:21:08.222]                             invokeRestart(restart)
[16:21:08.222]                             muffled <- TRUE
[16:21:08.222]                             break
[16:21:08.222]                           }
[16:21:08.222]                         }
[16:21:08.222]                       }
[16:21:08.222]                       invisible(muffled)
[16:21:08.222]                     }
[16:21:08.222]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.222]                   }
[16:21:08.222]                 }
[16:21:08.222]             }
[16:21:08.222]         }))
[16:21:08.222]     }, error = function(ex) {
[16:21:08.222]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:08.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.222]                 ...future.rng), started = ...future.startTime, 
[16:21:08.222]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:08.222]             version = "1.8"), class = "FutureResult")
[16:21:08.222]     }, finally = {
[16:21:08.222]         if (!identical(...future.workdir, getwd())) 
[16:21:08.222]             setwd(...future.workdir)
[16:21:08.222]         {
[16:21:08.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:08.222]                 ...future.oldOptions$nwarnings <- NULL
[16:21:08.222]             }
[16:21:08.222]             base::options(...future.oldOptions)
[16:21:08.222]             if (.Platform$OS.type == "windows") {
[16:21:08.222]                 old_names <- names(...future.oldEnvVars)
[16:21:08.222]                 envs <- base::Sys.getenv()
[16:21:08.222]                 names <- names(envs)
[16:21:08.222]                 common <- intersect(names, old_names)
[16:21:08.222]                 added <- setdiff(names, old_names)
[16:21:08.222]                 removed <- setdiff(old_names, names)
[16:21:08.222]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:08.222]                   envs[common]]
[16:21:08.222]                 NAMES <- toupper(changed)
[16:21:08.222]                 args <- list()
[16:21:08.222]                 for (kk in seq_along(NAMES)) {
[16:21:08.222]                   name <- changed[[kk]]
[16:21:08.222]                   NAME <- NAMES[[kk]]
[16:21:08.222]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.222]                     next
[16:21:08.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.222]                 }
[16:21:08.222]                 NAMES <- toupper(added)
[16:21:08.222]                 for (kk in seq_along(NAMES)) {
[16:21:08.222]                   name <- added[[kk]]
[16:21:08.222]                   NAME <- NAMES[[kk]]
[16:21:08.222]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.222]                     next
[16:21:08.222]                   args[[name]] <- ""
[16:21:08.222]                 }
[16:21:08.222]                 NAMES <- toupper(removed)
[16:21:08.222]                 for (kk in seq_along(NAMES)) {
[16:21:08.222]                   name <- removed[[kk]]
[16:21:08.222]                   NAME <- NAMES[[kk]]
[16:21:08.222]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.222]                     next
[16:21:08.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.222]                 }
[16:21:08.222]                 if (length(args) > 0) 
[16:21:08.222]                   base::do.call(base::Sys.setenv, args = args)
[16:21:08.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:08.222]             }
[16:21:08.222]             else {
[16:21:08.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:08.222]             }
[16:21:08.222]             {
[16:21:08.222]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:08.222]                   0L) {
[16:21:08.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:08.222]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:08.222]                   base::options(opts)
[16:21:08.222]                 }
[16:21:08.222]                 {
[16:21:08.222]                   {
[16:21:08.222]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:08.222]                     NULL
[16:21:08.222]                   }
[16:21:08.222]                   options(future.plan = NULL)
[16:21:08.222]                   if (is.na(NA_character_)) 
[16:21:08.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:08.222]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:08.222]                     .init = FALSE)
[16:21:08.222]                 }
[16:21:08.222]             }
[16:21:08.222]         }
[16:21:08.222]     })
[16:21:08.222]     if (TRUE) {
[16:21:08.222]         base::sink(type = "output", split = FALSE)
[16:21:08.222]         if (TRUE) {
[16:21:08.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:08.222]         }
[16:21:08.222]         else {
[16:21:08.222]             ...future.result["stdout"] <- base::list(NULL)
[16:21:08.222]         }
[16:21:08.222]         base::close(...future.stdout)
[16:21:08.222]         ...future.stdout <- NULL
[16:21:08.222]     }
[16:21:08.222]     ...future.result$conditions <- ...future.conditions
[16:21:08.222]     ...future.result$finished <- base::Sys.time()
[16:21:08.222]     ...future.result
[16:21:08.222] }
[16:21:08.224] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:21:08.225] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[16:21:08.225] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[16:21:08.225] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:21:08.226] MultisessionFuture started
[16:21:08.226] - Launch lazy future ... done
[16:21:08.226] run() for ‘MultisessionFuture’ ... done
[16:21:08.226] result() for ClusterFuture ...
[16:21:08.226] receiveMessageFromWorker() for ClusterFuture ...
[16:21:08.226] - Validating connection of MultisessionFuture
[16:21:08.270] - received message: FutureResult
[16:21:08.271] - Received FutureResult
[16:21:08.271] - Erased future from FutureRegistry
[16:21:08.271] result() for ClusterFuture ...
[16:21:08.271] - result already collected: FutureResult
[16:21:08.271] result() for ClusterFuture ... done
[16:21:08.271] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:08.271] result() for ClusterFuture ... done
[16:21:08.271] result() for ClusterFuture ...
[16:21:08.271] - result already collected: FutureResult
[16:21:08.272] result() for ClusterFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:21:08.272] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:21:08.272] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:21:08.274] - globals found: [3] ‘{’, ‘<-’, ‘x’
[16:21:08.274] Searching for globals ... DONE
[16:21:08.274] Resolving globals: TRUE
[16:21:08.274] Resolving any globals that are futures ...
[16:21:08.274] - globals: [3] ‘{’, ‘<-’, ‘x’
[16:21:08.275] Resolving any globals that are futures ... DONE
[16:21:08.275] Resolving futures part of globals (recursively) ...
[16:21:08.275] resolve() on list ...
[16:21:08.275]  recursive: 99
[16:21:08.275]  length: 1
[16:21:08.275]  elements: ‘x’
[16:21:08.275]  length: 0 (resolved future 1)
[16:21:08.276] resolve() on list ... DONE
[16:21:08.276] - globals: [1] ‘x’
[16:21:08.276] Resolving futures part of globals (recursively) ... DONE
[16:21:08.276] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[16:21:08.276] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[16:21:08.276] - globals: [1] ‘x’
[16:21:08.277] 
[16:21:08.277] getGlobalsAndPackages() ... DONE
[16:21:08.277] run() for ‘Future’ ...
[16:21:08.277] - state: ‘created’
[16:21:08.277] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:08.292] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:08.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:08.292]   - Field: ‘node’
[16:21:08.292]   - Field: ‘label’
[16:21:08.292]   - Field: ‘local’
[16:21:08.293]   - Field: ‘owner’
[16:21:08.293]   - Field: ‘envir’
[16:21:08.293]   - Field: ‘workers’
[16:21:08.293]   - Field: ‘packages’
[16:21:08.293]   - Field: ‘gc’
[16:21:08.293]   - Field: ‘conditions’
[16:21:08.293]   - Field: ‘persistent’
[16:21:08.293]   - Field: ‘expr’
[16:21:08.293]   - Field: ‘uuid’
[16:21:08.293]   - Field: ‘seed’
[16:21:08.293]   - Field: ‘version’
[16:21:08.294]   - Field: ‘result’
[16:21:08.294]   - Field: ‘asynchronous’
[16:21:08.294]   - Field: ‘calls’
[16:21:08.294]   - Field: ‘globals’
[16:21:08.294]   - Field: ‘stdout’
[16:21:08.294]   - Field: ‘earlySignal’
[16:21:08.294]   - Field: ‘lazy’
[16:21:08.294]   - Field: ‘state’
[16:21:08.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:08.294] - Launch lazy future ...
[16:21:08.295] Packages needed by the future expression (n = 0): <none>
[16:21:08.295] Packages needed by future strategies (n = 0): <none>
[16:21:08.295] {
[16:21:08.295]     {
[16:21:08.295]         {
[16:21:08.295]             ...future.startTime <- base::Sys.time()
[16:21:08.295]             {
[16:21:08.295]                 {
[16:21:08.295]                   {
[16:21:08.295]                     {
[16:21:08.295]                       base::local({
[16:21:08.295]                         has_future <- base::requireNamespace("future", 
[16:21:08.295]                           quietly = TRUE)
[16:21:08.295]                         if (has_future) {
[16:21:08.295]                           ns <- base::getNamespace("future")
[16:21:08.295]                           version <- ns[[".package"]][["version"]]
[16:21:08.295]                           if (is.null(version)) 
[16:21:08.295]                             version <- utils::packageVersion("future")
[16:21:08.295]                         }
[16:21:08.295]                         else {
[16:21:08.295]                           version <- NULL
[16:21:08.295]                         }
[16:21:08.295]                         if (!has_future || version < "1.8.0") {
[16:21:08.295]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:08.295]                             "", base::R.version$version.string), 
[16:21:08.295]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:08.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:08.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:08.295]                               "release", "version")], collapse = " "), 
[16:21:08.295]                             hostname = base::Sys.info()[["nodename"]])
[16:21:08.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:08.295]                             info)
[16:21:08.295]                           info <- base::paste(info, collapse = "; ")
[16:21:08.295]                           if (!has_future) {
[16:21:08.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:08.295]                               info)
[16:21:08.295]                           }
[16:21:08.295]                           else {
[16:21:08.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:08.295]                               info, version)
[16:21:08.295]                           }
[16:21:08.295]                           base::stop(msg)
[16:21:08.295]                         }
[16:21:08.295]                       })
[16:21:08.295]                     }
[16:21:08.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:08.295]                     base::options(mc.cores = 1L)
[16:21:08.295]                   }
[16:21:08.295]                   ...future.strategy.old <- future::plan("list")
[16:21:08.295]                   options(future.plan = NULL)
[16:21:08.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:08.295]                 }
[16:21:08.295]                 ...future.workdir <- getwd()
[16:21:08.295]             }
[16:21:08.295]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:08.295]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:08.295]         }
[16:21:08.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:21:08.295]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:21:08.295]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:21:08.295]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:21:08.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:08.295]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:08.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:08.295]             base::names(...future.oldOptions))
[16:21:08.295]     }
[16:21:08.295]     if (FALSE) {
[16:21:08.295]     }
[16:21:08.295]     else {
[16:21:08.295]         if (TRUE) {
[16:21:08.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:08.295]                 open = "w")
[16:21:08.295]         }
[16:21:08.295]         else {
[16:21:08.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:08.295]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:08.295]         }
[16:21:08.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:08.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:08.295]             base::sink(type = "output", split = FALSE)
[16:21:08.295]             base::close(...future.stdout)
[16:21:08.295]         }, add = TRUE)
[16:21:08.295]     }
[16:21:08.295]     ...future.frame <- base::sys.nframe()
[16:21:08.295]     ...future.conditions <- base::list()
[16:21:08.295]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:08.295]     if (FALSE) {
[16:21:08.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:08.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:08.295]     }
[16:21:08.295]     ...future.result <- base::tryCatch({
[16:21:08.295]         base::withCallingHandlers({
[16:21:08.295]             ...future.value <- base::withVisible(base::local({
[16:21:08.295]                 ...future.makeSendCondition <- base::local({
[16:21:08.295]                   sendCondition <- NULL
[16:21:08.295]                   function(frame = 1L) {
[16:21:08.295]                     if (is.function(sendCondition)) 
[16:21:08.295]                       return(sendCondition)
[16:21:08.295]                     ns <- getNamespace("parallel")
[16:21:08.295]                     if (exists("sendData", mode = "function", 
[16:21:08.295]                       envir = ns)) {
[16:21:08.295]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:08.295]                         envir = ns)
[16:21:08.295]                       envir <- sys.frame(frame)
[16:21:08.295]                       master <- NULL
[16:21:08.295]                       while (!identical(envir, .GlobalEnv) && 
[16:21:08.295]                         !identical(envir, emptyenv())) {
[16:21:08.295]                         if (exists("master", mode = "list", envir = envir, 
[16:21:08.295]                           inherits = FALSE)) {
[16:21:08.295]                           master <- get("master", mode = "list", 
[16:21:08.295]                             envir = envir, inherits = FALSE)
[16:21:08.295]                           if (inherits(master, c("SOCKnode", 
[16:21:08.295]                             "SOCK0node"))) {
[16:21:08.295]                             sendCondition <<- function(cond) {
[16:21:08.295]                               data <- list(type = "VALUE", value = cond, 
[16:21:08.295]                                 success = TRUE)
[16:21:08.295]                               parallel_sendData(master, data)
[16:21:08.295]                             }
[16:21:08.295]                             return(sendCondition)
[16:21:08.295]                           }
[16:21:08.295]                         }
[16:21:08.295]                         frame <- frame + 1L
[16:21:08.295]                         envir <- sys.frame(frame)
[16:21:08.295]                       }
[16:21:08.295]                     }
[16:21:08.295]                     sendCondition <<- function(cond) NULL
[16:21:08.295]                   }
[16:21:08.295]                 })
[16:21:08.295]                 withCallingHandlers({
[16:21:08.295]                   {
[16:21:08.295]                     x <- x()
[16:21:08.295]                     x
[16:21:08.295]                   }
[16:21:08.295]                 }, immediateCondition = function(cond) {
[16:21:08.295]                   sendCondition <- ...future.makeSendCondition()
[16:21:08.295]                   sendCondition(cond)
[16:21:08.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.295]                   {
[16:21:08.295]                     inherits <- base::inherits
[16:21:08.295]                     invokeRestart <- base::invokeRestart
[16:21:08.295]                     is.null <- base::is.null
[16:21:08.295]                     muffled <- FALSE
[16:21:08.295]                     if (inherits(cond, "message")) {
[16:21:08.295]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:08.295]                       if (muffled) 
[16:21:08.295]                         invokeRestart("muffleMessage")
[16:21:08.295]                     }
[16:21:08.295]                     else if (inherits(cond, "warning")) {
[16:21:08.295]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:08.295]                       if (muffled) 
[16:21:08.295]                         invokeRestart("muffleWarning")
[16:21:08.295]                     }
[16:21:08.295]                     else if (inherits(cond, "condition")) {
[16:21:08.295]                       if (!is.null(pattern)) {
[16:21:08.295]                         computeRestarts <- base::computeRestarts
[16:21:08.295]                         grepl <- base::grepl
[16:21:08.295]                         restarts <- computeRestarts(cond)
[16:21:08.295]                         for (restart in restarts) {
[16:21:08.295]                           name <- restart$name
[16:21:08.295]                           if (is.null(name)) 
[16:21:08.295]                             next
[16:21:08.295]                           if (!grepl(pattern, name)) 
[16:21:08.295]                             next
[16:21:08.295]                           invokeRestart(restart)
[16:21:08.295]                           muffled <- TRUE
[16:21:08.295]                           break
[16:21:08.295]                         }
[16:21:08.295]                       }
[16:21:08.295]                     }
[16:21:08.295]                     invisible(muffled)
[16:21:08.295]                   }
[16:21:08.295]                   muffleCondition(cond)
[16:21:08.295]                 })
[16:21:08.295]             }))
[16:21:08.295]             future::FutureResult(value = ...future.value$value, 
[16:21:08.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.295]                   ...future.rng), globalenv = if (FALSE) 
[16:21:08.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:08.295]                     ...future.globalenv.names))
[16:21:08.295]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:08.295]         }, condition = base::local({
[16:21:08.295]             c <- base::c
[16:21:08.295]             inherits <- base::inherits
[16:21:08.295]             invokeRestart <- base::invokeRestart
[16:21:08.295]             length <- base::length
[16:21:08.295]             list <- base::list
[16:21:08.295]             seq.int <- base::seq.int
[16:21:08.295]             signalCondition <- base::signalCondition
[16:21:08.295]             sys.calls <- base::sys.calls
[16:21:08.295]             `[[` <- base::`[[`
[16:21:08.295]             `+` <- base::`+`
[16:21:08.295]             `<<-` <- base::`<<-`
[16:21:08.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:08.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:08.295]                   3L)]
[16:21:08.295]             }
[16:21:08.295]             function(cond) {
[16:21:08.295]                 is_error <- inherits(cond, "error")
[16:21:08.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:08.295]                   NULL)
[16:21:08.295]                 if (is_error) {
[16:21:08.295]                   sessionInformation <- function() {
[16:21:08.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:08.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:08.295]                       search = base::search(), system = base::Sys.info())
[16:21:08.295]                   }
[16:21:08.295]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:08.295]                     cond$call), session = sessionInformation(), 
[16:21:08.295]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:08.295]                   signalCondition(cond)
[16:21:08.295]                 }
[16:21:08.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:08.295]                 "immediateCondition"))) {
[16:21:08.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:08.295]                   ...future.conditions[[length(...future.conditions) + 
[16:21:08.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:08.295]                   if (TRUE && !signal) {
[16:21:08.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.295]                     {
[16:21:08.295]                       inherits <- base::inherits
[16:21:08.295]                       invokeRestart <- base::invokeRestart
[16:21:08.295]                       is.null <- base::is.null
[16:21:08.295]                       muffled <- FALSE
[16:21:08.295]                       if (inherits(cond, "message")) {
[16:21:08.295]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.295]                         if (muffled) 
[16:21:08.295]                           invokeRestart("muffleMessage")
[16:21:08.295]                       }
[16:21:08.295]                       else if (inherits(cond, "warning")) {
[16:21:08.295]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.295]                         if (muffled) 
[16:21:08.295]                           invokeRestart("muffleWarning")
[16:21:08.295]                       }
[16:21:08.295]                       else if (inherits(cond, "condition")) {
[16:21:08.295]                         if (!is.null(pattern)) {
[16:21:08.295]                           computeRestarts <- base::computeRestarts
[16:21:08.295]                           grepl <- base::grepl
[16:21:08.295]                           restarts <- computeRestarts(cond)
[16:21:08.295]                           for (restart in restarts) {
[16:21:08.295]                             name <- restart$name
[16:21:08.295]                             if (is.null(name)) 
[16:21:08.295]                               next
[16:21:08.295]                             if (!grepl(pattern, name)) 
[16:21:08.295]                               next
[16:21:08.295]                             invokeRestart(restart)
[16:21:08.295]                             muffled <- TRUE
[16:21:08.295]                             break
[16:21:08.295]                           }
[16:21:08.295]                         }
[16:21:08.295]                       }
[16:21:08.295]                       invisible(muffled)
[16:21:08.295]                     }
[16:21:08.295]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.295]                   }
[16:21:08.295]                 }
[16:21:08.295]                 else {
[16:21:08.295]                   if (TRUE) {
[16:21:08.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:08.295]                     {
[16:21:08.295]                       inherits <- base::inherits
[16:21:08.295]                       invokeRestart <- base::invokeRestart
[16:21:08.295]                       is.null <- base::is.null
[16:21:08.295]                       muffled <- FALSE
[16:21:08.295]                       if (inherits(cond, "message")) {
[16:21:08.295]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:08.295]                         if (muffled) 
[16:21:08.295]                           invokeRestart("muffleMessage")
[16:21:08.295]                       }
[16:21:08.295]                       else if (inherits(cond, "warning")) {
[16:21:08.295]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:08.295]                         if (muffled) 
[16:21:08.295]                           invokeRestart("muffleWarning")
[16:21:08.295]                       }
[16:21:08.295]                       else if (inherits(cond, "condition")) {
[16:21:08.295]                         if (!is.null(pattern)) {
[16:21:08.295]                           computeRestarts <- base::computeRestarts
[16:21:08.295]                           grepl <- base::grepl
[16:21:08.295]                           restarts <- computeRestarts(cond)
[16:21:08.295]                           for (restart in restarts) {
[16:21:08.295]                             name <- restart$name
[16:21:08.295]                             if (is.null(name)) 
[16:21:08.295]                               next
[16:21:08.295]                             if (!grepl(pattern, name)) 
[16:21:08.295]                               next
[16:21:08.295]                             invokeRestart(restart)
[16:21:08.295]                             muffled <- TRUE
[16:21:08.295]                             break
[16:21:08.295]                           }
[16:21:08.295]                         }
[16:21:08.295]                       }
[16:21:08.295]                       invisible(muffled)
[16:21:08.295]                     }
[16:21:08.295]                     muffleCondition(cond, pattern = "^muffle")
[16:21:08.295]                   }
[16:21:08.295]                 }
[16:21:08.295]             }
[16:21:08.295]         }))
[16:21:08.295]     }, error = function(ex) {
[16:21:08.295]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:08.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:08.295]                 ...future.rng), started = ...future.startTime, 
[16:21:08.295]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:08.295]             version = "1.8"), class = "FutureResult")
[16:21:08.295]     }, finally = {
[16:21:08.295]         if (!identical(...future.workdir, getwd())) 
[16:21:08.295]             setwd(...future.workdir)
[16:21:08.295]         {
[16:21:08.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:08.295]                 ...future.oldOptions$nwarnings <- NULL
[16:21:08.295]             }
[16:21:08.295]             base::options(...future.oldOptions)
[16:21:08.295]             if (.Platform$OS.type == "windows") {
[16:21:08.295]                 old_names <- names(...future.oldEnvVars)
[16:21:08.295]                 envs <- base::Sys.getenv()
[16:21:08.295]                 names <- names(envs)
[16:21:08.295]                 common <- intersect(names, old_names)
[16:21:08.295]                 added <- setdiff(names, old_names)
[16:21:08.295]                 removed <- setdiff(old_names, names)
[16:21:08.295]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:08.295]                   envs[common]]
[16:21:08.295]                 NAMES <- toupper(changed)
[16:21:08.295]                 args <- list()
[16:21:08.295]                 for (kk in seq_along(NAMES)) {
[16:21:08.295]                   name <- changed[[kk]]
[16:21:08.295]                   NAME <- NAMES[[kk]]
[16:21:08.295]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.295]                     next
[16:21:08.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.295]                 }
[16:21:08.295]                 NAMES <- toupper(added)
[16:21:08.295]                 for (kk in seq_along(NAMES)) {
[16:21:08.295]                   name <- added[[kk]]
[16:21:08.295]                   NAME <- NAMES[[kk]]
[16:21:08.295]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.295]                     next
[16:21:08.295]                   args[[name]] <- ""
[16:21:08.295]                 }
[16:21:08.295]                 NAMES <- toupper(removed)
[16:21:08.295]                 for (kk in seq_along(NAMES)) {
[16:21:08.295]                   name <- removed[[kk]]
[16:21:08.295]                   NAME <- NAMES[[kk]]
[16:21:08.295]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:08.295]                     next
[16:21:08.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:08.295]                 }
[16:21:08.295]                 if (length(args) > 0) 
[16:21:08.295]                   base::do.call(base::Sys.setenv, args = args)
[16:21:08.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:08.295]             }
[16:21:08.295]             else {
[16:21:08.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:08.295]             }
[16:21:08.295]             {
[16:21:08.295]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:08.295]                   0L) {
[16:21:08.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:08.295]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:08.295]                   base::options(opts)
[16:21:08.295]                 }
[16:21:08.295]                 {
[16:21:08.295]                   {
[16:21:08.295]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:08.295]                     NULL
[16:21:08.295]                   }
[16:21:08.295]                   options(future.plan = NULL)
[16:21:08.295]                   if (is.na(NA_character_)) 
[16:21:08.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:08.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:08.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:08.295]                     .init = FALSE)
[16:21:08.295]                 }
[16:21:08.295]             }
[16:21:08.295]         }
[16:21:08.295]     })
[16:21:08.295]     if (TRUE) {
[16:21:08.295]         base::sink(type = "output", split = FALSE)
[16:21:08.295]         if (TRUE) {
[16:21:08.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:08.295]         }
[16:21:08.295]         else {
[16:21:08.295]             ...future.result["stdout"] <- base::list(NULL)
[16:21:08.295]         }
[16:21:08.295]         base::close(...future.stdout)
[16:21:08.295]         ...future.stdout <- NULL
[16:21:08.295]     }
[16:21:08.295]     ...future.result$conditions <- ...future.conditions
[16:21:08.295]     ...future.result$finished <- base::Sys.time()
[16:21:08.295]     ...future.result
[16:21:08.295] }
[16:21:08.298] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[16:21:08.298] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[16:21:08.299] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[16:21:08.299] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[16:21:08.299] MultisessionFuture started
[16:21:08.299] - Launch lazy future ... done
[16:21:08.299] run() for ‘MultisessionFuture’ ... done
[16:21:08.299] result() for ClusterFuture ...
[16:21:08.300] receiveMessageFromWorker() for ClusterFuture ...
[16:21:08.300] - Validating connection of MultisessionFuture
[16:21:08.342] - received message: FutureResult
[16:21:08.342] - Received FutureResult
[16:21:08.342] - Erased future from FutureRegistry
[16:21:08.343] result() for ClusterFuture ...
[16:21:08.343] - result already collected: FutureResult
[16:21:08.343] result() for ClusterFuture ... done
[16:21:08.343] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:08.343] result() for ClusterFuture ... done
[16:21:08.343] result() for ClusterFuture ...
[16:21:08.343] - result already collected: FutureResult
[16:21:08.343] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[16:21:08.344] plan(): Setting new future strategy stack:
[16:21:08.344] List of future strategies:
[16:21:08.344] 1. FutureStrategy:
[16:21:08.344]    - args: function (..., envir = parent.frame())
[16:21:08.344]    - tweaked: FALSE
[16:21:08.344]    - call: future::plan(oplan)
[16:21:08.345] plan(): nbrOfWorkers() = 1
> 
